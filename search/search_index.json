{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Sitio web con los apuntes de teor\u00eda, seminarios y pr\u00e1cticas de la asignatura \"Lenguajes y paradigmas de programaci\u00f3n\". Despliega el men\u00fa de la izquierda para consultar los apuntes. Otros enlaces: Ficha de la asignatura Plataforma docente Moodle Repositorio GitHub de estos apuntes","title":"Home"},{"location":"practicas/practica01/practica01.html","text":"Pr\u00e1ctica 1: Introducci\u00f3n a Scheme Importante Antes de empezar esta pr\u00e1ctica debes haber terminado todos los ejercicios del seminario de Scheme. Entrega de la pr\u00e1ctica Para entregar la pr\u00e1ctica debes subir a Moodle el fichero practica01.rkt con una cabecera inicial con tu nombre y apellidos, y las soluciones de cada ejercicio separadas por comentarios. Cada soluci\u00f3n debe incluir: La definici\u00f3n de las funciones que resuelven el ejercicio. Un conjunto de pruebas que comprueben su funcionamiento, y el de funciones auxiliares que hayamos definido, utilizando el API SchemeUnit. Por ejemplo, supongamos que el primer ejercicio de la pr\u00e1ctica 1 sea implementar la funci\u00f3n suma-cuadrados que recibe dos n\u00fameros y devuelve la suma de sus cuadrados y se proponen en el enunciado los siguientes ejemplos: 1 2 ( suma-cuadrados 10 10 ) ; \u21d2 200 ( suma-cuadrados -2 9 ) ; \u21d2 85 La soluci\u00f3n se deber\u00eda entregar de la siguiente forma: practica01.rkt : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 ;; Jos\u00e9 Fernandez Mu\u00f1oz # lang r6rs ( import ( rnrs ) ( schemeunit )) ;; ;; Ejercicio 1: suma-cuadrados ;; ;; Funci\u00f3n auxiliar cuadrado ( define ( cuadrado x ) ( * x x )) ( display Probando cuadrado \\n ) ( check-equal? ( cuadrado 2 ) 4 ) ( check-equal? ( cuadrado 10 ) 100 ) ( check-equal? ( cuadrado -2 ) 4 ) ;; Funci\u00f3n principal suma-cuadrados ( define ( suma-cuadrados x y ) ( + ( * x x ) ( * y y ))) ( display Probando suma-cuadrados \\n ) ( check-equal? ( suma-cuadrados 10 10 ) 200 ) ( check-equal? ( suma-cuadrados -2 9 ) 85 ) ( check-equal? ( suma-cuadrados 0.5 9 ) 81.25 ) ;; ;; Ejercicio 2: ;; ... En los casos de prueba se deben incluir los ejemplos del enunciado del ejercicio y alguno m\u00e1s que compruebe que la implementaci\u00f3n funciona correctamente. Ejercicios Ejercicio 1 a) Implementa la funci\u00f3n (binario-a-decimal b3 b2 b1 b0) que reciba 4 bits que representan un n\u00famero en binario y devuelva el n\u00famero decimal equivalente. 1 2 3 ( binario-a-decimal 1 1 1 1 ) ; \u21d2 15 ( binario-a-decimal 0 1 1 0 ) ; \u21d2 6 ( binario-a-decimal 0 0 1 0 ) ; \u21d2 2 Nota : recuerda que para realizar esta conversi\u00f3n, se utiliza la siguiente f\u00f3rmula: 1 n = b3 * 2\u02c63 + b2 * 2\u02c62 + b1 * 2\u02c61 + b0 * 2\u02c60 Para la implementaci\u00f3n de la expresi\u00f3n debes utilizar la funci\u00f3n expt . b) Implementa la funci\u00f3n (binario-a-hexadecimal b3 b2 b1 b0) que reciba 4 bits de un n\u00famero representado en binario y devuelva el car\u00e1cter correspondiente a su representaci\u00f3n en hexadecimal. 1 2 3 ( binario-a-hexadecimal 1 1 1 1 ) ; \u21d2 #\\F ( binario-a-hexadecimal 0 1 1 0 ) ; \u21d2 #\\6 ( binario-a-hexadecimal 1 0 1 0 ) ; \u21d2 #\\A Nota : para realizar esta conversi\u00f3n, como paso intermedio debes pasar primero el n\u00famero binario a su representaci\u00f3n decimal (utilizando la funci\u00f3n definida en el apartado anterior) y despu\u00e9s a su correspondiente hexadecimal. Recuerda que la representaci\u00f3n hexadecimal de los n\u00fameros decimales del 0 al 9 es el car\u00e1cter correspondiente a ese n\u00famero, y que el n\u00famero decimal 10 se representa con el car\u00e1cter A, el 11 con el B, y as\u00ed sucesivamente hasta el 15 que es el F en hexadecimal. Para la implementaci\u00f3n de esta funci\u00f3n auxiliar que pasa de decimal a hexadecimal debes usar las funciones integer- char y char- integer . En la funci\u00f3n char- ingeger los caracteres consecutivos est\u00e1n asociados con n\u00fameros consecutivos. Por ejemplo, el entero correspondiente al car\u00e1cter #\\A es uno menos que el correspondiente al car\u00e1cter #\\B . Los caracteres de n\u00fameros y los de letras no son consecutivos. Ejercicio 2 Implementa la funci\u00f3n (mayor-de-tres n1 n2 n3) que reciba tres n\u00fameros como argumento y devuelva el mayor de los tres, intentando que el n\u00famero de condiciones sea m\u00ednima. No debes utilizar la funci\u00f3n max . Implementa dos versiones de la funci\u00f3n: versi\u00f3n 1: usando la forma especial if versi\u00f3n 2 (ll\u00e1mala mayor-de-tres-v2 ): definiendo una funci\u00f3n auxiliar (mayor x y) que devuelva el mayor de dos n\u00fameros (deber\u00e1s usar tambi\u00e9n la forma especial if para implementarla) y construyendo la funci\u00f3n mayor-de-tres-v2 como una composici\u00f3n de llamadas a esta funci\u00f3n auxiliar. 1 2 ( mayor-de-tres 2 8 1 ) ;; \u21d2 8 ( mayor-de-tres-v2 3 0 3 ) ;; \u21d2 3 Ejercicio 3 Supongamos las definiciones 1 2 3 4 5 ( define ( f x y ) ( + ( * 2 x ) y )) ( define ( cuadrado x ) ( * x x )) Realiza la evaluaci\u00f3n paso a paso de la siguiente expresi\u00f3n 1 ( f ( cuadrado ( + 2 1 )) ( + 1 1 )) mediante el modelo de sustituci\u00f3n , utilizando tanto el orden aplicativo y como el orden normal . Escribe la soluci\u00f3n entre comentarios en el propio fichero .rkt de la pr\u00e1ctica. Ejercicio 4 Implementa la funci\u00f3n (tirada-ganadora t1 t2) que reciba 2 parejas como argumento, donde cada pareja representa una tirada con 2 dados (contiene dos n\u00fameros). La funci\u00f3n debe determinar qu\u00e9 tirada es la ganadora, teniendo en cuenta que ser\u00e1 aquella cuya suma de sus 2 dados est\u00e9 m\u00e1s pr\u00f3xima al n\u00famero 7. La funci\u00f3n devolver\u00e1 1 si t1 es la ganadora, 2 si t2 es la ganadora o bien 0 si hay un empate. Este \u00faltimo caso se producir\u00e1 cuando la diferencia con 7 de ambas tiradas es la misma. 1 2 3 ( tirada-ganadora ( cons 1 3 ) ( cons 1 6 )) ; \u21d2 2 ( tirada-ganadora ( cons 1 5 ) ( cons 2 2 )) ; \u21d2 1 ( tirada-ganadora ( cons 6 2 ) ( cons 3 3 )) ; \u21d2 0 Ejercicio 5 Supongamos que estamos implementando un juego de guerra de barcos en el que los barcos est\u00e1n situados en coordenadas del plano definidas por la posici\u00f3n x y la posici\u00f3n y , ambos n\u00fameros reales ( metros ). Cada barco puede lanzar un torpedo a otro barco con una velocidad determinada ( v , en km/h ). El torpedo tiene combustible, y seguir\u00e1 movi\u00e9ndose hasta que se termine. La distancia a la que eso sucede la denominamos el alcance del torpedo (ver la siguiente figura): Cuanto m\u00e1s alta es la velocidad del torpedo, antes termina su combustible. En concreto, el tiempo de terminaci\u00f3n del combustible ( t , en segundos ) depende de la velocidad (en km/h ) seg\u00fan la siguiente expresi\u00f3n: 1 t= 50000 / v^2 Recuerda que conociendo la velocidad y el tiempo que est\u00e1 movi\u00e9ndose un objeto podemos calcular el espacio recorrido con la siguiente expresi\u00f3n: 1 e = v * t Esto es, multiplicando la velocidad por el tiempo resulta el espacio en recorrido. Las unidades de la velocidad y el tiempo deben ser compatibles . Esto es, si v est\u00e1 en m/s, t deber\u00e1 estar en segundos y el espacio reorrido resultar\u00e1 en metros. Dadas todas estas condiciones, debes programar en Scheme la funci\u00f3n 1 ( dentro-alcance? x1 y1 x2 y2 v ) que tome como par\u00e1metros las coordenadas x1 , y1 del barco 1 que lanza el torpedo (en metros ), x2 , y2 del barco 2 al que se le lanza (en metros ) y v la velocidad del torpedo (en km/h ). La funci\u00f3n debe comprobar si el barco 2 est\u00e1 dentro del alcance del torpedo, tal y como lo hemos definido previamente y devolver el booleano correspondiente. Debes modularizar la implementaci\u00f3n, creando las funciones auxiliares que necesites para que el c\u00f3digo sea legible y auto-documentado (los nombres de las funciones y los par\u00e1metros deben ser lo m\u00e1s descriptivos posibles). Ejemplos: 1 2 (dentro-alcance? 0 0 500 500 30) ; \u21d2 #f (dentro-alcance? 100 200 500 500 20) ; \u21d2 #t Ejercicio 6 Define la funci\u00f3n tipo-triangulo que recibe como par\u00e1metro las coordenadas en el plano de los v\u00e9rtices de un tri\u00e1ngulo representados con parejas. La funci\u00f3n devuelve un string con el tipo de tri\u00e1ngulo correspondiente: equil\u00e1tero, is\u00f3sceles o escaleno. Recuerda que un tri\u00e1ngulo equil\u00e1tero es aquel cuyos tres lados tienen la misma longitud, el is\u00f3sceles el que tiene dos lados iguales y el escaleno el que todos sus lados son diferentes. Ejemplos: 1 2 3 ( tipo-triangulo ( cons 1 1 ) ( cons 1 6 ) ( cons 6 1 )) ; \u21d2 isosceles ( tipo-triangulo ( cons -2 3 ) ( cons 2 6 ) ( cons 5 3 )) ; \u21d2 escaleno ( tipo-triangulo ( cons -3 0 ) ( cons 3 0 ) ( cons 0 5.1961 ) ; \u21d2 equilatero Nota : Para comparar dos n\u00fameros reales debemos comprobar si la resta entre ambos es menor que una constante epsilon que hemos definido. Por ejemplo, epsilon puede valer 0.0001. Puedes usar la siguiente funci\u00f3n auxiliar: 1 2 3 4 ( define epsilon 0.0001 ) ( define ( iguales-reales? x y ) ( ( abs ( - x y )) epsilon )) Ejercicio 7 Define la funci\u00f3n calculadora que recibe una lista como par\u00e1metro. La lista contiene tres elementos: el primero es un car\u00e1cter ( + , - , * o / ) que indica un operador y los dos siguientes elementos corresponden a los operandos. La funci\u00f3n realiza la operaci\u00f3n y devuelve el resultado. Ejemplos: 1 2 3 4 ( calculadora ( list #\\+ 2 3 )) ; \u21d2 5 ( calculadora ( list # \\ * 3 4 )) ; \u21d2 12 ( calculadora ( list #\\- 7 4 )) ; \u21d2 3 ( calculadora ( list #\\/ 6 3 )) ; \u21d2 2 Lenguajes y Paradigmas de Programaci\u00f3n, curso 2018-19 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Domingo Gallardo, Cristina Pomares, Antonio Bot\u00eda, Francisco Mart\u00ednez","title":"Pr\u00e1ctica 1: Introducci\u00f3n a Scheme"},{"location":"practicas/practica01/practica01.html#practica-1-introduccion-a-scheme","text":"Importante Antes de empezar esta pr\u00e1ctica debes haber terminado todos los ejercicios del seminario de Scheme.","title":"Pr\u00e1ctica 1: Introducci\u00f3n a Scheme"},{"location":"practicas/practica01/practica01.html#entrega-de-la-practica","text":"Para entregar la pr\u00e1ctica debes subir a Moodle el fichero practica01.rkt con una cabecera inicial con tu nombre y apellidos, y las soluciones de cada ejercicio separadas por comentarios. Cada soluci\u00f3n debe incluir: La definici\u00f3n de las funciones que resuelven el ejercicio. Un conjunto de pruebas que comprueben su funcionamiento, y el de funciones auxiliares que hayamos definido, utilizando el API SchemeUnit. Por ejemplo, supongamos que el primer ejercicio de la pr\u00e1ctica 1 sea implementar la funci\u00f3n suma-cuadrados que recibe dos n\u00fameros y devuelve la suma de sus cuadrados y se proponen en el enunciado los siguientes ejemplos: 1 2 ( suma-cuadrados 10 10 ) ; \u21d2 200 ( suma-cuadrados -2 9 ) ; \u21d2 85 La soluci\u00f3n se deber\u00eda entregar de la siguiente forma: practica01.rkt : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 ;; Jos\u00e9 Fernandez Mu\u00f1oz # lang r6rs ( import ( rnrs ) ( schemeunit )) ;; ;; Ejercicio 1: suma-cuadrados ;; ;; Funci\u00f3n auxiliar cuadrado ( define ( cuadrado x ) ( * x x )) ( display Probando cuadrado \\n ) ( check-equal? ( cuadrado 2 ) 4 ) ( check-equal? ( cuadrado 10 ) 100 ) ( check-equal? ( cuadrado -2 ) 4 ) ;; Funci\u00f3n principal suma-cuadrados ( define ( suma-cuadrados x y ) ( + ( * x x ) ( * y y ))) ( display Probando suma-cuadrados \\n ) ( check-equal? ( suma-cuadrados 10 10 ) 200 ) ( check-equal? ( suma-cuadrados -2 9 ) 85 ) ( check-equal? ( suma-cuadrados 0.5 9 ) 81.25 ) ;; ;; Ejercicio 2: ;; ... En los casos de prueba se deben incluir los ejemplos del enunciado del ejercicio y alguno m\u00e1s que compruebe que la implementaci\u00f3n funciona correctamente.","title":"Entrega de la pr\u00e1ctica"},{"location":"practicas/practica01/practica01.html#ejercicios","text":"","title":"Ejercicios"},{"location":"practicas/practica01/practica01.html#ejercicio-1","text":"a) Implementa la funci\u00f3n (binario-a-decimal b3 b2 b1 b0) que reciba 4 bits que representan un n\u00famero en binario y devuelva el n\u00famero decimal equivalente. 1 2 3 ( binario-a-decimal 1 1 1 1 ) ; \u21d2 15 ( binario-a-decimal 0 1 1 0 ) ; \u21d2 6 ( binario-a-decimal 0 0 1 0 ) ; \u21d2 2 Nota : recuerda que para realizar esta conversi\u00f3n, se utiliza la siguiente f\u00f3rmula: 1 n = b3 * 2\u02c63 + b2 * 2\u02c62 + b1 * 2\u02c61 + b0 * 2\u02c60 Para la implementaci\u00f3n de la expresi\u00f3n debes utilizar la funci\u00f3n expt . b) Implementa la funci\u00f3n (binario-a-hexadecimal b3 b2 b1 b0) que reciba 4 bits de un n\u00famero representado en binario y devuelva el car\u00e1cter correspondiente a su representaci\u00f3n en hexadecimal. 1 2 3 ( binario-a-hexadecimal 1 1 1 1 ) ; \u21d2 #\\F ( binario-a-hexadecimal 0 1 1 0 ) ; \u21d2 #\\6 ( binario-a-hexadecimal 1 0 1 0 ) ; \u21d2 #\\A Nota : para realizar esta conversi\u00f3n, como paso intermedio debes pasar primero el n\u00famero binario a su representaci\u00f3n decimal (utilizando la funci\u00f3n definida en el apartado anterior) y despu\u00e9s a su correspondiente hexadecimal. Recuerda que la representaci\u00f3n hexadecimal de los n\u00fameros decimales del 0 al 9 es el car\u00e1cter correspondiente a ese n\u00famero, y que el n\u00famero decimal 10 se representa con el car\u00e1cter A, el 11 con el B, y as\u00ed sucesivamente hasta el 15 que es el F en hexadecimal. Para la implementaci\u00f3n de esta funci\u00f3n auxiliar que pasa de decimal a hexadecimal debes usar las funciones integer- char y char- integer . En la funci\u00f3n char- ingeger los caracteres consecutivos est\u00e1n asociados con n\u00fameros consecutivos. Por ejemplo, el entero correspondiente al car\u00e1cter #\\A es uno menos que el correspondiente al car\u00e1cter #\\B . Los caracteres de n\u00fameros y los de letras no son consecutivos.","title":"Ejercicio 1"},{"location":"practicas/practica01/practica01.html#ejercicio-2","text":"Implementa la funci\u00f3n (mayor-de-tres n1 n2 n3) que reciba tres n\u00fameros como argumento y devuelva el mayor de los tres, intentando que el n\u00famero de condiciones sea m\u00ednima. No debes utilizar la funci\u00f3n max . Implementa dos versiones de la funci\u00f3n: versi\u00f3n 1: usando la forma especial if versi\u00f3n 2 (ll\u00e1mala mayor-de-tres-v2 ): definiendo una funci\u00f3n auxiliar (mayor x y) que devuelva el mayor de dos n\u00fameros (deber\u00e1s usar tambi\u00e9n la forma especial if para implementarla) y construyendo la funci\u00f3n mayor-de-tres-v2 como una composici\u00f3n de llamadas a esta funci\u00f3n auxiliar. 1 2 ( mayor-de-tres 2 8 1 ) ;; \u21d2 8 ( mayor-de-tres-v2 3 0 3 ) ;; \u21d2 3","title":"Ejercicio 2"},{"location":"practicas/practica01/practica01.html#ejercicio-3","text":"Supongamos las definiciones 1 2 3 4 5 ( define ( f x y ) ( + ( * 2 x ) y )) ( define ( cuadrado x ) ( * x x )) Realiza la evaluaci\u00f3n paso a paso de la siguiente expresi\u00f3n 1 ( f ( cuadrado ( + 2 1 )) ( + 1 1 )) mediante el modelo de sustituci\u00f3n , utilizando tanto el orden aplicativo y como el orden normal . Escribe la soluci\u00f3n entre comentarios en el propio fichero .rkt de la pr\u00e1ctica.","title":"Ejercicio 3"},{"location":"practicas/practica01/practica01.html#ejercicio-4","text":"Implementa la funci\u00f3n (tirada-ganadora t1 t2) que reciba 2 parejas como argumento, donde cada pareja representa una tirada con 2 dados (contiene dos n\u00fameros). La funci\u00f3n debe determinar qu\u00e9 tirada es la ganadora, teniendo en cuenta que ser\u00e1 aquella cuya suma de sus 2 dados est\u00e9 m\u00e1s pr\u00f3xima al n\u00famero 7. La funci\u00f3n devolver\u00e1 1 si t1 es la ganadora, 2 si t2 es la ganadora o bien 0 si hay un empate. Este \u00faltimo caso se producir\u00e1 cuando la diferencia con 7 de ambas tiradas es la misma. 1 2 3 ( tirada-ganadora ( cons 1 3 ) ( cons 1 6 )) ; \u21d2 2 ( tirada-ganadora ( cons 1 5 ) ( cons 2 2 )) ; \u21d2 1 ( tirada-ganadora ( cons 6 2 ) ( cons 3 3 )) ; \u21d2 0","title":"Ejercicio 4"},{"location":"practicas/practica01/practica01.html#ejercicio-5","text":"Supongamos que estamos implementando un juego de guerra de barcos en el que los barcos est\u00e1n situados en coordenadas del plano definidas por la posici\u00f3n x y la posici\u00f3n y , ambos n\u00fameros reales ( metros ). Cada barco puede lanzar un torpedo a otro barco con una velocidad determinada ( v , en km/h ). El torpedo tiene combustible, y seguir\u00e1 movi\u00e9ndose hasta que se termine. La distancia a la que eso sucede la denominamos el alcance del torpedo (ver la siguiente figura): Cuanto m\u00e1s alta es la velocidad del torpedo, antes termina su combustible. En concreto, el tiempo de terminaci\u00f3n del combustible ( t , en segundos ) depende de la velocidad (en km/h ) seg\u00fan la siguiente expresi\u00f3n: 1 t= 50000 / v^2 Recuerda que conociendo la velocidad y el tiempo que est\u00e1 movi\u00e9ndose un objeto podemos calcular el espacio recorrido con la siguiente expresi\u00f3n: 1 e = v * t Esto es, multiplicando la velocidad por el tiempo resulta el espacio en recorrido. Las unidades de la velocidad y el tiempo deben ser compatibles . Esto es, si v est\u00e1 en m/s, t deber\u00e1 estar en segundos y el espacio reorrido resultar\u00e1 en metros. Dadas todas estas condiciones, debes programar en Scheme la funci\u00f3n 1 ( dentro-alcance? x1 y1 x2 y2 v ) que tome como par\u00e1metros las coordenadas x1 , y1 del barco 1 que lanza el torpedo (en metros ), x2 , y2 del barco 2 al que se le lanza (en metros ) y v la velocidad del torpedo (en km/h ). La funci\u00f3n debe comprobar si el barco 2 est\u00e1 dentro del alcance del torpedo, tal y como lo hemos definido previamente y devolver el booleano correspondiente. Debes modularizar la implementaci\u00f3n, creando las funciones auxiliares que necesites para que el c\u00f3digo sea legible y auto-documentado (los nombres de las funciones y los par\u00e1metros deben ser lo m\u00e1s descriptivos posibles). Ejemplos: 1 2 (dentro-alcance? 0 0 500 500 30) ; \u21d2 #f (dentro-alcance? 100 200 500 500 20) ; \u21d2 #t","title":"Ejercicio 5"},{"location":"practicas/practica01/practica01.html#ejercicio-6","text":"Define la funci\u00f3n tipo-triangulo que recibe como par\u00e1metro las coordenadas en el plano de los v\u00e9rtices de un tri\u00e1ngulo representados con parejas. La funci\u00f3n devuelve un string con el tipo de tri\u00e1ngulo correspondiente: equil\u00e1tero, is\u00f3sceles o escaleno. Recuerda que un tri\u00e1ngulo equil\u00e1tero es aquel cuyos tres lados tienen la misma longitud, el is\u00f3sceles el que tiene dos lados iguales y el escaleno el que todos sus lados son diferentes. Ejemplos: 1 2 3 ( tipo-triangulo ( cons 1 1 ) ( cons 1 6 ) ( cons 6 1 )) ; \u21d2 isosceles ( tipo-triangulo ( cons -2 3 ) ( cons 2 6 ) ( cons 5 3 )) ; \u21d2 escaleno ( tipo-triangulo ( cons -3 0 ) ( cons 3 0 ) ( cons 0 5.1961 ) ; \u21d2 equilatero Nota : Para comparar dos n\u00fameros reales debemos comprobar si la resta entre ambos es menor que una constante epsilon que hemos definido. Por ejemplo, epsilon puede valer 0.0001. Puedes usar la siguiente funci\u00f3n auxiliar: 1 2 3 4 ( define epsilon 0.0001 ) ( define ( iguales-reales? x y ) ( ( abs ( - x y )) epsilon ))","title":"Ejercicio 6"},{"location":"practicas/practica01/practica01.html#ejercicio-7","text":"Define la funci\u00f3n calculadora que recibe una lista como par\u00e1metro. La lista contiene tres elementos: el primero es un car\u00e1cter ( + , - , * o / ) que indica un operador y los dos siguientes elementos corresponden a los operandos. La funci\u00f3n realiza la operaci\u00f3n y devuelve el resultado. Ejemplos: 1 2 3 4 ( calculadora ( list #\\+ 2 3 )) ; \u21d2 5 ( calculadora ( list # \\ * 3 4 )) ; \u21d2 12 ( calculadora ( list #\\- 7 4 )) ; \u21d2 3 ( calculadora ( list #\\/ 6 3 )) ; \u21d2 2 Lenguajes y Paradigmas de Programaci\u00f3n, curso 2018-19 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Domingo Gallardo, Cristina Pomares, Antonio Bot\u00eda, Francisco Mart\u00ednez","title":"Ejercicio 7"},{"location":"practicas/practica02/practica02.html","text":"Pr\u00e1ctica 2: Programaci\u00f3n funcional en Scheme Entrega de la pr\u00e1ctica Para entregar la pr\u00e1ctica debes subir a Moodle el fichero practica02.rkt con una cabecera inicial con tu nombre y apellidos, y las soluciones de cada ejercicio separadas por comentarios. Cada soluci\u00f3n debe incluir: La definici\u00f3n de las funciones que resuelven el ejercicio. Un conjunto de pruebas que comprueben su funcionamiento utilizando la librer\u00eda schemeunit . Ejercicios Ejercicio 1 Implementa la funci\u00f3n recursiva (m\u00e1ximo lista) que recibe una lista con n\u00fameros como argumento y devuelve el mayor n\u00famero de la lista. Suponemos listas de 1 o m\u00e1s elementos. Para la implementaci\u00f3n debes usar la funci\u00f3n mayor definida en la pr\u00e1ctica anterior. Pista : Podemos expresar el caso general de la recursi\u00f3n de la siguiente forma: El m\u00e1ximo de los elementos de una lista es el mayor entre el primer elemento de la lista y el m\u00e1ximo del resto de la lista. Ejemplos: 1 2 ( maximo ( 9 8 6 4 3 )) ; \u21d2 9 ( maximo ( 1 -1 3 6 4 )) ; \u21d2 6 Ejercicio 2 a) Implementa el predicado recursivo (pertenece? elem lista) que reciba un dato y una lista y comprueba si el elemento pertenece a la lista. 1 2 3 ( pertenece? a ( b c d e )) ; \u21d2 #f ( pertenece? 10 ( 1 20 10 40 10 )) ; \u21d2 #t ( pertenece? ( cons 1 2 ) ( list ( cons 2 3 ) ( cons 3 4 ) ( cons 9 0 ))) ; \u21d2 #f b) Implementa el predicado recursivo (repetidos? lista) que recibe una lista y devuelve #t si alg\u00fan elemento est\u00e1 repetido en la lista, y #f en caso contrario. Pista : puedes utilizar la funci\u00f3n anterior (pertenece? elem lista), que comprueba si un elemento est\u00e1 en la lista. 1 2 3 ( repetidos? ( 1 2 3 5 4 5 6 )) ; \u21d2 #t ( repetidos? ( adios hola que tal )) ; \u21d2 #f ( repetidos? ( #t #f #t #t #t )) ; \u21d2 #t Ejercicio 3 a) Dado el siguiente box pointer , escribe las sentencias en Scheme (usando el m\u00ednimo n\u00famero de llamadas a list y cons ) que definen a p1 , p2 y p3 . b) Explica si p1 , p2 y p3 son listas y cu\u00e1ntos elementos tienen (en el caso en que lo sean). c) Escribe las expresiones que: devuelve 3 utilizando p3 devuelve 5 utilizando p3 d) Dado el siguiente diagrama caja y puntero, escribe las sentencias en Scheme (usando llamadas a list y cons ) que definen p4 . Ejercicio 4 Implementa la funci\u00f3n (binario-a-decimal lista-bits) que reciba una lista de bits que representan un n\u00famero en binario (el primer elemento ser\u00e1 el bit m\u00e1s significativo) y devuelva el n\u00famero decimal equivalente. Pista : puedes utilizar la funci\u00f3n length . 1 2 3 ( binario-a-decimal ( 1 1 1 1 )) ; \u21d2 15 ( binario-a-decimal ( 1 1 0 )) ; \u21d2 6 ( binario-a-decimal ( 1 0 )) ; \u21d2 2 Ejercicio 5 Implementa la funci\u00f3n recursiva (ordenada-creciente? lista-nums) que recibe como argumento una lista de n\u00fameros y devuelve #t si los n\u00fameros de la lista est\u00e1n ordenados de forma creciente o #f en caso contrario. Suponemos listas de 1 o m\u00e1s elementos. 1 2 3 ( ordenada-creciente? ( -1 23 45 59 99 )) ; \u21d2 #t ( ordenada-creciente? ( 12 50 -1 293 1000 )) ; \u21d2 #f ( ordenada-creciente? ( 3 )) ; \u21d2 #t Ejercicio 6 a) Implementa las funciones (inc-izq pareja) y (inc-der pareja) definidas de la siguiente forma: (inc-izq pareja) : devuelve una nueva pareja con la parte izquierda incrementada en 1. (inc-der pareja) : devuelve una nueva pareja con la parte derecha incrementada en 1. Ejemplos: 1 2 (inc-izq (cons 10 20)) ; \u21d2 {11 . 20} (inc-der (cons 10 20)) ; \u21d2 {10 . 21} b) Implementa la funci\u00f3n recursiva (cuenta-impares-pares lista-num) que devuelva una pareja cuya parte izquierda sea la cantidad de n\u00fameros impares de la lista y la parte derecha la cantidad de n\u00fameros pares. Debes utilizar las funciones auxiliares definidas en el apartado anterior. Tambi\u00e9n puedes utilizar las funciones predefinidas even? y odd? . Ejemplos: 1 2 ( cuenta-impares-pares ( 3 2 1 4 8 7 6 5 )) ; \u21d2 {4 . 4} ( cuenta-impares-pares ( 3 1 5 )) ; \u21d2 {3 . 0} Ejercicio 7 Implementa la funci\u00f3n recursiva (cadena-mayor lista) que recibe un lista de cadenas y devuelve una pareja con la cadena de mayor longitud y dicha longitud. En el caso de que haya m\u00e1s de una cadena con la m\u00e1xima longitud, se devolver\u00e1 la \u00faltima de ellas que aparezca en la lista. En el caso en que la lista sea vac\u00eda se devolver\u00e1 la pareja con la cadena vac\u00eda y un 0 (la longitud de la lista vac\u00eda). Pista : puedes utilizar la funci\u00f3n string-length 1 2 3 ( cadena-mayor ( vamos a obtener la cadena mayor )) ; \u21d2 { obtener . 7} ( cadena-mayor ( prueba con maximo igual )) ; \u21d2 { maximo . 6} ( cadena-mayor ()) ; \u21d2 { . 0} Lenguajes y Paradigmas de Programaci\u00f3n, curso 2018-19 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Domingo Gallardo, Cristina Pomares, Antonio Bot\u00eda, Francisco Mart\u00ednez","title":"Pr\u00e1ctica 2: Programaci\u00f3n funcional en Scheme"},{"location":"practicas/practica02/practica02.html#practica-2-programacion-funcional-en-scheme","text":"","title":"Pr\u00e1ctica 2: Programaci\u00f3n funcional en Scheme"},{"location":"practicas/practica02/practica02.html#entrega-de-la-practica","text":"Para entregar la pr\u00e1ctica debes subir a Moodle el fichero practica02.rkt con una cabecera inicial con tu nombre y apellidos, y las soluciones de cada ejercicio separadas por comentarios. Cada soluci\u00f3n debe incluir: La definici\u00f3n de las funciones que resuelven el ejercicio. Un conjunto de pruebas que comprueben su funcionamiento utilizando la librer\u00eda schemeunit .","title":"Entrega de la pr\u00e1ctica"},{"location":"practicas/practica02/practica02.html#ejercicios","text":"","title":"Ejercicios"},{"location":"practicas/practica02/practica02.html#ejercicio-1","text":"Implementa la funci\u00f3n recursiva (m\u00e1ximo lista) que recibe una lista con n\u00fameros como argumento y devuelve el mayor n\u00famero de la lista. Suponemos listas de 1 o m\u00e1s elementos. Para la implementaci\u00f3n debes usar la funci\u00f3n mayor definida en la pr\u00e1ctica anterior. Pista : Podemos expresar el caso general de la recursi\u00f3n de la siguiente forma: El m\u00e1ximo de los elementos de una lista es el mayor entre el primer elemento de la lista y el m\u00e1ximo del resto de la lista. Ejemplos: 1 2 ( maximo ( 9 8 6 4 3 )) ; \u21d2 9 ( maximo ( 1 -1 3 6 4 )) ; \u21d2 6","title":"Ejercicio 1"},{"location":"practicas/practica02/practica02.html#ejercicio-2","text":"a) Implementa el predicado recursivo (pertenece? elem lista) que reciba un dato y una lista y comprueba si el elemento pertenece a la lista. 1 2 3 ( pertenece? a ( b c d e )) ; \u21d2 #f ( pertenece? 10 ( 1 20 10 40 10 )) ; \u21d2 #t ( pertenece? ( cons 1 2 ) ( list ( cons 2 3 ) ( cons 3 4 ) ( cons 9 0 ))) ; \u21d2 #f b) Implementa el predicado recursivo (repetidos? lista) que recibe una lista y devuelve #t si alg\u00fan elemento est\u00e1 repetido en la lista, y #f en caso contrario. Pista : puedes utilizar la funci\u00f3n anterior (pertenece? elem lista), que comprueba si un elemento est\u00e1 en la lista. 1 2 3 ( repetidos? ( 1 2 3 5 4 5 6 )) ; \u21d2 #t ( repetidos? ( adios hola que tal )) ; \u21d2 #f ( repetidos? ( #t #f #t #t #t )) ; \u21d2 #t","title":"Ejercicio 2"},{"location":"practicas/practica02/practica02.html#ejercicio-3","text":"a) Dado el siguiente box pointer , escribe las sentencias en Scheme (usando el m\u00ednimo n\u00famero de llamadas a list y cons ) que definen a p1 , p2 y p3 . b) Explica si p1 , p2 y p3 son listas y cu\u00e1ntos elementos tienen (en el caso en que lo sean). c) Escribe las expresiones que: devuelve 3 utilizando p3 devuelve 5 utilizando p3 d) Dado el siguiente diagrama caja y puntero, escribe las sentencias en Scheme (usando llamadas a list y cons ) que definen p4 .","title":"Ejercicio 3"},{"location":"practicas/practica02/practica02.html#ejercicio-4","text":"Implementa la funci\u00f3n (binario-a-decimal lista-bits) que reciba una lista de bits que representan un n\u00famero en binario (el primer elemento ser\u00e1 el bit m\u00e1s significativo) y devuelva el n\u00famero decimal equivalente. Pista : puedes utilizar la funci\u00f3n length . 1 2 3 ( binario-a-decimal ( 1 1 1 1 )) ; \u21d2 15 ( binario-a-decimal ( 1 1 0 )) ; \u21d2 6 ( binario-a-decimal ( 1 0 )) ; \u21d2 2","title":"Ejercicio 4"},{"location":"practicas/practica02/practica02.html#ejercicio-5","text":"Implementa la funci\u00f3n recursiva (ordenada-creciente? lista-nums) que recibe como argumento una lista de n\u00fameros y devuelve #t si los n\u00fameros de la lista est\u00e1n ordenados de forma creciente o #f en caso contrario. Suponemos listas de 1 o m\u00e1s elementos. 1 2 3 ( ordenada-creciente? ( -1 23 45 59 99 )) ; \u21d2 #t ( ordenada-creciente? ( 12 50 -1 293 1000 )) ; \u21d2 #f ( ordenada-creciente? ( 3 )) ; \u21d2 #t","title":"Ejercicio 5"},{"location":"practicas/practica02/practica02.html#ejercicio-6","text":"a) Implementa las funciones (inc-izq pareja) y (inc-der pareja) definidas de la siguiente forma: (inc-izq pareja) : devuelve una nueva pareja con la parte izquierda incrementada en 1. (inc-der pareja) : devuelve una nueva pareja con la parte derecha incrementada en 1. Ejemplos: 1 2 (inc-izq (cons 10 20)) ; \u21d2 {11 . 20} (inc-der (cons 10 20)) ; \u21d2 {10 . 21} b) Implementa la funci\u00f3n recursiva (cuenta-impares-pares lista-num) que devuelva una pareja cuya parte izquierda sea la cantidad de n\u00fameros impares de la lista y la parte derecha la cantidad de n\u00fameros pares. Debes utilizar las funciones auxiliares definidas en el apartado anterior. Tambi\u00e9n puedes utilizar las funciones predefinidas even? y odd? . Ejemplos: 1 2 ( cuenta-impares-pares ( 3 2 1 4 8 7 6 5 )) ; \u21d2 {4 . 4} ( cuenta-impares-pares ( 3 1 5 )) ; \u21d2 {3 . 0}","title":"Ejercicio 6"},{"location":"practicas/practica02/practica02.html#ejercicio-7","text":"Implementa la funci\u00f3n recursiva (cadena-mayor lista) que recibe un lista de cadenas y devuelve una pareja con la cadena de mayor longitud y dicha longitud. En el caso de que haya m\u00e1s de una cadena con la m\u00e1xima longitud, se devolver\u00e1 la \u00faltima de ellas que aparezca en la lista. En el caso en que la lista sea vac\u00eda se devolver\u00e1 la pareja con la cadena vac\u00eda y un 0 (la longitud de la lista vac\u00eda). Pista : puedes utilizar la funci\u00f3n string-length 1 2 3 ( cadena-mayor ( vamos a obtener la cadena mayor )) ; \u21d2 { obtener . 7} ( cadena-mayor ( prueba con maximo igual )) ; \u21d2 { maximo . 6} ( cadena-mayor ()) ; \u21d2 { . 0} Lenguajes y Paradigmas de Programaci\u00f3n, curso 2018-19 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Domingo Gallardo, Cristina Pomares, Antonio Bot\u00eda, Francisco Mart\u00ednez","title":"Ejercicio 7"},{"location":"practicas/practica03/practica03.html","text":"Pr\u00e1ctica 3: Funciones recursivas sobre listas Entrega de la pr\u00e1ctica Para entregar la pr\u00e1ctica debes subir a Moodle el fichero practica03.rkt con una cabecera inicial con tu nombre y apellidos, y las soluciones de cada ejercicio separadas por comentarios. Cada soluci\u00f3n debe incluir: La definici\u00f3n de las funciones que resuelven el ejercicio. Un conjunto de pruebas que comprueben su funcionamiento utilizando la librer\u00eda schemeunit . Ejercicios Ejercicio 1 Implementa la funcio\u0301n recursiva (multiplo-de n lista-nums) que recibe un n\u00famero n y un lista de n\u00fameros y devuelve una lista con los booleanos resultantes de comprobar si cada n\u00famero de la lista es m\u00faltiplo de n . Ejemplo: 1 ( multiplo-de 10 ( 100 23 10 300 48 7 )) ; \u21d2 (#t #f #t #t #f #f) Ejercicio 2 Define la funci\u00f3n recursiva (calcular-lista lista) que recibe una lista que contiene s\u00edmbolos (operadores +,-,*,/) y parejas de n\u00fameros (operandos), representando operaciones matem\u00e1ticas. Se considera que la lista siempre est\u00e1 bien formada, con sus elementos en este orden: (s\u00edmbolo pareja s\u00edmbolo pareja...) . Tiene que devolver una lista con los resultados de las operaciones. Ejemplos: 1 2 ( calcular-lista ( + ( 2 . 3 ) * ( 4 . 5 ))) ; \u21d2 {5 20} ( calcular-lista ( / ( -6 . 2 ) - ( 4.5 . 0.5 ) + ( 2 . 3 ))) ; \u21d2 {-3 4.0 5} Ejercicio 3 Escribe la funci\u00f3n recursiva (expande lista-parejas) que reciba una lista de parejas que contienen un dato y un n\u00famero y devuelva una lista donde se hayan \"expandido\" las parejas, a\u00f1adiendo tantos elementos como el n\u00famero que indique cada pareja. Pista : Puedes definir una funci\u00f3n auxiliar (expande-pareja pareja) que recibe una pareja y devuelve la lista expandida resultante de expandir s\u00f3lo esa pareja. Ejemplo: 1 2 ( expande (( #t . 3 ) ( LPP . 2 ) ( b . 4 ))) \u21d2 { #t #t #t LPP LPP b b b b } Ejercicio 4 a) Implementa la funci\u00f3n recursiva (resultados\u2010quiniela lista\u2010parejas) que devuelve una lista de 1, X, 2 a partir de una lista de parejas que representa resultados de partidos de f\u00fatbol. El resultado es 1 cuando el n\u00famero izquierdo de la pareja es mayor que el derecho, un 2 cuando es al rev\u00e9s, y una X cuando los dos n\u00fameros son iguales. Pista : Puedes definir una funci\u00f3n (resultado-partido partido) que reciba una pareja y devuelva 1, X o 2. 1 2 3 ( resultados-quiniela (( 1 . 2 ) ( 4 . 4 ) ( 3 . 5 ) ( 6 . 2 ) ( 9 . 9 ))) ; \u21d2 {2 X 2 1 X} ( resultados-quiniela (( 2 . 2 ))) ; \u21d2 {X} ( resultados-quiniela (( 3 . 2 ) ( 4 . 3 ) ( 3 . 5 ))) ; \u21d2 {1 1 2} b) Implementa la funci\u00f3n recursiva (cuenta-resultados resultado lista-resultados) donde resultado puede ser un uno, una equis o un dos y cuenta el n\u00famero de ese resultado en la lista de partidos. Ejemplo: 1 2 3 ( cuenta-resultados X (( 1 . 2 ) ( 4 . 4 ) ( 3 . 5 ) ( 6 . 2 ) ( 9 . 9 ))) ; \u21d2 2 ( cuenta-resultados 1 (( 1 . 2 ) ( 4 . 4 ) ( 3 . 5 ) ( 6 . 2 ) ( 9 . 9 ))) ; \u21d2 1 ( cuenta-resultados 2 (( 1 . 2 ) ( 4 . 4 ) ( 3 . 5 ) ( 6 . 2 ) ( 9 . 9 ))) ; \u21d2 2 c) Implementa la funci\u00f3n recursiva (cuenta-resultados-lista lista-resultados) que devuelva una lista de tres elementos que representan el n\u00famero de 1s, de Xs y de 2s existentes en la lista de resultados original. Pista : Puedes definir una funci\u00f3n auxiliar (inc-pos n lista) que incremente el n\u00famero de la lista situado en la posici\u00f3n n . 1 2 3 ( cuenta-resultados-lista (( 1 . 2 ) ( 4 . 4 ) ( 3 . 5 ) ( 6 . 2 ) ( 9 . 9 ))) ; \u21d2 {1 2 2} ( cuenta-resultados-lista (( 2 . 2 ))) ; \u21d2 {0 1 0} ( cuenta-resultados-lista (( 3 . 2 ) ( 4 . 3 ) ( 3 . 5 ))) ; \u21d2 {2 0 1} Ejercicio 5 Implementa una funci\u00f3n recursiva (filtra-simbolos lista-simbolos lista-num) que recibe una lista de s\u00edmbolos y una lista de n\u00fameros enteros (ambas de la misma longitud) y devuelve una lista de parejas. Cada pareja est\u00e1 formada por el s\u00edmbolo de la i-\u00e9sima posici\u00f3n de lista-simbolos y el n\u00famero entero situado en esa posici\u00f3n de lista-num , siempre y cuando dicho n\u00famero se corresponda con la longitud de la cadena correspondiente al s\u00edmbolo. Puedes utilizar las funciones predefinidas string-length y symbol- string . Ejemplo: 1 2 ( filtra-simbolos ( este es un ejercicio de examen ) ( 2 1 2 9 1 6 )) ; \u21d2 {{un . 2} {ejercicio . 9} {examen . 6}} Lenguajes y Paradigmas de Programaci\u00f3n, curso 2018-19 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Domingo Gallardo, Cristina Pomares, Antonio Bot\u00eda, Francisco Mart\u00ednez","title":"Pr\u00e1ctica 3: Funciones recursivas sobre listas"},{"location":"practicas/practica03/practica03.html#practica-3-funciones-recursivas-sobre-listas","text":"","title":"Pr\u00e1ctica 3: Funciones recursivas sobre listas"},{"location":"practicas/practica03/practica03.html#entrega-de-la-practica","text":"Para entregar la pr\u00e1ctica debes subir a Moodle el fichero practica03.rkt con una cabecera inicial con tu nombre y apellidos, y las soluciones de cada ejercicio separadas por comentarios. Cada soluci\u00f3n debe incluir: La definici\u00f3n de las funciones que resuelven el ejercicio. Un conjunto de pruebas que comprueben su funcionamiento utilizando la librer\u00eda schemeunit .","title":"Entrega de la pr\u00e1ctica"},{"location":"practicas/practica03/practica03.html#ejercicios","text":"","title":"Ejercicios"},{"location":"practicas/practica03/practica03.html#ejercicio-1","text":"Implementa la funcio\u0301n recursiva (multiplo-de n lista-nums) que recibe un n\u00famero n y un lista de n\u00fameros y devuelve una lista con los booleanos resultantes de comprobar si cada n\u00famero de la lista es m\u00faltiplo de n . Ejemplo: 1 ( multiplo-de 10 ( 100 23 10 300 48 7 )) ; \u21d2 (#t #f #t #t #f #f)","title":"Ejercicio 1"},{"location":"practicas/practica03/practica03.html#ejercicio-2","text":"Define la funci\u00f3n recursiva (calcular-lista lista) que recibe una lista que contiene s\u00edmbolos (operadores +,-,*,/) y parejas de n\u00fameros (operandos), representando operaciones matem\u00e1ticas. Se considera que la lista siempre est\u00e1 bien formada, con sus elementos en este orden: (s\u00edmbolo pareja s\u00edmbolo pareja...) . Tiene que devolver una lista con los resultados de las operaciones. Ejemplos: 1 2 ( calcular-lista ( + ( 2 . 3 ) * ( 4 . 5 ))) ; \u21d2 {5 20} ( calcular-lista ( / ( -6 . 2 ) - ( 4.5 . 0.5 ) + ( 2 . 3 ))) ; \u21d2 {-3 4.0 5}","title":"Ejercicio 2"},{"location":"practicas/practica03/practica03.html#ejercicio-3","text":"Escribe la funci\u00f3n recursiva (expande lista-parejas) que reciba una lista de parejas que contienen un dato y un n\u00famero y devuelva una lista donde se hayan \"expandido\" las parejas, a\u00f1adiendo tantos elementos como el n\u00famero que indique cada pareja. Pista : Puedes definir una funci\u00f3n auxiliar (expande-pareja pareja) que recibe una pareja y devuelve la lista expandida resultante de expandir s\u00f3lo esa pareja. Ejemplo: 1 2 ( expande (( #t . 3 ) ( LPP . 2 ) ( b . 4 ))) \u21d2 { #t #t #t LPP LPP b b b b }","title":"Ejercicio 3"},{"location":"practicas/practica03/practica03.html#ejercicio-4","text":"a) Implementa la funci\u00f3n recursiva (resultados\u2010quiniela lista\u2010parejas) que devuelve una lista de 1, X, 2 a partir de una lista de parejas que representa resultados de partidos de f\u00fatbol. El resultado es 1 cuando el n\u00famero izquierdo de la pareja es mayor que el derecho, un 2 cuando es al rev\u00e9s, y una X cuando los dos n\u00fameros son iguales. Pista : Puedes definir una funci\u00f3n (resultado-partido partido) que reciba una pareja y devuelva 1, X o 2. 1 2 3 ( resultados-quiniela (( 1 . 2 ) ( 4 . 4 ) ( 3 . 5 ) ( 6 . 2 ) ( 9 . 9 ))) ; \u21d2 {2 X 2 1 X} ( resultados-quiniela (( 2 . 2 ))) ; \u21d2 {X} ( resultados-quiniela (( 3 . 2 ) ( 4 . 3 ) ( 3 . 5 ))) ; \u21d2 {1 1 2} b) Implementa la funci\u00f3n recursiva (cuenta-resultados resultado lista-resultados) donde resultado puede ser un uno, una equis o un dos y cuenta el n\u00famero de ese resultado en la lista de partidos. Ejemplo: 1 2 3 ( cuenta-resultados X (( 1 . 2 ) ( 4 . 4 ) ( 3 . 5 ) ( 6 . 2 ) ( 9 . 9 ))) ; \u21d2 2 ( cuenta-resultados 1 (( 1 . 2 ) ( 4 . 4 ) ( 3 . 5 ) ( 6 . 2 ) ( 9 . 9 ))) ; \u21d2 1 ( cuenta-resultados 2 (( 1 . 2 ) ( 4 . 4 ) ( 3 . 5 ) ( 6 . 2 ) ( 9 . 9 ))) ; \u21d2 2 c) Implementa la funci\u00f3n recursiva (cuenta-resultados-lista lista-resultados) que devuelva una lista de tres elementos que representan el n\u00famero de 1s, de Xs y de 2s existentes en la lista de resultados original. Pista : Puedes definir una funci\u00f3n auxiliar (inc-pos n lista) que incremente el n\u00famero de la lista situado en la posici\u00f3n n . 1 2 3 ( cuenta-resultados-lista (( 1 . 2 ) ( 4 . 4 ) ( 3 . 5 ) ( 6 . 2 ) ( 9 . 9 ))) ; \u21d2 {1 2 2} ( cuenta-resultados-lista (( 2 . 2 ))) ; \u21d2 {0 1 0} ( cuenta-resultados-lista (( 3 . 2 ) ( 4 . 3 ) ( 3 . 5 ))) ; \u21d2 {2 0 1}","title":"Ejercicio 4"},{"location":"practicas/practica03/practica03.html#ejercicio-5","text":"Implementa una funci\u00f3n recursiva (filtra-simbolos lista-simbolos lista-num) que recibe una lista de s\u00edmbolos y una lista de n\u00fameros enteros (ambas de la misma longitud) y devuelve una lista de parejas. Cada pareja est\u00e1 formada por el s\u00edmbolo de la i-\u00e9sima posici\u00f3n de lista-simbolos y el n\u00famero entero situado en esa posici\u00f3n de lista-num , siempre y cuando dicho n\u00famero se corresponda con la longitud de la cadena correspondiente al s\u00edmbolo. Puedes utilizar las funciones predefinidas string-length y symbol- string . Ejemplo: 1 2 ( filtra-simbolos ( este es un ejercicio de examen ) ( 2 1 2 9 1 6 )) ; \u21d2 {{un . 2} {ejercicio . 9} {examen . 6}} Lenguajes y Paradigmas de Programaci\u00f3n, curso 2018-19 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Domingo Gallardo, Cristina Pomares, Antonio Bot\u00eda, Francisco Mart\u00ednez","title":"Ejercicio 5"},{"location":"practicas/practica04/practica04.html","text":"Pr\u00e1ctica 4: Funciones como datos de primera clase y funciones de orden superior Entrega de la pr\u00e1ctica Para entregar la pr\u00e1ctica debes subir a Moodle el fichero practica04.rkt con una cabecera inicial con tu nombre y apellidos, y las soluciones de cada ejercicio separadas por comentarios. Cada soluci\u00f3n debe incluir: La definici\u00f3n de las funciones que resuelven el ejercicio. Un conjunto de pruebas que comprueben su funcionamiento utilizando la librer\u00eda schemeunit . Ejercicios Ejercicio 1 Implementa, utilizando funciones de orden superior, las funciones longitud-impar , suma-longitudes y mayusculas que reciben una lista de s\u00edmbolos y devuelven: (longitud-impar lista-simbolos) : una lista con aquellos s\u00edmbolos que tienen longitud impar. (suma-longitudes lista-simbolos) : la suma de las longitudes de todos los s\u00edmbolos de la lista. (mayusculas lista-simbolos) : una lista con los s\u00edmbolos escritos en may\u00fascula. Pista : Puedes usar las funciones symbol- string , string- symbol y string-upcase . Ejemplos: 1 2 3 4 5 6 ( longitud-impar ( me gusta LPP porque aprendo nuevos paradigmas de programaci \u00f3 n )) ; \u21d2 {gusta LPP aprendo} ( suma-longitudes ( me gusta LPP porque aprendo nuevos paradigmas de programaci \u00f3 n )) ; \u21d2 53 ( mayusculas ( me gusta LPP porque aprendo nuevos paradigmas de programaci \u00f3 n )) ; \u21d2 {ME GUSTA LPP PORQUE APRENDO NUEVOS PARADIGMAS DE PROGRAMACI\u00d3N} Ejercicio 2 Implementa utilizando funciones de orden las funciones (resultados\u2010quiniela lista\u2010parejas) , (cuenta-resultados resultado lista-resultados) y (cuenta-resultados-lista lista-resultados) de la pr\u00e1ctica 3. Ejercicio 3 Sin utilizar el int\u00e9rprete DrRacket, rellena los siguientes huecos para obtener el resultado esperado. Despu\u00e9s usa el int\u00e9rprete para comprobar si has acertado. a) 1 2 ( ______ list 0 ( 1 2 3 )) ; \u21d2 {1 {2 {3 0}}} b) 1 2 ( ______ list hola ( como estas adios )) ; \u21d2 {{{ hola como } estas } adios } Los siguientes apartados se realizan a partir de la siguiente lista: 1 ( define lista (( 2 . 7 ) ( 3 . 5 ) ( 10 . 4 ) ( 5 . 5 ))) c) Queremos obtener una lista donde cada n\u00famero es la suma de las parejas que son pares 1 2 3 4 5 ( filter ________ ( ________ ( lambda ( x ) ( + ( car x ) ( cdr x ))) lista )) ; \u21d2 {8 14 10} d) Queremos obtener una lista de parejas invertidas donde la \"nueva\" parte izquierda es mayor que la derecha. 1 2 3 ( filter ___________ ( map ____________ lista )) ; \u21d2 {{7 . 2} {5 . 3}} e) Queremos obtener una lista cuyos elementos son las partes izquierda de aquellas parejas cuya suma sea par. 1 2 3 (fold-right __________ () (_________ (lambda (x) (even? (+ (car x) (cdr x)))) lista)) ; \u21d2 {3 10 5} Ejercicio 4 a) Implementa las funciones constructoras (construye-multiplicador k) y (construye-exponenciador k) similares al ejemplo visto en teor\u00eda (construye-sumador k) . La funci\u00f3n construye-multiplicador construye una funci\u00f3n multiplicadora por k . Y la funci\u00f3n construye-exponenciador construye una funci\u00f3n de un argumento x que eleva k a x . Ejemplo: 1 2 3 4 5 6 7 8 ( define multiplica-por-10 ( construye-multiplicador 10 )) ( multiplica-por-10 3 ) ; \u21d2 30 ( define multiplica-por-5 ( construye-multiplicador 5 )) ( multiplica-por-5 3 ) ; \u21d2 15 ( define elevado-2-a ( construye-exponenciador 2 )) ( elevado-2-a 3 ) ; \u21d2 8 ( define elevado-5-a ( construye-exponenciador 5 )) ( elevado-5-a 3 ) ; \u21d2 125 b) La diferencia fundamental entre las funciones anteriores es que (construye-exponenciador k) debe fijar a k el primer par\u00e1metro de la funci\u00f3n expt , mientras que (construye-sumador k) y (construye-multiplicador k) fijan el segundo par\u00e1metro. Podemos generalizar estas funciones definiendo la funci\u00f3n (fija-arg f i k) que recibe una funci\u00f3n de dos argumentos f , un valor i que indica si queremos fijar el primer par\u00e1metro (cuando i = 1) o el segundo par\u00e1metro (i = 2) y el valor k al que fijamos el par\u00e1metro correspondiente. Ejemplo: 1 2 3 4 5 6 7 8 ( define suma-10 ( fija-arg + 2 10 )) ( suma-10 8 ) ; \u21d2 18 ( define elevado-3-a ( fija-arg expt 1 3 )) ( elevado-3-a 5 ) ; \u21d2 243 ( define a \u00f1 ade-asteriscos ( fija-arg string-append 2 **** )) ( a \u00f1 ade-asteriscos Hola ) ; \u21d2 Hola**** ( define precede-asteriscos ( fija-arg string-append 1 **** )) ( precede-asteriscos Hola ) ; \u21d2 ****Hola Ejercicio 5 a) Implementa usando funciones de orden superior la funci\u00f3n (suma-n-izq n lista-parejas) que recibe una lista de parejas y devuelve otra lista a la que hemos sumado n a todas las partes izquierdas. Ejemplo 1 2 ( suma-n-izq 10 (( 1 . 3 ) ( 0 . 9 ) ( 5 . 8 ) ( 4 . 1 ))) ; \u21d2 {{11 . 3} {10 . 9} {15 . 8} {14 . 1}} b) Implementa usando funciones de orden superior la funci\u00f3n (aplica-2 func lista-parejas) que recibe una funci\u00f3n de dos argumentos y una lista de parejas y devuelve una lista con el resultado de aplicar esa funci\u00f3n a los elementos izquierdo y derecho de cada pareja. Ejemplo: 1 2 3 4 5 6 7 ( aplica-2 + (( 2 . 3 ) ( 1 . -1 ) ( 5 . 4 ))) ; \u21d2 {5 0 9} ( aplica-2 ( lambda ( x y ) ( if ( even? x ) y ( * y -1 ))) (( 2 . 3 ) ( 1 . 3 ) ( 5 . 4 ) ( 8 . 10 ))) ; \u21d2 {3 -3 -4 10} Ejercicio 6 a) Utilizando una composici\u00f3n de las funciones de orden superior fold-right y map , implementa la funci\u00f3n (cadena-mayor lista) que recibe un lista de cadenas y devuelve una pareja con la cadena de mayor longitud y dicha longitud. En el caso de que haya m\u00e1s de una cadena con la m\u00e1xima longitud, se devolver\u00e1 la \u00faltima de ellas que aparezca en la lista. 1 2 3 ( cadena-mayor ( vamos a obtener la cadena mayor )) ; \u21d2 { obtener . 7} ( cadena-mayor ( prueba con maximo igual )) ; \u21d2 { maximo . 6} ( cadena-mayor ( hola )) ; \u21d2 { hola . 4} b) La funci\u00f3n map de Scheme tambi\u00e9n puede mapear una funci\u00f3n de dos argumentos sobre dos listas. Por ejemplo: 1 2 3 ( map ( lambda ( x y ) ( + x y )) ( 1 2 3 4 ) ( 4 4 4 4 )) ; \u21d2 {5 6 7 8} Implementa la funcio\u0301n (filtra-simbolos lista-simbolos lista-num) de de la pr\u00e1ctica 3, usando una composici\u00f3n de funciones en las que se use map como en el ejemplo anterior. Lenguajes y Paradigmas de Programaci\u00f3n, curso 2018-19 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Domingo Gallardo, Cristina Pomares, Antonio Bot\u00eda, Francisco Mart\u00ednez","title":"Pr\u00e1ctica 4: Funciones como datos de primera clase y funciones de orden superior"},{"location":"practicas/practica04/practica04.html#practica-4-funciones-como-datos-de-primera-clase-y-funciones-de-orden-superior","text":"","title":"Pr\u00e1ctica 4: Funciones como datos de primera clase y funciones de orden superior"},{"location":"practicas/practica04/practica04.html#entrega-de-la-practica","text":"Para entregar la pr\u00e1ctica debes subir a Moodle el fichero practica04.rkt con una cabecera inicial con tu nombre y apellidos, y las soluciones de cada ejercicio separadas por comentarios. Cada soluci\u00f3n debe incluir: La definici\u00f3n de las funciones que resuelven el ejercicio. Un conjunto de pruebas que comprueben su funcionamiento utilizando la librer\u00eda schemeunit .","title":"Entrega de la pr\u00e1ctica"},{"location":"practicas/practica04/practica04.html#ejercicios","text":"","title":"Ejercicios"},{"location":"practicas/practica04/practica04.html#ejercicio-1","text":"Implementa, utilizando funciones de orden superior, las funciones longitud-impar , suma-longitudes y mayusculas que reciben una lista de s\u00edmbolos y devuelven: (longitud-impar lista-simbolos) : una lista con aquellos s\u00edmbolos que tienen longitud impar. (suma-longitudes lista-simbolos) : la suma de las longitudes de todos los s\u00edmbolos de la lista. (mayusculas lista-simbolos) : una lista con los s\u00edmbolos escritos en may\u00fascula. Pista : Puedes usar las funciones symbol- string , string- symbol y string-upcase . Ejemplos: 1 2 3 4 5 6 ( longitud-impar ( me gusta LPP porque aprendo nuevos paradigmas de programaci \u00f3 n )) ; \u21d2 {gusta LPP aprendo} ( suma-longitudes ( me gusta LPP porque aprendo nuevos paradigmas de programaci \u00f3 n )) ; \u21d2 53 ( mayusculas ( me gusta LPP porque aprendo nuevos paradigmas de programaci \u00f3 n )) ; \u21d2 {ME GUSTA LPP PORQUE APRENDO NUEVOS PARADIGMAS DE PROGRAMACI\u00d3N}","title":"Ejercicio 1"},{"location":"practicas/practica04/practica04.html#ejercicio-2","text":"Implementa utilizando funciones de orden las funciones (resultados\u2010quiniela lista\u2010parejas) , (cuenta-resultados resultado lista-resultados) y (cuenta-resultados-lista lista-resultados) de la pr\u00e1ctica 3.","title":"Ejercicio 2"},{"location":"practicas/practica04/practica04.html#ejercicio-3","text":"Sin utilizar el int\u00e9rprete DrRacket, rellena los siguientes huecos para obtener el resultado esperado. Despu\u00e9s usa el int\u00e9rprete para comprobar si has acertado. a) 1 2 ( ______ list 0 ( 1 2 3 )) ; \u21d2 {1 {2 {3 0}}} b) 1 2 ( ______ list hola ( como estas adios )) ; \u21d2 {{{ hola como } estas } adios } Los siguientes apartados se realizan a partir de la siguiente lista: 1 ( define lista (( 2 . 7 ) ( 3 . 5 ) ( 10 . 4 ) ( 5 . 5 ))) c) Queremos obtener una lista donde cada n\u00famero es la suma de las parejas que son pares 1 2 3 4 5 ( filter ________ ( ________ ( lambda ( x ) ( + ( car x ) ( cdr x ))) lista )) ; \u21d2 {8 14 10} d) Queremos obtener una lista de parejas invertidas donde la \"nueva\" parte izquierda es mayor que la derecha. 1 2 3 ( filter ___________ ( map ____________ lista )) ; \u21d2 {{7 . 2} {5 . 3}} e) Queremos obtener una lista cuyos elementos son las partes izquierda de aquellas parejas cuya suma sea par. 1 2 3 (fold-right __________ () (_________ (lambda (x) (even? (+ (car x) (cdr x)))) lista)) ; \u21d2 {3 10 5}","title":"Ejercicio 3"},{"location":"practicas/practica04/practica04.html#ejercicio-4","text":"a) Implementa las funciones constructoras (construye-multiplicador k) y (construye-exponenciador k) similares al ejemplo visto en teor\u00eda (construye-sumador k) . La funci\u00f3n construye-multiplicador construye una funci\u00f3n multiplicadora por k . Y la funci\u00f3n construye-exponenciador construye una funci\u00f3n de un argumento x que eleva k a x . Ejemplo: 1 2 3 4 5 6 7 8 ( define multiplica-por-10 ( construye-multiplicador 10 )) ( multiplica-por-10 3 ) ; \u21d2 30 ( define multiplica-por-5 ( construye-multiplicador 5 )) ( multiplica-por-5 3 ) ; \u21d2 15 ( define elevado-2-a ( construye-exponenciador 2 )) ( elevado-2-a 3 ) ; \u21d2 8 ( define elevado-5-a ( construye-exponenciador 5 )) ( elevado-5-a 3 ) ; \u21d2 125 b) La diferencia fundamental entre las funciones anteriores es que (construye-exponenciador k) debe fijar a k el primer par\u00e1metro de la funci\u00f3n expt , mientras que (construye-sumador k) y (construye-multiplicador k) fijan el segundo par\u00e1metro. Podemos generalizar estas funciones definiendo la funci\u00f3n (fija-arg f i k) que recibe una funci\u00f3n de dos argumentos f , un valor i que indica si queremos fijar el primer par\u00e1metro (cuando i = 1) o el segundo par\u00e1metro (i = 2) y el valor k al que fijamos el par\u00e1metro correspondiente. Ejemplo: 1 2 3 4 5 6 7 8 ( define suma-10 ( fija-arg + 2 10 )) ( suma-10 8 ) ; \u21d2 18 ( define elevado-3-a ( fija-arg expt 1 3 )) ( elevado-3-a 5 ) ; \u21d2 243 ( define a \u00f1 ade-asteriscos ( fija-arg string-append 2 **** )) ( a \u00f1 ade-asteriscos Hola ) ; \u21d2 Hola**** ( define precede-asteriscos ( fija-arg string-append 1 **** )) ( precede-asteriscos Hola ) ; \u21d2 ****Hola","title":"Ejercicio 4"},{"location":"practicas/practica04/practica04.html#ejercicio-5","text":"a) Implementa usando funciones de orden superior la funci\u00f3n (suma-n-izq n lista-parejas) que recibe una lista de parejas y devuelve otra lista a la que hemos sumado n a todas las partes izquierdas. Ejemplo 1 2 ( suma-n-izq 10 (( 1 . 3 ) ( 0 . 9 ) ( 5 . 8 ) ( 4 . 1 ))) ; \u21d2 {{11 . 3} {10 . 9} {15 . 8} {14 . 1}} b) Implementa usando funciones de orden superior la funci\u00f3n (aplica-2 func lista-parejas) que recibe una funci\u00f3n de dos argumentos y una lista de parejas y devuelve una lista con el resultado de aplicar esa funci\u00f3n a los elementos izquierdo y derecho de cada pareja. Ejemplo: 1 2 3 4 5 6 7 ( aplica-2 + (( 2 . 3 ) ( 1 . -1 ) ( 5 . 4 ))) ; \u21d2 {5 0 9} ( aplica-2 ( lambda ( x y ) ( if ( even? x ) y ( * y -1 ))) (( 2 . 3 ) ( 1 . 3 ) ( 5 . 4 ) ( 8 . 10 ))) ; \u21d2 {3 -3 -4 10}","title":"Ejercicio 5"},{"location":"practicas/practica04/practica04.html#ejercicio-6","text":"a) Utilizando una composici\u00f3n de las funciones de orden superior fold-right y map , implementa la funci\u00f3n (cadena-mayor lista) que recibe un lista de cadenas y devuelve una pareja con la cadena de mayor longitud y dicha longitud. En el caso de que haya m\u00e1s de una cadena con la m\u00e1xima longitud, se devolver\u00e1 la \u00faltima de ellas que aparezca en la lista. 1 2 3 ( cadena-mayor ( vamos a obtener la cadena mayor )) ; \u21d2 { obtener . 7} ( cadena-mayor ( prueba con maximo igual )) ; \u21d2 { maximo . 6} ( cadena-mayor ( hola )) ; \u21d2 { hola . 4} b) La funci\u00f3n map de Scheme tambi\u00e9n puede mapear una funci\u00f3n de dos argumentos sobre dos listas. Por ejemplo: 1 2 3 ( map ( lambda ( x y ) ( + x y )) ( 1 2 3 4 ) ( 4 4 4 4 )) ; \u21d2 {5 6 7 8} Implementa la funcio\u0301n (filtra-simbolos lista-simbolos lista-num) de de la pr\u00e1ctica 3, usando una composici\u00f3n de funciones en las que se use map como en el ejemplo anterior. Lenguajes y Paradigmas de Programaci\u00f3n, curso 2018-19 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Domingo Gallardo, Cristina Pomares, Antonio Bot\u00eda, Francisco Mart\u00ednez","title":"Ejercicio 6"},{"location":"practicas/practica05/practica05.html","text":"Pr\u00e1ctica 5: Procedimientos recursivos Entrega de la pr\u00e1ctica Para entregar la pr\u00e1ctica debes subir a Moodle el fichero practica05.rkt con una cabecera inicial con tu nombre y apellidos, y las soluciones de cada ejercicio separadas por comentarios. Cada soluci\u00f3n debe incluir: La definici\u00f3n de las funciones que resuelven el ejercicio. Un conjunto de pruebas que comprueben su funcionamiento utilizando la librer\u00eda schemeunit . Ejercicios Ejercicio 1 a) Implementa utilizando recursi\u00f3n por la cola la versi\u00f3n iterativa de la funci\u00f3n (cuadrado-lista lista) que toma como argumento una lista de nu\u0301meros y devuelve una lista con sus cuadrados. La funci\u00f3n cuadrado-lista deber\u00e1 llamar a la funci\u00f3n cuadrado-lista-iter que es la que implementa propiamente la versi\u00f3n iterativa usando recursi\u00f3n por la cola. Ejemplo: 1 ( cuadrado-lista ( 2 3 4 5 )) ; \u21d2 (4 9 16 25) b) Define utilizando recursi\u00f3n por la cola la funci\u00f3n (max-lista lista) que recibe una lista num\u00e9rica y devuelve el m\u00e1ximo de sus elementos. Ejemplo: 1 ( max-lista ( 2 5 9 12 5 0 4 )) ; \u21d2 12 Ejercicio 2 Implementa utilizando recursi\u00f3n por la cola las funciones expande-pareja y expande de la pr\u00e1ctica 3. 1 2 3 ( expande-pareja ( cons a 4 )) ; \u21d2 {a a a a} ( expande (( #t . 3 ) ( LPP . 2 ) ( b . 4 ))) \u21d2 { #t #t #t LPP LPP b b b b } Ejercicio 3 Implementa utilizando recursi\u00f3n por la cola funci\u00f3n (aplica-funciones lista-parejas) que recibe una lista de parejas {{funci\u00f3n . argumento} ...} y devuelve la lista con los resultados de aplicar cada funci\u00f3n al argumento situado en la parte derecha de la pareja. Ejemplo: 1 2 ( aplica-funciones ( list ( cons sqrt 16 ) ( cons list 2 ) ( cons even? 5 ) ( cons not #f ))) ; \u21d2 {4 {2} #f #t} Ejercicio 4 a) Implementa utilizando recursi\u00f3n por la cola la funci\u00f3n binario-a-decimal que reciba una cadena con un n\u00famero arbitrario de 0s y 1s y devuelva el n\u00famero decimal correspondiente a ese n\u00famero binario. Ejemplos: 1 2 ( binario-a-decimal 101 ) ; \u21d2 5 ( binario-a-decimal 101101 ) ; \u21d2 45 Ejemplos: b) Implementa, utilizando recursi\u00f3n por la cola, la funci\u00f3n decimal-a-hexadecimal que recibe un n\u00famero decimal y devuelve una lista con el n\u00famero hexadecimal correspondiente en forma de cadena: 1 2 ( decimal-a-hexadecimal 200 ) ; \u21d2 C8 ( decimal-a-hexadecimal 999 ) ; \u21d2 3E7 Ejercicio 5 a) Usando gr\u00e1ficos de tortuga, implementa la funci\u00f3n (piramide-hexagonal lado decremento) que dibuje hex\u00e1gonos conc\u00e9ntricos con el lado inicial lado y que cada vez vaya decrementando ese valor con el decremento . Por ejemplo, la llamada a (piramide-hexagonal 150 10) debe dibujar la siguiente figura: Pista : el desplazamiento que debe realizar la tortuga antes de dibujar cada hex\u00e1gono es de decremento , en la direcci\u00f3n del \u00e1ngulo que va al centro del hex\u00e1gono. b) Define la funci\u00f3n (alfombra-sierpinski tam min) que construya la Alfombra de Sierpinski (una variante del Tri\u00e1gulo de Sierpinski que hemos visto en teor\u00eda) de lado tam p\u00edxeles utilizando gr\u00e1ficos de tortuga. Por ejemplo, la llamada a (alfombra-sierpinski 500 6) debe dibujar la siguiente figura: Lenguajes y Paradigmas de Programaci\u00f3n, curso 2018-19 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Domingo Gallardo, Cristina Pomares, Antonio Bot\u00eda, Francisco Mart\u00ednez","title":"Pr\u00e1ctica 5: Procedimientos recursivos"},{"location":"practicas/practica05/practica05.html#practica-5-procedimientos-recursivos","text":"","title":"Pr\u00e1ctica 5: Procedimientos recursivos"},{"location":"practicas/practica05/practica05.html#entrega-de-la-practica","text":"Para entregar la pr\u00e1ctica debes subir a Moodle el fichero practica05.rkt con una cabecera inicial con tu nombre y apellidos, y las soluciones de cada ejercicio separadas por comentarios. Cada soluci\u00f3n debe incluir: La definici\u00f3n de las funciones que resuelven el ejercicio. Un conjunto de pruebas que comprueben su funcionamiento utilizando la librer\u00eda schemeunit .","title":"Entrega de la pr\u00e1ctica"},{"location":"practicas/practica05/practica05.html#ejercicios","text":"","title":"Ejercicios"},{"location":"practicas/practica05/practica05.html#ejercicio-1","text":"a) Implementa utilizando recursi\u00f3n por la cola la versi\u00f3n iterativa de la funci\u00f3n (cuadrado-lista lista) que toma como argumento una lista de nu\u0301meros y devuelve una lista con sus cuadrados. La funci\u00f3n cuadrado-lista deber\u00e1 llamar a la funci\u00f3n cuadrado-lista-iter que es la que implementa propiamente la versi\u00f3n iterativa usando recursi\u00f3n por la cola. Ejemplo: 1 ( cuadrado-lista ( 2 3 4 5 )) ; \u21d2 (4 9 16 25) b) Define utilizando recursi\u00f3n por la cola la funci\u00f3n (max-lista lista) que recibe una lista num\u00e9rica y devuelve el m\u00e1ximo de sus elementos. Ejemplo: 1 ( max-lista ( 2 5 9 12 5 0 4 )) ; \u21d2 12","title":"Ejercicio 1"},{"location":"practicas/practica05/practica05.html#ejercicio-2","text":"Implementa utilizando recursi\u00f3n por la cola las funciones expande-pareja y expande de la pr\u00e1ctica 3. 1 2 3 ( expande-pareja ( cons a 4 )) ; \u21d2 {a a a a} ( expande (( #t . 3 ) ( LPP . 2 ) ( b . 4 ))) \u21d2 { #t #t #t LPP LPP b b b b }","title":"Ejercicio 2"},{"location":"practicas/practica05/practica05.html#ejercicio-3","text":"Implementa utilizando recursi\u00f3n por la cola funci\u00f3n (aplica-funciones lista-parejas) que recibe una lista de parejas {{funci\u00f3n . argumento} ...} y devuelve la lista con los resultados de aplicar cada funci\u00f3n al argumento situado en la parte derecha de la pareja. Ejemplo: 1 2 ( aplica-funciones ( list ( cons sqrt 16 ) ( cons list 2 ) ( cons even? 5 ) ( cons not #f ))) ; \u21d2 {4 {2} #f #t}","title":"Ejercicio 3"},{"location":"practicas/practica05/practica05.html#ejercicio-4","text":"a) Implementa utilizando recursi\u00f3n por la cola la funci\u00f3n binario-a-decimal que reciba una cadena con un n\u00famero arbitrario de 0s y 1s y devuelva el n\u00famero decimal correspondiente a ese n\u00famero binario. Ejemplos: 1 2 ( binario-a-decimal 101 ) ; \u21d2 5 ( binario-a-decimal 101101 ) ; \u21d2 45 Ejemplos: b) Implementa, utilizando recursi\u00f3n por la cola, la funci\u00f3n decimal-a-hexadecimal que recibe un n\u00famero decimal y devuelve una lista con el n\u00famero hexadecimal correspondiente en forma de cadena: 1 2 ( decimal-a-hexadecimal 200 ) ; \u21d2 C8 ( decimal-a-hexadecimal 999 ) ; \u21d2 3E7","title":"Ejercicio 4"},{"location":"practicas/practica05/practica05.html#ejercicio-5","text":"a) Usando gr\u00e1ficos de tortuga, implementa la funci\u00f3n (piramide-hexagonal lado decremento) que dibuje hex\u00e1gonos conc\u00e9ntricos con el lado inicial lado y que cada vez vaya decrementando ese valor con el decremento . Por ejemplo, la llamada a (piramide-hexagonal 150 10) debe dibujar la siguiente figura: Pista : el desplazamiento que debe realizar la tortuga antes de dibujar cada hex\u00e1gono es de decremento , en la direcci\u00f3n del \u00e1ngulo que va al centro del hex\u00e1gono. b) Define la funci\u00f3n (alfombra-sierpinski tam min) que construya la Alfombra de Sierpinski (una variante del Tri\u00e1gulo de Sierpinski que hemos visto en teor\u00eda) de lado tam p\u00edxeles utilizando gr\u00e1ficos de tortuga. Por ejemplo, la llamada a (alfombra-sierpinski 500 6) debe dibujar la siguiente figura: Lenguajes y Paradigmas de Programaci\u00f3n, curso 2018-19 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Domingo Gallardo, Cristina Pomares, Antonio Bot\u00eda, Francisco Mart\u00ednez","title":"Ejercicio 5"},{"location":"practicas/practica06/practica06.html","text":"Pr\u00e1ctica 6: Listas estructuradas Entrega de la pr\u00e1ctica Para entregar la pr\u00e1ctica debes subir a Moodle el fichero practica06.rkt con una cabecera inicial con tu nombre y apellidos, y las soluciones de cada ejercicio separadas por comentarios. Cada soluci\u00f3n debe incluir: La definici\u00f3n de las funciones que resuelven el ejercicio. Un conjunto de pruebas que comprueben su funcionamiento utilizando la librer\u00eda schemeunit . Ejercicios Ejercicio 1 a) Escribe la lista estructurada correspondiente a la siguiente representaci\u00f3n gr\u00e1fica por niveles, y escribe una \u00fanica expresi\u00f3n que devuelva el elemento 'h 1 2 3 4 5 6 7 8 * / | \\ | | \\ * d * / \\ / / | \\ a b c * * h | / \\ e f g 1 2 ( define lista-a ( ________ )) ( check-equal? _________ h ) b) Escribe la lista estructurada correspondiente a la siguiente representaci\u00f3n gr\u00e1fica por niveles, y escribe una \u00fanica expresi\u00f3n que devuelva el elemento 10 1 2 3 4 5 6 7 * / / \\ \\ 1 * * 8 / | \\ \\ 6 * 10 2 | 3 1 2 ( define lista-b ( ________ )) ( check-equal? _______ 10 ) Ejercicio 2 a) Define la funci\u00f3n recursiva (cuenta-pares lista) que recibe una lista estructurada y cuenta la cantidad de n\u00fameros pares que contiene Ejemplos: 1 2 ( cuenta-pares ( 1 ( 2 3 ) 4 ( 5 6 ))) ; \u21d2 3 ( cuenta-pares ((( 1 2 ) 3 ( 4 ) 5 ) (((( 6 )))))) ; \u21d2 3 b) Define la funci\u00f3n del apartado anterior utilizando funciones de orden superior. Ejercicio 3 a) Implementa la funci\u00f3n (cumplen-predicado pred lista) que devuelva una lista con todos los elementos de lista estructurada que cumplen un predicado. Ejemplo: 1 2 ( cumplen-predicado even? ( 1 ( 2 ( 3 ( 4 ))) ( 5 6 ))) ; \u21d2 {2 4 6} ( cumplen-predicado pair? ((( 1 . 2 ) 3 ( 4 . 3 ) 5 ) 6 )) ; \u21d2 {{1 . 2} {4 . 3} b) Implementa la funci\u00f3n del apartado anterior utilizando funciones de orden superior. Ejercicio 4 Implementa la funci\u00f3n recursiva (sustituye-elem lista elem-old elem-new) que recibe como argumentos una lista estructurada y dos elementos, y devuelve otra lista con la misma estructura, pero en la que se ha sustituido las ocurrencias de elem-old por elem-new . Ejemplo: 1 2 ( sustituye-elem ( a b ( c d ( e c )) c ( f ( c ) g )) c h ) \u21d2 { a b { h d { e h }} h { f { h } g }} Ejercicio 5 Implementa la funci\u00f3n recursiva (diff-listas l1 l2) que tome como argumentos dos listas estructuradas con la misma estructura, pero con diferentes elementos, y devuelva una lista de parejas que contenga los elementos que son diferentes. Ejemplos: 1 2 3 4 5 ( diff-listas ( a ( b (( c )) d e ) f ) ( 1 ( b (( 2 )) 3 4 ) f )) \u21d2 {{ a . 1 } { c . 2 } { d . 3 } { e . 4 }} ( diff-listas (( a b ) c ) (( a b ) c )) \u21d2 () Ejercicio 6 Dos funciones sobre niveles: a) Implementa la funci\u00f3n (cuenta-hojas-debajo-nivel lista n) que recibe una lista estructurada y un n\u00famero que indica un nivel, y devuelve el n\u00famero de hojas que hay por debajo de ese nivel. Puedes hacerlo con recursi\u00f3n o con funciones de orden superior. 1 2 ( cuenta-hojas-debajo-nivel ( 10 2 ( 4 6 ( 9 3 ) ( 8 7 ) 12 ) 1 ) 2 ) ; \u21d2 4 ( cuenta-hojas-debajo-nivel ( 10 2 ( 4 6 ( 9 3 ) ( 8 7 ) 12 ) 1 ) 3 ) ; \u21d2 0 b) Implementa la funci\u00f3n (nivel-elemento lista) que reciba una lista estructurada y devuelva una pareja (elem . nivel) , donde la parte izquierda es el elemento que se encuentra a mayor nivel y la parte derecha el nivel en el que se encuentra. Puedes definir alguna funci\u00f3n auxiliar si lo necesitas. Puedes hacerlo con recursi\u00f3n o con funciones de orden superior. 1 2 ( nivel-elemento ( 2 ( 3 ))) ;\u21d2 (3 . 2) ( nivel-elemento (( 2 ) ( 3 ( 4 )(((((( 5 ))) 6 )) 7 )) 8 )) ; \u21d2 (5 . 8) Lenguajes y Paradigmas de Programaci\u00f3n, curso 2018-19 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Domingo Gallardo, Cristina Pomares, Antonio Bot\u00eda, Francisco Mart\u00ednez","title":"Pr\u00e1ctica 6: Listas estructuradas"},{"location":"practicas/practica06/practica06.html#practica-6-listas-estructuradas","text":"","title":"Pr\u00e1ctica 6: Listas estructuradas"},{"location":"practicas/practica06/practica06.html#entrega-de-la-practica","text":"Para entregar la pr\u00e1ctica debes subir a Moodle el fichero practica06.rkt con una cabecera inicial con tu nombre y apellidos, y las soluciones de cada ejercicio separadas por comentarios. Cada soluci\u00f3n debe incluir: La definici\u00f3n de las funciones que resuelven el ejercicio. Un conjunto de pruebas que comprueben su funcionamiento utilizando la librer\u00eda schemeunit .","title":"Entrega de la pr\u00e1ctica"},{"location":"practicas/practica06/practica06.html#ejercicios","text":"","title":"Ejercicios"},{"location":"practicas/practica06/practica06.html#ejercicio-1","text":"a) Escribe la lista estructurada correspondiente a la siguiente representaci\u00f3n gr\u00e1fica por niveles, y escribe una \u00fanica expresi\u00f3n que devuelva el elemento 'h 1 2 3 4 5 6 7 8 * / | \\ | | \\ * d * / \\ / / | \\ a b c * * h | / \\ e f g 1 2 ( define lista-a ( ________ )) ( check-equal? _________ h ) b) Escribe la lista estructurada correspondiente a la siguiente representaci\u00f3n gr\u00e1fica por niveles, y escribe una \u00fanica expresi\u00f3n que devuelva el elemento 10 1 2 3 4 5 6 7 * / / \\ \\ 1 * * 8 / | \\ \\ 6 * 10 2 | 3 1 2 ( define lista-b ( ________ )) ( check-equal? _______ 10 )","title":"Ejercicio 1"},{"location":"practicas/practica06/practica06.html#ejercicio-2","text":"a) Define la funci\u00f3n recursiva (cuenta-pares lista) que recibe una lista estructurada y cuenta la cantidad de n\u00fameros pares que contiene Ejemplos: 1 2 ( cuenta-pares ( 1 ( 2 3 ) 4 ( 5 6 ))) ; \u21d2 3 ( cuenta-pares ((( 1 2 ) 3 ( 4 ) 5 ) (((( 6 )))))) ; \u21d2 3 b) Define la funci\u00f3n del apartado anterior utilizando funciones de orden superior.","title":"Ejercicio 2"},{"location":"practicas/practica06/practica06.html#ejercicio-3","text":"a) Implementa la funci\u00f3n (cumplen-predicado pred lista) que devuelva una lista con todos los elementos de lista estructurada que cumplen un predicado. Ejemplo: 1 2 ( cumplen-predicado even? ( 1 ( 2 ( 3 ( 4 ))) ( 5 6 ))) ; \u21d2 {2 4 6} ( cumplen-predicado pair? ((( 1 . 2 ) 3 ( 4 . 3 ) 5 ) 6 )) ; \u21d2 {{1 . 2} {4 . 3} b) Implementa la funci\u00f3n del apartado anterior utilizando funciones de orden superior.","title":"Ejercicio 3"},{"location":"practicas/practica06/practica06.html#ejercicio-4","text":"Implementa la funci\u00f3n recursiva (sustituye-elem lista elem-old elem-new) que recibe como argumentos una lista estructurada y dos elementos, y devuelve otra lista con la misma estructura, pero en la que se ha sustituido las ocurrencias de elem-old por elem-new . Ejemplo: 1 2 ( sustituye-elem ( a b ( c d ( e c )) c ( f ( c ) g )) c h ) \u21d2 { a b { h d { e h }} h { f { h } g }}","title":"Ejercicio 4"},{"location":"practicas/practica06/practica06.html#ejercicio-5","text":"Implementa la funci\u00f3n recursiva (diff-listas l1 l2) que tome como argumentos dos listas estructuradas con la misma estructura, pero con diferentes elementos, y devuelva una lista de parejas que contenga los elementos que son diferentes. Ejemplos: 1 2 3 4 5 ( diff-listas ( a ( b (( c )) d e ) f ) ( 1 ( b (( 2 )) 3 4 ) f )) \u21d2 {{ a . 1 } { c . 2 } { d . 3 } { e . 4 }} ( diff-listas (( a b ) c ) (( a b ) c )) \u21d2 ()","title":"Ejercicio 5"},{"location":"practicas/practica06/practica06.html#ejercicio-6","text":"Dos funciones sobre niveles: a) Implementa la funci\u00f3n (cuenta-hojas-debajo-nivel lista n) que recibe una lista estructurada y un n\u00famero que indica un nivel, y devuelve el n\u00famero de hojas que hay por debajo de ese nivel. Puedes hacerlo con recursi\u00f3n o con funciones de orden superior. 1 2 ( cuenta-hojas-debajo-nivel ( 10 2 ( 4 6 ( 9 3 ) ( 8 7 ) 12 ) 1 ) 2 ) ; \u21d2 4 ( cuenta-hojas-debajo-nivel ( 10 2 ( 4 6 ( 9 3 ) ( 8 7 ) 12 ) 1 ) 3 ) ; \u21d2 0 b) Implementa la funci\u00f3n (nivel-elemento lista) que reciba una lista estructurada y devuelva una pareja (elem . nivel) , donde la parte izquierda es el elemento que se encuentra a mayor nivel y la parte derecha el nivel en el que se encuentra. Puedes definir alguna funci\u00f3n auxiliar si lo necesitas. Puedes hacerlo con recursi\u00f3n o con funciones de orden superior. 1 2 ( nivel-elemento ( 2 ( 3 ))) ;\u21d2 (3 . 2) ( nivel-elemento (( 2 ) ( 3 ( 4 )(((((( 5 ))) 6 )) 7 )) 8 )) ; \u21d2 (5 . 8) Lenguajes y Paradigmas de Programaci\u00f3n, curso 2018-19 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Domingo Gallardo, Cristina Pomares, Antonio Bot\u00eda, Francisco Mart\u00ednez","title":"Ejercicio 6"},{"location":"practicas/practica07/practica07.html","text":"Pr\u00e1ctica 7: \u00c1rboles Entrega de la pr\u00e1ctica Para entregar la pr\u00e1ctica debes subir a Moodle el fichero practica07.rkt con una cabecera inicial con tu nombre y apellidos, y las soluciones de cada ejercicio separadas por comentarios. Cada soluci\u00f3n debe incluir: La definici\u00f3n de las funciones que resuelven el ejercicio. Un conjunto de pruebas que comprueben su funcionamiento utilizando la librer\u00eda schemeunit . Ejercicios Importante : Copia al principio de la pr\u00e1ctica las funciones de las barreras de abstracci\u00f3n de \u00e1rboles y \u00e1rboles binarios y utiliza esas funciones en todos los ejercicios cuando est\u00e9s realizando operaciones sobre \u00e1rboles. Ejercicio 1 a.1) Escribe la sentencia en Scheme que define el siguiente \u00e1rbol gen\u00e9rico y escribe utilizando las funciones de la barrera de abstracci\u00f3n de \u00e1rboles una expresi\u00f3n que devuelva el n\u00famero 10. 1 2 (define arbol (_________)) (check-equal? __________ 10) a.2) Las funciones que suman los datos de un \u00e1rbol utilizando recursi\u00f3n mutua y que hemos visto en teor\u00eda son las siguientes: 1 2 3 4 5 6 7 8 9 ( define ( suma-datos-arbol arbol ) ( + ( dato-arbol arbol ) ( suma-datos-bosque ( hijos-arbol arbol )))) ( define ( suma-datos-bosque bosque ) ( if ( null? bosque ) 0 ( + ( suma-datos-arbol ( car bosque )) ( suma-datos-bosque ( cdr bosque ))))) Si realizamos la siguiente llamada a la funci\u00f3n suma-datos-bosque , siendo arbol el definido en el apartado anterior: 1 ( suma-datos-bosque ( hijos-arbol arbol )) \u00bfQu\u00e9 devuelve la invocaci\u00f3n a (suma-datos-arbol (car bosque)) que se realiza dentro de la funci\u00f3n? \u00bfQu\u00e9 devuelve la primera llamada recursiva a suma-datos-bosque ? Escribe la contestaci\u00f3n a estas preguntas como comentarios en el fichero de la pr\u00e1ctica. a.3) La funci\u00f3n de orden superior que hemos visto en teor\u00eda y que realiza tambi\u00e9n la suma de los datos de un \u00e1rbol es: 1 2 3 ( define ( suma-datos-arbol-fos arbol ) ( fold-right + ( dato-arbol arbol ) ( map suma-datos-arbol-fos ( hijos-arbol arbol )))) Si realizamos la siguiente llamada a la funci\u00f3n, siendo arbol el definido en el apartado anterior: 1 ( suma-datos-arbol-fos arbol ) \u00bfQu\u00e9 devuelve la invocaci\u00f3n a map dentro de la funci\u00f3n? \u00bfQu\u00e9 invocaciones se realizan a la funci\u00f3n + durante la ejecuci\u00f3n de fold-right sobre la lista devuelta por la invocaci\u00f3n a map ? Enum\u00e9ralas en orden, indicando sus par\u00e1metros y el valor devuelto en cada una de ellas. b.1) Escribe la sentencia en Scheme que define el siguiente \u00e1rbol binario y escribe utilizando las funciones de la barrera de abstracci\u00f3n de \u00e1rboles binarios una expresi\u00f3n que devuelva el n\u00famero 29. 1 2 (define arbolb (_________)) (check-equal? __________ 29) Ejercicio 2 Implementa dos versiones de la funci\u00f3n (to-string-arbol arbol) que recibe un \u00e1rbol de s\u00edmbolos y devuelve la cadena resultante de concatenar todos los s\u00edmbolos en recorrido preorden. Debes implementar una versi\u00f3n con recursi\u00f3n mutua y otra (llamada to-string-arbol-fos ) con una \u00fanica funci\u00f3n en la que se use funciones de orden superior. Ejemplo: 1 2 ( define arbol2 ( a ( b ( c ( d )) ( e )) ( f ))) ( to-string-arbol arbol2 ) \u21d2 abcdef Ejercicio 3 Decimos que un \u00e1rbol est\u00e1 ordenado cuando cumple las siguientes propiedades: La ra\u00edz es mayor que las ra\u00edces de sus hijos. Las ra\u00edces de sus hijos est\u00e1n en orden creciente. Todos los hijos son \u00e1rboles que est\u00e1n ordenados. Por ejemplo, en la siguiente figura, el primer \u00e1rbol est\u00e1 ordenado. El segundo \u00e1rbol no lo est\u00e1, porque las ra\u00edces de sus hijos no est\u00e1n en orden creciente. Y el tercer \u00e1rbol no lo est\u00e1 porque hay una ra\u00edz de un hijo (el \u00fanico) es mayor que la propia ra\u00edz. Implementa la funci\u00f3n (ordenado-arbol? arbol) que compruebe si un \u00e1rbol cumple las condiciones anteriores. Puedes usar FOS, recursi\u00f3n mutua y/o funciones auxiliares. Ejemplos: 1 2 3 4 5 ( ordenado-arbol? ( 10 ( 5 ) ( 7 ))) \u21d2 #t ( ordenado-arbol? ( 50 ( 10 ( 4 ) ( 6 ) ( 8 )) ( 25 ( 15 )))) \u21d2 #t ( ordenado-arbol? ( 10 ( 8 ) ( 7 ))) \u21d2 #f ( ordenado-arbol? ( 6 ( 5 ) ( 7 ))) \u21d2 #f ( ordenado-arbol? ( 50 ( 10 ( 4 ) ( 6 ) ( 11 )) ( 25 ) ( 15 ))) \u21d2 #f Ejercicio 4 a) Implementa la funci\u00f3n (veces a b arbol) que busca en el \u00e1rbol arbol los valores a y b y devuelve una pareja con el n\u00famero de veces que aparece a y el n\u00famero de veces que aparece b. Debe recorrerse el \u00e1rbol una \u00fanica vez. Los valores a y b siempre ser\u00e1n distintos. Puedes usar recursi\u00f3n o funciones de orden superior. 1 2 3 4 ( define arbol ( 1 ( 1 ( 1 )) ( 2 ( 3 ) ( 2 )) ( 1 ( 2 ) ( 3 )))) ( veces 1 2 arbol ) = { 4 . 3 } ( veces 4 3 arbol ) = { 0 . 2 } ( veces 4 5 arbol ) = { 0 . 0 } b) Define la funci\u00f3n (es-camino? lista arbol) que debe comprobar si la secuencia de elementos de la lista se corresponde con un camino del \u00e1rbol que empieza en la ra\u00edz y que termina exactamente en una hoja. Suponemos que lista contiene al menos un elemento Por ejemplo, la lista '(a b a) s\u00ed que es camino en el siguiente \u00e1rbol, pero la lista '(a b) no. Ejemplos: suponiendo que arbol es el \u00e1rbol definido por la figura anterior: 1 2 3 ( es-camino? ( a b a ) arbol ) \u21d2 #t ( es-camino? ( a b ) arbol ) \u21d2 #f ( es-camino? ( a b a b ) arbol ) \u21d2 #f c) Escribe la funci\u00f3n (nodos-nivel nivel arbol) que reciba un nivel y un \u00e1rbol gen\u00e9rico y devuelva una lista con todos los nodos que se encuentran en ese nivel. Ejemplos, suponiendo que arbol es el \u00e1rbol definido por la figura anterior: 1 2 3 4 ( nodos-nivel 0 arbol ) \u21d2 ( 1 ) ( nodos-nivel 1 arbol ) \u21d2 ( 2 6 ) ( nodos-nivel 2 arbol ) \u21d2 ( 3 5 7 ) ( nodos-nivel 3 arbol ) \u21d2 ( 4 2 ) Ejercicio 5 a) Define la funci\u00f3n (pertenece? dato arbolb) que recibe un dato y un \u00e1rbol binario ordenado y que busque eficientemente el dato (realizando el menor recorrido posible) en el \u00e1rbol binario ordenado. 1 2 3 4 5 6 7 ( define arbolb ( 40 ( 18 ( 3 () ()) ( 23 () ( 29 () ()))) ( 52 ( 47 () ()) ()))) ( pertenece? 29 arbolb ) \u21d2 #t ( pertenece? 42 arbolb ) \u21d2 #f b) Un \u00e1rbol binario est\u00e1 ordenado cuando todos sus hijos de la rama izquierda son menores que el dato de la ra\u00edz y los de la rama derecha son mayores y, a su vez, los \u00e1rboles binarios de las ramas izquierda y derecha tambi\u00e9n est\u00e1n ordenados. Escribe el procedimiento (ordenado-arbolb? arbolb) que reciba un \u00e1rbol binario como argumento y devuelva verdadero si est\u00e1 ordenado y falso si no lo est\u00e1. Pista : Implementa como funciones auxiliares las funciones (menor-arbolb arbolb) y (mayor-arbolb arbolb) que devuelvan el menor y mayor n\u00famero respectivamente de un \u00e1rbol binario. c) Dado un \u00e1rbol binario y un camino definido como una lista de s\u00edmbolos: '( = =) en el que: : indica que nos vamos por la rama izquierda : indica que nos vamos por la rama derecha = : indica que nos quedamos con el dato de ese nodo. Implementa la funci\u00f3n (camino-b-tree b-tree camino) que devuelva una lista con los datos recogidos por el camino. 1 2 ( camino-b-tree b-tree ( = = = )) \u21d2 ( 9 3 4 ) ( camino-b-tree b-tree ( = = )) \u21d2 ( 15 10 ) Lenguajes y Paradigmas de Programaci\u00f3n, curso 2018-19 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Domingo Gallardo, Cristina Pomares, Antonio Bot\u00eda, Francisco Mart\u00ednez","title":"Pr\u00e1ctica 7: \u00c1rboles"},{"location":"practicas/practica07/practica07.html#practica-7-arboles","text":"","title":"Pr\u00e1ctica 7: \u00c1rboles"},{"location":"practicas/practica07/practica07.html#entrega-de-la-practica","text":"Para entregar la pr\u00e1ctica debes subir a Moodle el fichero practica07.rkt con una cabecera inicial con tu nombre y apellidos, y las soluciones de cada ejercicio separadas por comentarios. Cada soluci\u00f3n debe incluir: La definici\u00f3n de las funciones que resuelven el ejercicio. Un conjunto de pruebas que comprueben su funcionamiento utilizando la librer\u00eda schemeunit .","title":"Entrega de la pr\u00e1ctica"},{"location":"practicas/practica07/practica07.html#ejercicios","text":"Importante : Copia al principio de la pr\u00e1ctica las funciones de las barreras de abstracci\u00f3n de \u00e1rboles y \u00e1rboles binarios y utiliza esas funciones en todos los ejercicios cuando est\u00e9s realizando operaciones sobre \u00e1rboles.","title":"Ejercicios"},{"location":"practicas/practica07/practica07.html#ejercicio-1","text":"a.1) Escribe la sentencia en Scheme que define el siguiente \u00e1rbol gen\u00e9rico y escribe utilizando las funciones de la barrera de abstracci\u00f3n de \u00e1rboles una expresi\u00f3n que devuelva el n\u00famero 10. 1 2 (define arbol (_________)) (check-equal? __________ 10) a.2) Las funciones que suman los datos de un \u00e1rbol utilizando recursi\u00f3n mutua y que hemos visto en teor\u00eda son las siguientes: 1 2 3 4 5 6 7 8 9 ( define ( suma-datos-arbol arbol ) ( + ( dato-arbol arbol ) ( suma-datos-bosque ( hijos-arbol arbol )))) ( define ( suma-datos-bosque bosque ) ( if ( null? bosque ) 0 ( + ( suma-datos-arbol ( car bosque )) ( suma-datos-bosque ( cdr bosque ))))) Si realizamos la siguiente llamada a la funci\u00f3n suma-datos-bosque , siendo arbol el definido en el apartado anterior: 1 ( suma-datos-bosque ( hijos-arbol arbol )) \u00bfQu\u00e9 devuelve la invocaci\u00f3n a (suma-datos-arbol (car bosque)) que se realiza dentro de la funci\u00f3n? \u00bfQu\u00e9 devuelve la primera llamada recursiva a suma-datos-bosque ? Escribe la contestaci\u00f3n a estas preguntas como comentarios en el fichero de la pr\u00e1ctica. a.3) La funci\u00f3n de orden superior que hemos visto en teor\u00eda y que realiza tambi\u00e9n la suma de los datos de un \u00e1rbol es: 1 2 3 ( define ( suma-datos-arbol-fos arbol ) ( fold-right + ( dato-arbol arbol ) ( map suma-datos-arbol-fos ( hijos-arbol arbol )))) Si realizamos la siguiente llamada a la funci\u00f3n, siendo arbol el definido en el apartado anterior: 1 ( suma-datos-arbol-fos arbol ) \u00bfQu\u00e9 devuelve la invocaci\u00f3n a map dentro de la funci\u00f3n? \u00bfQu\u00e9 invocaciones se realizan a la funci\u00f3n + durante la ejecuci\u00f3n de fold-right sobre la lista devuelta por la invocaci\u00f3n a map ? Enum\u00e9ralas en orden, indicando sus par\u00e1metros y el valor devuelto en cada una de ellas. b.1) Escribe la sentencia en Scheme que define el siguiente \u00e1rbol binario y escribe utilizando las funciones de la barrera de abstracci\u00f3n de \u00e1rboles binarios una expresi\u00f3n que devuelva el n\u00famero 29. 1 2 (define arbolb (_________)) (check-equal? __________ 29)","title":"Ejercicio 1"},{"location":"practicas/practica07/practica07.html#ejercicio-2","text":"Implementa dos versiones de la funci\u00f3n (to-string-arbol arbol) que recibe un \u00e1rbol de s\u00edmbolos y devuelve la cadena resultante de concatenar todos los s\u00edmbolos en recorrido preorden. Debes implementar una versi\u00f3n con recursi\u00f3n mutua y otra (llamada to-string-arbol-fos ) con una \u00fanica funci\u00f3n en la que se use funciones de orden superior. Ejemplo: 1 2 ( define arbol2 ( a ( b ( c ( d )) ( e )) ( f ))) ( to-string-arbol arbol2 ) \u21d2 abcdef","title":"Ejercicio 2"},{"location":"practicas/practica07/practica07.html#ejercicio-3","text":"Decimos que un \u00e1rbol est\u00e1 ordenado cuando cumple las siguientes propiedades: La ra\u00edz es mayor que las ra\u00edces de sus hijos. Las ra\u00edces de sus hijos est\u00e1n en orden creciente. Todos los hijos son \u00e1rboles que est\u00e1n ordenados. Por ejemplo, en la siguiente figura, el primer \u00e1rbol est\u00e1 ordenado. El segundo \u00e1rbol no lo est\u00e1, porque las ra\u00edces de sus hijos no est\u00e1n en orden creciente. Y el tercer \u00e1rbol no lo est\u00e1 porque hay una ra\u00edz de un hijo (el \u00fanico) es mayor que la propia ra\u00edz. Implementa la funci\u00f3n (ordenado-arbol? arbol) que compruebe si un \u00e1rbol cumple las condiciones anteriores. Puedes usar FOS, recursi\u00f3n mutua y/o funciones auxiliares. Ejemplos: 1 2 3 4 5 ( ordenado-arbol? ( 10 ( 5 ) ( 7 ))) \u21d2 #t ( ordenado-arbol? ( 50 ( 10 ( 4 ) ( 6 ) ( 8 )) ( 25 ( 15 )))) \u21d2 #t ( ordenado-arbol? ( 10 ( 8 ) ( 7 ))) \u21d2 #f ( ordenado-arbol? ( 6 ( 5 ) ( 7 ))) \u21d2 #f ( ordenado-arbol? ( 50 ( 10 ( 4 ) ( 6 ) ( 11 )) ( 25 ) ( 15 ))) \u21d2 #f","title":"Ejercicio 3"},{"location":"practicas/practica07/practica07.html#ejercicio-4","text":"a) Implementa la funci\u00f3n (veces a b arbol) que busca en el \u00e1rbol arbol los valores a y b y devuelve una pareja con el n\u00famero de veces que aparece a y el n\u00famero de veces que aparece b. Debe recorrerse el \u00e1rbol una \u00fanica vez. Los valores a y b siempre ser\u00e1n distintos. Puedes usar recursi\u00f3n o funciones de orden superior. 1 2 3 4 ( define arbol ( 1 ( 1 ( 1 )) ( 2 ( 3 ) ( 2 )) ( 1 ( 2 ) ( 3 )))) ( veces 1 2 arbol ) = { 4 . 3 } ( veces 4 3 arbol ) = { 0 . 2 } ( veces 4 5 arbol ) = { 0 . 0 } b) Define la funci\u00f3n (es-camino? lista arbol) que debe comprobar si la secuencia de elementos de la lista se corresponde con un camino del \u00e1rbol que empieza en la ra\u00edz y que termina exactamente en una hoja. Suponemos que lista contiene al menos un elemento Por ejemplo, la lista '(a b a) s\u00ed que es camino en el siguiente \u00e1rbol, pero la lista '(a b) no. Ejemplos: suponiendo que arbol es el \u00e1rbol definido por la figura anterior: 1 2 3 ( es-camino? ( a b a ) arbol ) \u21d2 #t ( es-camino? ( a b ) arbol ) \u21d2 #f ( es-camino? ( a b a b ) arbol ) \u21d2 #f c) Escribe la funci\u00f3n (nodos-nivel nivel arbol) que reciba un nivel y un \u00e1rbol gen\u00e9rico y devuelva una lista con todos los nodos que se encuentran en ese nivel. Ejemplos, suponiendo que arbol es el \u00e1rbol definido por la figura anterior: 1 2 3 4 ( nodos-nivel 0 arbol ) \u21d2 ( 1 ) ( nodos-nivel 1 arbol ) \u21d2 ( 2 6 ) ( nodos-nivel 2 arbol ) \u21d2 ( 3 5 7 ) ( nodos-nivel 3 arbol ) \u21d2 ( 4 2 )","title":"Ejercicio 4"},{"location":"practicas/practica07/practica07.html#ejercicio-5","text":"a) Define la funci\u00f3n (pertenece? dato arbolb) que recibe un dato y un \u00e1rbol binario ordenado y que busque eficientemente el dato (realizando el menor recorrido posible) en el \u00e1rbol binario ordenado. 1 2 3 4 5 6 7 ( define arbolb ( 40 ( 18 ( 3 () ()) ( 23 () ( 29 () ()))) ( 52 ( 47 () ()) ()))) ( pertenece? 29 arbolb ) \u21d2 #t ( pertenece? 42 arbolb ) \u21d2 #f b) Un \u00e1rbol binario est\u00e1 ordenado cuando todos sus hijos de la rama izquierda son menores que el dato de la ra\u00edz y los de la rama derecha son mayores y, a su vez, los \u00e1rboles binarios de las ramas izquierda y derecha tambi\u00e9n est\u00e1n ordenados. Escribe el procedimiento (ordenado-arbolb? arbolb) que reciba un \u00e1rbol binario como argumento y devuelva verdadero si est\u00e1 ordenado y falso si no lo est\u00e1. Pista : Implementa como funciones auxiliares las funciones (menor-arbolb arbolb) y (mayor-arbolb arbolb) que devuelvan el menor y mayor n\u00famero respectivamente de un \u00e1rbol binario. c) Dado un \u00e1rbol binario y un camino definido como una lista de s\u00edmbolos: '( = =) en el que: : indica que nos vamos por la rama izquierda : indica que nos vamos por la rama derecha = : indica que nos quedamos con el dato de ese nodo. Implementa la funci\u00f3n (camino-b-tree b-tree camino) que devuelva una lista con los datos recogidos por el camino. 1 2 ( camino-b-tree b-tree ( = = = )) \u21d2 ( 9 3 4 ) ( camino-b-tree b-tree ( = = )) \u21d2 ( 15 10 ) Lenguajes y Paradigmas de Programaci\u00f3n, curso 2018-19 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Domingo Gallardo, Cristina Pomares, Antonio Bot\u00eda, Francisco Mart\u00ednez","title":"Ejercicio 5"},{"location":"practicas/practica08/practica08.html","text":"Pr\u00e1ctica 8: Programaci\u00f3n funcional en Swift (1) Entrega de la pr\u00e1ctica Para entregar la pr\u00e1ctica debes subir a Moodle el fichero practica08.swift con una cabecera inicial con tu nombre y apellidos, y las soluciones de cada ejercicio separadas por comentarios. Cada soluci\u00f3n debe incluir: La definici\u00f3n de las funciones que resuelven el ejercicio. Una visualizaci\u00f3n por pantalla de todos los ejemplos incluidos en el enunciado que demuestren qu\u00e9 hace la funci\u00f3n . Importante Antes de proceder a realizar los ejercicios de la pr\u00e1ctica, debes completar el seminario de Swift hasta el apartado de Enumeraciones . Y, evidentemente, los apuntes de teor\u00eda de la semana pasada. En la pr\u00e1ctica hay m\u00e1s de un ejercicio en el que tienes que trabajar con Arrays. Es conveniente que consultes el apartado sobre Arrays en la p\u00e1gina Collection Types de la gu\u00eda de Swift. Ejercicios Ejercicio 1 Escribe una funci\u00f3n en Swift obtenerFrencuencias que permita calcular las frecuencias de un conjunto de respuestas, n\u00fameros entre 0 y 9, que se guardan en un array de Int . Y otra imprimir que permita representar las frecuencias calculadas en forma de histograma. Como ejemplo de uso de las funciones puedes ver el siguiente c\u00f3digo. El par\u00e1metro maxAsteriscos define el n\u00famero de asteriscos con el que representaremos la frecuencia m\u00e1xima en la gr\u00e1fica de histogramas. Todos los dem\u00e1s asteriscos est\u00e1n escalados proporcionalmente a este n\u00famero m\u00e1ximo. 1 2 3 4 5 6 7 let respuestas = [ 0 , 0 , 1 , 1 , 2 , 1 , 2 , 3 , 5 , 1 , 2 , 2 , 2 , 6 ] print ( Valores: \\( respuestas ) ) let frec = obtenerFrecuencias ( respuestas : respuestas ) print ( Frecuencias: \\( frec ) ) print ( \\n Histograma ) print ( ---------- ) imprimir ( frecuencias : frec , maxAsteriscos : 10 ) Sacar\u00eda por pantalla lo siguiente: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 Valores: [0, 0, 1, 1, 2, 1, 2, 3, 5, 1, 2, 2, 2, 6] Frecuencias: [2, 4, 5, 1, 0, 1, 1, 0, 0, 0] Histograma ---------- 0: **** 1: ******** 2: ********** 3: ** 4: 5: ** 6: ** 7: 8: 9: Ejercicio 2 Implementa en Swift la funci\u00f3n recursiva compruebaParejas(_:funcion:) con el siguiente perfil: 1 ([Int], (Int) - Int) - [(Int, Int)] La funci\u00f3n recibe dos par\u00e1metros: un Array de enteros y una funci\u00f3n que recibe un entero y devuelve un entero. La funci\u00f3n devolver\u00e1 un array de tuplas que contiene las tuplas formadas por aquellos n\u00fameros contiguos del primer array que cumplan que el n\u00famero es el resultado de aplicar la funci\u00f3n al n\u00famero situado en la posici\u00f3n anterior. Ejemplo: 1 2 3 4 5 func cuadrado ( x : Int ) - Int { return x * x } print ( compruebaParejas ([ 2 , 4 , 16 , 5 , 10 , 100 , 105 ], funcion : cuadrado )) // Imprime [(2,4), (4,16), (10,100)] Ejercicio 3 Implementa en Swift un tipo enumerado recursivo que permita construir \u00e1rboles binarios de enteros. El enumerado debe tener un caso en el que guardar tres valores: un Int y dos \u00e1rboles binarios (el hijo izquierdo y el hijo derecho) otro caso constante: un \u00e1rbol binario vac\u00edo Llamaremos al tipo ArbolBinario y a los casos nodo y vacio . Implem\u00e9ntalo de forma que el siguiente ejemplo funcione correctamente: 1 let arbol : ArbolBinario = . nodo ( 8 , . nodo ( 2 , . vacio , . vacio ), . nodo ( 12 , . vacio , . vacio )) Implementa tambi\u00e9n la funci\u00f3n suma(arbolb:) que reciba una instancia de \u00e1rbol binario y devuelva la suma de todos sus nodos: 1 2 print ( suma ( arbolb : arbol )) // Imprime: 22 Ejercicio 4 Implementa en Swift la funci\u00f3n recursiva coinciden(parejas: [(Int,Int)], funcion: (Int)- Int) que devuelve un array de booleanos que indica si el resultado de aplicar la funci\u00f3n al primer n\u00famero de cada pareja coincide con el segundo. 1 2 3 4 5 6 let array = [( 2 , 4 ), ( 4 , 14 ), ( 4 , 16 ), ( 5 , 25 ), ( 10 , 100 )] func cuadrado ( x : Int ) - Int { return x * x } print ( Resultado coinciden: \\( coinciden ( parejas : array , funcion : cuadrado )) \\n ) // Imprime: Resultado coinciden: [true, false, true, true, true] Ejercicio 5 Supongamos que estamos escribiendo un programa que debe tratar movimientos de cuentas bancarias. Define un enumerado Movimiento con valores asociados con el que podamos representar: Dep\u00f3sito (valor asociado: (Double) ) Cargo de un recibo (valor asociado: (String, Double) ) Cajero (valor asociado: (Double) ) Y define la funci\u00f3n aplica(movimientos:[Movimiento]) que reciba un array de movimientos y devuelva una pareja con el dinero resultante de acumular todos los movimientos y un array de Strings con todos los cargos realizados. Ejemplo: 1 2 3 let movimientos : [ Movimiento ] = [. deposito ( 830.0 ), . cargoRecibo ( Gimnasio , 45.0 ), . deposito ( 400.0 ), . cajero ( 100.0 ), . cargoRecibo ( Fnac , 38.70 )] print ( aplica ( movimientos : movimientos )) //Imprime (1046.3, [ Gimnasio , Fnac ]) Ejercicio 6 Implementa en Swift un tipo enumerado recursivo que permita construir \u00e1rboles gen\u00e9ricos de enteros usando el mismo enfoque que en Scheme: un nodo est\u00e1 formado por un dato (un Int ) y una colecci\u00f3n de \u00e1rboles hijos. Llamaremos al tipo Arbol . Implem\u00e9ntalo de forma que el siguiente ejemplo funcione correctamente: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 /* Definimos el \u00e1rbol 10 / | \\ 3 5 8 | 1 */ let arbol1 = Arbol . nodo ( 10 , []) let arbol3 = Arbol . nodo ( 3 , [ arbol1 ]) let arbol5 = Arbol . nodo ( 5 , []) let arbol8 = Arbol . nodo ( 8 , []) let arbol10 = Arbol . nodo ( 10 , [ arbol3 , arbol5 , arbol8 ]) Implementa tambi\u00e9n la funci\u00f3n suma(arbol:cumplen:) que reciba una instancia de \u00e1rbol gen\u00e9rico y una funci\u00f3n (Int) - Bool que comprueba una condici\u00f3n sobre el nodo. La funci\u00f3n debe devolver la suma de todos los nodos del \u00e1rbol que cumplan la condici\u00f3n. Implementa la funci\u00f3n usando la misma estrategia que ya utilizamos en Scheme de definir una funci\u00f3n auxiliar suma(bosque:cumplen:) y una recursi\u00f3n mutua. 1 2 3 4 5 6 func esPar ( x : Int ) - Bool { return x % 2 == 0 } print ( La suma del \u00e1rbol gen\u00e9rico es: \\( suma ( arbol : arbol10 , cumplen : esPar )) ) // Imprime: La suma del \u00e1rbol gen\u00e9rico es: 28 Lenguajes y Paradigmas de Programaci\u00f3n, curso 2018-19 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Domingo Gallardo, Cristina Pomares, Antonio Bot\u00eda, Francisco Mart\u00ednez","title":"Pr\u00e1ctica 8: Programaci\u00f3n funcional en Swift (1)"},{"location":"practicas/practica08/practica08.html#practica-8-programacion-funcional-en-swift-1","text":"","title":"Pr\u00e1ctica 8: Programaci\u00f3n funcional en Swift (1)"},{"location":"practicas/practica08/practica08.html#entrega-de-la-practica","text":"Para entregar la pr\u00e1ctica debes subir a Moodle el fichero practica08.swift con una cabecera inicial con tu nombre y apellidos, y las soluciones de cada ejercicio separadas por comentarios. Cada soluci\u00f3n debe incluir: La definici\u00f3n de las funciones que resuelven el ejercicio. Una visualizaci\u00f3n por pantalla de todos los ejemplos incluidos en el enunciado que demuestren qu\u00e9 hace la funci\u00f3n . Importante Antes de proceder a realizar los ejercicios de la pr\u00e1ctica, debes completar el seminario de Swift hasta el apartado de Enumeraciones . Y, evidentemente, los apuntes de teor\u00eda de la semana pasada. En la pr\u00e1ctica hay m\u00e1s de un ejercicio en el que tienes que trabajar con Arrays. Es conveniente que consultes el apartado sobre Arrays en la p\u00e1gina Collection Types de la gu\u00eda de Swift.","title":"Entrega de la pr\u00e1ctica"},{"location":"practicas/practica08/practica08.html#ejercicios","text":"","title":"Ejercicios"},{"location":"practicas/practica08/practica08.html#ejercicio-1","text":"Escribe una funci\u00f3n en Swift obtenerFrencuencias que permita calcular las frecuencias de un conjunto de respuestas, n\u00fameros entre 0 y 9, que se guardan en un array de Int . Y otra imprimir que permita representar las frecuencias calculadas en forma de histograma. Como ejemplo de uso de las funciones puedes ver el siguiente c\u00f3digo. El par\u00e1metro maxAsteriscos define el n\u00famero de asteriscos con el que representaremos la frecuencia m\u00e1xima en la gr\u00e1fica de histogramas. Todos los dem\u00e1s asteriscos est\u00e1n escalados proporcionalmente a este n\u00famero m\u00e1ximo. 1 2 3 4 5 6 7 let respuestas = [ 0 , 0 , 1 , 1 , 2 , 1 , 2 , 3 , 5 , 1 , 2 , 2 , 2 , 6 ] print ( Valores: \\( respuestas ) ) let frec = obtenerFrecuencias ( respuestas : respuestas ) print ( Frecuencias: \\( frec ) ) print ( \\n Histograma ) print ( ---------- ) imprimir ( frecuencias : frec , maxAsteriscos : 10 ) Sacar\u00eda por pantalla lo siguiente: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 Valores: [0, 0, 1, 1, 2, 1, 2, 3, 5, 1, 2, 2, 2, 6] Frecuencias: [2, 4, 5, 1, 0, 1, 1, 0, 0, 0] Histograma ---------- 0: **** 1: ******** 2: ********** 3: ** 4: 5: ** 6: ** 7: 8: 9:","title":"Ejercicio 1"},{"location":"practicas/practica08/practica08.html#ejercicio-2","text":"Implementa en Swift la funci\u00f3n recursiva compruebaParejas(_:funcion:) con el siguiente perfil: 1 ([Int], (Int) - Int) - [(Int, Int)] La funci\u00f3n recibe dos par\u00e1metros: un Array de enteros y una funci\u00f3n que recibe un entero y devuelve un entero. La funci\u00f3n devolver\u00e1 un array de tuplas que contiene las tuplas formadas por aquellos n\u00fameros contiguos del primer array que cumplan que el n\u00famero es el resultado de aplicar la funci\u00f3n al n\u00famero situado en la posici\u00f3n anterior. Ejemplo: 1 2 3 4 5 func cuadrado ( x : Int ) - Int { return x * x } print ( compruebaParejas ([ 2 , 4 , 16 , 5 , 10 , 100 , 105 ], funcion : cuadrado )) // Imprime [(2,4), (4,16), (10,100)]","title":"Ejercicio 2"},{"location":"practicas/practica08/practica08.html#ejercicio-3","text":"Implementa en Swift un tipo enumerado recursivo que permita construir \u00e1rboles binarios de enteros. El enumerado debe tener un caso en el que guardar tres valores: un Int y dos \u00e1rboles binarios (el hijo izquierdo y el hijo derecho) otro caso constante: un \u00e1rbol binario vac\u00edo Llamaremos al tipo ArbolBinario y a los casos nodo y vacio . Implem\u00e9ntalo de forma que el siguiente ejemplo funcione correctamente: 1 let arbol : ArbolBinario = . nodo ( 8 , . nodo ( 2 , . vacio , . vacio ), . nodo ( 12 , . vacio , . vacio )) Implementa tambi\u00e9n la funci\u00f3n suma(arbolb:) que reciba una instancia de \u00e1rbol binario y devuelva la suma de todos sus nodos: 1 2 print ( suma ( arbolb : arbol )) // Imprime: 22","title":"Ejercicio 3"},{"location":"practicas/practica08/practica08.html#ejercicio-4","text":"Implementa en Swift la funci\u00f3n recursiva coinciden(parejas: [(Int,Int)], funcion: (Int)- Int) que devuelve un array de booleanos que indica si el resultado de aplicar la funci\u00f3n al primer n\u00famero de cada pareja coincide con el segundo. 1 2 3 4 5 6 let array = [( 2 , 4 ), ( 4 , 14 ), ( 4 , 16 ), ( 5 , 25 ), ( 10 , 100 )] func cuadrado ( x : Int ) - Int { return x * x } print ( Resultado coinciden: \\( coinciden ( parejas : array , funcion : cuadrado )) \\n ) // Imprime: Resultado coinciden: [true, false, true, true, true]","title":"Ejercicio 4"},{"location":"practicas/practica08/practica08.html#ejercicio-5","text":"Supongamos que estamos escribiendo un programa que debe tratar movimientos de cuentas bancarias. Define un enumerado Movimiento con valores asociados con el que podamos representar: Dep\u00f3sito (valor asociado: (Double) ) Cargo de un recibo (valor asociado: (String, Double) ) Cajero (valor asociado: (Double) ) Y define la funci\u00f3n aplica(movimientos:[Movimiento]) que reciba un array de movimientos y devuelva una pareja con el dinero resultante de acumular todos los movimientos y un array de Strings con todos los cargos realizados. Ejemplo: 1 2 3 let movimientos : [ Movimiento ] = [. deposito ( 830.0 ), . cargoRecibo ( Gimnasio , 45.0 ), . deposito ( 400.0 ), . cajero ( 100.0 ), . cargoRecibo ( Fnac , 38.70 )] print ( aplica ( movimientos : movimientos )) //Imprime (1046.3, [ Gimnasio , Fnac ])","title":"Ejercicio 5"},{"location":"practicas/practica08/practica08.html#ejercicio-6","text":"Implementa en Swift un tipo enumerado recursivo que permita construir \u00e1rboles gen\u00e9ricos de enteros usando el mismo enfoque que en Scheme: un nodo est\u00e1 formado por un dato (un Int ) y una colecci\u00f3n de \u00e1rboles hijos. Llamaremos al tipo Arbol . Implem\u00e9ntalo de forma que el siguiente ejemplo funcione correctamente: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 /* Definimos el \u00e1rbol 10 / | \\ 3 5 8 | 1 */ let arbol1 = Arbol . nodo ( 10 , []) let arbol3 = Arbol . nodo ( 3 , [ arbol1 ]) let arbol5 = Arbol . nodo ( 5 , []) let arbol8 = Arbol . nodo ( 8 , []) let arbol10 = Arbol . nodo ( 10 , [ arbol3 , arbol5 , arbol8 ]) Implementa tambi\u00e9n la funci\u00f3n suma(arbol:cumplen:) que reciba una instancia de \u00e1rbol gen\u00e9rico y una funci\u00f3n (Int) - Bool que comprueba una condici\u00f3n sobre el nodo. La funci\u00f3n debe devolver la suma de todos los nodos del \u00e1rbol que cumplan la condici\u00f3n. Implementa la funci\u00f3n usando la misma estrategia que ya utilizamos en Scheme de definir una funci\u00f3n auxiliar suma(bosque:cumplen:) y una recursi\u00f3n mutua. 1 2 3 4 5 6 func esPar ( x : Int ) - Bool { return x % 2 == 0 } print ( La suma del \u00e1rbol gen\u00e9rico es: \\( suma ( arbol : arbol10 , cumplen : esPar )) ) // Imprime: La suma del \u00e1rbol gen\u00e9rico es: 28 Lenguajes y Paradigmas de Programaci\u00f3n, curso 2018-19 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Domingo Gallardo, Cristina Pomares, Antonio Bot\u00eda, Francisco Mart\u00ednez","title":"Ejercicio 6"},{"location":"practicas/practica09/practica09.html","text":"Pr\u00e1ctica 9: Programaci\u00f3n funcional en Swift: clausuras y funciones de orden superior Entrega de la pr\u00e1ctica Para entregar la pr\u00e1ctica debes subir a Moodle el fichero practica09.swift con una cabecera inicial con tu nombre y apellidos, y las soluciones de cada ejercicio separadas por comentarios. Cada soluci\u00f3n debe incluir: La definici\u00f3n de las funciones que resuelven el ejercicio. Una visualizaci\u00f3n por pantalla de todos los ejemplos incluidos en el enunciado que demuestren qu\u00e9 hace la funci\u00f3n . Ejercicios Ejercicio 1 a) Indica qu\u00e9 devuelven las siguientes expresiones: a.1) 1 2 let nums = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] nums . filter { $0 % 3 == 0 }. count a.2) 1 2 let nums2 = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] nums2 . map { $0 + 100 }. filter { $0 % 5 == 0 }. reduce ( 0 , + ) a.3) 1 2 let cadenas = [ En , un , lugar , de , La , Mancha ] cadenas . sorted { $0 . count $1 . count }. map { $0 . count } a.4) 1 2 3 let cadenas2 = [ En , un , lugar , de , La , Mancha ] cadenas2 . reduce ([]) {( res : [( String , Int )], c : String ) - [( String , Int )] in res + [( c , c . count )]}. sorted ( by : { $0 . 1 $1 . 1 }) b) Explica qu\u00e9 hacen las siguientes funciones y pon un ejemplo de su funcionamiento: b.1) 1 2 3 func f ( nums : [ Int ], n : Int ) - Int { return nums . filter { $0 == n }. count } b.2) 1 2 3 4 5 6 7 8 9 func g ( nums : [ Int ]) - [ Int ] { return nums . reduce ([], {( res : [ Int ], n : Int ) - [ Int ] in if ! res . contains ( n ) { return res + [ n ] } else { return res } }) } b.3) 1 2 3 4 5 6 7 8 9 func h ( nums : [ Int ], n : Int ) - ([ Int ], [ Int ]) { return nums . reduce (([],[]), {( res : ([ Int ],[ Int ]), num : Int ) - ([ Int ],[ Int ]) in if ( num = n ) { return ( res . 0 , res . 1 + [ num ]) } else { return (( res . 0 + [ num ], res . 1 )) } }) } c) Implementa las siguientes funciones con funciones de orden superior. c.1) Funci\u00f3n suma(palabras:contienen:) : 1 suma ( palabras : [ String ], contienen : Character ) - Int que recibe una array de cadenas y devuelve la suma de las longitudes de las cadenas que contiene el car\u00e1cter que se pasa como par\u00e1metro. c.2) Funci\u00f3n sumaMenoresMayores(nums:pivote:) : 1 sumaMenoresMayores ( nums : [ Int ], pivote : Int ) - ( Int , Int ) que recibe un array de n\u00fameros y un n\u00famero pivote y devuelve una tupla con la suma de los n\u00fameros menores y mayores o iguales que el pivote. Ejercicio 2 Define un tipo enumerado con un \u00e1rbol gen\u00e9rico, tal y como hicimos en el \u00faltimo ejercicio de la pr\u00e1ctica anterior, que tenga como gen\u00e9rico el tipo de dato que contiene. En el siguiente ejemplo vemos c\u00f3mo deber\u00eda poderse definir con el mismo tipo gen\u00e9rico un \u00e1rbol de enteros y un \u00e1rbol de cadenas: 1 2 3 let arbolInt : Arbol = . nodo ( 53 , [. nodo ( 13 , []), . nodo ( 32 , []), . nodo ( 41 , [. nodo ( 36 , []), . nodo ( 39 , [])])]) let arbolString : Arbol = . nodo ( Zamora , [. nodo ( Buend\u00eda , [. nodo ( Albeza , []), . nodo ( Berenguer , []), . nodo ( Bolardo , [])]), . nodo ( Galv\u00e1n , [])]) Define las funciones gen\u00e9ricas toArray y toArrayFOS que devuelvan un array con todos los componentes del \u00e1rbol usando un recorrido preorden (primero la ra\u00edz y despu\u00e9s los hijos). La primera la debes implementar con recursi\u00f3n mutua y la segunda usando funciones de orden superior. Ejemplo: 1 2 3 4 print ( toArray ( arbol : arbolInt )) // Imprime: [53, 13, 32, 41, 36, 39] print ( toArrayFOS ( arbol : arbolString )) // Imprime: [ Zamora , Buend\u00eda , Albeza , Berenguer , Bolardo , Galv\u00e1n ] Ejercicio 3 Implementa en Swift la funci\u00f3n imprimirListadosNotas(alumnos:) que recibe un array de tuplas, en donde cada tupla contiene informaci\u00f3n de la evaluaci\u00f3n de un alumno de LPP (nombreAlumno, notaParcial1, notaParcial2, notaCuestionarios, a\u00f1osMatriculacion) y que debe imprimir por pantalla los siguientes listados: listado 1: array ordenado por nombre del alumno (orden alfab\u00e9tico creciente) listado 2: array ordenado por la nota del parcial 1 (orden decreciente de nota) listado 3: array ordenado por la nota del parcial 2 (orden creciente de nota) listado 4: array ordenado por a\u00f1o de matriculaci\u00f3n y nota del cuestionario (orden decreciente de a\u00f1o y nota) listado 5: array ordenado por nota que necesita obtener en el parcial 3 para aprobar la asignatura en la convocatoria de Junio (orden decreciente de nota necesaria) AYUDA: Para que los listados se muestren formateados con espacios, puedes usar la siguiente funci\u00f3n (para ello tambi\u00e9n debes incluir el import que se indica) 1 2 3 4 5 6 7 8 9 10 import Foundation func imprimirListadoAlumnos ( _ alumnos : [( String , Double , Double , Double , Int )]) { print ( Alumno Parcial1 Parcial2 Cuest A\u00f1os ) for alu in alumnos { alu . 0. withCString { print ( String ( format : %-10s %5.2f %5.2f %5.2f %3d , $0 , alu . 1 , alu . 2 , alu . 3 , alu . 4 )) } } } Ejemplo: 1 2 3 4 5 6 7 8 9 let listaAlumnos = [( Pepe , 8.45 , 3.75 , 6.05 , 1 ), ( Maria , 9.1 , 7.5 , 8.18 , 1 ), ( Jose , 8.0 , 6.65 , 7.96 , 1 ), ( Carmen , 6.25 , 1.2 , 5.41 , 2 ), ( Felipe , 5.65 , 0.25 , 3.16 , 3 ), ( Carla , 6.25 , 1.25 , 4.23 , 2 ), ( Luis , 6.75 , 0.25 , 4.63 , 2 ), ( Loli , 3.0 , 1.25 , 2.19 , 3 )] imprimirListadosNotas ( listaAlumnos ) Algunos de los listados que se deben mostrar ser\u00edan los siguientes: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 LISTADO ORIGINAL Alumno Parcial1 Parcial2 Cuest A\u00f1os Pepe 8.45 3.75 6.05 1 Maria 9.10 7.50 8.18 1 Jose 8.00 6.65 7.96 1 Carmen 6.25 1.20 5.41 2 Felipe 5.65 0.25 3.16 3 Carla 6.25 1.25 4.23 2 Luis 6.75 0.25 4.63 2 Loli 3.00 1.25 2.19 3 LISTADO ORDENADO por Parcial1 Alumno Parcial1 Parcial2 Cuest A\u00f1os Maria 9.10 7.50 8.18 1 Pepe 8.45 3.75 6.05 1 Jose 8.00 6.65 7.96 1 Luis 6.75 0.25 4.63 2 Carmen 6.25 1.20 5.41 2 Carla 6.25 1.25 4.23 2 Felipe 5.65 0.25 3.16 3 Loli 3.00 1.25 2.19 3 LISTADO ORDENADO por Nota para aprobar en Junio Alumno Parcial1 Parcial2 Cuest A\u00f1os Maria 9.10 7.50 8.18 1 Jose 8.00 6.65 7.96 1 Pepe 8.45 3.75 6.05 1 Carmen 6.25 1.20 5.41 2 Carla 6.25 1.25 4.23 2 Luis 6.75 0.25 4.63 2 Felipe 5.65 0.25 3.16 3 Loli 3.00 1.25 2.19 3 Ejercicio 4 Dado el array listaAlumnos del ejercicio anterior, utiliza funciones de orden superior para obtener los datos requeridos en cada caso A) N\u00famero de alumnos que han aprobado primer parcial y suspendido el segundo 1 2 print ( listaAlumnos . ________________________________ ) // Resultado: 5 B) Nota que deben tener en el parcial 3 para sacar un 5 en la nota final 1 2 3 4 print ( listaAlumnos . _______________________________ ) // Resultado: // [2.4500000000000011, -2.6599999999999984, -0.63666666666666671, 7.4133333333333331, 9.7133333333333347, 7.7566666666666677, 8.1233333333333348, 11.686666666666667] C) Nota media de todos los alumnos en forma de tupla (media_p1, media_p2, media_cuest) 1 2 3 4 var tupla = listaAlumnos . _____________________________________ ) tupla = ( tupla . 0 / Double ( listaAlumnos . count ), tupla . 1 / Double ( listaAlumnos . count ), tupla . 2 / Double ( listaAlumnos . count )) print ( tupla ) // Resultado: (6.6812499999999995, 2.7624999999999997, 5.2262500000000003) Ejercicio 5 Queremos escribir la funci\u00f3n calcular(exp: String, sobre: [(Double, Double)]) que recibe una cadena que codifica una expresi\u00f3n sobre una tupla y una lista de tuplas y devuelve el resultado de aplicar esa expresi\u00f3n matem\u00e1tica sobre cada una de las tuplas de la lista. Por ejemplo: 1 2 3 4 5 6 7 8 let tuplas = [( 1.0 , 2.5 ), ( 10.8 , 3.3 ), ( - 1.0 , 12.0 ), ( - 3.4 , 4.0 )] print ( calcular ( exp : $1 * 2.0 , sobre : tuplas ) ! ) // [5.0, 6.5999999999999996, 24.0, 8.0] print ( calcular ( exp : $0 - 5.0 , sobre : tuplas ) ! ) // [-4.0, 5.8000000000000007, -6.0, -8.4000000000000004] print ( calcular ( exp : $0 + $1 , sobre : tuplas ) ! ) // [3.5, 14.100000000000001, 11.0, 0.60000000000000009] En el primer ejemplo la expresi\u00f3n indica que hay que multiplicar el segundo n\u00famero de cada tupla por 2.0. En el segundo ejemplo la expresi\u00f3n indica que hay que restar al primer n\u00famero de cada tupla 5.0. En el tercer ejemplo la expresi\u00f3n indica que hay que sumar el primer y el segundo elemento de cada tupla. La expresi\u00f3n codificada tendr\u00e1 siempre dos operandos y una operaci\u00f3n. Los operandos pueden ser las expresiones $0 y $1 para referirse al primer y segundo elemento de cada tupla o n\u00fameros decimales. La operaci\u00f3n puede ser + , - , * y / para referirse a las operaciones suma, resta, multiplicaci\u00f3n y divisi\u00f3n. Vamos a realizar el ejercicio en tres partes. Primero hay que implementar una funci\u00f3n que analiza la cadena y devuelve una tupla de enumerados; despu\u00e9s una funci\u00f3n convertir\u00e1 la tupla de enumerados en una clausura y por \u00faltimo la funci\u00f3n principal que usa las anteriores y aplica la clausura al array de tuplas. Vamos a detallar cada una de las partes. a) En primer lugar debes implementar la funci\u00f3n parse(exp:) que analice la cadena y la transforme en una tupla de dos operandos y una operaci\u00f3n, siendo \u00e9stos los siguientes tipos enumerados: 1 2 3 4 5 6 7 8 9 10 11 12 enum Operando { case primero case segundo case valor ( Double ) } enum Operacion { case suma case resta case mult case div } La funci\u00f3n parse(exp:) tiene el siguiente perfil: 1 func parse ( exp : String ) - ( op1 : Operando , op2 : Operando , op : Operacion )? Tendr\u00e1s que definir funciones auxiliares para implementar esta funci\u00f3n. AYUDA : Para construir un array con las palabras que aparecen en la frase, puedes usar la siguiente sentencia: 1 let arrayPalabras = frase . split ( separator : ). map ( String . init ) Ejemplos: 1 2 3 4 5 6 parse ( $0 + $1 ) // Devuelve opcional con la tupla (Operando.primero, Operando.segundo, Operacion.suma) parse ( 5.0 * $1 ) // Devuelve opcional con la tupla (Operando.valor(5.0), Operando.segundo, Operacion.mult) parse ( Hola ) // Devuelve nil b) En segundo lugar debes implementar la funci\u00f3n construyeFunc(op1:op2:op:) que recibe los enumerados que representan la expresi\u00f3n matem\u00e1tica y devuelve una clausura que aplica la expresi\u00f3n matem\u00e1tica a una tupla. La funci\u00f3n tiene el siguiente perfil: 1 func construyeFunc ( op1 : Operando , op2 : Operando , op : Operacion ) - (( Double , Double )) - Double Tambi\u00e9n es conveniente que definas funciones auxiliares . Nota La clausura que se devuelve puede ser una clausura que captura los par\u00e1metros `op1`, `op2` y `op` y que los usa en su cuerpo. De esta forma podemos hacer una clausura gen\u00e9rica que llama a las funciones auxiliares y evitamos tener que escribir un n\u00famero enorme de clasuras concretas con todas las posibles combinaciones de tuplas y operadores. c) Por \u00faltimo debes implementar la funci\u00f3n calcular(exp:sobre:) con el siguiente perfil: 1 func calcular ( exp str : String , sobre tuplas : Array ( Double , Double ) ) - [ Double ]? Lenguajes y Paradigmas de Programaci\u00f3n, curso 2018-19 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Domingo Gallardo, Cristina Pomares, Antonio Bot\u00eda, Francisco Mart\u00ednez","title":"Pr\u00e1ctica 9: Programaci\u00f3n funcional en Swift: clausuras y funciones de orden superior"},{"location":"practicas/practica09/practica09.html#practica-9-programacion-funcional-en-swift-clausuras-y-funciones-de-orden-superior","text":"","title":"Pr\u00e1ctica 9: Programaci\u00f3n funcional en Swift: clausuras y funciones de orden superior"},{"location":"practicas/practica09/practica09.html#entrega-de-la-practica","text":"Para entregar la pr\u00e1ctica debes subir a Moodle el fichero practica09.swift con una cabecera inicial con tu nombre y apellidos, y las soluciones de cada ejercicio separadas por comentarios. Cada soluci\u00f3n debe incluir: La definici\u00f3n de las funciones que resuelven el ejercicio. Una visualizaci\u00f3n por pantalla de todos los ejemplos incluidos en el enunciado que demuestren qu\u00e9 hace la funci\u00f3n .","title":"Entrega de la pr\u00e1ctica"},{"location":"practicas/practica09/practica09.html#ejercicios","text":"","title":"Ejercicios"},{"location":"practicas/practica09/practica09.html#ejercicio-1","text":"a) Indica qu\u00e9 devuelven las siguientes expresiones: a.1) 1 2 let nums = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] nums . filter { $0 % 3 == 0 }. count a.2) 1 2 let nums2 = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] nums2 . map { $0 + 100 }. filter { $0 % 5 == 0 }. reduce ( 0 , + ) a.3) 1 2 let cadenas = [ En , un , lugar , de , La , Mancha ] cadenas . sorted { $0 . count $1 . count }. map { $0 . count } a.4) 1 2 3 let cadenas2 = [ En , un , lugar , de , La , Mancha ] cadenas2 . reduce ([]) {( res : [( String , Int )], c : String ) - [( String , Int )] in res + [( c , c . count )]}. sorted ( by : { $0 . 1 $1 . 1 }) b) Explica qu\u00e9 hacen las siguientes funciones y pon un ejemplo de su funcionamiento: b.1) 1 2 3 func f ( nums : [ Int ], n : Int ) - Int { return nums . filter { $0 == n }. count } b.2) 1 2 3 4 5 6 7 8 9 func g ( nums : [ Int ]) - [ Int ] { return nums . reduce ([], {( res : [ Int ], n : Int ) - [ Int ] in if ! res . contains ( n ) { return res + [ n ] } else { return res } }) } b.3) 1 2 3 4 5 6 7 8 9 func h ( nums : [ Int ], n : Int ) - ([ Int ], [ Int ]) { return nums . reduce (([],[]), {( res : ([ Int ],[ Int ]), num : Int ) - ([ Int ],[ Int ]) in if ( num = n ) { return ( res . 0 , res . 1 + [ num ]) } else { return (( res . 0 + [ num ], res . 1 )) } }) } c) Implementa las siguientes funciones con funciones de orden superior. c.1) Funci\u00f3n suma(palabras:contienen:) : 1 suma ( palabras : [ String ], contienen : Character ) - Int que recibe una array de cadenas y devuelve la suma de las longitudes de las cadenas que contiene el car\u00e1cter que se pasa como par\u00e1metro. c.2) Funci\u00f3n sumaMenoresMayores(nums:pivote:) : 1 sumaMenoresMayores ( nums : [ Int ], pivote : Int ) - ( Int , Int ) que recibe un array de n\u00fameros y un n\u00famero pivote y devuelve una tupla con la suma de los n\u00fameros menores y mayores o iguales que el pivote.","title":"Ejercicio 1"},{"location":"practicas/practica09/practica09.html#ejercicio-2","text":"Define un tipo enumerado con un \u00e1rbol gen\u00e9rico, tal y como hicimos en el \u00faltimo ejercicio de la pr\u00e1ctica anterior, que tenga como gen\u00e9rico el tipo de dato que contiene. En el siguiente ejemplo vemos c\u00f3mo deber\u00eda poderse definir con el mismo tipo gen\u00e9rico un \u00e1rbol de enteros y un \u00e1rbol de cadenas: 1 2 3 let arbolInt : Arbol = . nodo ( 53 , [. nodo ( 13 , []), . nodo ( 32 , []), . nodo ( 41 , [. nodo ( 36 , []), . nodo ( 39 , [])])]) let arbolString : Arbol = . nodo ( Zamora , [. nodo ( Buend\u00eda , [. nodo ( Albeza , []), . nodo ( Berenguer , []), . nodo ( Bolardo , [])]), . nodo ( Galv\u00e1n , [])]) Define las funciones gen\u00e9ricas toArray y toArrayFOS que devuelvan un array con todos los componentes del \u00e1rbol usando un recorrido preorden (primero la ra\u00edz y despu\u00e9s los hijos). La primera la debes implementar con recursi\u00f3n mutua y la segunda usando funciones de orden superior. Ejemplo: 1 2 3 4 print ( toArray ( arbol : arbolInt )) // Imprime: [53, 13, 32, 41, 36, 39] print ( toArrayFOS ( arbol : arbolString )) // Imprime: [ Zamora , Buend\u00eda , Albeza , Berenguer , Bolardo , Galv\u00e1n ]","title":"Ejercicio 2"},{"location":"practicas/practica09/practica09.html#ejercicio-3","text":"Implementa en Swift la funci\u00f3n imprimirListadosNotas(alumnos:) que recibe un array de tuplas, en donde cada tupla contiene informaci\u00f3n de la evaluaci\u00f3n de un alumno de LPP (nombreAlumno, notaParcial1, notaParcial2, notaCuestionarios, a\u00f1osMatriculacion) y que debe imprimir por pantalla los siguientes listados: listado 1: array ordenado por nombre del alumno (orden alfab\u00e9tico creciente) listado 2: array ordenado por la nota del parcial 1 (orden decreciente de nota) listado 3: array ordenado por la nota del parcial 2 (orden creciente de nota) listado 4: array ordenado por a\u00f1o de matriculaci\u00f3n y nota del cuestionario (orden decreciente de a\u00f1o y nota) listado 5: array ordenado por nota que necesita obtener en el parcial 3 para aprobar la asignatura en la convocatoria de Junio (orden decreciente de nota necesaria) AYUDA: Para que los listados se muestren formateados con espacios, puedes usar la siguiente funci\u00f3n (para ello tambi\u00e9n debes incluir el import que se indica) 1 2 3 4 5 6 7 8 9 10 import Foundation func imprimirListadoAlumnos ( _ alumnos : [( String , Double , Double , Double , Int )]) { print ( Alumno Parcial1 Parcial2 Cuest A\u00f1os ) for alu in alumnos { alu . 0. withCString { print ( String ( format : %-10s %5.2f %5.2f %5.2f %3d , $0 , alu . 1 , alu . 2 , alu . 3 , alu . 4 )) } } } Ejemplo: 1 2 3 4 5 6 7 8 9 let listaAlumnos = [( Pepe , 8.45 , 3.75 , 6.05 , 1 ), ( Maria , 9.1 , 7.5 , 8.18 , 1 ), ( Jose , 8.0 , 6.65 , 7.96 , 1 ), ( Carmen , 6.25 , 1.2 , 5.41 , 2 ), ( Felipe , 5.65 , 0.25 , 3.16 , 3 ), ( Carla , 6.25 , 1.25 , 4.23 , 2 ), ( Luis , 6.75 , 0.25 , 4.63 , 2 ), ( Loli , 3.0 , 1.25 , 2.19 , 3 )] imprimirListadosNotas ( listaAlumnos ) Algunos de los listados que se deben mostrar ser\u00edan los siguientes: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 LISTADO ORIGINAL Alumno Parcial1 Parcial2 Cuest A\u00f1os Pepe 8.45 3.75 6.05 1 Maria 9.10 7.50 8.18 1 Jose 8.00 6.65 7.96 1 Carmen 6.25 1.20 5.41 2 Felipe 5.65 0.25 3.16 3 Carla 6.25 1.25 4.23 2 Luis 6.75 0.25 4.63 2 Loli 3.00 1.25 2.19 3 LISTADO ORDENADO por Parcial1 Alumno Parcial1 Parcial2 Cuest A\u00f1os Maria 9.10 7.50 8.18 1 Pepe 8.45 3.75 6.05 1 Jose 8.00 6.65 7.96 1 Luis 6.75 0.25 4.63 2 Carmen 6.25 1.20 5.41 2 Carla 6.25 1.25 4.23 2 Felipe 5.65 0.25 3.16 3 Loli 3.00 1.25 2.19 3 LISTADO ORDENADO por Nota para aprobar en Junio Alumno Parcial1 Parcial2 Cuest A\u00f1os Maria 9.10 7.50 8.18 1 Jose 8.00 6.65 7.96 1 Pepe 8.45 3.75 6.05 1 Carmen 6.25 1.20 5.41 2 Carla 6.25 1.25 4.23 2 Luis 6.75 0.25 4.63 2 Felipe 5.65 0.25 3.16 3 Loli 3.00 1.25 2.19 3","title":"Ejercicio 3"},{"location":"practicas/practica09/practica09.html#ejercicio-4","text":"Dado el array listaAlumnos del ejercicio anterior, utiliza funciones de orden superior para obtener los datos requeridos en cada caso A) N\u00famero de alumnos que han aprobado primer parcial y suspendido el segundo 1 2 print ( listaAlumnos . ________________________________ ) // Resultado: 5 B) Nota que deben tener en el parcial 3 para sacar un 5 en la nota final 1 2 3 4 print ( listaAlumnos . _______________________________ ) // Resultado: // [2.4500000000000011, -2.6599999999999984, -0.63666666666666671, 7.4133333333333331, 9.7133333333333347, 7.7566666666666677, 8.1233333333333348, 11.686666666666667] C) Nota media de todos los alumnos en forma de tupla (media_p1, media_p2, media_cuest) 1 2 3 4 var tupla = listaAlumnos . _____________________________________ ) tupla = ( tupla . 0 / Double ( listaAlumnos . count ), tupla . 1 / Double ( listaAlumnos . count ), tupla . 2 / Double ( listaAlumnos . count )) print ( tupla ) // Resultado: (6.6812499999999995, 2.7624999999999997, 5.2262500000000003)","title":"Ejercicio 4"},{"location":"practicas/practica09/practica09.html#ejercicio-5","text":"Queremos escribir la funci\u00f3n calcular(exp: String, sobre: [(Double, Double)]) que recibe una cadena que codifica una expresi\u00f3n sobre una tupla y una lista de tuplas y devuelve el resultado de aplicar esa expresi\u00f3n matem\u00e1tica sobre cada una de las tuplas de la lista. Por ejemplo: 1 2 3 4 5 6 7 8 let tuplas = [( 1.0 , 2.5 ), ( 10.8 , 3.3 ), ( - 1.0 , 12.0 ), ( - 3.4 , 4.0 )] print ( calcular ( exp : $1 * 2.0 , sobre : tuplas ) ! ) // [5.0, 6.5999999999999996, 24.0, 8.0] print ( calcular ( exp : $0 - 5.0 , sobre : tuplas ) ! ) // [-4.0, 5.8000000000000007, -6.0, -8.4000000000000004] print ( calcular ( exp : $0 + $1 , sobre : tuplas ) ! ) // [3.5, 14.100000000000001, 11.0, 0.60000000000000009] En el primer ejemplo la expresi\u00f3n indica que hay que multiplicar el segundo n\u00famero de cada tupla por 2.0. En el segundo ejemplo la expresi\u00f3n indica que hay que restar al primer n\u00famero de cada tupla 5.0. En el tercer ejemplo la expresi\u00f3n indica que hay que sumar el primer y el segundo elemento de cada tupla. La expresi\u00f3n codificada tendr\u00e1 siempre dos operandos y una operaci\u00f3n. Los operandos pueden ser las expresiones $0 y $1 para referirse al primer y segundo elemento de cada tupla o n\u00fameros decimales. La operaci\u00f3n puede ser + , - , * y / para referirse a las operaciones suma, resta, multiplicaci\u00f3n y divisi\u00f3n. Vamos a realizar el ejercicio en tres partes. Primero hay que implementar una funci\u00f3n que analiza la cadena y devuelve una tupla de enumerados; despu\u00e9s una funci\u00f3n convertir\u00e1 la tupla de enumerados en una clausura y por \u00faltimo la funci\u00f3n principal que usa las anteriores y aplica la clausura al array de tuplas. Vamos a detallar cada una de las partes. a) En primer lugar debes implementar la funci\u00f3n parse(exp:) que analice la cadena y la transforme en una tupla de dos operandos y una operaci\u00f3n, siendo \u00e9stos los siguientes tipos enumerados: 1 2 3 4 5 6 7 8 9 10 11 12 enum Operando { case primero case segundo case valor ( Double ) } enum Operacion { case suma case resta case mult case div } La funci\u00f3n parse(exp:) tiene el siguiente perfil: 1 func parse ( exp : String ) - ( op1 : Operando , op2 : Operando , op : Operacion )? Tendr\u00e1s que definir funciones auxiliares para implementar esta funci\u00f3n. AYUDA : Para construir un array con las palabras que aparecen en la frase, puedes usar la siguiente sentencia: 1 let arrayPalabras = frase . split ( separator : ). map ( String . init ) Ejemplos: 1 2 3 4 5 6 parse ( $0 + $1 ) // Devuelve opcional con la tupla (Operando.primero, Operando.segundo, Operacion.suma) parse ( 5.0 * $1 ) // Devuelve opcional con la tupla (Operando.valor(5.0), Operando.segundo, Operacion.mult) parse ( Hola ) // Devuelve nil b) En segundo lugar debes implementar la funci\u00f3n construyeFunc(op1:op2:op:) que recibe los enumerados que representan la expresi\u00f3n matem\u00e1tica y devuelve una clausura que aplica la expresi\u00f3n matem\u00e1tica a una tupla. La funci\u00f3n tiene el siguiente perfil: 1 func construyeFunc ( op1 : Operando , op2 : Operando , op : Operacion ) - (( Double , Double )) - Double Tambi\u00e9n es conveniente que definas funciones auxiliares . Nota La clausura que se devuelve puede ser una clausura que captura los par\u00e1metros `op1`, `op2` y `op` y que los usa en su cuerpo. De esta forma podemos hacer una clausura gen\u00e9rica que llama a las funciones auxiliares y evitamos tener que escribir un n\u00famero enorme de clasuras concretas con todas las posibles combinaciones de tuplas y operadores. c) Por \u00faltimo debes implementar la funci\u00f3n calcular(exp:sobre:) con el siguiente perfil: 1 func calcular ( exp str : String , sobre tuplas : Array ( Double , Double ) ) - [ Double ]? Lenguajes y Paradigmas de Programaci\u00f3n, curso 2018-19 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Domingo Gallardo, Cristina Pomares, Antonio Bot\u00eda, Francisco Mart\u00ednez","title":"Ejercicio 5"},{"location":"practicas/practica10/practica10.html","text":"Pr\u00e1ctica 10: Programaci\u00f3n Orientada a Objetos en Swift 1 Entrega de la pr\u00e1ctica Para entregar la pr\u00e1ctica debes subir a Moodle el fichero practica10.swift con una cabecera inicial con tu nombre y apellidos, y las soluciones de cada ejercicio separadas por comentarios. Ejercicio 1 a) El siguiente c\u00f3digo usa observadores de propiedades y una variable del tipo (est\u00e1tica). \u00bfQu\u00e9 se imprime al final de su ejecuci\u00f3n? Reflexiona sobre el funcionamiento del c\u00f3digo, compru\u00e9balo con el compilador y experimenta haciendo cambios y comprobando el resultado. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 struct Valor { var valor : Int = 0 { willSet { Valor . z += newValue } didSet { if valor 10 { valor = 10 } } } static var z = 0 } var c1 = Valor () var c2 = Valor () c1 . valor = 20 c2 . valor = 8 print ( c1 . valor + c2 . valor + Valor . z ) b) El siguiente c\u00f3digo utiliza la inicializaci\u00f3n de una clase. \u00bfQu\u00e9 errores tiene? \u00bfQu\u00e9 se imprimir\u00eda en su ejecuci\u00f3n una vez arreglado? Intenta descubrirlo sin utilizar el compilador. Prueba distintas formas de arreglar el c\u00f3digo cambiando lo m\u00ednimo posible de lo ya definido (por ejemplo, no debes cambiar la funci\u00f3n prueba ). Compru\u00e9balo con el compilador. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 func prueba ( x : Int ) - Int ? { if x 100 { return nil } else { return x } } class A { var a = prueba ( x : 100 ) var b , c : Int init () {} init ( b : Int ) { self . b = c } } let a = A ( b : 0 ) let b : Int = a . a print ( El valor de a.a es: \\( b ) ) c) Escribe un ejemplo de c\u00f3digo en el que definas una relaci\u00f3n de herencia entre una clase base y una clase derivada. Comprueba en el c\u00f3digo que un objeto de la clase derivada hereda las propiedades y m\u00e9todos de la clase base. Investiga sobre lo el funcionamiento de la herencia en Swift. Escribe ejemplos en donde compruebes este funcionamiento. Algunos ejemplos de preguntas que puedes investigar (puedes a\u00f1adir t\u00fa m\u00e1s preguntas): \u00bfSe puede sobreescribir el valor de una propiedad almacenada? \u00bfY calculada? \u00bfSe puede a\u00f1adir un observador a una propiedad de la clase base en una clase derivada? \u00bfHereda la clase derivada propiedades y m\u00e9todos est\u00e1ticos de la clase base? \u00bfC\u00f3mo se puede llamar a la implementaci\u00f3n de un m\u00e9todo de la clase base en una sobreescritura de ese mismo m\u00e9todo en la clase derivada? Ejercicio 2 Supongamos la siguiente clase MisPalabras : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class MisPalabras { var guardadas : [ String ] = [] func guarda ( palabra : String ) { guardadas = guardadas + [ palabra ] } } let palabras = MisPalabras () palabras . guarda ( palabra : Hola ) palabras . guarda ( palabra : me ) palabras . guarda ( palabra : llamo ) palabras . guarda ( palabra : Yolanda ) print ( palabras . guardadas ) // [ Hola , me , llamo , Yolanda ] Debes a\u00f1adir una propiedad calculada logitud que devuelva la suma de las longitudes de todas las palabras guardadas (usa una funci\u00f3n de orden superior para calcular esta suma). Haz tambi\u00e9n que sea una propiedad modificable de la siguiente forma: Si se intenta asignar un valor mayor o igual que la longitud de las cadenas guardadas, o un n\u00famero negativo, no se hace nada. Si se asigna un valor menor que la longitud de las cadenas se deben dejar guardadas s\u00f3lo las palabras que suman esa longitud, recortando la \u00faltima de ellas si es necesario. Ejemplo: 1 2 3 4 5 print ( palabras . longitud ) // 18 palabras . longitud = 10 print ( palabras . guardadas ) // [ Hola , me , llam ] Ayuda : Puedes utilizar la siguiente funci\u00f3n recorta para recortar una palabra: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 func recorta ( _ palabra : String , hasta : Int ) - String { if hasta = palabra . count { return palabra } else { let start = palabra . startIndex let end = palabra . index ( start , offsetBy : hasta ) return String ( palabra [ start .. end ]) } } print ( recorta ( Hola , hasta : 2 )) // Ho print ( recorta ( Hola , hasta : 3 )) // Hol print ( recorta ( Hola , hasta : 4 )) // Hola print ( recorta ( Hola , hasta : 5 )) // Hola Ejercicio 3 En este ejercicio vamos a trabajar con estructuras y clases geom\u00e9tricas: Punto , Tama\u00f1o , Rectangulo y Circulo . Vamos a definir propiedades almacenadas y propiedades calculadas para todas las figuras geom\u00e9tricas. Para usar la funci\u00f3n sqrt debes importar la librer\u00eda Foundation : 1 import Foundation El valor de la constante matem\u00e1tica pi lo puedes obtener con la propiedad Double.pi . Estructuras Punto y Tama\u00f1o Las debes declarar tal y como aparecen en los apuntes. Clase Rectangulo Propiedades de instancia almacenadas: origen ( Punto ) que contiene las coordenadas de la esquina inferior izquierda del rect\u00e1ngulo. tama\u00f1o ( Tama\u00f1o ) que contiene las dimensiones del rect\u00e1ngulo. Ambas propiedades se inicializan en un inicializador. Propiedades de instancia calculadas: centro ( Punto , de lectura y escritura) que devuelve el centro del rect\u00e1ngulo. El setter modifica la posici\u00f3n del rect\u00e1ngulo manteniendo fijo su tama\u00f1o. area ( Double , s\u00f3lo lectura ) que devuelve el \u00e1rea del rect\u00e1ngulo. Clase Circulo Propiedades de instancia almacenadas: centro ( Punto ) que contiene las coordenadas del centro del c\u00edrculo. radio ( Double ) que contiene la longitud del radio. Ambas propiedades se inicializan en un inicializador. Propiedades de instancia calculadas: area ( Double , de lectura y escritura) que devuelve el \u00e1rea del c\u00edrculo. El setter modifica el tama\u00f1o del c\u00edrculo (su radio), manteni\u00e9ndolo en la misma posici\u00f3n. Estructura AlmacenFiguras Propiedades de tipo almacenadas: rectangulos y circulos que contienen respectivamente arrays de rect\u00e1ngulos y c\u00edrculos inicializados a arrays vac\u00edos. Se actualizan con cada nueva figura creada. En los inicializadores de Rectangulo y Circulo se debe incluir el c\u00f3digo que a\u00f1ade la instancia reci\u00e9n creada al almac\u00e9n de figuras. Propiedades de tipo calculadas: numFiguras ( Int ) que devuelve el n\u00famero total de figuras creadas. areaTotal ( Double ) que devuelve la suma total de las \u00e1reas de todas las figuras creadas. Nota La definici\u00f3n anterior del almac\u00e9n de figuras no es demasiado correcta, porque se utiliza una variable distinta para cada tipo de figura, sin generalizar. En la pr\u00e1ctica de la semana que viene veremos c\u00f3mo mejorarlo utilizando protocolos. Implementa las estructuras y clases anteriores y escribe algunos ejemplos de c\u00f3digo para probarlas. Ejercicio 4 En este ejercicio deber\u00e1s implementar un conjunto de clases con las que podamos \"simular\" una carrera de coches. Funci\u00f3n random Utilizaremos la funci\u00f3n del sistema random() que devuelve un n\u00famero aleatorio. Hay que importar la librer\u00eda Glibc (en Linux) y Foundation (en iOS) para usarla. A continuaci\u00f3n puedes ver un ejemplo de su utilizaci\u00f3n en un m\u00e9todo de tipo del enumerado MarcaCoche para devolver una marca aleatoria de coche: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import Glibc func rand ( n : Int ) - Int { return random () % n } enum MarcaCoche : Int { case Mercedes = 0 , Ferrari , RedBull , McLaren static func random () - MarcaCoche { let maxValue = McLaren . rawValue let r = rand ( maxValue + 1 ) return MarcaCoche ( rawValue : r ) ! } } Enumerados y clases que gestionan los veh\u00edculos Deber\u00e1s implementar los siguientes enumerados y clases, con las propiedades indicadas. Enumerado MarcaCoche Posibles valores: Mercedes , Ferrari , RedBull y McLaren M\u00e9todo del tipo random() que devuelva aleatoriamente uno de los valores (consultar el c\u00f3digo anterior). Enumerado TipoCambio Posibles valores: Automatico o Manual M\u00e9todo del tipo random() que devuelve uno de esos valores. Clase base Coche Propiedades de instancia almacenadas: velocidadActual ( Double ), marcha ( Int ), distanciaRecorrida ( Double ) y marca ( MarcaCoche ). Propiedad de instancia calculada: descripcion ( String ), que devuelve la marca del coche. Propiedades del tipo: Constantes velocidadMaxima ( Double ) y marchaMaxima ( Int ) inicializadas a 150.0 y 6 Subclase CocheAutomatico Hereda de Coche y sobreescribe la descripci\u00f3n, a\u00f1adiendo la cadena \"Autom\u00e1tico\". Subclase CocheManual Hereda de Coche y sobreescribe la descripci\u00f3n, a\u00f1adiendo la cadena \"Manual\". Observadores de propiedades en las subclases La velocidad de un coche manual se modifica cambiando su propiedad marcha y la de un coche autom\u00e1tico cambiando su propiedad velocidadActual . En cada caso hay que definir observadores de propiedades que modifiquen la otra propiedad. La velocidad se calcula a partir de la marcha seg\u00fan la siguiente expresi\u00f3n: 1 velocidadActual = 25.0 * marcha Y la marcha se calcula a partir de la velocidad con la expresi\u00f3n que puedes encontrar en los apuntes de teor\u00eda, en la definici\u00f3n de la clase CocheAutomatico . Distancia recorrida e informaci\u00f3n en pantalla Suponemos que se cambia la velocidad del coche cada hora y que en cada cambio de velocidad se actualiza la propiedad distanciaRecorrida , que ir\u00e1 acumulando la distancia recorrida por el coche desde su inicializaci\u00f3n. Cada vez que se cambia la velocidad tambi\u00e9n se imprimir\u00e1 la velocidad actual y la marca del coche en pantalla (ver el ejemplo al final del ejercicio). Esto se puede implementar tambi\u00e9n en los observadores. Clase Carrera Debes implementar las clases anteriores y una clase Carrera con la que simular una carrera de n coches que conducen durante k horas. Un ejemplo de uso de la clase Carrera : 1 2 3 4 5 6 7 let carrera = Carrera ( numCoches : 2 , horas : 3 ) print ( \\n Descripci\u00f3n de la carrera: ) carrera . descripcion () print ( \\n !!! Comienza la carrera !!! ) carrera . empezar () print ( \\n !!! Clasificaci\u00f3n !!! ) carrera . clasificacion () Y su correspondiente salida por pantalla: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 Descripci\u00f3n de la carrera: 2 coches con una duraci\u00f3n de 3 horas McLaren Automatico Mercedes Manual !!! Comienza la carrera !!! Horas transcurridas 1 McLaren Automatico viajando a 141.0 kil\u00f3metros por hora con la marcha 6 Mercedes Manual viajando a 25.0 kil\u00f3metros por hora con la marcha 1 Horas transcurridas 2 McLaren Automatico viajando a 114.0 kil\u00f3metros por hora con la marcha 5 Mercedes Manual viajando a 25.0 kil\u00f3metros por hora con la marcha 1 Horas transcurridas 3 McLaren Automatico viajando a 105.0 kil\u00f3metros por hora con la marcha 5 Mercedes Manual viajando a 100.0 kil\u00f3metros por hora con la marcha 4 !!! Clasificaci\u00f3n !!! 1. McLaren Automatico (360.0 kil\u00f3metros recorridos) 2. Mercedes Manual (150.0 kil\u00f3metros recorridos) Lenguajes y Paradigmas de Programaci\u00f3n, curso 2018-19 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Domingo Gallardo, Cristina Pomares, Antonio Bot\u00eda, Francisco Mart\u00ednez","title":"Pr\u00e1ctica 10: Programaci\u00f3n Orientada a Objetos en Swift 1"},{"location":"practicas/practica10/practica10.html#practica-10-programacion-orientada-a-objetos-en-swift-1","text":"","title":"Pr\u00e1ctica 10: Programaci\u00f3n Orientada a Objetos en Swift 1"},{"location":"practicas/practica10/practica10.html#entrega-de-la-practica","text":"Para entregar la pr\u00e1ctica debes subir a Moodle el fichero practica10.swift con una cabecera inicial con tu nombre y apellidos, y las soluciones de cada ejercicio separadas por comentarios.","title":"Entrega de la pr\u00e1ctica"},{"location":"practicas/practica10/practica10.html#ejercicio-1","text":"a) El siguiente c\u00f3digo usa observadores de propiedades y una variable del tipo (est\u00e1tica). \u00bfQu\u00e9 se imprime al final de su ejecuci\u00f3n? Reflexiona sobre el funcionamiento del c\u00f3digo, compru\u00e9balo con el compilador y experimenta haciendo cambios y comprobando el resultado. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 struct Valor { var valor : Int = 0 { willSet { Valor . z += newValue } didSet { if valor 10 { valor = 10 } } } static var z = 0 } var c1 = Valor () var c2 = Valor () c1 . valor = 20 c2 . valor = 8 print ( c1 . valor + c2 . valor + Valor . z ) b) El siguiente c\u00f3digo utiliza la inicializaci\u00f3n de una clase. \u00bfQu\u00e9 errores tiene? \u00bfQu\u00e9 se imprimir\u00eda en su ejecuci\u00f3n una vez arreglado? Intenta descubrirlo sin utilizar el compilador. Prueba distintas formas de arreglar el c\u00f3digo cambiando lo m\u00ednimo posible de lo ya definido (por ejemplo, no debes cambiar la funci\u00f3n prueba ). Compru\u00e9balo con el compilador. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 func prueba ( x : Int ) - Int ? { if x 100 { return nil } else { return x } } class A { var a = prueba ( x : 100 ) var b , c : Int init () {} init ( b : Int ) { self . b = c } } let a = A ( b : 0 ) let b : Int = a . a print ( El valor de a.a es: \\( b ) ) c) Escribe un ejemplo de c\u00f3digo en el que definas una relaci\u00f3n de herencia entre una clase base y una clase derivada. Comprueba en el c\u00f3digo que un objeto de la clase derivada hereda las propiedades y m\u00e9todos de la clase base. Investiga sobre lo el funcionamiento de la herencia en Swift. Escribe ejemplos en donde compruebes este funcionamiento. Algunos ejemplos de preguntas que puedes investigar (puedes a\u00f1adir t\u00fa m\u00e1s preguntas): \u00bfSe puede sobreescribir el valor de una propiedad almacenada? \u00bfY calculada? \u00bfSe puede a\u00f1adir un observador a una propiedad de la clase base en una clase derivada? \u00bfHereda la clase derivada propiedades y m\u00e9todos est\u00e1ticos de la clase base? \u00bfC\u00f3mo se puede llamar a la implementaci\u00f3n de un m\u00e9todo de la clase base en una sobreescritura de ese mismo m\u00e9todo en la clase derivada?","title":"Ejercicio 1"},{"location":"practicas/practica10/practica10.html#ejercicio-2","text":"Supongamos la siguiente clase MisPalabras : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class MisPalabras { var guardadas : [ String ] = [] func guarda ( palabra : String ) { guardadas = guardadas + [ palabra ] } } let palabras = MisPalabras () palabras . guarda ( palabra : Hola ) palabras . guarda ( palabra : me ) palabras . guarda ( palabra : llamo ) palabras . guarda ( palabra : Yolanda ) print ( palabras . guardadas ) // [ Hola , me , llamo , Yolanda ] Debes a\u00f1adir una propiedad calculada logitud que devuelva la suma de las longitudes de todas las palabras guardadas (usa una funci\u00f3n de orden superior para calcular esta suma). Haz tambi\u00e9n que sea una propiedad modificable de la siguiente forma: Si se intenta asignar un valor mayor o igual que la longitud de las cadenas guardadas, o un n\u00famero negativo, no se hace nada. Si se asigna un valor menor que la longitud de las cadenas se deben dejar guardadas s\u00f3lo las palabras que suman esa longitud, recortando la \u00faltima de ellas si es necesario. Ejemplo: 1 2 3 4 5 print ( palabras . longitud ) // 18 palabras . longitud = 10 print ( palabras . guardadas ) // [ Hola , me , llam ] Ayuda : Puedes utilizar la siguiente funci\u00f3n recorta para recortar una palabra: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 func recorta ( _ palabra : String , hasta : Int ) - String { if hasta = palabra . count { return palabra } else { let start = palabra . startIndex let end = palabra . index ( start , offsetBy : hasta ) return String ( palabra [ start .. end ]) } } print ( recorta ( Hola , hasta : 2 )) // Ho print ( recorta ( Hola , hasta : 3 )) // Hol print ( recorta ( Hola , hasta : 4 )) // Hola print ( recorta ( Hola , hasta : 5 )) // Hola","title":"Ejercicio 2"},{"location":"practicas/practica10/practica10.html#ejercicio-3","text":"En este ejercicio vamos a trabajar con estructuras y clases geom\u00e9tricas: Punto , Tama\u00f1o , Rectangulo y Circulo . Vamos a definir propiedades almacenadas y propiedades calculadas para todas las figuras geom\u00e9tricas. Para usar la funci\u00f3n sqrt debes importar la librer\u00eda Foundation : 1 import Foundation El valor de la constante matem\u00e1tica pi lo puedes obtener con la propiedad Double.pi . Estructuras Punto y Tama\u00f1o Las debes declarar tal y como aparecen en los apuntes. Clase Rectangulo Propiedades de instancia almacenadas: origen ( Punto ) que contiene las coordenadas de la esquina inferior izquierda del rect\u00e1ngulo. tama\u00f1o ( Tama\u00f1o ) que contiene las dimensiones del rect\u00e1ngulo. Ambas propiedades se inicializan en un inicializador. Propiedades de instancia calculadas: centro ( Punto , de lectura y escritura) que devuelve el centro del rect\u00e1ngulo. El setter modifica la posici\u00f3n del rect\u00e1ngulo manteniendo fijo su tama\u00f1o. area ( Double , s\u00f3lo lectura ) que devuelve el \u00e1rea del rect\u00e1ngulo. Clase Circulo Propiedades de instancia almacenadas: centro ( Punto ) que contiene las coordenadas del centro del c\u00edrculo. radio ( Double ) que contiene la longitud del radio. Ambas propiedades se inicializan en un inicializador. Propiedades de instancia calculadas: area ( Double , de lectura y escritura) que devuelve el \u00e1rea del c\u00edrculo. El setter modifica el tama\u00f1o del c\u00edrculo (su radio), manteni\u00e9ndolo en la misma posici\u00f3n. Estructura AlmacenFiguras Propiedades de tipo almacenadas: rectangulos y circulos que contienen respectivamente arrays de rect\u00e1ngulos y c\u00edrculos inicializados a arrays vac\u00edos. Se actualizan con cada nueva figura creada. En los inicializadores de Rectangulo y Circulo se debe incluir el c\u00f3digo que a\u00f1ade la instancia reci\u00e9n creada al almac\u00e9n de figuras. Propiedades de tipo calculadas: numFiguras ( Int ) que devuelve el n\u00famero total de figuras creadas. areaTotal ( Double ) que devuelve la suma total de las \u00e1reas de todas las figuras creadas. Nota La definici\u00f3n anterior del almac\u00e9n de figuras no es demasiado correcta, porque se utiliza una variable distinta para cada tipo de figura, sin generalizar. En la pr\u00e1ctica de la semana que viene veremos c\u00f3mo mejorarlo utilizando protocolos. Implementa las estructuras y clases anteriores y escribe algunos ejemplos de c\u00f3digo para probarlas.","title":"Ejercicio 3"},{"location":"practicas/practica10/practica10.html#ejercicio-4","text":"En este ejercicio deber\u00e1s implementar un conjunto de clases con las que podamos \"simular\" una carrera de coches.","title":"Ejercicio 4"},{"location":"practicas/practica11/practica11.html","text":"Pr\u00e1ctica 11: Programaci\u00f3n Orientada a Objetos en Swift (2) Entrega de la pr\u00e1ctica Para entregar la pr\u00e1ctica debes subir a Moodle el fichero practica11.swift con una cabecera inicial con tu nombre y apellidos, y las soluciones de cada ejercicio separadas por comentarios. Ejercicios Ejercicio 1 a) El siguiente c\u00f3digo tiene errores. Intenta descubrir cu\u00e1les son sin utilizar el compilador. Prueba distintas formas de arreglar el c\u00f3digo cambiando lo m\u00ednimo posible de lo ya definido (por ejemplo, no debes a\u00f1adir nuevas propiedades en MiStruct ). Compru\u00e9balo con el compilador. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 protocol A { var a : String { get set } func foo ( a : Int , b : Int ) - Int ? } protocol B { mutating func bar () } struct MiStruct : A , B { let a = 10 func foo ( valor1 a : Int , valor2 b : Int ) - Int { let res = a 10 ? a : b return res } } b) Repasa el protocolo GeneradorNumerosAleatorios visto en teor\u00eda. Define otra implementaci\u00f3n del protocol llamada GeneradorFake en la que siempre se devuelva el n\u00famero 0.1 . Cambia el ejemplo del dado para que utilice este generador y comprueba que siempre devuelve el n\u00famero 1. c) Supongamos la estructura Equipo que aparece a continuaci\u00f3n que representa un equipo en una competici\u00f3n deportiva: 1 2 3 4 struct Equipo { let puntos : Int let nombre : String } Debes hacer que la estructura se ajuste al protocolo Comparable para poder comparar dos equipos . Consulta el protocolo en documentaci\u00f3n de Swift . Un equipo ser\u00e1 menor que otro cuando tenga menos puntos. En el caso en que ambos tengan los mismos puntos, ser\u00e1 menor el que tenga menor nombre en orden alfab\u00e9tico. Una vez definidos los operadores necesarios comprueba que funcionan correctamente creando varios equipos, insert\u00e1ndolos en un array y llamando al m\u00e9todo sorted . Ejercicio 2 a) Completa el bucle con el c\u00f3digo que comprueba el tipo de la variable i e imprime su propiedad x y su propiedad b o c , dependiendo de su tipo. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 protocol X { var x : Int { get } } class Xb : A { var x = 0 var b = 0 } class Xc : A { var x = 1 var c = 0 } var array : [ X ] = [ Xb (), Xc ()] for i in array { // // C\u00f3digo a completar // } // debe imprimir: // x: 0, b: 0 // x: 1, c: 0 b) Completa el c\u00f3digo que hay a continuaci\u00f3n para que compile correctamente y aparezca en pantalla el resultado que se muestra. Resultado: 1 2 0.0 300.0 C\u00f3digo: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 protocol TieneVelocidad { func velocidadActual () - Double } class Vehiculo { var velocidad = 0.0 func velocidadActual () - Double { return velocidad } } class Tren { static let velocidadEnMarcha = 300.0 var pasajeros = 0 var enMarcha = false } // // C\u00f3digo a completar // var vehiculo1 = Vehiculo () var tren1 = Tren () tren1 . enMarcha = true let transportes : [ TieneVelocidad ] = [ vehiculo1 , tren1 ] for i in transportes { print ( i . velocidadActual ()) } c) Define una extensi\u00f3n del enum Arbol del ejercicio 2 de la pr\u00e1ctica 9 en la que se implemente el m\u00e9todo min que devuelva el menor elemento del \u00e1rbol. En la extensi\u00f3n debes especificar que el tipo de los elementos del \u00e1rbol deben cumplir el protocolo Comparable , para poder realizar la comparaci\u00f3n y obtener el m\u00ednimo. Haz una prueba con un \u00e1rbol de equipos, objetos de la estructura Equipo definida en el apartado anterior. Ejercicio 3 Continuamos con el ejercicio de las figuras geom\u00e9tricas de la pr\u00e1ctica anterior. Comienza incluyendo en la pr\u00e1ctica el c\u00f3digo de todas las definiciones de las estructuras y clases geom\u00e9tricas: Punto , Tama\u00f1o , Rectangulo y Circulo . Una vez incluido debes realizar lo siguiente. Protocolo figura Define el protocolo Figura que contiene: Propiedad de lectura y escritura centro ( Punto ), que define el centro de la figura. Propiedades de s\u00f3lo lectura area ( Double ) y tama\u00f1o ( Tama\u00f1o ) que devuelven el tama\u00f1o (alto y ancho) de la figura. Extensiones Define las extensiones necesarias para que las clases Rectangulo , y Circulo se ajusten al protocolo Figura , a\u00f1adiendo el c\u00f3digo de implementaci\u00f3n necesario. A\u00f1ade mediante una extensi\u00f3n al protocolo Figura la propiedad calculada descripcion que devuelva un String con el centro y el \u00e1rea de la figura. Clase AlmacenFiguras Reescribe la clase AlmacenFiguras y define en ella una \u00fanica propiedad figuras que contenga todas las figuras que se vayan creando. Reescribe tambi\u00e9n la implementaci\u00f3n de areaTotal . Modifica los inicializadores en las clases geom\u00e9tricas para que se incluya la figura reci\u00e9n creada en esta propiedad. Escribe el m\u00e9todo de clase cuentaTipos() - (Int, Int) que recorra el array de figuras y devuelva una tupla con dos enteros: n\u00famero de rect\u00e1ngulos y n\u00famero de c\u00edrculos. La funci\u00f3n debe imprimir por cada figura del array, su descripci\u00f3n por defecto proporcionada por el protocolo y el tipo de figura y sus caracter\u00edsticas espec\u00edficas. Por ejemplo: 1 2 3 4 - Descripci\u00f3n de la figura: Una figura con centro Punto(x: 7.0, y: 3.5) y \u00e1rea 50.0 Rectangulo con origen Punto(x: 2.0, y: 1.0) y tama\u00f1o Tama\u00f1o(ancho: 10.0, alto: 5.0) - Descripci\u00f3n de la figura: Una figura con centro Punto(x: 0.0, y: 2.0) y \u00e1rea 78.5398163397448 Circulo con centro Punto(x: 0.0, y: 2.0) y radio 5.0 Cumplimiento de Equatable Implementa las extensiones necesarias para que las clases geom\u00e9tricas definidas en el ejercicio cumplan el protocolo Equatable . Lenguajes y Paradigmas de Programaci\u00f3n, curso 2018-19 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Domingo Gallardo, Cristina Pomares, Antonio Bot\u00eda, Francisco Mart\u00ednez","title":"Pr\u00e1ctica 11: Programaci\u00f3n Orientada a Objetos en Swift (2)"},{"location":"practicas/practica11/practica11.html#practica-11-programacion-orientada-a-objetos-en-swift-2","text":"","title":"Pr\u00e1ctica 11: Programaci\u00f3n Orientada a Objetos en Swift (2)"},{"location":"practicas/practica11/practica11.html#entrega-de-la-practica","text":"Para entregar la pr\u00e1ctica debes subir a Moodle el fichero practica11.swift con una cabecera inicial con tu nombre y apellidos, y las soluciones de cada ejercicio separadas por comentarios.","title":"Entrega de la pr\u00e1ctica"},{"location":"practicas/practica11/practica11.html#ejercicios","text":"","title":"Ejercicios"},{"location":"practicas/practica11/practica11.html#ejercicio-1","text":"a) El siguiente c\u00f3digo tiene errores. Intenta descubrir cu\u00e1les son sin utilizar el compilador. Prueba distintas formas de arreglar el c\u00f3digo cambiando lo m\u00ednimo posible de lo ya definido (por ejemplo, no debes a\u00f1adir nuevas propiedades en MiStruct ). Compru\u00e9balo con el compilador. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 protocol A { var a : String { get set } func foo ( a : Int , b : Int ) - Int ? } protocol B { mutating func bar () } struct MiStruct : A , B { let a = 10 func foo ( valor1 a : Int , valor2 b : Int ) - Int { let res = a 10 ? a : b return res } } b) Repasa el protocolo GeneradorNumerosAleatorios visto en teor\u00eda. Define otra implementaci\u00f3n del protocol llamada GeneradorFake en la que siempre se devuelva el n\u00famero 0.1 . Cambia el ejemplo del dado para que utilice este generador y comprueba que siempre devuelve el n\u00famero 1. c) Supongamos la estructura Equipo que aparece a continuaci\u00f3n que representa un equipo en una competici\u00f3n deportiva: 1 2 3 4 struct Equipo { let puntos : Int let nombre : String } Debes hacer que la estructura se ajuste al protocolo Comparable para poder comparar dos equipos . Consulta el protocolo en documentaci\u00f3n de Swift . Un equipo ser\u00e1 menor que otro cuando tenga menos puntos. En el caso en que ambos tengan los mismos puntos, ser\u00e1 menor el que tenga menor nombre en orden alfab\u00e9tico. Una vez definidos los operadores necesarios comprueba que funcionan correctamente creando varios equipos, insert\u00e1ndolos en un array y llamando al m\u00e9todo sorted .","title":"Ejercicio 1"},{"location":"practicas/practica11/practica11.html#ejercicio-2","text":"a) Completa el bucle con el c\u00f3digo que comprueba el tipo de la variable i e imprime su propiedad x y su propiedad b o c , dependiendo de su tipo. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 protocol X { var x : Int { get } } class Xb : A { var x = 0 var b = 0 } class Xc : A { var x = 1 var c = 0 } var array : [ X ] = [ Xb (), Xc ()] for i in array { // // C\u00f3digo a completar // } // debe imprimir: // x: 0, b: 0 // x: 1, c: 0 b) Completa el c\u00f3digo que hay a continuaci\u00f3n para que compile correctamente y aparezca en pantalla el resultado que se muestra. Resultado: 1 2 0.0 300.0 C\u00f3digo: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 protocol TieneVelocidad { func velocidadActual () - Double } class Vehiculo { var velocidad = 0.0 func velocidadActual () - Double { return velocidad } } class Tren { static let velocidadEnMarcha = 300.0 var pasajeros = 0 var enMarcha = false } // // C\u00f3digo a completar // var vehiculo1 = Vehiculo () var tren1 = Tren () tren1 . enMarcha = true let transportes : [ TieneVelocidad ] = [ vehiculo1 , tren1 ] for i in transportes { print ( i . velocidadActual ()) } c) Define una extensi\u00f3n del enum Arbol del ejercicio 2 de la pr\u00e1ctica 9 en la que se implemente el m\u00e9todo min que devuelva el menor elemento del \u00e1rbol. En la extensi\u00f3n debes especificar que el tipo de los elementos del \u00e1rbol deben cumplir el protocolo Comparable , para poder realizar la comparaci\u00f3n y obtener el m\u00ednimo. Haz una prueba con un \u00e1rbol de equipos, objetos de la estructura Equipo definida en el apartado anterior.","title":"Ejercicio 2"},{"location":"practicas/practica11/practica11.html#ejercicio-3","text":"Continuamos con el ejercicio de las figuras geom\u00e9tricas de la pr\u00e1ctica anterior. Comienza incluyendo en la pr\u00e1ctica el c\u00f3digo de todas las definiciones de las estructuras y clases geom\u00e9tricas: Punto , Tama\u00f1o , Rectangulo y Circulo . Una vez incluido debes realizar lo siguiente.","title":"Ejercicio 3"},{"location":"seminarios/seminario1-scheme/seminario1-scheme.html","text":"Seminario 1: Seminario de Scheme Bibliograf\u00eda Este seminario est\u00e1 basado en los siguientes materiales. Os recomendamos que les ech\u00e9is un vistazo y, si os interesa y os queda tiempo, que explor\u00e9is tambi\u00e9n en los enlaces que hemos dejado en los apuntes para ampliar informaci\u00f3n. DrRacket , Entorno de programaci\u00f3n DrRacket R6RS base (pdf) (html) Librer\u00edas R6RS (pdf) (html) Simply Scheme El lenguaje de programaci\u00f3n Scheme Scheme es un lenguaje de programaci\u00f3n que surgi\u00f3 en los laboratorios del MIT en 1975, cuando Guy L. Steele y Gerarld J. Sussman buscaban un lenguaje con una sem\u00e1ntica muy clara y sencilla. Scheme es un dialecto de Lisp, es un lenguaje interpretado, muy expresivo y soporta varios paradigmas. Estuvo influenciado por el c\u00e1lculo lambda. El desarrollo de Scheme ha sido lento, ya que la gente que estandariz\u00f3 Scheme es muy conservadora en cuanto a a\u00f1adirle nuevas caracter\u00edsticas,porque la calidad ha sido siempre m\u00e1s importante que la utilidad empresarial. Por eso Scheme es considerado como uno de los lenguajes mejor dise\u00f1ados de prop\u00f3sito general. Aprender Scheme har\u00e1 que se\u00e1is mejores programadores cuando utilic\u00e9is otros lenguajes de programaci\u00f3n. El entorno de programaci\u00f3n DrRacket Cuando lanzamos DrRacket, vemos que tiene tres partes: una fila de botones arriba, dos paneles de edici\u00f3n en el medio y una barra de estado abajo. El panel de edici\u00f3n superior es la ventana de definiciones. Se utiliza para implementar funciones, como la funci\u00f3n square en el ejemplo. El panel inferior, llamado ventana de interacci\u00f3n , se utiliza para evaluar expresiones interactivamente. Pulsando el bot\u00f3n Run , se eval\u00faa el programa de la ventana de definiciones , haciendo que esas definiciones est\u00e9n disponibles en la ventana de interacci\u00f3n. As\u00ed, dada la definici\u00f3n de square , despu\u00e9s de pulsar Run , podemos teclear la expresi\u00f3n (square 2) en la ventana de interacci\u00f3n , se evaluar\u00e1 y mostrar\u00e1 el resultado, en este caso 4. Cambiar el idioma del entorno Podemos interactuar con el entorno en el idioma que queramos. Si queremos tenerlo por ejemplo en espa\u00f1ol, vamos al men\u00fa Help - Interact\u00faa con DrRacket en espa\u00f1ol . Nos aparecer\u00e1 un di\u00e1logo que nos obligar\u00e1 a reiniciar el int\u00e9rprete para aceptar los cambios. Eligiendo un lenguaje DrRacket soporta muchos dialectos de Scheme, entre los cuales se encuentra su primera versi\u00f3n est\u00e1ndar IEEE, llamada R5RS ( Revised 5 Report on the Algorithmic Language Scheme ), que aparece en el a\u00f1o 1998. Nosotros vamos a utilizar la siguiente versi\u00f3n R6RS (2007). Para ello, cuando arranquemos DrRacket, debemos hacer lo siguiente: Asegurarnos que en la parte inferior de la ventana aparece \" Determine language from source \" En el panel de edici\u00f3n debemos escribir las siguientes l\u00edneas: 1 2 3 4 `` ` scheme #lang r6rs ( import ( rnrs )) `` ` Finalmente pulsar el bot\u00f3n Run (Ejecutar) para que se cargue ese lenguaje en el int\u00e9rprete. Aclaraciones La l\u00ednea de c\u00f3digo 1 # lang r6rs es una directiva de DrRacket que determina qu\u00e9 lenguaje ser\u00e1 interpretado. La l\u00ednea 1 ( import ( rnrs )) Permite importar la librer\u00eda rnrs , que es la librer\u00eda que contiene todas las funciones del lenguaje r6rs. Adem\u00e1s de \u00e9sta, en la asignatura usaremos otras librer\u00edas que se indicar\u00e1n en los correspondientes enunciados de las pr\u00e1cticas cuando sean necesarias. El lenguaje Scheme Vamos a empezar probando algunos ejemplos Scheme es un lenguaje interpretado. Vamos a lanzar DrRacket y teclear en la ventana de interacci\u00f3n algunas expresiones. El int\u00e9rprete analizar\u00e1 la expresi\u00f3n y mostrar\u00e1 el valor resultante de evaluarla. 1 2 3 4 5 2 ( + 2 3 ) ( + ) ( + 2 4 5 6 ) ( + ( * 2 3 ) ( - 3 1 )) Las expresiones en Scheme tienen una forma denominada notaci\u00f3n prefija de Cambridge (el nombre de Cambridge es por la localidad Cambridge, Massachusets, donde reside el MIT, lugar en el que se ide\u00f3 el Lisp), en la que la expresi\u00f3n est\u00e1 delimitada por par\u00e9ntesis y el operador va seguido de los operandos. La sintaxis es la siguiente: 1 ( funci \u00f3 n arg1 ... argn ) En Scheme podemos interpretar los par\u00e9ntesis abiertos \u2018(\u2019 como evaluadores o lanzadores de la funci\u00f3n que hay a continuaci\u00f3n. La forma que tiene Scheme de evaluar una expresi\u00f3n es muy sencilla: Eval\u00faa cada uno de los argumentos Aplica la funci\u00f3n nombrada tras el par\u00e9ntesis a los valores resultantes de la evaluaci\u00f3n anterior 1 2 3 4 5 ( + ( * 2 3 ) ( - 3 ( / 12 3 ))) \u21d2 ( + 6 ( - 3 ( / 12 3 ))) \u21d2 ( + 6 ( - 3 4 )) \u21d2 ( + 6 -1 ) \u21d2 5 En Scheme los t\u00e9rminos funci\u00f3n y procedimiento significan lo mismo y se usan de forma intercambiable. Son ejemplos de funciones o procedimientos: +, -, *. En Scheme la evaluaci\u00f3n de una funci\u00f3n siempre devuelve un valor, a no ser que se produzca un error que detiene la evaluaci\u00f3n: 1 ( * ( + 3 4 ) ( / 3 0 )) Definiendo variables y funciones Podemos utilizar en el int\u00e9rprete la forma especial define para definir variables y funciones. En clase de teor\u00eda veremos c\u00f3mo es el funcionamiento del define , pero por el momento lo utilizaremos para definir variables asociadas a valores, e implementar funciones o procedimientos. Scheme es un lenguaje multiparadigma pero principalmente funcional, y una de sus caracter\u00edsticas principales es que los programas se construyen mediante la definici\u00f3n de funciones. Definimos variables en la ventana de interacci\u00f3n: 1 2 3 4 5 ( define pi 3.14159 ) pi ( sin ( / pi 2 )) ( define a ( + 2 ( * 3 4 ))) a Para implementar una funci\u00f3n tambi\u00e9n se utiliza define, con la siguiente sintaxis: 1 2 3 ( define ( nombre-funcion args ) cuerpo-funcion ) Por ejemplo, vamos a implementar una funci\u00f3n que toma dos n\u00fameros como par\u00e1metros y devuelve la suma de sus cuadrados: 1 2 ( define ( suma-cuadrados x y ) ( + ( * x x ) ( * y y ))) Si llamamos a la funci\u00f3n pasando el 2 y el 3 como par\u00e1metros, la funci\u00f3n devuelve el n\u00famero 13: 1 ( suma-cuadrados 2 3 ) ; \u21d2 13 Nota A diferencia de la mayor\u00eda de lenguajes de programaci\u00f3n, en Scheme no se utiliza la palabra return para indicar que una funci\u00f3n devuelve un valor. Las funciones se definen con una \u00fanica expresi\u00f3n y el resultado calculado en esa expresi\u00f3n es el que siempre se devuelve. Podemos comprobar una caracter\u00edstica muy importante de Scheme. Se trata de un lenguaje d\u00e9bilmente tipado , en el que los argumentos x e y no tienen tipo. Si se invoca a la funci\u00f3n pasando alg\u00fan dato que no sea un n\u00famero, el int\u00e9rprete no detectar\u00e1 ning\u00fan error hasta que el momento en que se intente evaluar la multiplicaci\u00f3n. Lo podemos comprobar con el siguiente ejemplo: 1 ( suma-cuadrados 10 hola ) Veremos m\u00e1s adelante que hay distintos tipos de n\u00fameros, y la funci\u00f3n definida va a funcionar bien para todos ellos. En el ejemplo anterior hemos pasado como par\u00e1metro n\u00fameros enteros. Podemos pasar n\u00fameros reales: 1 ( suma-cuadrados 2.4 5.8 ) ; \u21d2 39.4 o fracciones: 1 ( suma-cuadrados ( / 2 3 ) ( / 3 5 )) ; \u21d2 181/225 Algunas primitivas Las primitivas de Scheme consisten en un conjunto de tipos de datos, formas especiales y funciones incluidas en el lenguaje. A lo largo del curso iremos introduciendo estas primitivas. Las primitivas b\u00e1sicas del lenguaje est\u00e1n descritas en las 30 p\u00e1ginas del apartado 11 ( Base library ) del manual de referencia del R6RS. Vamos a revisar los tipos de datos primitivos de Scheme, as\u00ed como algunas funciones primitivas para trabajar con valores de esos tipos. Booleanos N\u00fameros Caracteres Cadenas Parejas Listas Estos dos \u00faltimos los veremos en detalle en futuras clases, cuando hablemos de tipos de datos compuestos. Booleanos Un booleano es un valor de verdad, que puede ser verdadero o falso. En Scheme, tenemos los s\u00edmbolos #t y #f para expresar verdadero y falso respectivamente, pero en muchas operaciones se considera que cualquier valor distinto de #f es verdadero. Ejemplos: 1 2 3 4 5 6 7 8 9 #t #f ( 3 1.5 ) ( = 3 3.0 ) ( equal? 3 3.0 ) ( or ( 3 1.5 ) #t ) ( and #t #t #f ) ( not #f ) ( not 3 ) N\u00fameros La cantidad de tipos num\u00e9ricos que soporta Scheme es grande, incluyendo enteros de diferente precisi\u00f3n, n\u00fameros racionales, complejos e inexactos. Algunas primitivas sobre n\u00fameros 1 2 3 4 5 6 7 8 9 ( = 2 3 3 4 5 ) ( max 3 5 10 1000 ) ( / 22 4 ) ; Devuelve una fracci\u00f3n ( div 22 4 ) ( mod 22 4 ) ( equal? 0.5 ( / 1 2 )) ( = 0.5 ( / 1 2 )) ( abs ( * 3 -2 )) ( sin 2.2 ) ; relacionados: cos, tan, asin, acos, ata Funciones de redondedo 1 2 3 4 5 6 7 8 9 10 11 12 ( floor x ) devuelve el entero m \u00e1 s grande no mayor que x ( ceiling x ) devuelve el entero m \u00e1 s peque \u00f1 o no menor que x ( truncate x ) devuelve el entero m \u00e1 s cercano a x cuyo valor absoluto no es mayor que el valor absoluto de x ( round x ) devuelve el entero m \u00e1 s cercano a x, redondeado ( floor -4.3 ) ; \u21d2 -5.0 ( floor 3.5 ) ; \u21d2 3.0 ( ceiling -4.3 ) ; \u21d2 -4.0 ( ceiling 3.5 ) ; \u21d2 4.0 ( truncate -4.3 ) ; \u21d2 -4.0 ( truncate 3.5 ) ; \u21d2 3.0 ( round -4.3 ) ; \u21d2 -4.0 ( round 3.5 ) ; \u21d2 4.0 Predicados sobre n\u00fameros Se denominan predicados a funciones que devuelven un booleano. 1 2 3 4 5 6 7 8 9 ( number? 1 ) ( integer? 2.3 ) ( integer? 4.0 ) ( real? 1 ) ( positive? -4 ) ( negative? -4 ) ( zero? 0.2 ) ( even? 2 ) ( odd? 3 ) Caracteres Se soportan caracteres internacionales y se codifican en UTF-8. 1 2 3 4 5 #\\a #\\A #\\space # \\\u00f1 # \\\u00e1 Operaciones sobre caracteres 1 2 3 4 5 6 7 8 9 10 ( char ? #\\a #\\b ) ( char-numeric? #\\1 ) ( char-alphabetic? #\\3 ) ( char-whitespace? #\\space ) ( char-upper-case? #\\A ) ( char-lower-case? #\\a ) ( char-upcase # \\\u00f1 ) ( char- integer #\\space ) ( integer- char 32 ) ;#\\space ( char- integer ( integer- char 5000 )) Cadenas Las cadenas son secuencias finitas de caracteres. 1 2 hola La palabra \\ hola\\ tiene 4 letras Constructores de cadenas 1 2 ( make-string 5 #\\o ) \u21d2 ooooo ( string #\\h #\\o #\\l #\\a ) \u21d2 hola Operaciones con cadenas 1 2 3 4 5 6 ( substring Hola que tal 2 4 ) ( string? hola ) ( string- list hola ) ( string-length hola ) ( string-ref hola 0 ) ( string-append hola adios ) Comparadores de cadenas 1 2 3 4 ( string=? Hola hola ) ( string=? hola hola ) ( string ? aab cde ) ( string =? www qqq ) Parejas Elemento fundamental de Scheme. Es un tipo compuesto formado por dos elementos (no necesariamente del mismo tipo). 1 2 3 4 ( cons 1 2 ) ; cons crea una pareja ( cons #t 3 ) ; elementos de tipos diferentes ( car ( cons hola 2 )) ; elemento izquierdo ( cdr ( cons bye 5 )) ; elemento derecho Cuando evaluamos las expresiones anteriores en el int\u00e9rprete, Scheme muestra el resultado de construir la pareja con la sintaxis: 1 { elemento izquierdo . elemento derecho } Por ejemplo: 1 ( cons 1 2 ) ; \u21d2 {1 . 2} Scheme es un lenguaje d\u00e9bilmente tipado y las variables y parejas pueden contener cualquier tipo de dato. Incluso otras parejas: 1 2 3 4 5 ( define p1 ( cons 1 2 )) ; definimos una pareja formada por 1 y 2 ( cons p1 3 ) ; definimos una pareja formada por la pareja (1 . 2) y 3 ; \u21d2 {{1 . 2} . 3} ( cons ( cons 1 2 ) 3 ) ; igual que la expresi\u00f3n anterior ; \u21d2 {{1 . 2} . 3} Hay veces que el trabajo de imprimir una pareja no es tan sencillo para Scheme. Si la pareja est\u00e1 en la parte derecha de la pareja principal el int\u00e9rprete imprime esto, que no se corresponde con lo que esperamos: 1 ( cons 1 ( cons 2 3 )) ; \u21d2 {1 2 . 3} M\u00e1s adelante explicaremos por qu\u00e9. Listas Uno de los elementos fundamentales de Scheme, y de Lisp, son las listas. Es un tipo compuesto formado por un conjunto finito de elementos (no necesariamente del mismo tipo). Vamos a ver c\u00f3mo definir, crear, recorrer y concatenar listas: Podemos crear una lista con la funci\u00f3n list : 1 ( list 1 2 3 4 ) ;list crea una lista El int\u00e9rprete de Scheme R6RS muestra las listas entre llaves: 1 ( list 1 2 3 4 ) ; \u21d2 {1 2 3 4} La forma m\u00e1s b\u00e1sica de trabajar con una lista es usando las funciones car para obtener su primer elemento y cdr para obtener el resto de la lista. Son las mismas funciones de las parejas, pero ahora se aplican a listas. Tambi\u00e9n veremos m\u00e1s adelante por qu\u00e9 estas funciones pueden trabajar tanto sobre parejas como sobre listas. 1 2 3 ( define l1 ( list 1 2 3 4 )) ; se crea la lista {1 2 3 4} y se guarda en l1 ( car l1 ) ; \u21d2 1 ( cdr l1 ) ; \u21d2 {2 3 4} El cdr de una lista siempre devuelve otra lista. El cdr de una lista de un elemento es la lista vac\u00eda , que en Scheme se representa con () : 1 2 3 4 ( define l2 ( list 1 2 3 )) ( cdr l2 ) ; \u21d2 {2 3} ( cdr ( cdr l2 )) ; \u21d2 {3} ( cdr ( cdr ( cdr l2 ))) ; \u21d2 () lista vac\u00eda La funci\u00f3n list sin argumentos devuelve una lista vac\u00eda y la funci\u00f3n null? comprueba si una lista es vac\u00eda. Es el caso base de gran parte de funciones recursivas que recorren listas. 1 2 3 ( list ) ; \u21d2 () ( null? ( list )) ; \u21d2 #t ( null? ( list 1 2 3 ) ; \u21d2 #f Podemos construir una nueva lista a\u00f1adiendo un elemento a la cabeza de una lista existente usando la funci\u00f3n cons (tambi\u00e9n la misma funci\u00f3n sobre pareja, ya explicaremos tambi\u00e9n por qu\u00e9) usando como par\u00e1metro un elemento y una lista: 1 ( cons elemento lista ) Por ejemplo: 1 2 3 ( cons 1 ( list 2 3 4 5 )) ; \u21d2 {1 2 3 4 5} ( cons 1 ( list )) \u21d2 { 1 } ( cons 1 ( cons 2 ( list ))) ; \u21d2 {1 2} Importante Cuando queramos a\u00f1adir un dato a la cabeza de una lista la lista siempre debe ser el segundo par\u00e1metro de la llamada a la funci\u00f3n. Si nos equivocamos y pasamos la lista como primer par\u00e1metro y el dato a a\u00f1adir como segundo, Scheme no da un error sino que construye una pareja cuyo primer elemento es una lista y su segundo elemento es el dato. Por ejemplo: 1 ( cons ( list 1 2 3 ) 4 ) ; \u21d2 {{1 2 3} . 4} Tambi\u00e9n podemos usar la funci\u00f3n append para concatenar dos o m\u00e1s listas 1 2 3 4 ( define l3 ( list 1 )) ( define l4 ( list 2 3 4 )) ( define l5 ( list 5 6 )) ( append l3 l4 l5 ) ; \u21d2 {1 2 3 4 5 6} Nota Si queremos a\u00f1adir un dato al final de una lista podemos hacerlo convirti\u00e9ndolo en una lista y usando append para concatenar la lista resultante al final de la primera: 1 2 3 4 5 6 ;;; Definimos la funci\u00f3n cons-al-final ( define ( cons-al-final x lista ) ( append lista ( list x ))) ;;; La probamos ( cons-al-final 10 ( list 1 2 3 )) ; \u21d2 {1 2 3 10} Igual que las parejas, las listas pueden contener distintos tipos de datos: 1 2 ( list hola que tal ) ; \u21d2 { hola que tal } lista de cadenas ( cons hola ( list 1 2 3 4 )) ; \u21d2 { hola 1 2 3 4} lista de distintos tipos de datos Una lista puede incluso contener otras listas: 1 2 3 4 5 6 ( list ( list 1 2 ) 3 4 ( list 5 6 )) ; lista que contiene listas ; \u21d2 {{1 2} 3 4 {5 6}} ( cons ( list 1 2 ) ( list 3 4 5 )) ; nueva lista a\u00f1adiendo una lista ; \u21d2 {{1 2} 3 4 5}} ( list ( cons 1 2 ) ( cons 3 4 )) ; lista que contiene parejas ; \u21d2 {{1 . 2} {3 . 4}} En clase de teor\u00eda estudiaremos con m\u00e1s profundidad las listas en Scheme, c\u00f3mo est\u00e1n implementadas y c\u00f3mo se utilizan para crear otras estructuras de datos m\u00e1s complejas como \u00e1rboles. Para este seminario de introducci\u00f3n es suficiente con estas funciones b\u00e1sicas que nos permiten crear, combinar y obtener elementos de listas. Estructuras de control Como en cualquier lenguaje de programaci\u00f3n, las estructuras de control en Scheme nos permiten seleccionar qu\u00e9 parte de una expresi\u00f3n evaluamos en funci\u00f3n de la evaluaci\u00f3n de una expresi\u00f3n condicional. Las estructuras de control las veremos con m\u00e1s detenimiento en las clases de teor\u00eda, ahora por el momento vamos a ver ejemplos de funcionamiento. En Scheme tenemos dos tipos de estructuras de control: if y cond . if Realiza una evaluaci\u00f3n condicional de las expresiones que la siguen, seg\u00fan el resultado de una condici\u00f3n. Una expresi\u00f3n if tiene siempre cuatro elementos: el propio if , la condici\u00f3n, la expresi\u00f3n que se eval\u00faa si la condici\u00f3n es verdadera y la expresi\u00f3n que se eval\u00faa si la expresi\u00f3n es falsa: 1 ( if ( 2 3 ) 2 es mayor que 3 2 es menor o igual que 3 ) Al escribir c\u00f3digo en Scheme es habitual colocar el if y la condici\u00f3n en una l\u00ednea y las otras dos expresiones en las siguientes l\u00edneas: 1 2 3 ( if ( 2 3 ) 2 es mayor que 3 2 es menor o igual que 3 ) En las expresiones que devuelven el valor cuando la condici\u00f3n es cierta o falsa se puede escribir cualquier expresi\u00f3n de Scheme, incluido otro if : 1 2 3 4 5 ( if ( 2 3 ) ( if ( 10 5 ) 2 es mayor que 3 y 10 es menor que 5 2 es mayor que 3 y 10 es mayor o igual que 5 ) 2 es menor o igual que 3 ) Un ejemplo en el que vemos una funci\u00f3n que contiene un if . La siguiente funci\u00f3n de tres argumentos devuelve la suma de los \u00faltimos si el primero es positivo o la resta en caso contrario: 1 2 3 4 5 6 7 ( define ( suma-si-x-positivo x y z ) ( if ( = x 0 ) ( + y z ) ( - y z ))) ( suma-si-x-positivo 2 3 5 ) ; \u21d2 8 ( suma-si-x-positivo -3 3 5 ) ; \u21d2 -2 cond Cuando tenemos un conjunto de alternativas o para evitar usar ifs anidados. cond eval\u00faa una serie de condiciones y devuelve el valor de la expresi\u00f3n asociada a la primera condici\u00f3n verdadera. 1 2 3 4 5 ( cond (( 3 4 ) 3 es mayor que 4 ) (( 2 1 ) 2 es menor que 1 ) (( 3 2 ) 3 es mayor que 2 ) ( else ninguna condicion es cierta )) Comentarios Para comentar una l\u00ednea de c\u00f3digo en la ventana de definiciones, se escribe el s\u00edmbolo punto y coma ; al comienzo de la l\u00ednea. Si queremos comentar m\u00e1s de una l\u00ednea, podemos utilizar el men\u00fa de DrRacket: seleccionamos las l\u00edneas a comentar y pinchamos en la opci\u00f3n Racket - comentar con punto y coma. Ejemplos completos Ra\u00edz de segundo grado Vamos a resolver la ecuaci\u00f3n de segundo grado en Scheme. Vamos a implementar el procedimiento (ecuacion a b c) que devuelva una pareja con las dos ra\u00edces de la soluci\u00f3n. Nos vamos a ayudar de funciones auxiliares. Recordamos la f\u00f3rmula: Nota En lugar de definir una funci\u00f3n con una expresi\u00f3n muy larga compuesta de muchas expresiones anidadas, vamos a implementar la soluci\u00f3n de forma modular, definiendo funciones auxiliares . Primer definimos la funci\u00f3n que define el discriminante: 1 2 ( define ( discriminante a b c ) ( - ( * b b ) ( * 4 a c ))) Despu\u00e9s definimos las funciones que devuelven la ra\u00edz positiva y la ra\u00edz negativa, usando la funci\u00f3n discriminante anterior: 1 2 3 4 5 ( define ( raiz-pos a b c ) ( / ( + ( * b -1 ) ( sqrt ( discriminante a b c ))) ( * 2 a ))) ( define ( raiz-neg a b c ) ( / ( - ( * b -1 ) ( sqrt ( discriminante a b c ))) ( * 2 a ))) Por \u00faltimo, definimos la funci\u00f3n ecuacion que invoca a las funciones anteriores y devuelve una pareja con los valores resultantes: 1 2 ( define ( ecuacion a b c ) ( cons ( raiz-pos a b c ) ( raiz-neg a b c ))) Lo probamos: 1 2 3 4 5 6 ( ecuacion 1 -5 6 ) ; \u21d2 {3 . 2} ( ecuacion 2 -7 3 ) ; \u21d2 {3 . 1/2} ( ecuacion -1 7 -10 ) ; \u21d2 {2 . 5} Conversi\u00f3n de grados Celsius a Farenheit Vamos a definir una funci\u00f3n llamada convertir-temperatura que permite realizar una conversi\u00f3n de grados Fahrenheit a Cent\u00edgrados o vicerversa. La funci\u00f3n toma dos argumentos, el primero ser\u00e1 un n\u00famero que representa los grados y el segundo ser\u00e1 un car\u00e1cter ( F o C ) que indica la unidad de medida en la que est\u00e1n expresados los grados. Las f\u00f3rmulas de conversi\u00f3n son las siguientes: Primero definimos unas funciones auxiliares que calculan las expresiones anteriores: 1 2 3 4 5 ( define ( a-grados-fahrenheit grados-centigrados ) ( + ( * ( / 9 5 ) grados-centigrados ) 32 )) ( define ( a-grados-centigrados grados-fahrenheit ) ( * ( / 5 9 ) ( - grados-fahrenheit 32 ))) Y ahora ya podemos definir la funci\u00f3n principal: 1 2 3 4 ( define ( convertir-temperatura grados tipo ) ( cond (( equal? tipo #\\F ) ( list ( a-grados-centigrados grados ) grados centigrados )) (( equal? tipo #\\C ) ( list ( a-grados-fahrenheit grados ) grados fahrenheit )) ( else tipo de cambio incorrecto ))) Por ejemplo: 1 2 ( convertir-temperatura 50 #\\F ) ; = {10 grados centigrados } ( convertir-temperatura 50 #\\C ) ; = {122 grados fahrenheit } Funci\u00f3n display Para imprimir por pantalla en Scheme se pude usar la funci\u00f3n display , similar a la sentencia print de muchos otros lenguajes. 1 2 3 4 5 6 7 # lang r6rs ( import ( rnrs )) ( display \\nHola mundo!\\n ) ( display La suma de 2 + 3 es: ) ( display ( + 2 3 )) ( display \\n ) Pruebas unitarias en Scheme Para verificar que las funciones que definimos tienen un funcionamiento correcto, es decir, \"hacen lo que tienen que hacer\" , podemos dise\u00f1ar distintos casos de prueba. Cada caso de prueba se caracteriza por unos datos de entrada de la funci\u00f3n y por el resultado que esperamos que devuelva dicha funci\u00f3n con esos valores de entrada. Por ejemplo, en las pruebas de la funci\u00f3n convertir-temperatura , hemos dise\u00f1ado dos casos de prueba: Datos de Entrada Resultado Esperado 50 , #\\F {10 \"grados centigrados\"} 50 , #\\C {122 \"grados fahrenheit\"} El resultado esperado a partir de unos valores concretos de entrada, se determina entendiendo qu\u00e9 debe hacer la funci\u00f3n. Es decir, se obtiene a partir de la especificaci\u00f3n del problema, antes de plantearnos c\u00f3mo solucionarlo. Os aconsejamos tener siempre presente la siguiente idea aunque resulte obvia: Para implementar una funci\u00f3n, primero es imprescindible entender qu\u00e9 debe hacer la funci\u00f3n . Despu\u00e9s, seremos capaces de dise\u00f1ar casos de prueba y ocuparnos de c\u00f3mo implementarla . En las pr\u00e1cticas de la asignatura, para realizar pruebas usaremos el API SchemeUnit . Para ello, lo primero que tendremos que hacer es importar esta nueva librer\u00eda. Por tanto, debemos a\u00f1adir en nuestros ficheros de pr\u00e1cticas lo siguiente: 1 2 ( import ( rnrs ) ( schemeunit )) Una vez importada la librer\u00eda, ya podemos hacer uso de algunas de sus funciones. En concreto, utilizaremos las siguientes: check-true 1 2 3 ( check-true expr ) ;; Comprueba si su argumento es #t. ;; En caso contrario, se imprime un mensaje de error. check-false 1 2 3 ( check-false expr ) ;; Comprueba si su argumento es #f. ;; En caso contrario, se imprime un mensaje de error. check-equal? 1 2 3 ( check-equal? resultado-real resultado-esperado ) ;; Comprueba si sus dos argumentos son iguales. ;; En caso contrario, se imprime un mensaje de error. Con las funciones check-true y check-false validaremos predicados (recuerda que en Scheme son funciones que devuelven un valor booleano) que hayamos implementado, comprobando si el resultado esperado es true o false , respectivamente. Con la funci\u00f3n check-equal? podremos validar si el resultado de la invocaci\u00f3n a la funci\u00f3n con unos determinados valores de entrada, representado por el argumento resultado-real , es igual al resultado que esperamos, dado por el argumento resultado-esperado . Ejemplo de pruebas de la funci\u00f3n ecuacion definida anteriormente Las siguientes pruebas no mostrar\u00e1n ning\u00fan mensaje de error, lo que significa que nuestra funci\u00f3n ecuacion es 'CORRECTA' para estas pruebas, es decir, que con los valores de entrada utilizados, su resultado se corresponde con el esperado. 1 2 3 ( check-equal? ( ecuacion 1 -5 6 ) ( cons 3 2 )) ( check-equal? ( ecuacion 2 -7 3 ) ( cons 3 ( / 1 2 )) ) ( check-equal? ( ecuacion -1 7 -10 ) ( cons 2 5 )) Ahora vamos a suponer que nos hemos equivocado en la definici\u00f3n de la funci\u00f3n ecuacion , por ejemplo en el orden de los argumentos al invocar a la funci\u00f3n auxiliar raiz-pos , en la llamada que se hace en la parte izquierda de la pareja resultante. 1 2 ( define ( ecuacion a b c ) ( cons ( raiz-pos b a c ) ( raiz-neg a b c ))) Con esta nueva definici\u00f3n, si ejecutamos la siguiente prueba: 1 ( check-equal? ( ecuacion 1 -5 6 ) ( cons 3 2 )) el resultado ser\u00e1: 1 2 3 4 5 6 7 8 -------------------- FAILURE actual: {-1 . 2} expected: {3 . 2} name: check-equal? location: (# path:/.../filename.rkt ) expression: (check-equal? (ecuacion 1 -5 6) (cons 3 2)) -------------------- Esta prueba muestra un mensaje de error, lo que significa que la nueva definici\u00f3n de ecuacion 'FALLA', es decir, que el resultado que devuelve {-1 . 2} no coincide con el resultado esperado {3 . 2} . Ejercicios Ejercicio 1 Lanza DrRacket y escribe cada una de las siguientes instrucciones en el int\u00e9rprete, intentado adivinar el resultado que va devolver. Est\u00e1n ordenadas por dificultad de arriba abajo y de izquierda a derecha. \u00a1\u00a1Piensa en los resultados!!. Intenta entender c\u00f3mo interpreta Scheme lo que escribes. Instrucci\u00f3n Instrucci\u00f3n 3 (+ (- 4 (* 3 (/ 4 2) 4)) 3) (+ 1 2 ) ( (+ (+ 2 3) 4) ( (* 3 3) 2)) (+ 1 2 3 4) (* (+ 2 3 4 5) 3 (- 5 2 1)) (+) (+ (- (+ (- (+ 2 3) 5) 1) 2) 3) (sqrt 25) (- (sqrt (* 5 ( + 3 2))) (+ 1 1 1 1)) (* (+ 2 3) 5) ( ( 3 (+ 2 (+ 3 1)) (+ 1 1)) (+ ( 2 2) 3)) + (= (* 3 2) (+ 1 (+ 2 2) 1)) #\\+ (not ( (+ 3 2) 5)) \"+\" (and (even? 2) (odd? (+ 3 2))) \"hola\" (mod (+ 6 2) (+ 1 1)) Ejercicio 2 Predice lo que devolver\u00e1 Scheme cuando escribas las siguientes expresiones. Est\u00e1n ordenadas por dificultad de arriba abajo y de izquierda a derecha. Despu\u00e9s, pru\u00e9balas y comprueba si tu predicci\u00f3n era correcta. Si no lo era, intenta comprender por qu\u00e9. Instrucci\u00f3n Instrucci\u00f3n (equal? \"hola\" \"hola\") (+ (char- integer(integer- char 1200))(char- integer #\\A)) (string-ref \"pepe\" 1) (string-length (make-string 7 #\\E)) (substring \"buenos dias\" 1 4) (define a 3) (define b (+ a 1)) (= \"hola\" \"hola\") (+ a b (* a b)) (string-ref (substring \"buenos dias 2 5) 1) (= a b) (define pi 3.14159) (if (and ( a b) ( b (* a b))) b a) pi (cond ((= a 4) 6) ((= b 4) (+ 6 7 a)) (else 25)) \"pi\" (+ 2 (if ( b a) b a)) (+ pi (+ pi pi)) (* (cond (( a b) a) (( a b) b) (else -1)) (+ a 1)) (+ (* pi pi) (- 2 pi pi pi pi)) ((if ( a b) + -) a b) Ejercicio 3 Ejercicios con parejas. Predice lo que hace Scheme cuando escribas las siguientes expresiones. Est\u00e1n ordenadas por dificultad de arriba abajo y de izquierda a derecha. Despu\u00e9s, pru\u00e9balas y comprueba si tu predicci\u00f3n era correcta. Si no lo era, intenta comprender por qu\u00e9. Instrucci\u00f3n Instrucci\u00f3n (cons 1 2) (car (cons (cons 3 4) 2)) (car (cons 1 2)) (cdr (cons (cons 3 4) 2)) (cdr (cons 1 2)) (cdr (cons 1 (cons 2 3))) (car (car (cons (cons 1 2) 3))) (cdr (car (cons (cons 1 2) 3))) Ejercicio 4 Ejercicios con listas. Predice lo que hace Scheme cuando escribas las siguientes expresiones. Despu\u00e9s, pru\u00e9balas y comprueba si tu predicci\u00f3n era correcta. Si no lo era, intenta comprender por qu\u00e9. Instrucci\u00f3n Instrucci\u00f3n (list 1 2 3 4) (cons 3 (list 1 2 3)) (cdr (list 1 2 3 4)) (cdr (cons 8 (list 1 2 3 4))) (car (list 1 2 3 4)) (car (list (list 1 2) 1 2 3 4)) (list 1 (list 2 3) (list 4 (list 5))) (list 1 (list 2 3) (list 4 (list 5))) (car (cdr (list 1 2 3 4))) (cons (list 1 2 3) (list 4 5 6)) (cdr (cdr (list 1 2 3 4))) (car (cdr (list 1 2 3 4))) (list 1 2 3 4) (cdr (cdr (list 1 2 3 4))) Ejercicio 5 Los siguientes apartados intenta hacerlos sin utilizar el int\u00e9rprete de Scheme. a) Dada la siguiente lista, indica la expresi\u00f3n correcta para que Scheme devuelva 5: 1 ( list 1 2 3 4 5 6 7 8 ) b) Dada la siguiente lista, indica la expresi\u00f3n correcta para que Scheme devuelva (8). 1 ( list 1 2 3 4 5 6 7 8 ) c) Dada la siguiente lista, indica la expresi\u00f3n correcta para que Scheme devuelva 8. 1 ( list 1 2 3 4 5 6 7 8 ) d) Dada la siguiente expresi\u00f3n, \u00bfqu\u00e9 devuelve Scheme? 1 ( car ( cdr ( cdr ( list 1 ( list 2 3 ) ( list 4 5 ) 6 )))) e) Dada la siguiente expresi\u00f3n, \u00bfqu\u00e9 devuelve Scheme? 1 ( cdr ( cdr ( list 1 ( list 2 3 ) 4 5 ))) Lenguajes y Paradigmas de Programaci\u00f3n, curso 2018-19 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Domingo Gallardo, Cristina Pomares, Antonio Bot\u00eda, Francisco Mart\u00ednez","title":"Seminario de Scheme"},{"location":"seminarios/seminario1-scheme/seminario1-scheme.html#seminario-1-seminario-de-scheme","text":"","title":"Seminario 1: Seminario de Scheme"},{"location":"seminarios/seminario1-scheme/seminario1-scheme.html#bibliografia","text":"Este seminario est\u00e1 basado en los siguientes materiales. Os recomendamos que les ech\u00e9is un vistazo y, si os interesa y os queda tiempo, que explor\u00e9is tambi\u00e9n en los enlaces que hemos dejado en los apuntes para ampliar informaci\u00f3n. DrRacket , Entorno de programaci\u00f3n DrRacket R6RS base (pdf) (html) Librer\u00edas R6RS (pdf) (html) Simply Scheme","title":"Bibliograf\u00eda"},{"location":"seminarios/seminario1-scheme/seminario1-scheme.html#el-lenguaje-de-programacion-scheme","text":"Scheme es un lenguaje de programaci\u00f3n que surgi\u00f3 en los laboratorios del MIT en 1975, cuando Guy L. Steele y Gerarld J. Sussman buscaban un lenguaje con una sem\u00e1ntica muy clara y sencilla. Scheme es un dialecto de Lisp, es un lenguaje interpretado, muy expresivo y soporta varios paradigmas. Estuvo influenciado por el c\u00e1lculo lambda. El desarrollo de Scheme ha sido lento, ya que la gente que estandariz\u00f3 Scheme es muy conservadora en cuanto a a\u00f1adirle nuevas caracter\u00edsticas,porque la calidad ha sido siempre m\u00e1s importante que la utilidad empresarial. Por eso Scheme es considerado como uno de los lenguajes mejor dise\u00f1ados de prop\u00f3sito general. Aprender Scheme har\u00e1 que se\u00e1is mejores programadores cuando utilic\u00e9is otros lenguajes de programaci\u00f3n.","title":"El lenguaje de programaci\u00f3n Scheme"},{"location":"seminarios/seminario1-scheme/seminario1-scheme.html#el-entorno-de-programacion-drracket","text":"Cuando lanzamos DrRacket, vemos que tiene tres partes: una fila de botones arriba, dos paneles de edici\u00f3n en el medio y una barra de estado abajo. El panel de edici\u00f3n superior es la ventana de definiciones. Se utiliza para implementar funciones, como la funci\u00f3n square en el ejemplo. El panel inferior, llamado ventana de interacci\u00f3n , se utiliza para evaluar expresiones interactivamente. Pulsando el bot\u00f3n Run , se eval\u00faa el programa de la ventana de definiciones , haciendo que esas definiciones est\u00e9n disponibles en la ventana de interacci\u00f3n. As\u00ed, dada la definici\u00f3n de square , despu\u00e9s de pulsar Run , podemos teclear la expresi\u00f3n (square 2) en la ventana de interacci\u00f3n , se evaluar\u00e1 y mostrar\u00e1 el resultado, en este caso 4.","title":"El entorno de programaci\u00f3n DrRacket"},{"location":"seminarios/seminario1-scheme/seminario1-scheme.html#cambiar-el-idioma-del-entorno","text":"Podemos interactuar con el entorno en el idioma que queramos. Si queremos tenerlo por ejemplo en espa\u00f1ol, vamos al men\u00fa Help - Interact\u00faa con DrRacket en espa\u00f1ol . Nos aparecer\u00e1 un di\u00e1logo que nos obligar\u00e1 a reiniciar el int\u00e9rprete para aceptar los cambios.","title":"Cambiar el idioma del entorno"},{"location":"seminarios/seminario1-scheme/seminario1-scheme.html#eligiendo-un-lenguaje","text":"DrRacket soporta muchos dialectos de Scheme, entre los cuales se encuentra su primera versi\u00f3n est\u00e1ndar IEEE, llamada R5RS ( Revised 5 Report on the Algorithmic Language Scheme ), que aparece en el a\u00f1o 1998. Nosotros vamos a utilizar la siguiente versi\u00f3n R6RS (2007). Para ello, cuando arranquemos DrRacket, debemos hacer lo siguiente: Asegurarnos que en la parte inferior de la ventana aparece \" Determine language from source \" En el panel de edici\u00f3n debemos escribir las siguientes l\u00edneas: 1 2 3 4 `` ` scheme #lang r6rs ( import ( rnrs )) `` ` Finalmente pulsar el bot\u00f3n Run (Ejecutar) para que se cargue ese lenguaje en el int\u00e9rprete. Aclaraciones La l\u00ednea de c\u00f3digo 1 # lang r6rs es una directiva de DrRacket que determina qu\u00e9 lenguaje ser\u00e1 interpretado. La l\u00ednea 1 ( import ( rnrs )) Permite importar la librer\u00eda rnrs , que es la librer\u00eda que contiene todas las funciones del lenguaje r6rs. Adem\u00e1s de \u00e9sta, en la asignatura usaremos otras librer\u00edas que se indicar\u00e1n en los correspondientes enunciados de las pr\u00e1cticas cuando sean necesarias.","title":"Eligiendo un lenguaje"},{"location":"seminarios/seminario1-scheme/seminario1-scheme.html#el-lenguaje-scheme","text":"","title":"El lenguaje Scheme"},{"location":"seminarios/seminario1-scheme/seminario1-scheme.html#vamos-a-empezar-probando-algunos-ejemplos","text":"Scheme es un lenguaje interpretado. Vamos a lanzar DrRacket y teclear en la ventana de interacci\u00f3n algunas expresiones. El int\u00e9rprete analizar\u00e1 la expresi\u00f3n y mostrar\u00e1 el valor resultante de evaluarla. 1 2 3 4 5 2 ( + 2 3 ) ( + ) ( + 2 4 5 6 ) ( + ( * 2 3 ) ( - 3 1 )) Las expresiones en Scheme tienen una forma denominada notaci\u00f3n prefija de Cambridge (el nombre de Cambridge es por la localidad Cambridge, Massachusets, donde reside el MIT, lugar en el que se ide\u00f3 el Lisp), en la que la expresi\u00f3n est\u00e1 delimitada por par\u00e9ntesis y el operador va seguido de los operandos. La sintaxis es la siguiente: 1 ( funci \u00f3 n arg1 ... argn ) En Scheme podemos interpretar los par\u00e9ntesis abiertos \u2018(\u2019 como evaluadores o lanzadores de la funci\u00f3n que hay a continuaci\u00f3n. La forma que tiene Scheme de evaluar una expresi\u00f3n es muy sencilla: Eval\u00faa cada uno de los argumentos Aplica la funci\u00f3n nombrada tras el par\u00e9ntesis a los valores resultantes de la evaluaci\u00f3n anterior 1 2 3 4 5 ( + ( * 2 3 ) ( - 3 ( / 12 3 ))) \u21d2 ( + 6 ( - 3 ( / 12 3 ))) \u21d2 ( + 6 ( - 3 4 )) \u21d2 ( + 6 -1 ) \u21d2 5 En Scheme los t\u00e9rminos funci\u00f3n y procedimiento significan lo mismo y se usan de forma intercambiable. Son ejemplos de funciones o procedimientos: +, -, *. En Scheme la evaluaci\u00f3n de una funci\u00f3n siempre devuelve un valor, a no ser que se produzca un error que detiene la evaluaci\u00f3n: 1 ( * ( + 3 4 ) ( / 3 0 ))","title":"Vamos a empezar probando algunos ejemplos"},{"location":"seminarios/seminario1-scheme/seminario1-scheme.html#definiendo-variables-y-funciones","text":"Podemos utilizar en el int\u00e9rprete la forma especial define para definir variables y funciones. En clase de teor\u00eda veremos c\u00f3mo es el funcionamiento del define , pero por el momento lo utilizaremos para definir variables asociadas a valores, e implementar funciones o procedimientos. Scheme es un lenguaje multiparadigma pero principalmente funcional, y una de sus caracter\u00edsticas principales es que los programas se construyen mediante la definici\u00f3n de funciones. Definimos variables en la ventana de interacci\u00f3n: 1 2 3 4 5 ( define pi 3.14159 ) pi ( sin ( / pi 2 )) ( define a ( + 2 ( * 3 4 ))) a Para implementar una funci\u00f3n tambi\u00e9n se utiliza define, con la siguiente sintaxis: 1 2 3 ( define ( nombre-funcion args ) cuerpo-funcion ) Por ejemplo, vamos a implementar una funci\u00f3n que toma dos n\u00fameros como par\u00e1metros y devuelve la suma de sus cuadrados: 1 2 ( define ( suma-cuadrados x y ) ( + ( * x x ) ( * y y ))) Si llamamos a la funci\u00f3n pasando el 2 y el 3 como par\u00e1metros, la funci\u00f3n devuelve el n\u00famero 13: 1 ( suma-cuadrados 2 3 ) ; \u21d2 13 Nota A diferencia de la mayor\u00eda de lenguajes de programaci\u00f3n, en Scheme no se utiliza la palabra return para indicar que una funci\u00f3n devuelve un valor. Las funciones se definen con una \u00fanica expresi\u00f3n y el resultado calculado en esa expresi\u00f3n es el que siempre se devuelve. Podemos comprobar una caracter\u00edstica muy importante de Scheme. Se trata de un lenguaje d\u00e9bilmente tipado , en el que los argumentos x e y no tienen tipo. Si se invoca a la funci\u00f3n pasando alg\u00fan dato que no sea un n\u00famero, el int\u00e9rprete no detectar\u00e1 ning\u00fan error hasta que el momento en que se intente evaluar la multiplicaci\u00f3n. Lo podemos comprobar con el siguiente ejemplo: 1 ( suma-cuadrados 10 hola ) Veremos m\u00e1s adelante que hay distintos tipos de n\u00fameros, y la funci\u00f3n definida va a funcionar bien para todos ellos. En el ejemplo anterior hemos pasado como par\u00e1metro n\u00fameros enteros. Podemos pasar n\u00fameros reales: 1 ( suma-cuadrados 2.4 5.8 ) ; \u21d2 39.4 o fracciones: 1 ( suma-cuadrados ( / 2 3 ) ( / 3 5 )) ; \u21d2 181/225","title":"Definiendo variables y funciones"},{"location":"seminarios/seminario1-scheme/seminario1-scheme.html#algunas-primitivas","text":"Las primitivas de Scheme consisten en un conjunto de tipos de datos, formas especiales y funciones incluidas en el lenguaje. A lo largo del curso iremos introduciendo estas primitivas. Las primitivas b\u00e1sicas del lenguaje est\u00e1n descritas en las 30 p\u00e1ginas del apartado 11 ( Base library ) del manual de referencia del R6RS. Vamos a revisar los tipos de datos primitivos de Scheme, as\u00ed como algunas funciones primitivas para trabajar con valores de esos tipos. Booleanos N\u00fameros Caracteres Cadenas Parejas Listas Estos dos \u00faltimos los veremos en detalle en futuras clases, cuando hablemos de tipos de datos compuestos.","title":"Algunas primitivas"},{"location":"seminarios/seminario1-scheme/seminario1-scheme.html#parejas","text":"Elemento fundamental de Scheme. Es un tipo compuesto formado por dos elementos (no necesariamente del mismo tipo). 1 2 3 4 ( cons 1 2 ) ; cons crea una pareja ( cons #t 3 ) ; elementos de tipos diferentes ( car ( cons hola 2 )) ; elemento izquierdo ( cdr ( cons bye 5 )) ; elemento derecho Cuando evaluamos las expresiones anteriores en el int\u00e9rprete, Scheme muestra el resultado de construir la pareja con la sintaxis: 1 { elemento izquierdo . elemento derecho } Por ejemplo: 1 ( cons 1 2 ) ; \u21d2 {1 . 2} Scheme es un lenguaje d\u00e9bilmente tipado y las variables y parejas pueden contener cualquier tipo de dato. Incluso otras parejas: 1 2 3 4 5 ( define p1 ( cons 1 2 )) ; definimos una pareja formada por 1 y 2 ( cons p1 3 ) ; definimos una pareja formada por la pareja (1 . 2) y 3 ; \u21d2 {{1 . 2} . 3} ( cons ( cons 1 2 ) 3 ) ; igual que la expresi\u00f3n anterior ; \u21d2 {{1 . 2} . 3} Hay veces que el trabajo de imprimir una pareja no es tan sencillo para Scheme. Si la pareja est\u00e1 en la parte derecha de la pareja principal el int\u00e9rprete imprime esto, que no se corresponde con lo que esperamos: 1 ( cons 1 ( cons 2 3 )) ; \u21d2 {1 2 . 3} M\u00e1s adelante explicaremos por qu\u00e9.","title":"Parejas"},{"location":"seminarios/seminario1-scheme/seminario1-scheme.html#listas","text":"Uno de los elementos fundamentales de Scheme, y de Lisp, son las listas. Es un tipo compuesto formado por un conjunto finito de elementos (no necesariamente del mismo tipo). Vamos a ver c\u00f3mo definir, crear, recorrer y concatenar listas: Podemos crear una lista con la funci\u00f3n list : 1 ( list 1 2 3 4 ) ;list crea una lista El int\u00e9rprete de Scheme R6RS muestra las listas entre llaves: 1 ( list 1 2 3 4 ) ; \u21d2 {1 2 3 4} La forma m\u00e1s b\u00e1sica de trabajar con una lista es usando las funciones car para obtener su primer elemento y cdr para obtener el resto de la lista. Son las mismas funciones de las parejas, pero ahora se aplican a listas. Tambi\u00e9n veremos m\u00e1s adelante por qu\u00e9 estas funciones pueden trabajar tanto sobre parejas como sobre listas. 1 2 3 ( define l1 ( list 1 2 3 4 )) ; se crea la lista {1 2 3 4} y se guarda en l1 ( car l1 ) ; \u21d2 1 ( cdr l1 ) ; \u21d2 {2 3 4} El cdr de una lista siempre devuelve otra lista. El cdr de una lista de un elemento es la lista vac\u00eda , que en Scheme se representa con () : 1 2 3 4 ( define l2 ( list 1 2 3 )) ( cdr l2 ) ; \u21d2 {2 3} ( cdr ( cdr l2 )) ; \u21d2 {3} ( cdr ( cdr ( cdr l2 ))) ; \u21d2 () lista vac\u00eda La funci\u00f3n list sin argumentos devuelve una lista vac\u00eda y la funci\u00f3n null? comprueba si una lista es vac\u00eda. Es el caso base de gran parte de funciones recursivas que recorren listas. 1 2 3 ( list ) ; \u21d2 () ( null? ( list )) ; \u21d2 #t ( null? ( list 1 2 3 ) ; \u21d2 #f Podemos construir una nueva lista a\u00f1adiendo un elemento a la cabeza de una lista existente usando la funci\u00f3n cons (tambi\u00e9n la misma funci\u00f3n sobre pareja, ya explicaremos tambi\u00e9n por qu\u00e9) usando como par\u00e1metro un elemento y una lista: 1 ( cons elemento lista ) Por ejemplo: 1 2 3 ( cons 1 ( list 2 3 4 5 )) ; \u21d2 {1 2 3 4 5} ( cons 1 ( list )) \u21d2 { 1 } ( cons 1 ( cons 2 ( list ))) ; \u21d2 {1 2} Importante Cuando queramos a\u00f1adir un dato a la cabeza de una lista la lista siempre debe ser el segundo par\u00e1metro de la llamada a la funci\u00f3n. Si nos equivocamos y pasamos la lista como primer par\u00e1metro y el dato a a\u00f1adir como segundo, Scheme no da un error sino que construye una pareja cuyo primer elemento es una lista y su segundo elemento es el dato. Por ejemplo: 1 ( cons ( list 1 2 3 ) 4 ) ; \u21d2 {{1 2 3} . 4} Tambi\u00e9n podemos usar la funci\u00f3n append para concatenar dos o m\u00e1s listas 1 2 3 4 ( define l3 ( list 1 )) ( define l4 ( list 2 3 4 )) ( define l5 ( list 5 6 )) ( append l3 l4 l5 ) ; \u21d2 {1 2 3 4 5 6} Nota Si queremos a\u00f1adir un dato al final de una lista podemos hacerlo convirti\u00e9ndolo en una lista y usando append para concatenar la lista resultante al final de la primera: 1 2 3 4 5 6 ;;; Definimos la funci\u00f3n cons-al-final ( define ( cons-al-final x lista ) ( append lista ( list x ))) ;;; La probamos ( cons-al-final 10 ( list 1 2 3 )) ; \u21d2 {1 2 3 10} Igual que las parejas, las listas pueden contener distintos tipos de datos: 1 2 ( list hola que tal ) ; \u21d2 { hola que tal } lista de cadenas ( cons hola ( list 1 2 3 4 )) ; \u21d2 { hola 1 2 3 4} lista de distintos tipos de datos Una lista puede incluso contener otras listas: 1 2 3 4 5 6 ( list ( list 1 2 ) 3 4 ( list 5 6 )) ; lista que contiene listas ; \u21d2 {{1 2} 3 4 {5 6}} ( cons ( list 1 2 ) ( list 3 4 5 )) ; nueva lista a\u00f1adiendo una lista ; \u21d2 {{1 2} 3 4 5}} ( list ( cons 1 2 ) ( cons 3 4 )) ; lista que contiene parejas ; \u21d2 {{1 . 2} {3 . 4}} En clase de teor\u00eda estudiaremos con m\u00e1s profundidad las listas en Scheme, c\u00f3mo est\u00e1n implementadas y c\u00f3mo se utilizan para crear otras estructuras de datos m\u00e1s complejas como \u00e1rboles. Para este seminario de introducci\u00f3n es suficiente con estas funciones b\u00e1sicas que nos permiten crear, combinar y obtener elementos de listas.","title":"Listas"},{"location":"seminarios/seminario1-scheme/seminario1-scheme.html#estructuras-de-control","text":"Como en cualquier lenguaje de programaci\u00f3n, las estructuras de control en Scheme nos permiten seleccionar qu\u00e9 parte de una expresi\u00f3n evaluamos en funci\u00f3n de la evaluaci\u00f3n de una expresi\u00f3n condicional. Las estructuras de control las veremos con m\u00e1s detenimiento en las clases de teor\u00eda, ahora por el momento vamos a ver ejemplos de funcionamiento. En Scheme tenemos dos tipos de estructuras de control: if y cond .","title":"Estructuras de control"},{"location":"seminarios/seminario1-scheme/seminario1-scheme.html#if","text":"Realiza una evaluaci\u00f3n condicional de las expresiones que la siguen, seg\u00fan el resultado de una condici\u00f3n. Una expresi\u00f3n if tiene siempre cuatro elementos: el propio if , la condici\u00f3n, la expresi\u00f3n que se eval\u00faa si la condici\u00f3n es verdadera y la expresi\u00f3n que se eval\u00faa si la expresi\u00f3n es falsa: 1 ( if ( 2 3 ) 2 es mayor que 3 2 es menor o igual que 3 ) Al escribir c\u00f3digo en Scheme es habitual colocar el if y la condici\u00f3n en una l\u00ednea y las otras dos expresiones en las siguientes l\u00edneas: 1 2 3 ( if ( 2 3 ) 2 es mayor que 3 2 es menor o igual que 3 ) En las expresiones que devuelven el valor cuando la condici\u00f3n es cierta o falsa se puede escribir cualquier expresi\u00f3n de Scheme, incluido otro if : 1 2 3 4 5 ( if ( 2 3 ) ( if ( 10 5 ) 2 es mayor que 3 y 10 es menor que 5 2 es mayor que 3 y 10 es mayor o igual que 5 ) 2 es menor o igual que 3 ) Un ejemplo en el que vemos una funci\u00f3n que contiene un if . La siguiente funci\u00f3n de tres argumentos devuelve la suma de los \u00faltimos si el primero es positivo o la resta en caso contrario: 1 2 3 4 5 6 7 ( define ( suma-si-x-positivo x y z ) ( if ( = x 0 ) ( + y z ) ( - y z ))) ( suma-si-x-positivo 2 3 5 ) ; \u21d2 8 ( suma-si-x-positivo -3 3 5 ) ; \u21d2 -2","title":"if"},{"location":"seminarios/seminario1-scheme/seminario1-scheme.html#cond","text":"Cuando tenemos un conjunto de alternativas o para evitar usar ifs anidados. cond eval\u00faa una serie de condiciones y devuelve el valor de la expresi\u00f3n asociada a la primera condici\u00f3n verdadera. 1 2 3 4 5 ( cond (( 3 4 ) 3 es mayor que 4 ) (( 2 1 ) 2 es menor que 1 ) (( 3 2 ) 3 es mayor que 2 ) ( else ninguna condicion es cierta ))","title":"cond"},{"location":"seminarios/seminario1-scheme/seminario1-scheme.html#comentarios","text":"Para comentar una l\u00ednea de c\u00f3digo en la ventana de definiciones, se escribe el s\u00edmbolo punto y coma ; al comienzo de la l\u00ednea. Si queremos comentar m\u00e1s de una l\u00ednea, podemos utilizar el men\u00fa de DrRacket: seleccionamos las l\u00edneas a comentar y pinchamos en la opci\u00f3n Racket - comentar con punto y coma.","title":"Comentarios"},{"location":"seminarios/seminario1-scheme/seminario1-scheme.html#ejemplos-completos","text":"","title":"Ejemplos completos"},{"location":"seminarios/seminario1-scheme/seminario1-scheme.html#raiz-de-segundo-grado","text":"Vamos a resolver la ecuaci\u00f3n de segundo grado en Scheme. Vamos a implementar el procedimiento (ecuacion a b c) que devuelva una pareja con las dos ra\u00edces de la soluci\u00f3n. Nos vamos a ayudar de funciones auxiliares. Recordamos la f\u00f3rmula: Nota En lugar de definir una funci\u00f3n con una expresi\u00f3n muy larga compuesta de muchas expresiones anidadas, vamos a implementar la soluci\u00f3n de forma modular, definiendo funciones auxiliares . Primer definimos la funci\u00f3n que define el discriminante: 1 2 ( define ( discriminante a b c ) ( - ( * b b ) ( * 4 a c ))) Despu\u00e9s definimos las funciones que devuelven la ra\u00edz positiva y la ra\u00edz negativa, usando la funci\u00f3n discriminante anterior: 1 2 3 4 5 ( define ( raiz-pos a b c ) ( / ( + ( * b -1 ) ( sqrt ( discriminante a b c ))) ( * 2 a ))) ( define ( raiz-neg a b c ) ( / ( - ( * b -1 ) ( sqrt ( discriminante a b c ))) ( * 2 a ))) Por \u00faltimo, definimos la funci\u00f3n ecuacion que invoca a las funciones anteriores y devuelve una pareja con los valores resultantes: 1 2 ( define ( ecuacion a b c ) ( cons ( raiz-pos a b c ) ( raiz-neg a b c ))) Lo probamos: 1 2 3 4 5 6 ( ecuacion 1 -5 6 ) ; \u21d2 {3 . 2} ( ecuacion 2 -7 3 ) ; \u21d2 {3 . 1/2} ( ecuacion -1 7 -10 ) ; \u21d2 {2 . 5}","title":"Ra\u00edz de segundo grado"},{"location":"seminarios/seminario1-scheme/seminario1-scheme.html#conversion-de-grados-celsius-a-farenheit","text":"Vamos a definir una funci\u00f3n llamada convertir-temperatura que permite realizar una conversi\u00f3n de grados Fahrenheit a Cent\u00edgrados o vicerversa. La funci\u00f3n toma dos argumentos, el primero ser\u00e1 un n\u00famero que representa los grados y el segundo ser\u00e1 un car\u00e1cter ( F o C ) que indica la unidad de medida en la que est\u00e1n expresados los grados. Las f\u00f3rmulas de conversi\u00f3n son las siguientes: Primero definimos unas funciones auxiliares que calculan las expresiones anteriores: 1 2 3 4 5 ( define ( a-grados-fahrenheit grados-centigrados ) ( + ( * ( / 9 5 ) grados-centigrados ) 32 )) ( define ( a-grados-centigrados grados-fahrenheit ) ( * ( / 5 9 ) ( - grados-fahrenheit 32 ))) Y ahora ya podemos definir la funci\u00f3n principal: 1 2 3 4 ( define ( convertir-temperatura grados tipo ) ( cond (( equal? tipo #\\F ) ( list ( a-grados-centigrados grados ) grados centigrados )) (( equal? tipo #\\C ) ( list ( a-grados-fahrenheit grados ) grados fahrenheit )) ( else tipo de cambio incorrecto ))) Por ejemplo: 1 2 ( convertir-temperatura 50 #\\F ) ; = {10 grados centigrados } ( convertir-temperatura 50 #\\C ) ; = {122 grados fahrenheit }","title":"Conversi\u00f3n de grados Celsius a Farenheit"},{"location":"seminarios/seminario1-scheme/seminario1-scheme.html#funcion-display","text":"Para imprimir por pantalla en Scheme se pude usar la funci\u00f3n display , similar a la sentencia print de muchos otros lenguajes. 1 2 3 4 5 6 7 # lang r6rs ( import ( rnrs )) ( display \\nHola mundo!\\n ) ( display La suma de 2 + 3 es: ) ( display ( + 2 3 )) ( display \\n )","title":"Funci\u00f3n display"},{"location":"seminarios/seminario1-scheme/seminario1-scheme.html#pruebas-unitarias-en-scheme","text":"Para verificar que las funciones que definimos tienen un funcionamiento correcto, es decir, \"hacen lo que tienen que hacer\" , podemos dise\u00f1ar distintos casos de prueba. Cada caso de prueba se caracteriza por unos datos de entrada de la funci\u00f3n y por el resultado que esperamos que devuelva dicha funci\u00f3n con esos valores de entrada. Por ejemplo, en las pruebas de la funci\u00f3n convertir-temperatura , hemos dise\u00f1ado dos casos de prueba: Datos de Entrada Resultado Esperado 50 , #\\F {10 \"grados centigrados\"} 50 , #\\C {122 \"grados fahrenheit\"} El resultado esperado a partir de unos valores concretos de entrada, se determina entendiendo qu\u00e9 debe hacer la funci\u00f3n. Es decir, se obtiene a partir de la especificaci\u00f3n del problema, antes de plantearnos c\u00f3mo solucionarlo. Os aconsejamos tener siempre presente la siguiente idea aunque resulte obvia: Para implementar una funci\u00f3n, primero es imprescindible entender qu\u00e9 debe hacer la funci\u00f3n . Despu\u00e9s, seremos capaces de dise\u00f1ar casos de prueba y ocuparnos de c\u00f3mo implementarla . En las pr\u00e1cticas de la asignatura, para realizar pruebas usaremos el API SchemeUnit . Para ello, lo primero que tendremos que hacer es importar esta nueva librer\u00eda. Por tanto, debemos a\u00f1adir en nuestros ficheros de pr\u00e1cticas lo siguiente: 1 2 ( import ( rnrs ) ( schemeunit )) Una vez importada la librer\u00eda, ya podemos hacer uso de algunas de sus funciones. En concreto, utilizaremos las siguientes: check-true 1 2 3 ( check-true expr ) ;; Comprueba si su argumento es #t. ;; En caso contrario, se imprime un mensaje de error. check-false 1 2 3 ( check-false expr ) ;; Comprueba si su argumento es #f. ;; En caso contrario, se imprime un mensaje de error. check-equal? 1 2 3 ( check-equal? resultado-real resultado-esperado ) ;; Comprueba si sus dos argumentos son iguales. ;; En caso contrario, se imprime un mensaje de error. Con las funciones check-true y check-false validaremos predicados (recuerda que en Scheme son funciones que devuelven un valor booleano) que hayamos implementado, comprobando si el resultado esperado es true o false , respectivamente. Con la funci\u00f3n check-equal? podremos validar si el resultado de la invocaci\u00f3n a la funci\u00f3n con unos determinados valores de entrada, representado por el argumento resultado-real , es igual al resultado que esperamos, dado por el argumento resultado-esperado .","title":"Pruebas unitarias en Scheme"},{"location":"seminarios/seminario1-scheme/seminario1-scheme.html#ejemplo-de-pruebas-de-la-funcion-ecuacion-definida-anteriormente","text":"Las siguientes pruebas no mostrar\u00e1n ning\u00fan mensaje de error, lo que significa que nuestra funci\u00f3n ecuacion es 'CORRECTA' para estas pruebas, es decir, que con los valores de entrada utilizados, su resultado se corresponde con el esperado. 1 2 3 ( check-equal? ( ecuacion 1 -5 6 ) ( cons 3 2 )) ( check-equal? ( ecuacion 2 -7 3 ) ( cons 3 ( / 1 2 )) ) ( check-equal? ( ecuacion -1 7 -10 ) ( cons 2 5 )) Ahora vamos a suponer que nos hemos equivocado en la definici\u00f3n de la funci\u00f3n ecuacion , por ejemplo en el orden de los argumentos al invocar a la funci\u00f3n auxiliar raiz-pos , en la llamada que se hace en la parte izquierda de la pareja resultante. 1 2 ( define ( ecuacion a b c ) ( cons ( raiz-pos b a c ) ( raiz-neg a b c ))) Con esta nueva definici\u00f3n, si ejecutamos la siguiente prueba: 1 ( check-equal? ( ecuacion 1 -5 6 ) ( cons 3 2 )) el resultado ser\u00e1: 1 2 3 4 5 6 7 8 -------------------- FAILURE actual: {-1 . 2} expected: {3 . 2} name: check-equal? location: (# path:/.../filename.rkt ) expression: (check-equal? (ecuacion 1 -5 6) (cons 3 2)) -------------------- Esta prueba muestra un mensaje de error, lo que significa que la nueva definici\u00f3n de ecuacion 'FALLA', es decir, que el resultado que devuelve {-1 . 2} no coincide con el resultado esperado {3 . 2} .","title":"Ejemplo de pruebas de la funci\u00f3n ecuacion definida anteriormente"},{"location":"seminarios/seminario1-scheme/seminario1-scheme.html#ejercicios","text":"","title":"Ejercicios"},{"location":"seminarios/seminario1-scheme/seminario1-scheme.html#ejercicio-1","text":"Lanza DrRacket y escribe cada una de las siguientes instrucciones en el int\u00e9rprete, intentado adivinar el resultado que va devolver. Est\u00e1n ordenadas por dificultad de arriba abajo y de izquierda a derecha. \u00a1\u00a1Piensa en los resultados!!. Intenta entender c\u00f3mo interpreta Scheme lo que escribes. Instrucci\u00f3n Instrucci\u00f3n 3 (+ (- 4 (* 3 (/ 4 2) 4)) 3) (+ 1 2 ) ( (+ (+ 2 3) 4) ( (* 3 3) 2)) (+ 1 2 3 4) (* (+ 2 3 4 5) 3 (- 5 2 1)) (+) (+ (- (+ (- (+ 2 3) 5) 1) 2) 3) (sqrt 25) (- (sqrt (* 5 ( + 3 2))) (+ 1 1 1 1)) (* (+ 2 3) 5) ( ( 3 (+ 2 (+ 3 1)) (+ 1 1)) (+ ( 2 2) 3)) + (= (* 3 2) (+ 1 (+ 2 2) 1)) #\\+ (not ( (+ 3 2) 5)) \"+\" (and (even? 2) (odd? (+ 3 2))) \"hola\" (mod (+ 6 2) (+ 1 1))","title":"Ejercicio 1"},{"location":"seminarios/seminario1-scheme/seminario1-scheme.html#ejercicio-2","text":"Predice lo que devolver\u00e1 Scheme cuando escribas las siguientes expresiones. Est\u00e1n ordenadas por dificultad de arriba abajo y de izquierda a derecha. Despu\u00e9s, pru\u00e9balas y comprueba si tu predicci\u00f3n era correcta. Si no lo era, intenta comprender por qu\u00e9. Instrucci\u00f3n Instrucci\u00f3n (equal? \"hola\" \"hola\") (+ (char- integer(integer- char 1200))(char- integer #\\A)) (string-ref \"pepe\" 1) (string-length (make-string 7 #\\E)) (substring \"buenos dias\" 1 4) (define a 3) (define b (+ a 1)) (= \"hola\" \"hola\") (+ a b (* a b)) (string-ref (substring \"buenos dias 2 5) 1) (= a b) (define pi 3.14159) (if (and ( a b) ( b (* a b))) b a) pi (cond ((= a 4) 6) ((= b 4) (+ 6 7 a)) (else 25)) \"pi\" (+ 2 (if ( b a) b a)) (+ pi (+ pi pi)) (* (cond (( a b) a) (( a b) b) (else -1)) (+ a 1)) (+ (* pi pi) (- 2 pi pi pi pi)) ((if ( a b) + -) a b)","title":"Ejercicio 2"},{"location":"seminarios/seminario1-scheme/seminario1-scheme.html#ejercicio-3","text":"Ejercicios con parejas. Predice lo que hace Scheme cuando escribas las siguientes expresiones. Est\u00e1n ordenadas por dificultad de arriba abajo y de izquierda a derecha. Despu\u00e9s, pru\u00e9balas y comprueba si tu predicci\u00f3n era correcta. Si no lo era, intenta comprender por qu\u00e9. Instrucci\u00f3n Instrucci\u00f3n (cons 1 2) (car (cons (cons 3 4) 2)) (car (cons 1 2)) (cdr (cons (cons 3 4) 2)) (cdr (cons 1 2)) (cdr (cons 1 (cons 2 3))) (car (car (cons (cons 1 2) 3))) (cdr (car (cons (cons 1 2) 3)))","title":"Ejercicio 3"},{"location":"seminarios/seminario1-scheme/seminario1-scheme.html#ejercicio-4","text":"Ejercicios con listas. Predice lo que hace Scheme cuando escribas las siguientes expresiones. Despu\u00e9s, pru\u00e9balas y comprueba si tu predicci\u00f3n era correcta. Si no lo era, intenta comprender por qu\u00e9. Instrucci\u00f3n Instrucci\u00f3n (list 1 2 3 4) (cons 3 (list 1 2 3)) (cdr (list 1 2 3 4)) (cdr (cons 8 (list 1 2 3 4))) (car (list 1 2 3 4)) (car (list (list 1 2) 1 2 3 4)) (list 1 (list 2 3) (list 4 (list 5))) (list 1 (list 2 3) (list 4 (list 5))) (car (cdr (list 1 2 3 4))) (cons (list 1 2 3) (list 4 5 6)) (cdr (cdr (list 1 2 3 4))) (car (cdr (list 1 2 3 4))) (list 1 2 3 4) (cdr (cdr (list 1 2 3 4)))","title":"Ejercicio 4"},{"location":"seminarios/seminario1-scheme/seminario1-scheme.html#ejercicio-5","text":"Los siguientes apartados intenta hacerlos sin utilizar el int\u00e9rprete de Scheme. a) Dada la siguiente lista, indica la expresi\u00f3n correcta para que Scheme devuelva 5: 1 ( list 1 2 3 4 5 6 7 8 ) b) Dada la siguiente lista, indica la expresi\u00f3n correcta para que Scheme devuelva (8). 1 ( list 1 2 3 4 5 6 7 8 ) c) Dada la siguiente lista, indica la expresi\u00f3n correcta para que Scheme devuelva 8. 1 ( list 1 2 3 4 5 6 7 8 ) d) Dada la siguiente expresi\u00f3n, \u00bfqu\u00e9 devuelve Scheme? 1 ( car ( cdr ( cdr ( list 1 ( list 2 3 ) ( list 4 5 ) 6 )))) e) Dada la siguiente expresi\u00f3n, \u00bfqu\u00e9 devuelve Scheme? 1 ( cdr ( cdr ( list 1 ( list 2 3 ) 4 5 ))) Lenguajes y Paradigmas de Programaci\u00f3n, curso 2018-19 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Domingo Gallardo, Cristina Pomares, Antonio Bot\u00eda, Francisco Mart\u00ednez","title":"Ejercicio 5"},{"location":"seminarios/seminario2-swift/seminario2-swift.html","text":"Seminario 2: Seminario de Swift El lenguaje de programaci\u00f3n Swift Swift es un lenguaje de programaci\u00f3n compilado, de prop\u00f3sito general y multi-paradigma desarrollado por Apple. Swift se present\u00f3 en la Conferencia de Desarrolladores de Apple (WWDC) de 2014. Durante el a\u00f1o 2014 se desarroll\u00f3 la versi\u00f3n 1.2 y en la WWDC 2015 se present\u00f3 Swift 2, una actualizaci\u00f3n importante del lenguaje. Inicialmente fue un lenguaje propietario, pero el 3 de diciembre de 2015 se hizo open source bajo la licencia Apache 2.0, para las plataformas Apple y Linux. Los cambios en el lenguaje son propuestos y discutidos por la comunidad en un proceso denominado Swift evolution . En la actualidad se ha estabilizado la versi\u00f3n 4 del lenguaje y se est\u00e1 desarrollando la versi\u00f3n 5 que se presentar\u00e1 a finales de 2018. La siguiente descripci\u00f3n se ha extra\u00eddo del repositorio GitHub de Swift: Swift es un lenguaje de programaci\u00f3n de sistemas de alta eficiencia. Tiene una sintaxis limpia y moderna, ofrece acceso transparente a c\u00f3digo y librer\u00edas existentes en C y Objective-C, y es seguro en el uso de memoria ( memory safe ). Aunque est\u00e1 inspirado en Objective-C y en muchos otros lenguajes, Swift no es en si mismo un lenguaje derivado de C. Como lenguaje completo e independiente, Swift proporciona caracter\u00edsticas fundamentales como control de flujo, estructuras de datos y funciones, junto con construcciones de alto nivel como objetos, protocolos, clausuras y gen\u00e9ricos. Swift se apoya en m\u00f3dulos, eliminando la necesidad de cabeceras y la duplicaci\u00f3n de c\u00f3digo que \u00e9stas inducen. Ejecuci\u00f3n de programas Swift Es posible descargar el compilador de Swift en los sistemas operativos Mac (utilizando el entorno de desarrollo Xcode) o Linux. Para la asignatura recomendamos utilizar una m\u00e1quina Docker basada en la distribuci\u00f3n Linux. La utilizaci\u00f3n de la m\u00e1quina Docker hace posible su utilizaci\u00f3n en Windows y Mac sin instalar Xcode y permite un entorno unificado en el que hacer las pr\u00e1cticas. A continuaci\u00f3n explicamos las distintas formas de ejecutar programas Swift. Ejecuci\u00f3n en una m\u00e1quina Docker Docker es una tecnolog\u00eda que ha tenido una gran expansi\u00f3n en los \u00faltimos a\u00f1os. Permite construir m\u00e1quinas virtuales ligeras que utilizan el mismo sistema operativo de la m\u00e1quina host. Estas m\u00e1quinas virtuales se denominan contenedores y, al compartir el propio sistema operativo en el que se est\u00e1n ejecutando, su gesti\u00f3n (construcci\u00f3n, arranque, parada, etc.) es much\u00edsimo m\u00e1s r\u00e1pida que las m\u00e1quinas virtuales tradicionales. Docker se controla desde l\u00ednea de comando, desde la aplicaci\u00f3n Terminal de Mac o el PowerShell de Windows. Existen comandos docker para descargar im\u00e1genes, lanzar y parar contenedores, montar directorios de la m\u00e1quina host en contenedores, etc. Nosotros s\u00f3lo utilizaremos el comando docker run para lanzar un contenedor, pero te recomendamos que investigues y pruebes m\u00e1s comandos y que conozcas mejor esta interesante tecnolog\u00eda. Puedes empezar por la gu\u00eda Get started with Docker . Usaremos la imagen Docker swift:4.0.3 , que contiene el comando swift necesario para compilar y ejecutar aplicaciones Swift. Instalaci\u00f3n de Docker Debes instalar la versi\u00f3n de Docker CE ( Community Edition ) correspondiente a tu sistema operativo. Desc\u00e1rgalo desde esta p\u00e1gina y sigue las instrucciones correspondientes a tu sistema operativo. Instalaci\u00f3n y ejecuci\u00f3n de la imagen Swift Una vez instalado Docker, abre un terminal y lanza el siguiente comando: 1 $ docker pull swift:4.0.3 El comando descarga la imagen swift:4.0.3 a nuestro ordenador. Una vez descargada lanzamos el contenedor con el siguiente comando: 1 $ docker run --privileged -it --rm -v ${PWD}:/home swift:4.0.3 /bin/bash El contenedor arranca en muy pocos segundos y aparece su prompt, indicando que ya est\u00e1s dentro de \u00e9l y puedes ejecutar cualquier comando linux: 1 2 3 root@97265a262a58:/# ls bin boot dev etc home lib lib64 media mnt opt proc root run sbin srv sys tmp usr var root@97265a262a58:/# Lanzamos el int\u00e9rprete de Swift con el comando swift : 1 2 3 4 5 root@97265a262a58:/# swift Welcome to Swift version 4.0.3 (swift-4.0.3-RELEASE). Type :help for assistance. 1 hola .uppercased() $R0: String = HOLA 2 Una vez hayamos terminado de trabajar podemos salir del int\u00e9rprete de Swift y del contenedor de la siguiente forma: 1 2 3 :quit root@97265a262a58:/# exit Directorio compartido entre el ordenador host y el contenedor El argumento -v \"${PWD}:/home\" del comando docker run hace que el contenedor monte el directorio actual en su directorio /home . De esta forma podemos editar los programas Swift en el ordenador anfitri\u00f3n y ejecutarlos desde l\u00ednea de comando en el contenedor. Recomendamos utilizar un editor de textos orientado a la programaci\u00f3n para editar los programas Swift en el ordenador anfitri\u00f3n. M\u00e1s adelante hablaremos de los editores Atom y Visual Studio Code, pero cualquier otro editor orientado a programaci\u00f3n te puede valer (Sublime, Xcode en el Mac, etc.) Vamos a probar a usar el directorio compartido: Nos movemos en el ordenador anfitri\u00f3n a un directorio en el que trabajaremos con los programas en Swift: 1 2 ~ $ cd swift ~/swift $ Creamos en el directorio actual un programa llamado holaMundo.swift . Fichero holaMundo.swift : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // Primer programa Swift var str = Mensaje str = Hola mundo! print ( str ) // Vamos a sumar dos n\u00fameros var firstNumber = 2 var secondNumber = 3 var totalSum = firstNumber + secondNumber firstNumber = firstNumber + 1 secondNumber = secondNumber + 1 totalSum = firstNumber + secondNumber print ( El resultado de la suma es = \\( totalSum ) ) Arrancamos el contenedor swift: 1 $ docker run --privileged -it --rm -v ${PWD}:/home swift:4.0.3 /bin/bash Compilamos y ejecutamos el programa desde el contenedor, cambiando al directorio /home (el directorio compartido) y ejecutando el comando swift: 1 2 3 4 root@3131534ce480:/# cd /home root@3131534ce480:~# swift holaMundo.swift Hola mundo! El resultado de la suma es = 7 Prueba a cambiar cualquier cosa en el programa desde el editor en el ordenador anfitri\u00f3n y a volver a ejecutar el programa desde el contenedor. Ver\u00e1s que el directorio est\u00e1 realmente compartido y que el programa se ejecuta con las modificaciones que has introducido. Cuando termines de trabajar con el contenedor Docker recuerda salir de \u00e9l. El argumento --rm del comando docker run hace que el contenedor se elimine al terminar su ejecuci\u00f3n. 1 2 3 root@3131534ce480:~# exit exit ~/swift $ Instalaci\u00f3n en MacOS Para instalar la \u00faltima versi\u00f3n de Swift en MacOs debes instalar Xcode. Una vez instalado puedes ejecutar Swift desde el terminal. Instalaci\u00f3n en Linux Ubuntu Existe una distribuci\u00f3n oficial de Swift para Ubuntu de 64 bits (distribuciones 14.04, 16.04 y 16.10). Puedes encontrar la informaci\u00f3n completa en la web oficial de Apple . Brevemente, los pasos son los siguientes: 1 2 3 4 5 $ sudo apt-get install clang libicu-dev // Descargar la versi\u00f3n y plataforma deseada ( fichero swift- VERSION - PLATFORM .tar.gz ) $ tar xzf swift- VERSION - PLATFORM .tar.gz // Esto crea el directorio usr/ en la localizaci\u00f3n del archivo // Actualizar el PATH o mover usr/bin/swift al directorio /usr/bin Editor de c\u00f3digo Para editar c\u00f3digo Swift puedes usar cualquier editor orientado a programaci\u00f3n. Aconsejamos Atom o Visual Studio Code . Ambos son multi-plataforma. Atom Atom es un editor modular en el que se pueden instalar m\u00faltiples extensiones desarrolladas por terceros. Para programar con swift es conveniente instalar los siguientes paquetes (en Preferencias Settings Install Packages ): language-swift : proporciona coloreado de sintaxis de Swift platformio-ide-terminal : proporciona la posibilidad de abrir un terminal en la parte inferior de la ventana. Puedes consultar los conceptos b\u00e1sicos de Atom y el manual completo en este enlace . Visual Studio Code Es recomendable instalar la extensi\u00f3n Swift Language que realiza un coloreado de sintaxis de Swift. Para trabajar de forma m\u00e1s c\u00f3moda podemos abrir el terminal integrado Ver Terminal integrado y lanzar el contenedor de Swift en ese terminal. Puedes consultar los conceptos b\u00e1sicos de Visual Studio Code y el manual completo en este enlace . Un tour de Swift Aqu\u00ed empieza el seminario de Swift. El texto que hay a continuaci\u00f3n es una traducci\u00f3n del documento de Apple A Swift Tour en el que se presenta una introducci\u00f3n r\u00e1pida a los conceptos fundamentales del lenguaje. En los temas siguientes de la asignatura (Tema 5 - Programaci\u00f3n Funcional con Swift y Tema 6 - Programaci\u00f3n Orientada a Objetos con Swift) profundizaremos en aspectos como funciones, gen\u00e9ricos, clases o protocolos. Te recomendamos que crees un fichero llamado seminario.swift y que vayas copiando y probando en \u00e9l todos los ejemplos que aparecen a continuaci\u00f3n. La tradici\u00f3n sugiere que el primer programa en un nuevo lenguaje deber\u00eda imprimir las palabras \"Hello, world!\" en la pantalla. En Swift, esto puede hacerse con una \u00fanica l\u00ednea: 1 print ( Hello, world! ) Si has escrito c\u00f3digo en C o en Objective-C, esta sintaxis te parecer\u00e1 familiar. En Swift, esta l\u00ednea de c\u00f3digo es un programa completo. No necesitas importar una biblioteca separada para funcionaliades como entrada/salida o manejo de cadenas. El c\u00f3digo escrito en el \u00e1mbito global se usa como el punto de entrada del programa, por lo que no necesitas una funci\u00f3n main() . Tampoco tienes que escribir puntos y comas al final de cada sentencia. Este tour te da informaci\u00f3n suficiente para empezar a escribir c\u00f3digo in Swift ense\u00f1\u00e1ndote c\u00f3mo conseguir una variedad de tareas de programaci\u00f3n. No te preocupes si no entiendes algo, todo lo que se introduce en este tour se explica en detalle en el resto del libro . Valores simples Usa let para crear una constante y var para crear una variable. No es necesario que se conozca en tiempo de compilaci\u00f3n el valor de una constante, pero debes asignarle un valor exactamente una vez. Esto significa que puedes usar constantes para nombrar un valor que determinas una vez pero que usas en muchos lugares. 1 2 3 var miVariable = 42 miVariable = 50 let miConstante = 42 Una constante o variable debe tener el mismo tipo que el valor que quieres asignarle. Sin embargo, no siempre tienes que escribir el tipo expl\u00edcitamente. Cuando se proporciona un valor al crear una constante o una variable el compilador infiere su tipo. En el ejemplo anterior, el compilador infiere que myVariable es un entero porque su valor inicial es un entero. Si el valor inicial no proporciona informaci\u00f3n suficiente (o si no hay valor inicial), especifica el tipo escribi\u00e9ndolo despu\u00e9s de la variable, separ\u00e1ndolo por dos puntos. 1 2 3 let implicitoInteger = 70 let implicitoDouble = 70.0 let explicitoDouble : Double = 70 EXPERIMENTO Crea una constante con el tipo expl\u00edcito de Float y un valor de 4. Los valores nunca se convierten impl\u00edcitamente a otro tipo. Si necesitas convertir un valor a un tipo diferente, construye expl\u00edcitamente una instancia del tipo deseado. 1 2 3 let etiqueta = El ancho es let ancho = 94 let anchoEtiqueta = etiqueta + String ( ancho ) EXPERIMENTO Intenta eliminar la conversi\u00f3n a String en la \u00faltima l\u00ednea. \u00bfQu\u00e9 error obtienes? Hay una forma a\u00fan m\u00e1s sencilla de incluir valores en cadenas: escribe el valor entre par\u00e9ntesis, y escribe una barra invertida ( \\ ) antes de los par\u00e9ntesis. Por ejemplo: 1 2 3 4 let manzanas = 3 let naranjas = 5 let resumenManzanas = Tengo \\( manzanas ) manzanas. let resumenFrutas = Tengo \\( manzanas + naranjas ) frutas. EXPERIMENTO Usa \\() para incluir un c\u00e1lculo en punto flotante en una cadena y para incluir el nombre de alguien en un saludo. Crea arrays y diccionarios utilizando corchetes ( [] ), y accede a sus elementos escribiendo el \u00edndice o la clave en los corchetes. Se permite una coma despu\u00e9s del \u00faltimo elemento. 1 2 3 4 5 6 7 8 var listaCompra = [ huevos , agua , tomates , pan ] listaCompra [ 1 ] = botella de agua var trabajos = [ Malcolm : Capit\u00e1n , Kaylee : Mec\u00e1nico , ] trabajos [ Jayne ] = Relaciones p\u00fablicas Para crear un array o diccionario vac\u00edo, usa la sintaxis de inicializaci\u00f3n. 1 2 let arrayVacio = [ String ]() let diccionarioVacio = [ String : Float ]() Si el tipo de informaci\u00f3n puede ser inferido, puedes escribir un array vac\u00edo como [] y un diccionario vac\u00edo como [:] ; por ejemplo, cuando estableces un nuevo valor para una variable o pasas un argumento a una funci\u00f3n. 1 2 listaCompra = [] trabajos = [:] Tuplas Una tupla agrupa varios valores en un \u00fanico valor compuesto. 1 let http404Error = ( 404 , Not Found ) El tipo de la tupla es (Int, String) . Para obtener los valores de la tupla podemos descomponerla . Si queremos ignorar una parte podemos utilizar un subrrayado ( _ ). 1 2 let ( statusCode , statusMensaje ) = http404Error let ( soloStatusCode , _ ) = http404Error Tambi\u00e9n podemos acceder por posici\u00f3n: 1 print ( El c\u00f3digo de estado es \\( http404Error . 0 ) ) Control de flujo Usa if y switch para hacer condicionales y usa for-in , for , while y repeat-while para hacer bucles. Los par\u00e9ntesis alrededor de las condiciones o de la variable del bucle son opcionales. Se requieren llaves alrededor del cuerpo. 1 2 3 4 5 6 7 8 9 10 let puntuacionesIndividuales = [ 75 , 43 , 103 , 87 , 12 ] var puntuacionEquipo = 0 for puntuacion in puntuacionesIndividuales { if puntuacion 50 { puntuacionEquipo += 3 } else { puntuacionEquipo += 1 } } print ( puntuacionEquipo ) En una sentencia if , el condicional debe ser una expresi\u00f3n booleana; esto significa que c\u00f3digo como if score { ... } es un error, no una comparaci\u00f3n impl\u00edcita con cero. Puedes usar if y let juntos para trabajar con valores que pueden faltar. Estos valores se representan como opcionales. Un valor opcional o bien contiene un valor o contiene nil para indicar que el valor falta. Escribe una interrogaci\u00f3n ( ? ) despu\u00e9s del tipo de un valor para marcar el valor como opcional. 1 2 3 4 5 6 7 8 var cadenaOpcional : String ? = Hola print ( cadenaOpcional == nil ) var nombreOpcional : String ? = John Appleseed var saludo = Hola! if let nombre = nombreOpcional { saludo = Hola, \\( nombre ) } EXPERIMENTO Cambia nombreOpcional a nil . \u00bfQu\u00e9 saludo obtienes? A\u00f1ade una cl\u00e1usula else que establezca un saludo diferente si nombreOpcional es nil . Si el valor opcional es nil , el condicional es false y el c\u00f3digo en las llaves se salta. En otro caso, el valor opcional se desenvuelve y se asigna a la constante despu\u00e9s del let , lo que hace que el valor desenvuelto est\u00e9 disponible dentro del bloque de c\u00f3digo. Otra forma de manejar valores opcionales es proporcionar un valor por defecto usando el operador ?? . Si falta el valor valor opcional, se usa el valor por defecto en su lugar. 1 2 3 let nombrePila : String ? = nil let nombreCompleto : String = John Appleseed let saludoInformal = \u00bfQu\u00e9 tal, \\( nombrePila ?? nombreCompleto ) ? Las sentencias switch permiten cualquier tipo de datos y una amplia variedad de operaciones de comparaci\u00f3n; no est\u00e1n limitados a enteros y pruebas de igualdad. 1 2 3 4 5 6 7 8 9 let verdura = pimiento rojo switch verdura { case zanahoria : print ( Buena para la vista. ) case lechuga , tomates : print ( Podr\u00edas hacer una buena ensalada. ) default : print ( Siempre puedes hacer una buena sopa. ) } EXPERIMENTO Intenta eliminar el caso por defecto. \u00bfQu\u00e9 error obtienes? Despu\u00e9s de ejecutar el c\u00f3digo dentro del caso que se empareja, el programa sale de la sentencia switch . La ejecuci\u00f3n no continua con el siguiente caso, por lo que no hay necesidad de romper el switch al final del c\u00f3digo de cada caso. Usa for-in para iterar sobre elementos en un diccionario proporcionando una pareja de nombres para usar en cada pareja clave-valor. Los diccionarios son colecciones desordenadas, por lo que sus claves y valores se iteran en un orden arbitrario. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 let numerosInteresantes = [ Primos : [ 2 , 3 , 5 , 7 , 11 , 13 ], Fibonacci : [ 1 , 1 , 2 , 3 , 5 , 8 ], Cuadrados : [ 1 , 4 , 9 , 16 , 25 ], ] var mayor = 0 for ( clase , numeros ) in numerosInteresantes { for numero in numeros { if numero mayor { mayor = numero } } } print ( mayor ) EXPERIMENTO A\u00f1ade otra variable para seguir qu\u00e9 clase de n\u00famero es el mayor. Usa while para repetir un bloque de c\u00f3digo hasta que una condici\u00f3n cambie. La condici\u00f3n de un bucle puede estar tambi\u00e9n al final, asegurando que el bucle se ejecuta al menos una vez. 1 2 3 4 5 6 7 8 9 10 11 var n = 2 while n 100 { n *= 2 } print ( n ) var m = 2 repeat { m *= 2 } while m 100 print ( m ) Puedes definir un \u00edndice en un bucle usando .. para construir un rango de \u00edndices. 1 2 3 4 5 var total = 0 for i in 0. . 4 { total += i } print ( total ) Usa .. para construir un rango que omita su valor superior, y usa ... para construir un rango que incluya ambos valores. Funciones y clausuras Usa func para declarar una funci\u00f3n. Usa - para separar los nombres de los par\u00e1metros y sus tipos del tipo devuelto de la funci\u00f3n. 1 2 3 4 func saluda ( nombre : String , dia : String ) - String { return Hola \\( nombre ) , hoy es \\( dia ) . } saluda ( nombre : Bob , dia : Martes ) EXPERIMENTO Elimina el par\u00e1metro d\u00eda. A\u00f1ade un par\u00e1metro para incluir la comida de hoy en el saludo. Por defecto, las funciones usan los nombres de los par\u00e1metros como etiquetas de los argumentos. Es posible definir una etiqueta escribi\u00e9ndola antes del nombre del par\u00e1metro, o no usar etiqueta escribiendo _ : 1 2 3 4 func saluda ( _ nombre : String , el dia : String ) - String { return Hola \\( nombre ) , hoy es \\( dia ) . } saluda ( Bob , el : Martes ) Las funciones pueden devolver cualquier tipo de dato, como tuplas. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 func calculaEstadisticas ( puntuaciones : [ Int ]) - ( min : Int , max : Int , sum : Int ) { var min = puntuaciones [ 0 ] var max = puntuaciones [ 0 ] var sum = 0 for puntuacion in puntuaciones { if puntuacion max { max = puntuacion } else if puntuacion min { min = puntuacion } sum += puntuacion } return ( min , max , sum ) } let estadisticas = calculaEstadisticas ( puntuaciones : [ 5 , 3 , 100 , 3 , 9 ]) print ( estadisticas . sum ) print ( estadisticas . 2 ) Las funciones tambi\u00e9n pueden tener un n\u00famero variable de argumentos, agrup\u00e1ndose todos ellos en un array. 1 2 3 4 5 6 7 8 9 func suma ( numeros : Int ...) - Int { var suma = 0 for numeros in numeros { suma += numeros } return suma } print ( suma ()) print ( suma ( numeros : 42 , 597 , 12 )) EXPERIMENTO Escribe una funci\u00f3n que calcule la media de sus argumentos. Las funciones pueden anidarse. Las funciones pueden acceder variables declaradas en la funci\u00f3n exterior. Puedes usar funciones anidadas para organizar el c\u00f3digo en una funci\u00f3n que es larga o complicada. 1 2 3 4 5 6 7 8 9 func devuelveQuince () - Int { var y = 10 func suma () { y += 5 } suma () return y } print ( devuelveQuince ()) Las funciones son un tipo de primera clase. Esto significa que una funci\u00f3n puede devolver otra funci\u00f3n como resultado. 1 2 3 4 5 6 7 8 func construyeIncrementador () - (( Int ) - Int ) { func sumaUno ( numero : Int ) - Int { return 1 + numero } return sumaUno } var incrementa = construyeIncrementador () print ( incrementa ( 7 )) Podemos modificar el ejemplo devuelveQuince para que se devuelva una versi\u00f3n modificada de la funci\u00f3n suma . Llamamos a la funci\u00f3n devuelveSuma . 1 2 3 4 5 6 7 8 9 10 11 12 func devuelveSuma () - (() - Int ) { var y = 10 func suma () - Int { y += 5 return y } return suma } let f = devuelveSuma () print ( f ()) print ( f ()) Una funci\u00f3n puede tomar otra funci\u00f3n como uno de sus argumentos. 1 2 3 4 5 6 7 8 9 10 11 12 13 func cumpleCondicion ( lista : [ Int ], condicion : ( Int ) - Bool ) - Bool { for item in lista { if condicion ( item ) { return true } } return false } func menorQueDiez ( numero : Int ) - Bool { return numero 10 } var numeros = [ 20 , 19 , 7 , 12 ] print ( cumpleCondicion ( lista : numeros , condicion : menorQueDiez )) Las funciones son en la realidad un caso especial de clausuras: bloques de c\u00f3digo que pueden ser llamados despu\u00e9s. El c\u00f3digo en la clausura tiene acceso a cosas como variables y funciones que estaban disponibles en el \u00e1mbito ( scope ) en el que se cre\u00f3 la clausura, incluso si la clausura est\u00e1 en un \u00e1mbito distinto cuando se ejecuta; ya viste un ejemplo de esto con las funciones anidadas. Puedes escribir una clausura rodeando el c\u00f3digo con llaves ( {} ). Usa in para separar los argumentos del cuerpo. 1 2 3 4 5 numeros . map ({ ( numero : Int ) - Int in let resultado = 3 * numero return resultado }) EXPERIMENTO Reescribe la clausura para que devuelva cero para todos los n\u00fameros impares. Tienes bastantes opciones para escribir clausuras de forma m\u00e1s concisa. Cuando ya se conoce el tipo de una clausura puedes omitir el tipo de sus par\u00e1metros, el tipo devuelto o ambos. Las clausuras escritas en una l\u00ednea devuelven impl\u00edcitamente el valor de su \u00fanica sentencia. 1 2 let numerosMapeados = numeros . map ({ numero in 3 * numero }) print ( numerosMapeados ) Puedes referirte a los par\u00e1metros por n\u00famero en lugar de por nombre; este enfoque es especialmente \u00fatil en clausuras muy cortas. Una clausura pasada como \u00faltimo argumento puede aparecer inmediatamente despu\u00e9s de los par\u00e9ntesis. Cuando una clausura es el \u00fanico argumento de una funci\u00f3n, puedes omitir los par\u00e9ntesis por completo. 1 2 let numerosOrdenados = numeros . sorted { $0 $1 } print ( numerosOrdenados ) Objetos y clases Usa class seguido por el nombre de la clase para crear una clase. Una declaraci\u00f3n de una propiedad en una clase se escribe de la misma forma que la declaraci\u00f3n de una constante o una variable, excepto que est\u00e1 en el contexto de una clase. De la misma forma, las declaraciones de los m\u00e9todos se escriben de la misma forma que las funciones. 1 2 3 4 5 6 class Figura { var numeroDeLados = 0 func descripcionSencilla () - String { return Una figura con \\( numeroDeLados ) lados. } } EXPERIMENTO A\u00f1ade una propiedad constante con let , y a\u00f1ade otro m\u00e9todo que tome un argumento. Crea una instancia de una clase poniendo par\u00e9ntesis despu\u00e9s del nombre de la clase. Usa la sintaxis de punto para acceder a las propiedades y los m\u00e9todos de la instancia. 1 2 3 var figura = Figura () figura . numeroDeLados = 7 var descripcionFigura = figura . descripcionSencilla () A esta versi\u00f3n de la clase Figura le falta algo importante: un inicializador para preparar la clase cuando se crea una instancia. Usa init para crear uno. 1 2 3 4 5 6 7 8 9 10 11 12 class FiguraConNombre { var numeroDeLados : Int = 0 var nombre : String init ( nombre : String ) { self . nombre = nombre } func descripcionSencilla () - String { return Una figura con \\( numeroDeLados ) lados. } } F\u00edjate en c\u00f3mo se utiliza self para distinguir la propiedad nombre del argumento nombre al inicializador. Los argumentos al inicializador se pasan como una llamada a una funci\u00f3n cuando creas una instancia de la clase. Cada propiedad necesita un valor asignado; ya sea en su declaraci\u00f3n (como numeroDeLados ) o en el inicializador (como nombre ). Usa deinit para crear un desinicializador si necesitas realizar alguna limpieza antes de que el objeto sea eliminado. Las subclases incluyen el nombre de su subclase despu\u00e9s del nombre de la clase, separado por una coma. No hay ning\u00fan requisito de que las clases deban ser subclases de alguna clase ra\u00edz, por lo que puedes omitir una superclase si as\u00ed lo necesitas. Los m\u00e9todos en una subclase que sobreescriben la implementaci\u00f3n de la superclase se marcan con override ; la sobreescritura de un m\u00e9todo por accidente, sin override , se detecta por el compilador como un error. El compilador tambi\u00e9n detecta m\u00e9todos con override que realmente no sobreescriben ning\u00fan m\u00e9todo de la superclase. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Cuadrado : FiguraConNombre { var longitudLado : Double init ( longitudLado : Double , nombre : String ) { self . longitudLado = longitudLado super . init ( nombre : nombre ) numeroDeLados = 4 } func area () - Double { return longitudLado * longitudLado } override func descripcionSencilla () - String { return Un cuadrado con lados de longitud \\( longitudLado ) . } } let test = Cuadrado ( longitudLado : 5.2 , nombre : Mi cuadrado de prueba ) print ( test . area ()) print ( test . descripcionSencilla ()) EXPERIMENTO Construye otra subclase de FiguraConNombre llamada Circulo que tome un radio y un nombre como argumentos de su inicializador. Implementa un m\u00e9todo area() y descripcionSencilla() en la clase Circulo . Adem\u00e1s de propiedades simples que se almacenan, las propiedades pueden tener un getter y un setter . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class TrianguloEquilatero : FiguraConNombre { var longitudLado : Double = 0.0 init ( longitudLado : Double , nombre : String ) { self . longitudLado = longitudLado super . init ( nombre : nombre ) numeroDeLados = 3 } var perimetro : Double { get { return 3.0 * longitudLado } set { longitudLado = newValue / 3.0 } } override func descripcionSencilla () - String { return Un triangulo equil\u00e1tero con lados de longitud \\( longitudLado ) . } } var triangulo = TrianguloEquilatero ( longitudLado : 3.1 , nombre : un tri\u00e1ngulo ) print ( triangulo . perimetro ) triangulo . perimetro = 9.9 print ( triangulo . longitudLado ) En el setter de perimetro , el nuevo valor tiene el nombre impl\u00edcito newValue . Puedes proporcionar un nombre expl\u00edcito en el par\u00e9ntesis despu\u00e9s de set . Date cuenta de que el inicializador de la clase TrianguloEquilatero tiene tres pasos diferentes: Establecer el valor de las propiedades que declara la subclase. Llamar al inicializador de la superclase. Cambiar el valor de las propiedades definidas por la superclase. Cualquier trabajo adicional que use m\u00e9todos, getters o setters puede hacerse tambi\u00e9n en este punto. Si no necesitas calcular la propiedad pero necesitas proporcionar c\u00f3digo que se ejecuta antes y despu\u00e9s de establecer un nuevo valor, usa willSet y didSet . El c\u00f3digo que proporcionas se ejecuta cada vez que el valor cambia fuera de un inicializador. Por ejemplo, la siguiente clase se asegura de que la longitud del lado de su tri\u00e1ngulo siempre es la misma que la longitud del lado de su cuadrado. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class TrianguloYCuadrado { var triangulo : TrianguloEquilatero { willSet { cuadrado . longitudLado = newValue . longitudLado } } var cuadrado : Cuadrado { willSet { triangulo . longitudLado = newValue . longitudLado } } init ( tama \u00f1 o : Double , nombre : String ) { cuadrado = Cuadrado ( longitudLado : tama \u00f1 o , nombre : nombre ) triangulo = TrianguloEquilatero ( longitudLado : tama \u00f1 o , nombre : nombre ) } } var trianguloYCuadrado = TrianguloYCuadrado ( tama \u00f1 o : 10 , nombre : Otra figura de prueba ) print ( trianguloYCuadrado . cuadrado . longitudLado ) print ( trianguloYCuadrado . triangulo . longitudLado ) trianguloYCuadrado . cuadrado = Cuadrado ( longitudLado : 50 , nombre : Cuadrado mayor ) print ( trianguloYCuadrado . triangulo . longitudLado ) Cuando trabajamos con valores opcionales, puedes escribir ? antes de operaciones como m\u00e9todos, propiedades y sub\u00edndices. Si el valor antes del ? es nil , todo lo que hay despu\u00e9s se ignora y el valor de la expresi\u00f3n completa es nil . En otro caso, el valor opcional se desenvuelve, y todo lo que hay despu\u00e9s del ? se realiza sobre el valor desenvuelto. En ambos casos, el valor de la expresi\u00f3n completa es un valor opcional. 1 2 let cuadradoOpcional : Cuadrado ? = Cuadrado ( longitudLado : 2.5 , nombre : Cuadrado opcional ) let longitudLado = cuadradoOpcional ?. longitudLado Enumeraciones y estructuras Usa enum para crear una enumeraci\u00f3n. Como las clases y otros tipos con nombre, las enumeraciones pueden tener m\u00e9todos asociados. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 enum Valor : Int { case uno = 1 case dos , tres , cuatro , cinco , seis , siete , ocho , nueve , diez case sota , caballo , rey func descripcionSencilla () - String { switch self { case . uno : return as case . sota : return sota case . caballo : return caballo case . rey : return rey default : return String ( self . rawValue ) } } } let carta = Valor . uno let valorBrutoCarta = carta . rawValue EXPERIMENTO Escribe una funci\u00f3n que compare dos valores Valor a trav\u00e9s de una comparaci\u00f3n de sus valores brutos. Por defecto, Swift asigna los valores brutos comenzando en cero e increment\u00e1ndolos por uno cada vez, pero puedes cambiar esta conducta especificando expl\u00edcitamente los valores. En el ejemplo anterior, a As se le da un valor bruto de 1 y el resto de los valores brutos se asignan en orden. Puedes tambi\u00e9n usar cadenas o n\u00fameros en punto flotante como valores brutos de una enumeraci\u00f3n. Utiliza la propiedad rawValue para acceder al valor bruto de una enumeraci\u00f3n. Usa el inicializador para construir un valor de una enumeraci\u00f3n a trav\u00e9s de un valor bruto. Si el valor bruto no existe, el inicializador devolver\u00e1 nil . 1 2 3 4 if let valorConvertido = Valor ( rawValue : 3 ) { let descripcionTres = valorConvertido . descripcionSencilla () print ( descripcionTres ) } Los valores case de una enumeraci\u00f3n son valores reales, no una forma nueva de escribir sus valores brutos. De hecho, en los casos en los que no hay un valor bruto que tenga sentido, no tienes que proporcionar uno. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 enum Palo { case oros , bastos , copas , espadas func descripcionSencilla () - String { switch self { case . oros : return oros case . bastos : return bastos case . copas : return copas case . espadas : return espadas } } } let copas = Palo . copas let descripcionCopas = copas . descripcionSencilla () EXPERIMENTO A\u00f1ade un m\u00e9todo color() a Palo que devuelva \"agresivo\" para bastos y espadas y devuelva \"reflexivo\" para oros y copas . Date cuenta de las dos formas en las que nos referimos al caso copas de la enumeraci\u00f3n anterior: cuando se asigna un valor a la constante copas , nos referimos al caso de la enumeraci\u00f3n Palo.copas usando su nombre completo porque la constante no tiene un tipo expl\u00edcito especificado. Dentro del switch , nos referimos al caso de la enumeraci\u00f3n con la forma abreviada .copas porque ya se sabe que el valor de self es un Palo . Puedes usar la forma abreviada en cualquier momento en que el tipo del valor ya se conozca. Una instancia de un caso de enumeraci\u00f3n puede tener valores asociados con la instancia. Instancias del mismo caso de enumeraci\u00f3n pueden tener asociados valores diferentes. Proporcionas los valores asociados cuando creas la instancia. Los valores asociados y los valores brutos son distintos: el valor bruto de un caso de enumeraci\u00f3n es el mismo para todas las instancias, mientras que proporcionas el valor asociado cuando defines la enumeraci\u00f3n. Por ejemplo, considera el caso de realizar una petici\u00f3n a un servidor de la hora de salir el sol y de la hora de ponerse el sol. El servidor responde con la informaci\u00f3n o responde con alguna informaci\u00f3n de error. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 enum RespuestaServidor { case resultado ( String , String ) case error ( String ) } let exito = RespuestaServidor . resultado ( 6:00 am , 8:09 pm ) let fallo = RespuestaServidor . error ( Sin queso. ) switch exito { case let . resultado ( salidaSol , puestaSol ): print ( La salida del sol es a las \\( salidaSol ) y la puesta es a \\( puestaSol ) . ) case let . error ( error ): print ( Fallo... \\( error ) ) } EXPERIMENTO A\u00f1ade un tercer caso al ServerResponse y al switch. Date cuenta de c\u00f3mo la hora de salir el sol y de ponerse el sol se extraen del ServerResponse como parte del emparejamiento entre el valor y los casos switch. Usa struct para crear una estructura. Las estructuras comparten muchas caracter\u00edsticas de las clases, incluyendo m\u00e9todos e inicializadores. Una de las diferencias m\u00e1s importantes entre estructuras y clases es que las estructuras siempre se copian cuando las pasas en tu c\u00f3digo, mientras que las clases se pasan por referencia. 1 2 3 4 5 6 7 8 9 struct Carta { var valor : Valor var palo : Palo func descripcionSencilla () - String { return El \\( valor . descripcionSencilla ()) de \\( palo . descripcionSencilla ()) } } let tresDeEspadas = Carta ( valor : . tres , palo : . espadas ) let descripcionTresDeEspadas = tresDeEspadas . descripcionSencilla () EXPERIMENTO A\u00f1ade un m\u00e9todo a Carta que cree un mazo completo de cartas, con una carta de cada combinaci\u00f3n de valor y palo. Protocolos y extensiones Usa protocol para declarar un protocolo. 1 2 3 4 protocol ProtocoloEjemplo { var descripcionSencilla : String { get } mutating func ajustar () } Clases, enumeraciones y estructuras pueden todas adoptar protocolos. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class ClaseSencilla : ProtocoloEjemplo { var descripcionSencilla : String = Una clase muy simple. var otraPropiedad : Int = 69105 func ajustar () { descripcionSencilla += Ahora 100% ajustada. } } var a = ClaseSencilla () a . ajustar () let descripcionA = a . descripcionSencilla struct EstructuraSencilla : ProtocoloEjemplo { var descripcionSencilla : String = Una estructura sencilla mutating func ajustar () { descripcionSencilla += (ajustada) } } var b = EstructuraSencilla () b . ajustar () let descripcionB = b . descripcionSencilla EXPERIMENTO Escribe una enumeraci\u00f3n que cumpla el protocolo. Date cuenta del uso de la palabra clave mutating en la declaraci\u00f3n de SimpleStructure para marcar el m\u00e9todo que modifica la estructura. La declaraci\u00f3n de SimpleClass no necesita que se marquen como mutadores ninguno de sus m\u00e9todos porque los m\u00e9todos en una clase siempre pueden modificar la clase. Usa extension para a\u00f1adir funcionalidad a un tipo existente, como m\u00e9todos nuevos y propiedades calculadas. Puedes utilizar una extensi\u00f3n para a\u00f1adir un cumplimiento de un protocolo a un tipo que se declara en otro lugar, o incluso a un tipo que hayas importado de una biblioteca o un framework . 1 2 3 4 5 6 7 8 9 extension Int : ProtocoloEjemplo { var descripcionSencilla : String { return El n\u00famero \\( self ) } mutating func ajustar () { self += 42 } } print ( 7. descripcionSencilla ) Otro ejemplo usando una funci\u00f3n: 1 2 3 4 5 6 7 8 9 extension Int { func repetir ( task : () - ()) { for _ in 0. .. self { task () } } } 10. repetir { print ( Hola )} EXPERIMENTO Escribe una extensi\u00f3n para el tipo Double que a\u00f1ada una propiedad absoluteValue . Puedes usar un nombre de un protocolo de la misma forma que cualquier otro tipo con nombre; por ejemplo, para crear una colecci\u00f3n de objetos que tienen tipos diferentes pero que cumplen un \u00fanico protocolo. Cuando trabajas con valores cuyo tipo es un tipo de protocolo, no est\u00e1n disponibles los m\u00e9todos fuera del protocolo. 1 2 3 let valorProtocolo : ProtocoloEjemplo = a print ( valorProtocolo . descripcionSencilla ) // print(valorProtocolo.otraPropiedad) // Descomentar para comprobar el error Incluso aunque la variable valorProtocolo tenga un tipo en tiempo de ejecuci\u00f3n de ClaseSencilla , el compilador lo trata como uno del tipo ProtocoloEjemplo . De esta forma no es posible acceder accidentalmente a m\u00e9todos o propiedades que implemente la clase de forma adicional al cumplimiento del protocolo. Gen\u00e9ricos Escribe un nombre dentro de par\u00e9ntesis angulares para construir una funci\u00f3n o un tipo gen\u00e9rico. 1 2 3 4 5 6 7 8 func itemRepetido Item ( _ item : Item , numeroDeVeces : Int ) - [ Item ] { var resultado = [ Item ]() for _ in 0. . numeroDeVeces { resultado . append ( item ) } return resultado } print ( itemRepetido ( knock , numeroDeVeces : 4 )) Puedes hacer formas gen\u00e9ricas de funciones y m\u00e9todos, as\u00ed como de clases, enumeraciones y estructuras. 1 2 3 4 5 6 7 // Reimplementamos el tipo Optional de la biblioteca est\u00e1ndar de Swift enum ValorOpcional Envuelto { case ninguno case alguno ( Envuelto ) } var posibleInteger : ValorOpcional Int = . ninguno posibleInteger = . alguno ( 100 ) Es posible usar where justo antes del cuerpo para especificar una lista de requisitos. Por ejemplo, para requerir el tipo que debe implementar un protocolo, para requerir que dos tipos sean los mismos o para requerir que una clase tenga una superclase determinada. 1 2 3 4 5 6 7 8 9 10 11 12 13 func elementosComunes T : Sequence , U : Sequence ( _ izq : T , _ der : U ) - Bool where T . Iterator . Element : Equatable , T . Iterator . Element == U . Iterator . Element { for izqItem in izq { for derItem in der { if izqItem == derItem { return true } } } return false } print ( elementosComunes ([ 1 , 2 , 3 ], [ 3 ])) Si se escribe T: Equatable es equivalente a escribir T ... where T: Equatable . Bibliograf\u00eda y referencias Documentaci\u00f3n sobre Swift The Swift Programming Language (html) Recursos Swift en Apple swift.org Swift Open Source Repositorio swift en GitHub : repositorio principal de Swift, que contiene el c\u00f3digo fuente del compilador Swift, la biblioteca est\u00e1ndar y SourceKit. Repositorio swift-evolution en GitHub : documentos relacionados con la evoluci\u00f3n continua de Swift, incluyendo objetivos de las pr\u00f3ximas versiones y propuestas de cambios y extensiones de Swift. Lenguajes y Paradigmas de Programaci\u00f3n, curso 2018-19 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante","title":"Seminario 2: Seminario de Swift"},{"location":"seminarios/seminario2-swift/seminario2-swift.html#seminario-2-seminario-de-swift","text":"","title":"Seminario 2: Seminario de Swift"},{"location":"seminarios/seminario2-swift/seminario2-swift.html#el-lenguaje-de-programacion-swift","text":"Swift es un lenguaje de programaci\u00f3n compilado, de prop\u00f3sito general y multi-paradigma desarrollado por Apple. Swift se present\u00f3 en la Conferencia de Desarrolladores de Apple (WWDC) de 2014. Durante el a\u00f1o 2014 se desarroll\u00f3 la versi\u00f3n 1.2 y en la WWDC 2015 se present\u00f3 Swift 2, una actualizaci\u00f3n importante del lenguaje. Inicialmente fue un lenguaje propietario, pero el 3 de diciembre de 2015 se hizo open source bajo la licencia Apache 2.0, para las plataformas Apple y Linux. Los cambios en el lenguaje son propuestos y discutidos por la comunidad en un proceso denominado Swift evolution . En la actualidad se ha estabilizado la versi\u00f3n 4 del lenguaje y se est\u00e1 desarrollando la versi\u00f3n 5 que se presentar\u00e1 a finales de 2018. La siguiente descripci\u00f3n se ha extra\u00eddo del repositorio GitHub de Swift: Swift es un lenguaje de programaci\u00f3n de sistemas de alta eficiencia. Tiene una sintaxis limpia y moderna, ofrece acceso transparente a c\u00f3digo y librer\u00edas existentes en C y Objective-C, y es seguro en el uso de memoria ( memory safe ). Aunque est\u00e1 inspirado en Objective-C y en muchos otros lenguajes, Swift no es en si mismo un lenguaje derivado de C. Como lenguaje completo e independiente, Swift proporciona caracter\u00edsticas fundamentales como control de flujo, estructuras de datos y funciones, junto con construcciones de alto nivel como objetos, protocolos, clausuras y gen\u00e9ricos. Swift se apoya en m\u00f3dulos, eliminando la necesidad de cabeceras y la duplicaci\u00f3n de c\u00f3digo que \u00e9stas inducen.","title":"El lenguaje de programaci\u00f3n Swift"},{"location":"seminarios/seminario2-swift/seminario2-swift.html#ejecucion-de-programas-swift","text":"Es posible descargar el compilador de Swift en los sistemas operativos Mac (utilizando el entorno de desarrollo Xcode) o Linux. Para la asignatura recomendamos utilizar una m\u00e1quina Docker basada en la distribuci\u00f3n Linux. La utilizaci\u00f3n de la m\u00e1quina Docker hace posible su utilizaci\u00f3n en Windows y Mac sin instalar Xcode y permite un entorno unificado en el que hacer las pr\u00e1cticas. A continuaci\u00f3n explicamos las distintas formas de ejecutar programas Swift.","title":"Ejecuci\u00f3n de programas Swift"},{"location":"seminarios/seminario2-swift/seminario2-swift.html#ejecucion-en-una-maquina-docker","text":"Docker es una tecnolog\u00eda que ha tenido una gran expansi\u00f3n en los \u00faltimos a\u00f1os. Permite construir m\u00e1quinas virtuales ligeras que utilizan el mismo sistema operativo de la m\u00e1quina host. Estas m\u00e1quinas virtuales se denominan contenedores y, al compartir el propio sistema operativo en el que se est\u00e1n ejecutando, su gesti\u00f3n (construcci\u00f3n, arranque, parada, etc.) es much\u00edsimo m\u00e1s r\u00e1pida que las m\u00e1quinas virtuales tradicionales. Docker se controla desde l\u00ednea de comando, desde la aplicaci\u00f3n Terminal de Mac o el PowerShell de Windows. Existen comandos docker para descargar im\u00e1genes, lanzar y parar contenedores, montar directorios de la m\u00e1quina host en contenedores, etc. Nosotros s\u00f3lo utilizaremos el comando docker run para lanzar un contenedor, pero te recomendamos que investigues y pruebes m\u00e1s comandos y que conozcas mejor esta interesante tecnolog\u00eda. Puedes empezar por la gu\u00eda Get started with Docker . Usaremos la imagen Docker swift:4.0.3 , que contiene el comando swift necesario para compilar y ejecutar aplicaciones Swift.","title":"Ejecuci\u00f3n en una m\u00e1quina Docker"},{"location":"seminarios/seminario2-swift/seminario2-swift.html#instalacion-en-macos","text":"Para instalar la \u00faltima versi\u00f3n de Swift en MacOs debes instalar Xcode. Una vez instalado puedes ejecutar Swift desde el terminal.","title":"Instalaci\u00f3n en MacOS"},{"location":"seminarios/seminario2-swift/seminario2-swift.html#instalacion-en-linux-ubuntu","text":"Existe una distribuci\u00f3n oficial de Swift para Ubuntu de 64 bits (distribuciones 14.04, 16.04 y 16.10). Puedes encontrar la informaci\u00f3n completa en la web oficial de Apple . Brevemente, los pasos son los siguientes: 1 2 3 4 5 $ sudo apt-get install clang libicu-dev // Descargar la versi\u00f3n y plataforma deseada ( fichero swift- VERSION - PLATFORM .tar.gz ) $ tar xzf swift- VERSION - PLATFORM .tar.gz // Esto crea el directorio usr/ en la localizaci\u00f3n del archivo // Actualizar el PATH o mover usr/bin/swift al directorio /usr/bin","title":"Instalaci\u00f3n en Linux Ubuntu"},{"location":"seminarios/seminario2-swift/seminario2-swift.html#editor-de-codigo","text":"Para editar c\u00f3digo Swift puedes usar cualquier editor orientado a programaci\u00f3n. Aconsejamos Atom o Visual Studio Code . Ambos son multi-plataforma.","title":"Editor de c\u00f3digo"},{"location":"seminarios/seminario2-swift/seminario2-swift.html#un-tour-de-swift","text":"Aqu\u00ed empieza el seminario de Swift. El texto que hay a continuaci\u00f3n es una traducci\u00f3n del documento de Apple A Swift Tour en el que se presenta una introducci\u00f3n r\u00e1pida a los conceptos fundamentales del lenguaje. En los temas siguientes de la asignatura (Tema 5 - Programaci\u00f3n Funcional con Swift y Tema 6 - Programaci\u00f3n Orientada a Objetos con Swift) profundizaremos en aspectos como funciones, gen\u00e9ricos, clases o protocolos. Te recomendamos que crees un fichero llamado seminario.swift y que vayas copiando y probando en \u00e9l todos los ejemplos que aparecen a continuaci\u00f3n. La tradici\u00f3n sugiere que el primer programa en un nuevo lenguaje deber\u00eda imprimir las palabras \"Hello, world!\" en la pantalla. En Swift, esto puede hacerse con una \u00fanica l\u00ednea: 1 print ( Hello, world! ) Si has escrito c\u00f3digo en C o en Objective-C, esta sintaxis te parecer\u00e1 familiar. En Swift, esta l\u00ednea de c\u00f3digo es un programa completo. No necesitas importar una biblioteca separada para funcionaliades como entrada/salida o manejo de cadenas. El c\u00f3digo escrito en el \u00e1mbito global se usa como el punto de entrada del programa, por lo que no necesitas una funci\u00f3n main() . Tampoco tienes que escribir puntos y comas al final de cada sentencia. Este tour te da informaci\u00f3n suficiente para empezar a escribir c\u00f3digo in Swift ense\u00f1\u00e1ndote c\u00f3mo conseguir una variedad de tareas de programaci\u00f3n. No te preocupes si no entiendes algo, todo lo que se introduce en este tour se explica en detalle en el resto del libro .","title":"Un tour de Swift"},{"location":"seminarios/seminario2-swift/seminario2-swift.html#bibliografia-y-referencias","text":"Documentaci\u00f3n sobre Swift The Swift Programming Language (html) Recursos Swift en Apple swift.org Swift Open Source Repositorio swift en GitHub : repositorio principal de Swift, que contiene el c\u00f3digo fuente del compilador Swift, la biblioteca est\u00e1ndar y SourceKit. Repositorio swift-evolution en GitHub : documentos relacionados con la evoluci\u00f3n continua de Swift, incluyendo objetivos de las pr\u00f3ximas versiones y propuestas de cambios y extensiones de Swift. Lenguajes y Paradigmas de Programaci\u00f3n, curso 2018-19 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante","title":"Bibliograf\u00eda y referencias"},{"location":"teoria/tema00-descripcion-asignatura/tema00-descripcion-asignatura.html","text":"Lenguajes y Paradigmas de Programaci\u00f3n Datos acad\u00e9micos de la asignatura Departamento de Ciencia de la Computaci\u00f3n e Inteligencia Artificial 6 cr\u00e9ditos ECTS : 1 clase de teor\u00eda de 2 h. y 1 clase de pr\u00e1cticas de 2 h. a la semana Profesores : Antonio Bot\u00eda ( e-mail ): Grupos de pr\u00e1cticas: 2, 9 y 401 Domingo Gallardo ( e-mail ): Profesor coordinador de la asignatura. Grupos de teor\u00eda: 3, 4 y 40. Grupos de pr\u00e1cticas: 4 y 402 Francisco Mart\u00ednez ( e-mail ): Grupos de pr\u00e1cticas: 5, 6 y 8 Cristina Pomares ( e-mail ): Grupos de teor\u00eda: 1 y 2. Grupos de pr\u00e1cticas: 1, 3 y 7. Recursos de la asignatura Ficha de la asignatura Apuntes de la asignatura (teor\u00eda, seminarios y pr\u00e1cticas) Sitio Moodle abierto y accesible a toda la comunidad educativa, contiene los apuntes, transparencias, pr\u00e1cticas y otros materiales docentes Foro de consultas y anuncios en el sitio Moodle (s\u00f3lo accesible a estudiantes) Objetivos y competencias Objetivos : \u00bfQu\u00e9 elementos son comunes a los lenguajes de programaci\u00f3n? \u00bfQu\u00e9 familias o paradigmas de lenguajes podemos identificar? \u00bfQu\u00e9 es la programaci\u00f3n funcional? \u00bfC\u00f3mo es un lenguaje multi-paradigma que combina la programaci\u00f3n funcional y la programaci\u00f3n orientada a objetos? Dominando estos contenidos ser\u00e1 mucho m\u00e1s f\u00e1cil aprender nuevos lenguajes de programaci\u00f3n, identificar sus aspectos esenciales e incluso ser capaz de dise\u00f1ar lenguajes espec\u00edficos orientados a dominios concretos. Competencias : Conocer y diferenciar las caracter\u00edsticas de los distintos paradigmas de programaci\u00f3n (programaci\u00f3n funcional, procedural y orientada a objetos) e identificarlas en lenguajes de programaci\u00f3n concretos. Diferenciar entre tiempo de ejecuci\u00f3n y tiempo de compilaci\u00f3n en distintos \u00e1mbitos: detecci\u00f3n de errores o definici\u00f3n, creaci\u00f3n o \u00e1mbito de vida de variables. Conocer los principios b\u00e1sicos de la programaci\u00f3n funcional: recursi\u00f3n, inmutabilidad, funciones como objetos de primera clase, funciones de orden superior, expresiones lambda (clausuras). Conocer los problemas derivados del uso de la mutaci\u00f3n en los lenguajes de programaci\u00f3n imperativos y la forma de trabajar con estructuras inmutables en lenguajes declarativos y funcionales. Utilizar la abstracci\u00f3n y la recursi\u00f3n para dise\u00f1ar correctamente procedimientos y estructuras de datos (listas y \u00e1rboles). Ser capaz de dise\u00f1ar, implementar y corregir programas funcionales, en concreto utilizando el lenguaje de programaci\u00f3n Scheme. Ser capaz de implementar programas sencillos en Swift, en los que se utilicen las caracter\u00edsticas multi-paradigma del lenguaje. Comparar el paradigma orientado a objetos con el paradigma procedural cl\u00e1sico, reconociendo las ventajas que aporta en cuanto a abstracci\u00f3n, reutilizaci\u00f3n y modificaci\u00f3n de c\u00f3digo. Temario Tema 1. Lenguajes de programaci\u00f3n : Historia de los lenguajes de programaci\u00f3n. Elementos de los lenguajes de programaci\u00f3n. Abstracci\u00f3n. Paradigmas de programaci\u00f3n. Compiladores e int\u00e9rpretes. Tema 2. Programaci\u00f3n Funcional : Caracter\u00edsticas e historia del paradigma de Programaci\u00f3n Funcional. Diferencias con el paradigma imperativo. Caracter\u00edsticas declarativas del paradigma funcional. Definici\u00f3n de funciones. Funciones como datos de primer orden. La forma especial lambda. \u00c1mbito de variables y closures. Datos compuestos en Scheme: parejas. Construcci\u00f3n, recorrido y operaciones sobre listas. Listas con elementos compuestos. Listas de listas. Tema 3. Procedimientos recursivos : Dise\u00f1o de funciones recursivas. Recursi\u00f3n mutua. Procesos recursivos e iterativos. Memoization. Recursi\u00f3n y gr\u00e1ficos de tortuga. Tema 4. Estructuras recursivas : Estructuras de datos recursivas: listas estructuradas y \u00e1rboles. Tema 5. Programaci\u00f3n funcional en Swift : Lenguajes multiparadigma. Programaci\u00f3n funcional en Swift. Valores opcionales. Listas. Recursi\u00f3n pura y recursi\u00f3n por la cola. Funciones como datos de primer orden. Clousures y funciones an\u00f3nimas. Funciones de orden superior: mappings y filtros de colecciones. Tema 6. Programaci\u00f3n Orientada a Objetos en Swift : Caracter\u00edsticas e historia del paradigma de Programaci\u00f3n Orientada a Objetos. Estructuras y clases en Swift. Herencia. Conceptos avanzados de POO en Swift: Extensiones, Protocolos y Gen\u00e9ricos. Gesti\u00f3n de errores. Seminarios: Seminario 1. El lenguaje de programaci\u00f3n Scheme : Primitivas. Tipos de datos b\u00e1sicos. S\u00edmbolos. Cadenas. Listas. Definici\u00f3n de funciones. Seminario 2. El lenguaje de programaci\u00f3n Swift . Int\u00e9rprete y scripts. Tipos de datos b\u00e1sicos. Operadores. Estructuras de control. \u00c1mbito de variables. Tipos de datos compuestos: tuplas, arrays y colecciones. Recorriendo colecciones. Valores mutables e inmutables. Inicializaci\u00f3n. Tipos de referencia y valor en Swift. El calendario de temas, pr\u00e1cticas y ex\u00e1menes se puede ver en la siguiente figura. Pr\u00e1cticas Las pr\u00e1cticas consistir\u00e1n en la resoluci\u00f3n de hojas de ejercicios con 5 o 6 problemas de programaci\u00f3n relacionados con los conceptos vistos en las sesiones de teor\u00eda. Estos ejercicios servir\u00e1n para reforzar y profundizar en las competencias de la asignatura. Para el desarrollo de las pr\u00e1cticas utilizaremos los siguientes lenguajes de programaci\u00f3n y entornos de desarrollo: Racket (versi\u00f3n de Scheme, lenguaje de programaci\u00f3n funcional) Swift (lenguaje multiparadigma creado por Apple, con conceptos modernos de programaci\u00f3n funcional y programaci\u00f3n orientada a objetos) Se realizar\u00e1n 11 sesiones de ejercicios de pr\u00e1cticas de una semana de duraci\u00f3n y 2 seminarios sobre los anteriores lenguajes de programaci\u00f3n. La hoja de ejercicios estar\u00e1 disponible inmediatamente despu\u00e9s de terminar la teor\u00eda y se dispondr\u00e1 de una semana para su realizaci\u00f3n, hasta la sesi\u00f3n de pr\u00e1cticas de la semana siguiente. Durante la semana, mientras se resuelven los ejercicios de la hoja, se podr\u00e1n consultar las dudas que puedan surgir en el foro de la asignatura (en Moodle) y con tutor\u00edas a los profesores. Es preferible el foro, porque de esta forma las contestaciones y aclaraciones ser\u00e1n compartidas con el resto de compa\u00f1eros. En la sesi\u00f3n de pr\u00e1cticas se terminar\u00e1 la hoja de ejercicios, completando el trabajo realizado en casa. Durante la sesi\u00f3n de pr\u00e1cticas el profesor estar\u00e1 disponible para resolver dudas y dar pistas sobre c\u00f3mo atacar los problemas. Al final de la clase de pr\u00e1cticas se realizar\u00e1 en Moodle un cuestionario de pr\u00e1cticas individual sobre los ejercicios propuestos y sobre los conceptos de teor\u00eda asociados. El cuestionario se evaluar\u00e1 con una calificaci\u00f3n de 0 a 10. La nota media de todos los cuestionarios formar\u00e1 parte de la calificaci\u00f3n final de la asignatura, ponderada en un 20%. Uso del software iTALC Durante el desarrollo de las sesiones pr\u00e1cticas es obligatorio usar el ordenador del aula y no el port\u00e1til personal. El profesor de pr\u00e1cticas abrir\u00e1 el programa iTALC, con el que podr\u00e1 comprobar c\u00f3mo est\u00e1is desarrollando los ejercicios y podr\u00e1 haceros recomendaciones cuando lo considere oportuno. Adem\u00e1s se utilizar\u00e1 iTALC para vigilar la contestaci\u00f3n de los cuestionarios. Una vez realizado el cuestionario y terminada la hoja de ejercicios se entregar\u00e1 su soluci\u00f3n en Moodle para su archivo. Cuando todos los grupos hayan hecho los cuestionarios y archivado las pr\u00e1cticas se publicar\u00e1 su soluci\u00f3n. Horarios La distribuci\u00f3n de grupos del curso 2018-19 es la siguiente: Evaluaci\u00f3n Convocatoria normal C3 (evaluaci\u00f3n continua) La asignatura se divide en 3 bloques tem\u00e1ticos, todos ellos de igual duraci\u00f3n, en los que se utilizar\u00e1 el lenguaje de programaci\u00f3n que aparece entre par\u00e9ntesis: Programaci\u00f3n funcional (Scheme) Procesos y estructuras recursivas. (Scheme) Programaci\u00f3n funcional en Swift y programaci\u00f3n orientada a objetos (Swift) Para cada bloque tem\u00e1tico se realizar\u00e1 un examen parcial escrito que ponderar\u00e1 un 26,67% (80% en total) en la nota final. El 20% restante para la nota final se obtendr\u00e1 con la nota media de los cuestionarios realizados en las sesiones de pr\u00e1cticas. Normas importantes sobre la realizaci\u00f3n de los cuestionarios de pr\u00e1cticas Por cuestiones de log\u00edstica de la asignatura, cada alumno debe realizar el cuestionario en el turno de pr\u00e1cticas en el que est\u00e1 matriculado (o el acordado con el profesor si ha sido posible el cambio). Excepcionalmente, si por alg\u00fan motivo JUSTIFICADO, hay alguna vez que no pod\u00e1is asistir a vuestro turno de pr\u00e1cticas, se debe asistir a otro turno de ESA MISMA SEMANA y antes de empezar la clase entregarle el justificante al profesor. Sobre los dispositivos m\u00f3viles Como norma b\u00e1sica de todas las pruebas de evaluaci\u00f3n de esta asignatura (cuestionarios y ex\u00e1menes escritos), durante la realizaci\u00f3n de los mismos no est\u00e1 permitido que llev\u00e9is encima ning\u00fan dispositivo con conexi\u00f3n a internet (smart phones, smart watches, tablets, etc). Antes de empezar la prueba, se deber\u00e1n dejar dentro de las mochilas, y \u00e9stas en el suelo. En caso de no cumplir alguna esta norma, la prueba queda invalidada con calificaci\u00f3n de 0. Convocatoria extraordinaria C4 En la convocatoria extraordinaria se realizar\u00e1 un examen final sobre todos los bloques tem\u00e1ticos cuya calificaci\u00f3n representar\u00e1 el 100% de la nota de la asignatura. Consejos para aprender con \u00e9xito los contenidos de la asignatura El consejo fundamental para aprobar la asignatura es trabajar todas las semanas e intentar seguir el ritmo de la asignatura . Los conceptos de la asignatura se van construyendo de forma progresiva y lo visto en una semana depende muchas veces de lo aprendido en semanas anteriores. \u00bfC\u00f3mo estudiar estos conceptos? Con la excepci\u00f3n de algunos temas y apartados concretos (como la historia de los lenguajes de programaci\u00f3n o las caracter\u00edsticas de los distintos paradigmas) la asignatura es fundamentalmente pr\u00e1ctica. Cuando hablamos de estudiar los ejemplos de c\u00f3digo queremos decir entenderlos, no aprenderlos de memoria . No tiene sentido aprender de memoria los ejercicios y los ejemplos vistos en clase. Hay que trabajarlos . Eso significa que, primero, hay que entenderlos sobre el papel y muy importante hay que probar todos los ejemplos en el int\u00e9rprete (el REPL) . Y probar significa escribir los ejemplos y jugar con ellos, proponiendo peque\u00f1as variantes, pregunt\u00e1ndose \u00bfqu\u00e9 pasar\u00eda si...? y prob\u00e1ndolo. En cuanto a las pr\u00e1cticas y a los ejercicios propuestos es fundamental pelearse con ellos e intentar hacerlos por uno mismo sin ver ninguna soluci\u00f3n . Es la \u00fanica forma de aprender: probando, equivoc\u00e1ndose y encontrando la soluci\u00f3n por uno mismo. A la hora de enfrentarse con un problema es fundamental tambi\u00e9n usar l\u00e1piz y papel para probar enfoques y encontrar la soluci\u00f3n m\u00e1s sencilla sobre el papel antes de probarla en el REPL. Los ejercicios que proponemos no son excesivamente complicados. Todos se resuelven con muy pocas l\u00edneas de c\u00f3digo y su codificaci\u00f3n en el ordenador no tiene dificultad, una vez que se ha encontrado la soluci\u00f3n que lo resuelve. Al usar el l\u00e1piz y papel tambi\u00e9n estar\u00e1s practicando una situaci\u00f3n similar a la que te vas a encontrar en los ex\u00e1menes de la asignatura. Resumiendo: trabajar todas las semanas, hacer uno mismo todos los ejercicios y no desanimarse ni descolgarse. Son muy interesantes algunos comentarios de antiguos estudiantes que han aprobado la asignatura. C\u00f3mo dominar los conceptos Para superar la asignatura lo que hice fue estudiar mucho. Hay que practicar y sobre todo entender los ejercicios y no sabe\u0301rselos de memoria. Una vez dominados los ejercicios yo mismo me propuse variantes de los mismos. Asi\u0301 es como se domina. El problema del cambio de paradigma El problema principal de la asignatura es enfrentarse a un cambio del paradigma de programacio\u0301n.\" Trabajar d\u00eda a d\u00eda Lo que hice fue tratar de llevar al di\u0301a toda la asignatura, adema\u0301s de trabajar con material adicional para poder ampliar y profundizar conocimientos. LPP es una asignatura de fondo en la que tienes que mantener el ritmo de trabajo de principio a fin de cuatrimestre.\" No copiar las pr\u00e1cticas El mayor problema que creo que existe es que muchas personas se relajan y se copian las pra\u0301cticas en cuanto les resultan un poco difi\u0301ciles o les lleva algo mas del tiempo que les gustari\u0301a. Esta asignatura si no haces tu los ejercicios y te peleas con ellos es pra\u0301cticamente imposible de sacar. No memorizar Otra de las cosas es que tienes que cambiar la forma de estudiar, no vale memorizar, ni hacer muchos ejercicios sin ma\u0301s. Tienes que entender bien el funcionamiento de la recursio\u0301n para luego poder practicar con ejercicios, sino no sirve. [...] En mi opinio\u0301n el problema de LPP para mucha gente es que para los exa\u0301menes se memorizan los ejercicios de pra\u0301cticas de las soluciones que se dan en clase. Plantearse uno mismo problemas Los problemas que me encontre\u0301 a la hora de cursar LPP fue que eran dos lenguajes completamente nuevos, otro tipo de programacio\u0301n que nunca habi\u0301a visto, otra forma de estudiar distinta. Para poder superarla simplemente tienes que hacer ejercicios y tambie\u0301n plantearte tu\u0301 mismo nuevos ejercicios. Bibliograf\u00eda En Moodle se publican los apuntes de la asignatura, con ejercicios, explicaciones y ejemplos de todos los conceptos estudiados, tanto en teor\u00eda como en pr\u00e1ctica. Para ampliar algunos conceptos se recomiendan los dos siguientes manuales: Harold Abelson y Gerald Jay Sussman, Structure and Interpretation of Computer Programs , MIT Press, 1996 Enlace a la edici\u00f3n on-line Signatura en la Biblioteca Polit\u00e9cnica: I.06/ABE/STR Apple, The Swift Programming Language (Swift 4.2) , 2019 Web Lenguajes y Paradigmas de Programaci\u00f3n, curso 2018-19 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Domingo Gallardo, Cristina Pomares, Antonio Bot\u00eda, Francisco Mart\u00ednez","title":"Descripci\u00f3n de la asignatura"},{"location":"teoria/tema00-descripcion-asignatura/tema00-descripcion-asignatura.html#lenguajes-y-paradigmas-de-programacion","text":"","title":"Lenguajes y Paradigmas de Programaci\u00f3n"},{"location":"teoria/tema00-descripcion-asignatura/tema00-descripcion-asignatura.html#datos-academicos-de-la-asignatura","text":"Departamento de Ciencia de la Computaci\u00f3n e Inteligencia Artificial 6 cr\u00e9ditos ECTS : 1 clase de teor\u00eda de 2 h. y 1 clase de pr\u00e1cticas de 2 h. a la semana Profesores : Antonio Bot\u00eda ( e-mail ): Grupos de pr\u00e1cticas: 2, 9 y 401 Domingo Gallardo ( e-mail ): Profesor coordinador de la asignatura. Grupos de teor\u00eda: 3, 4 y 40. Grupos de pr\u00e1cticas: 4 y 402 Francisco Mart\u00ednez ( e-mail ): Grupos de pr\u00e1cticas: 5, 6 y 8 Cristina Pomares ( e-mail ): Grupos de teor\u00eda: 1 y 2. Grupos de pr\u00e1cticas: 1, 3 y 7.","title":"Datos acad\u00e9micos de la asignatura"},{"location":"teoria/tema00-descripcion-asignatura/tema00-descripcion-asignatura.html#recursos-de-la-asignatura","text":"Ficha de la asignatura Apuntes de la asignatura (teor\u00eda, seminarios y pr\u00e1cticas) Sitio Moodle abierto y accesible a toda la comunidad educativa, contiene los apuntes, transparencias, pr\u00e1cticas y otros materiales docentes Foro de consultas y anuncios en el sitio Moodle (s\u00f3lo accesible a estudiantes)","title":"Recursos de la asignatura"},{"location":"teoria/tema00-descripcion-asignatura/tema00-descripcion-asignatura.html#objetivos-y-competencias","text":"Objetivos : \u00bfQu\u00e9 elementos son comunes a los lenguajes de programaci\u00f3n? \u00bfQu\u00e9 familias o paradigmas de lenguajes podemos identificar? \u00bfQu\u00e9 es la programaci\u00f3n funcional? \u00bfC\u00f3mo es un lenguaje multi-paradigma que combina la programaci\u00f3n funcional y la programaci\u00f3n orientada a objetos? Dominando estos contenidos ser\u00e1 mucho m\u00e1s f\u00e1cil aprender nuevos lenguajes de programaci\u00f3n, identificar sus aspectos esenciales e incluso ser capaz de dise\u00f1ar lenguajes espec\u00edficos orientados a dominios concretos. Competencias : Conocer y diferenciar las caracter\u00edsticas de los distintos paradigmas de programaci\u00f3n (programaci\u00f3n funcional, procedural y orientada a objetos) e identificarlas en lenguajes de programaci\u00f3n concretos. Diferenciar entre tiempo de ejecuci\u00f3n y tiempo de compilaci\u00f3n en distintos \u00e1mbitos: detecci\u00f3n de errores o definici\u00f3n, creaci\u00f3n o \u00e1mbito de vida de variables. Conocer los principios b\u00e1sicos de la programaci\u00f3n funcional: recursi\u00f3n, inmutabilidad, funciones como objetos de primera clase, funciones de orden superior, expresiones lambda (clausuras). Conocer los problemas derivados del uso de la mutaci\u00f3n en los lenguajes de programaci\u00f3n imperativos y la forma de trabajar con estructuras inmutables en lenguajes declarativos y funcionales. Utilizar la abstracci\u00f3n y la recursi\u00f3n para dise\u00f1ar correctamente procedimientos y estructuras de datos (listas y \u00e1rboles). Ser capaz de dise\u00f1ar, implementar y corregir programas funcionales, en concreto utilizando el lenguaje de programaci\u00f3n Scheme. Ser capaz de implementar programas sencillos en Swift, en los que se utilicen las caracter\u00edsticas multi-paradigma del lenguaje. Comparar el paradigma orientado a objetos con el paradigma procedural cl\u00e1sico, reconociendo las ventajas que aporta en cuanto a abstracci\u00f3n, reutilizaci\u00f3n y modificaci\u00f3n de c\u00f3digo.","title":"Objetivos y competencias"},{"location":"teoria/tema00-descripcion-asignatura/tema00-descripcion-asignatura.html#temario","text":"Tema 1. Lenguajes de programaci\u00f3n : Historia de los lenguajes de programaci\u00f3n. Elementos de los lenguajes de programaci\u00f3n. Abstracci\u00f3n. Paradigmas de programaci\u00f3n. Compiladores e int\u00e9rpretes. Tema 2. Programaci\u00f3n Funcional : Caracter\u00edsticas e historia del paradigma de Programaci\u00f3n Funcional. Diferencias con el paradigma imperativo. Caracter\u00edsticas declarativas del paradigma funcional. Definici\u00f3n de funciones. Funciones como datos de primer orden. La forma especial lambda. \u00c1mbito de variables y closures. Datos compuestos en Scheme: parejas. Construcci\u00f3n, recorrido y operaciones sobre listas. Listas con elementos compuestos. Listas de listas. Tema 3. Procedimientos recursivos : Dise\u00f1o de funciones recursivas. Recursi\u00f3n mutua. Procesos recursivos e iterativos. Memoization. Recursi\u00f3n y gr\u00e1ficos de tortuga. Tema 4. Estructuras recursivas : Estructuras de datos recursivas: listas estructuradas y \u00e1rboles. Tema 5. Programaci\u00f3n funcional en Swift : Lenguajes multiparadigma. Programaci\u00f3n funcional en Swift. Valores opcionales. Listas. Recursi\u00f3n pura y recursi\u00f3n por la cola. Funciones como datos de primer orden. Clousures y funciones an\u00f3nimas. Funciones de orden superior: mappings y filtros de colecciones. Tema 6. Programaci\u00f3n Orientada a Objetos en Swift : Caracter\u00edsticas e historia del paradigma de Programaci\u00f3n Orientada a Objetos. Estructuras y clases en Swift. Herencia. Conceptos avanzados de POO en Swift: Extensiones, Protocolos y Gen\u00e9ricos. Gesti\u00f3n de errores. Seminarios: Seminario 1. El lenguaje de programaci\u00f3n Scheme : Primitivas. Tipos de datos b\u00e1sicos. S\u00edmbolos. Cadenas. Listas. Definici\u00f3n de funciones. Seminario 2. El lenguaje de programaci\u00f3n Swift . Int\u00e9rprete y scripts. Tipos de datos b\u00e1sicos. Operadores. Estructuras de control. \u00c1mbito de variables. Tipos de datos compuestos: tuplas, arrays y colecciones. Recorriendo colecciones. Valores mutables e inmutables. Inicializaci\u00f3n. Tipos de referencia y valor en Swift. El calendario de temas, pr\u00e1cticas y ex\u00e1menes se puede ver en la siguiente figura.","title":"Temario"},{"location":"teoria/tema00-descripcion-asignatura/tema00-descripcion-asignatura.html#practicas","text":"Las pr\u00e1cticas consistir\u00e1n en la resoluci\u00f3n de hojas de ejercicios con 5 o 6 problemas de programaci\u00f3n relacionados con los conceptos vistos en las sesiones de teor\u00eda. Estos ejercicios servir\u00e1n para reforzar y profundizar en las competencias de la asignatura. Para el desarrollo de las pr\u00e1cticas utilizaremos los siguientes lenguajes de programaci\u00f3n y entornos de desarrollo: Racket (versi\u00f3n de Scheme, lenguaje de programaci\u00f3n funcional) Swift (lenguaje multiparadigma creado por Apple, con conceptos modernos de programaci\u00f3n funcional y programaci\u00f3n orientada a objetos) Se realizar\u00e1n 11 sesiones de ejercicios de pr\u00e1cticas de una semana de duraci\u00f3n y 2 seminarios sobre los anteriores lenguajes de programaci\u00f3n. La hoja de ejercicios estar\u00e1 disponible inmediatamente despu\u00e9s de terminar la teor\u00eda y se dispondr\u00e1 de una semana para su realizaci\u00f3n, hasta la sesi\u00f3n de pr\u00e1cticas de la semana siguiente. Durante la semana, mientras se resuelven los ejercicios de la hoja, se podr\u00e1n consultar las dudas que puedan surgir en el foro de la asignatura (en Moodle) y con tutor\u00edas a los profesores. Es preferible el foro, porque de esta forma las contestaciones y aclaraciones ser\u00e1n compartidas con el resto de compa\u00f1eros. En la sesi\u00f3n de pr\u00e1cticas se terminar\u00e1 la hoja de ejercicios, completando el trabajo realizado en casa. Durante la sesi\u00f3n de pr\u00e1cticas el profesor estar\u00e1 disponible para resolver dudas y dar pistas sobre c\u00f3mo atacar los problemas. Al final de la clase de pr\u00e1cticas se realizar\u00e1 en Moodle un cuestionario de pr\u00e1cticas individual sobre los ejercicios propuestos y sobre los conceptos de teor\u00eda asociados. El cuestionario se evaluar\u00e1 con una calificaci\u00f3n de 0 a 10. La nota media de todos los cuestionarios formar\u00e1 parte de la calificaci\u00f3n final de la asignatura, ponderada en un 20%. Uso del software iTALC Durante el desarrollo de las sesiones pr\u00e1cticas es obligatorio usar el ordenador del aula y no el port\u00e1til personal. El profesor de pr\u00e1cticas abrir\u00e1 el programa iTALC, con el que podr\u00e1 comprobar c\u00f3mo est\u00e1is desarrollando los ejercicios y podr\u00e1 haceros recomendaciones cuando lo considere oportuno. Adem\u00e1s se utilizar\u00e1 iTALC para vigilar la contestaci\u00f3n de los cuestionarios. Una vez realizado el cuestionario y terminada la hoja de ejercicios se entregar\u00e1 su soluci\u00f3n en Moodle para su archivo. Cuando todos los grupos hayan hecho los cuestionarios y archivado las pr\u00e1cticas se publicar\u00e1 su soluci\u00f3n.","title":"Pr\u00e1cticas"},{"location":"teoria/tema00-descripcion-asignatura/tema00-descripcion-asignatura.html#horarios","text":"La distribuci\u00f3n de grupos del curso 2018-19 es la siguiente:","title":"Horarios"},{"location":"teoria/tema00-descripcion-asignatura/tema00-descripcion-asignatura.html#evaluacion","text":"","title":"Evaluaci\u00f3n"},{"location":"teoria/tema00-descripcion-asignatura/tema00-descripcion-asignatura.html#convocatoria-normal-c3-evaluacion-continua","text":"La asignatura se divide en 3 bloques tem\u00e1ticos, todos ellos de igual duraci\u00f3n, en los que se utilizar\u00e1 el lenguaje de programaci\u00f3n que aparece entre par\u00e9ntesis: Programaci\u00f3n funcional (Scheme) Procesos y estructuras recursivas. (Scheme) Programaci\u00f3n funcional en Swift y programaci\u00f3n orientada a objetos (Swift) Para cada bloque tem\u00e1tico se realizar\u00e1 un examen parcial escrito que ponderar\u00e1 un 26,67% (80% en total) en la nota final. El 20% restante para la nota final se obtendr\u00e1 con la nota media de los cuestionarios realizados en las sesiones de pr\u00e1cticas. Normas importantes sobre la realizaci\u00f3n de los cuestionarios de pr\u00e1cticas Por cuestiones de log\u00edstica de la asignatura, cada alumno debe realizar el cuestionario en el turno de pr\u00e1cticas en el que est\u00e1 matriculado (o el acordado con el profesor si ha sido posible el cambio). Excepcionalmente, si por alg\u00fan motivo JUSTIFICADO, hay alguna vez que no pod\u00e1is asistir a vuestro turno de pr\u00e1cticas, se debe asistir a otro turno de ESA MISMA SEMANA y antes de empezar la clase entregarle el justificante al profesor. Sobre los dispositivos m\u00f3viles Como norma b\u00e1sica de todas las pruebas de evaluaci\u00f3n de esta asignatura (cuestionarios y ex\u00e1menes escritos), durante la realizaci\u00f3n de los mismos no est\u00e1 permitido que llev\u00e9is encima ning\u00fan dispositivo con conexi\u00f3n a internet (smart phones, smart watches, tablets, etc). Antes de empezar la prueba, se deber\u00e1n dejar dentro de las mochilas, y \u00e9stas en el suelo. En caso de no cumplir alguna esta norma, la prueba queda invalidada con calificaci\u00f3n de 0.","title":"Convocatoria normal C3 (evaluaci\u00f3n continua)"},{"location":"teoria/tema00-descripcion-asignatura/tema00-descripcion-asignatura.html#convocatoria-extraordinaria-c4","text":"En la convocatoria extraordinaria se realizar\u00e1 un examen final sobre todos los bloques tem\u00e1ticos cuya calificaci\u00f3n representar\u00e1 el 100% de la nota de la asignatura.","title":"Convocatoria extraordinaria C4"},{"location":"teoria/tema00-descripcion-asignatura/tema00-descripcion-asignatura.html#consejos-para-aprender-con-exito-los-contenidos-de-la-asignatura","text":"El consejo fundamental para aprobar la asignatura es trabajar todas las semanas e intentar seguir el ritmo de la asignatura . Los conceptos de la asignatura se van construyendo de forma progresiva y lo visto en una semana depende muchas veces de lo aprendido en semanas anteriores. \u00bfC\u00f3mo estudiar estos conceptos? Con la excepci\u00f3n de algunos temas y apartados concretos (como la historia de los lenguajes de programaci\u00f3n o las caracter\u00edsticas de los distintos paradigmas) la asignatura es fundamentalmente pr\u00e1ctica. Cuando hablamos de estudiar los ejemplos de c\u00f3digo queremos decir entenderlos, no aprenderlos de memoria . No tiene sentido aprender de memoria los ejercicios y los ejemplos vistos en clase. Hay que trabajarlos . Eso significa que, primero, hay que entenderlos sobre el papel y muy importante hay que probar todos los ejemplos en el int\u00e9rprete (el REPL) . Y probar significa escribir los ejemplos y jugar con ellos, proponiendo peque\u00f1as variantes, pregunt\u00e1ndose \u00bfqu\u00e9 pasar\u00eda si...? y prob\u00e1ndolo. En cuanto a las pr\u00e1cticas y a los ejercicios propuestos es fundamental pelearse con ellos e intentar hacerlos por uno mismo sin ver ninguna soluci\u00f3n . Es la \u00fanica forma de aprender: probando, equivoc\u00e1ndose y encontrando la soluci\u00f3n por uno mismo. A la hora de enfrentarse con un problema es fundamental tambi\u00e9n usar l\u00e1piz y papel para probar enfoques y encontrar la soluci\u00f3n m\u00e1s sencilla sobre el papel antes de probarla en el REPL. Los ejercicios que proponemos no son excesivamente complicados. Todos se resuelven con muy pocas l\u00edneas de c\u00f3digo y su codificaci\u00f3n en el ordenador no tiene dificultad, una vez que se ha encontrado la soluci\u00f3n que lo resuelve. Al usar el l\u00e1piz y papel tambi\u00e9n estar\u00e1s practicando una situaci\u00f3n similar a la que te vas a encontrar en los ex\u00e1menes de la asignatura. Resumiendo: trabajar todas las semanas, hacer uno mismo todos los ejercicios y no desanimarse ni descolgarse. Son muy interesantes algunos comentarios de antiguos estudiantes que han aprobado la asignatura. C\u00f3mo dominar los conceptos Para superar la asignatura lo que hice fue estudiar mucho. Hay que practicar y sobre todo entender los ejercicios y no sabe\u0301rselos de memoria. Una vez dominados los ejercicios yo mismo me propuse variantes de los mismos. Asi\u0301 es como se domina. El problema del cambio de paradigma El problema principal de la asignatura es enfrentarse a un cambio del paradigma de programacio\u0301n.\" Trabajar d\u00eda a d\u00eda Lo que hice fue tratar de llevar al di\u0301a toda la asignatura, adema\u0301s de trabajar con material adicional para poder ampliar y profundizar conocimientos. LPP es una asignatura de fondo en la que tienes que mantener el ritmo de trabajo de principio a fin de cuatrimestre.\" No copiar las pr\u00e1cticas El mayor problema que creo que existe es que muchas personas se relajan y se copian las pra\u0301cticas en cuanto les resultan un poco difi\u0301ciles o les lleva algo mas del tiempo que les gustari\u0301a. Esta asignatura si no haces tu los ejercicios y te peleas con ellos es pra\u0301cticamente imposible de sacar. No memorizar Otra de las cosas es que tienes que cambiar la forma de estudiar, no vale memorizar, ni hacer muchos ejercicios sin ma\u0301s. Tienes que entender bien el funcionamiento de la recursio\u0301n para luego poder practicar con ejercicios, sino no sirve. [...] En mi opinio\u0301n el problema de LPP para mucha gente es que para los exa\u0301menes se memorizan los ejercicios de pra\u0301cticas de las soluciones que se dan en clase. Plantearse uno mismo problemas Los problemas que me encontre\u0301 a la hora de cursar LPP fue que eran dos lenguajes completamente nuevos, otro tipo de programacio\u0301n que nunca habi\u0301a visto, otra forma de estudiar distinta. Para poder superarla simplemente tienes que hacer ejercicios y tambie\u0301n plantearte tu\u0301 mismo nuevos ejercicios.","title":"Consejos para aprender con \u00e9xito los contenidos de la asignatura"},{"location":"teoria/tema00-descripcion-asignatura/tema00-descripcion-asignatura.html#bibliografia","text":"En Moodle se publican los apuntes de la asignatura, con ejercicios, explicaciones y ejemplos de todos los conceptos estudiados, tanto en teor\u00eda como en pr\u00e1ctica. Para ampliar algunos conceptos se recomiendan los dos siguientes manuales: Harold Abelson y Gerald Jay Sussman, Structure and Interpretation of Computer Programs , MIT Press, 1996 Enlace a la edici\u00f3n on-line Signatura en la Biblioteca Polit\u00e9cnica: I.06/ABE/STR Apple, The Swift Programming Language (Swift 4.2) , 2019 Web Lenguajes y Paradigmas de Programaci\u00f3n, curso 2018-19 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Domingo Gallardo, Cristina Pomares, Antonio Bot\u00eda, Francisco Mart\u00ednez","title":"Bibliograf\u00eda"},{"location":"teoria/tema01-historia-lenguajes-programacion/tema01-historia-lenguajes-programacion.html","text":"Tema 1: Historia y conceptos de los lenguajes de programaci\u00f3n Historia de los lenguajes de programaci\u00f3n De las m\u00e1quinas de calcular a los computadores programables M\u00e1quina de Schickard (1623) Calculadora de Pascal (1650) Desde las primeras calculadoras mec\u00e1nicas dise\u00f1adas en el siglo XVII hasta los a\u00f1os 40 del siglo pasado se han inventado multitud de m\u00e1quinas y computadores mec\u00e1nicos, anal\u00f3gicos o electr\u00f3nicos que han intentado acelerar y mejorar la precisi\u00f3n de los c\u00e1lculos. El punto culminante de todos los enfoques mec\u00e1nicos para realizar c\u00e1lculos fue el famoso Motor Anal\u00edtico dise\u00f1ado por Charles Babbage en 1840. La diferencia fundamental con todos los artefactos anteriores es que se trataba de una m\u00e1quina de calcular programable mediante tarjetas perforadas (Babbage se inspir\u00f3 en el telar de Jackquard en el que el dise\u00f1o de los dibujos de las telas se pod\u00edan configurar usando tarjetas perforadas). La m\u00e1quina estaba dise\u00f1ada para trabajar en base 10 y se pod\u00eda conseguir que sus c\u00e1lculos realizaran saltos condicionales y bucles. Babbage trabaj\u00f3 durante m\u00e1s de 30 a\u00f1os para intentar construir la m\u00e1quina. Ten\u00eda una enorme complejidad para la \u00e9poca y necesitaba much\u00edsima financiaci\u00f3n. En 1871 muri\u00f3 habiendo podido construir s\u00f3lo una parte. La matem\u00e1tica Ada Lovelace tuvo un papel fundamental en la divulgaci\u00f3n de la m\u00e1quina, de sus sistema de programaci\u00f3n y fue la primera que entendi\u00f3 sus posibilidades m\u00e1s all\u00e1 del c\u00e1lculo de f\u00f3rmulas. De forma poco habitual para la \u00e9poca, Ada fue educada en el campo de las ciencias y de las matem\u00e1ticas. A principios de 1840, con veinticico a\u00f1os, conoci\u00f3 el trabajo de Babbage y colabor\u00f3 con \u00e9l, dedic\u00e1ndose durante varios a\u00f1os a conocer y estudiar el dise\u00f1o y el funcionamiento del motor anal\u00edtico. En 1843 public\u00f3 el trabajo \"Sketch of the analytical engine invented by Charles Babbage\" en el que describe el Motor Anal\u00edtico, a\u00f1ade reflexiones propias sobre el alcance del invento y construye un ejemplo completo, con tablas y diagramas, de c\u00f3mo hacer que la m\u00e1quina produzca la secuencia de los n\u00fameros de Bernoulli. Se puede considerar estas tablas y diagramas como el primer programa de un computador . Antes de que existiera ning\u00fan computador real, en 1936, el matem\u00e1tico ingl\u00e9s Alan Turing formaliz\u00f3 la idea abstracta de computador, utilizando un modelo muy sencillo de procesamiento: una m\u00e1quina abstracta con un scanner que lee y escribe 0s y 1s de una cinta infinita (memoria) y se mueve y los escribe en funci\u00f3n de una tabla definida en la m\u00e1quina (programa). Con esta m\u00e1quina abstracta ( M\u00e1quina de Turing ) Turing explora la idea de lo computable y lo no computable. \u00bfExisten problemas no computables para los que no es posible inventar un algoritmo que los resuelva? Turing demuestra que s\u00ed y establece con su trabajo los l\u00edmites de la computaci\u00f3n. En el mismo trabajo Turing define el concepto de m\u00e1quina universal que es capaz de leer de la cinta un programa cualquiera y simular su comportamiento en otra parte de la cinta. Esta idea tuvo un profundo impacto en el desarrollo de los computadores, porque mostraba que es posible escribir programas que tomen como datos otros programas. Esto abre la puerta a la idea de los programas almacenados en memoria (ya que son otros datos m\u00e1s) y a la creaci\u00f3n de compiladores e int\u00e9rpretes. En la d\u00e9cada de 1940 hubo una explosi\u00f3n de m\u00e1quinas de computaci\u00f3n electr\u00f3nicas y electromec\u00e1nicas. Fue una d\u00e9cada prodigiosa en la que se desarrollaron tecnolog\u00edas cada vez m\u00e1s r\u00e1pidas y resistentes, y se consiguieron enormes avances en la velocidad y precisi\u00f3n de los c\u00e1lculos. Pero no fue hasta 1945 cuando John Von Neumann , que trabajaba en la construcci\u00f3n del ENIAC , propuso su famosa arquitectura en la que por primera vez se introducen las dos ideas claves de los computadores de prop\u00f3sito general: el programa almacenado en memoria y un conjunto de instrucciones de procesamiento que incluye el direccionamiento indirecto. Y en 1948, tres a\u00f1os despu\u00e9s, se construy\u00f3 en la universidad de Manchester el primer computador electr\u00f3nico digital de prop\u00f3sito general que utilizaba esta arquitectura (llamado Baby ). Fue dise\u00f1ado por Max Newmann usando la tecnolog\u00eda proporcionada por los ingenieros F.C. Williams y Tom Kilburn. Williams hab\u00eda inventado un dispositivo de memoria electr\u00f3nico (la v\u00e1lvula de Williams ) capaz de sustituir las lentas l\u00edneas de retardo de mercurio utilizadas hasta ese momento. La m\u00e1quina de Manchester fue el primer computador con un conjunto de instrucciones completo, capaz de realizar saltos, condicionales y direccionamiento indirecto. La primera ejecuci\u00f3n de un programa fue el 21 de junio de 1948. En esa fecha Alan Turing se incorpor\u00f3 a la universidad de Manchester, como director del Laboratorio de Computaci\u00f3n. Tres a\u00f1os despu\u00e9s, con un dise\u00f1o ampliado en el que tambi\u00e9n influy\u00f3 Turing, una versi\u00f3n mucho mayor de la m\u00e1quina se convirti\u00f3 en el primer computador disponible comercialmente, el Ferranti Mark I. El primero se instal\u00f3 en la universidad de Manchester en febrero de 1951, un mes antes que el UNIVAC I fuera entregado al Departamento de Censo de los EEUU. Se vendieron otras 10 m\u00e1quinas a Gran Breta\u00f1a, Canad\u00e1, Holanda e Italia. El primer programa complejo de Inteligencia Artificial, un jugador de damas escrito por Christopher Strachey, se ejecut\u00f3 en el verano de 1952 en el Ferranti Mark I en el Laboratorio de Computaci\u00f3n de Manchester. Strachey escribi\u00f3 el programa animado por Turing y usando el manual de programaci\u00f3n del Ferranti que Turing acababa de escribir. Turing particip\u00f3 tambi\u00e9n en el desarrollo de otros programas de IA, como un jugador de ajedrez basado en heur\u00edsticas. Los primeros lenguajes de programaci\u00f3n Los primeros computadores electr\u00f3nicos se programan directamente usando el conjunto de instrucciones del procesador, en c\u00f3digo m\u00e1quina, c\u00f3digo hexadecimal El primer lenguaje de un nivel algo m\u00e1s elevado que el c\u00f3digo m\u00e1quina es el ensamblador. Programas que empiezan a ayudar a los programadores: ensambladores. Hay una relaci\u00f3n casi directa entre la notaci\u00f3n en ensamblador y el c\u00f3digo hexadecimal que produce el ensamblador. A finales de la d\u00e9cada de los 40 se empiezan a intentar resolver con los primeros computadores los primeros problemas matem\u00e1ticos distintos de operaciones num\u00e9ricas: codificaci\u00f3n y descodificaci\u00f3n, problemas combinatorios como el coloreado del mapa o problemas de ordenaci\u00f3n. Uno de los primeros algoritmos de von Neumann realiza una ordenaci\u00f3n de un conjunto de n\u00fameros. Von Neumann lo describe en una carta fechada en 1945. Utiliza el conjunto de instrucciones del EDSAC cuando todav\u00eda no se hab\u00eda construido. El programa fue estudiado por Donald Knuth en el art\u00edculo Von Neumann's first Computer Program , en donde documenta que hab\u00eda un bug en las primeras instrucciones. Es el primer bug escrito del que se tiene historia. Si Von Neumann hubiera podido ejecutar el programa en el EDSAC se hubiera dado cuenta del error y hubiera sido la primera depuraci\u00f3n de un programa. Primer programa de Von Neumann (Donald Knuth, \"Von Neumann's first Computer Program\", Journal of the ACM Computing Surveys (CSUR) Surveys, Volume 2 Issue 4, Dec. 1970, Pages 247-260) El nacimiento de los computadores comerciales El UNIVAC fue el primer computador comercial (1951). Con este computadora aparece por primera vez la figura del programador: manuales, cursos de formaci\u00f3n, ofertas de empleo, etc. UNIVAC Instalaciones comerciales del UNIVAC Manual de programaci\u00f3n del UNIVAC (1959) Los computadores son lentos y muy complicados de instalar y mantener. Son m\u00e1s importantes las horas de funcionamiento del computador que las horas de trabajo del programador. La complejidad de las tareas a programar es peque\u00f1a y es suficiente con los programas en ensamblador. El manual de 1959 de programaci\u00f3n del UNIVAC es una referencia hist\u00f3rica de gran inter\u00e9s de la que hemos extra\u00eddo las siguientes im\u00e1genes: Manual del UNIVAC Programaci\u00f3n del UNIVAC Algoritmo UNIVAC Codigo UNIVAC Se realizan los primeros anuncios y reportajes de televisi\u00f3n sobre computadores ( YouTube ) Anuncio UNIVAC IBM 704 El IBM 704 fue el otro gran ordenador comercial de la d\u00e9cada de los 50. Tuvo una difusi\u00f3n mucho mayor que el UNIVAC: centros gubernamentales, universidades. Los primeros lenguajes de programaci\u00f3n de alto nivel se desarrollan para este computador. Foto IBM 704 Programando los primeros computadores The UNIVAC I was an interesting machine to program, with its mercury delay line storage and its short mean time to failure. Programs were entered into the computer by typing them onto steel magnetic tape, a major innovation at that time. Working with the IBM 704 at NYU was an entirely different experience from the UNIVAC I. It was built for executing scientific applications, and had as its major innovation a magnetic core memory, replacing the Williams tube memory of the IBM 701 and the primary memory drum of the IBM 650. It also had a floating point arithmetic unit and index registers to form effective addresses, both of which were significant advances at that time. The machine had the equivalent of 128 KB primary memory, 32 KB of secondary drum memory and magnetic tapes that held 5 MB of data. It operated at 0.04 MIPS, and cost $3 million dollars in 1957, the equivalent of perhaps $20 million today. George Sadowsky, My Second Computer was a UNIVAC I Los primeros lenguajes de alto nivel Los primeros lenguajes de alto nivel se desarrollaron a finales de la d\u00e9cada de los 50: FORTRAN en 1956 Lisp en 1958 Ambos lenguajes planteaban dos enfoques muy distintos desde el principio: FORTRAN Primer lenguaje comercial, equipo de IBM dirigido por John W. Backus Lenguaje imperativo: estado, estructuras de control, contador de programa, celdas de memoria Lenguaje compilado Lisp Lenguaje dise\u00f1ado en un departamento de investigaci\u00f3n, un equipo del MIT dirigido por John McCarthy Lenguaje funcional: funciones, recursi\u00f3n, listas, s\u00edmbolos Lenguaje interpretado FORTRAN Desarrollado por IBM para programar el IBM 704. Algunos datos: Su nombre proviene de FORmula TRANslating system . El primer manual de FORTRAN se imprime en octubre de 1956 para el IBM 704. El primer compilador se comercializa en abril de 1956. Cita de John Backus ( Wikipedia sobre FORTRAN ): Much of my work has come from being lazy. I didn't like writing programs, and so, when I was working on the IBM 701, writing programs for computing missile trajectories, I started work on a programming system to make it easier to write programs. John Backus Ejemplo FORTRAN Tomado del manual de FORTRAN del IBM 704 Lisp El otro lenguaje de alto nivel desarrollado en esa \u00e9poca es el Lisp. Desarrollado a finales de los 50 en el MIT por John McCarthy. Aunque hist\u00f3ricamente el nombre del lenguaje se sol\u00eda escribir con letras may\u00fasculas (LISP), posteriormente se ha popularizado el uso de la may\u00fascula s\u00f3lo para la primera letra (Lisp). Esta forma es m\u00e1s fiel al origen del nombre del lenguaje. Lisp no es un acr\u00f3nimo, sino la contracci\u00f3n de la expresi\u00f3n List Processing . El procesamiento de listas es una de las caracter\u00edsticas principales del Lisp. McCarthy explica en un art\u00edculo de 1979 la historia inicial del Lisp: [...] My desire for an algebraic list processing language for artificial intelligence work on the IBM 704 computer arose in the summer of 1956 during the Dartmouth Summer Research Project on Artificial Intelligence which was the first organized study of AI. [...] [...] There were two motivations for developing a language for the IBM 704. First, IBM was generously establishing a New England Computation Center at M.I.T. which Dartmouth would use. Second, IBM was undertaking to develop a program for proving theorems in plane geometry (based on an idea of Marvin Minsky's), and I was to serve as a consultant to that project. At the time, IBM looked like a good bet to pursue artificial intelligence research vigorously, and further projects were expected. It was not then clear whether IBM's FORTRAN project would lead to a language within which list processing could conveniently be carried out or whether a new language would be required.[...] [...] I invented conditional expressions in connection with a set of chess legal move routines I wrote in FORTRAN for the IBM 704 at M.I.T. during 1957-58. This program did not use list processing. The IF statement provided in FORTRAN 1 and FORTRAN 2 was very awkward to use, and it was natural to invent a function XIF(M,N1,N2) whose value was N1 or N2 according to whether the expression M was zero or not. The function shortened many programs and made them easier to understand, but it had to be used sparingly, because all three arguments had to be evaluated before XIF was entered, since XIF was called as an ordinary FORTRAN function though written in machine language. This led to the invention of the true conditional expression which evaluates only one of N1 and N2 according to whether M is true or false and to a desire for a programming language that would allow its use.[...] John McCarthy, History of LISP John McCarthy Uno de los primeros manuales de Lisp publicados es el manual de LISP de 1960 para el IBM 704 escrito por Phyllis A. Fox. del grupo de investigaci\u00f3n del MIT dirigido por McCarthy. Un ejemplo de c\u00f3digo Lisp: Ejemplo LISP Tomado de \" The Programming Language LISP \", MIT Press, 1964 La explosi\u00f3n de los lenguajes de programaci\u00f3n Desde 1954 hasta la actualidad se han documentado m\u00e1s de 2.500 (consultar en The Language List ). Entre 1952 y 1972 alrededor de 200 lenguajes. Una decena fueron realmente siginificativos y tuvieron influencia en el desarrollo de lenguajes posteriores. Genealog\u00eda de los lenguajes de programaci\u00f3n Genealog\u00eda de los LP Algunas notas sobre la genealog\u00eda: APL es un lenguaje algebraico declarativo de especificaci\u00f3n de funciones y circuitos l\u00f3gicos. Su car\u00e1cter declarativo ha tenido influencia en lenguajes como Prolog o Haskell. Lisp no s\u00f3lo es un lenguaje funcional, sino que tambi\u00e9n es el primer lenguaje interpretado, con muchas caracter\u00edsticas de tiempo de ejecuci\u00f3n y poco chequeo est\u00e1tico. En esos aspectos ha influido en lenguajes din\u00e1micos no funcionales como Python o Smalltalk. Lenguajes como Smalltalk o Objective-C tambi\u00e9n heredan de Lisp algunas caracter\u00edsticas funcionales como la posibilidad de usar un bloque de c\u00f3digo como un objeto primitivo que se crea en tiempo de ejecuci\u00f3n y que se puede asignar o pasar como par\u00e1metro. Es lo que se denomina clausura en el paradigma de programaci\u00f3n funcional. SIMULA es el primer lenguaje que define conceptos como clase u objeto. Es el origen de la programaci\u00f3n orientada a objetos est\u00e1tica y fuertemente tipeada. Lenguajes como C++, Eiffel, o Java toman esta idea. Frente a esta tendencia se encuentra otra visi\u00f3n de la programaci\u00f3n orientada a objetos de lenguajes como Smalltalk u Objective-C en la que se enfatiza m\u00e1s aspectos din\u00e1micos como el paso de mensajes o la modificaci\u00f3n de clases en tiempo de ejecuci\u00f3n. Algunos lenguajes importantes y su fecha de creaci\u00f3n 1950-1960 1970 1980 1990 2000 1957 FORTRAN 1970 Pascal 1980 Smalltalk-80 1990 Haskell 2000 C# 1958 ALGOL 1972 Prolog 1983 Objective-C 1991 Python 2003 Scala 1960 Lisp 1972 C 1983 Ada 1993 Ruby 2003 Groovy 1960 COBOL 1975 Scheme 1986 C++ 1995 Java 2009 Go 1962 APL 1975 Modula 1986 Eiffel 2014 Swift 1964 BASIC 1987 Perl 1967 SIMULA Aspectos que provocan la evoluci\u00f3n de los LP \u00bfPor qu\u00e9 hay tanta variedad en los lenguajes de programaci\u00f3n? Hay muchos aspectos que fomentan esta variedad y que provocan la necesidad de nuevos lenguajes: Nuevos recursos y tipos de ordenadores Nuevas aplicaciones y necesidades de los usuarios Nuevos m\u00e9todos de programaci\u00f3n Descubrimientos en estudios te\u00f3ricos Necesidad de estandarizaci\u00f3n La siguiente tabla (extra\u00edda del libro Programming Languages. Design and Implementation , de Terrence W. Pratt y Marvin V. Zelkowitz) muestra una peque\u00f1a lista de los lenguajes y las influencias que fueron importante a finales del siglo 20. Evoluci\u00f3n de los lenguajes Los creadores de los LPs Si comprobamos la historia de los lenguajes de programaci\u00f3n, podemos clasificar a sus creadores en tres grandes categor\u00edas: Investigadores trabajando en empresas ( Backus , IBM-FORTRAN, Gosling , Sun-Java) Investigadores en universidades y departamentos de Inform\u00e1tica ( McCarthy , MIT-Lisp, Wirth , ETH-Pascal, Odersky , EHT-Scala) Desarrolladores open source que distribuyen su trabajo a la comunidad ( Wall , Perl, Matsumoto , Ruby) Lenguajes de programaci\u00f3n en la actualidad El \u00edndice TIOBE es un indicador de la popularidad de los lenguajes de programaci\u00f3n. El \u00edndice se actualiza una vez al mes. Las puntaciones se basan en estad\u00edsticas no reveladas que incluyen el n\u00famero de ingenieros en todo el mundo, cursos y aplicaciones desarrolladas. Tambi\u00e9n se utilizan resultados obtenidos en los motores de b\u00fasqueda m\u00e1s usados. El \u00edndice TIOBE no trata de medir el n\u00famero de l\u00edneas escritas en los lenguajes de programaci\u00f3n sino su popularidad e importancia en la comunidad. Lista TIOBE Tambi\u00e9n es muy interesante comprobar la evoluci\u00f3n de los 10 lenguajes m\u00e1s populares en los \u00faltimos 10 a\u00f1os. Evoluci\u00f3n TIOBE La evoluci\u00f3n no se detiene Es interesante comprobar que cada vez es m\u00e1s f\u00e1cil desarrollar nuevos lenguajes de programaci\u00f3n. Las t\u00e9cnicas y herramientas de procesamiento de lenguajes se han popularizado cada vez m\u00e1s y son accesibles a mayor n\u00famero de personas. Los lenguajes ya no s\u00f3lo se crean en departamentos con un gran n\u00famero de investigadores, sino tambi\u00e9n en comunidades open source formadas por voluntarios interesados y motivados Ejemplos de nuevos lenguajes y sus creadores: Ruby Yukihiro Matsumoto Ruby ( Wikipedia ), un lenguaje de programaci\u00f3n ideado en 1993 por el desarrollador japon\u00e9s Yukihiro Matsumoto Lenguaje multi-paradigma interpretado y muy expresivo que actualmente se utiliza tanto para desarrollar aplicaciones web como videojuegos. Proyecto vivo, cada a\u00f1o aparecen nuevas versiones Scala Martin Odersky Scala ( Wikipedia ), dise\u00f1ado en 2003 por el profesor alem\u00e1n Martin Odersky Respuesta a los problemas de los lenguajes tradicionales imperativos para manejar la concurrencia Est\u00e1 implementado sobre Java y corre en la M\u00e1quina Virtual Java Go Ken Thompson Go ( Wikipedia ), el nuevo lenguaje de programaci\u00f3n de Google lanzado en 2009 Desarrollado, entre otros, por Ken Thompson, uno de los padres del UNIX Una mezcla de C y Python que intenta conseguir un lenguaje de programaci\u00f3n de sistemas muy eficiente, expresivo y tambi\u00e9n multiparadigma. Swift Chris Lattner Swift ( Wikipedia ), el nuevo lenguaje de programaci\u00f3n de Apple lanzado en 2014 Proyecto open source en el que se puede observar su evoluci\u00f3n y roadmap futuro Desarrollado, entre otros, por Chris Lattner , autor del sistema LLVM Compiler Infrastructure , conjunto de compilador, depurador, optimizador, etc. de c\u00f3digo C, C++ y Objective-C. Lenguaje moderno, multiparadigma (programaci\u00f3n orientada a objetos y funcional) fuertemente tipeado y compilado. Elementos de los lenguajes de programaci\u00f3n Definici\u00f3n de la Encyclopedia of Computer Science A programming language is a set of characters, rules for combining them, and rules specifying their effects when executed by a computer, which have the following four characteristics: It requires no knowledge of machine code on the part of the user It has machine independence Is translated into machine language Employs a notation that is closer to that of the specific problem being solved than is machine code Definici\u00f3n de Abelson y Sussman We are about to study the idea of a computational process . Computational processes are abstract beings that inhabit computers. As they evolve, processes manipulate other abstract things called data . The evolution of a process is directed by a pattern of rules called a program. [\u2026] The programs we use to conjure processes are like a sorcerer's spells. They are carefully composed from symbolic expressions in arcane and esoteric programming languages that prescribe the tasks we want our processes to perform. Y otra idea fundamental A powerful programming language is more than just a means for instructing a computer to perform tasks. The language also serves as a framework within which we organize our ideas about processes. Thus, when we describe a language, we should pay particular attention to the means that the language provides for combining simple ideas to form more complex ideas. Caracter\u00edsticas de un LP Define un proceso que se ejecuta en un computador Es de alto nivel, cercano a los problemas que se quieren resolver (abstracci\u00f3n) Permite construir nuevas abstracciones que se adapten al dominio que se programa Elementos de un LP Para Abelson y Sussman, todos los lenguajes de progamaci\u00f3n permiten combinar ideas simples en ideas m\u00e1s complejas mediante los siguientes tres mecanismos Expresiones primitivas que representan las entidades m\u00e1s simples del lenguaje Mecanismos de combinaci\u00f3n con los que se construyen elementos compuestos a partir de elementos m\u00e1s simples Mecanismos de abstracci\u00f3n con los que dar nombre a los elementos compuestos y manipularlos como unidades Sintaxis y sem\u00e1ntica Sintaxis : un conjunto de reglas que definen qu\u00e9 expresiones de texto son correctas. Por ejemplo, en C todas las sentencias deben terminar en ';' Los lenguajes de programaci\u00f3n se ejecutan en un computador y tienen una determinada sem\u00e1ntica que define cu\u00e1l ser\u00e1 el resultado de la ejecuci\u00f3n de un programa. Los lenguajes son para las personas Los lenguajes de programaci\u00f3n deben ser precisos, deben poder traducirse sin ambig\u00fcedad en lenguaje m\u00e1quina para que sean ejecutados por computadores. Pero deben ser utilizados (le\u00eddos, comentados, probados, etc.) por personas. La programaci\u00f3n es una actividad colaborativa y debe basarse en la comunicaci\u00f3n. Importancia del aprendizaje de t\u00e9cnicas de LPs Es importante conocer c\u00f3mo funciona \"por dentro\" un lenguaje de programaci\u00f3n y sus caracter\u00edsticas comparadas. Mejora el uso del lenguaje de programaci\u00f3n Incrementa el vocabulario de los elementos de programaci\u00f3n Permite una mejor elecci\u00f3n del lenguaje de programaci\u00f3n Mejora la habilidad para desarrollar programas efectivos y eficientes Facilita el aprendizaje de un nuevo lenguaje de programaci\u00f3n Facilita el dise\u00f1o de nuevos lenguajes de programaci\u00f3n Abstracci\u00f3n Una misi\u00f3n fundamental de los lenguajes de programaci\u00f3n es proporcionar herramientas que sirvan para construir estas abstracciones. Cuando definimos una abstracci\u00f3n le damos un nombre a una entidad del lenguaje (una variable, una funci\u00f3n, una clase, etc.). Escoger un buen nombre para los elementos que vamos construyendo en nuestro programas es fundamental para conseguir un c\u00f3digo legible y reutilizable. Modelar como una actividad fundamental Para escribir un programa que preste unos servicios es fundamental modelar el dominio sobre el que va a trabajar Es necesario definir distintas abstracciones (tanto APIs, como datos) que nos permitan tratar sus elementos y comunicarnos correctamente con los usuarios que van a utilizar el programa. Las abstracciones que vamos construyendo van apoy\u00e1ndose unas en otras y permiten hacer compresible y comunicable un problema complejo Ejemplo: el modelado del funcionamiento de una biblioteca contiene abstracciones como \"libros\", \"pr\u00e9stamo\", \"reserva\", o \"libros disponibles\" que representan conceptos del dominio que deben ser implementados en nuestra soluci\u00f3n Casos de uso biblioteca Abstracciones computacionales Existen abstracciones propias de la inform\u00e1tica ( computer science ), que se utilizan en m\u00faltiples dominios. Por ejemplo, abstracciones de datos como: Listas \u00c1rboles Grafos Tablas hash Tambi\u00e9n existen abstracciones que nos permiten tratar con dispositivos y ordenadores externos: Fichero Raster gr\u00e1fico Protocolo TCP/IP Construcci\u00f3n de abstracciones Uno de los trabajos principales de un inform\u00e1tico es la construcci\u00f3n de abstracciones que permitan ahorrar tiempo y esfuerzo a la hora de tratar con la complejidad del mundo real. Cita de Joel Spolsky en su blog Joel on Software TCP is what computer scientists like to call an abstraction: a simplification of something much more complicated that is going on under the covers. As it turns out, a lot of computer programming consists of building abstractions. What is a string library? It's a way to pretend that computers can manipulate strings just as easily as they can manipulate numbers. What is a file system? It's a way to pretend that a hard drive isn't really a bunch of spinning magnetic platters that can store bits at certain locations, but rather a hierarchical system of folders-within-folders containing individual files that in turn consist of one or more strings of bytes. Distintos aspectos de los lenguajes de programaci\u00f3n La programaci\u00f3n es una disciplina compleja, que tiene que tener en cuenta m\u00faltiples aspectos de los lenguajes de programaci\u00f3n y las API: Programas como procesos runtime que se ejecutan en un computador. Tenemos que entender qu\u00e9 pasa cuando se crea un objeto, cu\u00e1nto tiempo permanece en memoria, cu\u00e1l es el \u00e1mbito de una variable, etc. Herramientas: depuradores, analizadores de rendimiento. Programas como declaraciones est\u00e1ticas. Hay que considerar un programa desde el punto de vista de una declaraci\u00f3n de nuevos tipos, nuevos m\u00e9todos, tipos gen\u00e9ricos, herencia entre clases, etc. Herramientas: entornos de programaci\u00f3n con autocompletado de c\u00f3digo, detecci\u00f3n de errores sint\u00e1cticos. Programas como comunicaci\u00f3n y actividad social. Tenemos que tener en cuenta que un programa va a ser usado por otras personas, le\u00eddo, extendido, mantenido, modificado. Los programas siempre se van a modificar. Herramientas: sistemas de control de versiones (Git, Mercurial, Github, Bitbucket), de gesti\u00f3n incidencias (Jira) , tests que evitan errores de regresi\u00f3n, ... Paradigmas de programaci\u00f3n \u00bfQu\u00e9 es un paradigma de programaci\u00f3n? Un paradigma define un conjunto de caracter\u00edsticas, patrones y estilos de programaci\u00f3n basados en alguna idea fundamental. Por ejemplo el paradigma funcional se basa en la idea que una computaci\u00f3n se puede especificar como un conjunto de funciones que transforman valores de entrada en valores de salida. Es conveniente ver un paradigma como un estilo de programaci\u00f3n que puede usarse en distintos lenguajes de programaci\u00f3n y expresarse con distintas sintaxis. Por ejemplo, se puede escribir c\u00f3digo que use programaci\u00f3n l\u00f3gica en Prolog (ser\u00eda lo m\u00e1s natural), pero tambi\u00e9n en Java, usando alg\u00fan API espec\u00edfica. Normalmente todos los lenguajes tienen caracter\u00edsticas de m\u00e1s de un paradigma. Por motivos pr\u00e1cticos los lenguajes m\u00e1s populares no se limitan de forma estricta o pura a un \u00fanico paradigma de programaci\u00f3n. Por ejemplo, el Prolog es un lenguaje en su mayor parte l\u00f3gico y declarativo, pero tiene operadores imperativos como el corte . A pesar de ello, es normal adscribir un lenguaje al paradigma en el que es m\u00e1s sencillo o natural escribir c\u00f3digo usando sus construcciones. Existen lenguajes que refuerzan y promueven la expresi\u00f3n de c\u00f3digo en m\u00e1s de un paradigma de programaci\u00f3n. Y lo hacen no por necesidad o accidente, sino con el intento expl\u00edcito de fusionar m\u00e1s de un paradigma en una forma \u00fanica de programar. Estos lenguajes se denominan lenguajes multi-paradigma . Por ejemplo, Scala es lenguaje multi-paradigma en el que Martin Odersky, su creador, mezcla caracter\u00edsticas de programaci\u00f3n orientada a objetos con programaci\u00f3n funcional. Prolog o Lisp, aunque tienen caracter\u00edsticas no l\u00f3gicas o no funcionales, no pueden ser considerados multi-paradigma porque no fueron creados con la idea de integrar paradigmas variados en una forma coherente de expresi\u00f3n. Los paradigmas m\u00e1s importantes son: Paradigma funcional Paradigma l\u00f3gico Paradigma imperativo o procedural Paradigma orientado a objetos Paradigma funcional Resumen de las caracter\u00edsticas principales: La computaci\u00f3n se realiza mediante la evaluaci\u00f3n de expresiones Definici\u00f3n de funciones Funciones como datos primitivos Valores sin efectos laterales, no existen referencias a celdas de memoria en las que se guarda un estado modificable Programaci\u00f3n declarativa (en la programaci\u00f3n funcional pura ) Lenguajes: Lisp, Scheme, Haskell, Scala, Clojure. Ejemplo de c\u00f3digo (Lisp): 1 2 3 4 5 6 7 8 9 (define (factorial x) (if (= x 0) 1 (* x (factorial (- x 1))))) (factorial 8) 40320 (factorial 30) 265252859812191058636308480000000 Paradigma l\u00f3gico Caracter\u00edsticas: Definici\u00f3n de reglas Unificaci\u00f3n como elemento de computaci\u00f3n Programaci\u00f3n declarativa Lenguajes: Prolog, Mercury, Oz. Ejemplo de c\u00f3digo (Prolog): 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 padrede ( juan , maria ). % juan es padre de maria padrede ( pablo , juan ). % pablo es padre de juan padrede ( pablo , marcela ). padrede ( carlos , debora ). hijode ( A , B ) :- padrede ( B , A ). abuelode ( A , B ) :- padrede ( A , C ), padrede ( C , B ). hermanode ( A , B ) :- padrede ( C , A ) , padrede ( C , B ), A \\== B . familiarde ( A , B ) :- padrede ( A , B ). familiarde ( A , B ) :- hijode ( A , B ). familiarde ( A , B ) :- hermanode ( A , B ). ?- hermanode ( juan , marcela ). yes ?- hermanode ( carlos , juan ). no ?- abuelode ( pablo , maria ). yes ?- abuelode ( maria , pablo ). no Paradigma imperativo Los lenguajes de programaci\u00f3n que cumplen el paradigma imperativo se caracterizan por tener un estado impl\u00edcito que es modificado mediante instrucciones o comandos del lenguaje. Como resultado, estos lenguajes tienen una noci\u00f3n de secuenciaci\u00f3n de los comandos para permitir un control preciso y determinista del estado. Caracter\u00edsticas: Definici\u00f3n de procedimientos Definici\u00f3n de tipos de datos Chequeo de tipos en tiempo de compilaci\u00f3n Cambio de estado de variables Pasos de ejecuci\u00f3n de un proceso Ejemplo (Pascal): 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 type tDimension = 1 . . 100 ; eMatriz ( f , c : tDimension ) = array [ 1 .. f , 1 .. c ] of real ; tRango = record f , c : tDimension value 1 ; end ; tpMatriz = ^ eMatriz ; procedure EscribirMatriz ( var m : tpMatriz ); var filas , col : integer ; begin for filas := 1 to m ^ . f do begin for col := 1 to m ^ . c do write ( m ^ [ filas , col ] : 7 : 2 ); writeln ( resultado ); writeln ( resultado ) end ; end ; Paradigma orientado a objetos Caracter\u00edsticas: Definici\u00f3n de clases y herencia Objetos como abstracci\u00f3n de datos y procedimientos Polimorfismo y chequeo de tipos en tiempo de ejecuci\u00f3n Ejemplo (Java): 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 public class Bicicleta { public int marcha; public int velocidad; public Bicicleta(int velocidadInicial, int marchaInicial) { marcha = marchaInicial; velocidad = velocidadInicial; } public void setMarcha(int nuevoValor) { marcha = nuevoValor; } public void frenar(int decremento) { velocidad -= decremento; } public void acelerar(int incremento) { velocidad += incremento; } } public class MountainBike extends Bicicleta { public int alturaSillin; public MountainBike(int alturaInicial, int velocidadInicial, int marchaInicial) { super(velocidadInicial, marchaInicial); alturaSillin = alturaInicial; } public void setAltura(int nuevoValor) { alturaSillin = nuevoValor; } } public class Excursion { public static void main(String[] args) { MountainBike miBicicleta = new MoutainBike(10,10,3); miBicicleta.acelerar(10); miBicicleta.setMarcha(4); miBicicleta.frenar(10); } } Compiladores e int\u00e9rpretes En el nivel de abstracci\u00f3n m\u00e1s bajo, la ejecuci\u00f3n de un programa en un computador consiste en la ejecuci\u00f3n de un conjunto de instrucciones del c\u00f3digo m\u00e1quina del procesador. Por ejemplo, la siguiente figura muestra un ejemplo de un programa en ensamblador para un antiguo procesador (el Z80, procesador de 8 bits del m\u00edtico ZX Spectrum , uno de los primeros ordenadores personales en Europa): Ensamblador Z80 Dependiendo del tipo de lenguaje de programaci\u00f3n en el que est\u00e9 escrito este programa, el c\u00f3digo m\u00e1quina que se estar\u00e1 ejecutando ser\u00e1: el resultado de la compilaci\u00f3n del programa original (en el caso de un lenguaje compilado) el c\u00f3digo de un programa (int\u00e9rprete) que realiza la interpretaci\u00f3n del programa original (en el caso de un lenguaje interpretado) Compilaci\u00f3n La siguiente figura (tomada, como las dem\u00e1s de este apartado del Programming Language Pragmatics ) muestra el proceso de generaci\u00f3n y ejecuci\u00f3n de un programa compilado. Compilaci\u00f3n El proceso de compilaci\u00f3n de un programa consiste en la traducci\u00f3n del c\u00f3digo fuente original en el lenguaje de alto nivel al c\u00f3digo m\u00e1quina espec\u00edfico del procesador en el que va a ejecutarse el programa. El c\u00f3digo m\u00e1quina resultante s\u00f3lo corre en el procesador para el que se ha generado. Por ejemplo, un programa C compilado para un procesador Intel no puede ejecutarse en un procesador ARM, como los Ax de Apple . Ejemplos: C, C++ Diferentes momentos en la vida de un programa: tiempo de compilaci\u00f3n y tiempo de ejecuci\u00f3n Mayor eficiencia Interpretaci\u00f3n Interpretaci\u00f3n Ejemplos: BASIC, Lisp, Scheme, Python, Ruby No hay diferencia entre el tiempo de compilaci\u00f3n y el tiempo de ejecuci\u00f3n Mayor flexibilidad: el c\u00f3digo se puede construir y ejecutar \"on the fly\" (funciones lambda o clousures) Los lenguajes interpretados suelen proporcionar un shell o int\u00e9rprete. Se trata de un entorno interactivo en el que podemos definir y evaluar expresiones. Este entorno se denomina en los c\u00edrculos de programaci\u00f3n funcional un REPL ( Read , Eval , Print , Loop ) y ya se utiliz\u00f3 en los primeros a\u00f1os de implementaci\u00f3n del Lisp. El uso del REPL promueve una programaci\u00f3n interactiva en la que continuamente evaluamos y comprobamos el c\u00f3digo que desarrollamos. Enfoques mixtos Existen tambi\u00e9n enfoques mixtos, como el usado por el lenguaje de programaci\u00f3n Java, en el que se realizan ambos procesos. En una primera fase el compilador de Java ( javac ) realiza una traducci\u00f3n del c\u00f3digo fuente original a un c\u00f3digo intermedio binario independiente del procesado, denominado bytecode . Este c\u00f3digo binario es multiplataforma. El c\u00f3digo intermedio es interpretado despu\u00e9s por un el int\u00e9rprete ( java ) que ya s\u00ed que es dependiente de la plataforma. En la figura el int\u00e9rprete se denomina Virtual machine (no confundir con el concepto de m\u00e1quina virtual que permite emular un sistema operativo, por ejemplo VirtualBox). Enfoque mixto (Java) Ejemplos: Java, Scala Bibliograf\u00eda Introducci\u00f3n cap\u00edtulo 1 SICP, Building Abstractions with Procedures Cap\u00edtulo 1.2 PLP, The Programming Language Spectrum Cap\u00edtulo 1.3 PLP, Why Study Programming Languages Cap\u00edtulo 1.4 PLP, Compilation and Interpretation Raul Rojas, \"Konrad Zuse's legacy the architecture of the Z1 and Z3\", IEEE Annals of the History of Computing, Vol. 19, No. 2, 1997 Charles Petzold, \"Code\", Microsoft Press, 2000 (Cap\u00edtulo 18: \"From Abaci to Chips\") Jack Copeland, \"The Modern History of Computing\", The Stanford Encyclopedia of Philosophy (Fall 2008 Edition), URL = http://plato.stanford.edu/archives/fall2008/entries/computing-history/ Georgi Dalakov, \"History of Computers\", URL = http://history-computer.com Lenguajes y Paradigmas de Programaci\u00f3n, curso 2018-19 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Domingo Gallardo, Cristina Pomares, Antonio Bot\u00eda, Francisco Mart\u00ednez","title":"Tema 1: Historia de los lenguajes de programaci\u00f3n"},{"location":"teoria/tema01-historia-lenguajes-programacion/tema01-historia-lenguajes-programacion.html#tema-1-historia-y-conceptos-de-los-lenguajes-de-programacion","text":"","title":"Tema 1: Historia y conceptos de los lenguajes de programaci\u00f3n"},{"location":"teoria/tema01-historia-lenguajes-programacion/tema01-historia-lenguajes-programacion.html#historia-de-los-lenguajes-de-programacion","text":"","title":"Historia de los lenguajes de programaci\u00f3n"},{"location":"teoria/tema01-historia-lenguajes-programacion/tema01-historia-lenguajes-programacion.html#de-las-maquinas-de-calcular-a-los-computadores-programables","text":"M\u00e1quina de Schickard (1623) Calculadora de Pascal (1650) Desde las primeras calculadoras mec\u00e1nicas dise\u00f1adas en el siglo XVII hasta los a\u00f1os 40 del siglo pasado se han inventado multitud de m\u00e1quinas y computadores mec\u00e1nicos, anal\u00f3gicos o electr\u00f3nicos que han intentado acelerar y mejorar la precisi\u00f3n de los c\u00e1lculos. El punto culminante de todos los enfoques mec\u00e1nicos para realizar c\u00e1lculos fue el famoso Motor Anal\u00edtico dise\u00f1ado por Charles Babbage en 1840. La diferencia fundamental con todos los artefactos anteriores es que se trataba de una m\u00e1quina de calcular programable mediante tarjetas perforadas (Babbage se inspir\u00f3 en el telar de Jackquard en el que el dise\u00f1o de los dibujos de las telas se pod\u00edan configurar usando tarjetas perforadas). La m\u00e1quina estaba dise\u00f1ada para trabajar en base 10 y se pod\u00eda conseguir que sus c\u00e1lculos realizaran saltos condicionales y bucles. Babbage trabaj\u00f3 durante m\u00e1s de 30 a\u00f1os para intentar construir la m\u00e1quina. Ten\u00eda una enorme complejidad para la \u00e9poca y necesitaba much\u00edsima financiaci\u00f3n. En 1871 muri\u00f3 habiendo podido construir s\u00f3lo una parte. La matem\u00e1tica Ada Lovelace tuvo un papel fundamental en la divulgaci\u00f3n de la m\u00e1quina, de sus sistema de programaci\u00f3n y fue la primera que entendi\u00f3 sus posibilidades m\u00e1s all\u00e1 del c\u00e1lculo de f\u00f3rmulas. De forma poco habitual para la \u00e9poca, Ada fue educada en el campo de las ciencias y de las matem\u00e1ticas. A principios de 1840, con veinticico a\u00f1os, conoci\u00f3 el trabajo de Babbage y colabor\u00f3 con \u00e9l, dedic\u00e1ndose durante varios a\u00f1os a conocer y estudiar el dise\u00f1o y el funcionamiento del motor anal\u00edtico. En 1843 public\u00f3 el trabajo \"Sketch of the analytical engine invented by Charles Babbage\" en el que describe el Motor Anal\u00edtico, a\u00f1ade reflexiones propias sobre el alcance del invento y construye un ejemplo completo, con tablas y diagramas, de c\u00f3mo hacer que la m\u00e1quina produzca la secuencia de los n\u00fameros de Bernoulli. Se puede considerar estas tablas y diagramas como el primer programa de un computador . Antes de que existiera ning\u00fan computador real, en 1936, el matem\u00e1tico ingl\u00e9s Alan Turing formaliz\u00f3 la idea abstracta de computador, utilizando un modelo muy sencillo de procesamiento: una m\u00e1quina abstracta con un scanner que lee y escribe 0s y 1s de una cinta infinita (memoria) y se mueve y los escribe en funci\u00f3n de una tabla definida en la m\u00e1quina (programa). Con esta m\u00e1quina abstracta ( M\u00e1quina de Turing ) Turing explora la idea de lo computable y lo no computable. \u00bfExisten problemas no computables para los que no es posible inventar un algoritmo que los resuelva? Turing demuestra que s\u00ed y establece con su trabajo los l\u00edmites de la computaci\u00f3n. En el mismo trabajo Turing define el concepto de m\u00e1quina universal que es capaz de leer de la cinta un programa cualquiera y simular su comportamiento en otra parte de la cinta. Esta idea tuvo un profundo impacto en el desarrollo de los computadores, porque mostraba que es posible escribir programas que tomen como datos otros programas. Esto abre la puerta a la idea de los programas almacenados en memoria (ya que son otros datos m\u00e1s) y a la creaci\u00f3n de compiladores e int\u00e9rpretes. En la d\u00e9cada de 1940 hubo una explosi\u00f3n de m\u00e1quinas de computaci\u00f3n electr\u00f3nicas y electromec\u00e1nicas. Fue una d\u00e9cada prodigiosa en la que se desarrollaron tecnolog\u00edas cada vez m\u00e1s r\u00e1pidas y resistentes, y se consiguieron enormes avances en la velocidad y precisi\u00f3n de los c\u00e1lculos. Pero no fue hasta 1945 cuando John Von Neumann , que trabajaba en la construcci\u00f3n del ENIAC , propuso su famosa arquitectura en la que por primera vez se introducen las dos ideas claves de los computadores de prop\u00f3sito general: el programa almacenado en memoria y un conjunto de instrucciones de procesamiento que incluye el direccionamiento indirecto. Y en 1948, tres a\u00f1os despu\u00e9s, se construy\u00f3 en la universidad de Manchester el primer computador electr\u00f3nico digital de prop\u00f3sito general que utilizaba esta arquitectura (llamado Baby ). Fue dise\u00f1ado por Max Newmann usando la tecnolog\u00eda proporcionada por los ingenieros F.C. Williams y Tom Kilburn. Williams hab\u00eda inventado un dispositivo de memoria electr\u00f3nico (la v\u00e1lvula de Williams ) capaz de sustituir las lentas l\u00edneas de retardo de mercurio utilizadas hasta ese momento. La m\u00e1quina de Manchester fue el primer computador con un conjunto de instrucciones completo, capaz de realizar saltos, condicionales y direccionamiento indirecto. La primera ejecuci\u00f3n de un programa fue el 21 de junio de 1948. En esa fecha Alan Turing se incorpor\u00f3 a la universidad de Manchester, como director del Laboratorio de Computaci\u00f3n. Tres a\u00f1os despu\u00e9s, con un dise\u00f1o ampliado en el que tambi\u00e9n influy\u00f3 Turing, una versi\u00f3n mucho mayor de la m\u00e1quina se convirti\u00f3 en el primer computador disponible comercialmente, el Ferranti Mark I. El primero se instal\u00f3 en la universidad de Manchester en febrero de 1951, un mes antes que el UNIVAC I fuera entregado al Departamento de Censo de los EEUU. Se vendieron otras 10 m\u00e1quinas a Gran Breta\u00f1a, Canad\u00e1, Holanda e Italia. El primer programa complejo de Inteligencia Artificial, un jugador de damas escrito por Christopher Strachey, se ejecut\u00f3 en el verano de 1952 en el Ferranti Mark I en el Laboratorio de Computaci\u00f3n de Manchester. Strachey escribi\u00f3 el programa animado por Turing y usando el manual de programaci\u00f3n del Ferranti que Turing acababa de escribir. Turing particip\u00f3 tambi\u00e9n en el desarrollo de otros programas de IA, como un jugador de ajedrez basado en heur\u00edsticas.","title":"De las m\u00e1quinas de calcular a los computadores programables"},{"location":"teoria/tema01-historia-lenguajes-programacion/tema01-historia-lenguajes-programacion.html#los-primeros-lenguajes-de-programacion","text":"Los primeros computadores electr\u00f3nicos se programan directamente usando el conjunto de instrucciones del procesador, en c\u00f3digo m\u00e1quina, c\u00f3digo hexadecimal El primer lenguaje de un nivel algo m\u00e1s elevado que el c\u00f3digo m\u00e1quina es el ensamblador. Programas que empiezan a ayudar a los programadores: ensambladores. Hay una relaci\u00f3n casi directa entre la notaci\u00f3n en ensamblador y el c\u00f3digo hexadecimal que produce el ensamblador. A finales de la d\u00e9cada de los 40 se empiezan a intentar resolver con los primeros computadores los primeros problemas matem\u00e1ticos distintos de operaciones num\u00e9ricas: codificaci\u00f3n y descodificaci\u00f3n, problemas combinatorios como el coloreado del mapa o problemas de ordenaci\u00f3n. Uno de los primeros algoritmos de von Neumann realiza una ordenaci\u00f3n de un conjunto de n\u00fameros. Von Neumann lo describe en una carta fechada en 1945. Utiliza el conjunto de instrucciones del EDSAC cuando todav\u00eda no se hab\u00eda construido. El programa fue estudiado por Donald Knuth en el art\u00edculo Von Neumann's first Computer Program , en donde documenta que hab\u00eda un bug en las primeras instrucciones. Es el primer bug escrito del que se tiene historia. Si Von Neumann hubiera podido ejecutar el programa en el EDSAC se hubiera dado cuenta del error y hubiera sido la primera depuraci\u00f3n de un programa. Primer programa de Von Neumann (Donald Knuth, \"Von Neumann's first Computer Program\", Journal of the ACM Computing Surveys (CSUR) Surveys, Volume 2 Issue 4, Dec. 1970, Pages 247-260)","title":"Los primeros lenguajes de programaci\u00f3n"},{"location":"teoria/tema01-historia-lenguajes-programacion/tema01-historia-lenguajes-programacion.html#el-nacimiento-de-los-computadores-comerciales","text":"El UNIVAC fue el primer computador comercial (1951). Con este computadora aparece por primera vez la figura del programador: manuales, cursos de formaci\u00f3n, ofertas de empleo, etc. UNIVAC Instalaciones comerciales del UNIVAC","title":"El nacimiento de los computadores comerciales"},{"location":"teoria/tema01-historia-lenguajes-programacion/tema01-historia-lenguajes-programacion.html#los-primeros-lenguajes-de-alto-nivel","text":"Los primeros lenguajes de alto nivel se desarrollaron a finales de la d\u00e9cada de los 50: FORTRAN en 1956 Lisp en 1958 Ambos lenguajes planteaban dos enfoques muy distintos desde el principio: FORTRAN Primer lenguaje comercial, equipo de IBM dirigido por John W. Backus Lenguaje imperativo: estado, estructuras de control, contador de programa, celdas de memoria Lenguaje compilado Lisp Lenguaje dise\u00f1ado en un departamento de investigaci\u00f3n, un equipo del MIT dirigido por John McCarthy Lenguaje funcional: funciones, recursi\u00f3n, listas, s\u00edmbolos Lenguaje interpretado","title":"Los primeros lenguajes de alto nivel"},{"location":"teoria/tema01-historia-lenguajes-programacion/tema01-historia-lenguajes-programacion.html#la-explosion-de-los-lenguajes-de-programacion","text":"Desde 1954 hasta la actualidad se han documentado m\u00e1s de 2.500 (consultar en The Language List ). Entre 1952 y 1972 alrededor de 200 lenguajes. Una decena fueron realmente siginificativos y tuvieron influencia en el desarrollo de lenguajes posteriores.","title":"La explosi\u00f3n de los lenguajes de programaci\u00f3n"},{"location":"teoria/tema01-historia-lenguajes-programacion/tema01-historia-lenguajes-programacion.html#lenguajes-de-programacion-en-la-actualidad","text":"El \u00edndice TIOBE es un indicador de la popularidad de los lenguajes de programaci\u00f3n. El \u00edndice se actualiza una vez al mes. Las puntaciones se basan en estad\u00edsticas no reveladas que incluyen el n\u00famero de ingenieros en todo el mundo, cursos y aplicaciones desarrolladas. Tambi\u00e9n se utilizan resultados obtenidos en los motores de b\u00fasqueda m\u00e1s usados. El \u00edndice TIOBE no trata de medir el n\u00famero de l\u00edneas escritas en los lenguajes de programaci\u00f3n sino su popularidad e importancia en la comunidad. Lista TIOBE Tambi\u00e9n es muy interesante comprobar la evoluci\u00f3n de los 10 lenguajes m\u00e1s populares en los \u00faltimos 10 a\u00f1os. Evoluci\u00f3n TIOBE","title":"Lenguajes de programaci\u00f3n en la actualidad"},{"location":"teoria/tema01-historia-lenguajes-programacion/tema01-historia-lenguajes-programacion.html#elementos-de-los-lenguajes-de-programacion","text":"","title":"Elementos de los lenguajes de programaci\u00f3n"},{"location":"teoria/tema01-historia-lenguajes-programacion/tema01-historia-lenguajes-programacion.html#definicion-de-la-encyclopedia-of-computer-science","text":"A programming language is a set of characters, rules for combining them, and rules specifying their effects when executed by a computer, which have the following four characteristics: It requires no knowledge of machine code on the part of the user It has machine independence Is translated into machine language Employs a notation that is closer to that of the specific problem being solved than is machine code","title":"Definici\u00f3n de la Encyclopedia of Computer Science"},{"location":"teoria/tema01-historia-lenguajes-programacion/tema01-historia-lenguajes-programacion.html#definicion-de-abelson-y-sussman","text":"We are about to study the idea of a computational process . Computational processes are abstract beings that inhabit computers. As they evolve, processes manipulate other abstract things called data . The evolution of a process is directed by a pattern of rules called a program. [\u2026] The programs we use to conjure processes are like a sorcerer's spells. They are carefully composed from symbolic expressions in arcane and esoteric programming languages that prescribe the tasks we want our processes to perform. Y otra idea fundamental A powerful programming language is more than just a means for instructing a computer to perform tasks. The language also serves as a framework within which we organize our ideas about processes. Thus, when we describe a language, we should pay particular attention to the means that the language provides for combining simple ideas to form more complex ideas.","title":"Definici\u00f3n de Abelson y Sussman"},{"location":"teoria/tema01-historia-lenguajes-programacion/tema01-historia-lenguajes-programacion.html#caracteristicas-de-un-lp","text":"Define un proceso que se ejecuta en un computador Es de alto nivel, cercano a los problemas que se quieren resolver (abstracci\u00f3n) Permite construir nuevas abstracciones que se adapten al dominio que se programa","title":"Caracter\u00edsticas de un LP"},{"location":"teoria/tema01-historia-lenguajes-programacion/tema01-historia-lenguajes-programacion.html#elementos-de-un-lp","text":"Para Abelson y Sussman, todos los lenguajes de progamaci\u00f3n permiten combinar ideas simples en ideas m\u00e1s complejas mediante los siguientes tres mecanismos Expresiones primitivas que representan las entidades m\u00e1s simples del lenguaje Mecanismos de combinaci\u00f3n con los que se construyen elementos compuestos a partir de elementos m\u00e1s simples Mecanismos de abstracci\u00f3n con los que dar nombre a los elementos compuestos y manipularlos como unidades","title":"Elementos de un LP"},{"location":"teoria/tema01-historia-lenguajes-programacion/tema01-historia-lenguajes-programacion.html#sintaxis-y-semantica","text":"Sintaxis : un conjunto de reglas que definen qu\u00e9 expresiones de texto son correctas. Por ejemplo, en C todas las sentencias deben terminar en ';' Los lenguajes de programaci\u00f3n se ejecutan en un computador y tienen una determinada sem\u00e1ntica que define cu\u00e1l ser\u00e1 el resultado de la ejecuci\u00f3n de un programa.","title":"Sintaxis y sem\u00e1ntica"},{"location":"teoria/tema01-historia-lenguajes-programacion/tema01-historia-lenguajes-programacion.html#los-lenguajes-son-para-las-personas","text":"Los lenguajes de programaci\u00f3n deben ser precisos, deben poder traducirse sin ambig\u00fcedad en lenguaje m\u00e1quina para que sean ejecutados por computadores. Pero deben ser utilizados (le\u00eddos, comentados, probados, etc.) por personas. La programaci\u00f3n es una actividad colaborativa y debe basarse en la comunicaci\u00f3n.","title":"Los lenguajes son para las personas"},{"location":"teoria/tema01-historia-lenguajes-programacion/tema01-historia-lenguajes-programacion.html#importancia-del-aprendizaje-de-tecnicas-de-lps","text":"Es importante conocer c\u00f3mo funciona \"por dentro\" un lenguaje de programaci\u00f3n y sus caracter\u00edsticas comparadas. Mejora el uso del lenguaje de programaci\u00f3n Incrementa el vocabulario de los elementos de programaci\u00f3n Permite una mejor elecci\u00f3n del lenguaje de programaci\u00f3n Mejora la habilidad para desarrollar programas efectivos y eficientes Facilita el aprendizaje de un nuevo lenguaje de programaci\u00f3n Facilita el dise\u00f1o de nuevos lenguajes de programaci\u00f3n","title":"Importancia del aprendizaje de t\u00e9cnicas de LPs"},{"location":"teoria/tema01-historia-lenguajes-programacion/tema01-historia-lenguajes-programacion.html#abstraccion","text":"Una misi\u00f3n fundamental de los lenguajes de programaci\u00f3n es proporcionar herramientas que sirvan para construir estas abstracciones. Cuando definimos una abstracci\u00f3n le damos un nombre a una entidad del lenguaje (una variable, una funci\u00f3n, una clase, etc.). Escoger un buen nombre para los elementos que vamos construyendo en nuestro programas es fundamental para conseguir un c\u00f3digo legible y reutilizable.","title":"Abstracci\u00f3n"},{"location":"teoria/tema01-historia-lenguajes-programacion/tema01-historia-lenguajes-programacion.html#modelar-como-una-actividad-fundamental","text":"Para escribir un programa que preste unos servicios es fundamental modelar el dominio sobre el que va a trabajar Es necesario definir distintas abstracciones (tanto APIs, como datos) que nos permitan tratar sus elementos y comunicarnos correctamente con los usuarios que van a utilizar el programa. Las abstracciones que vamos construyendo van apoy\u00e1ndose unas en otras y permiten hacer compresible y comunicable un problema complejo Ejemplo: el modelado del funcionamiento de una biblioteca contiene abstracciones como \"libros\", \"pr\u00e9stamo\", \"reserva\", o \"libros disponibles\" que representan conceptos del dominio que deben ser implementados en nuestra soluci\u00f3n Casos de uso biblioteca","title":"Modelar como una actividad fundamental"},{"location":"teoria/tema01-historia-lenguajes-programacion/tema01-historia-lenguajes-programacion.html#abstracciones-computacionales","text":"Existen abstracciones propias de la inform\u00e1tica ( computer science ), que se utilizan en m\u00faltiples dominios. Por ejemplo, abstracciones de datos como: Listas \u00c1rboles Grafos Tablas hash Tambi\u00e9n existen abstracciones que nos permiten tratar con dispositivos y ordenadores externos: Fichero Raster gr\u00e1fico Protocolo TCP/IP","title":"Abstracciones computacionales"},{"location":"teoria/tema01-historia-lenguajes-programacion/tema01-historia-lenguajes-programacion.html#construccion-de-abstracciones","text":"Uno de los trabajos principales de un inform\u00e1tico es la construcci\u00f3n de abstracciones que permitan ahorrar tiempo y esfuerzo a la hora de tratar con la complejidad del mundo real. Cita de Joel Spolsky en su blog Joel on Software TCP is what computer scientists like to call an abstraction: a simplification of something much more complicated that is going on under the covers. As it turns out, a lot of computer programming consists of building abstractions. What is a string library? It's a way to pretend that computers can manipulate strings just as easily as they can manipulate numbers. What is a file system? It's a way to pretend that a hard drive isn't really a bunch of spinning magnetic platters that can store bits at certain locations, but rather a hierarchical system of folders-within-folders containing individual files that in turn consist of one or more strings of bytes.","title":"Construcci\u00f3n de abstracciones"},{"location":"teoria/tema01-historia-lenguajes-programacion/tema01-historia-lenguajes-programacion.html#distintos-aspectos-de-los-lenguajes-de-programacion","text":"La programaci\u00f3n es una disciplina compleja, que tiene que tener en cuenta m\u00faltiples aspectos de los lenguajes de programaci\u00f3n y las API: Programas como procesos runtime que se ejecutan en un computador. Tenemos que entender qu\u00e9 pasa cuando se crea un objeto, cu\u00e1nto tiempo permanece en memoria, cu\u00e1l es el \u00e1mbito de una variable, etc. Herramientas: depuradores, analizadores de rendimiento. Programas como declaraciones est\u00e1ticas. Hay que considerar un programa desde el punto de vista de una declaraci\u00f3n de nuevos tipos, nuevos m\u00e9todos, tipos gen\u00e9ricos, herencia entre clases, etc. Herramientas: entornos de programaci\u00f3n con autocompletado de c\u00f3digo, detecci\u00f3n de errores sint\u00e1cticos. Programas como comunicaci\u00f3n y actividad social. Tenemos que tener en cuenta que un programa va a ser usado por otras personas, le\u00eddo, extendido, mantenido, modificado. Los programas siempre se van a modificar. Herramientas: sistemas de control de versiones (Git, Mercurial, Github, Bitbucket), de gesti\u00f3n incidencias (Jira) , tests que evitan errores de regresi\u00f3n, ...","title":"Distintos aspectos de los lenguajes de programaci\u00f3n"},{"location":"teoria/tema01-historia-lenguajes-programacion/tema01-historia-lenguajes-programacion.html#paradigmas-de-programacion","text":"","title":"Paradigmas de programaci\u00f3n"},{"location":"teoria/tema01-historia-lenguajes-programacion/tema01-historia-lenguajes-programacion.html#que-es-un-paradigma-de-programacion","text":"Un paradigma define un conjunto de caracter\u00edsticas, patrones y estilos de programaci\u00f3n basados en alguna idea fundamental. Por ejemplo el paradigma funcional se basa en la idea que una computaci\u00f3n se puede especificar como un conjunto de funciones que transforman valores de entrada en valores de salida. Es conveniente ver un paradigma como un estilo de programaci\u00f3n que puede usarse en distintos lenguajes de programaci\u00f3n y expresarse con distintas sintaxis. Por ejemplo, se puede escribir c\u00f3digo que use programaci\u00f3n l\u00f3gica en Prolog (ser\u00eda lo m\u00e1s natural), pero tambi\u00e9n en Java, usando alg\u00fan API espec\u00edfica. Normalmente todos los lenguajes tienen caracter\u00edsticas de m\u00e1s de un paradigma. Por motivos pr\u00e1cticos los lenguajes m\u00e1s populares no se limitan de forma estricta o pura a un \u00fanico paradigma de programaci\u00f3n. Por ejemplo, el Prolog es un lenguaje en su mayor parte l\u00f3gico y declarativo, pero tiene operadores imperativos como el corte . A pesar de ello, es normal adscribir un lenguaje al paradigma en el que es m\u00e1s sencillo o natural escribir c\u00f3digo usando sus construcciones. Existen lenguajes que refuerzan y promueven la expresi\u00f3n de c\u00f3digo en m\u00e1s de un paradigma de programaci\u00f3n. Y lo hacen no por necesidad o accidente, sino con el intento expl\u00edcito de fusionar m\u00e1s de un paradigma en una forma \u00fanica de programar. Estos lenguajes se denominan lenguajes multi-paradigma . Por ejemplo, Scala es lenguaje multi-paradigma en el que Martin Odersky, su creador, mezcla caracter\u00edsticas de programaci\u00f3n orientada a objetos con programaci\u00f3n funcional. Prolog o Lisp, aunque tienen caracter\u00edsticas no l\u00f3gicas o no funcionales, no pueden ser considerados multi-paradigma porque no fueron creados con la idea de integrar paradigmas variados en una forma coherente de expresi\u00f3n. Los paradigmas m\u00e1s importantes son: Paradigma funcional Paradigma l\u00f3gico Paradigma imperativo o procedural Paradigma orientado a objetos","title":"\u00bfQu\u00e9 es un paradigma de programaci\u00f3n?"},{"location":"teoria/tema01-historia-lenguajes-programacion/tema01-historia-lenguajes-programacion.html#paradigma-funcional","text":"Resumen de las caracter\u00edsticas principales: La computaci\u00f3n se realiza mediante la evaluaci\u00f3n de expresiones Definici\u00f3n de funciones Funciones como datos primitivos Valores sin efectos laterales, no existen referencias a celdas de memoria en las que se guarda un estado modificable Programaci\u00f3n declarativa (en la programaci\u00f3n funcional pura ) Lenguajes: Lisp, Scheme, Haskell, Scala, Clojure. Ejemplo de c\u00f3digo (Lisp): 1 2 3 4 5 6 7 8 9 (define (factorial x) (if (= x 0) 1 (* x (factorial (- x 1))))) (factorial 8) 40320 (factorial 30) 265252859812191058636308480000000","title":"Paradigma funcional"},{"location":"teoria/tema01-historia-lenguajes-programacion/tema01-historia-lenguajes-programacion.html#paradigma-logico","text":"Caracter\u00edsticas: Definici\u00f3n de reglas Unificaci\u00f3n como elemento de computaci\u00f3n Programaci\u00f3n declarativa Lenguajes: Prolog, Mercury, Oz. Ejemplo de c\u00f3digo (Prolog): 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 padrede ( juan , maria ). % juan es padre de maria padrede ( pablo , juan ). % pablo es padre de juan padrede ( pablo , marcela ). padrede ( carlos , debora ). hijode ( A , B ) :- padrede ( B , A ). abuelode ( A , B ) :- padrede ( A , C ), padrede ( C , B ). hermanode ( A , B ) :- padrede ( C , A ) , padrede ( C , B ), A \\== B . familiarde ( A , B ) :- padrede ( A , B ). familiarde ( A , B ) :- hijode ( A , B ). familiarde ( A , B ) :- hermanode ( A , B ). ?- hermanode ( juan , marcela ). yes ?- hermanode ( carlos , juan ). no ?- abuelode ( pablo , maria ). yes ?- abuelode ( maria , pablo ). no","title":"Paradigma l\u00f3gico"},{"location":"teoria/tema01-historia-lenguajes-programacion/tema01-historia-lenguajes-programacion.html#paradigma-imperativo","text":"Los lenguajes de programaci\u00f3n que cumplen el paradigma imperativo se caracterizan por tener un estado impl\u00edcito que es modificado mediante instrucciones o comandos del lenguaje. Como resultado, estos lenguajes tienen una noci\u00f3n de secuenciaci\u00f3n de los comandos para permitir un control preciso y determinista del estado. Caracter\u00edsticas: Definici\u00f3n de procedimientos Definici\u00f3n de tipos de datos Chequeo de tipos en tiempo de compilaci\u00f3n Cambio de estado de variables Pasos de ejecuci\u00f3n de un proceso Ejemplo (Pascal): 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 type tDimension = 1 . . 100 ; eMatriz ( f , c : tDimension ) = array [ 1 .. f , 1 .. c ] of real ; tRango = record f , c : tDimension value 1 ; end ; tpMatriz = ^ eMatriz ; procedure EscribirMatriz ( var m : tpMatriz ); var filas , col : integer ; begin for filas := 1 to m ^ . f do begin for col := 1 to m ^ . c do write ( m ^ [ filas , col ] : 7 : 2 ); writeln ( resultado ); writeln ( resultado ) end ; end ;","title":"Paradigma imperativo"},{"location":"teoria/tema01-historia-lenguajes-programacion/tema01-historia-lenguajes-programacion.html#paradigma-orientado-a-objetos","text":"Caracter\u00edsticas: Definici\u00f3n de clases y herencia Objetos como abstracci\u00f3n de datos y procedimientos Polimorfismo y chequeo de tipos en tiempo de ejecuci\u00f3n Ejemplo (Java): 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 public class Bicicleta { public int marcha; public int velocidad; public Bicicleta(int velocidadInicial, int marchaInicial) { marcha = marchaInicial; velocidad = velocidadInicial; } public void setMarcha(int nuevoValor) { marcha = nuevoValor; } public void frenar(int decremento) { velocidad -= decremento; } public void acelerar(int incremento) { velocidad += incremento; } } public class MountainBike extends Bicicleta { public int alturaSillin; public MountainBike(int alturaInicial, int velocidadInicial, int marchaInicial) { super(velocidadInicial, marchaInicial); alturaSillin = alturaInicial; } public void setAltura(int nuevoValor) { alturaSillin = nuevoValor; } } public class Excursion { public static void main(String[] args) { MountainBike miBicicleta = new MoutainBike(10,10,3); miBicicleta.acelerar(10); miBicicleta.setMarcha(4); miBicicleta.frenar(10); } }","title":"Paradigma orientado a objetos"},{"location":"teoria/tema01-historia-lenguajes-programacion/tema01-historia-lenguajes-programacion.html#compiladores-e-interpretes","text":"En el nivel de abstracci\u00f3n m\u00e1s bajo, la ejecuci\u00f3n de un programa en un computador consiste en la ejecuci\u00f3n de un conjunto de instrucciones del c\u00f3digo m\u00e1quina del procesador. Por ejemplo, la siguiente figura muestra un ejemplo de un programa en ensamblador para un antiguo procesador (el Z80, procesador de 8 bits del m\u00edtico ZX Spectrum , uno de los primeros ordenadores personales en Europa): Ensamblador Z80 Dependiendo del tipo de lenguaje de programaci\u00f3n en el que est\u00e9 escrito este programa, el c\u00f3digo m\u00e1quina que se estar\u00e1 ejecutando ser\u00e1: el resultado de la compilaci\u00f3n del programa original (en el caso de un lenguaje compilado) el c\u00f3digo de un programa (int\u00e9rprete) que realiza la interpretaci\u00f3n del programa original (en el caso de un lenguaje interpretado)","title":"Compiladores e int\u00e9rpretes"},{"location":"teoria/tema01-historia-lenguajes-programacion/tema01-historia-lenguajes-programacion.html#compilacion","text":"La siguiente figura (tomada, como las dem\u00e1s de este apartado del Programming Language Pragmatics ) muestra el proceso de generaci\u00f3n y ejecuci\u00f3n de un programa compilado. Compilaci\u00f3n El proceso de compilaci\u00f3n de un programa consiste en la traducci\u00f3n del c\u00f3digo fuente original en el lenguaje de alto nivel al c\u00f3digo m\u00e1quina espec\u00edfico del procesador en el que va a ejecutarse el programa. El c\u00f3digo m\u00e1quina resultante s\u00f3lo corre en el procesador para el que se ha generado. Por ejemplo, un programa C compilado para un procesador Intel no puede ejecutarse en un procesador ARM, como los Ax de Apple . Ejemplos: C, C++ Diferentes momentos en la vida de un programa: tiempo de compilaci\u00f3n y tiempo de ejecuci\u00f3n Mayor eficiencia","title":"Compilaci\u00f3n"},{"location":"teoria/tema01-historia-lenguajes-programacion/tema01-historia-lenguajes-programacion.html#interpretacion","text":"Interpretaci\u00f3n Ejemplos: BASIC, Lisp, Scheme, Python, Ruby No hay diferencia entre el tiempo de compilaci\u00f3n y el tiempo de ejecuci\u00f3n Mayor flexibilidad: el c\u00f3digo se puede construir y ejecutar \"on the fly\" (funciones lambda o clousures) Los lenguajes interpretados suelen proporcionar un shell o int\u00e9rprete. Se trata de un entorno interactivo en el que podemos definir y evaluar expresiones. Este entorno se denomina en los c\u00edrculos de programaci\u00f3n funcional un REPL ( Read , Eval , Print , Loop ) y ya se utiliz\u00f3 en los primeros a\u00f1os de implementaci\u00f3n del Lisp. El uso del REPL promueve una programaci\u00f3n interactiva en la que continuamente evaluamos y comprobamos el c\u00f3digo que desarrollamos.","title":"Interpretaci\u00f3n"},{"location":"teoria/tema01-historia-lenguajes-programacion/tema01-historia-lenguajes-programacion.html#enfoques-mixtos","text":"Existen tambi\u00e9n enfoques mixtos, como el usado por el lenguaje de programaci\u00f3n Java, en el que se realizan ambos procesos. En una primera fase el compilador de Java ( javac ) realiza una traducci\u00f3n del c\u00f3digo fuente original a un c\u00f3digo intermedio binario independiente del procesado, denominado bytecode . Este c\u00f3digo binario es multiplataforma. El c\u00f3digo intermedio es interpretado despu\u00e9s por un el int\u00e9rprete ( java ) que ya s\u00ed que es dependiente de la plataforma. En la figura el int\u00e9rprete se denomina Virtual machine (no confundir con el concepto de m\u00e1quina virtual que permite emular un sistema operativo, por ejemplo VirtualBox). Enfoque mixto (Java) Ejemplos: Java, Scala","title":"Enfoques mixtos"},{"location":"teoria/tema01-historia-lenguajes-programacion/tema01-historia-lenguajes-programacion.html#bibliografia","text":"Introducci\u00f3n cap\u00edtulo 1 SICP, Building Abstractions with Procedures Cap\u00edtulo 1.2 PLP, The Programming Language Spectrum Cap\u00edtulo 1.3 PLP, Why Study Programming Languages Cap\u00edtulo 1.4 PLP, Compilation and Interpretation Raul Rojas, \"Konrad Zuse's legacy the architecture of the Z1 and Z3\", IEEE Annals of the History of Computing, Vol. 19, No. 2, 1997 Charles Petzold, \"Code\", Microsoft Press, 2000 (Cap\u00edtulo 18: \"From Abaci to Chips\") Jack Copeland, \"The Modern History of Computing\", The Stanford Encyclopedia of Philosophy (Fall 2008 Edition), URL = http://plato.stanford.edu/archives/fall2008/entries/computing-history/ Georgi Dalakov, \"History of Computers\", URL = http://history-computer.com Lenguajes y Paradigmas de Programaci\u00f3n, curso 2018-19 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Domingo Gallardo, Cristina Pomares, Antonio Bot\u00eda, Francisco Mart\u00ednez","title":"Bibliograf\u00eda"},{"location":"teoria/tema02-programacion-funcional/tema02-programacion-funcional.html","text":"Tema 2: Programaci\u00f3n funcional El paradigma de Programaci\u00f3n Funcional Pasado y presente del paradigma funcional Definici\u00f3n y caracter\u00edsticas En una definici\u00f3n muy breve y concisa la programaci\u00f3n funcional define un programa como: Un conjunto de funciones matem\u00e1ticas que convierten unas entradas en unas salidas, sin ning\u00fan estado interno y ning\u00fan efecto lateral. Hablaremos m\u00e1s adelante de la no existencia de estado interno (variables en las que se guardan y se modifican valores) y de la ausencia de efectos laterales. Avancemos que estas son tambi\u00e9n caracter\u00edsticas de la programaci\u00f3n declarativa . En este sentido, la programaci\u00f3n funcional es un tipo concreto de programaci\u00f3n declarativa. Las caracter\u00edsticas principales del paradigma funcional son: Definiciones de funciones matem\u00e1ticas puras, sin estado interno ni efectos laterales Valores inmutables Uso profuso de la recursi\u00f3n en la definici\u00f3n de las funciones Uso de listas como estructuras de datos fundamentales Funciones como tipos de datos primitivos: expresiones lambda y funciones de orden superior Explicaremos estas propiedades a continuaci\u00f3n. Or\u00edgenes hist\u00f3ricos En los a\u00f1os 30, junto con la m\u00e1quina de Turing, se propusieron distintos modelos computacionales que formalizaban el concepto de algoritmo . Uno de estos modelos fue el denominado C\u00e1lculo lambda propuesto por Alonzo Church en los a\u00f1os 30 y basado en la evaluaci\u00f3n de expresiones matem\u00e1ticas. En este formalismo se expresan los algoritmos mediante funciones matem\u00e1ticas en las que puede ser usada la recursi\u00f3n. Una funci\u00f3n matem\u00e1tica recibe par\u00e1metros de entrada y devuelve un valor. La evaluaci\u00f3n de la funci\u00f3n se realiza evaluando sus expresiones matem\u00e1ticas mediante la sustituci\u00f3n de los par\u00e1metros formales por los valores reales que se utilizan en la invocaci\u00f3n. Turing demostr\u00f3 que este modelo matem\u00e1tico era equivalente al su m\u00e1quina, demostrando que es posible construir una maquina equivalente a cualquier funci\u00f3n lambda existente, una m\u00e1quina que devuelva exactamente los mismos resultados que la funci\u00f3n lambda. El hecho de que ambos modelos computacionales sean equivalentes significa que cualquier cualquier algoritmo que podamos definir con una m\u00e1quina de Turing, puede ser definido tambi\u00e9n con una funci\u00f3n del c\u00e1lculo lambda. Y viceversa: cualquier funci\u00f3n definida con el c\u00e1lculo lambda puede ser implementada por alguna m\u00e1quina de Turing. El c\u00e1lculo lambda es un formalismo matem\u00e1tico, basado en operaciones abstractas. Dos d\u00e9cadas despu\u00e9s, cuando los primeros computadores electr\u00f3nicos estaban empezando a utilizarse en grandes empresas y en universidades, este formalismo dio origen a algo mucho m\u00e1s tangible y pr\u00e1ctico: un lenguaje de alto nivel, mucho m\u00e1s expresivo que el ensamblador, con el que expresar operaciones y funciones que pueden ser definidas y evaluadas en el computador . Historia y caracter\u00edsticas del Lisp Lisp es el primer lenguaje de programaci\u00f3n de alto nivel basado en el paradigma funcional. Creado en 1958 por John McCarthy. Lisp fue en su \u00e9poca un lenguaje revolucionario que introdujo nuevos conceptos de programaci\u00f3n no existentes entonces: funciones como objetos primitivos, funciones de orden superior, polimorfismo, listas, recursi\u00f3n, s\u00edmbolos, homogeneidad de datos y programas, bucle REPL ( Read-Eval-Print Loop ) La herencia del Lisp llega a lenguajes derivados de \u00e9l (Scheme, Golden Common Lisp) y a nuevos lenguajes de paradigmas no estrictamente funcionales, como C#, Python, Ruby, Objective-C o Scala. Lisp fue el primer lenguaje de programaci\u00f3n interpretado, con muchas caracter\u00edsticas din\u00e1micas que se ejecutan en tiempo de ejecuci\u00f3n ( run-time ). Entre estas caracter\u00edsticas podemos destacar la gesti\u00f3n de la memoria (creaci\u00f3n y destrucci\u00f3n autom\u00e1tica de memoria reservada para datos), la detecci\u00f3n de excepciones y errores en tiempo de ejecuci\u00f3n o la creaci\u00f3n en tiempo de ejecuci\u00f3n de funciones an\u00f3nimas (expresiones lambda ). Todas estas caracter\u00edsticas se ejecutan mediante un sistema de tiempo de ejecuci\u00f3n ( rutime system ) presente en la ejecuci\u00f3n de los programas. A partir del Lisp muchos otros lenguajes han usado estas caracter\u00edsticas de interpretaci\u00f3n o de sistemas de tiempo de ejecuci\u00f3n. Por ejemplo, lenguajes como BASIC, Python, Ruby o JavaScript son lenguajes interpretados. Y lenguajes como Java o C# tienen una avanzada plataforma de tiempo de ejecuci\u00f3n con soporte para la gesti\u00f3n de la memoria din\u00e1mica ( recolecci\u00f3n de basura , garbage collection ) o la compilaci\u00f3n just in time . Lisp no es un lenguaje exclusivamente funcional. Lisp se dise\u00f1\u00f3 con el objetivo de ser un lenguaje de alto nivel capaz de resolver problemas pr\u00e1cticos de Inteligencia Artificial, no con la idea de ser un lenguaje formal basado un \u00fanico modelo de computaci\u00f3n. Por ello en Lisp (y en Scheme) existen primitivas que se salen del paradigma funcional puro y permiten programar de formar imperativa (no declarativa), usando mutaci\u00f3n de estado y pasos de ejecuci\u00f3n. Sin embargo, durante la primera parte de la asignatura en la que estudiaremos la programaci\u00f3n funcional, no utilizaremos las instrucciones imperativas de Scheme sino que escribiremos c\u00f3digo exclusivamente funcional. Lenguajes de programaci\u00f3n funcional En los a\u00f1os 60 la programaci\u00f3n funcional definida por el Lisp fue dominante en departamentos de investigaci\u00f3n en Inteligencia Artificial (MIT por ejemplo). En los a\u00f1os 70, 80 y 90 se fue relegando cada vez m\u00e1s a los nichos acad\u00e9micos y de investigaci\u00f3n; en la empresa se impusieron los lenguajes imperativos y orientados a objetos. En la primera d\u00e9cada del 2000 han aparecido lenguajes que evolucionan de Lisp y que resaltan sus aspectos funcionales, aunque actualizando su sintaxis. Destacamos entre ellos: Clojure Erlang Tambi\u00e9n hay una tendencia desde mediados de la d\u00e9cada de 2000 de incluir aspectos funcionales como las expresiones lambda o las funciones de orden superior en lenguajes imperativos orientados a objetos, dando lugar a lenguajes multi-paradigma : Ruby Python Groovy Scala Swift Por \u00faltimo, en la d\u00e9cada del 2010 tambi\u00e9n se ha hecho popular un lenguaje exclusivamente funcional como Haskell . Este lenguaje, a diferencia de Scheme y de otros lenguajes multi-paradigma, no tienen ning\u00fan elemento imperativo y consigue que todas sus expresiones sean puramente funcionales. Aplicaciones pr\u00e1cticas de la programaci\u00f3n funcional En la actualidad el paradigma funcional es un paradigma de moda , como se puede comprobar observando la cantidad de art\u00edculos, charlas y blogs en los que se habla de \u00e9l, as\u00ed como la cantidad de lenguajes que est\u00e1n aplicando sus conceptos. Por ejemplo, solo como muestra, mostramos a continuaci\u00f3n algunos enlaces a charlas y art\u00edculos interesantes publicados recientemente sobre programaci\u00f3n funcional: Lupo Montero - Introducci\u00f3n a la programaci\u00f3n funcional en JavaScript (Blog) Andr\u00e9s Marzal - Por qu\u00e9 deber\u00edas aprender programaci\u00f3n funcional ya mismo (Charla en YouTube) Mary Rose Cook - A practical introduction to functional programming (Blog) Ben Christensen - Functional Reactive Programming in the Netflix API (Charla en InfoQ) El auge reciente de estos lenguajes y del paradigma funcional se debe a varios factores, entre ellos que es un paradigma que facilita: la programaci\u00f3n de sistemas concurrentes, con m\u00faltiples hilos de ejecuci\u00f3n o con m\u00faltiples computadores ejecutando procesos conectados concurrentes. la definici\u00f3n y composici\u00f3n de m\u00faltiples operaciones sobre streams de forma muy concisa y compacta, aplicable a la programaci\u00f3n de sistemas distribuidos en Internet. la programaci\u00f3n interactiva y evolutiva. Programaci\u00f3n de sistemas concurrentes Veremos m\u00e1s adelante que una de las caracter\u00edsticas principales de la programaci\u00f3n funcional es que no se usa la mutaci\u00f3n (no se modifican los valores asignados a variables ni par\u00e1metros). Esta propiedad lo hace un paradigma excelente para implementar programas concurrentes, en los que existen m\u00faltiples hilos de ejecuci\u00f3n. La programaci\u00f3n de sistemas concurrentes es muy complicada con el paradigma imperativo tradicional, en el que la modificaci\u00f3n del estado de una variable compartida por m\u00e1s de un hilo puede provocar condiciones de carrera y errores dif\u00edcilmente localizables y reproducibles. Como dice Bartosz Milewski , investigador y te\u00f3rico de ciencia de computaci\u00f3n, en su respuesta en Quora a la pregunta \u00bfpor qu\u00e9 a los ingenieros de software les gusta la programaci\u00f3n funcional? : Porque es la \u00fanica forma pr\u00e1ctica de escribir programas concurrentes. Intentar escribir programas concurrentes en lenguajes imperativos, no s\u00f3lo es dif\u00edcil, sino que lleva a bugs que son muy dif\u00edciles de descubrir, reproducir y arreglar. En los lenguajes imperativos y, en particular, en los lenguajes orientados a objetos se ocultan las mutaciones y se comparten datos sin darse cuenta, por lo que son extremadamente propensos a los errores de concurrencia producidos por las condiciones de carrera. Definici\u00f3n y composici\u00f3n de operaciones sobre streams El paradigma funcional ha originado un estilo de programaci\u00f3n sobre streams de datos, en el que se concatenan operaciones como filter o map para definir de forma sencilla procesos y transformaciones as\u00edncronas aplicables a los elementos del stream . Este estilo de programaci\u00f3n ha hecho posible nuevas ideas de programaci\u00f3n, como la programaci\u00f3n reactiva , basada en eventos, o los futuros o promesas muy utilizados en lenguajes muy populares como JavaScript para realizar peticiones as\u00edncronas a servicios web. Por ejemplo, en el art\u00edculo Exploring the virtues of microservices with Play and Akka se explica con detalle las ventajas del uso de lenguajes y primitivas para trabajar con sistemas as\u00edncronos basados en eventos en servicios como Tumblr o Netflix. Otro ejemplo es el uso de Scala en Tumblr con el que se consigue crear c\u00f3digo que no tiene estado compartido y que es f\u00e1cilmente paralelizable entre los m\u00e1s de 800 servidores necesarios para atender picos de m\u00e1s de 40.000 peticiones por segundo: \"Scala promueve que no haya estado compartido. El estado mutable se evita usando sentencias en Scala. No se usan m\u00e1quinas de estado de larga duraci\u00f3n. El estado se saca de la base de datos, se usa, y se escribe de nuevo en la base de datos. La ventaja principal es que los desarrolladores no tienen que preocuparse sobre hilos o bloqueos. Programaci\u00f3n evolutiva En la metodolog\u00eda de programaci\u00f3n denominada programaci\u00f3n evolutiva o iterativa los programas complejos se construyen a base de ir definiendo y probando elementos computacionales cada vez m\u00e1s complicados. Los lenguajes de programaci\u00f3n funcional encajan perfectamente en esta forma de construir programas. Como Abelson y Sussman comentan en el SICP: En general, los objetos computacionales pueden tener estructuras muy complejas, y ser\u00eda extremadamente inconveniente tener que recordar y repetir sus detalles cada vez que queremos usarlas. En lugar de ello, se construyen programas complejos componiendo, paso a paso, objetos computacionales de creciente complejidad. El int\u00e9rprete hace esta construcci\u00f3n paso-a-paso de los programas particularmente conveniente porque las asociaciones nombre-objeto se pueden crear de forma incremental en interacciones sucesivas. Esta caracter\u00edstica favorece el desarrollo y prueba incremental de programas, y es en gran medida responsable del hecho de que un programa Lisp consiste normalmente de un gran n\u00famero de procedimientos relativamente simples. No hay que confundir una metodolog\u00eda de programaci\u00f3n con un paradigma de programaci\u00f3n. Una metodolog\u00eda de programaci\u00f3n proporciona sugerencias sobre c\u00f3mo debemos dise\u00f1ar, desarrollar y mantener una aplicaci\u00f3n que va a ser usada por usuarios finales. La programaci\u00f3n funcional se puede usar con m\u00faltiples metodolog\u00edas de programaci\u00f3n, debido a que los programas resultantes son muy claros, expresivos y f\u00e1ciles de probar. Programaci\u00f3n declarativa vs. imperativa Hemos dicho que la programaci\u00f3n funcional es un estilo de programaci\u00f3n declarativa, frente a la programaci\u00f3n tradicional de los lenguajes denominados imperativos. Vamos a explicar esto un poco m\u00e1s. Programaci\u00f3n declarativa Empecemos con lo que conocemos todos: un programa imperativo . Se trata de un conjunto de instrucciones que se ejecutan una tras otra (pasos de ejecuci\u00f3n) de forma secuencial. En la ejecuci\u00f3n de estas instrucciones se van cambiando los valores de las variables y, dependiendo de estos valores, se modifica el flujo de control de la ejecuci\u00f3n del programa. Para entender el funcionamiento de un programa imperativo debemos imaginar toda la evoluci\u00f3n del programa, los pasos que se ejecutan y cu\u00e1l es el flujo de control en funci\u00f3n de los cambios de los valores en las variables. En la programaci\u00f3n declarativa , sin embargo, utilizamos un paradigma totalmente distinto. Hablamos de programaci\u00f3n declarativa para referirnos a lenguajes de programaci\u00f3n (o sentencias de c\u00f3digo) en los que se declaran los valores, objetivos o caracter\u00edsticas de los elementos del programa y en cuya ejecuci\u00f3n no existe mutaci\u00f3n (modificaci\u00f3n de valores de variables) ni secuencias de pasos de ejecuci\u00f3n. De esta forma, la ejecuci\u00f3n de un programa declarativo tiene que ver m\u00e1s con alg\u00fan modelo formal o matem\u00e1tico que con un programa tradicional imperativo. Define un conjunto de reglas y definiciones de estilo matem\u00e1tico . Un ejemplo claro de programaci\u00f3n declarativa es una hoja de c\u00e1lculo . Las celdas contiene valores o expresiones matem\u00e1ticas que se actualizan autom\u00e1ticamente cuando cambiamos los valores de entrada. La relaci\u00f3n entre valores y resultados es totalmente matem\u00e1tica y para su c\u00e1lculo no tenemos que tener en cuenta pasos de ejecuci\u00f3n. Evidente, por debajo de la hoja de c\u00e1lculo existe un programa que realiza el su c\u00e1lculo de la hoja, pero cuando estamos us\u00e1ndola no nos preocupa esa implementaci\u00f3n. Podemos no preocuparnos de ella y usar \u00fanicamente el modelo matem\u00e1tico definido en la hoja. En la programaci\u00f3n funcional se cumplen estas caracter\u00edsticas, porque se definen funciones en las que se realizan unas operaciones sobre unos par\u00e1metros de entrada y se devuelve un valor, sin modificar ning\u00fan estado del programa ni utilizar pasos de ejecuci\u00f3n definidos como tales. El siguiente ejemplo es una declaraci\u00f3n en Scheme de una funci\u00f3n que toma como entrada un n\u00famero y devuelve su cuadrado: 1 2 ( define ( cuadrado x ) ( * x x )) La llamada a la funci\u00f3n con un par\u00e1metro concreto devuelve el resultado de evaluar su definici\u00f3n. Debemos pensar que esta evaluaci\u00f3n se hace de forma instant\u00e1nea, sin realizar pasos de ejecuci\u00f3n ni mutaci\u00f3n de valores en variables auxiliares. 1 ( cuadrado 4 ) ; devuelve 16 La programaci\u00f3n declarativa no es exclusiva de los lenguajes funcionales. Existen muchos lenguajes no funcionales con caracter\u00edsticas declarativas. Por ejemplo Prolog, en el que un programa se define como un conjunto de reglas l\u00f3gicas y su ejecuci\u00f3n realiza una deducci\u00f3n l\u00f3gica matem\u00e1tica que devuelve un resultado. En dicha ejecuci\u00f3n no son relevantes los pasos internos que realiza el sistema sino las relaciones l\u00f3gicas entre los datos y los resultados finales. Programaci\u00f3n imperativa Repasemos un algunas caracter\u00edsticas propias de la programaci\u00f3n imperativa que no existen en la programaci\u00f3n funcional . Son caracter\u00edsticas a las que estamos muy habituados porque son propias de los lenguajes m\u00e1s populares y con los que hemos aprendido a programar (C, C++, Java, python, etc.) Pasos de ejecuci\u00f3n y mutaci\u00f3n Efectos laterales Estado local mutable en las funciones Veremos que, aunque parece imposible, es posible programar sin utilizar estas caracter\u00edsticas. Lo demuestran lenguajes lenguajes de programaci\u00f3n funcional como Haskell, Clojure o el propio Scheme. Pasos de ejecuci\u00f3n y mutaci\u00f3n El estilo de programaci\u00f3n imperativa se basa en pasos de ejecuci\u00f3n que modifican el estado de variables: 1 2 int x = 10 ; int x = x + 1 ; La expresi\u00f3n x = x + 1 es una expresi\u00f3n de asignaci\u00f3n que modifica el valor anterior de una variable por un nuevo valor. El estado de las variables (su valor) cambia con la ejecuci\u00f3n de los pasos del programa. A esta asignaci\u00f3n que modifica un valor ya existente se le denomina asignaci\u00f3n destructiva o mutaci\u00f3n . En programaci\u00f3n imperativa tambi\u00e9n se puede modificar (mutar) el valor de componentes de estructuras de datos, como posiciones de un array, de una lista o de un diccionario. Mutaci\u00f3n y efectos laterales En programaci\u00f3n imperativa es habitual tambi\u00e9n trabajar con referencias y hacer que m\u00e1s de un identificador referencie el mismo valor. Esto produce la posibilidad de que la modificaci\u00f3n (mutaci\u00f3n) del valor a trav\u00e9s de uno de los identificadores produzca un efecto lateral ( side effect en ingl\u00e9s) en el que el valor de un identificador cambia sin ejecutar ninguna expresi\u00f3n en la que se utilice expl\u00edcitamente el propio identificador. Por ejemplo, en la mayor\u00eda de lenguajes orientados a objetos los identificadores guardan referencias a objetos. De forma que si asignamos un objeto a m\u00e1s de un identificador, todos los identificadores est\u00e1n accediendo al mismo objeto. Si mutamos alg\u00fan valor del objeto a trav\u00e9s de un identificador provocamos un efecto lateral en los otros identificadores. Por ejemplo, lo siguiente es un ejemplo de una mutaci\u00f3n en programaci\u00f3n imperativa, en la que se modifican los atributos de un objeto en Java: 1 2 3 4 Point2D p1 = new Point2D ( 3.0 , 2.0 ); // creamos un punto 2D con coordX=3.0 y coordY=2.0 p1 . getCoordX (); // la coord x de p2 es 3.0 p1 . setCoordX ( 10.0 ); p1 . getCoordX (); // la coord x de p1 es 10.0 Si el objeto est\u00e1 asignado a m\u00e1s de una variable tendremos el efecto lateral ( side effect ) en el que el dato guardado en una variable cambia despu\u00e9s de una sentencia en la que no se ha usado esa variable: 1 2 3 4 5 Point2D p1 = new Point2D ( 3.0 , 2.0 ); // la coord x de p1 es 3.0 p1 . getCoordX (); // la coord x de p1 es 3.0 Point2D p2 = p1 ; p2 . setCoordX ( 10.0 ); p1 . getCoordX (); // la coord x de p1 es 10.0, sin que ninguna sentencia haya modificado directamente p1 En programaci\u00f3n funcional, por contra, las definiciones son inmutables , una vez asignado un valor a un identificador no se puede modificar \u00e9ste. En programaci\u00f3n funcional se entienden las variables como variables matem\u00e1ticas, no como referencias a una posiciones de memoria que puede ser modificada. Los valores son inmutables y no existen efectos laterales. Por ejemplo, la forma especial define en Scheme crea un nuevo identificador y le da el valor definido de forma permanente. Si escribimos el siguiente c\u00f3digo en un programa en Scheme R6RS: 1 2 3 4 5 # lang r6rs ( import ( rnrs base )) ( define a 12 ) ( define a 200 ) tendremos el siguiente error: 1 module : duplicate definition for identifier in : a Nota : en el int\u00e9rprete REPL del DrRacket s\u00ed que podemos definir m\u00e1s de una vez la misma funci\u00f3n o identificador. Se ha dise\u00f1ado as\u00ed para facilitar el uso del int\u00e9rprete para la prueba de expresiones en Scheme. En los lenguajes de programaci\u00f3n es habitual mezclar sentencias imperativas y sentencias declarativas. Por ejemplo, en el siguiente c\u00f3digo Java las l\u00edneas 1 y 3 las podr\u00edamos considerar declarativas y las 2 y 4 imperativas: 1 2 3 4 1. int x = 1; 2. x = x+1; 3. int y = x+1; 4. y = x; Estado local Otra caracter\u00edstica de la programaci\u00f3n imperativa es lo que se denomina estado local mutable en funciones, procedimientos o m\u00e9todos. Se trata la posibilidad de que una invocaci\u00f3n a un m\u00e9todo o una funci\u00f3n modifique un cierto estado y de forma que la siguiente invocaci\u00f3n devuelva un valor distinto. Es una caracter\u00edstica b\u00e1sica de la programaci\u00f3n orientada a objetos, donde los objetos guardan valores que se modifican con la invocaciones a sus m\u00e9todos. Por ejemplo, en Java, podemos definir un contador que incrementa su valor: 1 2 3 4 5 6 7 8 9 10 11 12 public class Contador { int c ; public Contador ( int valorInicial ) { c = valorInicial ; } public int valor () { c ++; return c ; } } Cada llamada al m\u00e9todo valor() devolver\u00e1 un valor distinto: 1 2 3 4 Contador cont = new Contador ( 10 ); cont . valor (); // 11 cont . valor (); // 12 cont . valor (); // 13 Tambi\u00e9n se pueden definir funciones con estado local mutable en C: 1 2 3 4 5 6 int function contador () { static int c = 0 ; c ++ ; return c ; } Cada llamada a la funci\u00f3n contador() devolver\u00e1 un valor distinto: 1 2 3 contador () ;; 1 contador () ;; 2 contador () ;; 3 Por el contrario, los lenguajes funcionales tienen la propiedad de transparencia referencial : es posible sustituir cualquier aparici\u00f3n de una expresi\u00f3n por su resultado sin que cambia el resultado final del programa. Dicho de otra forma, en programaci\u00f3n funcional, una funci\u00f3n siempre devuelve el mismo valor cuando se le llama con los mismos par\u00e1metros . Las funciones no modifican ning\u00fan estado, no acceden a ninguna variable ni objeto global y modifican su valor. Resumen Un resumen de las caracter\u00edsticas fundamentales de la programaci\u00f3n declarativa frente a la programaci\u00f3n imperativa. En los siguientes apartados explicaremos m\u00e1s estas caracter\u00edsticas. Caracter\u00edsticas de la programaci\u00f3n declarativa Variable = nombre dado a un valor (declaraci\u00f3n) No existe asignaci\u00f3n ni cambio de estado No existe mutaci\u00f3n, se cumple la transferencia referencial : dentro de un mismo \u00e1mbito todas las ocurrencias de una variable y las llamadas a funciones devuelven el mismo valor Caracter\u00edsticas de la programaci\u00f3n imperativa Variable = nombre de una zona de memoria Asignaci\u00f3n Referencias Pasos de ejecuci\u00f3n Evaluaci\u00f3n de expresiones y definici\u00f3n de funciones En la asignatura usaremos Scheme como primer lenguaje en el que exploraremos la programaci\u00f3n funcional. En el seminario de Scheme que se imparte en pr\u00e1cticas se estudiar\u00e1 en m\u00e1s profundidad los conceptos m\u00e1s importantes del lenguaje: tipos de datos, operadores, estructuras de control, int\u00e9rprete, etc. Evaluaci\u00f3n de expresiones Empezamos este apartado viendo c\u00f3mo se definen y eval\u00faan expresiones Scheme. Y despu\u00e9s veremos c\u00f3mo construir nuevas funciones. Scheme es un lenguaje que viene del Lisp. Una de sus caracter\u00edsticas principales es que las expresiones se construyen utilizando par\u00e9ntesis. Ejemplos de expresiones en Scheme, junto con el resultado de su ejecuci\u00f3n: 1 2 3 4 5 2 ; \u21d2 2 ( + 2 3 ) ; \u21d2 5 ( + ) ; \u21d2 0 ( + 2 4 5 6 ) ; \u21d2 17 ( + ( * 2 3 ) ( - 3 1 )) ; \u21d2 8 En programaci\u00f3n funcional en lugar de decir \"ejecutar una expresi\u00f3n\" se dice \" evaluar una expresi\u00f3n \", para reforzar la idea de que se tratan de expresiones matem\u00e1ticas que siempre devuelven uno y s\u00f3lo un resultado . Las expresiones se definen con una notaci\u00f3n prefija: el primer elemento despu\u00e9s del par\u00e9ntesis de apertura es el operador de la expresi\u00f3n y el resto de elementos (hasta el par\u00e9ntesis de cierre) son sus operandos. Por ejemplo, en la expresi\u00f3n (+ 2 4 5 6) el operador es el s\u00edmbolo + que representa funci\u00f3n suma y los operandos son los n\u00fameros 2, 4, 5 y 6. Puede haber expresiones que no tengan operandos, como el ejemplo (+) , cuya evaluaci\u00f3n devuelve 0. Una idea fundamental de Lisp y Scheme es que los par\u00e9ntesis se eval\u00faan de dentro a fuera. Por ejemplo, la expresi\u00f3n (+ (* 2 3) (- 3 (/ 12 3))) que devuelve 5, se eval\u00faa as\u00ed: 1 2 3 4 5 ( + ( * 2 3 ) ( - 3 ( / 12 3 ))) \u21d2 ( + 6 ( - 3 ( / 12 3 ))) \u21d2 ( + 6 ( - 3 4 )) \u21d2 ( + 6 -1 ) \u21d2 5 La evaluaci\u00f3n de cada expresi\u00f3n devuelve un valor que se utiliza para continuar calculando la expresi\u00f3n exterior. En el caso anterior primero se eval\u00faa la expresi\u00f3n (* 2 3) que devuelve 6, despu\u00e9s se eval\u00faa (/ 12 3) que devuelve 4, despu\u00e9s se eval\u00faa (- 3 4) que devuelve -1 y por \u00faltimo se eval\u00faa (+ 6 -1) que devuelve 5 Cuando se eval\u00faa una expresi\u00f3n en el int\u00e9rprete de Scheme el resultado aparece en la siguiente l\u00ednea. Definici\u00f3n de funciones En programaci\u00f3n funcional las funciones son similares a las funciones matem\u00e1ticas: reciben par\u00e1metros y devuelven siempre un \u00fanico resultado de operar con esos par\u00e1metros. Por ejemplo, podemos definir la funci\u00f3n (cuadrado x) que devuelve el cuadrado de un n\u00famero que pasamos como par\u00e1metro: 1 2 ( define ( cuadrado x ) ( * x x )) El cuerpo de la funci\u00f3n es una expresi\u00f3n que se evaluar\u00e1 con el valor que se pase como par\u00e1metro. En el caso anterior la expresi\u00f3n es (* x x) y multiplicar\u00e1 el par\u00e1metro por si mismo. Hay que hacer notar que en Scheme no existe la palabra clave return , sino que las funciones siempre se definen con una \u00fanica expresi\u00f3n cuya evaluaci\u00f3n es el resultado que se devuelve. Una vez definida la funci\u00f3n cuadrado podemos usarla de la misma forma que las funciones primitivas de Scheme: 1 2 ( cuadrado 10 ) ; \u21d2 100 ( cuadrado ( + 10 ( cuadrado ( + 2 4 )))) ; \u21d2 2116 La evaluaci\u00f3n de la \u00faltima expresi\u00f3n se hace de la siguiente forma: 1 2 3 4 5 ( cuadrado ( + 10 ( cuadrado ( + 2 4 )))) \u21d2 ( cuadrado ( + 10 ( cuadrado 6 ))) \u21d2 ( cuadrado ( + 10 36 )) \u21d2 ( cuadrado 46 ) \u21d2 2116 Las funciones definidas se pueden utilizar a su vez para construir otras funciones Lo habitual en programaci\u00f3n funcional es definir funciones muy peque\u00f1as e ir construyendo funciones cada vez de mayor nivel usando las anteriores. Ejemplo: tiempo de impacto Por ejemplo, supongamos que estamos programando un juego de guerra de barcos y submarinos, en el que utilizamos las coordenadas del plano para situar todos los elementos de nuestra flota. Supongamos que necesitamos calcular el tiempo que tarda un torpedo en llegar desde una posici\u00f3n (x1, y1) a otra (x2, y2) . Suponemos que la velocidad del torpedo es otro par\u00e1metro v . \u00bfC\u00f3mo calcular\u00edamos este tiempo de impacto? La forma menos correcta de hacerlo es definir todo el c\u00e1lculo en una \u00fanica expresi\u00f3n. Como en programaci\u00f3n funcional las funciones deben definirse con una \u00fanica expresi\u00f3n deber\u00edamos poner todo el c\u00e1lculo en forma de expresiones anidadas, unas dentro de otras. Eso crear\u00eda una funci\u00f3n que calcular\u00eda bien el resultado, pero que ser\u00eda muy dif\u00edcil de leer y entender para un compa\u00f1ero (o para nosotros mismos, cuando pasen unos meses): 1 2 3 4 5 6 7 8 9 10 11 12 ; ; Definici\u00f3n incorrecta: muy poco legible ; ; La funci\u00f3n tiempo-impacto1 devuelve el tiempo que tarda ; en llegar un torpedo a la velocidad v desde la posici\u00f3n ; (x1, y1) a la posici\u00f3n (x2, y2) ; ( define ( tiempo-impacto x1 y1 x2 y2 v ) ( / ( sqrt ( + ( * ( - x2 x1 ) ( - x2 x1 )) ( * ( - y2 y1 ) ( - y2 y1 )))) v )) La funci\u00f3n anterior har\u00eda bien el c\u00e1lculo pero ser\u00eda muy complicada de modificar y de entender. La forma m\u00e1s correcta de definir la funci\u00f3n ser\u00eda usando varias funciones auxiliares. F\u00edjate que es muy importante tambi\u00e9n poner los nombres correctos a cada funci\u00f3n, para entender qu\u00e9 hace. Scheme es un lenguaje d\u00e9bilmente tipado y no tenemos la ayuda de los tipos que nos dan m\u00e1s contexto de qu\u00e9 es cada par\u00e1metro y qu\u00e9 devuelve la funci\u00f3n. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 ; ; Definici\u00f3n correcta, modular y legible ; ; La funci\u00f3n tiempo-impacto devuelve el tiempo que tarda ; en llegar un torpedo a la velocidad v desde la posici\u00f3n ; (x1, y1) a la posici\u00f3n (x2, y2) ; ( define ( tiempo-impacto x1 y1 x2 y2 velocidad ) ( tiempo ( distancia x1 y1 x2 y2 ) velocidad )) ; ; ; La funci\u00f3n tiempo devuelve el tiempo que ; tarde en recorrer un m\u00f3vil una distancia d a un velocidad v ; ( define ( tiempo distancia velocidad ) ( / distancia velocidad )) ; ; La funci\u00f3n distancia devuelve la distancia entre dos ; coordenadas (x1, y1) y (x2, y2) ; ( define ( distancia x1 y1 x2 y2 ) ( sqrt ( + ( cuadrado ( - x2 x1 )) ( cuadrado ( - y2 y1 ))))) ; ; La funci\u00f3n cuadrado devuelve el cuadrado de un n\u00famero ; ( define ( cuadrado x ) ( * x x )) En esta segunda versi\u00f3n definimos m\u00e1s funciones, pero cada una es mucho m\u00e1s legible. Adem\u00e1s las funciones como cuadrado , distancia o tiempo las vamos a poder reutilizar para otros c\u00e1lculos. Funciones puras A diferencia de lo que hemos visto en programaci\u00f3n imperativa, en programaci\u00f3n funcional no es posible definir funciones con estado local. Las funciones que se definen son funciones matem\u00e1ticas puras, que cumplen las siguientes condiciones: No modifican los par\u00e1metros que se les pasa Devuelven un \u00fanico resultado No tienen estado local ni el resultado depende de un estado exterior mutable Esta \u00faltima propiedad es muy importante y quiere decir que la funci\u00f3n siempre devuelve el mismo valor cuando se le pasan los mismos par\u00e1metros. Las funciones puras son muy f\u00e1ciles de entender porque no es necesario tener en cuenta ning\u00fan contexto a la hora de describir su funcionamiento. El valor devuelto \u00fanicamente depende de los par\u00e1metros de entrada. Por ejemplo, funciones matem\u00e1ticas como suma, resta, cuadrado, sin, cos, etc. cumplen esta propiedad. Modelo de computaci\u00f3n de sustituci\u00f3n Un modelo computacional es un formalismo (conjunto de reglas) que definen el funcionamiento de un programa. En el caso de los lenguajes funcionales basados en la evaluaci\u00f3n de expresiones, el modelo computacional define cu\u00e1l ser\u00e1 el resultado de evaluar una expresi\u00f3n. El modelo de sustituci\u00f3n es un modelo muy sencillo que permite definir la sem\u00e1ntica de la evaluaci\u00f3n de expresiones en lenguajes funcionales como Scheme. Se basa en una versi\u00f3n simplificada de la regla de reducci\u00f3n del c\u00e1lculo lambda. Es un modelo basado en la reescritura de unos t\u00e9rminos por otros. Aunque se trata de un modelo abstracto, ser\u00eda posible escribir un int\u00e9rprete que, bas\u00e1ndose en este modelo, eval\u00fae expresiones funcionales. Supongamos un conjunto de definiciones en Scheme: 1 2 3 4 5 6 7 8 9 10 ( define ( doble x ) ( + x x )) ( define ( cuadrado y ) ( * y y )) ( define ( f z ) ( + ( cuadrado ( doble z )) 1 )) ( define a 2 ) Supongamos que, una vez realizadas esas definiciones, se eval\u00faa la siguiente expresi\u00f3n: 1 ( f ( + a 1 )) \u00bfCu\u00e1l ser\u00e1 su resultado? Si lo hacemos de forma intuitiva podemos pensar que 37 . Si lo comprobamos en el int\u00e9rprete de Scheme veremos que devuelve 37. \u00bfHemos seguido algunas reglas espec\u00edficas? \u00bfQu\u00e9 reglas son las que sigue el int\u00e9rprete? \u00bfPodr\u00edamos implementar nosotros un int\u00e9rprete similar? S\u00ed, usando las reglas del modelo de sustituci\u00f3n. El modelo de sustituci\u00f3n define cuatro reglas sencillas para evaluar una expresi\u00f3n. Llamemos a la expresi\u00f3n e . Las reglas son las siguientes: Si e es un valor primitivo (por ejemplo, un n\u00famero), devolvemos ese mismo valor. Si e es un identificador, devolvemos su valor asociado con un define (se lanzar\u00e1 un error si no existe ese valor). Si e es una expresi\u00f3n del tipo (f arg1 ... argn) , donde f es el nombre de una funci\u00f3n primitiva ( + , - , ...), evaluamos uno a uno los argumentos arg1 ... argn (con estas mismas reglas) y evaluamos la funci\u00f3n primitiva con los resultados. La regla 4 tiene dos variantes, dependiendo del orden de evaluaci\u00f3n que utilizamos. Orden aplicativo Si e es una expresi\u00f3n del tipo (f arg1 ... argn) , donde f es el nombre de una funci\u00f3n definida con un define , tenemos que evaluar primero los argumentos arg1 ... argn y despu\u00e9s sustituir f por su cuerpo , reemplazando cada par\u00e1metro formal de la funci\u00f3n por el correspondiente argumento evaluado. Despu\u00e9s evaluaremos la expresi\u00f3n resultante usando estas mismas reglas. Orden normal Si e es una expresi\u00f3n del tipo (f arg1 ... argn) , donde f es el nombre de una funci\u00f3n definida con un define , tenemos que sustituir f por su cuerpo , reemplazando cada par\u00e1metro formal de la funci\u00f3n por el correspondiente argumento sin evaluar. Despu\u00e9s evaluar la expresi\u00f3n resultante usando estas mismas reglas. Ambas formas de evaluaci\u00f3n dar\u00e1n el mismo resultado en programaci\u00f3n funcional. Scheme utiliza el orden aplicativo. En el siguiente apartado veremos un ejemplo de ambos tipos de evaluaciones. Ejemplo En el orden aplicativo se realizan las evaluaciones antes de realizar las sustituciones, lo que define una evaluaci\u00f3n de dentro a fuera de los par\u00e9ntesis. Cuando se llega a una expresi\u00f3n primitiva se eval\u00faa. En el orden normal se realizan todas las sustituciones hasta que se tiene una larga expresi\u00f3n formada por expresiones primitivas; se eval\u00faa entonces. Veamos c\u00f3mo se eval\u00faa el mismo ejemplo de ambas formas. Supongamos el ejemplo anterior. Definiciones: 1 2 3 4 5 6 7 8 9 10 ( define ( doble x ) ( + x x )) ( define ( cuadrado y ) ( * y y )) ( define ( f z ) ( + ( cuadrado ( doble z )) 1 )) ( define a 2 ) Expresi\u00f3n a evaluar: 1 ( f ( + a 1 )) Veamos el resultado de la evaluaci\u00f3n usando el modelo de sustituci\u00f3n aplicativo , aplicando paso a paso las reglas anteriores (en cada l\u00ednea pondremos entre par\u00e9ntesis la regla que aplicamos): 1 2 3 4 5 6 7 8 9 10 (f (+ a 1)) \u21d2 ; Para evaluar f, evaluamos primero su argumento (+ a 1) (Regla 4) ; y sustituimos a por 2 (Regla 2) (f (+ 2 1)) \u21d2 ; Evaluamos (+ 2 1) (Reglas 2 y 3) (f 3) \u21d2 ; (Regla 4) (+ (cuadrado (doble 3)) 1) \u21d2 ; Sustituimos (doble 3) (Regla 4) (+ (cuadrado (+ 3 3)) 1) \u21d2 ; Evaluamos (+ 3 3) (Reglas 2 y 3) (+ (cuadrado 6) 1) \u21d2 ; Sustitumos (cuadrado 6) (Regla 4) (+ (* 6 6) 1) \u21d2 ; Evaluamos (* 6 6) (Reglas 2 y 3) (+ 36 1) \u21d2 ; Evaluamos (+ 36 1) (Reglas 2 y 3) 37 Y veamos el resultado de usar el modelo de sustituci\u00f3n normal : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 (f (+ a 1)) \u21d2 ; Sustituimos (f (+ a 1)) ; por su definici\u00f3n, con z = (+ a 1) (Regla 4) (+ (cuadrado (doble (+ a 1))) 1) \u21d2 ; Sustituimos (cuadrado ...) (Regla 4) (+ (* (doble (+ a 1)) (doble (+ a 1))) 1) ; Sustituimos (doble ...) (Regla 4) (+ (* (+ (+ a 1) (+ a 1)) (+ (+ a 1) (+ a 1))) 1) \u21d2 ; Evaluamos a (Regla 2) (+ (* (+ (+ 2 1) (+ 2 1)) (+ (+ 2 1) (+ 2 1))) 1) \u21d2 ; Evaluamos (+ 2 1) (Regla 3) (+ (* (+ 3 3) (+ 3 3)) 1) \u21d2 ; Evaluamos (+ 3 3) (Regla 3) (+ (* 6 6) 1) \u21d2 ; Evaluamos (* 6 6) (Regla 3) (+ 36 1) \u21d2 ; Evaluamos (+ 36 1) (Regla 3) 37 En programaci\u00f3n funcional el resultado de evaluar una expresi\u00f3n es el mismo independientemente del tipo de orden. Pero si estamos fuera del paradigma funcional y las funciones tienen estado y cambian de valor entre distintas invocaciones s\u00ed que importan si escogemos un orden. Por ejemplo, supongamos una funci\u00f3n (random x) que devuelve un entero aleatorio entre 0 y x . Esta funci\u00f3n no cumplir\u00eda el paradigma funcional, porque devuelve un valor distinto con el mismo par\u00e1metro de entrada. Evaluamos las siguientes expresiones con orden aplicativo y normal, para comprobar que el resultado es distinto 1 2 ( define ( zero x ) ( - x x )) ( zero ( random 10 )) Scheme como lenguaje de programaci\u00f3n funcional Ya hemos visto c\u00f3mo definir funciones y evaluar expresiones en Scheme. Vamos continuar con ejemplos concretos de otras caracter\u00edsticas funcionales caracter\u00edsticas funcionales de Scheme. En concreto, veremos: S\u00edmbolos y primitiva quote Uso de listas Definici\u00f3n de funciones recursivas en Scheme Funciones y formas especiales En el seminario de Scheme hemos visto un conjunto de primitivas que podemos utilizar en Scheme. Podemos clasificar las primitivas en funciones y formas especiales . Las funciones se eval\u00faan usando el modelo de sustituci\u00f3n aplicativo ya visto: Primero se eval\u00faan los argumentos y despu\u00e9s se sustituye la llamada a la funci\u00f3n por su cuerpo y se vuelve a evaluar la expresi\u00f3n resultante. Las expresiones siempre se eval\u00faan desde los par\u00e9ntesis interiores a los exteriores. Las formas especiales son expresiones primitivas de Scheme que tienen una forma de evaluarse propia, distinta de las funciones. Formas especiales en Scheme: define, if, cond Veamos la forma de evaluar las distintas formas especiales en Scheme. En estas formas especiales no se aplica el modelo de sustituci\u00f3n, al no ser invocaciones de funciones, sino que cada una se eval\u00faa de una forma diferente. Forma especial define Sintaxis 1 ( define identificador expresi \u00f3 n ) Evaluaci\u00f3n Evaluar expresi\u00f3n Asociar el valor resultante con el identificador Ejemplo 1 2 3 ( define base 10 ) ; Asociamos a base el valor 10 ( define altura 12 ) ; Asociamos a altura el valor 12 ( define area ( / ( * base altura ) 2 )) ; Asociamos a area el valor 60 Forma especial define para definir funciones Sintaxis 1 2 (define ( nombre-funcion argumentos ) cuerpo ) Evaluaci\u00f3n La semana que viene veremos con m\u00e1s detalle la sem\u00e1ntica, y explicaremos la forma especial lambda que es la que realmente crea la funci\u00f3n. Hoy nos quedamos en la siguiente descripci\u00f3n de alto nivel de la sem\u00e1ntica: Crear la funci\u00f3n con el cuerpo Dar a la funci\u00f3n el nombre nombre-funci\u00f3n Ejemplo 1 2 3 4 ( define ( factorial x ) ( if ( = x 0 ) 1 ( * x ( factorial ( - x 1 ))))) Forma especial if Sintaxis 1 ( if condici \u00f3 n expresi \u00f3 n-true expresi \u00f3 n-false ) Evaluaci\u00f3n Evaluar condici\u00f3n Si el resultado es #t evaluar la expresi\u00f3n-true , en otro caso, evaluar la expresi\u00f3n-false Ejemplo 1 2 3 4 ( if ( 10 5 ) ( substring Hola qu\u00e9 tal ( + 1 1 ) 4 ) ( / 12 0 )) ;; Evaluamos ( 10 5). Como el resultado es #t, evaluamos ;; (substring Hola qu\u00e9 tal (+ 1 1) 4), que devuelve la Forma especial cond Sintaxis 1 2 3 4 5 ( cond ( exp-cond-1 exp-consec-1 ) ( exp-cond-2 exp-consec-2 ) ... ( else exp-consec-else )) Evaluaci\u00f3n Se eval\u00faan de forma ordenada todas las expresiones hasta que una de ellas devuelva #t Si alguna expresi\u00f3n devuelve #t , se devuelve el valor del consecuente de esa expresi\u00f3n Si ninguna expresi\u00f3n es cierta, se devuelve el valor resultante de evaluar el consecuente del else Ejemplo 1 2 3 4 5 6 7 8 9 10 ( cond (( 3 4 ) 3 es mayor que 4 ) (( 2 1 ) 2 es menor que 1 ) (( = 3 1 ) 3 es igual que 1 ) (( 3 5 ) 3 es mayor que 2 ) ( else ninguna condici\u00f3n es cierta )) ;; Se eval\u00faan una a una las expresiones ( 3 4), ;; ( 2 1), (= 3 1) y ( 3 5). Como ninguna de ella ;; es cierta se devuelve la cadena ninguna condici\u00f3n es cierta . Forma especial quote y s\u00edmbolos Sintaxis 1 2 ( quote identificador ) ( quote expresion ) Evaluaci\u00f3n Se devuelve el identificador o la expresi\u00f3n sin evaluar . Si la expresi\u00f3n es compuesta (entre par\u00e9ntesis), se devuelve una lista. La expresi\u00f3n puede ser cualquier expresi\u00f3n correcta de Scheme. Se abrevia en con el car\u00e1cter ' . Ejemplo 1 2 ( quote x ) ; el s\u00edmbolo x hola ; el s\u00edmbolo hola A diferencia de los lenguajes imperativos, Scheme trata a los identificadores (nombres que se les da a las variables) como datos del lenguaje de tipo symbol . En el paradigma funcional a los identificadores se les denomina s\u00edmbolos . Los s\u00edmbolos son distintos de las cadenas. Una cadena es un tipo de dato compuesto y se guardan en memoria todos y cada uno de los caracteres que la forman. Sin embargo, los s\u00edmbolos son tipos at\u00f3micos, que se representan en memoria con un \u00fanico valor determinado por el c\u00f3digo hash del identificador. Ejemplos de funciones Scheme con s\u00edmbolos: 1 2 3 4 5 6 7 8 9 10 11 12 13 ( define x 12 ) ( symbol? x ) ; \u21d2 #t ( symbol? x ) ; \u21d2 #f \u00bfPor qu\u00e9? ( symbol? hola-que ) ( symbol- string hola-que ) ma \u00f1 ana l \u00e1 piz ; aunque sea posible, no vamos a usar acentos en los s\u00edmbolos ; pero s\u00ed en los comentarios ( symbol? hola ) ; #f ( symbol? #f ) ; #f ( symbol? ( car ( hola c \u00f3 mo est \u00e1 s ))) ; #t ( equal? hola hola ) ( equal? hola hola ) Un s\u00edmbolo puede asociarse o ligarse ( bind ) a un valor (cualquier dato de primera clase ) con la forma especial define . Cuando escribimos un s\u00edmbolo en el prompt de Scheme el int\u00e9rprete lo eval\u00faa y devuelve su valor: 1 2 3 ( define pi 3.14159 ) pi \u21d2 3.14159 Los nombres de las funciones ( equal? , sin , + , ...) son tambi\u00e9n s\u00edmbolos y Scheme tambi\u00e9n los eval\u00faa (en un par de semanas hablaremos de las funciones como objetos primitivos en Scheme): 1 2 3 4 sin ; \u21d2 # procedure:sin + ; \u21d2 # procedure:+ ( define ( cuadrado x ) ( * x x )) cuadrado ; \u21d2 # procedure:cuadrado Los s\u00edmbolos son tipos primitivos del lenguaje: pueden pasarse como par\u00e1metros o ligarse a variables. 1 2 ( define x hola ) x ; \u21d2 hola Listas Otra de las caracter\u00edsticas fundamentales del paradigma funcional es la utilizaci\u00f3n de listas. Ya hemos visto en el seminario de Scheme las funciones m\u00e1s importantes para trabajar con ellas. Vamos a repasarlas de nuevo en este apartado, antes de ver alg\u00fan ejemplo de c\u00f3mo usar la recursi\u00f3n con listas. Ya hemos visto en dicho seminario que Scheme es un lenguaje d\u00e9bilmente tipado. Una variable o par\u00e1metro no se declara de un tipo y puede contener cualquier valor. Sucede igual con las listas: una lista en Scheme puede contener cualquier valor, incluyendo otras listas. Funci\u00f3n list y forma especial quote En el seminario de Scheme explicamos que podemos crear listas de forma din\u00e1mica, llamando a la funci\u00f3n list y pas\u00e1ndole un n\u00famero variable de par\u00e1metros que son los elementos que se incluir\u00e1n en la lista: 1 2 3 4 ( list 1 2 3 4 5 ) ; \u21d2 {1 2 3 4} ( list a b c ) ; \u21d2 {a b c} ( list 1 a 2 b 3 c #t ) ; \u21d2 {1 a 2 b 3 c #t} ( list 1 ( + 1 1 ) ( * 2 ( + 1 2 ))) ; \u21d2 {1 2 6} Las expresiones interiores se eval\u00faan y se llama a la funci\u00f3n list con los valores resultantes. Otro ejemplo: 1 2 3 4 ( define a 1 ) ( define b 2 ) ( define c 3 ) ( list a b c ) ; \u21d2 {1 2 3} La otra forma de crear una lista es de forma est\u00e1tica, utilizando la forma especial quote vista anteriormente. Esa forma especial detiene la evaluaci\u00f3n natural de Scheme y devuelve la expresi\u00f3n que hay a continuaci\u00f3n sin evaluar. Si esa expresi\u00f3n es compuesta (entre par\u00e9ntesis) se devuelve como una lista, sin evaluar sus elementos Por ejemplo: 1 2 3 4 5 6 ( 1 2 3 4 ) ; \u21d2 {1 2 3 4} ( define a 1 ) ( define b 2 ) ( define c 3 ) ( a b c ) ; \u21d2 {a b c} ( 1 ( + 1 1 ) ( * 2 ( + 1 2 ))) ; \u21d2 {1 {+ 1 1} {* 2 {+ 1 2}}} La \u00faltima lista tiene 3 elementos: El n\u00famero 1 La lista {+ 1 1} La lista {* 2 {+ 1 2}} Es posible definir una lista vac\u00eda (sin elementos) realizando una llamada sin argumentos a la funci\u00f3n list o utilizando el s\u00edmbolo `(): 1 2 ( list ) ; \u21d2 {} ` () ; \u21d2 {} La diferencia entre creaci\u00f3n de listas con la funci\u00f3n list y con la forma especial quote se puede comprobar en los ejemplos. La evaluaci\u00f3n de la funci\u00f3n list funciona como cualquier funci\u00f3n, primero se eval\u00faan los argumentos y despu\u00e9s se invoca a la funci\u00f3n con los argumentos evaluados. Por ejemplo, en la siguiente invocaci\u00f3n se obtiene una lista con cuatro elementos resultantes de las invocaciones de las funciones dentro del par\u00e9ntesis: 1 ( list 1 ( / 2 3 ) ( + 2 3 ) ( cons 3 4 )) ; \u21d2 {1 2/3 5 {3 . 4}} Sin embargo, usamos quote obtenemos una lista con sublistas con s\u00edmbolos en sus primeras posiciones: 1 ( 1 ( / 2 3 ) ( + 2 3 ) ( cons 3 4 )) ; \u21d2 {1 {/ 2 3} {+ 2 3} {cons 3 4}} Selecci\u00f3n de elementos de una lista: car y cdr En el seminario vimos tambi\u00e9n c\u00f3mo obtener los elementos de una lista. Primer elemento: funci\u00f3n car Resto de elementos: funci\u00f3n cdr (los devuelve en forma de lista) Ejemplos: 1 2 3 4 5 6 ( define lista1 ( 1 2 3 4 )) ( car lista1 ) ; \u21d2 1 ( cdr lista1 ) ; \u21d2 {2 3 4} ( define lista2 (( 1 2 ) 3 4 )) ( car lista2 ) \u21d2 { 1 2 } ( cdr lista2 ) \u21d2 { 3 4 } Composici\u00f3n de listas: cons y append Por \u00faltimo, en el seminario vimos tambi\u00e9n c\u00f3mo crear nuevas listas a partir de ya existentes con las funciones cons y append . La funci\u00f3n cons crea una lista nueva resultante de a\u00f1adir un elemento al comienzo de la lista. Esta funci\u00f3n es la forma habitual de construir nuevas listas a partir de una lista ya existente y un nuevo elemento. 1 2 3 ( cons 1 ( 1 2 3 4 )) ; \u21d2 {1 1 2 3 4} ( cons hola ( como est \u00e1 s )) ; \u21d2 {hola como est\u00e1s} ( cons ( 1 2 ) ( 1 2 3 4 )) ; \u21d2 {{1 2} 1 2 3 4} La funci\u00f3n append se usa para crear una lista nueva resultado de concatenar dos o m\u00e1s listas 1 2 3 ( define list1 ( 1 2 3 4 )) ( define list2 ( hola como est \u00e1 s )) ( append list1 list2 ) ; \u21d2 {1 2 3 4 hola como est\u00e1s} Lenguajes y Paradigmas de Programaci\u00f3n, curso 2018-19 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Domingo Gallardo, Cristina Pomares, Antonio Bot\u00eda, Francisco Mart\u00ednez","title":"Tema 2: Programaci\u00f3n funcional"},{"location":"teoria/tema02-programacion-funcional/tema02-programacion-funcional.html#tema-2-programacion-funcional","text":"","title":"Tema 2: Programaci\u00f3n funcional"},{"location":"teoria/tema02-programacion-funcional/tema02-programacion-funcional.html#el-paradigma-de-programacion-funcional","text":"","title":"El paradigma de Programaci\u00f3n Funcional"},{"location":"teoria/tema02-programacion-funcional/tema02-programacion-funcional.html#pasado-y-presente-del-paradigma-funcional","text":"","title":"Pasado y presente del paradigma funcional"},{"location":"teoria/tema02-programacion-funcional/tema02-programacion-funcional.html#programacion-declarativa-vs-imperativa","text":"Hemos dicho que la programaci\u00f3n funcional es un estilo de programaci\u00f3n declarativa, frente a la programaci\u00f3n tradicional de los lenguajes denominados imperativos. Vamos a explicar esto un poco m\u00e1s.","title":"Programaci\u00f3n declarativa vs. imperativa"},{"location":"teoria/tema02-programacion-funcional/tema02-programacion-funcional.html#evaluacion-de-expresiones-y-definicion-de-funciones","text":"En la asignatura usaremos Scheme como primer lenguaje en el que exploraremos la programaci\u00f3n funcional. En el seminario de Scheme que se imparte en pr\u00e1cticas se estudiar\u00e1 en m\u00e1s profundidad los conceptos m\u00e1s importantes del lenguaje: tipos de datos, operadores, estructuras de control, int\u00e9rprete, etc.","title":"Evaluaci\u00f3n de expresiones y definici\u00f3n de funciones"},{"location":"teoria/tema02-programacion-funcional/tema02-programacion-funcional.html#modelo-de-computacion-de-sustitucion","text":"Un modelo computacional es un formalismo (conjunto de reglas) que definen el funcionamiento de un programa. En el caso de los lenguajes funcionales basados en la evaluaci\u00f3n de expresiones, el modelo computacional define cu\u00e1l ser\u00e1 el resultado de evaluar una expresi\u00f3n. El modelo de sustituci\u00f3n es un modelo muy sencillo que permite definir la sem\u00e1ntica de la evaluaci\u00f3n de expresiones en lenguajes funcionales como Scheme. Se basa en una versi\u00f3n simplificada de la regla de reducci\u00f3n del c\u00e1lculo lambda. Es un modelo basado en la reescritura de unos t\u00e9rminos por otros. Aunque se trata de un modelo abstracto, ser\u00eda posible escribir un int\u00e9rprete que, bas\u00e1ndose en este modelo, eval\u00fae expresiones funcionales. Supongamos un conjunto de definiciones en Scheme: 1 2 3 4 5 6 7 8 9 10 ( define ( doble x ) ( + x x )) ( define ( cuadrado y ) ( * y y )) ( define ( f z ) ( + ( cuadrado ( doble z )) 1 )) ( define a 2 ) Supongamos que, una vez realizadas esas definiciones, se eval\u00faa la siguiente expresi\u00f3n: 1 ( f ( + a 1 )) \u00bfCu\u00e1l ser\u00e1 su resultado? Si lo hacemos de forma intuitiva podemos pensar que 37 . Si lo comprobamos en el int\u00e9rprete de Scheme veremos que devuelve 37. \u00bfHemos seguido algunas reglas espec\u00edficas? \u00bfQu\u00e9 reglas son las que sigue el int\u00e9rprete? \u00bfPodr\u00edamos implementar nosotros un int\u00e9rprete similar? S\u00ed, usando las reglas del modelo de sustituci\u00f3n. El modelo de sustituci\u00f3n define cuatro reglas sencillas para evaluar una expresi\u00f3n. Llamemos a la expresi\u00f3n e . Las reglas son las siguientes: Si e es un valor primitivo (por ejemplo, un n\u00famero), devolvemos ese mismo valor. Si e es un identificador, devolvemos su valor asociado con un define (se lanzar\u00e1 un error si no existe ese valor). Si e es una expresi\u00f3n del tipo (f arg1 ... argn) , donde f es el nombre de una funci\u00f3n primitiva ( + , - , ...), evaluamos uno a uno los argumentos arg1 ... argn (con estas mismas reglas) y evaluamos la funci\u00f3n primitiva con los resultados. La regla 4 tiene dos variantes, dependiendo del orden de evaluaci\u00f3n que utilizamos. Orden aplicativo Si e es una expresi\u00f3n del tipo (f arg1 ... argn) , donde f es el nombre de una funci\u00f3n definida con un define , tenemos que evaluar primero los argumentos arg1 ... argn y despu\u00e9s sustituir f por su cuerpo , reemplazando cada par\u00e1metro formal de la funci\u00f3n por el correspondiente argumento evaluado. Despu\u00e9s evaluaremos la expresi\u00f3n resultante usando estas mismas reglas. Orden normal Si e es una expresi\u00f3n del tipo (f arg1 ... argn) , donde f es el nombre de una funci\u00f3n definida con un define , tenemos que sustituir f por su cuerpo , reemplazando cada par\u00e1metro formal de la funci\u00f3n por el correspondiente argumento sin evaluar. Despu\u00e9s evaluar la expresi\u00f3n resultante usando estas mismas reglas. Ambas formas de evaluaci\u00f3n dar\u00e1n el mismo resultado en programaci\u00f3n funcional. Scheme utiliza el orden aplicativo. En el siguiente apartado veremos un ejemplo de ambos tipos de evaluaciones.","title":"Modelo de computaci\u00f3n de sustituci\u00f3n"},{"location":"teoria/tema02-programacion-funcional/tema02-programacion-funcional.html#scheme-como-lenguaje-de-programacion-funcional","text":"Ya hemos visto c\u00f3mo definir funciones y evaluar expresiones en Scheme. Vamos continuar con ejemplos concretos de otras caracter\u00edsticas funcionales caracter\u00edsticas funcionales de Scheme. En concreto, veremos: S\u00edmbolos y primitiva quote Uso de listas Definici\u00f3n de funciones recursivas en Scheme","title":"Scheme como lenguaje de programaci\u00f3n funcional"},{"location":"teoria/tema02-programacion-funcional/tema02-programacion-funcional.html#funciones-y-formas-especiales","text":"En el seminario de Scheme hemos visto un conjunto de primitivas que podemos utilizar en Scheme. Podemos clasificar las primitivas en funciones y formas especiales . Las funciones se eval\u00faan usando el modelo de sustituci\u00f3n aplicativo ya visto: Primero se eval\u00faan los argumentos y despu\u00e9s se sustituye la llamada a la funci\u00f3n por su cuerpo y se vuelve a evaluar la expresi\u00f3n resultante. Las expresiones siempre se eval\u00faan desde los par\u00e9ntesis interiores a los exteriores. Las formas especiales son expresiones primitivas de Scheme que tienen una forma de evaluarse propia, distinta de las funciones.","title":"Funciones y formas especiales"},{"location":"teoria/tema02-programacion-funcional/tema02-programacion-funcional.html#formas-especiales-en-scheme-define-if-cond","text":"Veamos la forma de evaluar las distintas formas especiales en Scheme. En estas formas especiales no se aplica el modelo de sustituci\u00f3n, al no ser invocaciones de funciones, sino que cada una se eval\u00faa de una forma diferente.","title":"Formas especiales en Scheme: define, if, cond"},{"location":"teoria/tema02-programacion-funcional/tema02-programacion-funcional.html#forma-especial-quote-y-simbolos","text":"Sintaxis 1 2 ( quote identificador ) ( quote expresion ) Evaluaci\u00f3n Se devuelve el identificador o la expresi\u00f3n sin evaluar . Si la expresi\u00f3n es compuesta (entre par\u00e9ntesis), se devuelve una lista. La expresi\u00f3n puede ser cualquier expresi\u00f3n correcta de Scheme. Se abrevia en con el car\u00e1cter ' . Ejemplo 1 2 ( quote x ) ; el s\u00edmbolo x hola ; el s\u00edmbolo hola A diferencia de los lenguajes imperativos, Scheme trata a los identificadores (nombres que se les da a las variables) como datos del lenguaje de tipo symbol . En el paradigma funcional a los identificadores se les denomina s\u00edmbolos . Los s\u00edmbolos son distintos de las cadenas. Una cadena es un tipo de dato compuesto y se guardan en memoria todos y cada uno de los caracteres que la forman. Sin embargo, los s\u00edmbolos son tipos at\u00f3micos, que se representan en memoria con un \u00fanico valor determinado por el c\u00f3digo hash del identificador. Ejemplos de funciones Scheme con s\u00edmbolos: 1 2 3 4 5 6 7 8 9 10 11 12 13 ( define x 12 ) ( symbol? x ) ; \u21d2 #t ( symbol? x ) ; \u21d2 #f \u00bfPor qu\u00e9? ( symbol? hola-que ) ( symbol- string hola-que ) ma \u00f1 ana l \u00e1 piz ; aunque sea posible, no vamos a usar acentos en los s\u00edmbolos ; pero s\u00ed en los comentarios ( symbol? hola ) ; #f ( symbol? #f ) ; #f ( symbol? ( car ( hola c \u00f3 mo est \u00e1 s ))) ; #t ( equal? hola hola ) ( equal? hola hola ) Un s\u00edmbolo puede asociarse o ligarse ( bind ) a un valor (cualquier dato de primera clase ) con la forma especial define . Cuando escribimos un s\u00edmbolo en el prompt de Scheme el int\u00e9rprete lo eval\u00faa y devuelve su valor: 1 2 3 ( define pi 3.14159 ) pi \u21d2 3.14159 Los nombres de las funciones ( equal? , sin , + , ...) son tambi\u00e9n s\u00edmbolos y Scheme tambi\u00e9n los eval\u00faa (en un par de semanas hablaremos de las funciones como objetos primitivos en Scheme): 1 2 3 4 sin ; \u21d2 # procedure:sin + ; \u21d2 # procedure:+ ( define ( cuadrado x ) ( * x x )) cuadrado ; \u21d2 # procedure:cuadrado Los s\u00edmbolos son tipos primitivos del lenguaje: pueden pasarse como par\u00e1metros o ligarse a variables. 1 2 ( define x hola ) x ; \u21d2 hola","title":"Forma especial quote y s\u00edmbolos"},{"location":"teoria/tema02-programacion-funcional/tema02-programacion-funcional.html#listas","text":"Otra de las caracter\u00edsticas fundamentales del paradigma funcional es la utilizaci\u00f3n de listas. Ya hemos visto en el seminario de Scheme las funciones m\u00e1s importantes para trabajar con ellas. Vamos a repasarlas de nuevo en este apartado, antes de ver alg\u00fan ejemplo de c\u00f3mo usar la recursi\u00f3n con listas. Ya hemos visto en dicho seminario que Scheme es un lenguaje d\u00e9bilmente tipado. Una variable o par\u00e1metro no se declara de un tipo y puede contener cualquier valor. Sucede igual con las listas: una lista en Scheme puede contener cualquier valor, incluyendo otras listas.","title":"Listas"},{"location":"teoria/tema03-procedimientos-recursivos/tema03-procedimientos-recursivos.html","text":"Tema 3: Procedimientos recursivos Ya hemos visto algunos muchos ejemplos de funciones recursivas. Una funci\u00f3n es recursiva cuando se llama a si misma. Una vez que uno se acostumbra a su uso, se comprueba que la recursi\u00f3n es una forma mucho m\u00e1s natural que la iteraci\u00f3n de expresar un gran n\u00famero de funciones y procedimientos. La formulaci\u00f3n matem\u00e1tica de la recursi\u00f3n es sencilla de entender, pero su implementaci\u00f3n en un lenguaje de programaci\u00f3n no lo es tanto. El primer lenguaje de programaci\u00f3n que permiti\u00f3 el uso de expresiones recursivas fue el Lisp. En el momento de su creaci\u00f3n exist\u00eda ya el Fortran, que no permit\u00eda que una funci\u00f3n se llamase a si misma. Ya hemos visto la utilidad de la recursi\u00f3n en muchos ejemplos para recorrer listas, para filtrarlas, etc. En este tema veremos algunos aspectos negativos de la recursi\u00f3n: su coste espacial y temporal. Veremos que hay soluciones a estos problemas, cambiando el estilo de la recursi\u00f3n y generando procesos iterativos o usando un enfoque autom\u00e1tico llamado memoization en el que se guardan los resultados de cada llamada recursiva. Por \u00faltimo, veremos un \u00faltimo ejemplo curioso e interesante de la recursi\u00f3n para realizar figuras fractales con gr\u00e1ficos de tortuga. Pensando recursivamente Para dise\u00f1ar procedimientos recursivos no funciona el m\u00e9todo de prueba y error . Hay que dise\u00f1ar la soluci\u00f3n recursiva desde el principio. Debemos fijarnos en lo que devuelve la funci\u00f3n y debemos preguntarnos c\u00f3mo ser\u00eda posible descomponer el problema de forma que podamos lanzar la recursi\u00f3n sobre una versi\u00f3n m\u00e1s sencilla del mismo. Supondremos que la llamada recursiva funciona correctamente y devuelve el resultado correcto. Y despu\u00e9s debemos transformar este resultado correcto de la versi\u00f3n m\u00e1s peque\u00f1a en el resultado de la soluci\u00f3n completa. Es muy importante escribir y pensar en las funciones de forma declarativa, teniendo en cuenta lo que hacen y no c\u00f3mo lo hacen. Debes confiar en que la llamada recursiva va a hacer su trabajo y devolver el resultado correcto , sin preocuparte de c\u00f3mo lo va a hacer. Despu\u00e9s tendr\u00e1s que utilizar lo que la llamada recursiva ha devuelto para componer la soluci\u00f3n definitiva al problema. Para dise\u00f1ar un algoritmo recursivo es \u00fatil no ponerse a programar directamente, sino reflexionar sobre la soluci\u00f3n recursiva con alg\u00fan ejemplo. El objetivo es obtener una formulaci\u00f3n abstracta del caso general de la recursi\u00f3n antes de programarlo. Una vez que encontramos esta formulaci\u00f3n, pasarlo a un lenguaje de programaci\u00f3n es muy sencillo. Por \u00faltimo, deberemos reflexionar en el caso base. Debe ser el caso m\u00e1s sencillo que puede recibir como par\u00e1metro la recursi\u00f3n. Debe devolver un valor compatible con la definici\u00f3n de la funci\u00f3n. Por ejemplo, si la funci\u00f3n debe construir una lista, el caso base debe devolver tambi\u00e9n una lista. Si la funci\u00f3n construye una pareja, el caso base tambi\u00e9n devolver\u00e1 una pareja. No debemos olvidar que el caso base es tambi\u00e9n un ejemplo de invocaci\u00f3n de la funci\u00f3n. Ya hemos usado todos estos consejos en el tema anterior y en las pr\u00e1cticas realizadas hasta ahora. Veamos ejemplo m\u00e1s. \u00bfc\u00f3mo definimos una lista pal\u00edndroma de forma recursiva?. Por ejemplo, las siguientes listas son pal\u00edndromas: 1 2 3 4 {1 2 3 3 2 1} {1 2 1} {1} () Comenzamos con una definici\u00f3n no recursiva : Una lista es pal\u00edndroma cuando es igual a su inversa. Esta definici\u00f3n no es recursiva porque no llamamos a la recursi\u00f3n con un caso m\u00e1s sencillo. La definici\u00f3n recursiva del caso general es la siguiente: Una lista es pal\u00edndroma cuando su primer elemento es igual que el \u00faltimo y la lista resultante de quitar el primer y el \u00faltimo elemento tambi\u00e9n es pal\u00edndroma En el caso base debemos buscar el caso m\u00e1s peque\u00f1o no contemplado por la definici\u00f3n anterior. En este caso, una lista de un elemento y una lista vac\u00eda tambi\u00e9n las consideraremos pal\u00edndromas. palindroma(lista) = (primer-elemento(lista) == ultimo-elemento(lista)) y palindroma(quitar-primero-ultimo(lista)) palindroma(lista) = un-elemento(lista) o vac\u00eda(lista) Podemos escribir la definici\u00f3n en Scheme, usando la funci\u00f3n or para indicar que la lista es pal\u00edndroma si sucede una de las tres condiciones: 1 2 3 4 5 ( define ( palindroma? lista ) ( or ( null? lista ) ( null? ( cdr lista )) ( and ( equal? ( car lista ) ( ultimo lista )) ( palindroma? ( quitar-primero-ultimo lista ))))) La funci\u00f3n auxiliar quitar-primero-ultimo la podemos definir as\u00ed: 1 2 3 4 5 6 7 8 ( define ( quitar-ultimo lista ) ( if ( null? ( cdr lista )) () ( cons ( car lista ) ( quitar-ultimo ( cdr lista ))))) ( define ( quitar-primero-ultimo lista ) ( cdr ( quitar-ultimo lista ))) El coste de la recursi\u00f3n Hasta ahora hemos estudiado el dise\u00f1o de funciones recursivas. Vamos a tratar por primera vez su coste. Veremos que hay casos en los que es prohibitivo utilizar la recursi\u00f3n tal y como la hemos visto. Y veremos tambi\u00e9n que existen soluciones para esos casos. La pila de la recursi\u00f3n Vamos a estudiar el comportamiento de la evaluaci\u00f3n de una llamada a una funci\u00f3n recursiva. Supongamos la funci\u00f3n mi-length : 1 2 3 4 ( define ( mi-length items ) ( if ( null? items ) 0 ( + 1 ( mi-length ( cdr items ))))) Examinamos c\u00f3mo se eval\u00faan las llamadas recursivas: 1 2 3 4 5 6 7 8 9 10 (mi-length (a b c d)) (+ 1 (mi-length (b c d))) (+ 1 (+ 1 (mi-length (c d)))) (+ 1 (+ 1 (+ 1 (mi-length (d))))) (+ 1 (+ 1 (+ 1 (+ 1 (mi-length ()))))) (+ 1 (+ 1 (+ 1 (+ 1 0)))) (+ 1 (+ 1 (+ 1 1))) (+ 1 (+ 1 2)) (+ 1 3) 4 Cada llamada a la recursi\u00f3n deja una funci\u00f3n en espera de ser evaluada cuando la recursi\u00f3n devuelva un valor (en el caso anterior las funciones suma). Estas llamadas en espera, junto con sus argumentos, se almacenan en la pila de la recursi\u00f3n . Cuando la recursi\u00f3n devuelve un valor, los valores se recuperan de la pila, se realiza la llamada y se devuelve el valor a la anterior llamada en espera. Si la recursi\u00f3n est\u00e1 mal hecha y nunca termina se genera un stack overflow porque la memoria que se almacena en la pila sobrepasa la memoria reservada para el int\u00e9rprete DrRacket. Coste espacial de la recursi\u00f3n El coste espacial de un programa es una funci\u00f3n que relaciona la memoria consumida por una llamada para resolver un problema con alguna variable que determina el tama\u00f1o del problema a resolver. En el caso de la funci\u00f3n mi-length el tama\u00f1o del problema viene dado por la longitud de la lista. El coste espacial de mi-lenght es O(n) , siendo n la longitud de la lista. El coste depende del n\u00famero de llamadas a la recursi\u00f3n Veamos con un ejemplo que el coste de las llamadas recursivas puede dispararse. Supongamos la famosa secuencia de Fibonacci : 0,1,1,2,3,5,8,13,... Formulaci\u00f3n matem\u00e1tica de la secuencia de Fibonacci: 1 2 3 Fibonacci(n) = Fibonacci(n-1) + Fibonacci(n-2) Fibonacci(0) = 0 Fibonacci(1) = 1 Formulaci\u00f3n recursiva en Scheme: 1 2 3 4 5 ( define ( fib n ) ( cond (( = n 0 ) 0 ) (( = n 1 ) 1 ) ( else ( + ( fib ( - n 1 )) ( fib ( - n 2 )))))) Evaluaci\u00f3n de una llamada a Fibonacci: Cada llamada a la recursi\u00f3n produce otras dos llamadas, por lo que el n\u00famero de llamadas finales es 2^n siendo n el n\u00famero que se pasa a la funci\u00f3n. El coste espacial y temporal es exponencial, O(2^n). Esto hace inviable utilizar esta implementaci\u00f3n para realizar el c\u00e1lculo de la funci\u00f3n. Puedes comprobarlo intentando evaluar en el int\u00e9rprete (fib 35) . Soluciones al coste de la recursi\u00f3n: procesos iterativos Diferenciamos entre procedimientos y procesos: un procedimiento es un algoritmo y un proceso es la ejecuci\u00f3n de ese algoritmo. Es posible definir procedimientos recursivos que generen procesos iterativos (como los bucles en programaci\u00f3n imperativa) en los que no se dejen llamadas recursivas en espera ni se incremente la pila de la recursi\u00f3n . Para ello construimos la recursi\u00f3n de forma que en cada llamada se haga un c\u00e1lculo parcial y en el caso base se pueda devolver directamente el resultado obtenido. Este estilo de recursi\u00f3n se denomina recursi\u00f3n por la cola ( tail recursion , en ingl\u00e9s). Se puede realizar una implementaci\u00f3n eficiente de la ejecuci\u00f3n del proceso, eliminando la pila de la recursi\u00f3n. Factorial iterativo Empezamos a explicar la recursi\u00f3n por la cola con un ejemplo muy sencillo: la versi\u00f3n iterativa de la t\u00edpica funci\u00f3n factorial . Le pondremos de nombre a la funci\u00f3n factorial-iter : 1 2 3 4 5 6 7 ( define ( factorial n ) ( fact-iter n n )) ( define ( fact-iter n result ) ( if ( = n 1 ) result ( fact-iter ( - n 1 ) ( * result ( - n 1 )) ))) La funci\u00f3n (fact-iter n result) es la que define el proceso iterativo. Su argumento n es el valor del que hay que calcular el factorial y el argumento result es un par\u00e1metro adicional en el que se van guardando los resultados intermedios. En cada llamada recursiva, n se va haciendo cada vez m\u00e1s peque\u00f1o y en result se va acumulando el c\u00e1lculo del factorial. Al final de la recursi\u00f3n el factorial debe estar calculado en result y se devuelve. Veamos la secuencia de llamadas: 1 2 3 4 5 6 (factorial 4) (factorial-iter 4 4) (factorial-iter 3 4*3=12) (factorial-iter 2 12*2=24) (factorial-iter 1 24*1=24) 24 Antes de realizar cada llamada recursiva se realiza el c\u00e1lculo del resultado parcial, que se guarda en el par\u00e1metro result . Despu\u00e9s se realiza la llamada con el nuevo valor calculado de n y de result . Al final, cuando n vale 1 se devuelve el valor calculado de result . Este valor es el resultado completo de la recursi\u00f3n, ya que no hay que hacer ninguna operaci\u00f3n m\u00e1s con \u00e9l. A diferencia de los procesos recursivos, en los que se quedan llamadas en espera en la pila de la recursi\u00f3n, en los procesos iterativos no hay ninguna llamada en espera. El resultado devuelto por el caso base es directamente la soluci\u00f3n de la recursi\u00f3n, no queda nada por hacer con este resultado. Es importante el valor inicial de resultado . La funci\u00f3n factorial se encarga de inicializar este par\u00e1metro. En este caso es el mismo valor del n\u00famero n a calcular el factorial. La secuencia de llamadas recursivas acumula en la variable result el valor del factorial: 1 4 * 3 * 2 * 1 = 24 Versi\u00f3n iterativa de mi-length Veamos un segundo ejemplo. \u00bfC\u00f3mo ser\u00eda la versi\u00f3n iterativa de mi-length , la funci\u00f3n que calcula la logitud de una lista?. Tenemos que a\u00f1adir un par\u00e1metro adicional en el que iremos acumulando el resultado parcial. En este caso, cada vez que llamemos a la recursi\u00f3n eliminado un elemento de la lista, incrementaremos en 1 el valor del resultado. Para que funcione bien este enfoque, debemos inicializar este resultado a 0. La soluci\u00f3n es la siguiente: 1 2 3 4 5 6 7 ( define ( mi-length lista ) ( mi-length-iter lista 0 )) ( define ( mi-length-iter lista result ) ( if ( null? lista ) result ( mi-length-iter ( cdr lista ) ( + result 1 )))) Fijaros que, al igual que en la versi\u00f3n iterativa de factorial, no hay ninguna llamada a ning\u00fana funci\u00f3n que recoja el resultado de la llamada recursiva y haga algo con \u00e9l. Directamente el resultado de la llamada recursiva es el resultado final de la recursi\u00f3n. Funci\u00f3n suma-lista usando recursi\u00f3n por la cola Veamos otro ejemplo. Supongamos que queremos calcular usando recursi\u00f3n por la cola la suma de los n\u00fameros de una lista. Deber\u00edamos a\u00f1adir un par\u00e1metro adicional en el que vamos acumulando esa suma. Inicializaremos a 0 ese par\u00e1metro e iremos en cada llamada recursiva acumulando el primer elemento de la lista: 1 2 3 4 5 6 7 ( define ( suma-lista lista ) ( suma-lista-iter lista 0 )) ( define ( suma-lista-iter lista result ) ( if ( null? lista ) result ( suma-lista-iter ( cdr lista ) ( + result ( car lista ))))) Procesos iterativos Un resumen de las caracter\u00edsticas de los procesos iterativos resultantes de hacer una recursi\u00f3n por la cola: La recursi\u00f3n resultante es menos elegante. Se necesita una par\u00e1metro adicional en el que se van acumulando los resultados parciales. La \u00faltima llamada a la recursi\u00f3n devuelve el valor acumulado. El proceso resultante de la recursi\u00f3n es iterativo en el sentido de que no deja llamadas en espera ni incurre en coste espacial. Fibonacci iterativo Cualquier programa recursivo se puede transformar en otro que genera un proceso iterativo. En general, las versiones iterativas son menos intuitivas y m\u00e1s dif\u00edciles de entender y depurar. Veamos, por ejemplo, la formulaci\u00f3n iterativa de Fibonacci: 1 2 3 4 5 6 7 ( define ( fib n ) ( fib-iter 1 0 n )) ( define ( fib-iter a b count ) ( if ( = count 0 ) b ( fib-iter ( + a b ) a ( - count 1 )))) La secuencia de llamadas recursivas ser\u00eda la siguiente: 1 2 3 4 5 6 7 8 9 (fib 6) (fib-iter 1 0 6) (fib-iter 1+0=1 1 5) (fib-iter 1+1=2 1 4) (fib-iter 2+1=3 2 3) (fib-iter 3+2=5 3 2) (fib-iter 5+3=8 5 1) (fib-iter 8+5=13 8 0) 8 En la llamada recursiva n , el par\u00e1metro a guarda el valor de fibonacci n+1 y el par\u00e1metro b guarda el valor de fibonacci n , que es el que se devuelve. Conseguimos n llamadas inicializando count a n y decrementando el par\u00e1metro en 1 cada vez. Tri\u00e1ngulo de Pascal El tri\u00e1ngulo de Pascal es el siguiente tri\u00e1ngulo de n\u00fameros. 1 2 3 4 5 6 7 8 9 1 1 1 1 2 1 1 3 3 1 1 4 6 4 1 1 5 10 10 5 1 1 6 15 20 15 6 1 1 7 21 35 35 21 7 1 ... Si numeramos las filas y columnas empezando a contar por 0, la expresi\u00f3n general del valor en una fila y columna determinada se puede obtener con la siguiente definici\u00f3n recursiva: 1 2 3 Pascal (n, 0) = 1 Pascal (n, n) = 1 Pascal (fila, columna) = Pascal (fila-1,columna-1) + Pascal (fila-1, columna) La funci\u00f3n s\u00f3lo est\u00e1 definida para valores de columna menores o iguales que fila . En Scheme es f\u00e1cil escribir una funci\u00f3n recursiva que implemente la definici\u00f3n anterior: 1 2 3 4 5 6 7 8 9 10 11 ( define ( pascal fila col ) ( cond (( = col 0 ) 1 ) (( = col fila ) 1 ) ( else ( + ( pascal ( - fila 1 ) ( - col 1 )) ( pascal ( - fila 1 ) col ) )))) ( pascal 4 2 ) ; \u21d2 6 ( pascal 8 4 ) ; \u21d2 70 ( pascal 27 13 ) ; \u21d2 20058300 Hay que llamar a la funci\u00f3n con un valor de col menor o igual que fila . En el caso en que se pase un valor col mayor que fila la recursi\u00f3n no termina y se entra en un bucle infinito. La funci\u00f3n tiene una formulaci\u00f3n sencilla y funciona correctamente. Sin embargo, el coste de esta recursi\u00f3n es tambi\u00e9n exponencial, igual que pasaba en el caso de la secuencia de fibonacci. Por ejemplo, la \u00faltima expresi\u00f3n (pascal 27 13) tarda un buen rato en devolver el resultado. Ser\u00eda imposible calcular el valor de n\u00fameros de Pascal un poco m\u00e1s grandes, como (pascal 40 20) . Veamos c\u00f3mo se puede conseguir una versi\u00f3n iterativa. La idea es definir una funci\u00f3n iterativa pascal-fila a la que le pasamos el n\u00famero de fila n y nos devuelve la lista de n+1 n\u00fameros que constituyen la fila n del tri\u00e1ngulo de Pascal: 1 2 3 4 5 6 fila 0 = {1} fila 1 = {1 1} fila 2 = {1 2 1} fila 3 = {1 3 3 1} fila 4 = {1 4 6 4 1} ... Esta funci\u00f3n necesitar\u00e1 un par\u00e1metro adicional ( lista-fila ) que se inicializa con la lista {1} y en el que se va guardando cada fila sucesiva. Esta fila va creciendo hasta que llegamos a la fila que tenemos que devolver. Hay que hacer la iteraci\u00f3n n veces, por lo que vamos decrementando el par\u00e1metro n hasta que se llega a 0. Para implementar esta funci\u00f3n usamos otra llamada (pascal-sig-fila lista-fila) que recibe una fila del tri\u00e1ngulo y devuelve la siguiente. Por ejemplo: 1 2 ( pascal-sig-fila ( 1 3 3 1 )) ; \u21d2 {1 4 6 4 1} Esta funci\u00f3n la implementamos con una funci\u00f3n recursiva auxiliar (esta es recursiva pura) llamada (pascal-suma-dos-a-dos lista-fila) que es la que se encarga de realizar el c\u00e1lculo de la nueva fila. El c\u00f3digo completo es el siguiente: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ( define ( pascal fila col ) ( list-ref ( pascal-fila ( 1 ) fila ) col )) ( define ( pascal-fila lista-fila n ) ( if ( = 0 n ) lista-fila ( pascal-fila ( pascal-sig-fila lista-fila ) ( - n 1 )))) ( define ( pascal-sig-fila lista-fila ) ( append ( 1 ) ( pascal-suma-dos-a-dos lista-fila ) ( 1 ))) ( define ( pascal-suma-dos-a-dos lista-fila ) ( if ( null? ( cdr lista-fila )) () ( cons ( + ( car lista-fila ) ( car ( cdr lista-fila ))) ( pascal-suma-dos-a-dos ( cdr lista-fila ))))) Con esta implementaci\u00f3n ya no se tiene un coste exponencial y se puede calcular el valor de n\u00fameros como Pascal(40, 20): 1 2 ( pascal 40 20 ) ; \u21d2 137846528820 Soluciones al coste de la recursi\u00f3n: memoization Una alternativa que mantiene la elegancia de los procesos recursivos y la eficiencia de los iterativos es la memoization . Si miramos la traza de (fibonacci 4) podemos ver que el coste est\u00e1 producido por la repetici\u00f3n de llamadas; por ejemplo (fibonacci 3) se eval\u00faa 2 veces. En programaci\u00f3n funcional la llamada a (fibonacci 3) siempre va a devolver el mismo valor. La idea de la memoization es guardar el valor devuelto por la cada llamada en alguna estructura (una lista de asociaci\u00f3n, por ejemplo) y no volver a realizar la llamada a la recursi\u00f3n las siguientes veces. Fibonacci con memoization Para implementar la memoization necesitamos dos m\u00e9todos imperativos put y get que implementan un diccionario clave-valor . La funci\u00f3n (put key value lista) asocia un valor a una clave, la guarda en la lista (con mutaci\u00f3n) y devuelve el valor. La funci\u00f3n (get key lista) devuelve el valor de la lista asociado a una clave. En el caso en que no exista ning\u00fan valor se devuelve la lista vac\u00eda. Inicialmente la lista debe tener un s\u00edmbolo cualquiera al comienzo. Ejemplos: 1 2 3 4 (define mi-lista (list lista-asoc)) (put 1 10 mi-lista) ; \u21d2 10 (get 1 mi-lista) ; \u21d2 10 (get 2 mi-lista) ; \u21d2 () Estos m\u00e9todos son imperativos porque modifican (mutan) los datos de la lista de asociaci\u00f3n que pasamos como par\u00e1metro. Para implementarlos tenemos que salirnos del paradigma funcional, importando una librer\u00eda de Scheme que permite mutar las parejas. No es importante la implementaci\u00f3n, la dejamos aqu\u00ed como referencia y para poder probar la memoization . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 ( import ( rnrs ) ( rnrs mutable-pairs )) ( define lista ( list lista-asoc )) ( define ( get key lista ) ( define record ( assq key ( cdr lista ))) ( if ( not record ) () ( cdr record ))) ( define ( put key value lista ) ( define record ( assq key ( cdr lista ))) ( if ( not record ) ( set-cdr! lista ( cons ( cons key value ) ( cdr lista ))) ( set-cdr! record value )) value ) La funci\u00f3n fib-memo realiza el c\u00e1lculo de la serie de Fibonacci utilizando exactamente la misma definici\u00f3n recursiva original, pero a\u00f1adiendo la t\u00e9cnica de memoization : lo primero que hacemos para calcular el n\u00famero de fibonacci n , antes de llamar a la recursi\u00f3n, es comprobar si est\u00e1 ya guardado en la lista de asociaci\u00f3n. En el caso en que est\u00e9, lo devolvemos. S\u00f3lo cuando el n\u00famero no est\u00e1 calculado llamamos a la recursi\u00f3n para calcularlo. La implementaci\u00f3n se muestra a continuaci\u00f3n. Vemos que para devolver el n\u00famero de fibonacci n se comprueba si ya est\u00e1 guardado en la lista. S\u00f3lo en el caso en que no est\u00e9 guardado se llama a la recursi\u00f3n para calcularlo y guardarlo. La funci\u00f3n put que guarda el nuevo valor calculado tambi\u00e9n lo devuelve. 1 2 3 4 5 6 7 ( define ( fib-memo n lista ) ( cond (( = n 0 ) 0 ) (( = n 1 ) 1 ) (( not ( null? ( get n lista ))) ( get n lista )) ( else ( put n ( + ( fib-memo ( - n 1 ) lista ) ( fib-memo ( - n 2 ) lista )) lista )))) Podemos comprobar la diferencia de tiempos de ejecuci\u00f3n entre esta versi\u00f3n y la anterior. El coste de la funci\u00f3n memoizada es O(n). Frente al coste O(2^n) de la versi\u00f3n inicial que la hac\u00eda imposible de utilizar. 1 2 ( fib-memo 200 lista ) \u21d2 280571172992510140037611932413038677189525 Recursi\u00f3n y gr\u00e1ficos de tortuga Vamos a terminar el apartado sobre procedimientos recursivos con un \u00faltimo ejemplo algo distinto de los vistos hasta ahora. Usaremos la recursi\u00f3n para dibujar figuras fractales usando los denominados gr\u00e1ficos de tortuga . Para dibujar las figuras tendremos que utilizar un estilo de programaci\u00f3n no funcional, dibujando los distintos trazos de las figuras con pasos de ejecuci\u00f3n secuenciales. Para ello usaremos una primitiva imperativa de Scheme: la forma especial begin que permite realizar un grupo de pasos de ejecuci\u00f3n de forma secuencial. Ten cuidado con la forma especial begin , es una forma especial imperativa. No debes usarla en la implementaci\u00f3n de ninguna funci\u00f3n cuando estemos usando el paradigma funcional. Gr\u00e1ficos de tortuga en Racket Se pueden utilizar los gr\u00e1ficos de tortuga en Racket cargando la librer\u00eda (graphics turtles) : 1 2 3 #lang r6rs ( import ( rnrs ) ( graphics turtles )) Los comandos m\u00e1s importantes de esta librer\u00eda son: (turtles #t) : abre una ventana y coloca la tortuga en el centro, mirando hacia el eje X (derecha) (clear) : borra la ventana y coloca la tortuga en el centro (draw d) : avanza la tortuga dibujando d p\u00edxeles (move d) : mueve la tortuga d p\u00edxeles hacia adelante (sin dibujar) (turn g) : gira la tortuga g grados (positivos: en el sentido contrario a las agujas del reloj) Prueba a realizar algunas figuras con los comandos de tortuga, antes de escribir el algoritmo en Scheme del tri\u00e1ngulo de Sierpinski. Por ejemplo, podemos definir una funci\u00f3n que dibuja un tri\u00e1ngulo rect\u00e1ngulo con catetos de longitud x : 1 2 3 4 5 6 7 8 9 10 11 12 13 ( define ( hipot x ) ( * x ( sqrt 2 ))) ( define ( triangulo-rectangulo x ) ( begin ( draw x ) ( turn 90 ) ( draw x ) ( turn 135 ) ( draw ( hipot x )) ( turn 135 ))) ( triangulo-rectangulo 100 ) La funci\u00f3n (hipot x) devuelve la longitud de la hipotenusa de un tri\u00e1ngulo rect\u00e1ngulo con dos lados de longitud x . O sea, la expresi\u00f3n: $$hipot(x) = \\sqrt{x^2+x^2} = x \\sqrt{2}$$ Como puedes comprobar, el c\u00f3digo es imperativo. La forma especial begin permite realizar una serie de pasos de ejecuci\u00f3n que modifican el estado (posici\u00f3n y orientaci\u00f3n) de la tortuga y dibujan los trazos de la figura. El siguiente c\u00f3digo es una variante del anterior que dibuja un tri\u00e1ngulo rect\u00e1ngulo de base w y lados w/2 . Va a ser la figura base del tri\u00e1ngulo de Sierpinski. 1 2 3 4 5 6 7 8 ( define ( triangle w ) ( begin ( draw w ) ( turn 135 ) ( draw ( hipot ( / w 2 ))) ( turn 90 ) ( draw ( hipot ( / w 2 ))) ( turn 135 ))) Tri\u00e1ngulo de Sierpinski Tri\u00e1ngulo de Sierpinski \u00bfVes alguna recursi\u00f3n en la figura? \u00bfCu\u00e1l podr\u00eda ser el par\u00e1metro de la funci\u00f3n que la dibujara? \u00bfSe te ocurre un algoritmo recursivo que la dibuje? La figura es autosimilar (una caracter\u00edstica de las figuras fractales). Una parte de la figura es id\u00e9ntica a la figura total, pero reducida de escala. Esto nos da una pista de que es posible dibujar la figura con un algoritmo recursivo. Para intentar encontrar una forma de enfocar el problema, vamos a pensarlo de la siguiente forma: supongamos que tenemos un tri\u00e1ngulo de Sierpinski de anchura h y altura h/2 con su esquina inferior izquierda en la posici\u00f3n 0,0. \u00bfC\u00f3mo podr\u00edamos construir el siguiente tri\u00e1ngulo de Sierpinski?. Podr\u00edamos construir un tri\u00e1ngulo de Sierpinski m\u00e1s grande dibujando 3 veces el mismo tri\u00e1ngulo, pero en distintas posiciones: Tri\u00e1ngulo 1 en la posici\u00f3n (0,0) Tri\u00e1ngulo 2 en la posici\u00f3n (h/2,h/2) Tri\u00e1ngulo 3 en la posici\u00f3n (h,0) El algoritmo recursivo se basa en la misma idea, pero hacia atr\u00e1s . Debemos intentar dibujar un tri\u00e1ngulo de altura h situado en la posici\u00f3n x , y bas\u00e1ndonos en 3 llamadas recursivas a tri\u00e1ngulos m\u00e1s peque\u00f1os. En el caso base, cuando h sea menor que un umbral, dibujaremos un tri\u00e1ngulo de lado h y altura h/2 : O sea, que para dibujar un tri\u00e1ngulo de Sierpinski de base h y altura h/2 debemos: Dibujar tres tri\u00e1ngulos de Sierpinsky de la mitad del tama\u00f1o del original ( h/2 ) situadas en las posiciones (x,y) , (x+h/4, y+h/4) y (x+h/2,y) En el caso base de la recursi\u00f3n, en el que h es menor que una constante, se dibuja un tri\u00e1ngulo de base h y altura h/2 . Una versi\u00f3n del algoritmo en pseudoc\u00f3digo : 1 2 3 4 5 6 Sierpinsky (x, y, h): if (h MIN) { Sierpinsky (x, y, h/2) Sierpinsky (x+h/4, y+h/4, h/2) Sierpinsky (x+h/2, y, h/2) } else dibujaTriangulo (x, y, h) Sierpinski en Racket La siguiente es una versi\u00f3n imperativa del algoritmo que dibuja el tri\u00e1ngulo de Sierpinski. No es funcional porque se realizan pasos de ejecuci\u00f3n , usando la forma especial begin o m\u00faltiples instrucciones en una misma funci\u00f3n (por ejemplo la funci\u00f3n triangle ). 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 # lang r6rs ( import ( rnrs ) ( graphics turtles )) ( turtles #t ) ( define ( hipot x ) ( * x ( sqrt 2 ))) ( define ( triangle w ) ( begin ( draw w ) ( turn 135 ) ( draw ( hipot ( / w 2 ))) ( turn 90 ) ( draw ( hipot ( / w 2 ))) ( turn 135 ))) ( define ( sierpinski w ) ( if ( w 20 ) ( begin ( sierpinski ( / w 2 )) ( move ( / w 4 )) ( turn 90 ) ( move ( / w 4 )) ( turn -90 ) ( sierpinski ( / w 2 )) ( turn -90 ) ( move ( / w 4 )) ( turn 90 ) ( move ( / w 4 )) ( sierpinski ( / w 2 )) ( turn 180 ) ( move ( / w 2 )) ( turn -180 )) ;; volvemos a la posici\u00f3n original ( triangle w ))) La llamada a 1 ( sierpinski 40 ) produce la siguiente figura: La llamada a 1 ( sierpinski 700 ) Produce la figura que vimos al principio del apartado: Para ocupar la venta completa debemos desplazar la tortuga hacia atr\u00e1s antes de invocar a sierpinski : 1 2 3 ( clear ) ( move -350 ) ( sierpinski 700 ) Recursi\u00f3n mutua En la recursi\u00f3n mutua definimos una funci\u00f3n en base a una segunda, que a su vez se define en base a la primera. Tambi\u00e9n debe haber un caso base que termine la recursi\u00f3n Por ejemplo: x es par si x-1 es impar x es impar si x-1 es par 0 es par Programas en Scheme: 1 2 3 4 5 6 7 8 9 ( define ( par? x ) ( if ( = 0 x ) #t ( impar? ( - x 1 )))) ( define ( impar? x ) ( if ( = 0 x ) #f ( par? ( - x 1 )))) Ejemplo avanzado: curvas de Hilbert La curva de Hilbert es una curva fractal que tiene la propiedad de rellenar completamente el espacio Su dibujo tiene una formulaci\u00f3n recursiva: La curva H3 se puede construir a partir de la curva H2. El algoritmo recursivo se formula dibujando la curva i-\u00e9sima a partir de la curva i-1. Para dibujar una curva de Hilbert de orden i a la derecha de la tortuga: 1 2 3 4 5 6 7 8 9 10 11 1. Gira la tortuga -90 2. Dibuja una curva de orden i-1 a la izquierda 3. Avanza long dibujando 4. Gira 90 5. Dibuja una curva de orden i-1 a la derecha 6. Avanza long dibujando 7. Dibuja una curva de orden i-1 a la derecha 8. Gira 90 9. Avanza long dibujando 10. Dibuja una curva de orden i-1 a la izquierda 11. Gira -90 El algoritmo para dibujar a la izquierda es sim\u00e9trico. Como en la curva de Sierpinsky, utilizamos la librer\u00eda graphics/turtles , que permite usar la tortuga de Logo con los comandos de Logo draw y turn . Definimos dos funciones sim\u00e9tricas, la funci\u00f3n (h-der i long) que dibuja una curva de Hilbert de orden i con una longitud de trazo long a la derecha de la tortuga y la funci\u00f3n (h-izq i w) que dibuja una curva de Hilbert de orden i con una longitud de trazo long a la izquierda de la tortuga. El algoritmo en Scheme: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 # lang r6rs ( import ( rnrs ) ( graphics turtles )) ( define ( h-der i long ) ( if ( i 0 ) ( begin ( turn -90 ) ( h-izq ( - i 1 ) long ) ( draw long ) ( turn 90 ) ( h-der ( - i 1 ) long ) ( draw long ) ( h-der ( - i 1 ) long ) ( turn 90 ) ( draw long ) ( h-izq ( - i 1 ) long ) ( turn -90 )))) ( define ( h-izq i long ) ( if ( i 0 ) ( begin ( turn 90 ) ( h-der ( - i 1 ) long ) ( draw long ) ( turn -90 ) ( h-izq ( - i 1 ) long ) ( draw long ) ( h-izq ( - i 1 ) long ) ( turn -90 ) ( draw long ) ( h-der ( - i 1 ) long ) ( turn 90 )))) Podemos probarlo con distintos par\u00e1metros de grado de curva y longitud de trazo. Curva de Hilbert de nivel 3 con trazo de longitud 20: 1 2 3 4 5 6 ( clear ) ( move -350 ) ( turn -90 ) ( move 350 ) ( turn 90 ) ( h-izq 3 20 ) Curva de Hilbert de nivel 6 con trazo de longitud 10: 1 2 3 4 5 6 ( clear ) ( move -350 ) ( turn -90 ) ( move 350 ) ( turn 90 ) ( h-izq 6 10 ) Curva de Hilbert de nivel 7 con trazo de longitud 5: 1 2 3 4 5 6 ( clear ) ( move -350 ) ( turn -90 ) ( move 350 ) ( turn 90 ) ( h-izq 7 5 ) Bibliograf\u00eda - SICP En este tema explicamos conceptos de los siguientes cap\u00edtulos del libro Structure and Intepretation of Computer Programs : 1.2 - Procedures and the Processes They Generate 1.2.1 - Linear Recursion and Iteration Lenguajes y Paradigmas de Programaci\u00f3n, curso 2018-19 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Domingo Gallardo, Cristina Pomares, Antonio Bot\u00eda, Francisco Mart\u00ednez","title":"Tema 3: Procedimientos recursivos"},{"location":"teoria/tema03-procedimientos-recursivos/tema03-procedimientos-recursivos.html#tema-3-procedimientos-recursivos","text":"Ya hemos visto algunos muchos ejemplos de funciones recursivas. Una funci\u00f3n es recursiva cuando se llama a si misma. Una vez que uno se acostumbra a su uso, se comprueba que la recursi\u00f3n es una forma mucho m\u00e1s natural que la iteraci\u00f3n de expresar un gran n\u00famero de funciones y procedimientos. La formulaci\u00f3n matem\u00e1tica de la recursi\u00f3n es sencilla de entender, pero su implementaci\u00f3n en un lenguaje de programaci\u00f3n no lo es tanto. El primer lenguaje de programaci\u00f3n que permiti\u00f3 el uso de expresiones recursivas fue el Lisp. En el momento de su creaci\u00f3n exist\u00eda ya el Fortran, que no permit\u00eda que una funci\u00f3n se llamase a si misma. Ya hemos visto la utilidad de la recursi\u00f3n en muchos ejemplos para recorrer listas, para filtrarlas, etc. En este tema veremos algunos aspectos negativos de la recursi\u00f3n: su coste espacial y temporal. Veremos que hay soluciones a estos problemas, cambiando el estilo de la recursi\u00f3n y generando procesos iterativos o usando un enfoque autom\u00e1tico llamado memoization en el que se guardan los resultados de cada llamada recursiva. Por \u00faltimo, veremos un \u00faltimo ejemplo curioso e interesante de la recursi\u00f3n para realizar figuras fractales con gr\u00e1ficos de tortuga.","title":"Tema 3: Procedimientos recursivos"},{"location":"teoria/tema03-procedimientos-recursivos/tema03-procedimientos-recursivos.html#pensando-recursivamente","text":"Para dise\u00f1ar procedimientos recursivos no funciona el m\u00e9todo de prueba y error . Hay que dise\u00f1ar la soluci\u00f3n recursiva desde el principio. Debemos fijarnos en lo que devuelve la funci\u00f3n y debemos preguntarnos c\u00f3mo ser\u00eda posible descomponer el problema de forma que podamos lanzar la recursi\u00f3n sobre una versi\u00f3n m\u00e1s sencilla del mismo. Supondremos que la llamada recursiva funciona correctamente y devuelve el resultado correcto. Y despu\u00e9s debemos transformar este resultado correcto de la versi\u00f3n m\u00e1s peque\u00f1a en el resultado de la soluci\u00f3n completa. Es muy importante escribir y pensar en las funciones de forma declarativa, teniendo en cuenta lo que hacen y no c\u00f3mo lo hacen. Debes confiar en que la llamada recursiva va a hacer su trabajo y devolver el resultado correcto , sin preocuparte de c\u00f3mo lo va a hacer. Despu\u00e9s tendr\u00e1s que utilizar lo que la llamada recursiva ha devuelto para componer la soluci\u00f3n definitiva al problema. Para dise\u00f1ar un algoritmo recursivo es \u00fatil no ponerse a programar directamente, sino reflexionar sobre la soluci\u00f3n recursiva con alg\u00fan ejemplo. El objetivo es obtener una formulaci\u00f3n abstracta del caso general de la recursi\u00f3n antes de programarlo. Una vez que encontramos esta formulaci\u00f3n, pasarlo a un lenguaje de programaci\u00f3n es muy sencillo. Por \u00faltimo, deberemos reflexionar en el caso base. Debe ser el caso m\u00e1s sencillo que puede recibir como par\u00e1metro la recursi\u00f3n. Debe devolver un valor compatible con la definici\u00f3n de la funci\u00f3n. Por ejemplo, si la funci\u00f3n debe construir una lista, el caso base debe devolver tambi\u00e9n una lista. Si la funci\u00f3n construye una pareja, el caso base tambi\u00e9n devolver\u00e1 una pareja. No debemos olvidar que el caso base es tambi\u00e9n un ejemplo de invocaci\u00f3n de la funci\u00f3n. Ya hemos usado todos estos consejos en el tema anterior y en las pr\u00e1cticas realizadas hasta ahora. Veamos ejemplo m\u00e1s. \u00bfc\u00f3mo definimos una lista pal\u00edndroma de forma recursiva?. Por ejemplo, las siguientes listas son pal\u00edndromas: 1 2 3 4 {1 2 3 3 2 1} {1 2 1} {1} () Comenzamos con una definici\u00f3n no recursiva : Una lista es pal\u00edndroma cuando es igual a su inversa. Esta definici\u00f3n no es recursiva porque no llamamos a la recursi\u00f3n con un caso m\u00e1s sencillo. La definici\u00f3n recursiva del caso general es la siguiente: Una lista es pal\u00edndroma cuando su primer elemento es igual que el \u00faltimo y la lista resultante de quitar el primer y el \u00faltimo elemento tambi\u00e9n es pal\u00edndroma En el caso base debemos buscar el caso m\u00e1s peque\u00f1o no contemplado por la definici\u00f3n anterior. En este caso, una lista de un elemento y una lista vac\u00eda tambi\u00e9n las consideraremos pal\u00edndromas. palindroma(lista) = (primer-elemento(lista) == ultimo-elemento(lista)) y palindroma(quitar-primero-ultimo(lista)) palindroma(lista) = un-elemento(lista) o vac\u00eda(lista) Podemos escribir la definici\u00f3n en Scheme, usando la funci\u00f3n or para indicar que la lista es pal\u00edndroma si sucede una de las tres condiciones: 1 2 3 4 5 ( define ( palindroma? lista ) ( or ( null? lista ) ( null? ( cdr lista )) ( and ( equal? ( car lista ) ( ultimo lista )) ( palindroma? ( quitar-primero-ultimo lista ))))) La funci\u00f3n auxiliar quitar-primero-ultimo la podemos definir as\u00ed: 1 2 3 4 5 6 7 8 ( define ( quitar-ultimo lista ) ( if ( null? ( cdr lista )) () ( cons ( car lista ) ( quitar-ultimo ( cdr lista ))))) ( define ( quitar-primero-ultimo lista ) ( cdr ( quitar-ultimo lista )))","title":"Pensando recursivamente"},{"location":"teoria/tema03-procedimientos-recursivos/tema03-procedimientos-recursivos.html#el-coste-de-la-recursion","text":"Hasta ahora hemos estudiado el dise\u00f1o de funciones recursivas. Vamos a tratar por primera vez su coste. Veremos que hay casos en los que es prohibitivo utilizar la recursi\u00f3n tal y como la hemos visto. Y veremos tambi\u00e9n que existen soluciones para esos casos.","title":"El coste de la recursi\u00f3n"},{"location":"teoria/tema03-procedimientos-recursivos/tema03-procedimientos-recursivos.html#la-pila-de-la-recursion","text":"Vamos a estudiar el comportamiento de la evaluaci\u00f3n de una llamada a una funci\u00f3n recursiva. Supongamos la funci\u00f3n mi-length : 1 2 3 4 ( define ( mi-length items ) ( if ( null? items ) 0 ( + 1 ( mi-length ( cdr items ))))) Examinamos c\u00f3mo se eval\u00faan las llamadas recursivas: 1 2 3 4 5 6 7 8 9 10 (mi-length (a b c d)) (+ 1 (mi-length (b c d))) (+ 1 (+ 1 (mi-length (c d)))) (+ 1 (+ 1 (+ 1 (mi-length (d))))) (+ 1 (+ 1 (+ 1 (+ 1 (mi-length ()))))) (+ 1 (+ 1 (+ 1 (+ 1 0)))) (+ 1 (+ 1 (+ 1 1))) (+ 1 (+ 1 2)) (+ 1 3) 4 Cada llamada a la recursi\u00f3n deja una funci\u00f3n en espera de ser evaluada cuando la recursi\u00f3n devuelva un valor (en el caso anterior las funciones suma). Estas llamadas en espera, junto con sus argumentos, se almacenan en la pila de la recursi\u00f3n . Cuando la recursi\u00f3n devuelve un valor, los valores se recuperan de la pila, se realiza la llamada y se devuelve el valor a la anterior llamada en espera. Si la recursi\u00f3n est\u00e1 mal hecha y nunca termina se genera un stack overflow porque la memoria que se almacena en la pila sobrepasa la memoria reservada para el int\u00e9rprete DrRacket.","title":"La pila de la recursi\u00f3n"},{"location":"teoria/tema03-procedimientos-recursivos/tema03-procedimientos-recursivos.html#coste-espacial-de-la-recursion","text":"El coste espacial de un programa es una funci\u00f3n que relaciona la memoria consumida por una llamada para resolver un problema con alguna variable que determina el tama\u00f1o del problema a resolver. En el caso de la funci\u00f3n mi-length el tama\u00f1o del problema viene dado por la longitud de la lista. El coste espacial de mi-lenght es O(n) , siendo n la longitud de la lista.","title":"Coste espacial de la recursi\u00f3n"},{"location":"teoria/tema03-procedimientos-recursivos/tema03-procedimientos-recursivos.html#el-coste-depende-del-numero-de-llamadas-a-la-recursion","text":"Veamos con un ejemplo que el coste de las llamadas recursivas puede dispararse. Supongamos la famosa secuencia de Fibonacci : 0,1,1,2,3,5,8,13,... Formulaci\u00f3n matem\u00e1tica de la secuencia de Fibonacci: 1 2 3 Fibonacci(n) = Fibonacci(n-1) + Fibonacci(n-2) Fibonacci(0) = 0 Fibonacci(1) = 1 Formulaci\u00f3n recursiva en Scheme: 1 2 3 4 5 ( define ( fib n ) ( cond (( = n 0 ) 0 ) (( = n 1 ) 1 ) ( else ( + ( fib ( - n 1 )) ( fib ( - n 2 )))))) Evaluaci\u00f3n de una llamada a Fibonacci: Cada llamada a la recursi\u00f3n produce otras dos llamadas, por lo que el n\u00famero de llamadas finales es 2^n siendo n el n\u00famero que se pasa a la funci\u00f3n. El coste espacial y temporal es exponencial, O(2^n). Esto hace inviable utilizar esta implementaci\u00f3n para realizar el c\u00e1lculo de la funci\u00f3n. Puedes comprobarlo intentando evaluar en el int\u00e9rprete (fib 35) .","title":"El coste depende del n\u00famero de llamadas a la recursi\u00f3n"},{"location":"teoria/tema03-procedimientos-recursivos/tema03-procedimientos-recursivos.html#soluciones-al-coste-de-la-recursion-procesos-iterativos","text":"Diferenciamos entre procedimientos y procesos: un procedimiento es un algoritmo y un proceso es la ejecuci\u00f3n de ese algoritmo. Es posible definir procedimientos recursivos que generen procesos iterativos (como los bucles en programaci\u00f3n imperativa) en los que no se dejen llamadas recursivas en espera ni se incremente la pila de la recursi\u00f3n . Para ello construimos la recursi\u00f3n de forma que en cada llamada se haga un c\u00e1lculo parcial y en el caso base se pueda devolver directamente el resultado obtenido. Este estilo de recursi\u00f3n se denomina recursi\u00f3n por la cola ( tail recursion , en ingl\u00e9s). Se puede realizar una implementaci\u00f3n eficiente de la ejecuci\u00f3n del proceso, eliminando la pila de la recursi\u00f3n.","title":"Soluciones al coste de la recursi\u00f3n: procesos iterativos"},{"location":"teoria/tema03-procedimientos-recursivos/tema03-procedimientos-recursivos.html#factorial-iterativo","text":"Empezamos a explicar la recursi\u00f3n por la cola con un ejemplo muy sencillo: la versi\u00f3n iterativa de la t\u00edpica funci\u00f3n factorial . Le pondremos de nombre a la funci\u00f3n factorial-iter : 1 2 3 4 5 6 7 ( define ( factorial n ) ( fact-iter n n )) ( define ( fact-iter n result ) ( if ( = n 1 ) result ( fact-iter ( - n 1 ) ( * result ( - n 1 )) ))) La funci\u00f3n (fact-iter n result) es la que define el proceso iterativo. Su argumento n es el valor del que hay que calcular el factorial y el argumento result es un par\u00e1metro adicional en el que se van guardando los resultados intermedios. En cada llamada recursiva, n se va haciendo cada vez m\u00e1s peque\u00f1o y en result se va acumulando el c\u00e1lculo del factorial. Al final de la recursi\u00f3n el factorial debe estar calculado en result y se devuelve. Veamos la secuencia de llamadas: 1 2 3 4 5 6 (factorial 4) (factorial-iter 4 4) (factorial-iter 3 4*3=12) (factorial-iter 2 12*2=24) (factorial-iter 1 24*1=24) 24 Antes de realizar cada llamada recursiva se realiza el c\u00e1lculo del resultado parcial, que se guarda en el par\u00e1metro result . Despu\u00e9s se realiza la llamada con el nuevo valor calculado de n y de result . Al final, cuando n vale 1 se devuelve el valor calculado de result . Este valor es el resultado completo de la recursi\u00f3n, ya que no hay que hacer ninguna operaci\u00f3n m\u00e1s con \u00e9l. A diferencia de los procesos recursivos, en los que se quedan llamadas en espera en la pila de la recursi\u00f3n, en los procesos iterativos no hay ninguna llamada en espera. El resultado devuelto por el caso base es directamente la soluci\u00f3n de la recursi\u00f3n, no queda nada por hacer con este resultado. Es importante el valor inicial de resultado . La funci\u00f3n factorial se encarga de inicializar este par\u00e1metro. En este caso es el mismo valor del n\u00famero n a calcular el factorial. La secuencia de llamadas recursivas acumula en la variable result el valor del factorial: 1 4 * 3 * 2 * 1 = 24","title":"Factorial iterativo"},{"location":"teoria/tema03-procedimientos-recursivos/tema03-procedimientos-recursivos.html#version-iterativa-de-mi-length","text":"Veamos un segundo ejemplo. \u00bfC\u00f3mo ser\u00eda la versi\u00f3n iterativa de mi-length , la funci\u00f3n que calcula la logitud de una lista?. Tenemos que a\u00f1adir un par\u00e1metro adicional en el que iremos acumulando el resultado parcial. En este caso, cada vez que llamemos a la recursi\u00f3n eliminado un elemento de la lista, incrementaremos en 1 el valor del resultado. Para que funcione bien este enfoque, debemos inicializar este resultado a 0. La soluci\u00f3n es la siguiente: 1 2 3 4 5 6 7 ( define ( mi-length lista ) ( mi-length-iter lista 0 )) ( define ( mi-length-iter lista result ) ( if ( null? lista ) result ( mi-length-iter ( cdr lista ) ( + result 1 )))) Fijaros que, al igual que en la versi\u00f3n iterativa de factorial, no hay ninguna llamada a ning\u00fana funci\u00f3n que recoja el resultado de la llamada recursiva y haga algo con \u00e9l. Directamente el resultado de la llamada recursiva es el resultado final de la recursi\u00f3n.","title":"Versi\u00f3n iterativa de mi-length"},{"location":"teoria/tema03-procedimientos-recursivos/tema03-procedimientos-recursivos.html#funcion-suma-lista-usando-recursion-por-la-cola","text":"Veamos otro ejemplo. Supongamos que queremos calcular usando recursi\u00f3n por la cola la suma de los n\u00fameros de una lista. Deber\u00edamos a\u00f1adir un par\u00e1metro adicional en el que vamos acumulando esa suma. Inicializaremos a 0 ese par\u00e1metro e iremos en cada llamada recursiva acumulando el primer elemento de la lista: 1 2 3 4 5 6 7 ( define ( suma-lista lista ) ( suma-lista-iter lista 0 )) ( define ( suma-lista-iter lista result ) ( if ( null? lista ) result ( suma-lista-iter ( cdr lista ) ( + result ( car lista )))))","title":"Funci\u00f3n suma-lista usando recursi\u00f3n por la cola"},{"location":"teoria/tema03-procedimientos-recursivos/tema03-procedimientos-recursivos.html#procesos-iterativos","text":"Un resumen de las caracter\u00edsticas de los procesos iterativos resultantes de hacer una recursi\u00f3n por la cola: La recursi\u00f3n resultante es menos elegante. Se necesita una par\u00e1metro adicional en el que se van acumulando los resultados parciales. La \u00faltima llamada a la recursi\u00f3n devuelve el valor acumulado. El proceso resultante de la recursi\u00f3n es iterativo en el sentido de que no deja llamadas en espera ni incurre en coste espacial.","title":"Procesos iterativos"},{"location":"teoria/tema03-procedimientos-recursivos/tema03-procedimientos-recursivos.html#fibonacci-iterativo","text":"Cualquier programa recursivo se puede transformar en otro que genera un proceso iterativo. En general, las versiones iterativas son menos intuitivas y m\u00e1s dif\u00edciles de entender y depurar. Veamos, por ejemplo, la formulaci\u00f3n iterativa de Fibonacci: 1 2 3 4 5 6 7 ( define ( fib n ) ( fib-iter 1 0 n )) ( define ( fib-iter a b count ) ( if ( = count 0 ) b ( fib-iter ( + a b ) a ( - count 1 )))) La secuencia de llamadas recursivas ser\u00eda la siguiente: 1 2 3 4 5 6 7 8 9 (fib 6) (fib-iter 1 0 6) (fib-iter 1+0=1 1 5) (fib-iter 1+1=2 1 4) (fib-iter 2+1=3 2 3) (fib-iter 3+2=5 3 2) (fib-iter 5+3=8 5 1) (fib-iter 8+5=13 8 0) 8 En la llamada recursiva n , el par\u00e1metro a guarda el valor de fibonacci n+1 y el par\u00e1metro b guarda el valor de fibonacci n , que es el que se devuelve. Conseguimos n llamadas inicializando count a n y decrementando el par\u00e1metro en 1 cada vez.","title":"Fibonacci iterativo"},{"location":"teoria/tema03-procedimientos-recursivos/tema03-procedimientos-recursivos.html#triangulo-de-pascal","text":"El tri\u00e1ngulo de Pascal es el siguiente tri\u00e1ngulo de n\u00fameros. 1 2 3 4 5 6 7 8 9 1 1 1 1 2 1 1 3 3 1 1 4 6 4 1 1 5 10 10 5 1 1 6 15 20 15 6 1 1 7 21 35 35 21 7 1 ... Si numeramos las filas y columnas empezando a contar por 0, la expresi\u00f3n general del valor en una fila y columna determinada se puede obtener con la siguiente definici\u00f3n recursiva: 1 2 3 Pascal (n, 0) = 1 Pascal (n, n) = 1 Pascal (fila, columna) = Pascal (fila-1,columna-1) + Pascal (fila-1, columna) La funci\u00f3n s\u00f3lo est\u00e1 definida para valores de columna menores o iguales que fila . En Scheme es f\u00e1cil escribir una funci\u00f3n recursiva que implemente la definici\u00f3n anterior: 1 2 3 4 5 6 7 8 9 10 11 ( define ( pascal fila col ) ( cond (( = col 0 ) 1 ) (( = col fila ) 1 ) ( else ( + ( pascal ( - fila 1 ) ( - col 1 )) ( pascal ( - fila 1 ) col ) )))) ( pascal 4 2 ) ; \u21d2 6 ( pascal 8 4 ) ; \u21d2 70 ( pascal 27 13 ) ; \u21d2 20058300 Hay que llamar a la funci\u00f3n con un valor de col menor o igual que fila . En el caso en que se pase un valor col mayor que fila la recursi\u00f3n no termina y se entra en un bucle infinito. La funci\u00f3n tiene una formulaci\u00f3n sencilla y funciona correctamente. Sin embargo, el coste de esta recursi\u00f3n es tambi\u00e9n exponencial, igual que pasaba en el caso de la secuencia de fibonacci. Por ejemplo, la \u00faltima expresi\u00f3n (pascal 27 13) tarda un buen rato en devolver el resultado. Ser\u00eda imposible calcular el valor de n\u00fameros de Pascal un poco m\u00e1s grandes, como (pascal 40 20) . Veamos c\u00f3mo se puede conseguir una versi\u00f3n iterativa. La idea es definir una funci\u00f3n iterativa pascal-fila a la que le pasamos el n\u00famero de fila n y nos devuelve la lista de n+1 n\u00fameros que constituyen la fila n del tri\u00e1ngulo de Pascal: 1 2 3 4 5 6 fila 0 = {1} fila 1 = {1 1} fila 2 = {1 2 1} fila 3 = {1 3 3 1} fila 4 = {1 4 6 4 1} ... Esta funci\u00f3n necesitar\u00e1 un par\u00e1metro adicional ( lista-fila ) que se inicializa con la lista {1} y en el que se va guardando cada fila sucesiva. Esta fila va creciendo hasta que llegamos a la fila que tenemos que devolver. Hay que hacer la iteraci\u00f3n n veces, por lo que vamos decrementando el par\u00e1metro n hasta que se llega a 0. Para implementar esta funci\u00f3n usamos otra llamada (pascal-sig-fila lista-fila) que recibe una fila del tri\u00e1ngulo y devuelve la siguiente. Por ejemplo: 1 2 ( pascal-sig-fila ( 1 3 3 1 )) ; \u21d2 {1 4 6 4 1} Esta funci\u00f3n la implementamos con una funci\u00f3n recursiva auxiliar (esta es recursiva pura) llamada (pascal-suma-dos-a-dos lista-fila) que es la que se encarga de realizar el c\u00e1lculo de la nueva fila. El c\u00f3digo completo es el siguiente: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ( define ( pascal fila col ) ( list-ref ( pascal-fila ( 1 ) fila ) col )) ( define ( pascal-fila lista-fila n ) ( if ( = 0 n ) lista-fila ( pascal-fila ( pascal-sig-fila lista-fila ) ( - n 1 )))) ( define ( pascal-sig-fila lista-fila ) ( append ( 1 ) ( pascal-suma-dos-a-dos lista-fila ) ( 1 ))) ( define ( pascal-suma-dos-a-dos lista-fila ) ( if ( null? ( cdr lista-fila )) () ( cons ( + ( car lista-fila ) ( car ( cdr lista-fila ))) ( pascal-suma-dos-a-dos ( cdr lista-fila ))))) Con esta implementaci\u00f3n ya no se tiene un coste exponencial y se puede calcular el valor de n\u00fameros como Pascal(40, 20): 1 2 ( pascal 40 20 ) ; \u21d2 137846528820","title":"Tri\u00e1ngulo de Pascal"},{"location":"teoria/tema03-procedimientos-recursivos/tema03-procedimientos-recursivos.html#soluciones-al-coste-de-la-recursion-memoization","text":"Una alternativa que mantiene la elegancia de los procesos recursivos y la eficiencia de los iterativos es la memoization . Si miramos la traza de (fibonacci 4) podemos ver que el coste est\u00e1 producido por la repetici\u00f3n de llamadas; por ejemplo (fibonacci 3) se eval\u00faa 2 veces. En programaci\u00f3n funcional la llamada a (fibonacci 3) siempre va a devolver el mismo valor. La idea de la memoization es guardar el valor devuelto por la cada llamada en alguna estructura (una lista de asociaci\u00f3n, por ejemplo) y no volver a realizar la llamada a la recursi\u00f3n las siguientes veces.","title":"Soluciones al coste de la recursi\u00f3n: memoization"},{"location":"teoria/tema03-procedimientos-recursivos/tema03-procedimientos-recursivos.html#fibonacci-con-memoization","text":"Para implementar la memoization necesitamos dos m\u00e9todos imperativos put y get que implementan un diccionario clave-valor . La funci\u00f3n (put key value lista) asocia un valor a una clave, la guarda en la lista (con mutaci\u00f3n) y devuelve el valor. La funci\u00f3n (get key lista) devuelve el valor de la lista asociado a una clave. En el caso en que no exista ning\u00fan valor se devuelve la lista vac\u00eda. Inicialmente la lista debe tener un s\u00edmbolo cualquiera al comienzo. Ejemplos: 1 2 3 4 (define mi-lista (list lista-asoc)) (put 1 10 mi-lista) ; \u21d2 10 (get 1 mi-lista) ; \u21d2 10 (get 2 mi-lista) ; \u21d2 () Estos m\u00e9todos son imperativos porque modifican (mutan) los datos de la lista de asociaci\u00f3n que pasamos como par\u00e1metro. Para implementarlos tenemos que salirnos del paradigma funcional, importando una librer\u00eda de Scheme que permite mutar las parejas. No es importante la implementaci\u00f3n, la dejamos aqu\u00ed como referencia y para poder probar la memoization . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 ( import ( rnrs ) ( rnrs mutable-pairs )) ( define lista ( list lista-asoc )) ( define ( get key lista ) ( define record ( assq key ( cdr lista ))) ( if ( not record ) () ( cdr record ))) ( define ( put key value lista ) ( define record ( assq key ( cdr lista ))) ( if ( not record ) ( set-cdr! lista ( cons ( cons key value ) ( cdr lista ))) ( set-cdr! record value )) value ) La funci\u00f3n fib-memo realiza el c\u00e1lculo de la serie de Fibonacci utilizando exactamente la misma definici\u00f3n recursiva original, pero a\u00f1adiendo la t\u00e9cnica de memoization : lo primero que hacemos para calcular el n\u00famero de fibonacci n , antes de llamar a la recursi\u00f3n, es comprobar si est\u00e1 ya guardado en la lista de asociaci\u00f3n. En el caso en que est\u00e9, lo devolvemos. S\u00f3lo cuando el n\u00famero no est\u00e1 calculado llamamos a la recursi\u00f3n para calcularlo. La implementaci\u00f3n se muestra a continuaci\u00f3n. Vemos que para devolver el n\u00famero de fibonacci n se comprueba si ya est\u00e1 guardado en la lista. S\u00f3lo en el caso en que no est\u00e9 guardado se llama a la recursi\u00f3n para calcularlo y guardarlo. La funci\u00f3n put que guarda el nuevo valor calculado tambi\u00e9n lo devuelve. 1 2 3 4 5 6 7 ( define ( fib-memo n lista ) ( cond (( = n 0 ) 0 ) (( = n 1 ) 1 ) (( not ( null? ( get n lista ))) ( get n lista )) ( else ( put n ( + ( fib-memo ( - n 1 ) lista ) ( fib-memo ( - n 2 ) lista )) lista )))) Podemos comprobar la diferencia de tiempos de ejecuci\u00f3n entre esta versi\u00f3n y la anterior. El coste de la funci\u00f3n memoizada es O(n). Frente al coste O(2^n) de la versi\u00f3n inicial que la hac\u00eda imposible de utilizar. 1 2 ( fib-memo 200 lista ) \u21d2 280571172992510140037611932413038677189525","title":"Fibonacci con memoization"},{"location":"teoria/tema03-procedimientos-recursivos/tema03-procedimientos-recursivos.html#recursion-y-graficos-de-tortuga","text":"Vamos a terminar el apartado sobre procedimientos recursivos con un \u00faltimo ejemplo algo distinto de los vistos hasta ahora. Usaremos la recursi\u00f3n para dibujar figuras fractales usando los denominados gr\u00e1ficos de tortuga . Para dibujar las figuras tendremos que utilizar un estilo de programaci\u00f3n no funcional, dibujando los distintos trazos de las figuras con pasos de ejecuci\u00f3n secuenciales. Para ello usaremos una primitiva imperativa de Scheme: la forma especial begin que permite realizar un grupo de pasos de ejecuci\u00f3n de forma secuencial. Ten cuidado con la forma especial begin , es una forma especial imperativa. No debes usarla en la implementaci\u00f3n de ninguna funci\u00f3n cuando estemos usando el paradigma funcional.","title":"Recursi\u00f3n y gr\u00e1ficos de tortuga"},{"location":"teoria/tema03-procedimientos-recursivos/tema03-procedimientos-recursivos.html#graficos-de-tortuga-en-racket","text":"Se pueden utilizar los gr\u00e1ficos de tortuga en Racket cargando la librer\u00eda (graphics turtles) : 1 2 3 #lang r6rs ( import ( rnrs ) ( graphics turtles )) Los comandos m\u00e1s importantes de esta librer\u00eda son: (turtles #t) : abre una ventana y coloca la tortuga en el centro, mirando hacia el eje X (derecha) (clear) : borra la ventana y coloca la tortuga en el centro (draw d) : avanza la tortuga dibujando d p\u00edxeles (move d) : mueve la tortuga d p\u00edxeles hacia adelante (sin dibujar) (turn g) : gira la tortuga g grados (positivos: en el sentido contrario a las agujas del reloj) Prueba a realizar algunas figuras con los comandos de tortuga, antes de escribir el algoritmo en Scheme del tri\u00e1ngulo de Sierpinski. Por ejemplo, podemos definir una funci\u00f3n que dibuja un tri\u00e1ngulo rect\u00e1ngulo con catetos de longitud x : 1 2 3 4 5 6 7 8 9 10 11 12 13 ( define ( hipot x ) ( * x ( sqrt 2 ))) ( define ( triangulo-rectangulo x ) ( begin ( draw x ) ( turn 90 ) ( draw x ) ( turn 135 ) ( draw ( hipot x )) ( turn 135 ))) ( triangulo-rectangulo 100 ) La funci\u00f3n (hipot x) devuelve la longitud de la hipotenusa de un tri\u00e1ngulo rect\u00e1ngulo con dos lados de longitud x . O sea, la expresi\u00f3n: $$hipot(x) = \\sqrt{x^2+x^2} = x \\sqrt{2}$$ Como puedes comprobar, el c\u00f3digo es imperativo. La forma especial begin permite realizar una serie de pasos de ejecuci\u00f3n que modifican el estado (posici\u00f3n y orientaci\u00f3n) de la tortuga y dibujan los trazos de la figura. El siguiente c\u00f3digo es una variante del anterior que dibuja un tri\u00e1ngulo rect\u00e1ngulo de base w y lados w/2 . Va a ser la figura base del tri\u00e1ngulo de Sierpinski. 1 2 3 4 5 6 7 8 ( define ( triangle w ) ( begin ( draw w ) ( turn 135 ) ( draw ( hipot ( / w 2 ))) ( turn 90 ) ( draw ( hipot ( / w 2 ))) ( turn 135 )))","title":"Gr\u00e1ficos de tortuga en Racket"},{"location":"teoria/tema03-procedimientos-recursivos/tema03-procedimientos-recursivos.html#triangulo-de-sierpinski","text":"Tri\u00e1ngulo de Sierpinski \u00bfVes alguna recursi\u00f3n en la figura? \u00bfCu\u00e1l podr\u00eda ser el par\u00e1metro de la funci\u00f3n que la dibujara? \u00bfSe te ocurre un algoritmo recursivo que la dibuje? La figura es autosimilar (una caracter\u00edstica de las figuras fractales). Una parte de la figura es id\u00e9ntica a la figura total, pero reducida de escala. Esto nos da una pista de que es posible dibujar la figura con un algoritmo recursivo. Para intentar encontrar una forma de enfocar el problema, vamos a pensarlo de la siguiente forma: supongamos que tenemos un tri\u00e1ngulo de Sierpinski de anchura h y altura h/2 con su esquina inferior izquierda en la posici\u00f3n 0,0. \u00bfC\u00f3mo podr\u00edamos construir el siguiente tri\u00e1ngulo de Sierpinski?. Podr\u00edamos construir un tri\u00e1ngulo de Sierpinski m\u00e1s grande dibujando 3 veces el mismo tri\u00e1ngulo, pero en distintas posiciones: Tri\u00e1ngulo 1 en la posici\u00f3n (0,0) Tri\u00e1ngulo 2 en la posici\u00f3n (h/2,h/2) Tri\u00e1ngulo 3 en la posici\u00f3n (h,0) El algoritmo recursivo se basa en la misma idea, pero hacia atr\u00e1s . Debemos intentar dibujar un tri\u00e1ngulo de altura h situado en la posici\u00f3n x , y bas\u00e1ndonos en 3 llamadas recursivas a tri\u00e1ngulos m\u00e1s peque\u00f1os. En el caso base, cuando h sea menor que un umbral, dibujaremos un tri\u00e1ngulo de lado h y altura h/2 : O sea, que para dibujar un tri\u00e1ngulo de Sierpinski de base h y altura h/2 debemos: Dibujar tres tri\u00e1ngulos de Sierpinsky de la mitad del tama\u00f1o del original ( h/2 ) situadas en las posiciones (x,y) , (x+h/4, y+h/4) y (x+h/2,y) En el caso base de la recursi\u00f3n, en el que h es menor que una constante, se dibuja un tri\u00e1ngulo de base h y altura h/2 . Una versi\u00f3n del algoritmo en pseudoc\u00f3digo : 1 2 3 4 5 6 Sierpinsky (x, y, h): if (h MIN) { Sierpinsky (x, y, h/2) Sierpinsky (x+h/4, y+h/4, h/2) Sierpinsky (x+h/2, y, h/2) } else dibujaTriangulo (x, y, h)","title":"Tri\u00e1ngulo de Sierpinski"},{"location":"teoria/tema03-procedimientos-recursivos/tema03-procedimientos-recursivos.html#sierpinski-en-racket","text":"La siguiente es una versi\u00f3n imperativa del algoritmo que dibuja el tri\u00e1ngulo de Sierpinski. No es funcional porque se realizan pasos de ejecuci\u00f3n , usando la forma especial begin o m\u00faltiples instrucciones en una misma funci\u00f3n (por ejemplo la funci\u00f3n triangle ). 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 # lang r6rs ( import ( rnrs ) ( graphics turtles )) ( turtles #t ) ( define ( hipot x ) ( * x ( sqrt 2 ))) ( define ( triangle w ) ( begin ( draw w ) ( turn 135 ) ( draw ( hipot ( / w 2 ))) ( turn 90 ) ( draw ( hipot ( / w 2 ))) ( turn 135 ))) ( define ( sierpinski w ) ( if ( w 20 ) ( begin ( sierpinski ( / w 2 )) ( move ( / w 4 )) ( turn 90 ) ( move ( / w 4 )) ( turn -90 ) ( sierpinski ( / w 2 )) ( turn -90 ) ( move ( / w 4 )) ( turn 90 ) ( move ( / w 4 )) ( sierpinski ( / w 2 )) ( turn 180 ) ( move ( / w 2 )) ( turn -180 )) ;; volvemos a la posici\u00f3n original ( triangle w ))) La llamada a 1 ( sierpinski 40 ) produce la siguiente figura: La llamada a 1 ( sierpinski 700 ) Produce la figura que vimos al principio del apartado: Para ocupar la venta completa debemos desplazar la tortuga hacia atr\u00e1s antes de invocar a sierpinski : 1 2 3 ( clear ) ( move -350 ) ( sierpinski 700 )","title":"Sierpinski en Racket"},{"location":"teoria/tema03-procedimientos-recursivos/tema03-procedimientos-recursivos.html#recursion-mutua","text":"En la recursi\u00f3n mutua definimos una funci\u00f3n en base a una segunda, que a su vez se define en base a la primera. Tambi\u00e9n debe haber un caso base que termine la recursi\u00f3n Por ejemplo: x es par si x-1 es impar x es impar si x-1 es par 0 es par Programas en Scheme: 1 2 3 4 5 6 7 8 9 ( define ( par? x ) ( if ( = 0 x ) #t ( impar? ( - x 1 )))) ( define ( impar? x ) ( if ( = 0 x ) #f ( par? ( - x 1 ))))","title":"Recursi\u00f3n mutua"},{"location":"teoria/tema03-procedimientos-recursivos/tema03-procedimientos-recursivos.html#ejemplo-avanzado-curvas-de-hilbert","text":"La curva de Hilbert es una curva fractal que tiene la propiedad de rellenar completamente el espacio Su dibujo tiene una formulaci\u00f3n recursiva: La curva H3 se puede construir a partir de la curva H2. El algoritmo recursivo se formula dibujando la curva i-\u00e9sima a partir de la curva i-1. Para dibujar una curva de Hilbert de orden i a la derecha de la tortuga: 1 2 3 4 5 6 7 8 9 10 11 1. Gira la tortuga -90 2. Dibuja una curva de orden i-1 a la izquierda 3. Avanza long dibujando 4. Gira 90 5. Dibuja una curva de orden i-1 a la derecha 6. Avanza long dibujando 7. Dibuja una curva de orden i-1 a la derecha 8. Gira 90 9. Avanza long dibujando 10. Dibuja una curva de orden i-1 a la izquierda 11. Gira -90 El algoritmo para dibujar a la izquierda es sim\u00e9trico. Como en la curva de Sierpinsky, utilizamos la librer\u00eda graphics/turtles , que permite usar la tortuga de Logo con los comandos de Logo draw y turn . Definimos dos funciones sim\u00e9tricas, la funci\u00f3n (h-der i long) que dibuja una curva de Hilbert de orden i con una longitud de trazo long a la derecha de la tortuga y la funci\u00f3n (h-izq i w) que dibuja una curva de Hilbert de orden i con una longitud de trazo long a la izquierda de la tortuga. El algoritmo en Scheme: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 # lang r6rs ( import ( rnrs ) ( graphics turtles )) ( define ( h-der i long ) ( if ( i 0 ) ( begin ( turn -90 ) ( h-izq ( - i 1 ) long ) ( draw long ) ( turn 90 ) ( h-der ( - i 1 ) long ) ( draw long ) ( h-der ( - i 1 ) long ) ( turn 90 ) ( draw long ) ( h-izq ( - i 1 ) long ) ( turn -90 )))) ( define ( h-izq i long ) ( if ( i 0 ) ( begin ( turn 90 ) ( h-der ( - i 1 ) long ) ( draw long ) ( turn -90 ) ( h-izq ( - i 1 ) long ) ( draw long ) ( h-izq ( - i 1 ) long ) ( turn -90 ) ( draw long ) ( h-der ( - i 1 ) long ) ( turn 90 )))) Podemos probarlo con distintos par\u00e1metros de grado de curva y longitud de trazo. Curva de Hilbert de nivel 3 con trazo de longitud 20: 1 2 3 4 5 6 ( clear ) ( move -350 ) ( turn -90 ) ( move 350 ) ( turn 90 ) ( h-izq 3 20 ) Curva de Hilbert de nivel 6 con trazo de longitud 10: 1 2 3 4 5 6 ( clear ) ( move -350 ) ( turn -90 ) ( move 350 ) ( turn 90 ) ( h-izq 6 10 ) Curva de Hilbert de nivel 7 con trazo de longitud 5: 1 2 3 4 5 6 ( clear ) ( move -350 ) ( turn -90 ) ( move 350 ) ( turn 90 ) ( h-izq 7 5 )","title":"Ejemplo avanzado: curvas de Hilbert"},{"location":"teoria/tema03-procedimientos-recursivos/tema03-procedimientos-recursivos.html#bibliografia-sicp","text":"En este tema explicamos conceptos de los siguientes cap\u00edtulos del libro Structure and Intepretation of Computer Programs : 1.2 - Procedures and the Processes They Generate 1.2.1 - Linear Recursion and Iteration Lenguajes y Paradigmas de Programaci\u00f3n, curso 2018-19 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Domingo Gallardo, Cristina Pomares, Antonio Bot\u00eda, Francisco Mart\u00ednez","title":"Bibliograf\u00eda - SICP"},{"location":"teoria/tema04-estructuras-recursivas/tema04-estructuras-recursivas.html","text":"Tema 4: Estructuras de datos recursivas Listas estructuradas Hemos visto que las listas en Scheme se implementan como un estructura de datos recursiva, formada por una pareja que enlaza en su parte derecha el resto de la lista y que termina con una parte derecha en la que hay una lista vac\u00eda. En este apartado vamos a volver a estudiar las listas desde un nivel de abstracci\u00f3n alto, usando las funciones: (car lista) para obtener el primer elemento de una lista (cdr lista) para obtener el resto de la lista (cons dato lista) para construir una nueva lista con el dato como primer elemento En la mayor\u00eda de funciones y ejemplos que hemos visto hasta ahora las listas est\u00e1n formadas por datos y el recorrido por la lista es un recorrido lineal, iterando por sus elementos. En este apartado vamos a ampliar este concepto y estudiar c\u00f3mo trabajar con listas que contienen otras listas . Veremos que esto cambia fundamentalmente la estructura de las listas y de las funciones que van a operar con ellas. El cambio fundamental es que la funci\u00f3n car lista puede devolver dos tipos de elementos: Un elemento de la lista (del tipo de elementos que hay en la lista) Otra lista (formada por el tipo de elementos de la lista) Definici\u00f3n y ejemplos Las listas en Scheme pueden tener cualquier tipo de elementos, incluido otras listas. Llamaremos lista estructurada a una lista que contiene otras sublistas. Lo contrario de lista estructurada es una lista plana , una lista formada por elementos que no son listas. Llamaremos hojas a los elementos de una lista que no son sublistas. A las listas estructuradas cuyas hojas son s\u00edmbolos se les denomina en el contexto de la programaci\u00f3n funcional expresiones-S ( S-expression ). Por ejemplo, la lista estructurada: 1 (a b (c d e) (f (g h))) es una lista estructurada con 4 elementos: El elemento 'a , una hoja El elemento 'b , otra hoja La lista plana '(c d e) La lista estructurada '(f (g h)) Se puede construir con cualquiera de las siguientes expresiones: 1 2 (define lista (list a b (list c d e) (list f (list g h)))) (define lista (a b (c d e) (f (g h)))) Una lista formada por parejas la consideraremos una lista plana, ya que no contiene ninguna sublista. Por ejemplo, la lista 1 ((a . 3) (b . 5) (c . 12)) es una lista plana de tres elementos (hojas) que son parejas. Definiciones en Scheme Vamos a escribir las definiciones anteriores de hoja , plana y estructurada usando c\u00f3digo de Scheme. Funci\u00f3n (hoja? dato) Un dato es una hoja si no es una lista: 1 2 (define (hoja? dato) (not (list? dato))) Utilizaremos esta funci\u00f3n para comprobar si un determinado elemento de una lista es o no una hoja. Por ejemplo, supongamos la siguiente lista: 1 ((1 2) 3 4 (5 6)) Es una lista de 4 elementos, siendo el primero y el \u00faltimo otras sublistas y el segundo y el tercero hojas. Podemos comprobar si son o no hojas sus elementos: 1 2 3 4 5 (define lista ((1 2) 3 4 (5 6))) (hoja? (car lista)) ; \u21d2 #f (hoja? (cadr lista)) ; \u21d2 #t (hoja? (caddr lista)) ; \u21d2 #t (hoja? (cadddr lista)) ; \u21d2 #f La lista vac\u00eda no es una hoja 1 (hoja? ()) ; \u21d2 #f Funci\u00f3n (plana? lista) Una definici\u00f3n recursiva de lista plana: Una lista es plana si y solo si el primer elemento es una hoja y el resto es plana. Y el caso base: Una lista vac\u00eda es plana. Usando esta definici\u00f3n recursiva, podemos implementar en Scheme la funci\u00f3n (plana? lista) que comprueba si una lista es plana: 1 2 3 4 (define (plana? lista) (or (null? lista) (and (hoja? (car lista)) (plana? (cdr lista))))) Ejemplos: 1 2 3 4 ( plana? ( a b c d e f )) ; \u21d2 #t ( plana? ( list ( cons a 1 ) Hola #f )) ; \u21d2 #t ( plana? ( a ( b c ) d )) ; \u21d2 #f ( plana? ( a () b )) ; \u21d2 #f Funci\u00f3n (estructurada? lista) Una lista es estructurada cuando alguno de sus elementos es otra lista: 1 2 3 4 5 (define (estructurada? lista) (if (null? lista) #f (or (list? (car lista)) (estructurada? (cdr lista))))) Ejemplos: 1 2 3 4 ( estructurada? ( 1 2 3 4 )) ; \u21d2 #f ( estructurada? ( list ( cons a 1 ) ( cons b 2 ) ( cons c 3 ))) ; \u21d2 #f ( estructurada? ( a () b )) ; \u21d2 #t ( estructurada? ( a ( b c ) d )) ; \u21d2 #t Realmente bastar\u00eda con haber hecho una de las dos definiciones y escribir la otra como la negaci\u00f3n de la primera: 1 2 (define (estructurada? lista) (not (plana? lista))) Ejemplos de listas estructuradas Las listas estructuradas son muy \u00fatiles para representar informaci\u00f3n jer\u00e1rquica en donde queremos representar elementos que contienen otros elementos. Por ejemplo, las expresiones de Scheme son listas estructuradas: 1 2 3 ( = 4 ( + 2 2 )) ( if ( = x y ) ( * x y ) ( + ( / x y ) 45 )) ( define ( factorial x ) ( if ( = x 0 ) 1 ( * x ( factorial ( - x 1 ))))) El an\u00e1lisis sint\u00e1ctico de una oraci\u00f3n puede generar una lista estructurada de s\u00edmbolos, en donde se agrupan los distintos elementos de la oraci\u00f3n: 1 (( Juan ) ( compr \u00f3 ) ( la entrada ( de los Miserables )) ( el viernes por la tarde )) Una p\u00e1gina HTML, con sus distintos elementos, unos dentro de otros, tambi\u00e9n se puede representar con una lista estructurada: 1 2 3 4 (( h1 Mi lista de la compra /h1 ) ( ul ( li naranjas /li ) ( li tomates /li ) ( li huevos /li } /ul )) Pseudo \u00e1rboles con niveles Las listas estructuradas definen una estructura de niveles, donde la lista inicial representa el primer nivel, y cada sublista representa un nivel inferior. Los datos de las listas representan las hojas. Por ejemplo, la representaci\u00f3n en forma de niveles de la lista ((a b c) d e) es la siguiente: Las hojas d y e est\u00e1n en el nivel 1 y en las posiciones 2 y 3 de la lista y las hojas a , b y c en el nivel 2 y en la posici\u00f3n 1 de la lista. UNA LISTA ESTRUCTURADA NO ES UN \u00c1RBOL Una lista estructurada no es un \u00e1rbol propiamente dicho, porque todos los datos est\u00e1n en las hojas. Otro ejemplo. \u00bfCu\u00e1l ser\u00eda la representaci\u00f3n en niveles de la siguiente lista estructurada?: 1 2 3 ( let (( x 12 ) ( y 5 )) ( + x y )) Funciones recursivas sobre listas estructuradas N\u00famero de hojas Veamos como primer ejemplo la funci\u00f3n (num-hojas lista) que cuenta el n\u00famero de hojas de una lista estructurada. Por ejemplo: 1 (num-hojas ((1 2) (3 4 (5) 6) (7))) \u21d2 7 Como hemos comentado antes, una cuesti\u00f3n clave en las funciones que vamos a construir sobre listas estructuradas es que el car de una lista estructurada puede ser a su vez otra lista. Para calcular el n\u00famero de hojas de una lista podemos obtener el primer elemento y el resto de la lista, y contar recursivamente el n\u00famero de hojas del primer elemento y del resto. Al ser una lista estructurada, el primer elemento puede ser a su vez otra lista, por lo que llamamos a la recursi\u00f3n para contar sus hojas. La definici\u00f3n de este caso general usando pseudoc\u00f3digo es: El n\u00famero de hojas de una lista estructurada es la suma del n\u00famero de hojas de su primer elemento (que puede ser otra lista) y del n\u00famero de hojas del resto. Como casos base, podemos considerar cuando la lista es vac\u00eda (el n\u00famero de hojas es 0) y cuando la lista no es tal, sino que es un dato (una hoja), en cuyo caso es 1. En la implementaci\u00f3n siguiente llamamos siempre a la recursi\u00f3n por el car y por el cdr . Si el car es una lista o una hoja se determinar\u00e1 dentro de esa llamada recursiva. 1 2 3 4 5 6 ( define ( num-hojas x ) ( cond (( null? x ) 0 ) (( hoja? x ) 1 ) ( else ( + ( num-hojas ( car x )) ( num-hojas ( cdr x )))))) Hay que hacer notar que el par\u00e1metro x puede ser tanto una lista como un dato at\u00f3mico (una hoja). Estamos aprovech\u00e1ndonos de la caracter\u00edstica de Scheme de ser d\u00e9bilmente tipeado para hacer un c\u00f3digo bastante conciso. Versi\u00f3n con funciones de orden superior Podemos usar tambi\u00e9n las funciones de orden superior map y fold-right para obtener una versi\u00f3n m\u00e1s concisa. Una lista estructurada tiene como elementos en un primer nivel hojas o otras sublistas. Podemos entonces mapear una expresi\u00f3n lambda que se aplica a cada uno de esos elementos. En la expresi\u00f3n lambda comprobamos si el elemento (el par\u00e1metro sublista de la expresi\u00f3n lambda) es una hoja o una lista. En el primero caso devolvemos 1. En el segundo aplicaremos la propia funci\u00f3n que estamos definiendo sobre la sublista, con lo que se devolver\u00e1 el n\u00famero de hojas de esa sublista. El resultado del map ser\u00e1 una lista de n\u00fameros (el n\u00famero de hojas de cada componente), que podemos sumar haciendo un fold-right con la funci\u00f3n + : 1 2 3 4 5 ( define ( num-hojas-fos lista ) ( fold-right + 0 ( map ( lambda ( elem ) ( if ( hoja? elem ) 1 ( num-hojas-fos elem ))) lista ))) Una explicaci\u00f3n gr\u00e1fica de c\u00f3mo funciona la funci\u00f3n sobre la lista '(1 (2 3) (4) (5 (6 7) 8)) : Altura de una lista estructurada La altura de una lista estructurada viene dada por su n\u00famero de niveles: una lista plana tiene una altura de 1, la lista '((1 2 3) 4 5) tiene una altura de 2. Para calcular la altura de una lista estructurada tenemos que obtener (de forma recursiva) la altura de su primer elemento, y la altura del resto de la lista, sumarle 1 a la altura del primer elemento y devolver el m\u00e1ximo de los dos n\u00fameros. Como casos base, la altura de una lista vac\u00eda o de una hoja (dato) es 0. En Scheme: 1 2 3 4 5 6 ( define ( altura x ) ( cond (( null? x ) 0 ) (( hoja? x ) 0 ) ( else ( max ( + 1 ( altura ( car x ))) ( altura ( cdr x )))))) Por ejemplo: 1 2 ( altura ( 1 ( 2 3 ) 4 )) \u21d2 2 ( altura ( 1 ( 2 ( 3 )) 3 )) \u21d2 3 Versi\u00f3n con funciones de orden superior Y la segunda versi\u00f3n, usando las funciones de orden superior map para obtener la altura de sus elementos del primer nivel (puedes ser hojas o sublistas) y fold-right para quedarse con el m\u00e1ximo de la lista de valores que devuelve el map. 1 2 3 4 5 ( define ( altura-fos lista ) ( + 1 ( fold-right max 0 ( map ( lambda ( elem ) ( if ( hoja? elem ) 0 ( altura-fos elem ))) lista )))) Otras funciones recursivas Vamos a dise\u00f1ar otras funciones recursivas que trabajan con la estructura jer\u00e1rquica de las listas estructuradas. (aplana lista) : devuelve una lista plana con todas las hojas de la lista (pertenece-lista? dato lista) : busca una hoja en una lista estructurada (nivel-hoja dato lista) : devuelve el nivel en el que se encuentra un dato en una lista (cuadrado-lista lista) : eleva todas las hojas al cuadrado (suponemos que la lista estructurada contiene n\u00fameros) (map-lista f lista) : similar a map, aplica una funci\u00f3n a todas las hojas de la lista estructurada y devuelve el resultado (otra lista estructurada) (aplana lista) Devuelve una lista plana con todas las hojas de la lista. 1 2 3 4 5 6 7 ( define ( aplana x ) ( cond (( null? x ) ()) (( hoja? x ) ( list x )) ( else ( append ( aplana ( car x )) ( aplana ( cdr x )))))) Por ejemplo: 1 2 ( aplana ( 1 2 ( 3 ( 4 ( 5 ))) ((( 6 ))))) ; \u21d2 {1 2 3 4 5 6} Con funciones de orden superior: 1 2 3 4 5 6 7 ( define ( aplana-fos lista ) ( fold-right append () ( map ( lambda ( elem ) ( if ( hoja? elem ) ( list elem ) ( aplana-fos elem ))) lista ))) (pertenece-lista? dato lista) Comprueba si el dato aparece en la lista estructurada. 1 2 3 4 5 6 ( define ( pertenece? dato x ) ( cond (( null? x ) #f ) (( hoja? x ) ( equal? dato x )) ( else ( or ( pertenece? dato ( car x )) ( pertenece? dato ( cdr x )))))) Ejemplos: 1 2 ( pertenece? a ( b c ( d ( a )))) \u21d2 #t ( pertenece? a ( b c ( d e ( f )) g )) \u21d2 #f Con funciones de orden superior: 1 2 3 4 5 ( define ( pertenece-fos? dato lista ) ( exists ( lambda ( elem ) ( if ( hoja? elem ) ( equal? dato elem ) ( pertenece-fos? dato elem ))) lista )) (nivel-hoja dato lista) Veamos como \u00faltima funci\u00f3n que explora una lista estructurada la funci\u00f3n (nivel-hoja dato lista) que recorre la lista buscando el dato y devuelve el nivel en que se encuentra. Si el dato no se encuentra en la lista, se devolver\u00e1 -1. Si el dato se encuentra en m\u00e1s de un lugar de la lista se devolver\u00e1 el nivel mayor. Ejemplos: 1 2 3 4 ( nivel-hoja b ( a b ( c ))) ; \u21d2 1 ( nivel-hoja b ( a ( b ) c )) ; \u21d2 2 ( nivel-hoja b ( a ( b ) d (( b )))) ; \u21d2 3 ( nivel-hoja b ( a c d (( e )))) ; \u21d2 -1 1 2 3 4 5 6 ( define ( nivel-hoja dato x ) ( cond (( null? x ) -1 ) (( hoja? x ) ( if ( equal? x dato ) 0 -1 )) ( else ( max ( suma-1-si-mayor-igual-que-0 ( nivel-hoja dato ( car x ))) ( nivel-hoja dato ( cdr x )))))) La funci\u00f3n auxiliar se define de la siguiente forma: 1 2 3 4 ( define ( suma-1-si-mayor-igual-que-0 x ) ( if ( = x 0 ) ( + x 1 ) x )) Con funciones de orden superior: 1 2 3 4 5 6 7 ( define ( nivel-hoja-fos dato lista ) ( suma-1-si-mayor-igual-que-0 ( fold-right max -1 ( map ( lambda ( elem ) ( if ( hoja? elem ) ( if ( equal? elem dato ) 0 -1 ) ( nivel-hoja-fos dato elem ))) lista )))) (cuadrado-lista lista) Devuelve una lista estructurada con la misma estructura y sus n\u00fameros elevados al cuadrado. 1 2 3 4 5 ( define ( cuadrado-lista x ) ( cond (( null? x ) ()) (( hoja? x ) ( * x x )) ( else ( cons ( cuadrado-lista ( car x )) ( cuadrado-lista ( cdr x )))))) Por ejemplo: 1 ( cuadrado-lista ( 2 3 ( 4 ( 5 )))) \u21d2 ( 4 9 ( 16 ( 25 )) Es muy interesante la versi\u00f3n de esta funci\u00f3n con funciones de orden superior: 1 2 3 4 5 ( define ( cuadrado-lista-fos lista ) ( map ( lambda ( elem ) ( if ( hoja? elem ) ( * sublista elem ) ( cuadrado-lista-fos elem ))) lista )) Como una lista estructurada est\u00e1 compuesta de datos o de otras sublistas podemos aplicar map para que devuelva la lista resultante de transformar la original con la funci\u00f3n que le pasamos como par\u00e1metro. (map-lista f lista) Devuelve una lista estructurada igual que la original con el resultado de aplicar a cada uno de sus hojas la funci\u00f3n f 1 2 3 4 5 ( define ( map-lista f x ) ( cond (( null? x ) ()) (( hoja? x ) ( f x )) ( else ( cons ( map-lista f ( car x )) ( map-lista f ( cdr x )))))) Por ejemplo: 1 ( map-lista ( lambda ( x ) ( * x x )) ( 2 3 ( 4 ( 5 )))) \u21d2 ( 4 9 ( 16 ( 25 )) \u00c1rboles Definici\u00f3n de \u00e1rboles en Scheme Definici\u00f3n de \u00e1rbol Un \u00e1rbol es una estructura de datos definida por un valor ra\u00edz, que es el padre de toda la estructura, del que salen otros sub\u00e1rboles hijos ( Wikipedia ). Un \u00e1rbol se puede definir recursivamente de la siguiente forma: Una colecci\u00f3n de un dato (el valor de la ra\u00edz del \u00e1rbol) y una lista de hijos que tambi\u00e9n son \u00e1rboles. Una hoja ser\u00e1 un \u00e1rbol sin hijos (un dato con una lista de hijos vac\u00eda). Un ejemplo de \u00e1rbol: El \u00e1rbol anterior tiene como dato de la ra\u00edz es el s\u00edmbolo + y tiene 3 \u00e1rboles hijos: El primer hijo es un \u00e1rbol hoja, con valor 5 y sin hijos El segundo hijo es un \u00e1rbol con valor * y dos hijos hoja, el 2 y el 3 El tercer hijo es otro \u00e1rbol hoja, con valor 10 Representaci\u00f3n de \u00e1rboles con listas En Scheme tenemos como estructura de datos principal la lista. \u00bfC\u00f3mo construimos un \u00e1rbol usando listas? La forma de hacerlo ser\u00e1 usar una lista de n+1 elems para representar un \u00e1rbol con n hijos: el primer elemento la lista ser\u00e1 el dato de la ra\u00edz el resto ser\u00e1n los \u00e1rboles hijos \u00c1rbol: '(dato hijo-1 hijo-2 ... hijo-n) Los nodos hoja ser\u00e1n por tanto listas de un elemento, el propio dato (no tiene m\u00e1s elementos porque no tiene hijos) Nodo hoja: '(dato) Por ejemplo, el \u00e1rbol anterior lo representaremos en Scheme con la siguiente lista: 1 ( + ( 5 ) ( * ( 2 ) ( 3 )) ( 10 )) Los elementos de esta lista son: El primer elemento es el s\u00edmbolo + , el dato valor de la ra\u00edz del \u00e1rbol El segundo elemento es la lista '(5) , que representa el \u00e1rbol hoja formado por un 5 El tercer elemento es la lista '(* (2) (3)) , que representa el \u00e1rbol con un dato * y dos hijos El cuarto elemento es la lista '(10) , que representa el \u00e1rbol hoja formado por un 10 Podr\u00edamos definir el \u00e1rbol con la siguiente sentencia: 1 ( define arbol1 ( + ( 5 ) ( * ( 2 ) ( 3 )) ( 10 ))) Otro ejemplo m\u00e1s. \u00bfC\u00f3mo se implementa en Scheme el \u00e1rbol de la siguiente figura? Se har\u00eda con la lista de la siguiente sentencia: 1 ( define arbol2 ( 40 ( 18 ( 3 ) ( 23 ( 29 ))) ( 52 ( 47 )))) Barrera de abstracci\u00f3n Una vez definida la forma de representar \u00e1rboles, vamos a definir las funciones para manejarlos. Veremos las funciones para obtener el dato y los hijos y la funci\u00f3n para construir un \u00e1rbol nuevo. Estas funciones proporcionar\u00e1n lo que se denomina barrera de abstracci\u00f3n del tipo datos \u00e1rbol . En todos los nombres de las funciones de la barrera de abstracci\u00f3n a\u00f1adimos el sufijo -arbol . Definimos dos conjuntos de funciones: constructores para construir un nuevo \u00e1rbol y selectores para obtener los elementos del \u00e1rbol. Vamos a empezar por los selectores. Las funciones que permiten obtener los elementos que constituyen un dato compuesto reciben el nombre de selectores . Selectores Funciones que obtienen los elementos de un \u00e1rbol: 1 2 3 4 5 6 7 8 ( define ( dato-arbol arbol ) ( car arbol )) ( define ( hijos-arbol arbol ) ( cdr arbol )) ( define ( hoja-arbol? arbol ) ( null? ( hijos-arbol arbol ))) Es importante tener claro los tipos devueltos por las dos primeras funciones: (dato-arbol arbol) : devuelve el dato de la ra\u00edz del \u00e1rbol. (hijos-arbol arbol) : devuelve una lista de \u00e1rboles hijos. En algunas ocasiones llamaremos bosque a una lista de \u00e1rboles. Por ejemplo, en el \u00e1rbol arbol1 las funciones anteriores devuelven los siguientes valores: 1 2 3 ( dato-arbol arbol1 ) ; \u21d2 + ( hijos-arbol arbol1 ) ; \u21d2 {{5} {* {2} {3}} {10}} ( hoja-arbol? ( car ( hijos-arbol arbol1 ))) ; \u21d2 #t La llamada (dato-arbol arbol1) devuelve el dato que hay en la ra\u00edz del \u00e1rbol, el s\u00edmbolo + La invocaci\u00f3n (hijos-arbol arbol1) devuelve una lista de tres elementos, los \u00e1rboles hijos: '((5) (* (2) (3)) (10)) : El primer elemento es la lista '(5) , que representa el \u00e1rbol hoja formado por el 5 El segundo es la lista '(* (2) (3)) , que representa el \u00e1rbol formado por el * en su ra\u00edz y las hojas 2 y 3 El tercero es la lista '(10) , que representa el \u00e1rbol hoja 10 . El primer elemento de la lista de hijos es un \u00e1rbol hoja: (hoja-arbol? (car (hijos-arbol arbol1))) \u21d2 #t Es muy importante considerar en cada caso con qu\u00e9 tipo de dato estamos trabajando y usar la barrera de abstracci\u00f3n adecuada en cada caso: La funci\u00f3n hijos-arbol siempre devuelve una lista de \u00e1rboles, que podemos recorrer usando car y cdr . El car de una lista de \u00e1rboles (devuelta por hijos-arbol ) siempre es un \u00e1rbol y debemos de usar las funciones de su barrera de abstracci\u00f3n: dato-arbol e hijos-arbol . La funci\u00f3n dato-arbol devuelve un dato de \u00e1rbol, del tipo que guardemos en el \u00e1rbol. Por ejemplo, para obtener el n\u00famero 2 en el \u00e1rbol anterior tendr\u00edamos que hacer lo siguiente: acceder al segundo elemento de la lista de hijos, despu\u00e9s al primer hijo de \u00e9ste y por \u00faltimo acceder a su dato. Recordemos que hijos-arbol devuelve la lista de \u00e1rboles hijos, por lo que utilizaremos las funciones car y cdr para recorrerlas y obtener los elementos que nos interesen: 1 ( dato-arbol ( car ( hijos-arbol ( cadr ( hijos-arbol arbol1 ))))) ; \u21d2 2 Constructor Definimos una funci\u00f3n constructora que abstrae la construcci\u00f3n de un \u00e1rbol y encapsula su implementaci\u00f3n concreta. Para construir un \u00e1rbol necesitamos un dato y una lista de \u00e1rboles hijos. Si la lista de \u00e1rboles hijos es vac\u00eda, tendremos un nodo hoja. 1 2 ( define ( construye-arbol dato lista-arboles ) ( cons dato lista-arboles )) Llamaremos a la funci\u00f3n construye-arbol pasando su dato (obligatorio) y la lista de arboles hijos. Si se pasa una lista vac\u00eda como par\u00e1metro se estar\u00e1 definiendo un nodo hoja. Por ejemplo, para definir un nodo hoja con el dato 2: 1 ( define arbol3 ( construye-arbol 2 ())) Y para definir un \u00e1rbol con 3 hijos: 1 2 3 ( define arbol4 ( construye-arbol 10 ( list ( construye-arbol 2 ()) ( construye-arbol 5 ()) ( construye-arbol 9 ()))) El \u00e1rbol 1 anterior se puede construir con las siguientes llamadas al constructor: 1 2 3 4 ( construye-arbol + ( list ( construye-arbol 5 ()) ( construye-arbol * ( list ( construye-arbol 2 ()) ( construye-arbol 3 ()))) ( construye-arbol 10 ())) Diferencia entre \u00e1rboles y listas estructuradas Es importante diferenciar la barrera de abstracci\u00f3n de los \u00e1rboles de la de las listas estructuradas. Aunque un \u00e1rbol se implementa en Scheme con una lista estructurada, a la hora de definir funciones sobre \u00e1rboles hay que trabajar con las funciones definidas arriba. El siguiente esquema resumen las caracter\u00edsticas de los selectores de la barrera de abstracci\u00f3n de listas y \u00e1rboles: Funciones recursivas sobre \u00e1rboles Vamos a dise\u00f1ar las siguientes funciones recursivas: (suma-datos-arbol arbol) : devuelve la suma de todos los nodos (to-list-arbol arbol) : devuelve una lista con los datos del \u00e1rbol (cuadrado-arbol arbol) : eleva al cuadrado todos los datos de un \u00e1rbol manteniendo la estructura del \u00e1rbol original (map-arbol f arbol) : devuelve un \u00e1rbol con la estructura del \u00e1rbol original aplicando la funci\u00f3n f a subdatos. (altura-arbol arbol) : devuelve la altura de un \u00e1rbol Todas comparten un patr\u00f3n similar de recursi\u00f3n mutua. (suma-datos-arbol arbol) Vamos a implementar una funci\u00f3n recursiva que sume todos los datos de un \u00e1rbol. Un \u00e1rbol siempre va a tener un dato y una lista de hijos (que puede ser vac\u00eda) que obtenemos con las funciones dato-arbol e hijos-arbol . Podemos plantear entonces el problema de sumar los datos de un \u00e1rbol como la suma del dato de su ra\u00edz y lo que devuelva la llamada a una funci\u00f3n auxiliar que sume los datos de su lista de hijos (un bosque): 1 2 3 ( define ( suma-datos-arbol arbol ) ( + ( dato-arbol arbol ) ( suma-datos-bosque ( hijos-arbol arbol )))) Esta funci\u00f3n suma los datos de UN \u00e1rbol. La podemos utilizar entonces para construir la siguiente funci\u00f3n que suma una lista de \u00e1rboles: 1 2 3 4 ( define ( suma-datos-bosque bosque ) ( if ( null? bosque ) 0 ( + ( suma-datos-arbol ( car bosque )) ( suma-datos-bosque ( cdr bosque ))))) Tenemos una recursi\u00f3n mutua : para sumar los datos de una lista de \u00e1rboles llamamos a la suma de un \u00e1rbol individual que a su vez llama a la suma de sus hijos, etc. La recursi\u00f3n termina cuando calculamos la suma de un \u00e1rbol hoja. Entonces se pasa a suma-datos-bosque una lista vac\u00eda y \u00e9sta devolver\u00e1 0. 1 ( suma-datos-arbol arbol2 ) ; \u21d2 212 Versi\u00f3n alternativa con funciones de orden superior Al igual que hac\u00edamos con las listas estructuradas, es posible conseguir una versi\u00f3n m\u00e1s concisa y elegante utilizando funciones de orden superior: 1 2 3 ( define ( suma-datos-arbol-fos arbol ) ( fold-right + ( dato-arbol arbol ) ( map suma-datos-arbol-fos ( hijos-arbol arbol )))) La funci\u00f3n map aplica la propia funci\u00f3n que estamos definiendo a cada uno de los \u00e1rboles de (hijos-arbol arbol) , devolviendo una lista de n\u00fameros. Esta lista de n\u00famero la sumamos haciendo un fold-right + 0 . Una traza de su funcionamiento ser\u00eda la siguiente: 1 2 3 4 5 6 ( suma-datos-arbol-fos ( 1 ( 2 ( 3 ) ( 4 )) ( 5 ) ( 6 ( 7 )))) \u21d2 ( fold-right + 1 ( map suma-datos-arbol-fos (( 2 ( 3 ) ( 4 )) ( 5 ) ( 6 ( 7 ))))) \u21d2 ( fold-right + 1 ( 9 5 13 )) \u21d2 28 (to-list-arbol arbol) Queremos dise\u00f1ar una funci\u00f3n (to-list-arbol arbol) que devuelva una lista con los datos del \u00e1rbol en un recorrido preorden . 1 2 3 4 5 6 7 8 9 ( define ( to-list-arbol arbol ) ( cons ( dato-arbol arbol ) ( to-list-bosque ( hijos-arbol arbol )))) ( define ( to-list-bosque bosque ) ( if ( null? bosque ) () ( append ( to-list-arbol ( car bosque )) ( to-list-bosque ( cdr bosque ))))) La funci\u00f3n utiliza una recursi\u00f3n mutua : para listar todos los nodos, a\u00f1adimos el dato a la lista de nodos que nos devuelve la funci\u00f3n to-list-bosque . Esta funci\u00f3n coge una lista de \u00e1rboles (un bosque ) y devuelve la lista preorden de sus nodos. Para ello, concatena la lista de los nodos de su primer elemento (el primer \u00e1rbol) a la lista de nodos del resto de \u00e1rboles (que devuelve la llamada recursiva). Ejemplo: 1 2 ( to-list-arbol ( * ( + ( 5 ) ( * ( 2 ) ( 3 )) ( 10 )) ( - ( 12 )))) ; \u21d2 (* + 5 * 2 3 10 - 12) Una definici\u00f3n alternativa usando funciones de orden superior: 1 2 3 ( define ( to-list-arbol-fos arbol ) ( cons ( dato-arbol arbol ) ( fold-right append () ( map to-list-arbol-fos ( hijos-arbol arbol ))))) Esta versi\u00f3n es muy elegante y concisa. Usa la funci\u00f3n map que aplica una funci\u00f3n a los elementos de una lista y devuelve la lista resultante. Como lo que devuelve (hijos-arbol arbol) es precisamente una lista de \u00e1rboles podemos aplicar a sus elementos cualquier funci\u00f3n definida sobre \u00e1rboles. Incluso la propia funci\u00f3n que estamos definiendo (\u00a1conf\u00eda en la recursi\u00f3n!). (cuadrado-arbol arbol) Veamos ahora la funci\u00f3n (cuadrado-arbol arbol) que toma un \u00e1rbol de n\u00fameros y devuelve un \u00e1rbol con la misma estructura y sus datos elevados al cuadrado: 1 2 3 4 5 6 7 8 9 ( define ( cuadrado-arbol arbol ) ( construye-arbol ( cuadrado ( dato-arbol arbol )) ( cuadrado-bosque ( hijos-arbol arbol )))) ( define ( cuadrado-bosque bosque ) ( if ( null? bosque ) () ( cons ( cuadrado-arbol ( car bosque )) ( cuadrado-bosque ( cdr bosque ))))) Ejemplo: 1 2 ( cuadrado-arbol ( 2 ( 3 ( 4 ) ( 5 )) ( 6 ))) ; \u21d2 (4 (9 (16) (25)) (36)) Versi\u00f3n 2, con la funci\u00f3n de orden superior map : 1 2 3 ( define ( cuadrado-arbol-fos arbol ) ( construye-arbol ( cuadrado ( dato-arbol arbol )) ( map cuadrado-arbol-fos ( hijos-arbol arbol )))) map-arbol La funci\u00f3n map-arbol es una funci\u00f3n de orden superior que generaliza la funci\u00f3n anterior. Definimos un par\u00e1metro adicional en el que se pasa la funci\u00f3n a aplicar a los elementos del \u00e1rbol. 1 2 3 4 5 6 7 8 9 ( define ( map-arbol f arbol ) ( construye-arbol ( f ( dato-arbol arbol )) ( map-bosque f ( hijos-arbol arbol )))) ( define ( map-bosque f bosque ) ( if ( null? bosque ) () ( cons ( map-arbol f ( car bosque )) ( map-bosque f ( cdr bosque ))))) Ejemplos: 1 2 3 4 ( map-arbol cuadrado ( 2 ( 3 ( 4 ) ( 5 )) ( 6 ))) ; \u21d2 (4 (9 (16) (25)) (36)) ( map-arbol ( lambda ( x ) ( + x 1 )) ( 2 ( 3 ( 4 ) ( 5 )) ( 6 ))) ; \u21d2 (3 (4 (5) (6)) (7)) Con map : 1 2 3 4 ( define ( map-arbol-fos f arbol ) ( construye-arbol ( f ( dato-arbol arbol )) ( map ( lambda ( x ) ( map-arbol-fos f x )) ( hijos-arbol arbol )))) altura-arbol Vamos por \u00faltimo a definir una funci\u00f3n que devuelve la altura de un \u00e1rbol (el nivel del nodo de mayor nivel). Un nodo hoja tiene de altura 0. Soluci\u00f3n 1: 1 2 3 4 5 6 7 8 9 10 ( define ( altura-arbol arbol ) ( if ( hoja-arbol? arbol ) 0 ( + 1 ( max-altura-bosque ( hijos-arbol arbol ))))) ( define ( max-altura-bosque bosque ) ( if ( null? bosque ) 0 ( max ( altura-arbol ( car bosque )) ( max-altura-bosque ( cdr bosque ))))) Ejemplos: 1 2 ( altura-arbol ( 2 )) ; \u21d2 0 ( altura-arbol ( 4 ( 9 ( 16 ) ( 25 )) ( 36 ))) ; \u21d2 2 Soluci\u00f3n con funciones de orden superior: 1 2 3 4 5 ( define ( altura-arbol-fos arbol ) ( if ( hoja-arbol? arbol ) 0 ( + 1 ( fold-right max 0 ( map altura-arbol-fos ( hijos-arbol arbol )))))) La funci\u00f3n map mapea sobre los \u00e1rboles hijos la propia funci\u00f3n que calcula la altura del hijo (ser\u00e1 uno menos que la altura del padre, 0 si se trata de una hoja). La funci\u00f3n map devuelve entonces una lista altura de los hijos, de la que obtenemos el m\u00e1ximo plegando la lista con la funci\u00f3n max . Por \u00faltimo sumamos 1 para devolver la altura del \u00e1rbol completo (un nivel m\u00e1s que el nivel m\u00e1ximo de los hijos). Arboles binarios Definici\u00f3n de \u00e1rboles binarios en Scheme Los \u00e1rboles binarios son \u00e1rboles cuyos nodos tienen 0, 1 o 2 hijos. Por ejemplo, el \u00e1rbol mostrado en la siguiente figura es un \u00e1rbol binario. A diferencia de los \u00e1rboles gen\u00e9ricos vistos anteriormente un \u00e1rbol binario no puede tener m\u00e1s de dos hijos. Los representaremos en Scheme utilizando una lista de tres elementos: Dato Hijo izquierdo (otro \u00e1rbol binario) Hijo derecho (otro \u00e1rbol binario) En el caso en que no exista el hijo izquierdo o el derecho (o ambos) utilizaremos una lista vac\u00eda para indicar un nodo vac\u00edo. De esta manera, un nodo hoja con el dato 10 se representar\u00e1 en Scheme con la lista: 1 ( 10 () ()) Por ejemplo, representamos el \u00e1rbol de la figura anterior con la siguiente lista: 1 2 3 4 5 ( 40 ( 18 ( 3 () ()) ( 23 () ( 29 () ()))) ( 52 ( 47 () ()) ())) Barrera de abstracci\u00f3n Definimos la siguiente barrera de abstracci\u00f3n para los \u00e1rboles binarios. Terminamos todos los nombres de las funciones con el sufijo -arbolb (\u00e1rbol binario). Selectores 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 ( define ( dato-arbolb arbol ) ( car arbol )) ( define ( hijo-izq-arbolb arbol ) ( cadr arbol )) ( define ( hijo-der-arbolb arbol ) ( caddr arbol )) ( define ( vacio-arbolb? arbol ) ( null? arbol )) ( define ( hoja-arbolb? arbol ) ( and ( vacio-arbolb? ( hijo-izq-arbolb arbol )) ( vacio-arbolb? ( hijo-der-arbolb arbol )))) ( define arbolb-vacio ()) Constructor 1 2 ( define ( construye-arbolb dato hijo-izq hijo-der ) ( list dato hijo-izq hijo-der )) Por ejemplo, para construir un \u00e1rbol con 10 en la ra\u00edz y 8 en su hijo izquierdo y 15 en su derecho utilizando el constructor de la barrera de abstracci\u00f3n: 1 2 3 ( define arbolb1 ( construye-arbolb 10 ( construye-arbolb 8 arbolb-vacio arbolb-vacio ) ( construye-arbolb 15 arbolb-vacio arbolb-vacio ))) Otro ejemplo, el \u00e1rbol binario de la figura anterior utilizando el constructor de la barrera de abstracci\u00f3n: 1 2 3 4 5 6 7 8 9 10 11 12 ( define arbolb2 ( construye-arbolb 40 ( construye-arbolb 18 ( construye-arbolb 3 arbolb-vacio arbolb-vacio ) ( construye-arbolb 23 arbolb-vacio ( construye-arbolb 29 arbolb-vacio arbolb-vacio ))) ( construye-arbolb 52 ( construye-arbolb 47 arbolb-vacio arbolb-vacio ) arbolb-vacio ))) Funciones recursivas sobre \u00e1rboles binarios Veamos las siguientes funciones recursivas sobre \u00e1rboles binarios: (suma-datos-arbolb arbol) : devuelve la suma de todos los nodos (to-list-arbolb arbol) : devuelve una lista con los datos del \u00e1rbol (cuadrado-arbolb arbol) : eleva al cuadrado todos los datos de un \u00e1rbol manteniendo la estructura del \u00e1rbol original suma-datos-arbolb 1 2 3 4 5 6 7 8 ( define ( suma-datos-arbolb arbol ) ( if ( vacio-arbolb? arbol ) 0 ( + ( dato-arbolb arbol ) ( suma-datos-arbolb ( hijo-izq-arbolb arbol )) ( suma-datos-arbolb ( hijo-der-arbolb arbol ))))) ( suma-datos-arbolb arbolb2 ) ; \u21d2 212 to-list-arbolb 1 2 3 4 5 6 7 8 ( define ( to-list-arbolb arbol ) ( if ( vacio-arbolb? arbol ) () ( cons ( dato-arbolb arbol ) ( append ( to-list-arbolb ( hijo-izq-arbolb arbol )) ( to-list-arbolb ( hijo-der-arbolb arbol )))))) ( to-list-arbolb arbolb2 ) ; \u21d2 (40 18 3 23 29 52 47) cuadrado-arbolb 1 2 3 4 5 6 7 8 ( define ( cuadrado-arbolb arbol ) ( if ( vacio-arbolb? arbol ) arbolb-vacio ( construye-arbolb ( cuadrado ( dato-arbolb arbol )) ( cuadrado-arbolb ( hijo-izq-arbolb arbol )) ( cuadrado-arbolb ( hijo-der-arbolb arbol ))))) ( cuadrado-arbolb arbolb1 ) ; \u21d2 (100 (64 () ()) (225 () ())) Bibliograf\u00eda - SICP En este tema explicamos conceptos de los siguientes cap\u00edtulos del libro Structure and Intepretation of Computer Programs : 1.2.2 - Tree Recursion 2.2.2 - Hierarchical Structures Lenguajes y Paradigmas de Programaci\u00f3n, curso 2018-19 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Domingo Gallardo, Cristina Pomares, Antonio Bot\u00eda, Francisco Mart\u00ednez","title":"Tema 4: Estructuras de datos recursivas"},{"location":"teoria/tema04-estructuras-recursivas/tema04-estructuras-recursivas.html#tema-4-estructuras-de-datos-recursivas","text":"","title":"Tema 4: Estructuras de datos recursivas"},{"location":"teoria/tema04-estructuras-recursivas/tema04-estructuras-recursivas.html#listas-estructuradas","text":"Hemos visto que las listas en Scheme se implementan como un estructura de datos recursiva, formada por una pareja que enlaza en su parte derecha el resto de la lista y que termina con una parte derecha en la que hay una lista vac\u00eda. En este apartado vamos a volver a estudiar las listas desde un nivel de abstracci\u00f3n alto, usando las funciones: (car lista) para obtener el primer elemento de una lista (cdr lista) para obtener el resto de la lista (cons dato lista) para construir una nueva lista con el dato como primer elemento En la mayor\u00eda de funciones y ejemplos que hemos visto hasta ahora las listas est\u00e1n formadas por datos y el recorrido por la lista es un recorrido lineal, iterando por sus elementos. En este apartado vamos a ampliar este concepto y estudiar c\u00f3mo trabajar con listas que contienen otras listas . Veremos que esto cambia fundamentalmente la estructura de las listas y de las funciones que van a operar con ellas. El cambio fundamental es que la funci\u00f3n car lista puede devolver dos tipos de elementos: Un elemento de la lista (del tipo de elementos que hay en la lista) Otra lista (formada por el tipo de elementos de la lista)","title":"Listas estructuradas"},{"location":"teoria/tema04-estructuras-recursivas/tema04-estructuras-recursivas.html#definicion-y-ejemplos","text":"Las listas en Scheme pueden tener cualquier tipo de elementos, incluido otras listas. Llamaremos lista estructurada a una lista que contiene otras sublistas. Lo contrario de lista estructurada es una lista plana , una lista formada por elementos que no son listas. Llamaremos hojas a los elementos de una lista que no son sublistas. A las listas estructuradas cuyas hojas son s\u00edmbolos se les denomina en el contexto de la programaci\u00f3n funcional expresiones-S ( S-expression ). Por ejemplo, la lista estructurada: 1 (a b (c d e) (f (g h))) es una lista estructurada con 4 elementos: El elemento 'a , una hoja El elemento 'b , otra hoja La lista plana '(c d e) La lista estructurada '(f (g h)) Se puede construir con cualquiera de las siguientes expresiones: 1 2 (define lista (list a b (list c d e) (list f (list g h)))) (define lista (a b (c d e) (f (g h)))) Una lista formada por parejas la consideraremos una lista plana, ya que no contiene ninguna sublista. Por ejemplo, la lista 1 ((a . 3) (b . 5) (c . 12)) es una lista plana de tres elementos (hojas) que son parejas.","title":"Definici\u00f3n y ejemplos"},{"location":"teoria/tema04-estructuras-recursivas/tema04-estructuras-recursivas.html#funciones-recursivas-sobre-listas-estructuradas","text":"","title":"Funciones recursivas sobre listas estructuradas"},{"location":"teoria/tema04-estructuras-recursivas/tema04-estructuras-recursivas.html#arboles","text":"","title":"\u00c1rboles"},{"location":"teoria/tema04-estructuras-recursivas/tema04-estructuras-recursivas.html#definicion-de-arboles-en-scheme","text":"","title":"Definici\u00f3n de \u00e1rboles en Scheme"},{"location":"teoria/tema04-estructuras-recursivas/tema04-estructuras-recursivas.html#funciones-recursivas-sobre-arboles","text":"Vamos a dise\u00f1ar las siguientes funciones recursivas: (suma-datos-arbol arbol) : devuelve la suma de todos los nodos (to-list-arbol arbol) : devuelve una lista con los datos del \u00e1rbol (cuadrado-arbol arbol) : eleva al cuadrado todos los datos de un \u00e1rbol manteniendo la estructura del \u00e1rbol original (map-arbol f arbol) : devuelve un \u00e1rbol con la estructura del \u00e1rbol original aplicando la funci\u00f3n f a subdatos. (altura-arbol arbol) : devuelve la altura de un \u00e1rbol Todas comparten un patr\u00f3n similar de recursi\u00f3n mutua.","title":"Funciones recursivas sobre \u00e1rboles"},{"location":"teoria/tema04-estructuras-recursivas/tema04-estructuras-recursivas.html#arboles-binarios","text":"","title":"Arboles binarios"},{"location":"teoria/tema04-estructuras-recursivas/tema04-estructuras-recursivas.html#definicion-de-arboles-binarios-en-scheme","text":"Los \u00e1rboles binarios son \u00e1rboles cuyos nodos tienen 0, 1 o 2 hijos. Por ejemplo, el \u00e1rbol mostrado en la siguiente figura es un \u00e1rbol binario. A diferencia de los \u00e1rboles gen\u00e9ricos vistos anteriormente un \u00e1rbol binario no puede tener m\u00e1s de dos hijos. Los representaremos en Scheme utilizando una lista de tres elementos: Dato Hijo izquierdo (otro \u00e1rbol binario) Hijo derecho (otro \u00e1rbol binario) En el caso en que no exista el hijo izquierdo o el derecho (o ambos) utilizaremos una lista vac\u00eda para indicar un nodo vac\u00edo. De esta manera, un nodo hoja con el dato 10 se representar\u00e1 en Scheme con la lista: 1 ( 10 () ()) Por ejemplo, representamos el \u00e1rbol de la figura anterior con la siguiente lista: 1 2 3 4 5 ( 40 ( 18 ( 3 () ()) ( 23 () ( 29 () ()))) ( 52 ( 47 () ()) ()))","title":"Definici\u00f3n de \u00e1rboles binarios en Scheme"},{"location":"teoria/tema04-estructuras-recursivas/tema04-estructuras-recursivas.html#funciones-recursivas-sobre-arboles-binarios","text":"Veamos las siguientes funciones recursivas sobre \u00e1rboles binarios: (suma-datos-arbolb arbol) : devuelve la suma de todos los nodos (to-list-arbolb arbol) : devuelve una lista con los datos del \u00e1rbol (cuadrado-arbolb arbol) : eleva al cuadrado todos los datos de un \u00e1rbol manteniendo la estructura del \u00e1rbol original suma-datos-arbolb 1 2 3 4 5 6 7 8 ( define ( suma-datos-arbolb arbol ) ( if ( vacio-arbolb? arbol ) 0 ( + ( dato-arbolb arbol ) ( suma-datos-arbolb ( hijo-izq-arbolb arbol )) ( suma-datos-arbolb ( hijo-der-arbolb arbol ))))) ( suma-datos-arbolb arbolb2 ) ; \u21d2 212 to-list-arbolb 1 2 3 4 5 6 7 8 ( define ( to-list-arbolb arbol ) ( if ( vacio-arbolb? arbol ) () ( cons ( dato-arbolb arbol ) ( append ( to-list-arbolb ( hijo-izq-arbolb arbol )) ( to-list-arbolb ( hijo-der-arbolb arbol )))))) ( to-list-arbolb arbolb2 ) ; \u21d2 (40 18 3 23 29 52 47) cuadrado-arbolb 1 2 3 4 5 6 7 8 ( define ( cuadrado-arbolb arbol ) ( if ( vacio-arbolb? arbol ) arbolb-vacio ( construye-arbolb ( cuadrado ( dato-arbolb arbol )) ( cuadrado-arbolb ( hijo-izq-arbolb arbol )) ( cuadrado-arbolb ( hijo-der-arbolb arbol ))))) ( cuadrado-arbolb arbolb1 ) ; \u21d2 (100 (64 () ()) (225 () ()))","title":"Funciones recursivas sobre \u00e1rboles binarios"},{"location":"teoria/tema04-estructuras-recursivas/tema04-estructuras-recursivas.html#bibliografia-sicp","text":"En este tema explicamos conceptos de los siguientes cap\u00edtulos del libro Structure and Intepretation of Computer Programs : 1.2.2 - Tree Recursion 2.2.2 - Hierarchical Structures Lenguajes y Paradigmas de Programaci\u00f3n, curso 2018-19 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Domingo Gallardo, Cristina Pomares, Antonio Bot\u00eda, Francisco Mart\u00ednez","title":"Bibliograf\u00eda - SICP"},{"location":"teoria/tema05-bis-programacion-imperativa/ambitos-let-clousures.html","text":"6. \u00c1mbitos de variables, let y closures Ahora que hemos introducido la forma especial lambda y la idea de que una funci\u00f3n es un objeto de primera clase, podemos revisar el concepto de \u00e1mbito de variables en Scheme e introducir un importante concepto: clausura ( closure en ingl\u00e9s). 6.1. \u00c1mbitos de variables El concepto del \u00e1mbito de vida de las variables es un concepto fundamental en los lenguajes de programaci\u00f3n. En ingl\u00e9s se utiliza el t\u00e9rmino scope . Cuando se define una variable, asoci\u00e1ndole un valor, esta asociaci\u00f3n tiene una extensi\u00f3n determinada, ya sea en t\u00e9rminos de tiempo de compilaci\u00f3n ( \u00e1mbito l\u00e9xico ) como en t\u00e9rminos de tiempo de ejecuci\u00f3n ( \u00e1mbito din\u00e1mico ). El \u00e1mbito de una variable determina cu\u00e1ndo podemos referirnos a ella para recuperar el valor asociado. Al conjunto de variables disponibles en una parte del programa o en una parte de su ejecuci\u00f3n se denomina contexto o entorno ( context o environment ). Variables de \u00e1mbito global Una variable definida en el programa con la instrucci\u00f3n define tiene un \u00e1mbito global. 1 2 3 (define a hola ) (define b (string-append adios a)) (define cuadrado (lambda (x) (* x x))) Todas las variables definidas fuera de funciones forman parte del entorno global del programa. Variables de \u00e1mbito local Como en la mayor\u00eda de lenguajes de programaci\u00f3n, en Scheme se crea un entorno local cada vez que se invoca a una funci\u00f3n. En este entorno local los argumentos de la funci\u00f3n toman los valores de los par\u00e1metros usados en la llamada a la funci\u00f3n. Consideramos, por tanto, estos par\u00e1metros como variables de \u00e1mbito local de la funci\u00f3n. Podemos usar en un entorno local una variable con el mismo nombre que en el entorno global. Cuando se ejecute el c\u00f3digo de la funci\u00f3n se evaluar\u00e1 la variable de \u00e1mbito local. Por ejemplo, supongamos las expresiones: 1 2 3 4 5 6 ( define x 5 ) ( define ( suma-3 x ) ( + x 3 )) ( suma-3 12 ) \u21d2 15 Cuando se ejecuta la expresi\u00f3n (+ x 3) en la invocaci\u00f3n a (suma-3 12) el valor de x es 12, no es 5, devolvi\u00e9ndose 15. Una vez realizada la invocaci\u00f3n, desparece el entorno local y las variables locales definidas en \u00e9l, recuper\u00e1ndose el contexto global. Por ejemplo, en la siguiente expresi\u00f3n, una vez realizada la invocaci\u00f3n a (suma-3 12) se devuelve el n\u00famero 15 y se eval\u00faa en el entorno global la expresi\u00f3n (+ 15 x) . En este contexto la variable x vale 5 por lo que la expresi\u00f3n devuelve 20. 1 2 3 4 5 6 ( define x 5 ) ( define ( suma-3 x ) ( + x 3 )) ( + ( suma-3 12 ) x ) \u21d2 20 En el entorno local tambi\u00e9n se pueden utilizar variables definidas en el entorno global. Por ejemplo: 1 2 3 4 5 6 (define y 12) (define (suma-3-bis x) (+ x y 3)) (suma-3-bis 5) \u21d2 20 La expresi\u00f3n (+ x 3 y) se eval\u00faa en el entorno local en el que x vale 5. Al no estar definida la variable y en este entorno local, se usa su definici\u00f3n de \u00e1mbito global. 6.2 Forma especial let Forma especial let En Scheme se define la forma especial let que permite crear un entorno local en el que se da valor a variables y se eval\u00faa una expresi\u00f3n. Sintaxis: 1 2 3 4 ( let (( var1 exp-1 ) ... ( varn exp-n )) cuerpo ) Las variables var1 , \u2026 varn toman los valores devueltos por las expresiones exp1 , \u2026 expn y el cuerpo se eval\u00faa con esos valores. Por ejemplo: 1 2 3 4 5 6 7 ( define x 10 ) ( define y 20 ) ( let (( x 1 ) ( y 2 ) ( z 3 )) ( + x y z )) \u21d2 6 El \u00e1mbito de las variables definidas en el let es local Las variables definidas en el let s\u00f3lo tienen valores en el entorno creado por la forma especial. 1 2 3 4 5 6 7 ( define x 10 ) ( define y 20 ) ( let (( x 1 ) ( y 2 ) ( z 3 )) ( + x y z )) \u21d2 6 Cuando ha terminado la evaluaci\u00f3n del let el \u00e1mbito local desaparece y quedan los valores definidos en el \u00e1mbito global. 1 2 x \u21d2 5 y \u21d2 error, no definida Let permite usar variables definidas en un \u00e1mbito en el que se ejecuta el let Al igual que en la invocaci\u00f3n a funciones, desde el \u00e1mbito definido por el let se puede usar las variables del entorno en el que se est\u00e1 ejecutando el let . Por ejemplo, en el siguiente c\u00f3digo se usa la variable z definida en el \u00e1mbito global. 1 2 3 4 5 ( define z 8 ) ( let (( x 1 ) ( y 2 )) ( + x y z )) \u21d2 11 Variables en las definiciones del let Las expresiones que dan valor a las variables del let se eval\u00faan todas en el entorno en el que se ejecuta el let , antes de crear las variables locales. No se realiza una asignaci\u00f3n secuencial: 1 2 3 4 ( define x 1 ) ( let (( w ( + x 3 )) ( z ( + w 2 ))) ;; Error: w no est\u00e1 definida ( + w z )) Sem\u00e1ntica del let Para evaluar una expresi\u00f3n let debemos seguir las siguientes reglas: Evaluar todas las expresiones de la derecha de las variables y guardar sus valores en variables auxiliares locales. Definir un \u00e1mbito local en el que se ligan las variables del let con los valores de las variables auxiliares. Evaluar el cuerpo del let en el \u00e1mbito local Let se define utilizando lambda La sem\u00e1ntica anterior queda clara cuando comprobamos que let se puede definir en funci\u00f3n de lambda. En general, la expresi\u00f3n: 1 ( let (( var1 exp1 ) ... ( varn expn )) cuerpo ) se puede implementar con la siguiente llamada a lambda: 1 (( lambda ( var1 ... varn ) cuerpo ) exp1 ... expn ) Para ejecutar un let con un lambda se debe crear un procedimiento en tiempo de ejecuci\u00f3n con tantas variables como las variables del let , con el cuerpo del let , y se debe invocar a dicho procedimiento con las expresiones de las variables del let . Esas expresiones se eval\u00faan antes de invocar al procedimiento y la invocaci\u00f3n se realiza con los resultados. La invocaci\u00f3n crea un entorno local con los par\u00e1metros del procedimiento (las variables del let ) asociados a los valores, y en este \u00e1mbito local se ejecuta el cuerpo del procedimiento (el cuerpo del let ). Por ejemplo: 1 2 3 (let ((x (+ 2 3)) (y (+ x 3))) (+ x y)) Equivale a: 1 (( lambda ( x y ) ( + x y )) ( + 2 3 ) ( + x 3 )) Let dentro de funciones Podemos usar let en el cuerpo de funciones para crear nuevas variables locales, adem\u00e1s de los par\u00e1metros de la funci\u00f3n 1 2 3 4 5 6 ( define ( suma-cuadrados x y ) ( let (( cuadrado-x ( cuadrado x )) ( cuadrado-y ( cuadrado y ))) ( + cuadrado-x cuadrado-y ))) ( suma-cuadrados 4 10 ) \u21d2 116 Cuando se invoca (suma-cuadrados 4 10) se crea un entorno local en el que las variables x e y toman el valor 4 y 10 y en el que se ejecuta la forma especial let . Esta forma especial crea a su vez un entorno local en el que se definen las variables cuadrado-x y cuadrado-y que toman los valores devueltos por las expresiones (cuadrado x) y (cuadrado y) : 16 y 100 . En este entorno local se eval\u00faa la expresi\u00f3n (+ cuadrado-x cuadrado-y) . El uso de let permite aumentar la legibilidad de los programas, dando nombre a expresiones: Por ejemplo: 1 2 3 4 5 ( define ( distancia x1 y1 x2 y2 ) ( let (( distancia-x ( - x2 x1 )) ( distancia-y ( - y2 y1 ))) ( sqrt ( + ( cuadrado distancia-x ) ( cuadrado distancia-y ))))) Otro ejemplo: 1 2 3 4 5 6 ( define ( intersecta-intervalo a1 a2 b1 b2 ) ( let (( dentro-b1 ( and ( = b1 a1 ) ( = b1 a2 ))) ( dentro-b2 ( and ( = b2 a1 ) ( = b2 a2 )))) ( or dentro-b1 dentro-b2 ))) 6.3. Clausuras Vamos a terminar explicando el concepto de clausura . Hemos visto que las funciones son objetos de primera clase de Scheme y que es posible crear funciones en tiempo de ejecuci\u00f3n con la forma especial lambda . Una clausura es una funci\u00f3n devuelta por otra funci\u00f3n. La clausura captura las variables locales de la funci\u00f3n principal y puede usarlas en su propio c\u00f3digo cuando este se invoque posteriormente. Veamos un ejemplo. Supongamos que definimos la siguiente funci\u00f3n (make-sumador k) que devuelve otra funci\u00f3n. 1 2 3 4 5 6 (define (make-sumador k) (lambda (x) (+ x k))) (define f (make-sumador 10)) (f 2) \u21d2 12 En la funci\u00f3n (make-sumador k) se llama a la forma especial lambda para crear un procedimiento. El procedimiento devuelto es lo que se denomina clausura . En este caso la clausura captura la variable local k (el par\u00e1metro de make-sumador ) y usa su valor cuando posteriormente se invoca. Cuando se invoca a (f 2) se ejecuta la clausura y se crea un nuevo entorno local en el que x (el par\u00e1metro de la clausura) vale 2 y en el que se usa la variable k capturada. En la invocaci\u00f3n anterior (f 2) , cuando se ejecuta la expresi\u00f3n (+ x k) las variables tienen los siguientes valores: 1 2 x : 2 ( variable local de la clausura ) k : 10 ( valor capturado del entorno local en el que se cre \u00f3 la clausura Las variables locales creadas en un let tambi\u00e9n se capturan en las clausuras Veamos el siguiente ejemplo, en el que creamos una funci\u00f3n en un entorno local creado por un let : 1 2 3 4 5 6 7 8 9 ( define x 10 ) ( define y 12 ) ( define ( prueba x ) ( let (( y 3 )) ( lambda ( z ) ( + x y z )))) ( define h ( prueba 5 )) ( h 2 ) \u21d2 8 Sucede lo siguiente: Se invoca la expresi\u00f3n (prueba 5) . Esto crea un entorno local en el que se le da a la variable x (el par\u00e1metro de prueba ) el valor 5 . En este contexto se ejecuta el let , que crea otro entorno local en el que y vale 3. En el contexto del let se crea una clausura con la invocaci\u00f3n de la expresi\u00f3n lambda (lambda (z) (+ x y z)) . La clausura captura las variables locales x e y con sus valores 5 y 3 y la funci\u00f3n prueba la devuelve como resultado de la invocaci\u00f3n. La clausura se guarda en la variable h . Con la invocaci\u00f3n (h 2) se invoca a la clausura, lo que crea un entorno local en el que se encuentran las siguientes variables: 1 2 3 z : 2 ( par \u00e1 metro de la clausura ) x : 5 ( variable local de la funci \u00f3 n prueba capturada en el momento de creaci \u00f3 n de la clausura )) y : 3 ( variable local del let capturada en el momento de creaci \u00f3 n de la clausura ) En este contexto se ejecuta la expresi\u00f3n (+ x y z) , que devuelve 10. Lenguajes y Paradigmas de Programaci\u00f3n, curso 2015-16 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Domingo Gallardo, Cristina Pomares","title":"Ambitos let clousures"},{"location":"teoria/tema05-bis-programacion-imperativa/tema05-programacion-imperativa.html","text":"Tema 5: Programaci\u00f3n imperativa Contenidos 1. Historia y caracter\u00edsticas de la programaci\u00f3n imperativa 1.1. Historia de la programaci\u00f3n imperativa 1.2. Caracter\u00edsticas principales de la programaci\u00f3n imperativa 2. Programaci\u00f3n imperativa en Scheme 2.1. Pasos de ejecuci\u00f3n 2.2. Mutaci\u00f3n con formas especiales set! 2.3. Igualdad de referencia y de valor 3. Estructuras de datos mutables 3.1. Mutaci\u00f3n de elementos 3.2. Funciones mutadoras: make-ciclo! , append! y intercambia! 3.3. Lista ordenada mutable 3.4. Diccionario mutable 3.5. Ejemplo de mutaci\u00f3n con listas de asociaci\u00f3n 4. \u00c1mbitos de variables y clausuras 4.1. Variables de \u00e1mbito global 4.2. Variables de \u00e1mbito local 4.3. Clausuras y estado local 5. Clausuras con mutaci\u00f3n = estado local mutable 5.1. Estado local mutable 5.2. Paso de mensajes Bibliograf\u00eda En este tema explicamos conceptos de los siguientes cap\u00edtulos del libro Structure and Intepretation of Computer Programs : 3.3.1 Mutable List Structure 3.3.2 Representing Queues 3.3.3 Representing tables 3.1.1 Local State Variables 3.1.3 The Cost of Introducing Assignment 1. Historia y caracter\u00edsticas de la programaci\u00f3n imperativa 1.1. Historia de la programaci\u00f3n imperativa 1.1.1. Or\u00edgenes de la programaci\u00f3n imperativa La programaci\u00f3n imperativa es la forma natural de programar un computador, es el estilo de programaci\u00f3n que se utiliza en el ensamblador, el estilo m\u00e1s cercano a la arquitectura del computador Caracter\u00edsticas de la arquitectura arquitectura cl\u00e1sica de Von Newmann : memoria donde se almacenan los datos (referenciables por su direcci\u00f3n de memoria) y el programa unidad de control que ejecuta las instrucciones del programa (contador del programa) Los primeros lenguajes de programaci\u00f3n (como el Fortran) son abstracciones del ensamblador y de esta arquitectura. Lenguajes m\u00e1s modernos como el BASIC o el C han continuado con esta idea. 1.1.2. Programaci\u00f3n procedural Uso de procedimientos y subrutinas Los cambios de estado se localizan en estos procedimientos Los procedimientos especifican par\u00e1metros y valores devueltos (un primer paso hacia la abstracci\u00f3n y los modelos funcionales y declarativos) Primer lenguaje con estas ideas: ALGOL 1.1.3. Programaci\u00f3n estructurada Art\u00edculo a finales de los 60 de Edsger W. Dijkstra: GOTO statement considered harmful en el que se arremete contra la sentencia GOTO de muchos lenguajes de programaci\u00f3n de la \u00e9poca La programaci\u00f3n estructurada mantiene la programaci\u00f3n imperativa, pero haciendo \u00e9nfasis en la necesidad de que los programas sean correctos (debe ser posible de comprobar formalmente los programas), modulares y mantenibles. Lenguajes: Pascal, ALGOL 68, Ada 1.1.4. Programaci\u00f3n Orientada a Objetos La POO tambi\u00e9n utiliza la programaci\u00f3n imperativa, aunque extiende los conceptos de modularidad, mantenibilidad y estado local Se populariza a finales de los 70 y principios de los 80 1.2. Caracter\u00edsticas principales de la programaci\u00f3n imperativa Idea principal de la programaci\u00f3n imperativa: la computaci\u00f3n se realiza cambiando el estado del programa por medio de sentencias que definen pasos de ejecuci\u00f3n del computador Estado del programa modificable Sentencias de control que definen pasos de ejecuci\u00f3n Vamos a ver unos ejemplos de estas caracter\u00edsticas usando el lenguaje de programaci\u00f3n Java. 1.2.1. Modificaci\u00f3n de datos Uno de los elementos de la arquitectura de Von Newmann es la existencia de celdas de memoria referenciables y modificables 1 2 int x = 0 ; x = x + 1 ; Otro ejemplo t\u00edpico de este concepto en los lenguajes de programaci\u00f3n es el array: una estructura de datos que se almacena directamente en memoria y que puede ser accedido y modificado. En Java los arrays son tipeados, mutables y de tama\u00f1o fijo 1 2 String [] unoDosTres = { uno , dos , tres }; unoDosTres [ 0 ] = unoDosTres [ 2 ]; Un ejemplo de un m\u00e9todo que recibe un par\u00e1metro de tipo array en Java. El par\u00e1metro se pasa por referencia: 1 2 3 4 5 public void llenaCadenas ( String [] cadenas , String cadena ) { for ( int i = 0 ; i cadenas . length ; i ++) { cadenas [ i ] = cadena ; } } Todos los ejemplos anteriores en un programa main Java: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 public class Main { public static void main ( String [] args ) { int x = 0 ; x = x + 1 ; System . out . println ( x: + x ); String [] unoDosTres = { uno , dos , tres }; unoDosTres [ 0 ] = unoDosTres [ 2 ]; for ( String valor : unoDosTres ) { System . out . println ( valor ); } llenaCadenas ( unoDosTres , uno ); for ( String valor : unoDosTres ) { System . out . println ( valor ); } } public static void llenaCadenas ( String [] cadenas , String cadena ) { for ( int i = 0 ; i cadenas . length ; i ++) { cadenas [ i ] = cadena ; } } } 1.2.2. Almacenamiento de datos en variables Todos los lenguajes de programaci\u00f3n definen variables que contienen datos Las variables pueden mantener valores (tipos de valor o value types) o referencias (tipos de referencia o reference types) En C, C++ o Java, los datos primitivos como int o char son de tipo valor y los objetos y datos compuestos son de tipo referencia La asignaci\u00f3n de un valor a una variable tiene implicaciones distintas si el tipo es de valor (se copia el valor) o de referencia (se copia la referencia) Copia de valor (datos primitivos en Java): 1 2 3 4 int x = 10 ; int y = x ; x = 20 ; System . out . println ( y ); // Sigue siendo 10 Copia de referencia (objetos en Java): 1 2 3 4 5 6 // import java.awt.geom.Point2D; Point2D p1 = new Point2D . Double ( 2.0 , 3.0 ); Point2D p2 = p1 ; p1 . setLocation ( 12.0 , 13.0 ); System . out . println ( p2.x = + p2 . getX ()); // 12.0 System . out . println ( p2.y = + p2 . getY ()); // 13.0 El uso de las referencias para los objetos de clases y para los tipos compuestos est\u00e1 generalizado en la mayor\u00eda de lenguajes de programaci\u00f3n Tiene efectos laterales pero permite obtener estructuras de datos eficientes 1.2.3. Igualdad de valor y de referencia Todos los lenguajes de programaci\u00f3n imperativos que permite la distinci\u00f3n entre valores y referencias implementan dos tipos de igualdad entre variables Igualdad de valor (el contenido de los datos de las variables es el mismo) Igualdad de referencia (las variables tienen la misma referencia) Igualdad de referencia = Igualdad de valor (pero al rev\u00e9s no) En Java la igualdad de referencia se define con == y la de valor con el m\u00e9todo equals : 1 2 3 4 5 6 Point2D p1 = new Point2D . Double ( 2.0 , 3.0 ); Point2D p2 = p1 ; Point2D p3 = new Point2D . Double ( 2.0 , 3.0 ); System . out . println ( p1 == p2 ); // true System . out . println ( p1 == p3 ); // false System . out . println ( p1 . equals ( p3 )); // true 1.2.4. Sentencias de control Tambi\u00e9n tiene su origen en la arquitectura de Von Newmann Sentencia que modifica el contador de programa y determina cu\u00e1l ser\u00e1 la siguiente instrucci\u00f3n a ejecutar Tipos de sentencias de control en programaci\u00f3n estructurada: Las sentencias de secuencia definen instrucciones que son ejecutados una detr\u00e1s de otra de forma s\u00edncrona. Una instrucci\u00f3n no comienza hasta que la anterior ha terminado. Las sentencias de selecci\u00f3n definen una o m\u00e1s condiciones que determinan las instrucciones que se deber\u00e1n ejecutar. Las sentencias de iteraci\u00f3n definen instrucciones que se ejecutan de forma repetitiva hasta que se cumple una determinada condici\u00f3n. Bucles y variables Ejemplo imperativo que imprime en Java una tabla con los productos de los n\u00fameros del 1 al 9: 1 2 3 4 5 6 7 8 for ( int i = 1 ; i = 9 ; i ++) { System . out . println ( Tabla del + i ); System . out . println ( ----------- ); for ( int j = 1 ; j = 9 ; j ++) { System . out . println ( i + * + j + = + i * j ); } System . out . println (); } 2. Programaci\u00f3n imperativa en Scheme Al igual que LISP, Scheme tiene caracter\u00edsticas imperativas Vamos a ver algunas de ellas Pasos de ejecuci\u00f3n Asignaci\u00f3n con la forma especial set! Datos mutables con las formas especiales set-car! y set-cdr! Una nota importante: todos los ejemplos que hay a continuaci\u00f3n necesitan importar la librer\u00eda mutable-pairs : 1 2 3 # lang r6rs ( import ( rnrs ) ( rnrs mutable-pairs )) 2.1. Pasos de ejecuci\u00f3n Es posible definir pasos de ejecuci\u00f3n con la forma especial begin Todas las sentencias de la forma especial se ejecutan de forma secuencial, una tras otra Tanto en la definici\u00f3n de funciones como en lambda es posible definir cuerpos de funci\u00f3n con m\u00faltiples sentencias que se ejecutan tambi\u00e9n de forma secuencial. Hasta ahora no hemos usado esta caracter\u00edstica porque hemos utilizado Scheme de forma funcional. Ejemplo begin : 1 2 3 4 5 6 7 8 9 10 11 12 ( begin ( display Escribe un n\u00famero: ) ( define x ( read )) ( display Escribe otro: ) ( define y ( read )) ( define maximo ( max x y )) ( display ( string-append El m\u00e1ximo de ( number- string x ) y ( number- string y ) es ( number- string maximo )))) Ejemplo de pasos de ejecuci\u00f3n en la definici\u00f3n de una funci\u00f3n: 1 2 3 4 5 6 7 ( define ( display-tres-valores a b c ) ( display a ) ( newline ) ( display b ) ( newline ) ( display c ) ( newline )) 2.2. Mutaci\u00f3n con formas especiales set! 2.2.1. Forma especial set! La forma especial set! permite asignar un nuevo valor a una variable La variable debe haber sido previamente creada con define La forma especial no devuelve ning\u00fan valor, modifica el valor de la variable usada Sintaxis: 1 (set! variable nuevo-valor ) Por ejemplo, la t\u00edpica asignaci\u00f3n de los lenguajes imperativos se puede realizar de esta forma en Scheme: 1 2 3 ( define a 10 ) ( set! a ( + a 1 )) a ; \u21d2 11 La forma especial set! funciona con cualquier tipo de datos. Por ejemplo, utilizando la caracter\u00edstica de que Scheme es d\u00e9bilmente tipeado, puede incluso asignar un nuevo tipo de valor a una variable: 1 2 3 4 ( define a Hola ) a ; \u21d2 Hola ( set! a ( cons 1 2 )) a ; \u21d2 {1 . 2} 2.2.2. Datos mutables En Scheme se definen las formas especiales set-car! y set-cdr! que permite modificar (mutar) la parte izquierda o derecha de una pareja una vez creada Al igual que set! , no devuelven ning\u00fan valor Sintaxis: 1 2 (set-car! pareja nuevo-valor ) (set-cdr! pareja nuevo-valor ) Ejemplo 1 2 3 4 ( define p ( cons 1 2 )) ( set-car! p 10 ) ( set-cdr! p 20 ) p ; \u21d2 (10 . 20) 2.2.3. Efectos laterales La introducci\u00f3n de la asignaci\u00f3n y los datos mutables hace posible que Scheme se comporte como un lenguaje imperativo en el que m\u00e1s de una variable apunta a un mismo valor y se producen efectos laterales Un efecto lateral se produce cuando el valor de una variable cambia debido a una sentencia en la que no aparece la variable Podemos comprobar ahora que las parejas son datos que se copian por referencia Ejemplo: 1 2 3 4 5 6 7 ( define p1 ( cons 1 2 )) ( define p2 p1 ) p1 ; \u21d2 (1 . 2) p2 ; \u21d2 (1 . 2) ( set-car! p1 20 ) p1 ; \u21d2 (20 . 2) p2 ; \u21d2 (20 . 2) 2.3. Igualdad de referencia y de valor La utilizaci\u00f3n de referencias, la mutaci\u00f3n y los efectos laterales hace tambi\u00e9n necesario definir dos tipos de igualdades: igualdad de referencia e igualdad de valor. Igualdad de referencia: dos variables son iguales cuando apuntan al mismo valor Igualdad de valor: dos variables son iguales cuando contienen el mismo valor En Scheme la funci\u00f3n eq? comprueba la igualdad de referencia y equal? la igualdad de valor Igualdad de referencia implica igualdad de valor, pero no al rev\u00e9s Ejemplo: 1 2 3 4 5 6 7 8 ( define p1 ( cons 10 20 )) ( define p2 p1 ) ( define p3 ( cons 10 20 )) ( equal? p3 p1 ) ; \u21d2 #t ( eq? p3 p1 ) ; \u21d2 #f ( eq? p2 p1 ) ; \u21d2 #t ( set! p3 p1 ) ;; La asignaci\u00f3n copia referencias ( eq? p3 p1 ) ; \u21d2 #t 3. Estructuras de datos mutables La utilizaci\u00f3n de las formas especiales set-car! y set-cdr! permite un estilo nuevo de manejo de las estructuras de datos ya vistas (listas o \u00e1rboles) Es posible implementar funciones m\u00e1s eficientes que actualizan la estructura modificando directamente las referencias de unas celdas a otras Las operaciones no construyen estructuras nuevas, sino que modifican la ya existente 3.1. Mutaci\u00f3n de elementos Ejemplo 1 Vamos a empezar con un ejemplo sencillo en el que vamos a mutar un elemento de una estructura de datos formada por parejas. Supongamos la siguiente estructura: 1 2 3 4 ( define datos ( cons 2 ( cons ( cons 5 ( cons 8 9 )) ( cons 3 4 )))) El diagrama box-and-pointer es el siguiente. F\u00edjate que hay elementos de las parejas que son datos at\u00f3micos y otros que son referencias a otras parejas. Vamos ahora a mutar la estructura utilizando las sentencias set-car! y set-cdr! . Para mutar una pareja acceder a la pareja y modificar su parte derecha o su parte izquierda con las sentencias anteriores. Por ejemplo, \u00bfc\u00f3mo cambiar\u00edamos el 8 por un 18 ? Deber\u00edamos obtener la pareja (8 . 9) que est\u00e1 al final de la estructura y modificar su parte izquierda: 1 ( set-car! ( cdr ( car ( cdr datos ))) 18 ) La expresi\u00f3n (cdr (car (cdr datos))) devuelve la pareja que queremos modificar y la sentencia set-car! modifica su parte izquierda. Si ahora vemos qu\u00e9 hay en datos veremos que se ha modificado la estructura: 1 2 ( print-pareja datos ) ; \u21d2 (2 . ((5 . (18 . 9)) . (3 . 4))) Recuerda que print-pareja es una funci\u00f3n que vimos anteriormente. Hemos mutado un dato por otro. Tambi\u00e9n podemos mutar las referencias a las parejas. Por ejemplo, podr\u00edamos modificar la parte derecha de la pareja que contiene el 5 para que apunte a la pareja (3 . 4) : Para ello habr\u00eda que obtener la pareja que contiene el 5 con la expresi\u00f3n (car (cdr datos)) y mutar su parte derecha ( set-cdr! ) con la referencia a la pareja (3 . 4) que se obtiene con la expresi\u00f3n (cdr (cdr datos)) : 1 ( set-cdr! ( car ( cdr datos )) ( cdr ( cdr datos ))) Ejemplo 2 Veamos un segundo ejemplo. Supongamos las siguientes sentencias. \u00bfCu\u00e1l ser\u00eda el box-and-pointer resultante? 1 2 3 4 5 6 ( define x (( a b ) c d )) ( define y ( e f )) ( set-car! x y ) ( define z ( cons y ( cdr x ))) ( set-cdr! x y ) ( set-car! z ( caar x )) Debemos ir paso a paso ejecutando cada instrucci\u00f3n y dibujando c\u00f3mo cambia el diagrama. El diagrama representa el estado del programa , y es un conjunto de parejas que contienen valores y referencias entre ellas. Es muy importante considerar cu\u00e1ndo la sentencia copia un valor y cuando copia una referencia. Las parejas siempre tienen sem\u00e1ntica de referencia. El diagrama resultante despu\u00e9s de las dos primeras sentencias es: Y el diagrama despu\u00e9s de todas las sentencias es: Los valores de las variables despu\u00e9s de todas las sentencias son los siguientes: 1 2 3 x ; \u21d2 {{e f} e f} y ; \u21d2 {e f} z ; \u21d2 {e c d} Ejemplo 3 En este ejemplo vamos a usar una nueva forma especial de Scheme que permite crear variables locales y ejecutar expresiones en las que se utilicen esas variables. Se trata de la forma especial let . Veremos algo m\u00e1s de esta forma especial m\u00e1s adelante, cuando hablemos de \u00e1mbitos de variables. Por ahora es suficiente saber que permite crear variables locales y ejecutar un cuerpo (que puede tener m\u00e1s de una sentencia) con esas variables. 1 2 3 4 ( let (( x ( + 2 3 )) ( y ( * 2 10 )) ( + x y )) ; \u21d2 25 En este caso let permite crear dos variables locales x e y y asignarles los valores 5 y 20 respectivamente. Las sentencias del cuerpo del let (en este caso la sentencia (+ x y) ) se eval\u00faan con estos valores reci\u00e9n creados. Vamos a usar esta forma especial en ocasiones para guardar valores o referencias que despu\u00e9s necesitamos asignar. Por ejemplo, \u00bfc\u00f3mo podr\u00edamos definir una funci\u00f3n que mute las referencias de una lista para intercambiar sus posiciones segunda y tercera (sin crear nuevas parejas)? Si llamamos a la funci\u00f3n intercambia! deber\u00eda hacer lo siguiente: 1 2 3 ( define lista ( 1 2 3 4 5 6 )) ( intercambia! lista ) lista ; \u21d2 {1 3 2 4 5 6} Dibujando el diagrama box-and-pointer podemos ver las mutaciones que tenemos que hacer: La funci\u00f3n es la siguiente: 1 2 3 4 5 6 ( define ( intercambia! lista ) ( let (( segundo ( cdr lista )) ( tercero ( cddr lista ))) ( set-cdr! lista tercero ) ( set-cdr! segundo ( cdr tercero )) ( set-cdr! tercero segundo ))) 3.2. Funciones mutadoras: make-ciclo! , append! e intercambia-lista! Veamos ahora varios ejemplos de funciones recursivas que recorren listas y realizan mutaciones en ellas. Normalmente las funciones mutadoras no devuelven una estructura, sino que modifican la que se pasa como par\u00e1metro. Por convenio, indicaremos que una funci\u00f3n es mutadora terminando su nombre con un signo de admiraci\u00f3n. make-ciclo! Empecemos con una funci\u00f3n muta una lista, haciendo que la parte derecha de la \u00faltima pareja apunte a la pareja inicial de la misma. Para conseguirlo, necesitamos guardar la referencia a la pareja inicial de la lista en el primer par\u00e1metro de la funci\u00f3n. Y el segundo par\u00e1metro ir\u00e1 avanzando hasta encontrar el final de la lista: 1 2 3 4 ( define ( make-ciclo! lista ref ) ( if ( null? ( cdr ref )) ( set-cdr! ref lista ) ( make-ciclo! lista ( cdr ref )))) Si probamos la funci\u00f3n con una lista, podemos comprobar que DrRacket detecta el ciclo que se produce al final de la misma: 1 2 3 ( define lista ( 1 2 3 4 5 6 )) ( make-ciclo! lista lista ) lista ; \u21d2 #0={1 2 3 4 5 6 . #0#} Una forma alternativa de implementar esta funci\u00f3n es mediante una funci\u00f3n que devuelva la referencia de la \u00faltima pareja de la lista: 1 2 3 4 5 6 7 8 ( define ( ultima-pareja lista ) ( if ( null? ( cdr lista )) lista ( ultima-pareja ( cdr lista )))) ( define ( make-ciclo2! lista ) ( let (( ultima-pareja ( ultima-pareja lista ))) ( set-cdr! ultima-pareja lista ))) append! Y vemos a continuaci\u00f3n una versi\u00f3n mutadora de append que llamamos append! y que mejora la eficiencia de la original, copiando al final de la primera lista una referencia a la segunda: La implementaci\u00f3n es la siguiente: 1 2 3 4 ( define ( append! l1 l2 ) ( if ( null? ( cdr l1 )) ( set-cdr! l1 l2 ) ( append! ( cdr l1 ) l2 ))) Ejemplo: 1 2 3 4 ( define a ( 1 2 3 4 )) ( define b ( 5 6 7 )) ( append! a b ) a ; \u21d2 {1 2 3 4 5 6 7} Algunas puntualizaciones: Al igual que set! , set-car! o set-cdr! , la funci\u00f3n append! no devuelve ning\u00fan valor, sino que modifica directamente la lista que se pasa como primer par\u00e1metro. Al modificarse la lista, todas las referencias que apuntan a ellas quedan tambi\u00e9n modificadas. La funci\u00f3n dar\u00eda un error en el caso en que la llam\u00e1ramos con una lista vac\u00eda como primer argumento. intercambia-lista! Un \u00faltimo ejemplo de funci\u00f3n recursiva que muta una lista. Queremos definir una funci\u00f3n que intercambie todas las parejas excepto la primera de una lista con un n\u00famero de datos impar, pero sin usar set-car! . Llamamos a la funci\u00f3n (intercambia-lista! lista) y deber\u00eda hacer lo siguiente: 1 2 3 ( define lista ( 1 2 3 4 5 6 7 )) ( intercambia-lista! lista ) lista ; \u21d2 {1 3 2 5 4 7 6} La forma de implementar esta funci\u00f3n va a ser llamando a la funci\u00f3n intercambia! (la que hemos definido anteriormente que intercambia el segundo y el tercer elemento) hasta que lleguemos al final de la lista. Lo hacemos con una recursi\u00f3n: 1 2 3 4 5 ( define ( intercambia-lista! lista ) ( if ( not ( null? ( cdr lista ))) ( begin ( intercambia! lista ) ( intercambia-lista! ( cddr lista ))))) La funci\u00f3n termina cuando llegamos a la pareja final de la lista, la que tiene la lista vac\u00eda en su parte derecha. Si no estamos en el final de la lista llamamos a la funci\u00f3n intercambia! para intercambiar la siguiente pareja con su siguiente y llamamos a la recursi\u00f3n con la variable lista apuntando a la tercera pareja de la lista. 3.3. Lista ordenada mutable Veamos ahora una lista ordenada mutable de n\u00fameros, en la que insertaremos elementos de forma ordenada. Definiremos las siguientes funciones: (make-olist) : construye una lista ordenada vac\u00eda (borra-primero-olist! olist) : funci\u00f3n mutadora que elimina (con mutaci\u00f3n) el primer elemento de la lista (inserta-olist! olist n) : funci\u00f3n mutadora que inserta (con mutaci\u00f3n) de forma ordenada un n\u00famero en la lista Implementamos el tipo de datos con una lista normal con una pareja adicional en cabeza. Esta pareja adicional funcionar\u00e1 de cabecera de la lista y ser\u00e1 la referencia inmutable a la que apuntar\u00e1 cualquier variable que apunte a la lista. De esta forma podremos insertar elementos en primera posici\u00f3n de la lista. En la cabecera usaremos por convenio el s\u00edmbolo '*olist*' . 1 ( define lista ( *olist* 10 20 30 )) Constructor El constructor (make-olist) devuelve una lista s\u00f3lo con la cabecera. 1 2 ( define ( make-olist ) ( list *olist* )) Mutadores Las funciones mutadoras modifican la estructura de datos. Comenzamos con la funci\u00f3n (borra-primero-olist! olist) que elimina con mutaci\u00f3n el primer elemento de la lista ordenada: 1 2 ( define ( borra-primero-olist! olist ) ( set-cdr! olist ( cddr olist ))) Definimos la funci\u00f3n mutadora inserta-olist! que modifica la lista ordenada a\u00f1adiendo una nueva pareja, insert\u00e1ndola en la posici\u00f3n correcta modificando las referencias. La funci\u00f3n (add-item! item ref) es la funci\u00f3n clave que crea una nueva pareja con el item y la a\u00f1ade en el cdr de la pareja a la que apunta ref . 1 2 3 4 5 6 7 8 9 ( define ( add-item! ref item ) ( set-cdr! ref ( cons item ( cdr ref )))) ( define ( inserta-olist! olist n ) ( cond (( null? ( cdr olist )) ( add-item! olist n )) (( n ( cadr olist )) ( add-item! olist n )) (( = n ( cadr olist )) #f ) ; el valor devuelto no importa ( else ( inserta-olist! ( cdr olist ) n )))) Ejemplo de uso: 1 2 3 4 5 ( define c ( make-olist )) ( inserta-olist! c 5 ) ( inserta-olist! c 10 ) ( inserta-olist! c -10 ) c ; \u21d2 {*olist* -10 5 10} 3.4. Diccionario mutable Veamos ahora un ejemplo m\u00e1s: un diccionario mutable definido mediante una lista de asociaci\u00f3n formada por parejas de clave y valor 1 ( define l-assoc ( list ( cons a 1 ) ( cons b 2 ) ( cons c 3 ))) La funci\u00f3n de Scheme assq recorre la lista de asociaci\u00f3n y devuelve la tupla que contiene el dato que se pasa como par\u00e1metro como clave 1 2 3 4 5 ( assq a l-assoc ) ; \u21d2 (a.1) ( assq b l-assoc ) ; \u21d2 (b.2) ( assq c l-assoc ) ; \u21d2 (c.3) ( assq d l-assoc ) ; \u21d2 #f ( cdr ( assq c l-assoc )) ; \u21d2 3 La funci\u00f3n assq busca en la lista de asociaci\u00f3n usando la igualdad de referencia eq? 1 2 3 4 ( define p ( cons 1 2 )) ( define l-assoc ( list ( cons a 1 ) ( cons p 2 ) ( cons c 3 ))) ( assq ( cons 1 2 ) l-assoc ) ; \u21d2 #f ( assq p l-assoc ) ; \u21d2 {{1 . 2} . 2} Las funciones que vamos a implementar del diccionario son las siguientes: (make-dic) : construye un diccionario vac\u00edo (put-dic! dic clave valor) : inserta en el diccionario un nuevo valor asociado a una clave (get-dic dic clave) : devuelve el valor asociado a una clave en un diccionario Al igual que la lista ordenada mutable, el diccionario necesita una cabecera: 1 2 ( define ( make-dic ) ( list *dic* )) La funci\u00f3n (get-dic dic clave) usa la funci\u00f3n assq para buscar la pareja que contiene una clave determinada en la lista de asociaci\u00f3n (el cdr de dic). Y despu\u00e9s devuelve el cdr de esa pareja (el valor guardado junto con la clave: 1 2 3 4 5 ( define ( get-dic dic clave ) ( let ( pareja ( assq clave ( cdr dic ))) ( if ( not pareja ) #f ( cdr pareja )))) La funci\u00f3n (put-dic! dic clave valor) usa igual que antes la funci\u00f3n assq para comprobar si la clave ya est\u00e1 en la lista de asociaci\u00f3n. Si existe, sustituye el valor por el nuevo. Si no existe, crea una pareja con la clave y el valor y la inserta al comienzo del diccionario (despu\u00e9s de la cabecera): 1 2 3 4 5 6 7 8 ( define ( put-dic! dic clave valor ) ( let ( pareja ( assq clave ( cdr dic ))) ( if ( not pareja ) ( set-cdr! dic ( cons ( cons clave valor ) ( cdr dic ))) ( set-cdr! pareja valor ))) ok ) En las funciones anteriores volvemos a usar la forma especial let . Ejemplos de uso: 1 2 3 4 5 6 7 ( define dic ( make-dic )) ( put-dic! dic a 10 ) ; \u21d2 ok ( get-dic dic a ) ; \u21d2 10 ( put-dic! dic b ( a b c )) ; \u21d2 ok ( get-dic dic b ) ; \u21d2 {a b c} ( put-dic! dic a ardilla ) ; \u21d2 ok ( get-dic dic a ) ; \u21d2 ardilla 3.5. Ejemplo de mutaci\u00f3n con listas de asociaci\u00f3n Una vez introducidos distintas estructuras de datos mutables, incluyendo listas de asociaci\u00f3n, vamos a terminar estos ejemplos con un ejemplo pr\u00e1ctico en el que intervienen las listas y las listas de asociaci\u00f3n. Se trata de escribir un procedimiento regular- assoc! que transforme una lista regular en una lista de asociaci\u00f3n sin crear nuevas parejas. La lista regular (k1 v1 k2 v2 k3 v3 ...) deber\u00e1 convertirse en la lista de asociaci\u00f3n ((k1 . v1) (k2 . v2) (k3 . v3) ...) . Ejemplo: 1 2 3 4 ( define my-list ( list a 1 b 2 c 3 )) lista ; \u21d2 (a 1 b 2 c 3) ( regular- assoc! my-list ) lista ; \u21d2 ((a . 1) (b . 2) (c . 3)) Una posible soluci\u00f3n a este problema ser\u00eda la siguiente (no es la \u00fanica soluci\u00f3n): Cuando trabajamos con este tipo de problemas, es muy \u00fatil ayudarse con los diagramas caja y puntero. Vamos a crear los diagramas caja y puntero para el ejemplo anterior: Antes de llamar a regular- assoc!: Despu\u00e9s de llamar a regular- assoc!: Queremos hacer la transformaci\u00f3n sin crear nuevas parejas, por lo que cada pareja en el primer diagrama corresponde a una pareja particular en el segundo diagrama. No podemos modificar la primera pareja de la lista (porque perder\u00edamos la ligadura de la variable lista ), por lo que es primera pareja tiene que permanecer en el primer lugar. Por otra parte, a y 1 van a formar parte del mismo par en la lista de asociaci\u00f3n, por lo que vamos a considerar el siguiente cambio de las dos primeras parejas. Diagrama inicial: Despu\u00e9s del cambio de las dos primeras parejas: La siguiente funci\u00f3n manejar-dos-parejas! es la encargada de hacer esta mutaci\u00f3n: 1 2 3 4 5 6 ( define ( manejar-dos-parejas! p ) ( let (( key ( car p ))) ;; 1 ( set-car! p ( cdr p )) ;; 2 ( set-cdr! p ( cdar p )) ;; 3 ( set-cdr! ( car p ) ( caar p )) ;; 4 ( set-car! ( car p ) key ))) ;; 5 Se han numerado las l\u00edneas para una mejor explicaci\u00f3n. En la l\u00ednea 1, (define key (car p)) , creamos una variable local key que guarda el valor actual del (car p) , ese valor ser\u00e1 la clave de la primera pareja de la lista de asociaci\u00f3n; necesitamos almacenarlo para no perderlo. En la l\u00ednea 2, (set-car! p (cdr p)) , cambiamos el car de p para que apunte a la siguiente pareja (la azul): En la l\u00ednea 3, (set-cdr! p (cdar p)) , copiamos en el cdr de p el cdr de la pareja en azul para que ambos apunten a la siguiente pareja: En la l\u00ednea 4, (set-cdr! (car p) (caar p)) , cambiamos el cdr de la pareja en azul al car de la misma pareja. Hacemos \u00e9sto porque en una lista de asociaci\u00f3n, los valores se guardan en los cdrs y las claves en los cars : Por \u00faltimo, en la l\u00ednea 5 (set-car! (car p) key) , completamos el problema poniendo la clave que hab\u00edamos guardado, en el car de la pareja azul: Reordenamos el diagrama para verlo m\u00e1s claro: Hemos definido un procedimiento que maneja un subproblema (dos parejas) del problema. Ahora s\u00f3lo nos queda definir la funci\u00f3n que maneja toda la lista: 1 2 3 4 5 ( define ( regular- assoc! lista ) ( if ( null? lista ) ok ( begin ( manejar-dos-parejas! lista ) ( regular- assoc! ( cdr lista ))))) 4. \u00c1mbitos de variables y clausuras El concepto del \u00e1mbito de vida de las variables es un concepto fundamental en los lenguajes de programaci\u00f3n. Utilizaremos las palabras \u00e1mbito y entorno como sin\u00f3nimos. En ingl\u00e9s se utiliza el t\u00e9rmino scope . Cuando se define una variable, asoci\u00e1ndole un valor, esta asociaci\u00f3n tiene una extensi\u00f3n determinada, ya sea en t\u00e9rminos de tiempo de compilaci\u00f3n ( \u00e1mbito l\u00e9xico ) como en t\u00e9rminos de tiempo de ejecuci\u00f3n ( \u00e1mbito din\u00e1mico ). El \u00e1mbito de una variable determina cu\u00e1ndo podemos referirnos a ella para recuperar el valor asociado. Al conjunto de variables disponibles en una parte del programa o en una parte de su ejecuci\u00f3n se denomina contexto o entorno ( context o environment ). 4.1. Variables de \u00e1mbito global Una variable definida en el programa con la instrucci\u00f3n define tiene un \u00e1mbito global. 1 2 3 ( define a hola ) ( define b ( string-append adios a )) ( define cuadrado ( lambda ( x ) ( * x x ))) Todas las variables definidas fuera de funciones forman parte del entorno global del programa. 4.2. Variables de \u00e1mbito local En Scheme existen dos formas de definir variables de \u00e1mbito local: la forma especial define dentro de una funci\u00f3n y la forma especial let . 4.2.1 Variables locales con define Como en la mayor\u00eda de lenguajes de programaci\u00f3n, en Scheme se crea un entorno o \u00e1mbito local (memoria local de la invocaci\u00f3n de la funci\u00f3n) cada vez que se invoca a una funci\u00f3n. En este entorno local toman valor los par\u00e1metros y las variables locales de la funci\u00f3n. Es posible definir variables locales en una funci\u00f3n utilizando la forma especial define dentro de la propia funci\u00f3n. Esto no lo hac\u00edamos dentro del paradigma funcional, para evitar realizar pasos de ejecuci\u00f3n. Pero ahora que estamos en el paradigma imperativo podemos utilizarlo. 1 2 3 4 5 ( define ( distancia x1 y1 x2 y2 ) ( define distancia-x ( - x2 x1 )) ( define distancia-y ( - y2 y1 )) ( sqrt ( + ( cuadrado distancia-x ) ( cuadrado distancia-y )))) Podemos usar en un entorno local una variable con el mismo nombre que en el entorno global. Cuando se ejecute el c\u00f3digo de la funci\u00f3n se utilizar\u00e1 el valor local. Por ejemplo, supongamos las siguientes expresiones: 1 2 3 4 5 6 ( define x 5 ) ( define ( suma-10 y ) ( define x 10 ) ( + x y )) ( suma-10 3 ) ; \u21d2 13 La primera sentencia de la funci\u00f3n (suma y) define una variable local x a la que se asigna un valor inicial de 10. Cuando se ejecuta la expresi\u00f3n (+ x y) , en la invocaci\u00f3n a (suma 3) el valor de x es entonces 10 (el valor local que hemos definido en la sentencia anterior), no es 5, devolvi\u00e9ndose 15. Sucede igual si un par\u00e1metro tiene el mismo nombre que una variable global: 1 2 3 4 5 ( define x 5 ) ( define ( suma-3 x ) ( + x 3 )) ( suma-3 12 ) ; \u21d2 15 Cuando se ejecuta la expresi\u00f3n (+ x 3) en la invocaci\u00f3n a (suma-3 12) el valor de x es 12, no es 5, devolvi\u00e9ndose 15. En el entorno local tambi\u00e9n se pueden utilizar variables definidas en el entorno global. Por ejemplo: 1 2 3 4 5 6 ( define z 12 ) ( define ( foo y ) ( define x 10 ) ( + x y z )) ( foo 5 ) ; \u21d2 27 La expresi\u00f3n (+ x y z) se eval\u00faa en el entorno local en el que x vale 10 e y vale 5. Al no estar definida la variable z en este entorno local, se usa su definici\u00f3n de \u00e1mbito global. Una vez realizada la invocaci\u00f3n, desparece el entorno local junto con las variables locales definidas en \u00e9l, y se recupera el contexto global. Por ejemplo, en la siguiente expresi\u00f3n, una vez realizada la invocaci\u00f3n a (suma-10 2) se devuelve el n\u00famero 12 y se eval\u00faa en el entorno global la expresi\u00f3n (+ 12 x) . En este contexto la variable x vale 5 por lo que la expresi\u00f3n devuelve 17. 1 2 3 4 5 6 ( define x 5 ) ( define ( suma-10 y ) ( define x 10 ) ( + x y )) ( + ( suma-10 2 ) x ) ; \u21d2 17 Otro ejemplo: 1 2 3 4 5 6 7 8 9 ( define x 10 ) ( define ( foo2 y ) ( define z 5 ) ( + x y z )) ( foo2 2 ) ; \u21d2 17 x ; \u21d2 10 z ; \u21d2 error, no definida y ; \u21d2 error, no definida Define en el cuerpo de una funci\u00f3n La forma especial define para crear variables locales s\u00f3lo puede utilizarse al comienzo de la definici\u00f3n de una funci\u00f3n. Si intentamos utilizarla a mitad del c\u00f3digo de la funci\u00f3n tendremos un error: 1 2 3 4 5 6 7 8 9 ( define ( suma-10-si-mayor-que-0 x ) ( if ( x 0 ) ( begin ;; ERROR: ;; no es posible usar define a mitad del c\u00f3digo ;; de una funci\u00f3n ( define y 10 ) ( + x y )) x )) 4.2.1 Variables locales con let La otra forma de definir variables locales en Scheme es con la forma especial let . La forma especial let permite crear un \u00e1mbito local en el que se da valor a variables y se eval\u00faan expresiones. Sintaxis: 1 2 3 4 ( let (( var1 exp-1 ) ... ( varn exp-n )) cuerpo ) Las variables var1 , \u2026 varn toman los valores devueltos por las expresiones exp1 , \u2026 expn y el cuerpo se eval\u00faa con esos valores. Esas variables s\u00f3lo tienen valor en el \u00e1mbito de la forma especial. Por ejemplo: 1 2 3 4 5 6 ( define x 10 ) ( let (( x ( + 1 2 )) ( y ( * 10 2 )) ( + x y )) ; \u21d2 23 x ; \u21d2 10 y ; \u21d2 error, no definida Cuando ha terminado la evaluaci\u00f3n del let el \u00e1mbito local desaparece y quedan los valores definidos en el \u00e1mbito anterior. Las expresiones que dan valor a las variables del let se eval\u00faan antes de crear el \u00e1mbito local. Por ejemplo, en el siguiente c\u00f3digo, las expresiones (+ x 3) y (+ y 2) devuelven 4 y 7 respectivamente: 1 2 3 4 5 ( define x 1 ) ( define y 5 ) ( let (( w ( + x 3 )) ( z ( + y 2 ))) ( + w z )) ; \u21d2 11 En el cuerpo del let puede haber m\u00e1s de una expresi\u00f3n: 1 2 3 4 5 6 ( let (( x 10 ) ( y 20 )) ( display x: ) ( display x ) ( display \\ny: ) ( display y )) Let en el cuerpo de una funci\u00f3n A diferencia de define s\u00ed que es posible usar let en cualquier expresi\u00f3n de Scheme, por ejemplo, en un if : 1 2 3 4 5 ( define ( suma-10-si-mayor-que-0 x ) ( if ( x 0 ) ( let (( y 10 )) ( + x y )) x )) 4.3. Clausuras y estado local Recordemos que la forma especial lambda permite crear funciones an\u00f3nimas en tiempo de ejecuci\u00f3n. Si ejecutamos una forma especial lambda como \u00faltimo paso de una funci\u00f3n, se devolver\u00e1 la funci\u00f3n reci\u00e9n creada. \u00bfQu\u00e9 sucede si utilizamos en el cuerpo de esta funci\u00f3n an\u00f3nima una variable local definida en la funci\u00f3n principal? Vamos a verlo: 1 2 3 ( define ( make-sumador ) ( define z 10 ) ( lambda ( x ) ( + x z ))) La funci\u00f3n make-sumador define una variable local z con el valor de 10. Y despu\u00e9s construye una funci\u00f3n con la expresi\u00f3n lambda . Al ser la \u00faltima expresi\u00f3n de la funci\u00f3n make-sumador , esta funci\u00f3n construida en tiempo de ejecuci\u00f3n es lo que se devuelve. Si invocamos a make-sumador vemos que devuelve un procedimiento: 1 ( make-sumador ) ; \u21d2 # procedure Si guardamos el procedimiento en una variable y despu\u00e9s lo invocamos, tendremos que pasarle un par\u00e1metro (correspondiente al argumento x de la expresi\u00f3n lambda ). \u00bfQu\u00e9 devolver\u00e1 esa invocaci\u00f3n? 1 2 ( define f ( make-sumador )) ( f 5 ) ; \u21d2 ??? Al invocar a f se ejecutar\u00e1 el cuerpo del procedimiento, esto es, la expresi\u00f3n (+ x z) . La variable x valdr\u00e1 5 (el valor del par\u00e1metro). Pero, \u00bfcu\u00e1l es el valor de la variable z?. Podemos comprobar que es 10, porque la invocaci\u00f3n devuelve devuelve 15: 1 ( f 5 ) ; \u21d2 15 \u00bfPor qu\u00e9? Lo que est\u00e1 pasando es que la funci\u00f3n an\u00f3nima que crea la expresi\u00f3n lambda captura las variables locales definidas en el \u00e1mbito en el que se crea. Por eso recibe el nombre de clausura , porque encierra los valores que tienen esas variables en el momento de su creaci\u00f3n y esos valores son los que usa en las variables libres cuando posteriormente la invoquemos. En el ejemplo anterior se est\u00e1 capturando la variable z con su valor 10. Cuando despu\u00e9s invocamos a (f 5) se eval\u00faa el cuerpo (+ x z) con x valiendo 5 y z valiendo el valor capturado (10). Tambi\u00e9n podemos utilizar como estado local el valor de un par\u00e1metro. Por ejemplo: 1 2 3 4 5 6 ( define ( make-sumador k ) ( lambda ( x ) ( + x k ))) ( define f ( make-sumador 10 )) ( f 2 ) ; \u21d2 12 En la funci\u00f3n (make-sumador k) se llama a la forma especial lambda para crear una clausura. La clausura captura la variable local k (el par\u00e1metro de make-sumador ) y usar\u00e1 su valor cuando posteriormente se eval\u00fae. En este caso, la clausura se ha creado con k valiendo 10, y captura este valor. Cuando despu\u00e9s se invoca a (f 2) se ejecuta la clausura en un nuevo \u00e1mbito local con las siguientes variables y valores: 1 2 x : 2 ( variable local de la clausura ) k : 10 ( valor capturado del entorno local en el que se cre \u00f3 la clausura En este \u00e1mbito se ejecuta la expresi\u00f3n (+ x k) , devolvi\u00e9ndose el valor 12. Por \u00faltimo, tambi\u00e9n es posible crear la clausura dentro de un estado local definido con un let y usar en el cuerpo del lambda variables locales definidas en el let : 1 2 3 4 5 6 7 ( define ( make-sumador-cuadrado k ) ( if ( k 0 ) ( let (( y ( cuadrado k ))) ( lambda ( x ) ( + x y ))) ( lambda ( x ) x ))) La funci\u00f3n anterior tiene un condicional en el que se comprueba si k es mayor que 0. Si lo es, se devuelve una clausura creada en el \u00e1mbito del let con la variable y capturada con el valor del cuadrado de k . Esta clausura suma a su entrada el valor de y . Por ejemplo: 1 2 ( define f ( make-sumador-cuadrado 4 )) ( f 3 ) ; \u21d2 19 En el caso en que k menor o igual que 0, se devuelve una clausura que devuelve siempre el valor que recibe: 1 2 ( define f ( make-sumador-cuadrado -8 )) ( f 3 ) ; \u21d2 3 La definici\u00f3n de clausuras con un estado local inicializado a un valor creado en tiempo de ejecuci\u00f3n es una caracter\u00edstica muy potente. Permite no s\u00f3lo crear funciones en tiempo de ejecuci\u00f3n para utilizarlas posteriormente, sino configurarlas con el estado local que nos interese. Veremos en el apartado siguiente que la combinaci\u00f3n de clausuras y mutaci\u00f3n permite crear funciones con estado local mutable, algo equivalente a objetos que encapsulan c\u00f3digo y estado. 5. Clausuras con mutaci\u00f3n = estado local mutable 5.1. Estado local mutable Si combinamos una clausura con la posibilidad de mutar las variables capturadas por la clausura obtenemos un estado local mutable asociado a funciones creadas en tiempo de ejecuci\u00f3n. Veamos, por ejemplo, la siguiente funci\u00f3n (make-contador i) : 1 2 3 4 5 ( define ( make-contador i ) ( define x i ) ( lambda () ( set! x ( + x 1 )) x ))) La funci\u00f3n make-contador define una clausura que captura la variable local x inicializada a i . En cada invocaci\u00f3n a la clausura se ejecuta una sentencia set que modifica el valor de la variable capturada. Y despu\u00e9s se devuelve el nuevo valor de la variable. Estamos implementando un contador asociado a la clausura. 1 2 3 ( define f ( make-contador 10 )) ( f ) \u21d2 11 ( f ) \u21d2 12 El estado (el valor del contador) se mantiene y se modifica entre distintas invocaciones a f . A diferencia del paradigma funcional podemos comprobar que distintas invocaciones a la misma funci\u00f3n devuelven valores distintos (dependiente del estado de la clausura). Podemos crear distintas clausuras, cada una con su variable capturada, en distintas invocaciones a make-contador : 1 2 3 4 5 6 ( define h ( make-contador 10 )) ( define g ( make-contador 100 )) ( h ) \u21d2 11 ( h ) \u21d2 12 ( g ) \u21d2 101 ( g ) \u21d2 102 Una forma alternativa de crear la clausura, sin usar la forma especial lambda es defini\u00e9ndola con un define en el cuerpo de make-contador . Despu\u00e9s de los dos define la \u00faltima sentencia devuelve la funci\u00f3n incrementa (la clausura). 1 2 3 4 5 6 ( define ( make-contador i ) ( define x i ) ( define ( incrementa ) ( set! x ( + x 1 )) x ) incrementa ) 5.2. Paso de mensajes En el ejemplo anterior creamos una clausura que siempre incrementa el valor del contador. \u00bfC\u00f3mo podr\u00edamos crear una clausura que permitiera hacer distintas cosas con el valor capturado? Una forma de hacerlo es definir en la clausura un par\u00e1metro adicional (un s\u00edmbolo que llamamos mensaje ) y devolver distintas clausuras en funci\u00f3n del valor de ese par\u00e1metro adicional: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ( define ( make-contador i ) ( define x i ) ( define ( get ) x ) ( define ( inc-1 ) ( set! x ( + x 1 )) x ) ( define ( inc y ) ( set! x ( + x y )) x ) ( define ( dispatcher mensaje ) ( cond (( equal? mensaje get ) get ) (( equal? mensaje inc-1 ) inc-1 ) (( equal? mensaje inc ) inc ) ( else Error: mensaje desconocido ))) dispatcher ) La funci\u00f3n make-contador devuelve la clausura dispatcher que se encarga de procesar el mensaje y devolver la clausura asociada a ese mensaje. Cuando invoquemos al dispatcher con un s\u00edmbolo, devuelve otro procedimiento que hay que volver a invocar con los par\u00e1metros adecuados (sin par\u00e1metros en los dos primeros casos y con el valor a incrementar en el \u00faltimo caso): Si recibe el s\u00edmbolo 'get devuelve la clausura que devuelve el valor del contador Si recibe el s\u00edmbolo 'inc-1 devuelve la clausura que incrementa el valor del contador en 1 Si recibe el s\u00edmbolo 'inc devuelve la clausura que incrementa el valor del contador una cantidad determinada Por ejemplo: 1 2 3 4 ( define c ( make-contador 100 )) (( c get )) \u21d2 100 (( c inc-1 )) \u21d2 101 (( c inc ) 10 ) \u21d2 111 Lenguajes y Paradigmas de Programaci\u00f3n, curso 2016-17 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Domingo Gallardo, Cristina Pomares","title":"Tema 5: Programaci\u00f3n imperativa"},{"location":"teoria/tema05-bis-programacion-imperativa/tema05-programacion-imperativa.html#tema-5-programacion-imperativa","text":"","title":"Tema 5: Programaci\u00f3n imperativa"},{"location":"teoria/tema05-bis-programacion-imperativa/tema05-programacion-imperativa.html#contenidos","text":"1. Historia y caracter\u00edsticas de la programaci\u00f3n imperativa 1.1. Historia de la programaci\u00f3n imperativa 1.2. Caracter\u00edsticas principales de la programaci\u00f3n imperativa 2. Programaci\u00f3n imperativa en Scheme 2.1. Pasos de ejecuci\u00f3n 2.2. Mutaci\u00f3n con formas especiales set! 2.3. Igualdad de referencia y de valor 3. Estructuras de datos mutables 3.1. Mutaci\u00f3n de elementos 3.2. Funciones mutadoras: make-ciclo! , append! y intercambia! 3.3. Lista ordenada mutable 3.4. Diccionario mutable 3.5. Ejemplo de mutaci\u00f3n con listas de asociaci\u00f3n 4. \u00c1mbitos de variables y clausuras 4.1. Variables de \u00e1mbito global 4.2. Variables de \u00e1mbito local 4.3. Clausuras y estado local 5. Clausuras con mutaci\u00f3n = estado local mutable 5.1. Estado local mutable 5.2. Paso de mensajes","title":"Contenidos"},{"location":"teoria/tema05-bis-programacion-imperativa/tema05-programacion-imperativa.html#bibliografia","text":"En este tema explicamos conceptos de los siguientes cap\u00edtulos del libro Structure and Intepretation of Computer Programs : 3.3.1 Mutable List Structure 3.3.2 Representing Queues 3.3.3 Representing tables 3.1.1 Local State Variables 3.1.3 The Cost of Introducing Assignment","title":"Bibliograf\u00eda"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html","text":"Tema 5: Programaci\u00f3n Funcional con Swift Introducci\u00f3n Te recomendamos que leas el seminario de Swift , en el que se introduce el lenguaje y se explica c\u00f3mo ejecutar programas en este lenguaje: El lenguaje de programaci\u00f3n Swift Swift es un lenguaje principalmente imperativo, pero en su dise\u00f1o se han introducido conceptos modernos de programaci\u00f3n funcional, extra\u00eddos de lenguajes como Rust o Haskell. Como dice su creador Chris Lattner : El lenguaje Swift es el resultado de un esfuerzo incansable de un equipo de expertos en lenguajes, gur\u00fas de documentaci\u00f3n, ninjas de optimizaci\u00f3n de compiladores [..]. Por supuesto, tambi\u00e9n se benefici\u00f3 enormemente de las experiencias ganadas en muchos otros lenguajes, tomando ideas de Objective-C, Rust, Haskell, Ruby, Python, C#, CLU, y demasiados otros para ser enumerados. Vamos a repasar en este tema c\u00f3mo se implementan en Swift conceptos principalmente funcionales como: Valores inmutables Funciones como objetos de primera clase y clasuras Funciones de orden superior Repasamos r\u00e1pidamente algunos conceptos b\u00e1sicos de programaci\u00f3n funcional, vistos en los primeros temas de la asignatura. Programaci\u00f3n Funcional: La Programaci\u00f3n Funcional es un paradigma de programaci\u00f3n que trata la computaci\u00f3n como la evaluaci\u00f3n de funciones matem\u00e1ticas y que evita cambios de estado y datos mutables. Funciones matem\u00e1ticas o puras: Las funciones matem\u00e1ticas tienen la caracter\u00edstica de que cuando las invocas con el mismo argumento siempre te devolver\u00e1n el mismo resultado. Funciones como objetos de primera clase: En programaci\u00f3n funcional, las funciones son objetos de primera clase del lenguaje, similares a enteros o strings . Podemos pasar funciones como argumentos en las denominadas funciones de orden superior o devolver funciones creadas en tiempo de ejecuci\u00f3n (clausuras). Funciones Definici\u00f3n de una funci\u00f3n en Swift Para definir una funci\u00f3n en Swift se debe usar la palabra func , definir el nombre de la funci\u00f3n, sus par\u00e1metros y el tipo de vuelto. El valor devuelto por la funci\u00f3n se debe devolver usando la palabra return . C\u00f3digo de la funci\u00f3n saluda(nombre:) : 1 2 3 4 func saluda ( nombre : String ) - String { let saludo = Hola, + nombre + ! return saludo } Para invocar a la funci\u00f3n saluda(nombre:) : 1 2 3 4 print ( saluda ( nombre : Ana )) print ( saluda ( nombre : Pedro )) // Imprime Hola, Ana! // Imprime Hola, Pedro! Etiquetas de argumentos y nombres de par\u00e1metros Cada par\u00e1metro de una funci\u00f3n tiene una etiqueta del argumento y un nombre de par\u00e1metro. La etiqueta del argumento se usa cuando se llama a la funci\u00f3n y el nombre del par\u00e1metro se usa internamente en su implementaci\u00f3n. Por defecto, los par\u00e1metros usan su nombre de par\u00e1metro como etiqueta del argumento: 1 2 3 4 5 6 func unaFuncion ( primerNombreParametro : Int , segundoNombreParametro : Int ) { // En el cuerpo de la funci\u00f3n, primerNombreParametro y // segundoNombreParametro se refieren a los valores de los // argumentos del primer y el segundo par\u00e1metro } unaFuncion ( primerNombreParametro : 1 , segundoNombreParametro : 2 ) Es posible hacer distintos la etiqueta del argumento del nombre del par\u00e1metro: 1 2 3 4 5 func saluda ( nombre : String , de ciudad : String ) - String { return Hola \\( nombre ) ! Me alegro de que hayas podido visitarnos desde \\( ciudad ) . } print ( saluda ( nombre : Bill , de : Cupertino )) // Imprime Hola Bill! Me alegro de que hayas podido visitarnos desde Cupertino. Otro ejemplo, la siguiente funci\u00f3n concatena(palabra:con:) : 1 2 3 4 5 func concatena ( palabra str1 : String , con str2 : String ) - String { return str1 + str2 } print ( concatena ( palabra : Hola , con : adios )) Si no se quiere una etiqueta del argumento para un par\u00e1metro, se puede escribir un subrayado ( _ ) en lugar de una etiqueta del argumento expl\u00edcita para ese par\u00e1metro: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 func max ( _ x : Int , _ y : Int ) - Int { if x y { return x } else { return y } } print ( max ( 10 , 3 )) func divide ( _ x : Double , entre y : Double ) - Double { return x / y } print ( divide ( 30 , entre : 4 )) El perfil de la funci\u00f3n est\u00e1 formado por el nombre de la funci\u00f3n, las etiquetas de los argumentos y el tipo devuelto por la funci\u00f3n. En la documentaci\u00f3n de las funciones usaremos las etiquetas separadas por dos puntos. Por ejemplo, las funciones anteriores son max(_:_:) y divide(_:entre:) . Par\u00e1metros y valores devueltos Es posible definir funciones sin par\u00e1metros: 1 2 3 4 5 func diHolaMundo () - String { return hola, mundo } print ( diHolaMundo ()) // Imprime hola, mundo Podemos definir funciones sin valor devuelto. Por ejemplo, la siguiente funci\u00f3n diAdios(nombre:) . No hay que escribir flecha con el tipo devuelto. Cuidado, no ser\u00eda propiamente programaci\u00f3n funcional. 1 2 3 4 5 func diAdios ( nombre : String ) { print ( Adi\u00f3s, \\( nombre ) ! ) } diAdios ( nombre : Dave ) // Imprime Adi\u00f3s, Dave! Es posible devolver m\u00faltiples valores, construyendo una tupla. Por ejemplo, la siguiente funci\u00f3n minMax(array:) busca el n\u00famero m\u00e1s peque\u00f1o y m\u00e1s grande de un array de enteros. 1 2 3 4 5 6 7 8 9 10 11 12 func minMax ( array : [ Int ]) - ( min : Int , max : Int ) { var minActual = array [ 0 ] var maxActual = array [ 0 ] for valor in array [ 1. . array . count ] { if valor minActual { minActual = valor } else if valor maxActual { maxActual = valor } } return ( minActual , maxActual ) } Los valores de la tupla devuelta se etiquetan y se puede acceder por esos nombres cuando se consulta el valor devuelto por la funci\u00f3n: 1 2 3 let limites = minMax ( array : [ 8 , - 6 , 2 , 109 , 3 , 71 ]) print ( min es \\( limites . min ) y max es \\( limites . max ) ) // Imprime min es -6 y max es 109 Tipos funci\u00f3n En Swift las funciones son objetos de primera clase y podemos asignarlas a variables, pasarlas como par\u00e1metro o devolverlas como resultado de otra funci\u00f3n. Al ser un lenguaje fuertemente tipado, las variables, par\u00e1metros o resultados deben ser objetos de tipo funci\u00f3n. Cada funci\u00f3n tiene un tipo espec\u00edfico, definido por el tipo de sus par\u00e1metros y el tipo del valor devuelto. 1 2 3 4 5 6 func sumaDosInts ( _ a : Int , _ b : Int ) - Int { return a + b } func multiplicaDosInts ( _ a : Int , _ b : Int ) - Int { return a * b } El tipo de estas funciones es (Int, Int) - Int , que se puede leer como: \"Un tipo funci\u00f3n que tiene dos par\u00e1metros, ambos de tipo Int y que devuelve un valor de tipo Int \". En Swift se puede usar un tipo funci\u00f3n de la misma forma que cualquier otro tipo: 1 2 3 4 var funcionMatematica : ( Int , Int ) - Int = sumaDosInts print ( Resultado: \\( funcionMatematica ( 2 , 3 )) ) funcionMatematica = multiplicaDosInts print ( Resultado: \\( funcionMatematica ( 2 , 3 )) ) Funciones que reciben otras funciones Podemos usar un tipo funci\u00f3n en par\u00e1metros de otras funciones: 1 2 3 4 5 func printResultado ( funcion : ( Int , Int ) - Int , _ a : Int , _ b : Int ) { print ( Resultado: \\( funcionMatematica ( a , b )) ) } printResultado ( funcion : sumaDosInts , 3 , 5 ) // Prints Resultado: 8 La funci\u00f3n printResultado(funcion:_:_:) toma como primer par\u00e1metro otra funci\u00f3n que recibe dos Int y devuelve un Int , y como segundo y tercer par\u00e1metro dos Int . Veamos otro ejemplo, que ya vimos en Scheme. Supongamos que queremos calcular el sumatorio desde a hasta b en el que aplicamos una funci\u00f3n f a cada n\u00famero que sumamos: 1 sumatorio(a, b, f) = f(a) + f(a+1) + f(a+2) + ... + f(b) Recordamos que se resuelve con la siguiente recursi\u00f3n: 1 2 sumatorio(a, b, f) = f(a) + sumatorio(a+1, b, f) sumatorio(a, b, f) = 0 si a b Veamos c\u00f3mo se implementa en Swift: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 func sumatorio ( desde a : Int , hasta b : Int , func f : ( Int ) - Int ) - Int { if a b { return 0 } else { return f ( a ) + sumatorio ( desde : a + 1 , hasta : b , func : f ) } } func identidad ( _ x : Int ) - Int { return x } func doble ( _ x : Int ) - Int { return x + x } func cuadrado ( _ x : Int ) - Int { return x * x } print ( sumatorio ( desde : 0 , hasta : 10 , func : identidad )) // Imprime 55 print ( sumatorio ( desde : 0 , hasta : 10 , func : doble )) // Imprime 110 print ( sumatorio ( desde : 0 , hasta : 10 , func : cuadrado )) // Imprime 385 Funciones en estructuras Como cualquier otro tipo Las funciones pueden tambi\u00e9n incluirse en estructuras de datos compuestas, como arrays: 1 2 3 4 var funciones = [ identidad , doble , cuadrado ] print ( funciones [ 0 ]( 10 )) // 10 print ( funciones [ 1 ]( 10 )) // 20 print ( funciones [ 2 ]( 10 )) // 100 El tipo de la variable funciones ser\u00eda [(Int) - Int] . Al ser Swift fuertemente tipeado, no podr\u00edamos hacer un array con distintos tipos de funciones. Por ejemplo el siguiente c\u00f3digo dar\u00eda un error: 1 2 3 4 5 6 7 func suma ( _ x : Int , _ y : Int ) - Int { return x + y } // La siguiente l\u00ednea genera un error var misFunciones = [ doble , cuadrado , suma ] // error: heterogenous collection literal could only be inferred to // [Any] ; add explicit type annotation if this is intentional Funciones que devuelven otras funciones Por \u00faltimo, veamos un ejemplo de funciones que devuelven otras funciones. Empecemos por un ejemplo sencillo de una funci\u00f3n que devuelve otra que suma 10: 1 2 3 4 5 6 7 8 func makeSumador10 () - ( Int ) - Int { func suma10 ( x : Int ) - Int { return x + 10 } return suma10 } var f = makeSumador10 () print ( f ( 20 )) // Imprime 30 Hay que hacer notar la declaraci\u00f3n de la funci\u00f3n makeSumador10 . Es una funci\u00f3n que no recibe argumentos y que devuelve otra funci\u00f3n del tipo (Int) - Int , esto es, una funci\u00f3n que recibe un entero y devuelve otro entero. Otro ejemplo, un poco m\u00e1s complicado: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 func eligeFuncionPaso ( menorQueCero : Bool ) - ( Int ) - Int { func pasoAdelante ( x : Int ) - Int { return x + 1 } func pasoAtras ( x : Int ) - Int { return x - 1 } return menorQueCero ? pasoAdelante : pasoAtras } var valorActual = - 4 let acercarseACero = eligeFuncionPaso ( menorQueCero : valorActual 0 ) // acercarseACero ahora se refiere a la funci\u00f3n anidada pasoAdelante while valorActual != 0 { print ( \\( valorActual ) ... ) valorActual = acercarseACero ( valorActual ) } print ( cero! ) // -4... // -3... // -2... // -1... // cero! Recursi\u00f3n Ejemplos de funciones recursivas en Swift. Recursi\u00f3n pura: 1 2 3 4 5 6 7 8 9 func suma ( hasta x : Int ) - Int { if x == 0 { return 0 } else { return x + suma ( hasta : x - 1 ) } } print ( suma ( hasta : 5 )) Los arrays en Swift no funcionan exactamente como las listas de Scheme (no son listas de parejas), pero podr\u00edamos obtener el primer elemento y el resto de la siguiente forma. 1 2 3 let a = [ 10 , 20 , 30 , 40 , 50 , 60 ] let primero = a . first ! let resto = a . dropFirst () En primero se guarda el n\u00famero 10. El s\u00edmbolo ! sirve para desenvolver el opcional que devuelve first (veremos despu\u00e9s este concepto). En resto se guarda un ArraySlice del 20 al 60. Es una vista de un rango de elementos del array, en este caso el que va desde la posici\u00f3n 1 hasta la 5 (la posici\u00f3n inicial de un array es la 0). Un ArraySlice en un un Array : 1 let resto = Array ( a . dropFirst ()) De esta forma podemos definir la funci\u00f3n recursiva que suma los valores de un Array de la siguiente forma: 1 2 3 4 5 6 7 8 9 10 func sumaValores ( _ valores : [ Int ]) - Int { if let primero = valores . first { let resto = Array ( valores . dropFirst ()) return primero + sumaValores ( resto ) } else { return 0 } } print ( sumaValores ([ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 ])) // 36 Veremos que las colecciones en Swift implementan funciones de orden superior como map , filter , etc. Veremos tambi\u00e9n m\u00e1s adelante otras funciones recursivas cuando definamos \u00e1rboles en Swift. Tipos Swift es un lenguaje fuertemente tipeado, a diferencia de Scheme. Muchos otros lenguajes de programaci\u00f3n funcional, como Haskell o Clojure tambi\u00e9n lo son. Entre las ventajas del uso de tipos est\u00e1 la detecci\u00f3n de errores en los programas en tiempo de compilaci\u00f3n o las ayudas del entorno de desarrollo para autocompletar c\u00f3digo. Entre los inconvenientes se encuentra la necesidad de ser m\u00e1s estrictos a la hora de definir los par\u00e1metros y los valores devueltos por las funciones, lo que impide la flexibilidad de Scheme. Se utilizan tipos para definir los posibles valores de: variables par\u00e1metros de funciones valores devueltos por funciones Las definiciones de tipos van precedidas de dos puntos en las variables y par\u00e1metros, o de una flecha ( - ) en la definici\u00f3n de los tipos de los valores devueltos por una funci\u00f3n: 1 2 3 4 5 6 let valorDouble : Double = 3.0 let unaCadena : String = Hola func calculaEstadisticas ( valores : Array Int ) - ( min : Int , max : Int , media : Int ) { ... } En Swift existen dos clases de tipos: tipos con nombre y tipos compuestos. Tipos con nombre Un tipo con nombre es un tipo al que se le puede dar un nombre determinado cuando se define. Definimos un tipo al definir: nombres de clases nombres de estructuras nombres de enumeraciones nombres de protocolos Por ejemplo, instancias de una clase definida por el usuario llamada MiClase tienen el tipo MiClase . Adem\u00e1s de los tipos definidos por el usuario, la biblioteca est\u00e1ndar de Swift tiene un gran n\u00famero de tipos predefinidos. A diferencia de otros lenguajes, estos tipos no son parte del propio lenguaje sino que se definen en su mayor\u00eda como estructuras implementadas en esta biblioteca est\u00e1ndar. Por ejemplo, arrays, diccionarios o incluso los tipos m\u00e1s b\u00e1sicos como String o Int est\u00e1n construidos en esa biblioteca. Tipos compuestos Los tipos compuestos son tipos sin nombre. En Swift se definen dos: tuplas y tipos funci\u00f3n. Un tipo compuesto puede tener tipos con nombre y otros tipos compuestos. Por ejemplo la tupla (Int, (Int, Int)) contiene dos elementos: el primero es el tipo con nombre Int y el segundo el tipo compuesto que define la tupla (Int, Int) . Los tipos funci\u00f3n los hemos visto previamente. 1 2 3 4 5 6 7 8 9 10 11 let tupla : ( Int , Int , String ) = ( 2 , 3 , Hola ) let otraTupla : ( Int , Int , String ) = ( 5 , 8 , Adios ) func sumaTupla ( tupla t1 : ( Int , Int ), con t2 : ( Int , Int )) - ( Int , Int ) { return ( t1 . 0 + t2 . 0 , t1 . 1 + t2 . 1 ) } print ( sumaTupla ( tupla : ( tupla . 0 , tupla . 1 ), con : ( otraTupla . 0 , otraTupla . 1 ))) // Imprime (7, 11) Enumeraciones Las enumeraciones definen un tipo con un valor restringido de posibles valores: 1 2 3 4 5 6 enum Direccion { case norte case sur case este case oeste } Cualquier variable del tipo Direccion solo puede tener uno de los cuatro valores definidos. Se obtiene el valor escribiendo el nombre de la enumeraci\u00f3n, un punto y el valor definido. Si el tipo de enumeraci\u00f3n se puede inferir no es necesario escribirlo. 1 2 3 4 5 let hemosGirado = true var direccionActual = Direccion . norte if hemosGirado { direccionActual = . sur } En sentencias switch: 1 2 3 4 5 6 7 8 9 10 11 12 let direccionAIr = Direccion . sur switch direccionAIr { case . norte : print ( Nos vamos al norte ) case . sur : print ( Cuidado con los pinguinos ) case . este : print ( Donde nace el sol ) case . oeste : print ( Donde el cielo es azul ) } // Imprime Cuidado con los pinguinos Otro ejemplo: 1 2 3 enum Planeta { case mercurio , venus , tierra , marte , jupiter , saturno , urano , neptuno } Valores brutos de enumeraciones Es posible asignar a las constantes del enumerado un valor concreto de un tipo subyacente: 1 2 3 4 5 enum CaracterControlASCII : Character { case tab = \\t case lineFeed = \\n case carriageReturn = \\r } Se puede devolver el valor bruto de la siguiente forma: 1 let nuevaLinea = CaracterControlASCII.LineFeed.rawValue Tambi\u00e9n se puede hacer de forma impl\u00edcita cuando el tipo subyacente es Int , dando un valor a la primera constante: 1 2 3 4 5 enum Planeta : Int { case mercurio = 1 , venus , tierra , marte , jupiter , saturno , urano , neptuno } let posicionTierra = Planeta . tierra . rawValue // posicionTierra es 3 Por \u00faltimo, se puede definir como tipo subyacente String y los valores brutos de las constantes ser\u00e1n sus nombres convertidos a cadenas: 1 2 3 4 5 enum Direccion : String { case norte , sur , este , oeste } let direccionAtardecer = Direccion . oeste . rawValue // direccionAtardecer es oeste Cuando se definen valores brutos es posible inicializar el enumerado de una forma similar a una estructura o una clase pasando el valor bruto. Devuelve el valor enumerado correspondiente o nil (un opcional): 1 2 let posiblePlaneta = Planeta ( rawValue : 7 ) // posiblePlaneta es de tipo Planeta? y es igual a Planeta.urano Valores asociados a instancias de enumeraciones En otros lenguajes de programaci\u00f3n se llaman uniones etiquetadas o variantes . Permiten asociar valores de otro tipo a las opciones del enumerado. Una instancia de un caso de enumeraci\u00f3n puede tener valores asociados con la instancia. Instancias del mismo caso de enumeraci\u00f3n pueden tener asociados valores diferentes. Se proporciona el valor asociado cuando se crea la instancia. Los valores asociados y los valores brutos son distintos: el valor bruto de un caso de enumeraci\u00f3n es el mismo para todas las instancias, mientras que el valor asociado se proporciona cuando se define el valor concreto de la enumeraci\u00f3n. Veamos un ejemplo, en el que usamos un enum para definir posibles valores de un c\u00f3digo de barras, en el que incluimos dos posibles tipos de c\u00f3digo de barras: el c\u00f3digo de barras lineal (denominado UPC) y el c\u00f3digo QR: 1 2 3 4 enum CodigoBarras { case upc ( Int , Int , Int , Int ) case qrCode ( String ) } Se lee de la siguiente forma: \u201cDefinimos un tipo enumerado llamado CodigoBarras , que puede tomar como valor un upc (c\u00f3digo de barras lineal) con un valor asociado de tipo (Int, Int, Int, Int) (los 4 n\u00fameros que hay en los c\u00f3digos de barras lineales) o un valor qrCode con valor asociado de tipo String \". Esta definici\u00f3n no proporciona valores concretos de Int o String , sino que define el tipo de valores asociados que las constantes y variables pueden almacenar cuando son de tipo CodigoBarras.upc o CodigoBarras.qrCode . 1 2 3 4 5 6 7 8 9 10 var codigoBarrasProducto = CodigoBarras . upc ( 8 , 85909 , 51226 , 3 ) codigoBarrasProducto = . qrCode ( ABCDEFGHIJKLMNOP ) switch codigoBarrasProducto { case let . upc ( sistemaNumeracion , fabricante , producto , control ): print ( UPC: \\( sistemaNumeracion ) , \\( fabricante ) , \\( producto ) , \\( control ) . ) case let . qrCode ( codigoProducto ): print ( C\u00f3digo QR: \\( codigoProducto ) . ) } // Imprime C\u00f3digo QR : ABCDEFGHIJKLMNOP. Enumeraciones recursivas Es posible combinar las caracter\u00edsticas de las enumeraciones con valor con la recursi\u00f3n para crear enumeraciones recursivas. Hay que preceder la palabra clave enum con indirect : 1 2 3 4 5 6 7 8 9 10 indirect enum ExpresionAritmetica { case numero ( Int ) case suma ( ExpresionAritmetica , ExpresionAritmetica ) case multiplicacion ( ExpresionAritmetica , ExpresionAritmetica ) } let cinco = ExpresionAritmetica . numero ( 5 ) let cuatro = ExpresionAritmetica . numero ( 4 ) let suma = ExpresionAritmetica . suma ( cinco , cuatro ) let producto = ExpresionAritmetica . multiplicacion ( suma , ExpresionAritmetica . numero ( 2 )) Es muy c\u00f3modo manejar enumeraciones recursivas de forma recursiva: 1 2 3 4 5 6 7 8 9 10 11 12 13 func evalua ( expresion : ExpresionAritmetica ) - Int { switch expresion { case let . numero ( valor ): return valor case let . suma ( izquierda , derecha ): return evalua ( expresion : izquierda ) + evalua ( expresion : derecha ) case let . multiplicacion ( izquierda , derecha ): return evalua ( expresion : izquierda ) * evalua ( expresion : derecha ) } } print ( evalua ( expresion : producto )) // Imprime 18 Otro ejemplo de enums recursivos, para definir un tipo de datos Lista basado en parejas (similar a Scheme): 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 indirect enum Lista { case vacia case cons ( Int , Lista ) } func suma ( lista : Lista ) - Int { switch lista { case . vacia : return 0 case let . cons ( car , cdr ): return car + suma ( lista : cdr ) } } let z : Lista = . cons ( 20 , . cons ( 10 , . vacia )) print ( suma ( lista : z )) // Imprime 30 Podemos definir tambi\u00e9n una funci\u00f3n recursiva makeLista(array:[Int]) que devuelve una lista a partir de una array de enteros: 1 2 3 4 5 6 7 8 9 10 11 12 13 func make ( lista : [ Int ]) - Lista { if let primero = lista . first { let resto = Array ( lista . dropFirst ()) return Lista . cons ( primero , make ( lista : resto )) } else { return Lista . vacia } } let lista = make ( lista : [ 1 , 2 , 3 , 4 , 5 ]) print ( suma ( lista : lista )) // Imprime 15 Typealias En Swift se define la palabra clave typealias para darle un nombre asignado a cualquier otro tipo. Ambos tipos son iguales a todos los efectos (es \u00fanicamente az\u00facar sint\u00e1ctico). 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 typealias Resultado = ( Int , Int ) enum Quiniela { case uno , equis , dos } func quiniela ( resultado : Resultado ) - Quiniela { switch resultado { case let ( goles1 , goles2 ) where goles1 goles2 : return . dos case let ( goles1 , goles2 ) where goles1 goles2 : return . uno default : return . equis } } print ( quiniela ( resultado : ( 1 , 3 ))) // Imprime Dos print ( quiniela ( resultado : ( 2 , 2 ))) // Imprime Equis Opcionales En Swift el valor nulo se representa con nil (equivalente a null en Java). No podemos asignar nil a una variable de un tipo dado: 1 2 // La siguiente l\u00ednea dar\u00eda un error en tiempo de compilaci\u00f3n // let cadena: String = nil Los tipos opcionales de Swift permiten asignar a variables o bien un valor propio del tipo o bien nil , de forma que podemos expresar situaciones en las que: Hay un valor y es igual que x o No hay ning\u00fan valor Podemos definir como opcional variables, par\u00e1metros o valores devueltos por funciones. Por ejemplo, el tipo Int de Swift tiene un inicializador que intenta convertir un valor String a un valor Int . Sin embargo, no toda cadena puede convertirse a un n\u00famero. Por ejemplo, la cadena \"123\" se deber\u00eda convertir al n\u00famero 123, pero la cadena \"Hola, mundo\" no tiene un valor num\u00e9rico al que convertirse. El siguiente ejemplo muestra la forma correcta de usar el inicializador: 1 2 3 4 5 6 var posibleNumero = 123 let numeroConvertido = Int ( posibleNumero ) posibleNumero = Hola mundo let conversionErronea = Int ( posibleNumero ) // numeroConvertido y conversionErronea son de tipo Int? , o Int opcional // El primero contiene un n\u00famero y el segundo nil Debido a que el inicializador puede fallar, devuelve un Int opcional , en lugar de un Int . Un Int opcional se escribe como Int? . Para definir una variable como sin valor debemos asignarle el valor especial nil : 1 2 3 4 var codigoRespuestaServidor : Int ? = 404 // codigoRespuestaServidor contine un valor Int de 404 codigoRespuestaServidor = nil // codigoRespuestaServidor ahora no contiene ning\u00fan valor Una variable opcional sin asignar ning\u00fan valor se inicializa autom\u00e1ticamente a nil : 1 2 var respuestaEncuesta : String ? // respuestaEncuesta es inicializado autom\u00e1ticamente a nil Sentencias if y desenvoltura forzosa Se puede usar un if para comprobar si un valor opcional es distinto de nil : 1 2 3 4 if numeroConvertido != nil { print ( numeroConvertido contiene alg\u00fan valor entero. ) } // Imprime numeroConvertido contiene alg\u00fan valor entero. Si estamos seguros de que el opcional contiene un valor, podemos acceder a \u00e9l usando un signo de exclamaci\u00f3n ( ! ). Quiere decir \"S\u00e9 que hay este opcional tiene un valor concreto; por favor \u00fasalo\". Esto se conoce como desenvoltura forzosa ( forced unwrapping ) del valor opcional: 1 2 3 4 5 if numeroConvertido != nil { let numero = numeroConvertido ! print ( numeroConvertido tiene un valor entero de \\( numero ) . ) } // Imprime numeroConvertido tiene un valor entero de 123. Si se desenvuelve un opcional que contiene un nil se causa un error en tiempo de ejecuci\u00f3n: 1 2 3 let x = Int ( Hola ) let y = x ! + 100 // La sentencia anterior provoca un error en tiempo de ejecuci\u00f3n Ligado opcional Es posible comprobar si un opcional tiene valor y asignar su valor a otra variable al mismo tiempo con una construcci\u00f3n llamada ligado opcional ( optional binding ): 1 2 3 4 5 6 if let numeroVerdadero = Int ( posibleNumero ) { print ( \\ \\( posibleNumero ) \\ tiene un valor entero de \\( numeroVerdadero ) ) } else { print ( \\ \\( posibleNumero ) \\ no ha podido convertirse en un entero ) } // Imprime 123 tiene un valor entero de 123 Podemos leer el c\u00f3digo anterior de la siguiente forma: \"Si el Int opcional devuelto por Int(posibleNumero) contiene un valor, define la constante numeroVerdadero con el valor contenido en el opcional\". Si tenemos varios opcionales es posible comprobar que todos ellos son distintos de nil usando varios let en el mismo if : 1 2 3 4 5 6 7 8 9 var x1 : Int ? = pedirNumUsuario () var x2 : Int ? = pedirNumUsuario () var x3 : Int ? = pedirNumUsuario () if let dato1 = x1 , let dato2 = x2 , let dato3 = x3 { let suma = dato1 + dato2 + dato3 print ( Ning\u00fan nil y la suma de todos los datos es: \\( suma ) ) } else { print ( Alg\u00fan dato del usuario es nil ) } Ejemplos de uso de opcionales Como ejemplo de uso de opcionales adaptamos el ejemplo anterior de la funci\u00f3n minMax para que pueda recibir un array vac\u00edo, en cuyo caso devolver\u00e1 nil . 1 2 3 4 5 6 7 8 9 10 11 12 13 func minMax ( array : [ Int ]) - ( min : Int , max : Int )? { if array . isEmpty { return nil } var minActual = array [ 0 ] var maxActual = array [ 0 ] for valor in array [ 1. . array . count ] { if valor minActual { minActual = valor } else if valor maxActual { maxActual = valor } } return ( minActual , maxActual ) } Una vez obtenidos, la variable limites devuelta es tambi\u00e9n un opcional, y para obtener los valores deberemos desenvolver el resultado: 1 2 3 let limites = minMax ( array :[ 10 , 20 , - 1 ]) print ( min es \\( limites !. min ) y max es \\( limites !. max ) ) // Imprime min es -6 y max es 109 En el caso anterior sabemos que limites va a devolver un valor (porque llamamos a minMax con un array con elementos), por lo que podemos desenvolverlo sin temor de provocar un error. Sin embargo, en el ejemplo siguiente no es recomendable hacer una desenvoltura forzosa, porque no sabemos si minMax va a devolver nil o no: 1 2 3 4 5 6 7 8 let valores = pedirNums () // La funci\u00f3n pedirNums() pide una lista de // n\u00fameros por la entrada est\u00e1ndar y // devuelve un [Int] (que puede estar vac\u00edo) if let limites = minMax ( valores ) { print ( min es \\( limites . min ) y max es \\( limites . max ) ) } else { print ( No hay n\u00fameros ) } Otro ejemplo, una segunda versi\u00f3n del enum Lista , en el que utilizamos un \u00fanico case , pero dando la posibilidad de que el cdr de la lista sea nil haci\u00e9ndolo opcional: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 indirect enum Lista { case cons ( Int , Lista ?) } func suma ( lista : Lista ) - Int { switch lista { case let . cons ( car , cdr ): if ( cdr == nil ) { return car } else { return car + suma ( lista : cdr !) } } } let z : Lista = . cons ( 20 , . cons ( 10 , nil )) print ( suma ( lista : z )) /// Devuelve 30 Inmutabilidad Una de las caracter\u00edsticas funcionales importantes de Swift es el \u00e9nfasis en la inmutabilidad para reforzar la seguridad del lenguaje. Veamos algunas caracter\u00edsticas relacionadas con esto. Palabra clave let La palabra clave let permite definir constantes. El valor asignado puede no conocerse en tiempo de compilaci\u00f3n: 1 2 let maximoNumeroDeIntentosDeLogin = 10 let respuesta : String = respuestaUsuario . respuesta () Sem\u00e1ntica de copia en estructuras Una forma de evitar los efectos laterales es definir una sem\u00e1ntica de copia en la asignaci\u00f3n. En Swift la sem\u00e1ntica de una asignaci\u00f3n depende del tipo de objeto. Las estructuras ( structs ) tienen sem\u00e1ntica de copia . Veremos m\u00e1s adelante que las clases tienen una sem\u00e1ntica de referencia . El la biblioteca est\u00e1ndar de Swift la mayor parte de los tipos definidos son estructuras. Los tipos b\u00e1sicos de Swift como Int , Double , Bool , String , etc. son todos ellos estructuras y, por tanto, tienen sem\u00e1ntica de copia. 1 2 3 4 5 var str1 = Hola var str2 = str1 str1 . append ( Adios ) print ( str1 ) // Imprime HolaAdios print ( str2 ) // Imprime Hola Los arrays tambi\u00e9n son estructuras y, por tanto, tambi\u00e9n tienen sem\u00e1ntica de copia: 1 2 3 4 5 var array1 = [ 1 , 2 , 3 , 4 ] var array2 = array1 array1 [ 0 ] = 10 print ( array1 ) // [10, 2, 3, 4] print ( array2 ) // [1, 2, 3, 4] A diferencia de otros lenguajes como Java, los par\u00e1metros de una funci\u00f3n siempre son inmutables y se pasan por copia. Por ejemplo, el siguiente c\u00f3digo ser\u00eda un error: 1 2 3 4 func concat(_ str1: String, con str2: String) - String { // str1.append(str2) - error return str1 } A pesar de tener una sem\u00e1ntica de copia, la asignaci\u00f3n de un array de una variable a otra o el paso de un array como par\u00e1metro de una funci\u00f3n no realiza una copia de todo el array. El compilador de Swift optimiza estas sentencias y s\u00f3lo realiza la copia en el momento en que hay una modificaci\u00f3n de una de las variables que comparten el array. Estructuras mutables y let Si definimos un valor de una estructura con un let ese valor ser\u00e1 inmutable y no podr\u00e1 modificarse, a pesar de que el Struct tenga m\u00e9todos que mutan sus valores. Por ejemplo, hemos visto que el m\u00e9todo append(_:) de un String modifica la propia cadena. Si definimos una cadena con let no podremos modificarla: 1 2 3 4 5 6 var cadenaMutable = Hola let cadenaInmutable = Adios cadenaMutable . append ( cadenaInmutable ) // cadenaMutable es HolaAdios // cadenaInmutable.append( Adios ) // La sentencia anterior genera un error: // cannot use mutating member on immutable value: cadenaInmutable is a let constant Tipos valor y tipos referencia Un tipo valor es un tipo que tiene sem\u00e1ntica de copia en las asignaciones y cuando se pasan como par\u00e1metro en llamadas a funciones. Los tipos valor son muy \u00fatiles porque evitan los efectos laterales en los programas y simplifican el comportamiento del compilador en la gesti\u00f3n de memoria. Al no existir referencias, se simplifica enormemente la gesti\u00f3n de memoria de estas estructuras. No es necesario llevar la cuenta de qu\u00e9 referencias apuntan a un determinado valor, sino que se puede liberar la memoria en cuanto se elimina el \u00e1mbito actual. Frente a un tipo valor, un tipo de referencia es aquel en los que los valores se asignan a variables con una sem\u00e1ntica de referencia. Cuando se realizan varias asignaciones de una misma instancia a distintas variables todas ellas guardan una referencia a la misma instancia. Si la instancia se modifica, todas las variables reflejar\u00e1n el nuevo valor. Veremos que en Swift todas las instancias de clases tienen esta sem\u00e1ntica. En Swift las estructuras son tipos valor y las clases tipos de referencia. Comentaremos m\u00e1s diferencias en el tema de programaci\u00f3n orientada a objetos. Clausuras Ya hemos visto previamente que en Swift las funciones son objetos de primera clase del lenguaje y que es posible definir funciones y pasarlas como par\u00e1metro de otras funciones. Tambi\u00e9n es posible construir clausuras, funciones definidas en el \u00e1mbito de otras funcionas y devueltas como resultados. Veremos primero c\u00f3mo definir de forma compacta funciones que se pasan como par\u00e1metro de otras, utilizando expresiones de clausuras . Y despu\u00e9s veremos c\u00f3mo las clausuras definidas en el interior de otras funciones capturan las variables definidas en el \u00e1mbito de la funci\u00f3n principal. Expresiones de clausuras Swift permite definir expresiones compactas con las que construir estas funciones que se pasan como par\u00e1metro de otras funciones. Se denominan expresiones de clausuras ( closure expressions ). Estas expresiones proporcionan optimizaciones de sintaxis para escribir clausuras de forma concisa y clara. Vamos a ver las distintas optimizaciones utilizando como ejemplo el m\u00e9todo sorted(by:) . El m\u00e9todo sorted(by:) La biblioteca st\u00e1ndar de Swift define un m\u00e9todo sorted() que devuelve los elementos ordenados de un Array . El array original no se modifica. La comparaci\u00f3n entre los elementos se realiza usando el comparador . 1 2 3 4 let estudiantes = [ Kofi , Abena , Peter , Kweku , Akosua ] let ordenados = estudiantes.sorted() print(ordenados) // Prints [ Abena , Akosua , Kofi , Kweku , Peter ] Esta funci\u00f3n es similar a las que hay en muchos lenguajes. El \u00fanico aspecto funcional es que el array original no se modifica, sino que la ordenaci\u00f3n construye un nuevo array (existe una funci\u00f3n alternativa mutable que se denomina sort() ). Lo interesante relacionado con las clausuras est\u00e1 en la funci\u00f3n sorted(by:) . En esta funci\u00f3n se utiliza una clausura como par\u00e1metro para modificar la comparaci\u00f3n entre elementos y resultar en una ordenaci\u00f3n distinta. Es una de las distintas funciones de orden superior que se definen en las colecciones (m\u00e1s adelante veremos otras). El perfil de la funci\u00f3n sorted(by:) es: 1 func sorted(by areInIncreasingOrder: (Element, Element) - Bool) El par\u00e1metro es una funci\u00f3n de dos par\u00e1metros (del tipo de los elementos del array) que devuelve un booleano indicando si el primer par\u00e1metro va antes que el segundo en el array ordenado. La clausura de ordenaci\u00f3n devuelve true si el primer valor deber\u00eda aparecer antes del segundo valor y false en otro caso. Por ejemplo, podr\u00edamos ordenar un array de cadenas en orden alfab\u00e9tico inverso. 1 2 3 4 5 6 7 func primeroMayor ( s1 : String , s2 : String ) - Bool { return s1 s2 } let estudiantes = [ Kofi , Abena , Peter , Kweku , Akosua ] let alreves = estudiantes . sorted ( by : primeroMayor ) print ( alreves ) // Imprime [ Peter , Kweku , Kofi , Akosua , Abena ] Si la primera cadena ( s1 ) es mayor que la segunda cadena ( s2 ), la funci\u00f3n primeroMayor(s1:s2:) devolver\u00e1 true , indicando que s1 deber\u00eda aparecer antes que s2 en el array ordenado. La ordenaci\u00f3n mayor o menor se refiere a la ordenaci\u00f3n alfab\u00e9tica, al estar tratando con caracteres. La versi\u00f3n anterior esta es una forma bastante complicada de escribir lo que b\u00e1sicamente es una funci\u00f3n de una \u00fanica expresi\u00f3n ( a b ). En este ejemplo, ser\u00eda preferible escribir la clausura de ordenaci\u00f3n inline , utilizando la sintaxis de expresiones de clausuras. Sintaxis de las expresiones de clausura La sintaxis de las expresiones de clausura tiene la siguiente forma general: 1 2 3 { ( parametros ) - tipo devuelto in sentencias } Si aplicamos esta sintaxis al ejemplo anterior: 1 2 3 let alreves = estudiantes . sorted ( by : { ( s1 : String , s2 : String ) - Bool in return s1 s2 }) Hay que hacer notar que la declaraci\u00f3n de los par\u00e1metros y el tipo devuelto por esta clausura inline es id\u00e9ntica a la declaraci\u00f3n de la funci\u00f3n primeroMayor(s1:s2:) . En ambos casos, se escribe como (s1: String, s2: String) - Bool . Sin embargo, en la expresi\u00f3n de clausura los par\u00e1metros y el tipo devuelto se escribe dentro de las llaves, no fuera. El comienzo del cuerpo de la clausura se introduce por la palabra clave in . Esta palabra clave indica que la definici\u00f3n de los par\u00e1metros y del tipo devuelto por la clausura ha terminado, y que el cuerpo de la clausura va a comenzar. Como el cuerpo de la clausura es corto, podemos incluso escribirlo en una \u00fanica l\u00ednea: 1 let alreves = estudiantes . sorted ( by : { ( s1 : String , s2 : String ) - Bool in return s1 s2 } ) Inferencia del tipo por el contexto Como la clausura de ordenaci\u00f3n se pasa como argumento de un m\u00e9todo, Swift puede inferir los tipos de sus par\u00e1metros y el tipo del valor que devuelve. El m\u00e9todo sorted(by:) se llama sobre un array de cadenas, por lo que su argumento debe ser una funci\u00f3n del tipo (String, String) - Bool . Esto significa que los tipos (String, String) y Bool no necesitan escribirse como parte de la definici\u00f3n de la expresi\u00f3n de la clausura. Debido a que todos los tipos pueden ser inferidos, la flecha del tipo devuelto y los par\u00e9ntesis alrededor de los nombres de los par\u00e1metros tambi\u00e9n pueden omitirse: 1 let alreves = estudiantes . sorted ( by : { s1 , s2 in return s1 s2 } ) Devoluciones impl\u00edcitas en clausuras con una \u00fanica expresi\u00f3n En clausuras con una \u00fanica expresi\u00f3n podemos omitir tambi\u00e9n la palabra clave return : 1 let alreves = estudiantes . sorted ( by : { s1 , s2 in s1 s2 } ) Abreviaturas en los nombres de los argumentos Swift proporciona autom\u00e1ticamente abreviaturas para los nombres de argumentos de las clausuras inline que pueden usarse para referirse a los valores de los argumentos de la clausura usando los nombres $0 , $1 , $2 , etc. Si se usa estos argumentos abreviados, se puede omitir la definici\u00f3n de la lista de los argumentos: 1 let alreves = estudiantes . sorted ( by : { $0 $1 } ) Funciones operadoras Incluso hay una forma aun m\u00e1s corta de escribir la expresi\u00f3n de clausura anterior. Swift define una implementaci\u00f3n espec\u00edfica de cadenas del operador mayor-que ( ) como una funci\u00f3n que tiene dos par\u00e1metros de tipo String y devuelve un Bool . Esto es exactamente lo que necesita el m\u00e9todo sorted(by:) . Podemos, por tanto, pasar simplemente este operador mayor-que, y Swift inferir\u00e1 que queremos usar el espec\u00edfico de cadenas: 1 let alreves = estudiantes . sorted ( by : ) Clausuras al final Si necesitamos pasar una expresi\u00f3n de clausura a una funci\u00f3n como el argumento final de la clausura y la expresi\u00f3n es larga, puede ser \u00fatil escribirla en su lugar como una clausura al final ( trailing closure ). Una clausura al final es una expresi\u00f3n de clausura que se escribe fuera de (y despu\u00e9s de) los par\u00e9ntesis de la funci\u00f3n a la que se le pasa como par\u00e1metro: 1 let alreves = estudiantes . sorted () { $0 $1 } Cuando se proporciona una expresi\u00f3n de clausura como \u00fanico argumento de una funci\u00f3n o m\u00e9todo y se pasa como una clausura al final, no es necesario escribir los par\u00e9ntesis tras el nombre de la funci\u00f3n: 1 let alreves = estudiantes . sorted { $0 $1 } Las clausuras al final son \u00fatiles sobre todo cuando la clausura es suficientemente larga que no es posible escribirla inline en una \u00fanica l\u00ednea. Como ejemplo, el tipo Array de Swift tiene el m\u00e9todo map(_:) que toma una expresi\u00f3n de clausura como \u00fanico argumento (en el siguiente apartado hablaremos de esta y otras funciones de orden superior). La clausura se llama una vez para cada elemento del array y devuelve un valor transformado (posiblemente de otro tipo) para ese elemento. Despu\u00e9s de aplicar la clausura proporcionada a cada elemento del array, el m\u00e9todo map(_:) devuelve una array nuevo que contiene todos los nuevos valores transformados, en el mismo orden que sus valores correspondientes en el array original. Por ejemplo, podemos usar el m\u00e9todo map(_:) con una clausura al final para convertir un array de valores Int en un array de valores String . El array [16, 58, 510] se usa para crear el array 1 2 3 4 5 let digitos = [ 0 : Cero , 1 : Uno , 2 : Dos , 3 : Tres , 4 : Cuatro , 5 : Cinco , 6 : Seis , 7 : Siete , 8 : Ocho , 9 : Nueve ] let numeros = [ 16 , 58 , 510 ] El c\u00f3digo de arriba crea un diccionario que relaciona los d\u00edgitos enteros con sus nombres en castellano y un array de enteros que se convertir\u00e1n en cadenas. Ahora podemos usar el array de nombres para crear un array de valores String , pasando una expresi\u00f3n de clausura al m\u00e9todo map(_:) del array como una clausura al final: 1 2 3 4 5 6 7 8 9 10 11 12 13 let cadenas = numeros . map { ( numero ) - String in var numero = numero var salida = while numero 0 { salida = digitos [ numero % 10 ] ! + salida numero /= 10 } return salida } print ( cadenas ) // las cadenas se infieren de tipo [String] // imprime [ UnoSeis , CincoOcho , CincoUnoCero ] El m\u00e9todo map(_:) llama a la expresi\u00f3n de clausura una vez por cada elemento del array. La variable numero se incializa con el valor numero del par\u00e1metro de la clausura para poder modificarlo dentro del cuerpo de la clausura (los par\u00e1metros de las funciones y las clausuras son siempre constanes). El bucle while usa el diccionario de d\u00edgitos para construir la cadena correspondiente al valor Int . Valores capturados Una clausura puede capturar constantes y variables del contexto en el que se define. La clausura puede referirse y modificar esos valores dentro de su cuerpo, incluso si ya no existe el \u00e1mbito ( scope ) original en el que se definieron estas constantes y variables. En Swift, la forma m\u00e1s sencilla de una clausura que captura valores es una funci\u00f3n anidada ( nested function ) escrita en el cuerpo de otra funci\u00f3n. Una funci\u00f3n anidada puede capturar cualquiera de los argumentos de su funci\u00f3n exterior y tambi\u00e9n puede capturar cualquier constante y variable definida dentro de la funci\u00f3n exterior. Veamos un ejemplo similar al que vimos en Scheme. La funci\u00f3n construyeIncrementador contiene una funci\u00f3n anidada llamada incrementador . Esta funci\u00f3n captura dos valores de su contexto: totalAcumulado y cantidad . Despu\u00e9s de capturar estos valores, incrementador es devuelto por construyeIncrementador como una clausura que incrementa totalAcumulado en cantidad cada vez que se llama. 1 2 3 4 5 6 7 8 func construyeIncrementador ( incremento cantidad : Int ) - () - Int { var totalAcumulado = 0 func incrementador () - Int { totalAcumulado += cantidad return totalAcumulado } return incrementador } El tipo devuelto de construyeIncrementador es () - Int . Esto significa que devuelve una funci\u00f3n que no tiene par\u00e1metros y que devuelve un Int cada vez que es llamada. La funci\u00f3n construyeIncrementador(incremento:) tiene un \u00fanico par\u00e1metro Int con nombre externo incremento y nombre local cantidad . El argumento pasado a este par\u00e1metro especifica cu\u00e1nto ser\u00e1 incrementado totalAcumulado cada vez que se llama a la funci\u00f3n incrementador devuelta. La funci\u00f3n construyeIncrementador define una funci\u00f3n anidada llamada incrementador , que realiza el incremento real. Esta funci\u00f3n simplemente a\u00f1ade cantidad a totalAcumulado , y devuelve el resultado. Si la consideramos aislada, la funci\u00f3n anidada incrementador() podr\u00eda parecer extra\u00f1a: 1 2 3 4 func incrementador () - Int { totalAcumulado += cantidad return totalAcumulado } La funci\u00f3n no tiene ning\u00fan par\u00e1metro, y sin embargo se refiere a totalAcumulado y a cantidad en su cuerpo. Lo puede hacer porque ha capturado una referencia a estas variables de la funci\u00f3n de alrededor y las usa en su propio cuerpo. Al capturar estas referencias las variables totalAcumulado y cantidad no desaparecen cuando termina la llamada a construyeIncrementador . Estas variables tambi\u00e9n estar\u00e1n disponibles la pr\u00f3xima vez que se llame la funci\u00f3n incrementador . Aqu\u00ed hay un ejemplo de construyeIncrementador en acci\u00f3n: 1 let incrementaDiez = construyeIncrementador ( incremento : 10 ) Este ejemplo define una constante llamada incrementaDiez para referenciar la funci\u00f3n incrementador que devuelve construyeIncrementador . Esta funci\u00f3n a\u00f1ade 10 a la variable totalAcumulado cada vez que se es llamada. Si llamamos a la funci\u00f3n m\u00e1s de una vez podemos comprobar su conducta en acci\u00f3n: 1 2 3 4 5 6 incrementaDiez () // devuelve 10 incrementaDiez () // devuelve 20 incrementaDiez () // devuelve 30 Si creamos un segundo incrementador, tendr\u00e1 sus propias referencias a un variable totalAcumulado nueva, distinta de la anterior: 1 2 3 let incrementaSiete = construyeIncrementador ( incremento : 7 ) incrementaSiete () // devuelve 7 Si llamamos a la funci\u00f3n incrementador original ( incrementaDiez ) vemos que sigue incrementando su propia variable totalAcumulado y que no se ve afectada por la variable capturada por incrementaSiete : 1 2 incrementaDiez () // devuelve 40 Mutaci\u00f3n de variables capturadas Las clausuras tambi\u00e9n pueden modificar el valor de las variables capturadas. Veamos un ejemplo: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 var x = 1 func construyeFunc () - ( Int ) - Int { var x = 10 func prueba ( _ a : Int ) - Int { x = a + x return x } return prueba } let f = construyeFunc () print ( f ( 10 )) // Imprime 20 print ( f ( 10 )) // Imprime 30 let g = construyeFunc () print ( g ( 10 )) // Imprime 20 print ( x ) // Imprime 1 La clausura prueba captura la variable x definida en el \u00e1mbito de construyeFunc y la utiliza en su cuerpo. La variable capturada queda ligada a la clausura y es utilizada cada vez que la clausura se invoca. En la primera invocaci\u00f3n a la clausura se pasa como par\u00e1metro a el valor 10, que se suma a la variable capturada. De esta forma la variable capturada pasa a valer 20. En la segunda invocaci\u00f3n a la clausura el valor de x ser\u00e1 20, por lo que devolver\u00e1 30. La segunda vez que llamamos a construyeFunc se crea un nuevo \u00e1mbito local con una nueva variable x que se inicializa a 10. Esa nueva variable es el que captura la nueva clausura que se devuelve. Por eso al invocarla (en la llamada g(10) ) se devuelve 20. Las clausuras son tipos de referencia En el ejemplo anterior, incrementaSiete e incrementaDiez son constantes, pero las clausuras a las que estas constantes se refieren pueden incrementar la variable totalAcumulado que han capturado. Esto es porque funciones y clausuras son tipos referencia. Siempre que asignamos una funci\u00f3n o una clausura a una constante o una variable, estamos realmente estableciendo que la constante o variable es una referencia a la funci\u00f3n o la clausura. En el ejemplo anterior, es la elecci\u00f3n de la clausura a la que referencia incrementaDiez la que es constante, no los contenidos propios de la clausura. Esto tambi\u00e9n significa que si asignamos una clausura a dos constantes o variables distintas, ambas constantes o variables se referir\u00e1n a la misma clausura: 1 2 3 let tambienIncrementaDiez = incrementaDiez tambienIncrementaDiez () // devuelve 50 Funciones de orden superior Una de las caracter\u00edsticas funcionales que m\u00e1s hemos usado para trabajar con listas en Scheme son las funciones de orden superior como map , filter o fold-right . Swift tiene definidas funciones equivalentes para trabajar con colecciones. Se denominan map , filter y reduce . Todas ellas aceptan expresiones de clausura como argumento. Map El m\u00e9todo map se define en el protocolo CollectionType y es adoptado por m\u00faltiples estructuras como Array , Dictionary , Set o String.CharacterView . El m\u00e9todo map recibe como par\u00e1metro una funci\u00f3n unaria transform del tipo de los elementos de la colecci\u00f3n y que devuelve otro elemento (puede ser del mismo o de distinto tipo que los elementos de la colecci\u00f3n). Devuelve un array que contiene el resultado de aplicar transform a cada elemento del array original. Por ejemplo: 1 2 3 let numeros = [ Int ]( 0. .. 5 ) numeros . map { $0 * $0 } // devuelve [0, 1, 4, 9, 16, 25] Otro ejemplo, en el que usamos map para implementar la funci\u00f3n sumaParejas(parejas: [(Int, Int)]) - [Int] que devuelve recibe el array parejas de tuplas de dos enteros y devuelve un array con el resultado de sumar los dos elementos de cada pareja: 1 2 3 4 5 6 func suma ( parejas : [( Int , Int )]) - [ Int ] { return parejas . map ({( pareja : ( Int , Int )) - Int in return pareja . 0 + pareja . 1 }) } suma ( parejas :[( 1 , 1 ), ( 2 , 2 ), ( 3 , 3 ), ( 4 , 4 )]) // devuelve [2, 4, 6, 8] Podemos usar en el cuerpo de la expresi\u00f3n de clausura de map una variable capturada. Por ejemplo en la siguiente funci\u00f3n incrementaValores(_:con:) que suma con a todos los n\u00fameros de un array que se le pasa por par\u00e1metro: 1 2 3 4 5 6 func incrementa ( valores : [ Int ], con : Int ) - [ Int ] { return valores . map ({( x : Int ) - Int in return x + con }) } incrementa ( valores :[ 10 , 20 , 30 ], con : 5 ) // devuelve [15, 25, 35] La versi\u00f3n abreviada de la expresi\u00f3n de clausura es: 1 2 3 4 5 func incrementa ( valores : [ Int ], con inc : Int ) - [ Int ] { return valores . map { $0 + inc } } incrementa ( valores : [ 10 , 20 , 30 ], con : 5 ) // devuelve [15, 25, 35] Filter La funci\u00f3n filter recibe una clausura de un argumento que devuelve un booleano. La funci\u00f3n devuelve una colecci\u00f3n con los elementos de la colecci\u00f3n para los que la clausura devuelve true . Ejemplo: 1 2 3 let numeros = [ Int ]( 0. .. 10 ) numeros . filter { $0 % 2 == 0 } // devuelve [0, 2, 4, 6, 8, 10] Reduce Similar al fold de Scheme: 1 2 let numeros = [ Int ]( 0. .. 10 ) numeros . reduce ( 0 , + ) La funci\u00f3n combina los elementos de la colecci\u00f3n usando la funci\u00f3n de combinaci\u00f3n que se pasa como par\u00e1metro. La funci\u00f3n que se pasa como par\u00e1metro recibe dos par\u00e1metros: el primero es el resultado de la combinaci\u00f3n y el segundo se coge de la colecci\u00f3n. Por ejemplo: 1 2 3 4 let cadenas = [ Patatas , Arroz , Huevos ] cadenas . reduce ( 0 , {( i : Int , c : String ) - Int in c . count + i }) // devuelve 18 Es posible simplificar la notaci\u00f3n anterior: 1 cadenas . reduce ( 0 , { $1 . count + $0 }) Tambi\u00e9n se puede utilizar la notaci\u00f3n de clausura al final: 1 cadenas . reduce ( 0 ) { $1 . count + $0 } La combinaci\u00f3n se hace de izquierda a derecha: 1 2 3 let cadenas = [ Patatas , Arroz , Huevos ] cadenas . reduce ( , + ) // devuelve PatatasArrozHuevos Combinaci\u00f3n de funciones de orden superior Cuando el resultado de aplicar una funci\u00f3n de orden superior a una colecci\u00f3n es otra colecci\u00f3n es posible aplicar otra funci\u00f3n de orden superior a este resultado. Por ejemplo, la siguiente sentencia devuelve todos los n\u00fameros pares del array inicial elevados al cuadrado: 1 2 3 let numeros = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] numeros . filter { $0 % 2 == 0 }. map { $0 * $0 } // Devuelve el array [4,16,36,64,100] Y la siguiente devuelve la suma n\u00fameros mayores de 100: 1 2 3 let numeros = [ 103 , 2 , 330 , 42 , 532 , 6 , 125 ] numeros . filter { $0 = 100 }. reduce ( 0 , + ) // Devuelve 1090 Gen\u00e9ricos Empecemos con un ejemplo sencillo. Supongamos la siguiente funci\u00f3n intercambia(_:) que recibe una tupla (Int, String) y devuelve una tupla (String, Int) con los valores intercambiados. 1 2 3 4 5 6 7 8 func intercambia ( _ tupla : ( Int , String )) - ( String , Int ) { let tuplaNueva = ( tupla . 1 , tupla . 0 ) return tuplaNueva } let tupla = ( 10 , Hola ) intercambia ( tupla ) // devuelve ( Hola , 10) La funci\u00f3n es interesante, pero s\u00f3lo recibe tuplas cuya primera componente es un Int y su segunda componente es un String . Supongamos que queremos hacer la misma funci\u00f3n para intercambiar elementos de una tupla (Int, Int) . Tendr\u00edamos que usar el mismo c\u00f3digo, pero cambiando los tipos: 1 2 3 4 5 6 7 8 func intercambia ( _ tupla : ( Int , Int )) - ( Int , Int ) { let tuplaNueva = ( tupla . 1 , tupla . 0 ) return tuplaNueva } let tupla = ( 10 , 20 ) intercambia ( tupla ) // devuelve (20, 10) El c\u00f3digo es el mismo, lo \u00fanico distinto son los tipos. \u00bfPodr\u00edamos generalizar las funciones anteriores para hacer que el c\u00f3digo pueda trabajar con cualquier tipo? La respuesta es s\u00ed, usando funci\u00f3n gen\u00e9rica : 1 2 3 4 func intercambia A , B ( _ tupla : ( A , B )) - ( B , A ) { let tuplaNueva = ( tupla . 1 , tupla . 0 ) return tuplaNueva } El cuerpo de la funci\u00f3n es id\u00e9ntico a la funci\u00f3n anterior. La diferencia es que en la versi\u00f3n gen\u00e9rica se usan placeholders (los s\u00edmbolos A y B ) en lugar de tipos concretos. Son tipos gen\u00e9ricos, que se definen usando un identificador entre s\u00edmbolos de y . Los tipos reales que se van a usar en la funci\u00f3n se determinan en cada invocaci\u00f3n a la funci\u00f3n, dependiendo del tipo del par\u00e1metro que se utiliza en la llamada: 1 2 3 4 5 6 7 8 9 let tupla = ( 10 , Hola ) intercambia ( tupla ) // devuelve ( Hola , 10) let tupla2 = ( 10 , 20 ) intercambia ( tupla2 ) // devuelve (10, 20) let tupla3 = ( true , 10.5 ) intercambia ( tupla3 ) // devuelve (10.5, true) En el primer ejemplo, los tipos A y B se infieren como Int y String . En el segundo ejemplo como Int e Int . Y en el tercero como Bool y Double . Los tipos gen\u00e9ricos se pueden usar en la definici\u00f3n de todos los elementos de Swift: funciones, enums, estructuras, clases, protocolos o extensiones. Terminamos con un ejemplo en el que incluimos muchos conceptos vistos en este tema. Se trata de la implementaci\u00f3n en Swift de listas al estilo Scheme, con las funciones car , cdr y vacia usando un enum recursivo con un tipo gen\u00e9rico que permite generalizar el tipo de elementos de la lista. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 indirect enum Lista T { case vacia case cons ( T , Lista T ) } func car T ( _ lista : Lista T ) - T ? { switch lista { case let . cons ( primero , _ ): return primero case . vacia : return nil } } func cdr T ( _ lista : Lista T ) - Lista T ? { switch lista { case let . cons ( _ , resto ): return resto case . vacia : return nil } } func vacia T ( _ lista : Lista T ) - Bool { switch lista { case . vacia : return true default : return false } } let lista : Lista = . cons ( 20 , . cons ( 30 , . cons ( 40 , . vacia ))) print ( car ( lista ) ! ) // Imprime 20 print ( car ( cdr ( lista ) ! ) ! ) // Imprime 30 print ( car ( cdr ( cdr ( lista ) ! ) ! ) ! ) // Imprime 40 print ( vacia ( cdr ( cdr ( cdr ( lista ) ! ) ! ) ! )) // Imprime true Bibliograf\u00eda Swift Language Guide The Basics Collection Types Functions Closures Enumerations Generics Biblioteca est\u00e1ndar de Swift Lenguajes y Paradigmas de Programaci\u00f3n, curso 2018\u201319 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Domingo Gallardo, Cristina Pomares, Antonio Bot\u00eda, Francisco Mart\u00ednez","title":"Tema 5: Programaci\u00f3n Funcional con Swift"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#tema-5-programacion-funcional-con-swift","text":"","title":"Tema 5: Programaci\u00f3n Funcional con Swift"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#introduccion","text":"Te recomendamos que leas el seminario de Swift , en el que se introduce el lenguaje y se explica c\u00f3mo ejecutar programas en este lenguaje: El lenguaje de programaci\u00f3n Swift Swift es un lenguaje principalmente imperativo, pero en su dise\u00f1o se han introducido conceptos modernos de programaci\u00f3n funcional, extra\u00eddos de lenguajes como Rust o Haskell. Como dice su creador Chris Lattner : El lenguaje Swift es el resultado de un esfuerzo incansable de un equipo de expertos en lenguajes, gur\u00fas de documentaci\u00f3n, ninjas de optimizaci\u00f3n de compiladores [..]. Por supuesto, tambi\u00e9n se benefici\u00f3 enormemente de las experiencias ganadas en muchos otros lenguajes, tomando ideas de Objective-C, Rust, Haskell, Ruby, Python, C#, CLU, y demasiados otros para ser enumerados. Vamos a repasar en este tema c\u00f3mo se implementan en Swift conceptos principalmente funcionales como: Valores inmutables Funciones como objetos de primera clase y clasuras Funciones de orden superior Repasamos r\u00e1pidamente algunos conceptos b\u00e1sicos de programaci\u00f3n funcional, vistos en los primeros temas de la asignatura. Programaci\u00f3n Funcional: La Programaci\u00f3n Funcional es un paradigma de programaci\u00f3n que trata la computaci\u00f3n como la evaluaci\u00f3n de funciones matem\u00e1ticas y que evita cambios de estado y datos mutables. Funciones matem\u00e1ticas o puras: Las funciones matem\u00e1ticas tienen la caracter\u00edstica de que cuando las invocas con el mismo argumento siempre te devolver\u00e1n el mismo resultado. Funciones como objetos de primera clase: En programaci\u00f3n funcional, las funciones son objetos de primera clase del lenguaje, similares a enteros o strings . Podemos pasar funciones como argumentos en las denominadas funciones de orden superior o devolver funciones creadas en tiempo de ejecuci\u00f3n (clausuras).","title":"Introducci\u00f3n"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#funciones","text":"","title":"Funciones"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#definicion-de-una-funcion-en-swift","text":"Para definir una funci\u00f3n en Swift se debe usar la palabra func , definir el nombre de la funci\u00f3n, sus par\u00e1metros y el tipo de vuelto. El valor devuelto por la funci\u00f3n se debe devolver usando la palabra return . C\u00f3digo de la funci\u00f3n saluda(nombre:) : 1 2 3 4 func saluda ( nombre : String ) - String { let saludo = Hola, + nombre + ! return saludo } Para invocar a la funci\u00f3n saluda(nombre:) : 1 2 3 4 print ( saluda ( nombre : Ana )) print ( saluda ( nombre : Pedro )) // Imprime Hola, Ana! // Imprime Hola, Pedro!","title":"Definici\u00f3n de una funci\u00f3n en Swift"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#etiquetas-de-argumentos-y-nombres-de-parametros","text":"Cada par\u00e1metro de una funci\u00f3n tiene una etiqueta del argumento y un nombre de par\u00e1metro. La etiqueta del argumento se usa cuando se llama a la funci\u00f3n y el nombre del par\u00e1metro se usa internamente en su implementaci\u00f3n. Por defecto, los par\u00e1metros usan su nombre de par\u00e1metro como etiqueta del argumento: 1 2 3 4 5 6 func unaFuncion ( primerNombreParametro : Int , segundoNombreParametro : Int ) { // En el cuerpo de la funci\u00f3n, primerNombreParametro y // segundoNombreParametro se refieren a los valores de los // argumentos del primer y el segundo par\u00e1metro } unaFuncion ( primerNombreParametro : 1 , segundoNombreParametro : 2 ) Es posible hacer distintos la etiqueta del argumento del nombre del par\u00e1metro: 1 2 3 4 5 func saluda ( nombre : String , de ciudad : String ) - String { return Hola \\( nombre ) ! Me alegro de que hayas podido visitarnos desde \\( ciudad ) . } print ( saluda ( nombre : Bill , de : Cupertino )) // Imprime Hola Bill! Me alegro de que hayas podido visitarnos desde Cupertino. Otro ejemplo, la siguiente funci\u00f3n concatena(palabra:con:) : 1 2 3 4 5 func concatena ( palabra str1 : String , con str2 : String ) - String { return str1 + str2 } print ( concatena ( palabra : Hola , con : adios )) Si no se quiere una etiqueta del argumento para un par\u00e1metro, se puede escribir un subrayado ( _ ) en lugar de una etiqueta del argumento expl\u00edcita para ese par\u00e1metro: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 func max ( _ x : Int , _ y : Int ) - Int { if x y { return x } else { return y } } print ( max ( 10 , 3 )) func divide ( _ x : Double , entre y : Double ) - Double { return x / y } print ( divide ( 30 , entre : 4 )) El perfil de la funci\u00f3n est\u00e1 formado por el nombre de la funci\u00f3n, las etiquetas de los argumentos y el tipo devuelto por la funci\u00f3n. En la documentaci\u00f3n de las funciones usaremos las etiquetas separadas por dos puntos. Por ejemplo, las funciones anteriores son max(_:_:) y divide(_:entre:) .","title":"Etiquetas de argumentos y nombres de par\u00e1metros"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#parametros-y-valores-devueltos","text":"Es posible definir funciones sin par\u00e1metros: 1 2 3 4 5 func diHolaMundo () - String { return hola, mundo } print ( diHolaMundo ()) // Imprime hola, mundo Podemos definir funciones sin valor devuelto. Por ejemplo, la siguiente funci\u00f3n diAdios(nombre:) . No hay que escribir flecha con el tipo devuelto. Cuidado, no ser\u00eda propiamente programaci\u00f3n funcional. 1 2 3 4 5 func diAdios ( nombre : String ) { print ( Adi\u00f3s, \\( nombre ) ! ) } diAdios ( nombre : Dave ) // Imprime Adi\u00f3s, Dave! Es posible devolver m\u00faltiples valores, construyendo una tupla. Por ejemplo, la siguiente funci\u00f3n minMax(array:) busca el n\u00famero m\u00e1s peque\u00f1o y m\u00e1s grande de un array de enteros. 1 2 3 4 5 6 7 8 9 10 11 12 func minMax ( array : [ Int ]) - ( min : Int , max : Int ) { var minActual = array [ 0 ] var maxActual = array [ 0 ] for valor in array [ 1. . array . count ] { if valor minActual { minActual = valor } else if valor maxActual { maxActual = valor } } return ( minActual , maxActual ) } Los valores de la tupla devuelta se etiquetan y se puede acceder por esos nombres cuando se consulta el valor devuelto por la funci\u00f3n: 1 2 3 let limites = minMax ( array : [ 8 , - 6 , 2 , 109 , 3 , 71 ]) print ( min es \\( limites . min ) y max es \\( limites . max ) ) // Imprime min es -6 y max es 109","title":"Par\u00e1metros y valores devueltos"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#tipos-funcion","text":"En Swift las funciones son objetos de primera clase y podemos asignarlas a variables, pasarlas como par\u00e1metro o devolverlas como resultado de otra funci\u00f3n. Al ser un lenguaje fuertemente tipado, las variables, par\u00e1metros o resultados deben ser objetos de tipo funci\u00f3n. Cada funci\u00f3n tiene un tipo espec\u00edfico, definido por el tipo de sus par\u00e1metros y el tipo del valor devuelto. 1 2 3 4 5 6 func sumaDosInts ( _ a : Int , _ b : Int ) - Int { return a + b } func multiplicaDosInts ( _ a : Int , _ b : Int ) - Int { return a * b } El tipo de estas funciones es (Int, Int) - Int , que se puede leer como: \"Un tipo funci\u00f3n que tiene dos par\u00e1metros, ambos de tipo Int y que devuelve un valor de tipo Int \". En Swift se puede usar un tipo funci\u00f3n de la misma forma que cualquier otro tipo: 1 2 3 4 var funcionMatematica : ( Int , Int ) - Int = sumaDosInts print ( Resultado: \\( funcionMatematica ( 2 , 3 )) ) funcionMatematica = multiplicaDosInts print ( Resultado: \\( funcionMatematica ( 2 , 3 )) )","title":"Tipos funci\u00f3n"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#funciones-que-reciben-otras-funciones","text":"Podemos usar un tipo funci\u00f3n en par\u00e1metros de otras funciones: 1 2 3 4 5 func printResultado ( funcion : ( Int , Int ) - Int , _ a : Int , _ b : Int ) { print ( Resultado: \\( funcionMatematica ( a , b )) ) } printResultado ( funcion : sumaDosInts , 3 , 5 ) // Prints Resultado: 8 La funci\u00f3n printResultado(funcion:_:_:) toma como primer par\u00e1metro otra funci\u00f3n que recibe dos Int y devuelve un Int , y como segundo y tercer par\u00e1metro dos Int . Veamos otro ejemplo, que ya vimos en Scheme. Supongamos que queremos calcular el sumatorio desde a hasta b en el que aplicamos una funci\u00f3n f a cada n\u00famero que sumamos: 1 sumatorio(a, b, f) = f(a) + f(a+1) + f(a+2) + ... + f(b) Recordamos que se resuelve con la siguiente recursi\u00f3n: 1 2 sumatorio(a, b, f) = f(a) + sumatorio(a+1, b, f) sumatorio(a, b, f) = 0 si a b Veamos c\u00f3mo se implementa en Swift: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 func sumatorio ( desde a : Int , hasta b : Int , func f : ( Int ) - Int ) - Int { if a b { return 0 } else { return f ( a ) + sumatorio ( desde : a + 1 , hasta : b , func : f ) } } func identidad ( _ x : Int ) - Int { return x } func doble ( _ x : Int ) - Int { return x + x } func cuadrado ( _ x : Int ) - Int { return x * x } print ( sumatorio ( desde : 0 , hasta : 10 , func : identidad )) // Imprime 55 print ( sumatorio ( desde : 0 , hasta : 10 , func : doble )) // Imprime 110 print ( sumatorio ( desde : 0 , hasta : 10 , func : cuadrado )) // Imprime 385","title":"Funciones que reciben otras funciones"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#funciones-en-estructuras","text":"Como cualquier otro tipo Las funciones pueden tambi\u00e9n incluirse en estructuras de datos compuestas, como arrays: 1 2 3 4 var funciones = [ identidad , doble , cuadrado ] print ( funciones [ 0 ]( 10 )) // 10 print ( funciones [ 1 ]( 10 )) // 20 print ( funciones [ 2 ]( 10 )) // 100 El tipo de la variable funciones ser\u00eda [(Int) - Int] . Al ser Swift fuertemente tipeado, no podr\u00edamos hacer un array con distintos tipos de funciones. Por ejemplo el siguiente c\u00f3digo dar\u00eda un error: 1 2 3 4 5 6 7 func suma ( _ x : Int , _ y : Int ) - Int { return x + y } // La siguiente l\u00ednea genera un error var misFunciones = [ doble , cuadrado , suma ] // error: heterogenous collection literal could only be inferred to // [Any] ; add explicit type annotation if this is intentional","title":"Funciones en estructuras"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#funciones-que-devuelven-otras-funciones","text":"Por \u00faltimo, veamos un ejemplo de funciones que devuelven otras funciones. Empecemos por un ejemplo sencillo de una funci\u00f3n que devuelve otra que suma 10: 1 2 3 4 5 6 7 8 func makeSumador10 () - ( Int ) - Int { func suma10 ( x : Int ) - Int { return x + 10 } return suma10 } var f = makeSumador10 () print ( f ( 20 )) // Imprime 30 Hay que hacer notar la declaraci\u00f3n de la funci\u00f3n makeSumador10 . Es una funci\u00f3n que no recibe argumentos y que devuelve otra funci\u00f3n del tipo (Int) - Int , esto es, una funci\u00f3n que recibe un entero y devuelve otro entero. Otro ejemplo, un poco m\u00e1s complicado: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 func eligeFuncionPaso ( menorQueCero : Bool ) - ( Int ) - Int { func pasoAdelante ( x : Int ) - Int { return x + 1 } func pasoAtras ( x : Int ) - Int { return x - 1 } return menorQueCero ? pasoAdelante : pasoAtras } var valorActual = - 4 let acercarseACero = eligeFuncionPaso ( menorQueCero : valorActual 0 ) // acercarseACero ahora se refiere a la funci\u00f3n anidada pasoAdelante while valorActual != 0 { print ( \\( valorActual ) ... ) valorActual = acercarseACero ( valorActual ) } print ( cero! ) // -4... // -3... // -2... // -1... // cero!","title":"Funciones que devuelven otras funciones"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#recursion","text":"Ejemplos de funciones recursivas en Swift. Recursi\u00f3n pura: 1 2 3 4 5 6 7 8 9 func suma ( hasta x : Int ) - Int { if x == 0 { return 0 } else { return x + suma ( hasta : x - 1 ) } } print ( suma ( hasta : 5 )) Los arrays en Swift no funcionan exactamente como las listas de Scheme (no son listas de parejas), pero podr\u00edamos obtener el primer elemento y el resto de la siguiente forma. 1 2 3 let a = [ 10 , 20 , 30 , 40 , 50 , 60 ] let primero = a . first ! let resto = a . dropFirst () En primero se guarda el n\u00famero 10. El s\u00edmbolo ! sirve para desenvolver el opcional que devuelve first (veremos despu\u00e9s este concepto). En resto se guarda un ArraySlice del 20 al 60. Es una vista de un rango de elementos del array, en este caso el que va desde la posici\u00f3n 1 hasta la 5 (la posici\u00f3n inicial de un array es la 0). Un ArraySlice en un un Array : 1 let resto = Array ( a . dropFirst ()) De esta forma podemos definir la funci\u00f3n recursiva que suma los valores de un Array de la siguiente forma: 1 2 3 4 5 6 7 8 9 10 func sumaValores ( _ valores : [ Int ]) - Int { if let primero = valores . first { let resto = Array ( valores . dropFirst ()) return primero + sumaValores ( resto ) } else { return 0 } } print ( sumaValores ([ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 ])) // 36 Veremos que las colecciones en Swift implementan funciones de orden superior como map , filter , etc. Veremos tambi\u00e9n m\u00e1s adelante otras funciones recursivas cuando definamos \u00e1rboles en Swift.","title":"Recursi\u00f3n"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#tipos","text":"Swift es un lenguaje fuertemente tipeado, a diferencia de Scheme. Muchos otros lenguajes de programaci\u00f3n funcional, como Haskell o Clojure tambi\u00e9n lo son. Entre las ventajas del uso de tipos est\u00e1 la detecci\u00f3n de errores en los programas en tiempo de compilaci\u00f3n o las ayudas del entorno de desarrollo para autocompletar c\u00f3digo. Entre los inconvenientes se encuentra la necesidad de ser m\u00e1s estrictos a la hora de definir los par\u00e1metros y los valores devueltos por las funciones, lo que impide la flexibilidad de Scheme. Se utilizan tipos para definir los posibles valores de: variables par\u00e1metros de funciones valores devueltos por funciones Las definiciones de tipos van precedidas de dos puntos en las variables y par\u00e1metros, o de una flecha ( - ) en la definici\u00f3n de los tipos de los valores devueltos por una funci\u00f3n: 1 2 3 4 5 6 let valorDouble : Double = 3.0 let unaCadena : String = Hola func calculaEstadisticas ( valores : Array Int ) - ( min : Int , max : Int , media : Int ) { ... } En Swift existen dos clases de tipos: tipos con nombre y tipos compuestos.","title":"Tipos"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#tipos-con-nombre","text":"Un tipo con nombre es un tipo al que se le puede dar un nombre determinado cuando se define. Definimos un tipo al definir: nombres de clases nombres de estructuras nombres de enumeraciones nombres de protocolos Por ejemplo, instancias de una clase definida por el usuario llamada MiClase tienen el tipo MiClase . Adem\u00e1s de los tipos definidos por el usuario, la biblioteca est\u00e1ndar de Swift tiene un gran n\u00famero de tipos predefinidos. A diferencia de otros lenguajes, estos tipos no son parte del propio lenguaje sino que se definen en su mayor\u00eda como estructuras implementadas en esta biblioteca est\u00e1ndar. Por ejemplo, arrays, diccionarios o incluso los tipos m\u00e1s b\u00e1sicos como String o Int est\u00e1n construidos en esa biblioteca.","title":"Tipos con nombre"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#tipos-compuestos","text":"Los tipos compuestos son tipos sin nombre. En Swift se definen dos: tuplas y tipos funci\u00f3n. Un tipo compuesto puede tener tipos con nombre y otros tipos compuestos. Por ejemplo la tupla (Int, (Int, Int)) contiene dos elementos: el primero es el tipo con nombre Int y el segundo el tipo compuesto que define la tupla (Int, Int) . Los tipos funci\u00f3n los hemos visto previamente. 1 2 3 4 5 6 7 8 9 10 11 let tupla : ( Int , Int , String ) = ( 2 , 3 , Hola ) let otraTupla : ( Int , Int , String ) = ( 5 , 8 , Adios ) func sumaTupla ( tupla t1 : ( Int , Int ), con t2 : ( Int , Int )) - ( Int , Int ) { return ( t1 . 0 + t2 . 0 , t1 . 1 + t2 . 1 ) } print ( sumaTupla ( tupla : ( tupla . 0 , tupla . 1 ), con : ( otraTupla . 0 , otraTupla . 1 ))) // Imprime (7, 11)","title":"Tipos compuestos"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#enumeraciones","text":"Las enumeraciones definen un tipo con un valor restringido de posibles valores: 1 2 3 4 5 6 enum Direccion { case norte case sur case este case oeste } Cualquier variable del tipo Direccion solo puede tener uno de los cuatro valores definidos. Se obtiene el valor escribiendo el nombre de la enumeraci\u00f3n, un punto y el valor definido. Si el tipo de enumeraci\u00f3n se puede inferir no es necesario escribirlo. 1 2 3 4 5 let hemosGirado = true var direccionActual = Direccion . norte if hemosGirado { direccionActual = . sur } En sentencias switch: 1 2 3 4 5 6 7 8 9 10 11 12 let direccionAIr = Direccion . sur switch direccionAIr { case . norte : print ( Nos vamos al norte ) case . sur : print ( Cuidado con los pinguinos ) case . este : print ( Donde nace el sol ) case . oeste : print ( Donde el cielo es azul ) } // Imprime Cuidado con los pinguinos Otro ejemplo: 1 2 3 enum Planeta { case mercurio , venus , tierra , marte , jupiter , saturno , urano , neptuno }","title":"Enumeraciones"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#valores-brutos-de-enumeraciones","text":"Es posible asignar a las constantes del enumerado un valor concreto de un tipo subyacente: 1 2 3 4 5 enum CaracterControlASCII : Character { case tab = \\t case lineFeed = \\n case carriageReturn = \\r } Se puede devolver el valor bruto de la siguiente forma: 1 let nuevaLinea = CaracterControlASCII.LineFeed.rawValue Tambi\u00e9n se puede hacer de forma impl\u00edcita cuando el tipo subyacente es Int , dando un valor a la primera constante: 1 2 3 4 5 enum Planeta : Int { case mercurio = 1 , venus , tierra , marte , jupiter , saturno , urano , neptuno } let posicionTierra = Planeta . tierra . rawValue // posicionTierra es 3 Por \u00faltimo, se puede definir como tipo subyacente String y los valores brutos de las constantes ser\u00e1n sus nombres convertidos a cadenas: 1 2 3 4 5 enum Direccion : String { case norte , sur , este , oeste } let direccionAtardecer = Direccion . oeste . rawValue // direccionAtardecer es oeste Cuando se definen valores brutos es posible inicializar el enumerado de una forma similar a una estructura o una clase pasando el valor bruto. Devuelve el valor enumerado correspondiente o nil (un opcional): 1 2 let posiblePlaneta = Planeta ( rawValue : 7 ) // posiblePlaneta es de tipo Planeta? y es igual a Planeta.urano","title":"Valores brutos de enumeraciones"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#valores-asociados-a-instancias-de-enumeraciones","text":"En otros lenguajes de programaci\u00f3n se llaman uniones etiquetadas o variantes . Permiten asociar valores de otro tipo a las opciones del enumerado. Una instancia de un caso de enumeraci\u00f3n puede tener valores asociados con la instancia. Instancias del mismo caso de enumeraci\u00f3n pueden tener asociados valores diferentes. Se proporciona el valor asociado cuando se crea la instancia. Los valores asociados y los valores brutos son distintos: el valor bruto de un caso de enumeraci\u00f3n es el mismo para todas las instancias, mientras que el valor asociado se proporciona cuando se define el valor concreto de la enumeraci\u00f3n. Veamos un ejemplo, en el que usamos un enum para definir posibles valores de un c\u00f3digo de barras, en el que incluimos dos posibles tipos de c\u00f3digo de barras: el c\u00f3digo de barras lineal (denominado UPC) y el c\u00f3digo QR: 1 2 3 4 enum CodigoBarras { case upc ( Int , Int , Int , Int ) case qrCode ( String ) } Se lee de la siguiente forma: \u201cDefinimos un tipo enumerado llamado CodigoBarras , que puede tomar como valor un upc (c\u00f3digo de barras lineal) con un valor asociado de tipo (Int, Int, Int, Int) (los 4 n\u00fameros que hay en los c\u00f3digos de barras lineales) o un valor qrCode con valor asociado de tipo String \". Esta definici\u00f3n no proporciona valores concretos de Int o String , sino que define el tipo de valores asociados que las constantes y variables pueden almacenar cuando son de tipo CodigoBarras.upc o CodigoBarras.qrCode . 1 2 3 4 5 6 7 8 9 10 var codigoBarrasProducto = CodigoBarras . upc ( 8 , 85909 , 51226 , 3 ) codigoBarrasProducto = . qrCode ( ABCDEFGHIJKLMNOP ) switch codigoBarrasProducto { case let . upc ( sistemaNumeracion , fabricante , producto , control ): print ( UPC: \\( sistemaNumeracion ) , \\( fabricante ) , \\( producto ) , \\( control ) . ) case let . qrCode ( codigoProducto ): print ( C\u00f3digo QR: \\( codigoProducto ) . ) } // Imprime C\u00f3digo QR : ABCDEFGHIJKLMNOP.","title":"Valores asociados a instancias de enumeraciones"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#enumeraciones-recursivas","text":"Es posible combinar las caracter\u00edsticas de las enumeraciones con valor con la recursi\u00f3n para crear enumeraciones recursivas. Hay que preceder la palabra clave enum con indirect : 1 2 3 4 5 6 7 8 9 10 indirect enum ExpresionAritmetica { case numero ( Int ) case suma ( ExpresionAritmetica , ExpresionAritmetica ) case multiplicacion ( ExpresionAritmetica , ExpresionAritmetica ) } let cinco = ExpresionAritmetica . numero ( 5 ) let cuatro = ExpresionAritmetica . numero ( 4 ) let suma = ExpresionAritmetica . suma ( cinco , cuatro ) let producto = ExpresionAritmetica . multiplicacion ( suma , ExpresionAritmetica . numero ( 2 )) Es muy c\u00f3modo manejar enumeraciones recursivas de forma recursiva: 1 2 3 4 5 6 7 8 9 10 11 12 13 func evalua ( expresion : ExpresionAritmetica ) - Int { switch expresion { case let . numero ( valor ): return valor case let . suma ( izquierda , derecha ): return evalua ( expresion : izquierda ) + evalua ( expresion : derecha ) case let . multiplicacion ( izquierda , derecha ): return evalua ( expresion : izquierda ) * evalua ( expresion : derecha ) } } print ( evalua ( expresion : producto )) // Imprime 18 Otro ejemplo de enums recursivos, para definir un tipo de datos Lista basado en parejas (similar a Scheme): 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 indirect enum Lista { case vacia case cons ( Int , Lista ) } func suma ( lista : Lista ) - Int { switch lista { case . vacia : return 0 case let . cons ( car , cdr ): return car + suma ( lista : cdr ) } } let z : Lista = . cons ( 20 , . cons ( 10 , . vacia )) print ( suma ( lista : z )) // Imprime 30 Podemos definir tambi\u00e9n una funci\u00f3n recursiva makeLista(array:[Int]) que devuelve una lista a partir de una array de enteros: 1 2 3 4 5 6 7 8 9 10 11 12 13 func make ( lista : [ Int ]) - Lista { if let primero = lista . first { let resto = Array ( lista . dropFirst ()) return Lista . cons ( primero , make ( lista : resto )) } else { return Lista . vacia } } let lista = make ( lista : [ 1 , 2 , 3 , 4 , 5 ]) print ( suma ( lista : lista )) // Imprime 15","title":"Enumeraciones recursivas"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#typealias","text":"En Swift se define la palabra clave typealias para darle un nombre asignado a cualquier otro tipo. Ambos tipos son iguales a todos los efectos (es \u00fanicamente az\u00facar sint\u00e1ctico). 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 typealias Resultado = ( Int , Int ) enum Quiniela { case uno , equis , dos } func quiniela ( resultado : Resultado ) - Quiniela { switch resultado { case let ( goles1 , goles2 ) where goles1 goles2 : return . dos case let ( goles1 , goles2 ) where goles1 goles2 : return . uno default : return . equis } } print ( quiniela ( resultado : ( 1 , 3 ))) // Imprime Dos print ( quiniela ( resultado : ( 2 , 2 ))) // Imprime Equis","title":"Typealias"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#opcionales","text":"En Swift el valor nulo se representa con nil (equivalente a null en Java). No podemos asignar nil a una variable de un tipo dado: 1 2 // La siguiente l\u00ednea dar\u00eda un error en tiempo de compilaci\u00f3n // let cadena: String = nil Los tipos opcionales de Swift permiten asignar a variables o bien un valor propio del tipo o bien nil , de forma que podemos expresar situaciones en las que: Hay un valor y es igual que x o No hay ning\u00fan valor Podemos definir como opcional variables, par\u00e1metros o valores devueltos por funciones. Por ejemplo, el tipo Int de Swift tiene un inicializador que intenta convertir un valor String a un valor Int . Sin embargo, no toda cadena puede convertirse a un n\u00famero. Por ejemplo, la cadena \"123\" se deber\u00eda convertir al n\u00famero 123, pero la cadena \"Hola, mundo\" no tiene un valor num\u00e9rico al que convertirse. El siguiente ejemplo muestra la forma correcta de usar el inicializador: 1 2 3 4 5 6 var posibleNumero = 123 let numeroConvertido = Int ( posibleNumero ) posibleNumero = Hola mundo let conversionErronea = Int ( posibleNumero ) // numeroConvertido y conversionErronea son de tipo Int? , o Int opcional // El primero contiene un n\u00famero y el segundo nil Debido a que el inicializador puede fallar, devuelve un Int opcional , en lugar de un Int . Un Int opcional se escribe como Int? . Para definir una variable como sin valor debemos asignarle el valor especial nil : 1 2 3 4 var codigoRespuestaServidor : Int ? = 404 // codigoRespuestaServidor contine un valor Int de 404 codigoRespuestaServidor = nil // codigoRespuestaServidor ahora no contiene ning\u00fan valor Una variable opcional sin asignar ning\u00fan valor se inicializa autom\u00e1ticamente a nil : 1 2 var respuestaEncuesta : String ? // respuestaEncuesta es inicializado autom\u00e1ticamente a nil","title":"Opcionales"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#sentencias-if-y-desenvoltura-forzosa","text":"Se puede usar un if para comprobar si un valor opcional es distinto de nil : 1 2 3 4 if numeroConvertido != nil { print ( numeroConvertido contiene alg\u00fan valor entero. ) } // Imprime numeroConvertido contiene alg\u00fan valor entero. Si estamos seguros de que el opcional contiene un valor, podemos acceder a \u00e9l usando un signo de exclamaci\u00f3n ( ! ). Quiere decir \"S\u00e9 que hay este opcional tiene un valor concreto; por favor \u00fasalo\". Esto se conoce como desenvoltura forzosa ( forced unwrapping ) del valor opcional: 1 2 3 4 5 if numeroConvertido != nil { let numero = numeroConvertido ! print ( numeroConvertido tiene un valor entero de \\( numero ) . ) } // Imprime numeroConvertido tiene un valor entero de 123. Si se desenvuelve un opcional que contiene un nil se causa un error en tiempo de ejecuci\u00f3n: 1 2 3 let x = Int ( Hola ) let y = x ! + 100 // La sentencia anterior provoca un error en tiempo de ejecuci\u00f3n","title":"Sentencias if y desenvoltura forzosa"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#ligado-opcional","text":"Es posible comprobar si un opcional tiene valor y asignar su valor a otra variable al mismo tiempo con una construcci\u00f3n llamada ligado opcional ( optional binding ): 1 2 3 4 5 6 if let numeroVerdadero = Int ( posibleNumero ) { print ( \\ \\( posibleNumero ) \\ tiene un valor entero de \\( numeroVerdadero ) ) } else { print ( \\ \\( posibleNumero ) \\ no ha podido convertirse en un entero ) } // Imprime 123 tiene un valor entero de 123 Podemos leer el c\u00f3digo anterior de la siguiente forma: \"Si el Int opcional devuelto por Int(posibleNumero) contiene un valor, define la constante numeroVerdadero con el valor contenido en el opcional\". Si tenemos varios opcionales es posible comprobar que todos ellos son distintos de nil usando varios let en el mismo if : 1 2 3 4 5 6 7 8 9 var x1 : Int ? = pedirNumUsuario () var x2 : Int ? = pedirNumUsuario () var x3 : Int ? = pedirNumUsuario () if let dato1 = x1 , let dato2 = x2 , let dato3 = x3 { let suma = dato1 + dato2 + dato3 print ( Ning\u00fan nil y la suma de todos los datos es: \\( suma ) ) } else { print ( Alg\u00fan dato del usuario es nil ) }","title":"Ligado opcional"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#ejemplos-de-uso-de-opcionales","text":"Como ejemplo de uso de opcionales adaptamos el ejemplo anterior de la funci\u00f3n minMax para que pueda recibir un array vac\u00edo, en cuyo caso devolver\u00e1 nil . 1 2 3 4 5 6 7 8 9 10 11 12 13 func minMax ( array : [ Int ]) - ( min : Int , max : Int )? { if array . isEmpty { return nil } var minActual = array [ 0 ] var maxActual = array [ 0 ] for valor in array [ 1. . array . count ] { if valor minActual { minActual = valor } else if valor maxActual { maxActual = valor } } return ( minActual , maxActual ) } Una vez obtenidos, la variable limites devuelta es tambi\u00e9n un opcional, y para obtener los valores deberemos desenvolver el resultado: 1 2 3 let limites = minMax ( array :[ 10 , 20 , - 1 ]) print ( min es \\( limites !. min ) y max es \\( limites !. max ) ) // Imprime min es -6 y max es 109 En el caso anterior sabemos que limites va a devolver un valor (porque llamamos a minMax con un array con elementos), por lo que podemos desenvolverlo sin temor de provocar un error. Sin embargo, en el ejemplo siguiente no es recomendable hacer una desenvoltura forzosa, porque no sabemos si minMax va a devolver nil o no: 1 2 3 4 5 6 7 8 let valores = pedirNums () // La funci\u00f3n pedirNums() pide una lista de // n\u00fameros por la entrada est\u00e1ndar y // devuelve un [Int] (que puede estar vac\u00edo) if let limites = minMax ( valores ) { print ( min es \\( limites . min ) y max es \\( limites . max ) ) } else { print ( No hay n\u00fameros ) } Otro ejemplo, una segunda versi\u00f3n del enum Lista , en el que utilizamos un \u00fanico case , pero dando la posibilidad de que el cdr de la lista sea nil haci\u00e9ndolo opcional: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 indirect enum Lista { case cons ( Int , Lista ?) } func suma ( lista : Lista ) - Int { switch lista { case let . cons ( car , cdr ): if ( cdr == nil ) { return car } else { return car + suma ( lista : cdr !) } } } let z : Lista = . cons ( 20 , . cons ( 10 , nil )) print ( suma ( lista : z )) /// Devuelve 30","title":"Ejemplos de uso de opcionales"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#inmutabilidad","text":"Una de las caracter\u00edsticas funcionales importantes de Swift es el \u00e9nfasis en la inmutabilidad para reforzar la seguridad del lenguaje. Veamos algunas caracter\u00edsticas relacionadas con esto.","title":"Inmutabilidad"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#palabra-clave-let","text":"La palabra clave let permite definir constantes. El valor asignado puede no conocerse en tiempo de compilaci\u00f3n: 1 2 let maximoNumeroDeIntentosDeLogin = 10 let respuesta : String = respuestaUsuario . respuesta ()","title":"Palabra clave let"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#semantica-de-copia-en-estructuras","text":"Una forma de evitar los efectos laterales es definir una sem\u00e1ntica de copia en la asignaci\u00f3n. En Swift la sem\u00e1ntica de una asignaci\u00f3n depende del tipo de objeto. Las estructuras ( structs ) tienen sem\u00e1ntica de copia . Veremos m\u00e1s adelante que las clases tienen una sem\u00e1ntica de referencia . El la biblioteca est\u00e1ndar de Swift la mayor parte de los tipos definidos son estructuras. Los tipos b\u00e1sicos de Swift como Int , Double , Bool , String , etc. son todos ellos estructuras y, por tanto, tienen sem\u00e1ntica de copia. 1 2 3 4 5 var str1 = Hola var str2 = str1 str1 . append ( Adios ) print ( str1 ) // Imprime HolaAdios print ( str2 ) // Imprime Hola Los arrays tambi\u00e9n son estructuras y, por tanto, tambi\u00e9n tienen sem\u00e1ntica de copia: 1 2 3 4 5 var array1 = [ 1 , 2 , 3 , 4 ] var array2 = array1 array1 [ 0 ] = 10 print ( array1 ) // [10, 2, 3, 4] print ( array2 ) // [1, 2, 3, 4] A diferencia de otros lenguajes como Java, los par\u00e1metros de una funci\u00f3n siempre son inmutables y se pasan por copia. Por ejemplo, el siguiente c\u00f3digo ser\u00eda un error: 1 2 3 4 func concat(_ str1: String, con str2: String) - String { // str1.append(str2) - error return str1 } A pesar de tener una sem\u00e1ntica de copia, la asignaci\u00f3n de un array de una variable a otra o el paso de un array como par\u00e1metro de una funci\u00f3n no realiza una copia de todo el array. El compilador de Swift optimiza estas sentencias y s\u00f3lo realiza la copia en el momento en que hay una modificaci\u00f3n de una de las variables que comparten el array.","title":"Sem\u00e1ntica de copia en estructuras"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#estructuras-mutables-y-let","text":"Si definimos un valor de una estructura con un let ese valor ser\u00e1 inmutable y no podr\u00e1 modificarse, a pesar de que el Struct tenga m\u00e9todos que mutan sus valores. Por ejemplo, hemos visto que el m\u00e9todo append(_:) de un String modifica la propia cadena. Si definimos una cadena con let no podremos modificarla: 1 2 3 4 5 6 var cadenaMutable = Hola let cadenaInmutable = Adios cadenaMutable . append ( cadenaInmutable ) // cadenaMutable es HolaAdios // cadenaInmutable.append( Adios ) // La sentencia anterior genera un error: // cannot use mutating member on immutable value: cadenaInmutable is a let constant","title":"Estructuras mutables y let"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#tipos-valor-y-tipos-referencia","text":"Un tipo valor es un tipo que tiene sem\u00e1ntica de copia en las asignaciones y cuando se pasan como par\u00e1metro en llamadas a funciones. Los tipos valor son muy \u00fatiles porque evitan los efectos laterales en los programas y simplifican el comportamiento del compilador en la gesti\u00f3n de memoria. Al no existir referencias, se simplifica enormemente la gesti\u00f3n de memoria de estas estructuras. No es necesario llevar la cuenta de qu\u00e9 referencias apuntan a un determinado valor, sino que se puede liberar la memoria en cuanto se elimina el \u00e1mbito actual. Frente a un tipo valor, un tipo de referencia es aquel en los que los valores se asignan a variables con una sem\u00e1ntica de referencia. Cuando se realizan varias asignaciones de una misma instancia a distintas variables todas ellas guardan una referencia a la misma instancia. Si la instancia se modifica, todas las variables reflejar\u00e1n el nuevo valor. Veremos que en Swift todas las instancias de clases tienen esta sem\u00e1ntica. En Swift las estructuras son tipos valor y las clases tipos de referencia. Comentaremos m\u00e1s diferencias en el tema de programaci\u00f3n orientada a objetos.","title":"Tipos valor y tipos referencia"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#clausuras","text":"Ya hemos visto previamente que en Swift las funciones son objetos de primera clase del lenguaje y que es posible definir funciones y pasarlas como par\u00e1metro de otras funciones. Tambi\u00e9n es posible construir clausuras, funciones definidas en el \u00e1mbito de otras funcionas y devueltas como resultados. Veremos primero c\u00f3mo definir de forma compacta funciones que se pasan como par\u00e1metro de otras, utilizando expresiones de clausuras . Y despu\u00e9s veremos c\u00f3mo las clausuras definidas en el interior de otras funciones capturan las variables definidas en el \u00e1mbito de la funci\u00f3n principal.","title":"Clausuras"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#expresiones-de-clausuras","text":"Swift permite definir expresiones compactas con las que construir estas funciones que se pasan como par\u00e1metro de otras funciones. Se denominan expresiones de clausuras ( closure expressions ). Estas expresiones proporcionan optimizaciones de sintaxis para escribir clausuras de forma concisa y clara. Vamos a ver las distintas optimizaciones utilizando como ejemplo el m\u00e9todo sorted(by:) .","title":"Expresiones de clausuras"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#el-metodo-sortedby","text":"La biblioteca st\u00e1ndar de Swift define un m\u00e9todo sorted() que devuelve los elementos ordenados de un Array . El array original no se modifica. La comparaci\u00f3n entre los elementos se realiza usando el comparador . 1 2 3 4 let estudiantes = [ Kofi , Abena , Peter , Kweku , Akosua ] let ordenados = estudiantes.sorted() print(ordenados) // Prints [ Abena , Akosua , Kofi , Kweku , Peter ] Esta funci\u00f3n es similar a las que hay en muchos lenguajes. El \u00fanico aspecto funcional es que el array original no se modifica, sino que la ordenaci\u00f3n construye un nuevo array (existe una funci\u00f3n alternativa mutable que se denomina sort() ). Lo interesante relacionado con las clausuras est\u00e1 en la funci\u00f3n sorted(by:) . En esta funci\u00f3n se utiliza una clausura como par\u00e1metro para modificar la comparaci\u00f3n entre elementos y resultar en una ordenaci\u00f3n distinta. Es una de las distintas funciones de orden superior que se definen en las colecciones (m\u00e1s adelante veremos otras). El perfil de la funci\u00f3n sorted(by:) es: 1 func sorted(by areInIncreasingOrder: (Element, Element) - Bool) El par\u00e1metro es una funci\u00f3n de dos par\u00e1metros (del tipo de los elementos del array) que devuelve un booleano indicando si el primer par\u00e1metro va antes que el segundo en el array ordenado. La clausura de ordenaci\u00f3n devuelve true si el primer valor deber\u00eda aparecer antes del segundo valor y false en otro caso. Por ejemplo, podr\u00edamos ordenar un array de cadenas en orden alfab\u00e9tico inverso. 1 2 3 4 5 6 7 func primeroMayor ( s1 : String , s2 : String ) - Bool { return s1 s2 } let estudiantes = [ Kofi , Abena , Peter , Kweku , Akosua ] let alreves = estudiantes . sorted ( by : primeroMayor ) print ( alreves ) // Imprime [ Peter , Kweku , Kofi , Akosua , Abena ] Si la primera cadena ( s1 ) es mayor que la segunda cadena ( s2 ), la funci\u00f3n primeroMayor(s1:s2:) devolver\u00e1 true , indicando que s1 deber\u00eda aparecer antes que s2 en el array ordenado. La ordenaci\u00f3n mayor o menor se refiere a la ordenaci\u00f3n alfab\u00e9tica, al estar tratando con caracteres. La versi\u00f3n anterior esta es una forma bastante complicada de escribir lo que b\u00e1sicamente es una funci\u00f3n de una \u00fanica expresi\u00f3n ( a b ). En este ejemplo, ser\u00eda preferible escribir la clausura de ordenaci\u00f3n inline , utilizando la sintaxis de expresiones de clausuras.","title":"El m\u00e9todo sorted(by:)"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#sintaxis-de-las-expresiones-de-clausura","text":"La sintaxis de las expresiones de clausura tiene la siguiente forma general: 1 2 3 { ( parametros ) - tipo devuelto in sentencias } Si aplicamos esta sintaxis al ejemplo anterior: 1 2 3 let alreves = estudiantes . sorted ( by : { ( s1 : String , s2 : String ) - Bool in return s1 s2 }) Hay que hacer notar que la declaraci\u00f3n de los par\u00e1metros y el tipo devuelto por esta clausura inline es id\u00e9ntica a la declaraci\u00f3n de la funci\u00f3n primeroMayor(s1:s2:) . En ambos casos, se escribe como (s1: String, s2: String) - Bool . Sin embargo, en la expresi\u00f3n de clausura los par\u00e1metros y el tipo devuelto se escribe dentro de las llaves, no fuera. El comienzo del cuerpo de la clausura se introduce por la palabra clave in . Esta palabra clave indica que la definici\u00f3n de los par\u00e1metros y del tipo devuelto por la clausura ha terminado, y que el cuerpo de la clausura va a comenzar. Como el cuerpo de la clausura es corto, podemos incluso escribirlo en una \u00fanica l\u00ednea: 1 let alreves = estudiantes . sorted ( by : { ( s1 : String , s2 : String ) - Bool in return s1 s2 } )","title":"Sintaxis de las expresiones de clausura"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#inferencia-del-tipo-por-el-contexto","text":"Como la clausura de ordenaci\u00f3n se pasa como argumento de un m\u00e9todo, Swift puede inferir los tipos de sus par\u00e1metros y el tipo del valor que devuelve. El m\u00e9todo sorted(by:) se llama sobre un array de cadenas, por lo que su argumento debe ser una funci\u00f3n del tipo (String, String) - Bool . Esto significa que los tipos (String, String) y Bool no necesitan escribirse como parte de la definici\u00f3n de la expresi\u00f3n de la clausura. Debido a que todos los tipos pueden ser inferidos, la flecha del tipo devuelto y los par\u00e9ntesis alrededor de los nombres de los par\u00e1metros tambi\u00e9n pueden omitirse: 1 let alreves = estudiantes . sorted ( by : { s1 , s2 in return s1 s2 } )","title":"Inferencia del tipo por el contexto"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#devoluciones-implicitas-en-clausuras-con-una-unica-expresion","text":"En clausuras con una \u00fanica expresi\u00f3n podemos omitir tambi\u00e9n la palabra clave return : 1 let alreves = estudiantes . sorted ( by : { s1 , s2 in s1 s2 } )","title":"Devoluciones impl\u00edcitas en clausuras con una \u00fanica expresi\u00f3n"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#abreviaturas-en-los-nombres-de-los-argumentos","text":"Swift proporciona autom\u00e1ticamente abreviaturas para los nombres de argumentos de las clausuras inline que pueden usarse para referirse a los valores de los argumentos de la clausura usando los nombres $0 , $1 , $2 , etc. Si se usa estos argumentos abreviados, se puede omitir la definici\u00f3n de la lista de los argumentos: 1 let alreves = estudiantes . sorted ( by : { $0 $1 } )","title":"Abreviaturas en los nombres de los argumentos"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#funciones-operadoras","text":"Incluso hay una forma aun m\u00e1s corta de escribir la expresi\u00f3n de clausura anterior. Swift define una implementaci\u00f3n espec\u00edfica de cadenas del operador mayor-que ( ) como una funci\u00f3n que tiene dos par\u00e1metros de tipo String y devuelve un Bool . Esto es exactamente lo que necesita el m\u00e9todo sorted(by:) . Podemos, por tanto, pasar simplemente este operador mayor-que, y Swift inferir\u00e1 que queremos usar el espec\u00edfico de cadenas: 1 let alreves = estudiantes . sorted ( by : )","title":"Funciones operadoras"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#clausuras-al-final","text":"Si necesitamos pasar una expresi\u00f3n de clausura a una funci\u00f3n como el argumento final de la clausura y la expresi\u00f3n es larga, puede ser \u00fatil escribirla en su lugar como una clausura al final ( trailing closure ). Una clausura al final es una expresi\u00f3n de clausura que se escribe fuera de (y despu\u00e9s de) los par\u00e9ntesis de la funci\u00f3n a la que se le pasa como par\u00e1metro: 1 let alreves = estudiantes . sorted () { $0 $1 } Cuando se proporciona una expresi\u00f3n de clausura como \u00fanico argumento de una funci\u00f3n o m\u00e9todo y se pasa como una clausura al final, no es necesario escribir los par\u00e9ntesis tras el nombre de la funci\u00f3n: 1 let alreves = estudiantes . sorted { $0 $1 } Las clausuras al final son \u00fatiles sobre todo cuando la clausura es suficientemente larga que no es posible escribirla inline en una \u00fanica l\u00ednea. Como ejemplo, el tipo Array de Swift tiene el m\u00e9todo map(_:) que toma una expresi\u00f3n de clausura como \u00fanico argumento (en el siguiente apartado hablaremos de esta y otras funciones de orden superior). La clausura se llama una vez para cada elemento del array y devuelve un valor transformado (posiblemente de otro tipo) para ese elemento. Despu\u00e9s de aplicar la clausura proporcionada a cada elemento del array, el m\u00e9todo map(_:) devuelve una array nuevo que contiene todos los nuevos valores transformados, en el mismo orden que sus valores correspondientes en el array original. Por ejemplo, podemos usar el m\u00e9todo map(_:) con una clausura al final para convertir un array de valores Int en un array de valores String . El array [16, 58, 510] se usa para crear el array 1 2 3 4 5 let digitos = [ 0 : Cero , 1 : Uno , 2 : Dos , 3 : Tres , 4 : Cuatro , 5 : Cinco , 6 : Seis , 7 : Siete , 8 : Ocho , 9 : Nueve ] let numeros = [ 16 , 58 , 510 ] El c\u00f3digo de arriba crea un diccionario que relaciona los d\u00edgitos enteros con sus nombres en castellano y un array de enteros que se convertir\u00e1n en cadenas. Ahora podemos usar el array de nombres para crear un array de valores String , pasando una expresi\u00f3n de clausura al m\u00e9todo map(_:) del array como una clausura al final: 1 2 3 4 5 6 7 8 9 10 11 12 13 let cadenas = numeros . map { ( numero ) - String in var numero = numero var salida = while numero 0 { salida = digitos [ numero % 10 ] ! + salida numero /= 10 } return salida } print ( cadenas ) // las cadenas se infieren de tipo [String] // imprime [ UnoSeis , CincoOcho , CincoUnoCero ] El m\u00e9todo map(_:) llama a la expresi\u00f3n de clausura una vez por cada elemento del array. La variable numero se incializa con el valor numero del par\u00e1metro de la clausura para poder modificarlo dentro del cuerpo de la clausura (los par\u00e1metros de las funciones y las clausuras son siempre constanes). El bucle while usa el diccionario de d\u00edgitos para construir la cadena correspondiente al valor Int .","title":"Clausuras al final"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#valores-capturados","text":"Una clausura puede capturar constantes y variables del contexto en el que se define. La clausura puede referirse y modificar esos valores dentro de su cuerpo, incluso si ya no existe el \u00e1mbito ( scope ) original en el que se definieron estas constantes y variables. En Swift, la forma m\u00e1s sencilla de una clausura que captura valores es una funci\u00f3n anidada ( nested function ) escrita en el cuerpo de otra funci\u00f3n. Una funci\u00f3n anidada puede capturar cualquiera de los argumentos de su funci\u00f3n exterior y tambi\u00e9n puede capturar cualquier constante y variable definida dentro de la funci\u00f3n exterior. Veamos un ejemplo similar al que vimos en Scheme. La funci\u00f3n construyeIncrementador contiene una funci\u00f3n anidada llamada incrementador . Esta funci\u00f3n captura dos valores de su contexto: totalAcumulado y cantidad . Despu\u00e9s de capturar estos valores, incrementador es devuelto por construyeIncrementador como una clausura que incrementa totalAcumulado en cantidad cada vez que se llama. 1 2 3 4 5 6 7 8 func construyeIncrementador ( incremento cantidad : Int ) - () - Int { var totalAcumulado = 0 func incrementador () - Int { totalAcumulado += cantidad return totalAcumulado } return incrementador } El tipo devuelto de construyeIncrementador es () - Int . Esto significa que devuelve una funci\u00f3n que no tiene par\u00e1metros y que devuelve un Int cada vez que es llamada. La funci\u00f3n construyeIncrementador(incremento:) tiene un \u00fanico par\u00e1metro Int con nombre externo incremento y nombre local cantidad . El argumento pasado a este par\u00e1metro especifica cu\u00e1nto ser\u00e1 incrementado totalAcumulado cada vez que se llama a la funci\u00f3n incrementador devuelta. La funci\u00f3n construyeIncrementador define una funci\u00f3n anidada llamada incrementador , que realiza el incremento real. Esta funci\u00f3n simplemente a\u00f1ade cantidad a totalAcumulado , y devuelve el resultado. Si la consideramos aislada, la funci\u00f3n anidada incrementador() podr\u00eda parecer extra\u00f1a: 1 2 3 4 func incrementador () - Int { totalAcumulado += cantidad return totalAcumulado } La funci\u00f3n no tiene ning\u00fan par\u00e1metro, y sin embargo se refiere a totalAcumulado y a cantidad en su cuerpo. Lo puede hacer porque ha capturado una referencia a estas variables de la funci\u00f3n de alrededor y las usa en su propio cuerpo. Al capturar estas referencias las variables totalAcumulado y cantidad no desaparecen cuando termina la llamada a construyeIncrementador . Estas variables tambi\u00e9n estar\u00e1n disponibles la pr\u00f3xima vez que se llame la funci\u00f3n incrementador . Aqu\u00ed hay un ejemplo de construyeIncrementador en acci\u00f3n: 1 let incrementaDiez = construyeIncrementador ( incremento : 10 ) Este ejemplo define una constante llamada incrementaDiez para referenciar la funci\u00f3n incrementador que devuelve construyeIncrementador . Esta funci\u00f3n a\u00f1ade 10 a la variable totalAcumulado cada vez que se es llamada. Si llamamos a la funci\u00f3n m\u00e1s de una vez podemos comprobar su conducta en acci\u00f3n: 1 2 3 4 5 6 incrementaDiez () // devuelve 10 incrementaDiez () // devuelve 20 incrementaDiez () // devuelve 30 Si creamos un segundo incrementador, tendr\u00e1 sus propias referencias a un variable totalAcumulado nueva, distinta de la anterior: 1 2 3 let incrementaSiete = construyeIncrementador ( incremento : 7 ) incrementaSiete () // devuelve 7 Si llamamos a la funci\u00f3n incrementador original ( incrementaDiez ) vemos que sigue incrementando su propia variable totalAcumulado y que no se ve afectada por la variable capturada por incrementaSiete : 1 2 incrementaDiez () // devuelve 40","title":"Valores capturados"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#mutacion-de-variables-capturadas","text":"Las clausuras tambi\u00e9n pueden modificar el valor de las variables capturadas. Veamos un ejemplo: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 var x = 1 func construyeFunc () - ( Int ) - Int { var x = 10 func prueba ( _ a : Int ) - Int { x = a + x return x } return prueba } let f = construyeFunc () print ( f ( 10 )) // Imprime 20 print ( f ( 10 )) // Imprime 30 let g = construyeFunc () print ( g ( 10 )) // Imprime 20 print ( x ) // Imprime 1 La clausura prueba captura la variable x definida en el \u00e1mbito de construyeFunc y la utiliza en su cuerpo. La variable capturada queda ligada a la clausura y es utilizada cada vez que la clausura se invoca. En la primera invocaci\u00f3n a la clausura se pasa como par\u00e1metro a el valor 10, que se suma a la variable capturada. De esta forma la variable capturada pasa a valer 20. En la segunda invocaci\u00f3n a la clausura el valor de x ser\u00e1 20, por lo que devolver\u00e1 30. La segunda vez que llamamos a construyeFunc se crea un nuevo \u00e1mbito local con una nueva variable x que se inicializa a 10. Esa nueva variable es el que captura la nueva clausura que se devuelve. Por eso al invocarla (en la llamada g(10) ) se devuelve 20.","title":"Mutaci\u00f3n de variables capturadas"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#las-clausuras-son-tipos-de-referencia","text":"En el ejemplo anterior, incrementaSiete e incrementaDiez son constantes, pero las clausuras a las que estas constantes se refieren pueden incrementar la variable totalAcumulado que han capturado. Esto es porque funciones y clausuras son tipos referencia. Siempre que asignamos una funci\u00f3n o una clausura a una constante o una variable, estamos realmente estableciendo que la constante o variable es una referencia a la funci\u00f3n o la clausura. En el ejemplo anterior, es la elecci\u00f3n de la clausura a la que referencia incrementaDiez la que es constante, no los contenidos propios de la clausura. Esto tambi\u00e9n significa que si asignamos una clausura a dos constantes o variables distintas, ambas constantes o variables se referir\u00e1n a la misma clausura: 1 2 3 let tambienIncrementaDiez = incrementaDiez tambienIncrementaDiez () // devuelve 50","title":"Las clausuras son tipos de referencia"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#funciones-de-orden-superior","text":"Una de las caracter\u00edsticas funcionales que m\u00e1s hemos usado para trabajar con listas en Scheme son las funciones de orden superior como map , filter o fold-right . Swift tiene definidas funciones equivalentes para trabajar con colecciones. Se denominan map , filter y reduce . Todas ellas aceptan expresiones de clausura como argumento.","title":"Funciones de orden superior"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#map","text":"El m\u00e9todo map se define en el protocolo CollectionType y es adoptado por m\u00faltiples estructuras como Array , Dictionary , Set o String.CharacterView . El m\u00e9todo map recibe como par\u00e1metro una funci\u00f3n unaria transform del tipo de los elementos de la colecci\u00f3n y que devuelve otro elemento (puede ser del mismo o de distinto tipo que los elementos de la colecci\u00f3n). Devuelve un array que contiene el resultado de aplicar transform a cada elemento del array original. Por ejemplo: 1 2 3 let numeros = [ Int ]( 0. .. 5 ) numeros . map { $0 * $0 } // devuelve [0, 1, 4, 9, 16, 25] Otro ejemplo, en el que usamos map para implementar la funci\u00f3n sumaParejas(parejas: [(Int, Int)]) - [Int] que devuelve recibe el array parejas de tuplas de dos enteros y devuelve un array con el resultado de sumar los dos elementos de cada pareja: 1 2 3 4 5 6 func suma ( parejas : [( Int , Int )]) - [ Int ] { return parejas . map ({( pareja : ( Int , Int )) - Int in return pareja . 0 + pareja . 1 }) } suma ( parejas :[( 1 , 1 ), ( 2 , 2 ), ( 3 , 3 ), ( 4 , 4 )]) // devuelve [2, 4, 6, 8] Podemos usar en el cuerpo de la expresi\u00f3n de clausura de map una variable capturada. Por ejemplo en la siguiente funci\u00f3n incrementaValores(_:con:) que suma con a todos los n\u00fameros de un array que se le pasa por par\u00e1metro: 1 2 3 4 5 6 func incrementa ( valores : [ Int ], con : Int ) - [ Int ] { return valores . map ({( x : Int ) - Int in return x + con }) } incrementa ( valores :[ 10 , 20 , 30 ], con : 5 ) // devuelve [15, 25, 35] La versi\u00f3n abreviada de la expresi\u00f3n de clausura es: 1 2 3 4 5 func incrementa ( valores : [ Int ], con inc : Int ) - [ Int ] { return valores . map { $0 + inc } } incrementa ( valores : [ 10 , 20 , 30 ], con : 5 ) // devuelve [15, 25, 35]","title":"Map"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#filter","text":"La funci\u00f3n filter recibe una clausura de un argumento que devuelve un booleano. La funci\u00f3n devuelve una colecci\u00f3n con los elementos de la colecci\u00f3n para los que la clausura devuelve true . Ejemplo: 1 2 3 let numeros = [ Int ]( 0. .. 10 ) numeros . filter { $0 % 2 == 0 } // devuelve [0, 2, 4, 6, 8, 10]","title":"Filter"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#reduce","text":"Similar al fold de Scheme: 1 2 let numeros = [ Int ]( 0. .. 10 ) numeros . reduce ( 0 , + ) La funci\u00f3n combina los elementos de la colecci\u00f3n usando la funci\u00f3n de combinaci\u00f3n que se pasa como par\u00e1metro. La funci\u00f3n que se pasa como par\u00e1metro recibe dos par\u00e1metros: el primero es el resultado de la combinaci\u00f3n y el segundo se coge de la colecci\u00f3n. Por ejemplo: 1 2 3 4 let cadenas = [ Patatas , Arroz , Huevos ] cadenas . reduce ( 0 , {( i : Int , c : String ) - Int in c . count + i }) // devuelve 18 Es posible simplificar la notaci\u00f3n anterior: 1 cadenas . reduce ( 0 , { $1 . count + $0 }) Tambi\u00e9n se puede utilizar la notaci\u00f3n de clausura al final: 1 cadenas . reduce ( 0 ) { $1 . count + $0 } La combinaci\u00f3n se hace de izquierda a derecha: 1 2 3 let cadenas = [ Patatas , Arroz , Huevos ] cadenas . reduce ( , + ) // devuelve PatatasArrozHuevos","title":"Reduce"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#combinacion-de-funciones-de-orden-superior","text":"Cuando el resultado de aplicar una funci\u00f3n de orden superior a una colecci\u00f3n es otra colecci\u00f3n es posible aplicar otra funci\u00f3n de orden superior a este resultado. Por ejemplo, la siguiente sentencia devuelve todos los n\u00fameros pares del array inicial elevados al cuadrado: 1 2 3 let numeros = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] numeros . filter { $0 % 2 == 0 }. map { $0 * $0 } // Devuelve el array [4,16,36,64,100] Y la siguiente devuelve la suma n\u00fameros mayores de 100: 1 2 3 let numeros = [ 103 , 2 , 330 , 42 , 532 , 6 , 125 ] numeros . filter { $0 = 100 }. reduce ( 0 , + ) // Devuelve 1090","title":"Combinaci\u00f3n de funciones de orden superior"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#genericos","text":"Empecemos con un ejemplo sencillo. Supongamos la siguiente funci\u00f3n intercambia(_:) que recibe una tupla (Int, String) y devuelve una tupla (String, Int) con los valores intercambiados. 1 2 3 4 5 6 7 8 func intercambia ( _ tupla : ( Int , String )) - ( String , Int ) { let tuplaNueva = ( tupla . 1 , tupla . 0 ) return tuplaNueva } let tupla = ( 10 , Hola ) intercambia ( tupla ) // devuelve ( Hola , 10) La funci\u00f3n es interesante, pero s\u00f3lo recibe tuplas cuya primera componente es un Int y su segunda componente es un String . Supongamos que queremos hacer la misma funci\u00f3n para intercambiar elementos de una tupla (Int, Int) . Tendr\u00edamos que usar el mismo c\u00f3digo, pero cambiando los tipos: 1 2 3 4 5 6 7 8 func intercambia ( _ tupla : ( Int , Int )) - ( Int , Int ) { let tuplaNueva = ( tupla . 1 , tupla . 0 ) return tuplaNueva } let tupla = ( 10 , 20 ) intercambia ( tupla ) // devuelve (20, 10) El c\u00f3digo es el mismo, lo \u00fanico distinto son los tipos. \u00bfPodr\u00edamos generalizar las funciones anteriores para hacer que el c\u00f3digo pueda trabajar con cualquier tipo? La respuesta es s\u00ed, usando funci\u00f3n gen\u00e9rica : 1 2 3 4 func intercambia A , B ( _ tupla : ( A , B )) - ( B , A ) { let tuplaNueva = ( tupla . 1 , tupla . 0 ) return tuplaNueva } El cuerpo de la funci\u00f3n es id\u00e9ntico a la funci\u00f3n anterior. La diferencia es que en la versi\u00f3n gen\u00e9rica se usan placeholders (los s\u00edmbolos A y B ) en lugar de tipos concretos. Son tipos gen\u00e9ricos, que se definen usando un identificador entre s\u00edmbolos de y . Los tipos reales que se van a usar en la funci\u00f3n se determinan en cada invocaci\u00f3n a la funci\u00f3n, dependiendo del tipo del par\u00e1metro que se utiliza en la llamada: 1 2 3 4 5 6 7 8 9 let tupla = ( 10 , Hola ) intercambia ( tupla ) // devuelve ( Hola , 10) let tupla2 = ( 10 , 20 ) intercambia ( tupla2 ) // devuelve (10, 20) let tupla3 = ( true , 10.5 ) intercambia ( tupla3 ) // devuelve (10.5, true) En el primer ejemplo, los tipos A y B se infieren como Int y String . En el segundo ejemplo como Int e Int . Y en el tercero como Bool y Double . Los tipos gen\u00e9ricos se pueden usar en la definici\u00f3n de todos los elementos de Swift: funciones, enums, estructuras, clases, protocolos o extensiones. Terminamos con un ejemplo en el que incluimos muchos conceptos vistos en este tema. Se trata de la implementaci\u00f3n en Swift de listas al estilo Scheme, con las funciones car , cdr y vacia usando un enum recursivo con un tipo gen\u00e9rico que permite generalizar el tipo de elementos de la lista. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 indirect enum Lista T { case vacia case cons ( T , Lista T ) } func car T ( _ lista : Lista T ) - T ? { switch lista { case let . cons ( primero , _ ): return primero case . vacia : return nil } } func cdr T ( _ lista : Lista T ) - Lista T ? { switch lista { case let . cons ( _ , resto ): return resto case . vacia : return nil } } func vacia T ( _ lista : Lista T ) - Bool { switch lista { case . vacia : return true default : return false } } let lista : Lista = . cons ( 20 , . cons ( 30 , . cons ( 40 , . vacia ))) print ( car ( lista ) ! ) // Imprime 20 print ( car ( cdr ( lista ) ! ) ! ) // Imprime 30 print ( car ( cdr ( cdr ( lista ) ! ) ! ) ! ) // Imprime 40 print ( vacia ( cdr ( cdr ( cdr ( lista ) ! ) ! ) ! )) // Imprime true","title":"Gen\u00e9ricos"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#bibliografia","text":"Swift Language Guide The Basics Collection Types Functions","title":"Bibliograf\u00eda"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#closures","text":"Enumerations Generics Biblioteca est\u00e1ndar de Swift Lenguajes y Paradigmas de Programaci\u00f3n, curso 2018\u201319 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Domingo Gallardo, Cristina Pomares, Antonio Bot\u00eda, Francisco Mart\u00ednez","title":"Closures"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html","text":"Tema 6: Programaci\u00f3n Orientada a Objetos con Swift Introducci\u00f3n, historia y caracter\u00edsticas de la Programaci\u00f3n Orientada a Objetos Nacimiento La Programaci\u00f3n Orientada a Objetos es un paradigma de programaci\u00f3n que explota en los 80 pero nace a partir de ideas a finales de los 60 y 70 Primer lenguaje con las ideas fundamentales de POO: Simula Smalltalk (1980) como lenguaje paradigm\u00e1tica de POO Alan Kay es el creador del t\u00e9rmino \u201cObject-Oriented\u201d y una de las figuras fundamentales de la historia de la inform\u00e1tica moderna. Trabaj\u00f3 en Xerox Park y desarroll\u00f3 all\u00ed ideas que han sido clave para la inform\u00e1tica personal (como el Dynabook, precursor de tablets y dispositivos m\u00f3viles y el lenguajes de programaci\u00f3n Smalltalk) Art\u00edculo de Alan Kay: \u201cThe Early History of Smalltalk\u201d , ACM SIGPLAN, March 1993 Alan Kay \u201cI invented the term Object-Oriented and I can tell you I did not have C++ in mind.\u201d \u201cSmalltalk is not only NOT its syntax or the class library, it is not even about classes. I'm sorry that I long ago coined the term objects for this topic because it gets many people to focus on the lesser idea. The big idea is messaging.\u201d \u201cSmalltalk's design\u2013and existence\u2013is due to the insight that everything we can describe can be represented by the recursive composition of a single kind of behavioral building block that hides its combination of state and process inside itself and can be dealt with only through the exchange of messages.\u201d \u00bfInteresados en Smalltalk? Visitar: http://www.squeak.org/ http://swiki.agro.uba.ar/small_land http://www.squeakland.org Lenguajes OO Smalltalk, Java, Scala, Ruby, Python, C#, C++, Swift, ... Del paradigma imperativo al OO Programaci\u00f3n procedural: estado abstracto (tipos de datos y barrera de abstracci\u00f3n) + funciones Siguiente paso: agrupar estado y funciones en una \u00fanica entidad Los objetos son estas entidades Caracter\u00edsticas de la POO Objetos (creados/instanciados en tiempo de ejecuci\u00f3n) y clases (plantillas est\u00e1ticas/tiempo de compilaci\u00f3n) Los objetos agrupan estado y conducta (m\u00e9todos) Los m\u00e9todos se invocan mediante mensajes Dispatch din\u00e1mico : cuando una operaci\u00f3n es invocada sobre un objeto, el propio objeto determina qu\u00e9 c\u00f3digo se ejecuta. Dos objetos con la misma interfaz pueden tener implementaciones distintas. Herencia: las clases se pueden definir utilizando otras clases como plantillas y modificando sus m\u00e9todos y/o variables de instancia. Clases y objetos Objeto: Un objeto contiene un estado (propiedades, atributos o variables de instancia) y un conjunto de funciones (m\u00e9todos) que se ejecutan en el \u00e1mbito del objeto e implementan las funcionalidades soportadas Al ejecutar un m\u00e9todo, el objeto modifica su estado Pedimos a un objeto que ejecute un m\u00e9todo Clase: Una clase es la plantilla que sirve para definir los objetos En una clase se define los elementos que componen el objeto (sus atributos o campos) y sus m\u00e9todos En algunos lenguajes se pueden definir tambi\u00e9n en las clases variables (variables de clase) compartidas por todos los objetos de esa clase Lenguajes POO din\u00e1micos vs. est\u00e1ticos Dos tendencias: Lenguajes din\u00e1micos : muchas caracter\u00edsticas del programa se obtienen en tiempo de ejecuci\u00f3n Mayor flexibilidad y generalidad del c\u00f3digo Dispatch din\u00e1mico Reflexi\u00f3n (posibilidad de consultar caracter\u00edsticas de la instancia (nombres de m\u00e9todos, propiedades, etc.) en tiempo de ejecuci\u00f3n) Ejemplos: Smalltalk, Ruby, Python, JavaScript, Java (en menor medida) Lenguajes est\u00e1ticos : la mayor\u00eda de caracter\u00edsticas del programa se obtienen en tiempo de compilaci\u00f3n Mayor eficiencia Se conoce a priori el tipo de la mayor parte de instancias del programa Fuertemente tipeado Ejemplos: C++, Swift Vamos a detallar a continuaci\u00f3n las caracter\u00edsticas de Programaci\u00f3n Orientada a Objetos de Swift . Para tener una introducci\u00f3n r\u00e1pida puedes empezar leyendo los \u00faltimos apartados del seminario de Swift (los apartados Objetos, clases y estructuras , Protocolos y extensiones y Gen\u00e9ricos ). Clases y estructuras En el caso de Swift, las clases y las estructuras son muchas m\u00e1s cercanas en funcionalidad que en otros lenguajes, como C o C++, y tienen muchas caracter\u00edsticas comunes. Muchas caracter\u00edsticas de las instancias de una clase se pueden aplicar tambi\u00e9n a las instancias de una estructura. Por eso en Swift se suele hablar de instancias (un t\u00e9rmino m\u00e1s general) en lugar de objetos . Las clases y las estructuras en Swift tienen muchas cosas en com\u00fan. Ambos pueden: Definir propiedades y almacenar valores Definir m\u00e9todos para proporcionar funcionalidad Definir sub\u00edndices para proporcionar acceso a sus valores usando una sintaxis de sub\u00edndice Definir inicializadores para configurar el estado inicial Ser extendidas para expandir su funcionalidad m\u00e1s all\u00e1 de una implementaci\u00f3n por defecto Ajustarse a un protocolo Las clases tienen caracter\u00edsticas adicionales que no tienen las estructuras: Mediante la herencia una clase puede heredar las caracter\u00edsticas de otra El casting de tipos permite comprobar e interpretar el tipo de una instancia de una clase en tiempo de ejecuci\u00f3n Los deinicializadores permiten a una instancia de una clase liberar los recursos que ha asignado Mediante el conteo de referencias se permite que exista m\u00e1s de una referencia a una instancia de una clase Definici\u00f3n 1 2 3 4 5 6 class UnaClase { // definici\u00f3n de clase } struct UnaEstructura { // definici\u00f3n de una estructura } 1 2 3 4 5 6 7 8 9 10 11 12 struct CoordsPantalla { var posX = 0 var posY = 0 } class Ventana { var esquina = CoordsPantalla () var altura = 0 var anchura = 0 var visible = true var etiqueta : String ? } El ejemplo define una nueva estructura llamada CoordsPantalla , que describe una coordenada de pantalla con posiciones basadas en p\u00edxeles. La estructura tiene dos propiedades almacenadas llamadas posX y posY . Las propiedades son constantes o variables que se almacenan en la instancia de la clase o de la estructura. El compilador infiere que estas dos propiedades son Int al inicializarlas a los valores iniciales de 0. El ejemplo tambi\u00e9n define una nueva clase llamada Ventana que describe una ventana en una pantalla. Esta clase tiene cinco propiedades variables. La primera, esquina , se inicializa con una instancia nueva de una estructura CoorsPantalla y se infiere que es de tipo CoordsPantalla . Representa la posici\u00f3n superior izquierda de la pantalla. Las propiedades altura y anchura representan el n\u00famero de p\u00edxeles de las dimensiones de la pantalla. Se inicializan a 0. La propiedad visible es un Bool que indica si la ventana es visible en pantalla. Por ejemplo, una ventana que est\u00e9 minimizada no ser\u00e1 visible. Por \u00faltimo, etiqueta representa el nombre que aparece en la parte superior de la ventana. Es un String opcional que se inicializa a nil porque no se le asigna un valor inicial. Instancias de clases y estructuras La definici\u00f3n de las estructuras y las clases \u00fanicamente definen sus aspectos generales. Para describir una configuraci\u00f3n espec\u00edfica (una resoluci\u00f3n o un modo de v\u00eddeo concreto) es necesario crear una instancia de una estructura o una clase. La sintaxis para crear ambas es similar: 1 2 let unasCoordsPantalla = CoordsPantalla () let unaVentana = Ventana () La forma m\u00e1s sencilla de inicializaci\u00f3n es la anterior. Se utiliza el nombre del tipo de la clase o estructura seguidos de par\u00e9ntesis vac\u00edos. Esto crea una nueva instancia de una clase o estructura, con sus propiedades inicializadas a sus valores por defectos. M\u00e1s adelante comentaremos otras formas m\u00e1s elaboradas de inicializaci\u00f3n. Todas las propiedades de una instancia deben estar definidas despu\u00e9s de haberse inicializado, a no ser que la propiedad se un opcional. Acceso a propiedades Se puede acceder y modificar las propiedades usando la sintaxis de punto : 1 2 3 4 5 6 7 print ( La posici\u00f3n x de unasCoordsPantalla es \\( unasCoordsPantalla . posX ) ) // Imprime La posici\u00f3n x de unasCoordsPantalla es 0 print ( La posici\u00f3n y de la esquina de la venana es \\( unaVentana . esquina . posY ) ) // Imprime La posici\u00f3n y de la esquina de la venana es 0 ) unaVentana . esquina . posY = 900 print ( La posici\u00f3n y de la esquina de la venana es ahora \\( unaVentana . esquina . posY ) ) // Imprime La posici\u00f3n y de la esquina de la venana es ahora 900 ) Inicializaci\u00f3n de las estructuras por sus propiedades Podemos inicializar las estructuras el inicializador por defecto , en el que damos valor a todas sus propiedades. En las clases no se puede usar esta inicializaci\u00f3n por defecto. 1 let coords = CoordsPantalla ( posX : 200 , posY : 400 ) Estructuras y enumeraciones son tipos valor Un tipo valor es un tipo cuyo valor se copia cuando se asigna a una variable o constante, o cuando se pasa a una funci\u00f3n. Todos los tipos b\u00e1sicos de Swift -enteros, n\u00fameros en punto flotante, cadenas, arrays y diccionarios- son tipos valor y se implementan como estructuras. Las estructuras y las enumeraciones son tipos valor en Swift. 1 2 3 4 5 6 7 let coords1 = CoordsPantalla ( posX : 600 , posY : 600 ) var coords2 = coords1 coords2 . posX = 1000 print ( coords2 tiene ahora como posici\u00f3n x: \\( coords2 . posX ) ) // imprime: coords2 tiene ahora como posici\u00f3n x: 1000 print ( coords1 tiene todav\u00eda la posici\u00f3n x: \\( coords1 . posX ) ) // imprime: coords1 tiene todav\u00eda la posici\u00f3n x: 600 En el ejemplo se declara una constante llamada coords1 y se asigna a una instancia de CoordsPantalla inicializada con la posici\u00f3n x de 600 y la posici\u00f3n y de 600. Despu\u00e9s se declara una variable llamada coords2 y se asigna al valor actual de coors1 . Debido a que CoordsPantalla es una estructura, se crea una copia de la instancia existente y esta nueva copia se asigna a coords2 . Aunque ahora coords2 y coords1 tienen las mismas posX y posY , son dos instancias completamente distintas. Despu\u00e9s, la propiedad posX de coords2 se actualiza a 1000. Podemos comprobar que la propiedad se modifica, pero que el valor de posX en coords1 sigue siendo el mismo. Las clases son tipos referencia A diferencia de los tipos valor, los tipos de referencias no se copian cuando se asignan o se pasan a funciones. En su lugar se usa una referencia a la misma instancia existente. Veamos un ejemplo: 1 2 3 4 5 6 7 8 9 let ventana1 = Ventana () ventana1 . esquina = coords1 ventana1 . altura = 800 ventana1 . anchura = 800 ventana1 . etiqueta = Finder let ventana2 = ventana1 ventana2 . anchura = 1000 print ( La propiedad anchura de ventana1 es ahora \\( ventana1 . anchura ) ) // imprime La propiedad anchura de ventana1 es ahora 1000 Declaramos una constante llamada ventana1 inicializada con una instancia nueva de la clase Ventana . Le asignamos a la propiedad esquina una copia de la resoluci\u00f3n anterior coords1 . Despu\u00e9s declaramos la altura, anchura y etiqueta de la ventana. Despu\u00e9s, ventana1 se asigna a una nueva constante llamada ventan2 , y la anchura se modifica. Debido a que son tipos de referencia, ventana1 y ventana2 se refieren a la misma instancia de Ventana . Son s\u00f3lo dos nombres distintos para la misma \u00fanica instancia. Hay que hacer notar que ventana1 y ventana2 se declaran con let como constantes. Sin embargo, podemos modificar sus propiedades debido a que no se ha reasignado su instancia a la que se refieren\". Esas variables no \"almacenan\" instancias de Ventana , sino que se \"refieren\" a una instancia de la clase. Es la propiedad anchura de la instancia subyacente la que se cambia, no los valores de las referencias constantes a la instancia de Ventana . A diferencia de las clases, una instancia de un struct definida con un let define como constantes todas sus propiedades. Por ejemplo, el siguiente c\u00f3digo generar\u00eda un error: 1 2 3 let coords3 = CoordsPantalla ( posX : 400 , posY : 400 ) coords3 . posX = 800 // error: cannot assign to property: coords3 is a let constant Operadores de identidad A veces puede ser \u00fatil descubrir si dos constantes o variables se refieren exactamente a la misma instancia de una clase. Para permitir esto, Swift proporciona dos operadores de identidad: Id\u00e9ntico a ( === ) No id\u00e9ntico a ( !== ) 1 2 3 4 if ventana1 === ventana2 { print ( ventana1 y ventana2 se refierena a la misma instancia de ventana. ) } // Imprime ventana1 y ventana2 se refierena a la misma instancia de ventana. Estos operadores \"id\u00e9ntico a\" no son los mismos que los de \"igual a\" (representado por dos signos iguales == ): \"Id\u00e9ntico a\" significa que dos constantes o variables de una clase se refieren exactamente a la misma instancia de la clase. \"Igual a\" significa que dos instancias se consideran \"iguales\" o \"equivalentes\" en su valor. Es responsabilidad del dise\u00f1ador de la clase definir la implementaci\u00f3n de estos operadores. Si tienes experiencia con C, C++, o Objective-C, puedes saber que estos lenguajes usan punteros para referirse a una direcci\u00f3n de memoria. Una constante o variable en Swift que se refiere a una instancia de un tipo referencia es similar a un puntero en C, pero no es un puntero que apunta a una direcci\u00f3n de memoria y no requiere que se escriba un asterisco (*) para indicar que estas creando una referencia. En su lugar, estas referencias se definen como cualquier otra constante o variable en Swift. Criterios para usar estructuras y clases Podemos usar tanto clases como estructuras para definir nuestros tipos de datos y utilizarlos como bloques de construcci\u00f3n del c\u00f3digo de nuestros programas. Sin embargo, se utilizan para distintos tipos de tareas. Como regla general, utilizaremos una estructura cuando se cumplen una o m\u00e1s de las siguientes condiciones: El principal objetivo de la estructura es encapsular unos pocos datos relativamente sencillos. Es razonable esperar que los valores encapsulados ser\u00e1n copiados, m\u00e1s que referenciados, cuando asignamos o pasamos una instancia de esa estructura. Todas las propiedades almacenadas en la estructura son a su vez tipos valor, que tambi\u00e9n se espera que sean copiados m\u00e1s que referenciados. La estructura no necesita heredar propiedades o conducta de otro tipo existente. Ejemplos de buenos candidatos de estructuras incluyen: El tama\u00f1o de una forma geom\u00e9trica, encapsulando por ejemplo las propiedades ancho y alto de tipo Double . Una forma de referirse a rangos dentro de una serie, encapsulando por ejemplo, una propiedad comienzo y otra longitud , ambos del tipo Int . Un punto en un sistema de coordenadas 3D, encapsulando quiz\u00e1s las propiedades x , y y z , todos ellos de tipo Double . En el resto de casos, definiremos una clase y crearemos instancias de esa clase que tendr\u00e1n que ser gestionadas y pasadas por referencia. En la pr\u00e1ctica, esto representa que la mayor\u00eda de datos que construiremos en nuestros programas deber\u00edan clases, no estructuras. Aunque usaremos muchas de las estructuras est\u00e1ndar de Swift. Propiedades Las propiedades asocian valores con una clase, estructura o enumeraci\u00f3n particular. Las propiedades almacenadas ( stored properties ) almacenan valores constantes y variables como parte de una instancia, mientras que las propiedades calculadas ( computed properties ) calculan (en lugar de almacenar) un valor. Las propiedades calculadas se definen en clases, estructuras y enumeraciones. Las propiedades almacenadas se definen s\u00f3lo en clases y estructuras. Enumeraciones: pueden contener s\u00f3lo propiedades calculadas. Clases y estructuras: pueden contener propiedades almacenadas y calculadas. Las propiedades calculadas y almacenadas se asocian habitualmente con instancias de un tipo particular. Sin embargo, las propiedades tambi\u00e9n pueden asociarse con el propio tipo. Estas propiedades se conocen como propiedades del tipo ( type properties ). Adem\u00e1s, en Swift es posible definir observadores de propiedades que monitoricen cambios en los valores de una propiedad, a los que podemos responder con acciones programadas. Los observadores de propiedades pueden a\u00f1adirse tanto a propiedades almacenadas definidas por nosotros como a propiedades heredadas de la superclase. Propiedades almacenadas En su forma m\u00e1s simple, una propiedad almacenada es una constante o variable que est\u00e1 almacenada como parte de una instancia de una clase o estructura particular. Las propiedades almacenadas pueden ser o bien variables (usando la palabra clave var ) o bien constantes (usando la palabra clave let ). Podemos proporcionar un valor por defecto para la inicializaci\u00f3n de las propiedades almacenadas, tanto variables como constantes. El siguiente ejemplo define una estructura llamada RangoLongitudFija que describe un rango de valores enteros cuya longitud no puede ser modificada una vez que se crea: 1 2 3 4 5 6 7 8 struct RangoLongitudFija { var primerValor : Int let longitud : Int } var rangoDeTresItemss = RangoLongitudFija ( primerValor : 0 , longitud : 3 ) // el rango representa ahora valores enteros the range represents integer values 0, 1, and 2 rangoDeTresItemss . primerValor = 6 // el rango representa ahora valores enteros 6, 7 y 8 Las instancias de RangoLongitudFija tienen una propiedad almacenada variable llamada primerValor y una propiedad almacenada constante llamada longitud . En el ejemplo, longitud se inicializa cuando se crea el nuevo rango y no puede ser cambiada en el futuro, por ser una propiedad constante. Si creamos una instancia de una estructura y la asignamos a una constante, no podremos modificar las propiedades de la instancia, incluso si han sido declaradas como propiedades variables: 1 2 3 4 let rangoDeCuatroItems = RangoLongitudFija ( primerValor : 0 , longitud : 4 ) // este rango representa valores enteros 0, 1, 2 y 3 rangoDeCuatroItems . primerValor = 6 // esto producir\u00e1 un error, incluso aun siendo primerValor una propiedad variable Debido a que rangoDeCuatroItems se ha declarado como constante (con la palabra clave let ), no es posible cambiar su propiedad primerValor , incluso aunque sea una propiedad variable. Esta conducta se debe a que las estructuras son tipos valor . Cuando una instancia de un tipo valor se marca como constante, tambi\u00e9n lo son todas sus propiedades. Esto no sucede as\u00ed con las clases, que son tipos referencia . Si asignamos una instancia de un tipo referencia a una constante, puedes seguir cambiando las propiedades variables de esa instancia. Propiedades calculadas Adem\u00e1s de las propiedades almacenadas, las clases, estructuras y enumeraciones pueden definir propiedades calculadas , que no almacenan realmente un valor. En su lugar, proporcionan un getter y un opcional setter que devuelven y modifican otras propiedades y valores de forma indirecta. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 struct Punto { var x = 0.0 , y = 0.0 } struct Tama \u00f1 o { var ancho = 0.0 , alto = 0.0 } struct Rectangulo { var origen = Punto () var tama \u00f1 o = Tama \u00f1 o () var centro : Punto { get { let centroX = origen . x + ( tama \u00f1 o . ancho / 2 ) let centroY = origen . y + ( tama \u00f1 o . alto / 2 ) return Punto ( x : centroX , y : centroY ) } set ( centroNuevo ) { origen . x = centroNuevo . x - ( tama \u00f1 o . ancho / 2 ) origen . y = centroNuevo . y - ( tama \u00f1 o . alto / 2 ) } } } var cuadrado = Rectangulo ( origen : Punto ( x : 0.0 , y : 0.0 ), tama \u00f1 o : Tama \u00f1 o ( ancho : 10.0 , alto : 10.0 )) let centroCuadradoInicial = cuadrado . centro cuadrado . centro = Punto ( x : 15.0 , y : 15.0 ) print ( cuadrado.origen est\u00e1 ahora en ( \\( cuadrado . origen . x ) , \\( cuadrado . origen . y ) ) ) // Prints cuadrado.origen est\u00e1 ahora en (10.0, 10.0) Este ejemplo define tres estructuras para trabajar con formas geom\u00e9tricas: Punto encapsula una coordenada (x, y) Tama\u00f1o encapsula un ancho y un alto Rectangulo define una rect\u00e1ngulo por un punto de origen y un tama\u00f1o La estructura Rectangulo proporciona una propiedad calculada llamada centro . La posici\u00f3n actual del centro de un Rectangulo puede ser siempre determinada a partir de su origen y su tama\u00f1o, por lo que no necesitamos almacenarlo como un Punto expl\u00edcito. En su lugar, Rectangulo define un getter y un setter programado para una variable calculada llamada centro , para permitirnos trabajar con el centro del rect\u00e1ngulo como si fuera una propiedad almacenada. En el ejemplo se crea una variable Rectangulo llamada cuadrado . La variable cuadrado se inicializa un un punto origen de (0, 0) y un ancho y tama\u00f1o de 10 . Este cuadrado est\u00e1 representado por el cuadrado azul en el diagrama de abajo. Accedemos entonces a la propiedad centro de la variable cuadrado usando la sintaxis del punto ( square.centro ), lo que causa que se llame al getter de centro para devolver el valor actual de la propiedad. En lugar de devolver los valores existentes, el getter calcula realmente y devuelve un nuevo Punto para representar el centro del cuadrado. Como puede verse arriba, el getter devuelve correctamente un punto con los valores (5, 5) . Despu\u00e9s la propiedad centro se actualiza al nuevo valor de (15, 15) lo que mueve el cuadrado arriba a la derecha, a la nueva posici\u00f3n mostrada por el cuadrado naranja en el diagrama de abajo. Al asignar el nuevo valor a la propiedad se llama al setter del centro, lo que modifica los valores x e y de las propiedades almacenadas originales, y mueve el cuadrado a su nueva posici\u00f3n. Se puede definir una versi\u00f3n acortada del setter usando la variable por defecto newValue que contiene el nuevo valor asignado en el setter : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 struct Rectangulo { var origen = Punto () var tama \u00f1 o = Tama \u00f1 o () var centro : Punto { get { let centroX = origen . x + ( tama \u00f1 o . ancho / 2 ) let centroY = origen . y + ( tama \u00f1 o . alto / 2 ) return Punto ( x : centroX , y : centroY ) } set { origen . x = newValue . x - ( tama \u00f1 o . ancho / 2 ) origen . y = newValue . y - ( tama \u00f1 o . alto / 2 ) } } } Propiedades solo-lectura Una propiedad calculada con un getter y sin setter se conoce como una propiedad calculada de solo-lectura. Una propiedad calculada de solo-lectura siempre devuelve un valor, y puede accederse a ella usando la sintaxis de punto, pero no puede modificarse a un valor distinto. Es posible simplificar la declaraci\u00f3n de una propiedad calculada de solo-lectura eliminando la palabra clave get y sus llaves: 1 2 3 4 5 6 7 8 9 struct Cuboide { var ancho = 0.0 , alto = 0.0 , profundo = 0.0 var volumen : Double { return ancho * alto * profundo } } let cuatroPorCincoPorDos = Cuboide ( ancho : 4.0 , alto : 5.0 , profundo : 2.0 ) print ( el volumen de cuatroPorCincoPorDos es \\( cuatroPorCincoPorDos . volumen ) ) // Imprime el volumen de cuatroPorCincoPorDos es 40.0 Este ejemplo define una nueva estructura llamada Cubiode , que representa una caja rectangular 3D con propiedades ancho , alto y profundo . Esta estructura tiene una propiedad calculada llamada volumen , que calcula y devuelve el volumen actual del cuboide. No tendr\u00eda sentido que el volumen fuera modificable, porque no ser\u00eda ambiguo determinar qu\u00e9 valores concretos de ancho, alto y profundo deber\u00edan usarse para un valor particular del volumen. Observadores de propiedades Los observadores de propiedades ( property observers ) observan y responden a cambios en el valor de una propiedad. Los observadores de propiedades se llaman cada vez que el valor de una propiedad es actualizado, incluso si el nuevo valor es el mismo que el valor actual de la propiedad. Se pueden a\u00f1adir observadores a cualquier propiedad almacenada que se definan. Se pueden tambi\u00e9n a\u00f1adir observadores a cualquier propiedad heredada (ya sea almacenada o calculada) sobreescribiendo la propiedad en la subclase. No es necesario definir observadores de propiedades calculadas no sobreescritas porque siempre es posible observar y responder a cambios en su valor en el setter de la propiedad. Es posible definir alguno o ambos de estos observadores sobre una propiedad: willSet es llamado justo antes de que el nuevo valor se almacena en la propiedad. didSet es llamado inmediatamente despu\u00e9s de que el nuevo valor es almacenado en la propiedad. Si implementamos un observador willSet , se le pasa el nuevo valor de la propiedad como un par\u00e1metro constante. Podemos especificar un nombre para este par\u00e1metro como parte de la implementaci\u00f3n de willSet . Si no escribimos el nombre del par\u00e1metro y los par\u00e9ntesis dentro de la implementaci\u00f3n, el par\u00e1metro estar\u00e1 disponible con el nombre por defecto de newValue . De forma similar, si implementamos un observador didSet , se pasa como un par\u00e1metro constante que contiene el valor antiguo de la propiedad. Podemos darle nombre al par\u00e1metro o usar el nombre por defecto de oldValue . Si asignamos un valor a la propiedad dentro de su propio observador didSet , el nuevo valor que asignamos reemplaza el que acaba de a\u00f1adirse a la propiedad. A continuaci\u00f3n podemos ver un ejemplo de willSet y didSet en acci\u00f3n. En el definimos una clase nueva llamada CuentaPasos , que hace un seguimiento del n\u00famero total de pasos que una persona hace al caminar. Esta clase puede usarse con datos de entrada de un pod\u00f3metro o cualquier otro sistema de seguir el ejercicio de la persona durante sus rutina diaria. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class ContadorPasos { var totalPasos : Int = 0 { willSet ( nuevoTotalPasos ) { print ( A punto de actualizar totoalPasos a \\( nuevoTotalPasos ) ) } didSet { if totalPasos oldValue { print ( A\u00f1adidos \\( totalPasos - oldValue ) pasos ) } } } } let contadorPasos = ContadorPasos () contadorPasos . totalPasos = 200 // Imprime: A punto de actualizar totalPasos a 200 // Imprime: A\u00f1adidos 200 pasos contadorPasos . totalPasos = 360 // Imprime: A punto de actualizar totalPasos a 360 // Imprime: A\u00f1adidos 160 pasos contadorPasos . totalPasos = 896 // Imprime: A punto de actualizar totalPasos a 896 // Imprime: A\u00f1adidos 536 pasos La clase CuentaPasos declara la propiedad totalPasos de tipo Int . Esta es una propiedad almacenada con observadores willSet y didSet . Los observadores willSet y didSet de totalPasos se llaman siempre que se le asigna un nuevo valor a la propiedad. Esto es as\u00ed incluso si el nuevo valor es el mismo que el valor actual. El observador willSet usa un par\u00e1metro definido por nosotros con el nombre de nuevoTotalPasos para el valor que llega. En el ejemplo, sencillamente imprime el valor que est\u00e1 a punto de establecer. El observador didSet se llama despu\u00e9s de que el valor de totalPasos se ha actualizado. Compara el nuevo valor de totalPasos con el valor antiguo. Si el n\u00famero total de pasos se ha incrementado, se imprime un mensaje indicando cu\u00e1ntos pasos se han tomado. El observador didSet no proporciona un par\u00e1metro definido por nosotros para el valor antiguo, sino que usa el nombre por defecto oldValue . Variables locales y globales Las capacidades anteriores de propiedades calculadas y de observadores tambi\u00e9n est\u00e1n disponibles para variables globales y locales. El siguiente ejemplo muestra un ejemplo con una variable calculada a partir de otras dos: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 var x = 10 { didSet { print ( El nuevo valor: \\( x ) y el valor antiguo: \\( oldValue ) ) } } var y = 2 * x var z : Int { get { return x + y } set { x = newValue / 2 y = newValue / 2 } } print ( z ) z = 100 print ( x ) Propiedades del tipo Las propiedades de las instancias son propiedades que pertenecen a una instancia de un tipo particular. Cada vez que creamos una nueva instancia de ese tipo, tiene su propio conjunto de valores de propiedades, separados de los de cualquier otra instancia. Podemos definir tambi\u00e9n propiedades que pertenecen al tipo propiamente dicho, no a ninguna de las instancias de ese tipo. S\u00f3lo habr\u00e1 una copia de estas propiedades, sea cual sea el n\u00famero de instancias de ese tipo que creemos. Estos tipos de propiedades se llaman propiedades del tipo ( type propierties ). Se pueden definir en tanto en estructuras, clases como en enumeraciones. Las propiedades del tipo son \u00fatiles para definir valores que son universales a todas las instancias de un tipo particular, como una propiedad constante que todas las instancias pueden usar (como una constante est\u00e1tica en C), o una propiedad variable que almacena un valor que es global a todas las instancias de ese tipo (como una variable est\u00e1tica en C). Las propiedades del tipo almacenadas pueden ser variables o constantes. Las propiedades del tipo calculadas se declaran siempre como propiedades variables, de la misma forma que las propiedades calculadas de instancias. A diferencia de las propiedades almacenadas de instancias, debemos siempre proporcionar un valor por defecto para las propiedades almacenadas de tipo. Esto es debido a que el tipo por si mismo no tiene un inicializador que pueda asignar un valor en tiempo de inicializaci\u00f3n. En Swift, las propiedades del tipo se definen como parte de la definici\u00f3n del tipo, dentro de las llaves del tipo. Las propiedades del tipo toman valor en el \u00e1mbito del tipo. Para definir una propiedad del tipo hay que usar la palabra clave static . Para propiedades de tipo calculadas de clases, podemos usar en su lugar la palabra clave class para permitir a las subclases que sobreescriban la implementaci\u00f3n de la superclase. Las propiedades del tipo pueden ser tambi\u00e9n constantes ( let ) o variables ( var ). Ejemplo: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 struct UnaEstructura { static let propiedadTipoAlmacenada = Alg\u00fan valor. static var propiedadTipoCalculada : Int { return 1 } } enum UnaEnumeracion { static var propiedadTipoAlmacenada = Alg\u00fan valor. static var propiedadTipoCalculada : Int { return 6 } } class UnaClase { static var propiedadTipoAlmacenada = Alg\u00fan valor. static var propiedadTipoCalculada : Int { return 27 } class var propiedadTipoCalculadaSobreescribible : Int { return 107 } } Las propiedades del tipo se consultan y actualizan usando tambi\u00e9n la sintaxis de punto, pero sobre el tipo , no sobre una instancia: 1 2 3 4 5 6 7 8 9 print ( UnaEstructura . propiedadTipoAlmacenada ) // Imprime Alg\u00fan valor. UnaEstructura . propiedadTipoAlmacenada = Otro valor. print ( UnaEstructura . propiedadTipoAlmacenada ) // Imprime Otro valor. print ( UnaEnumeracion . propiedadTipoCalculada ) // Imprime 6 print ( UnaClase . propiedadTipoCalculada ) // Imprime 27 Un ejemplo: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 struct Valor { var valor : Int = 0 { didSet { Valor . sumaValores += valor } } static var sumaValores = 0 } var c1 = Valor () var c2 = Valor () var c3 = Valor () c1 . valor = 10 c2 . valor = 20 c3 . valor = 30 print ( Suma de los cambios de valores: \\( Valor . sumaValores ) ) // Imprime 60 M\u00e9todos Los m\u00e9todos son funciones que est\u00e1n asociadas a un tipo particular. Las clases, estructuras y enumeraciones pueden definir todas ellas m\u00e9todos de instancia, que encapsulan tareas y funcionalidades espec\u00edficas que trabajan con una instancia de un tipo dado. Las clases, estructuras y enumeraciones tambi\u00e9n pueden definir m\u00e9todos del tipo, que est\u00e1n asociados con el propio tipo. Los m\u00e9todos del tipo son similares a los m\u00e9todos de clase en Java. El hecho de que las estructuras y las enumeraciones puedan definir m\u00e9todos en Swift es una diferencia importante con C y Objective-C. M\u00e9todos de instancia Los m\u00e9todos de instancia son funciones que pertenecen a instancias de una clase, estructura o enumeraci\u00f3n. Proporcionan la funcionalidad de esas instancias, bien proporcionando formas de acceder y modificar propiedades de las instancias, o bien proporcionando funcionalidades relacionadas con el prop\u00f3sito de la instancia. Los m\u00e9todos de instancia tienen exactamente la misma sintaxis que las funciones. Los m\u00e9todos de instancia se escriben dentro de las llaves del tipo al que pertenecen. Un m\u00e9todo de instancia tiene acceso impl\u00edcito a todos los otros m\u00e9todos de instancia y propiedades del tipo. Un m\u00e9todo de instancia puede ser invocado s\u00f3lo sobre una instancia espec\u00edfica del tipo al que pertenece. No puede ser invocado de forma aislada sin una instancia existente. A continuaci\u00f3n podemos ver un ejemplo que define una sencilla clase Contador , que puede usarse para contar el n\u00famero de veces que sucede una acci\u00f3n: 1 2 3 4 5 6 7 8 9 10 11 12 class Contador { var veces = 0 func incrementa () { veces += 1 } func incrementa ( en cantidad : Int ) { veces += cantidad } func reset () { veces = 0 } } Y un ejemplo de uso: 1 2 3 4 5 6 7 8 let contador = Contador () // el valor inicial del contador es 0 contador . incrementa () // el valor del contador es ahora 1 contador . incrementa ( en : 5 ) // el valor del contador es ahora 6 contador . reset () // el valor del contador es ahora 0 Nombres locales y externos de par\u00e1metros Ya vimos que los par\u00e1metros de las funciones pueden tener un nombre interno y un nombre externo. Lo mismo sucede con los m\u00e9todos, porque los m\u00e9todos no son m\u00e1s que funciones asociadas con un tipo. Los nombres de los m\u00e9todos en Swift se refieren normalmente al primer par\u00e1metro usando una preposici\u00f3n como con , en , a o por , como hemos visto en el ejemplo anterior incrementa(en:) . El uso de la preposici\u00f3n permite que el m\u00e9todo se lea como una frase. El nombre de una par\u00e1metro se utiliza tambi\u00e9n como etiqueta del argumento (nombre externo). Al igual que en las funciones, es posible definir dos nombres del par\u00e1metro, uno externo y otro interno. Y el nombre externo puede ser un _ para indicar que no es necesario usar la etiqueta del argumento. Esta forma de invocar a los m\u00e9todos hace que el lenguaje sea m\u00e1s expresivo, sin necesidad de nombres largos de m\u00e9todos o funciones. Consideremos por ejemplo esta versi\u00f3n alternativa de la clase Contador , que define una forma m\u00e1s compleja del m\u00e9todo incrementa(en:) : 1 2 3 4 5 6 class Contador { var valor : Int = 0 func incrementa ( en cantidad : Int , numeroDeVeces : Int ) { valor += cantidad * numeroDeVeces } } El m\u00e9todo incrementa(en:numeroDeVeces:) tiene dos par\u00e1metros: cantidad y numeroDeVeces . El primer par\u00e1metro tiene un nombre externo y otro interno. En el cuerpo del m\u00e9todo se utiliza el nombre interno ( cantidad ). El segundo par\u00e1metro numeroDeVeces es tanto nombre externo como interno. Podemos llamar al m\u00e9todo de la siguiente forma: 1 2 3 let contador = Contador () contador . incrementa ( en : 5 , numeroDeVeces : 3 ) // el valor del contador es ahora 15 Al igual que en las funciones, podemos definir expl\u00edcitamente los nombres externos de los par\u00e1metros y usar el subrayado ( _ ) para indicar que ese par\u00e1metro no tendr\u00e1 nombre externo. La propiedad self Toda instancia de un tipo tiene una propiedad impl\u00edcita llamada self , que es exactamente equivalente a la instancia misma. Podemos usar la propiedad self para referirnos a la instancia actual dentro de sus propios m\u00e9todos de instancia. El m\u00e9todo increment() en el ejemplo anterior podr\u00eda haberse escrito de esta forma: 1 2 3 func incrementa () { self . veces += 1 } En la pr\u00e1ctica no es necesario usar self casi nunca. Swift asume que cualquier referencia a una propiedad dentro de un m\u00e9todo se refiere a la propiedad de la instancia. El \u00fanico caso en que es obligado usarlo es cuando el nombre de la propiedad coincide con el nombre de un par\u00e1metro. En esta situaci\u00f3n el nombre del par\u00e1metro toma precedencia y es necesario usar self para poder referirse a la propiedad de la instancia. Un ejemplo: 1 2 3 4 5 6 7 8 9 10 11 struct Punto { var x = 0.0 , y = 0.0 func estaAlaDerecha ( de x : Double ) - Bool { return self . x x } } let unPunto = Punto ( x : 4.0 , y : 5.0 ) if unPunto . estaAlaDerecha ( de : 1.0 ) { print ( Este punto est\u00e1 a la derecha de la l\u00ednea donde x == 1.0 ) } // Imprime Este punto est\u00e1 a la derecha de la l\u00ednea donde x == 1.0 Modificaci\u00f3n de tipos valor desde dentro de la instancia Las estructuras y las enumeraciones son tipos valor. Por defecto, las propiedades de un tipo valor no pueden ser modificadas desde dentro de los m\u00e9todos de instancia. Sin embargo, si necesitamos modificar las propiedades de nuestra estructura o enumeraci\u00f3n dentro de un m\u00e9todo particular, podemos conseguir una conducta mutadora para ese m\u00e9todo. El m\u00e9todo puede mutar (esto es, cambiar) sus propiedades desde dentro del m\u00e9todo, as\u00ed como asignar una instancia completamente nueva a su propiedad impl\u00edcita self , con lo que esta nueva instancia reemplazar\u00e1 la existente cuando el m\u00e9todo termine. Podemos conseguir esta conducta colocando la palabra clave mutating antes de la palabra func del m\u00e9todo: 1 2 3 4 5 6 7 8 9 10 11 struct Punto { var x = 0.0 , y = 0.0 mutating func incrementa ( incX : Double , incY : Double ) { x += incX y += incY } } var unPunto = Punto ( x : 1.0 , y : 1.0 ) unPunto . incrementa ( incX : 2.0 , incY : 3.0 ) print ( El punto est\u00e1 ahora en ( \\( unPunto . x ) , \\( unPunto . y ) ) ) // Imprime El punto est\u00e1 ahora en (3.0, 4.0) La estructura Punto anterior define un m\u00e9todo mutador increment(incX:incY:) que mueve una instancia de Punto una cierta cantidad. En lugar de devolver un nuevo punto, el m\u00e9todo modifica realmente el punto en el que es llamado. La palabra clave mutating se a\u00f1ade a su definici\u00f3n para permitirle modificar sus propiedades. Hay que hacer notar que no es posible llamar a un m\u00e9todo mutador sobre una constante de un tiempo estructura, porque sus propiedades no se pueden cambiar, incluso aunque sean propiedades variables: 1 2 3 let puntoFijo = Punto ( x : 3.0 , y : 3.0 ) puntoFijo . incrementa ( incX : 2.0 , incY : 3.0 ) // esto provocar\u00e1 un error Asignaci\u00f3n a self en un m\u00e9todo mutador Los m\u00e9todos mutadores pueden asignar una nueva instancia completamente nueva a la propiedad self . El anterior ejemplo Punto podr\u00eda habers escrito de la siguiente forma: 1 2 3 4 5 6 struct Punto { var x = 0.0 , y = 0.0 mutating func incrementa ( incX : Double , incY : Double ) { self = Punto ( x : x + incX , y : y + incY ) } } Esta versi\u00f3n del m\u00e9todo mutador incrementa(incX:incY:) crea una estructura nueva cuyos valores x e y se inicializan a los valores desados. El resutado final de llamar a esta versi\u00f3n alternativa ser\u00e1 exactamente el mismo que llamar a la versi\u00f3n anterior (aunque con una peque\u00f1a penalizaci\u00f3n de eficiencia: este m\u00e9todo es 1,3 veces m\u00e1s lento que el anterior en la versi\u00f3n 2.2 del compilador de Swift). Los m\u00e9todos mutadores de enumeraciones pueden establecer el par\u00e1metro self impl\u00edcito para que tenga un subtipo distinto de la misma enumeraci\u00f3n: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 enum InterruptorTriEstado { case apagado , medio , alto mutating func siguiente () { switch self { case . apagado : self = . medio case . medio : self = . alto case . alto : self = . apagado } } } var luzHorno = InterruptorTriEstado . medio luzHorno . siguiente () // luzHorno es ahora .alto luzHorno . siguiente () // luzHorno es ahora .apagado M\u00e9todos del tipo Los m\u00e9todos de instancia, como los descritos antes, se llaman en instancias de un tipo particular. Es posible tambi\u00e9n definir m\u00e9todos que se llaman en el propio tipo. Esta clase de m\u00e9todos se denominan m\u00e9todos del tipo . Se define un m\u00e9todo del tipo escribiendo la palabra clave static antes de la palabra clave func del m\u00e9todo. Las clases tambi\u00e9n pueden usar la palabra clave class para permitir a las subclases sobreescribir la implementaci\u00f3n del m\u00e9todo. Los m\u00e9todos del tipo se invocan tambi\u00e9n con la sintaxis de punto, escribiendo el nombre del tipo. Por ejemplo: 1 2 3 4 5 6 class NuevaClase { static func unMetodoDelTipo () { print ( Hola desde el tipo ) } } NuevaClase . unMetodoDelTipo () Dentro del cuerpo del m\u00e9todo, la propiedad impl\u00edcita self se refiere al propio tipo, m\u00e1s que a una instancia de ese tipo. Para estructuras y enumeraciones, esto significa que puedes usar self para desambiguar entre propiedades del tipo y los par\u00e1metros del m\u00e9todo, de la misma forma que se hace en los m\u00e9todos de instancias. Cualquier nombre de m\u00e9todo o propiedad que se utilice en el cuerpo de un m\u00e9todo del tipo se referir\u00e1 a otras propiedades o m\u00e9todos de nivel del tipo. Se puede utilizar estos nombres sin necesidad de a\u00f1adir el prefijo del nombre del tipo. Por ejemplo, podemos a\u00f1adir a la clase Ventana una propiedad y m\u00e9todo de clase con la que almacenar instancias de ventanas. Inicialmente guardamos un array vac\u00edo. 1 2 3 4 5 6 7 8 9 10 class Ventana { // Propiedades static var ventanas : [ Ventana ] = [] static func registrar ( ventana : Ventana ) { ventanas . append ( ventana ) } } Cada vez que creamos una ventana podemos llamar al m\u00e9todo registrar de la clase para a\u00f1adirlo a la colecci\u00f3n de ventanas de la clase: 1 2 3 4 let v1 = Ventana () Ventana . registrar ( ventana : v1 ) print ( Se han registrado \\( Ventana . ventanas . count ) ventanas ) // Imprime Se han registrado 1 ventanas Herencia Una clase puede heredar m\u00e9todos, propiedades y otras caracter\u00edsticas de otra clase. Cuando una clase hereda de otra, la clase que hereda se denomina subclase , y la clase de la que se hereda se denomina su superclase . La herencia es una conducta fundamental que diferencia las clases de otros tipos en Swift. Las clases en Swift pueden llamar y acceder a m\u00e9todos y propiedades que pertenecen a su superclase y pueden proporcionar sus propias versiones que sobreescriben esos m\u00e9todos y propiedades. Para sobreescribir un m\u00e9todo o una propiedad es necesario cumplir con la definici\u00f3n proporcionada por la superclase. Las clases tambi\u00e9n pueden a\u00f1adir observadores a las propiedades heredadas para ser notificadas cuando cambia el valor de una propiedad. A cualquier propiedad se le puede a\u00f1adir un observador de propiedad, independientemente de si es originalmente una propiedad almacenada o calculada. Definici\u00f3n de una clase base Una clase que no hereda de ninguna otra se denomina una clase base ( base class ). A diferencia de otros lenguajes orientados a objetos, las clases en Swift no heredan de una clase base universal. Tambi\u00e9n a diferencia de otros lenguajes orientados a objetos Swift no permite definir clases abstractas que no permiten crear instancias. Cualquier clase en Swift puede ser instanciada. El siguiente ejemplo define una clase base llamada Vehiculo . Esta clase base define una propiedad almacenada llamada velocidadActual con un valor por defecto de 0.0. Esta propiedad se utiliza por una propiedad String calculada llamada descripcion que crea una descripci\u00f3n del veh\u00edculo. La clase base Vehiculo tambi\u00e9n define un m\u00e9todo llamdo hazRuido . Este m\u00e9todo no hace nada realmente para una instancia de un veh\u00edculo base, pero ser\u00e1 modificado m\u00e1s adelante por las subclases de Vehiculo . 1 2 3 4 5 6 7 8 9 class Vehiculo { var velocidadActual = 0.0 var descripcion : String { return viajando a \\( velocidadActual ) kil\u00f3metros por hora } func hazRuido () { // no hace nada - un veh\u00edculo arbitrario no hace ruido necesariamente } } Creamos una instancia nueva de Vehiculo con la sintaxis de inicializaci\u00f3n que hemos visto, en la que se escribe el nombre del tipo de la clase seguido por par\u00e9ntesis vac\u00edos: 1 let unVehiculo = Vehiculo () Habiendo creado una instancia nueva de Vehiculo , podemos acceder a su descripci\u00f3n: 1 2 print ( Veh\u00edculo: \\( unVehiculo . descripcion ) ) // Veh\u00edculo: viajando a 0.0 kil\u00f3metros por hora La clase Vehiculo define caracter\u00edsticas comunes para un veh\u00edculo arbitrario, pero no es de mucha utilidad por si misma. Para hacerla m\u00e1s \u00fatil, tenemos que refinarla para describir tipos de veh\u00edculos m\u00e1s espec\u00edficos. Construcci\u00f3n de subclases La construcci\u00f3n de una subclase ( subclassing ) es la acci\u00f3n de basar una nueva clase en una clase existente. La subclase hereda caracter\u00edsticas de la clase existente, que despu\u00e9s podemos refinar. Tambi\u00e9n podemos a\u00f1adir nuevas caracter\u00edsticas a la subclase. Para indicar que una subclase tiene una superclase hay que escribir el nombre de la subclase antes de el de la superclase, separadas por dos puntos ( : ): 1 2 3 class UnaSubclase : UnaSuperClase { // definici\u00f3n de la subclase } En el ejemplo anterior del Vehiculo podemos definir una subclase Bicicleta : 1 2 3 class Bicicleta : Vehiculo { var tieneCesta = false } La nueva clase Bicicleta obtiene autom\u00e1ticamente todas las caracter\u00edsticas del Vehiculo , como sus propiedades velocidadActual y descripcion y su m\u00e9todo haceRuido() . Adem\u00e1s de las caracter\u00edsticas que hereda, la clase Bicicleta define una nueva propiedad almacenada, tieneCesta , con un valor por defecto de false . Por defecto, cualquier instancia nueva de Bicicleta no tendr\u00e1 una cesta. Puedes establecer la propiedad tieneCesta a true para una instancia particular de Bicicleta despu\u00e9s de crearla: 1 2 let bicicleta = Bicicleta () bicicleta . tieneCesta = true Podemos tambi\u00e9n modificar la propiedad heredada velocidadActual y preguntar por la propiedad descripcion : 1 2 3 bicicleta . velocidadActual = 10.0 print ( Bicicleta: \\( bicicleta . descripcion ) ) // Bicicleta: viajando a 10.0 kil\u00f3metros por hora Podemos construir subclases a partir de otras subclases. El siguiente ejemplo crea una subclase de Bicicleta que representa una bicicleta de dos sillines (un \"tandem\"): 1 2 3 class Tandem : Bicicleta { var numeroActualDePasajeros = 0 } Tandem hereda todas las propiedades y m\u00e9todos de Bicicleta , que a su vez hereda todas sus propiedades y m\u00e9todos de Vehiculo . La subclase Tandem tambi\u00e9n a\u00f1ade una nueva propiedad almacenada llamada numeroActualDePasajeros , con un valor por defecto de 0. Si creamos una instancia de Tandem podremos trabajar con cualquiera de sus propiedades nuevas y heredadas, y preguntar a la descripci\u00f3n de solo lectura que hereda de Vehiculo : 1 2 3 4 5 6 let tandem = Tandem () tandem . tieneCesta = true tandem . numeroActualDePasajeros = 2 tandem . velocidadActual = 18.0 print ( Tandem: \\( tandem . descripcion ) ) // Tandem: viajando a 18.0 kil\u00f3metros por hora Sobreescritura Una subclase puede proporcionar su propia implementaci\u00f3n de un m\u00e9todo de la instancia, m\u00e9todo del tipo, propiedad de la instancia o propiedad del tipo que hereda de su superclase. Esto se conoce como sobreescritura ( overriding ). Para sobreescribir una caracter\u00edstica que ser\u00eda de otra forma heredada debemos usar el prefijo override . De esta forma se clarifica que intentamos proporcionar una sobreescritura y que no lo hacemos por error. Esta palabra clave tambi\u00e9n hace que el compilador comprueba que la superclase (o una de sus clases padre) tiene una declaraci\u00f3n que empareja con la que proporcionamos en la sobreescritura. Cuando proporcionamos una sobreescritura puede ser \u00fatil acceder a los valores proporcionados por la clase padre. Para acceder a ellos podemos usar el prefijo super . El siguiente ejemplo define una nueva subclase de Vehiculo llamada Tren , que sobreescribe el m\u00e9todo hazRuido() : 1 2 3 4 5 class Tren : Vehiculo { override func hazRuido () { print ( Chuu Chuu ) } } Si creamos una nueva instancia de Tren y llamamos al m\u00e9todo hazRuido podemos comprobar que se llama a la versi\u00f3n del m\u00e9todo de la subclase: 1 2 3 let tren = Tren () tren . hazRuido () // Imprime Chuu Chuu Podemos sobreescribir cualquier propiedad heredada del tipo o de la instancia y proporcionar nuestros propios getters y setters para esa propiedad, o a\u00f1adir observadores de propiedades para observar cuando cambian los valores subyacentes de la propiedad. Podemos proporcionar un getter (o setter , si es apropiado) para sobreescribir cualquier propiedad heredada, independientemente de si la propiedad heredada se implementa como una propiedad almacenada o calculada. La naturaleza almacenada o calculada no se conoce por la subclase, que solo conoce su nombre y su tipo. Es posible convertir una propiedad heredada de solo-lectura en una de lectura-escritura. No es posible presentar una propiedad heredada de lectura-escritura como de solo-lectura. El siguiente ejemplo define una nueva clase llamada Coche , que es una subclase de Vehiculo . La clase Coche introduce una nueva propiedad almacenada llamada marcha , con un valor por defecto de 1. Tambi\u00e9n sobreescribe la propiedad heredada descripcion , incluyendo la marcha actual en la descripci\u00f3n: 1 2 3 4 5 6 class Coche : Vehiculo { var marcha = 1 override var descripcion : String { return super . descripcion + con la marcha \\( marcha ) } } Podemos ver el funcionamiento en el siguiente ejemplo: 1 2 3 4 5 let coche = Coche () coche . velocidadActual = 50.0 coche . marcha = 3 print ( Coche: \\( coche . descripcion ) ) // Coche: viajando a 50.0 kil\u00f3metros por hora con la marcha 3 Por \u00faltimo, podemos a\u00f1adir observadores a propiedades heredadas. Esto nos permite ser notificados cuando el valor de una propiedad heredada cambia, independientemente de si esa propiedad se ha implementado en la subclase o en la superclase. El siguiente ejemplo define una nueva clase llamada CocheAutomatico que es una subclase de Coche . La clase CocheAutomatico representa un coche con una caja de cambios autom\u00e1tica, que selecciona autom\u00e1ticamente la marcha bas\u00e1ndose en la velocidad actual: 1 2 3 4 5 6 7 class CocheAutomatico : Coche { override var velocidadActual : Double { didSet { marcha = min ( Int ( velocidadActual / 25.0 ) + 1 , 5 ) } } } En cualquier momento que se modifica la propiedad velocidadActual de una instancia de CocheAutomatico , el observador didSet establece la propiedad marcha a un valor apropiado para la nueva velocidad. Un ejemplo de ejecuci\u00f3n: 1 2 3 4 let automatico = CocheAutomatico () automatico . velocidadActual = 100.0 print ( CocheAutomatico: \\( automatico . descripcion ) ) // CocheAutomatico: viajando a 100.0 kil\u00f3metros por hora con la marcha 5 Por \u00faltimo, es posible prevenir un m\u00e9todo o propiedad de ser sobreescrito declar\u00e1ndolo como final . Para ello, hay que escribir el modificador final antes del nombre de la palabra clave que introduce el m\u00e9todo o la propiedad (como final var , final func o final class ). Tambi\u00e9n es posible marcar la clase completa como final, escribiendo el modificador antes de class ( final class ). Inicializaci\u00f3n Inicializaci\u00f3n es el proceso de preparar para su uso una instancia de una clase, estructura o enumeraci\u00f3n. Este proceso incluye la asignaci\u00f3n de un valor inicial para cada propiedad almacenada y la ejecuci\u00f3n de cualquier otra operaci\u00f3n de inicializaci\u00f3n que se necesite para que la nueva instancia est\u00e9 lista para usarse. Para implementar este proceso de inicializaci\u00f3n hay que definir inicializadores , que son como m\u00e9todos especiales que pueden llamarse para crear una nueva instancia de un tipo particular. A diferencia de otros lenguajes, los inicializadores en Swift no devuelven un valor. Su papel principal es que las nuevas instancias del tipo est\u00e9n correctamente inicializadas antes de poder ser usadas por primera vez. Tambi\u00e9n es posible implementar deinicializadores , m\u00e9todos que se ejecutan cuando las instancias son eliminadas de la memoria (no vamos a explicarlos por falta de tiempo). El proceso de inicializaci\u00f3n de una instancia puede resultar un proceso complicado, sobre todo cuando se tienen relaciones de herencia y hay que especificar tambi\u00e9n c\u00f3mo realizar la inicializaci\u00f3n de la subclase utilizando la superclase. Por falta de tiempo no vamos a explicar todo el proceso completo. Recomendamos consultar la documentaci\u00f3n original de Swift . Inicializaci\u00f3n de propiedades almacenadas Las clases y estructuras deben definir todas sus propiedades almacenadas a un valor inicial en el tiempo en la instancia se crea. Las propiedades almacenadas no pueden dejarse en un estado indeterminado. Podemos definir el valor inicial para una propiedad en un inicializador o asign\u00e1ndole un valor por defecto como parte de la definici\u00f3n de la propiedad. Un inicializador , en su forma m\u00e1s simple, es como un m\u00e9todo de la instancia sin par\u00e1metros, escrito con la palabra clave init : 1 2 3 init () { // realizar alguna inicializaci\u00f3n aqu\u00ed } Por ejemplo, podemos definir la estructura Farenheit que almacena una temperatura en grados Farenheit. Tiene una propiedad almacenada de tipo Double . Definimos un inicializador que inicializa las instancias a 32.0 (equivalente a 0.0 grados Celsius). 1 2 3 4 5 6 7 8 9 struct Fahrenheit { var temperatura : Double init () { temperatura = 32.0 } } var f = Fahrenheit () print ( La temperatura por defecto es \\( f . temperatura ) Fahrenheit ) // Imprime La temperatura por defecto es 32.0\u00b0 Fahrenheit La implementaci\u00f3n anterior es equivalente a la siguiente (que es preferible, por ser m\u00e1s clara): 1 2 3 struct Fahrenheit { var temperatura = 32.0 } Customizaci\u00f3n de la inicializaci\u00f3n Es posible customizar el proceso de inicializaci\u00f3n con par\u00e1metros de entrada y tipos opcionales, o asignando propiedades constantes durante la inicializaci\u00f3n. Podemos proporcionar par\u00e1metros de inicializaci\u00f3n como parte de la definici\u00f3n de un inicializador, para definir los tipos y los nombres de los valores que customizan el proceso de inicializaci\u00f3n. Los par\u00e1metros de inicializaci\u00f3n tienen las mismas capacidades y sintaxis que los par\u00e1metros de funciones y m\u00e9todos. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 struct Celsius { var temperaturaEnCelsius : Double init ( desdeFahrenheit fahrenheit : Double ) { temperaturaEnCelsius = ( fahrenheit - 32.0 ) / 1.8 } init ( desdeKelvin kelvin : Double ) { temperaturaEnCelsius = kelvin - 273.15 } } let puntoDeEbullicionDelAgua = Celsius ( desdeFahrenheit : 212.0 ) // puntoDeEbullicionDelAgua.temperaturaEnCelsius es 100.0 let puntoDeCongelacionDelAgua = Celsius ( desdeKelvin : 273.15 ) // puntoDeCongelacionDelAgua.temperaturaEnCelsius is 0.0 Vemos que dependiendo del nombre de par\u00e1metro proporcionado se escoge un inicializador u otro. En los inicializadores es obligatorio proporcionar los nombres de todos los par\u00e1metros: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 struct Color { let rojo , verde , azul : Double init ( rojo : Double , verde : Double , azul : Double ) { self . rojo = rojo self . verde = verde self . azul = azul } init ( blanco : Double ) { rojo = blanco verde = blanco azul = blanco } } let magenta = Color ( rojo : 1.0 , verde : 0.0 , azul : 1.0 ) let medioGris = Color ( blanco : 0.5 ) Podemos evitar proporcionar nombres externos usando un subrayado. Por ejemplo, podemos a\u00f1adir al struct anterior Celsius un inicializador sin nombre externo para el caso en que pasemos la temperatura inicial precisamente en Celsius: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 struct Celsius { var temperaturaEnCelsius : Double init ( desdeFahrenheit fahrenheit : Double ) { temperaturaEnCelsius = ( fahrenheit - 32.0 ) / 1.8 } init ( desdeKelvin kelvin : Double ) { temperaturaEnCelsius = kelvin - 273.15 } init ( _ celsius : Double ) { temperaturaEnCelsius = celsius } } let temperaturaCuerpo = Celsius ( 37.0 ) // temperaturaCuerpo.temperaturaEnCelsius es 37.0 Por \u00faltimo, es posible dejar sin inicializar propiedades opcionales, ya que el valor que tomar\u00edan ser\u00eda nil : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class PreguntaEncuesta { let texto : String var respuesta : String ? init ( texto : String ) { self . texto = texto } func pregunta () { print ( texto ) } } let preguntaQueso = PreguntaEncuesta ( texto : \u00bfTe gusta el queso? ) preguntaQueso . pregunta () // Imprime \u00bfTe gusta el queso? preguntaQueso . respuesta = S\u00ed, me gusta el queso. En el ejemplo anterior se comprueba tambi\u00e9n que es posible inicializar constantes. Por ejemplo, la propiedad text est\u00e1 definida con un let y se inicializa en el inicializador. Por \u00faltimo, es posible definir m\u00e1s de un inicializador, as\u00ed como invocar a inicializadores m\u00e1s b\u00e1sicos desde otros. Si definimos un inicializador en una estructura los inicializadores por defecto dejan de funcionar, es necesario escribirlos tambi\u00e9n. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 struct Rectangulo { var origen = Punto () var tama \u00f1 o = Tama \u00f1 o () init (){} init ( origen : Punto , tama \u00f1 o : Tama \u00f1 o ) { self . origen = origen self . tama \u00f1 o = tama \u00f1 o } init ( centro : Punto , tama \u00f1 o : Tama \u00f1 o ) { let origenX = centro . x - ( tama \u00f1 o . ancho / 2 ) let origenY = centro . y - ( tama \u00f1 o . ancho / 2 ) self . init ( origen : Punto ( x : origenX , y : origenY ), tama \u00f1 o : tama \u00f1 o ) } } let basicRectangulo = Rectangulo () // el origen de basicRectangulo es (0.0, 0.0) y su tama\u00f1o (0.0, 0.0) let origenRectangulo = Rectangulo ( origen : Punto ( x : 2.0 , y : 2.0 ), tama \u00f1 o : Tama \u00f1 o ( ancho : 5.0 , alto : 5.0 )) // el origne de origenRectangulo es (2.0, 2.0) y su tama\u00f1o (5.0, 5.0) let centroRectangulo = Rectangulo ( centro : Punto ( x : 4.0 , y : 4.0 ), tama \u00f1 o : Tama \u00f1 o ( ancho : 3.0 , alto : 3.0 )) // el origen de centroRectangulo es (2.5, 2.5) y su tama\u00f1o (3.0, 3.0) Protocolos Un protocolo ( protocol ) define un esquema de m\u00e9todos, propiedades y otros requisitos que encajan en una tarea particular o un trozo de funcionalidad. El protocolo puede luego ser adoptado ( adopted ) por una clase, estructura o enumarci\u00f3n para proporcionar una implementaci\u00f3n real de esos requisitos. Cualquier tipo que satisface los requerimientos de un protocolo se dice que se ajusta o cumple ( conform ) ese protocolo. Adem\u00e1s de especificar los requisitos de los tipos que cumplen el protocolo, tambi\u00e9n se puede extender un protocolo (lo veremos m\u00e1s adelante, cuando hablemos de extensiones ) para proporcionar una implementaci\u00f3n de algunos de los m\u00e9todos requeridos por el protocolo. Sintaxis Los protocolos se definen de forma similar a las clases, estructuras y enumeraciones: 1 2 3 protocol UnProtocolo { // definici\u00f3n del protocolo } Para definir un tipo que se ajusta a un protocolo particular se debe poner el nombre del protocolo tras el nombre del tipo, separado por dos puntos. Podemos listar m\u00e1s de un protocolo, y se separan por comas: 1 2 3 struct UnStruct : PrimerProtocolo , OtroProtocolo { // definici\u00f3n del struct } Si una clase tiene una superclase, se escribe el nombre de la superclase antes los protocolos, seguido por una coma: 1 2 3 class UnaClase : UnaSuperClase , PrimerProtocolo , OtroProto { // definici\u00f3n de la clase } Requisitos de propiedades Un protocolo puede requerir a cualquier tipo que se ajuste a \u00e9l que proporcione una propiedad de instancia o de tipo con un nombre y tipo particular. El protocolo no especifica si la propiedad es una propiedad calculada o almacenada, s\u00f3lo especifica el nombre y el tipo de la propiedad requerida. El protocolo tambi\u00e9n especifica si la propiedad debe ser de lectura y escritura o s\u00f3lo de lectura. Si un protocolo requiere que una propiedad sea de lectura y escritura, el requisito no puede ser satisfecho por una propiedad constante almacenada o por una propiedad calculada de s\u00f3lo lectura. Si el protocolo s\u00f3lo requiere que la propiedad sea de lectura, el requisito puede ser satisfecho por cualquier tipo de propiedad, y es v\u00e1lido que la propiedad sea tambi\u00e9n de escritura si es \u00fatil para nuestro propio c\u00f3digo. Los requisitos de la propiedad se declaran siempre como propiedades variables, precedido por la palabra clave var . Las propiedades de lectura y escritura se indican escribiendo { get set } despu\u00e9s de la declaraci\u00f3n de su tipo, y las propiedades de s\u00f3lo lectura se indican escribiendo { get } . 1 2 3 4 protocol UnProtocolo { var debeSerEscribible : Int { get set } var noTienePorQueSerEscribible : Int { get } } Para definir una propiedad de tipo hay que precederla en el protocolo con la palabra clave static : 1 2 3 protocol OtroProtocolo { static var unaPropiedadDeTipo : Int { get set } } Veamos un ejemplo. Definimos el protocolo TieneNombre en el que se requiere que cualquier clase que se ajuste a \u00e9l debe tener una propiedad de instancia de lectura de tipo String que se llame nombreCompleto : 1 2 3 protocol TieneNombre { var nombreCompleto : String { get } } Un ejemplo de una sencilla estructura que adopta el protocolo: 1 2 3 4 5 6 7 struct Persona : TieneNombre { var edad : Int var nombreCompleto : String } let john = Persona ( edad : 35 , nombreCompleto : John Appleseed ) // john.nombreCompleto es John Appleseed Este ejemplo define una estructure llamada Persona , que representa una persona con una edad y un nombre espec\u00edfico. En la primera l\u00ednea se declara que se adopta el protocolo TieneNombre . Cada instancia de Persona tiene la propiedad almacenada llamada nombreCompleto , que es de tipo String . Esto cumple el \u00fanico requisito del protocolo TieneNombre , y signifca que Persona se ajusta correctamente al protocolo (Swift informa de un error en tiempo de compilaci\u00f3n si un requisito de un protocolo no se cumple). Otro ejemplo de una clase m\u00e1s compleja, que tambi\u00e9n adopta el protocolo: 1 2 3 4 5 6 7 8 9 10 11 12 13 class NaveEstelar : TieneNombre { var prefijo : String ? var nombre : String init ( nombre : String , prefijo : String ? = nil ) { self . nombre = nombre self . prefijo = prefijo } var nombreCompleto : String { return ( prefijo != nil ? prefijo ! + : ) + nombre } } var ncc1701 = NaveEstelar ( nombre : Enterprise , prefijo : USS ) // ncc1701.nombreCompleto es USS Enterprise Esta clase implementa el requisito de la propiedad nombreCompleto como una propiedad calculada de solo lectura para una nave estelar. Cada instancia de NavaEstelar almacena un nombre obligatorio y un prefijo opcional. La propiedad nombreCompleto usa el valor del prefijo si existe, y la a\u00f1ade al comienzo del nombre para crear un nombre completo de la nave estelar. Requisitos de m\u00e9todos Los protocolos pueden requerir que los tipos que se ajusten a ellos implementen m\u00e9todos de instancia y de tipos espec\u00edficos. Estos m\u00e9todos se escriben como parte de la definici\u00f3n del protocolo de la misma forma que los m\u00e9todos normales, pero sin sus cuerpos. Los m\u00e9todos del tipo en el protocolo deben indicarse con la palabra clave static : 1 2 3 protocol UnProtocolo { static func unMetodoDelTipo () } Por ejemplo: 1 2 3 protocol GeneradorNumerosAleatorios { func random () - Double } Este protocolo, GeneradorNumerosAleatorios , requiere que cualquier tipo que se ajuste a \u00e9l tenga un m\u00e9todo de instancia llamado random , que devuelve un valor Double cada vez que se llama. Aunque no est\u00e1 especificado en el protocolo, se asume que este valor ser\u00e1 un n\u00famero entre 0.0 y 1.0 (sin incluirlo). El protocolo GeneradorNumerosAleatorios no hace ninguna suposici\u00f3n sobre c\u00f3mo ser\u00e1 generado cada n\u00famero aleatorio, simplemente requiere al generador que proporcione una forma est\u00e1ndar de generarlo. Una implementaci\u00f3n de una clase que adopta el protocolo: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class GeneradorLinealCongruente : GeneradorNumerosAleatorios { var ultimoRandom = 42.0 let m = 139968.0 let a = 3877.0 let c = 29573.0 func random () - Double { let number = ultimoRandom * a + c ultimoRandom = number . truncatingRemainder ( dividingBy : m ) return ultimoRandom / m } } let generador = GeneradorLinealCongruente () print ( Un n\u00famero aleatorio: \\( generador . random ()) ) // Imprime Un n\u00famero aleatorio: 0.37464991998171 print ( Y otro: \\( generador . random ()) ) // Imprime Y otro: 0.729023776863283 Requisito de m\u00e9todo mutating Si definimos un protocolo con un requisito de m\u00e9todo de instancia que pretenda mutar las instancias del tipo que adopte el protocolo, se debe marcar el m\u00e9todo con la palabra mutating . Esto permite a las estructuras y enumeraciones que adopten el protocolo definir ese m\u00e9todo como mutating . No es necesario hacerlo con las clases, porque la palabra mutating solo es necesaria en estructuras y enumeraciones. Un ejemplo: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 protocol Conmutable { mutating func conmutar () } enum Interruptor : Conmutable { case apagado , encendido mutating func conmutar () { switch self { case . apagado : self = . encendido case . encendido : self = . apagado } } } var interruptorLampara = Interruptor . apagado interruptorLampara . conmutar () // interruptorLampara es ahora igual a .encendido Protocolos como tipos Los protocolos no implementan realmente ninguna funcionalidad por ellos mismos. Sin embargo, cualquier protocolo que definamos se convierte autom\u00e1ticamente en un tipo con todas sus propiedades que podemos usar en nuestro c\u00f3digo. Podemos entonces usar el protocolo en cualquier sitio donde permitamos otros tipos, incluyendo: El tipo de un par\u00e1metro de una funci\u00f3n, m\u00e9todo o inicializador o de sus valores devueltos. El tipo de una constante, variable o propiedad El tipo de los \u00edtems de un array, diccionario u otro contenedor 1 2 3 4 5 6 7 8 9 10 11 class Dado { let caras : Int let generador : GeneradorNumerosAleatorios init ( caras : Int , generador : GeneradorNumerosAleatorios ) { self . caras = caras self . generador = generador } func tirar () - Int { return Int ( generador . random () * Double ( caras )) + 1 } } Este ejemplo define una nueva clase llamada Dado , que representa un dado de n caras que se puede usar en un juego de tablero. Las instancias de dados tienen una propiedad llamada caras , que representa cu\u00e1ntas caras tienen, y una propiedad llamada generador , que proporciona un generador a partir del cual crear valores de tiradas. La propiedad generador es del tipo GeneradorNumerosAleatorios . Podemos asignarle una instancia de cualquier tipo que adopte el protocolo GeneradorNumerosAleatorios . Dado tiene tambi\u00e9n un inicializador, para configurar sus estado inicial. El inicializador tiene un par\u00e1metro llamado generador , que tambi\u00e9n es del tipo GeneradorNumerosAleatorios . Podemos pasarle un valor de cualquier instancia que se ajuste a este tipo. Y tambi\u00e9n proporciona un m\u00e9todo de instancia llamado tirar , que devuelve un valor entero entre 1 y el n\u00famero de caras del dado. Este m\u00e9todo llama al m\u00e9todo random() del generador para crear un nuevo n\u00famero aleatorio entre 0.0 y 1.0 y usa este n\u00famero aleatorio para crear un valor de tirada que est\u00e9 dentro del rango correcto. Debido a que sabemos que el generador se ajusta al protocolo GeneradorNumerosAleatorios tenemos la garant\u00eda de que va a existir un m\u00e9todo random() al que llamar. Un ejemplo de uso del c\u00f3digo: 1 2 3 4 5 6 7 8 9 var d6 = Dado ( caras : 6 , generador : GeneradorLinealCongruente ()) for _ in 1. .. 5 { print ( La tirada del dado es \\( d6 . tirar ()) ) } // La tirada del dado es 3 // La tirada del dado es 5 // La tirada del dado es 4 // La tirada del dado es 5 // La tirada del dado es 4 Colecciones de tipos protocolo Como hemos comentado anteriormente, un protocolo puede usarse como el tipo que se almacena un una colecci\u00f3n (array, diccionario, etc.). Veamos un ejemplo: 1 2 3 4 5 6 7 8 9 10 var peterParker = Persona ( edad : 24 , nombreCompleto : Peter Parker ) var ncc1701 = NaveEstelar ( nombre : Enterprise , prefijo : USS ) let cosasConNombre : [ TieneNombre ] = [ peterParker , ncc1701 ] for cosa in cosasConNombre { print ( cosa . nombreCompleto ) } // Peter Parker // USS Enterprise Hay que hacer notar que la constante cosa que itera sobre los elementos del array es de tipo TieneNombre ], no es de tipo Persona ni de tipo NaveEstelar , incluso aunque las instancias que hay tras de escena son do esos tipos. Por ser del tipo TieneNombre sabemos que tiene una propiedad nombreCompleto que podemos usar sobre la variable iteradora. Protocolos de la biblioteca est\u00e1ndar de Swift En la biblioteca est\u00e1ndar de Swift se definen distintos protocolos como Collection y Equatable que describen abstracciones comunes. Muchos de estos protocolos incorporan implementaciones por defecto de algunos de sus m\u00e9todos mediante extensiones definidas en la propia biblioteca est\u00e1ndar. Veamos por ejemplo el protocolo Equatable . Se trata de un protocolo importante que define las operaciones de igualdad ( == ) y diferencia ( != ). Debemos implementar la operaci\u00f3n de igualdad en cualquier clase que se ajuste al protocolo, pero la operaci\u00f3n de diferencia ya tiene una implementaci\u00f3n por defecto. Un ejemplo: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 struct Punto3D : Equatable { let x , y , z : Double init ( x : Double , y : Double , z : Double ) { self . x = x self . y = y self . z = z } static func == ( izquierda : Punto3D , derecha : Punto3D ) - Bool { return izquierda . x == derecha . x izquierda . y == derecha . y izquierda . z == derecha . z } } let p1 = Punto3D ( x : 0.0 , y : 0.0 , z : 0.0 ) let p2 = Punto3D ( x : 0.0 , y : 0.0 , z : 0.0 ) print ( p1 == p2 ) // Imprime true print ( p1 != p2 ) // Imprime false El operador == se define en la propia estructura. Se utiliza la palabra static para indicar que se trata de un operador que estamos sobrecargando (hablaremos m\u00e1s adelante de los operadores). El operador != que se usa en la \u00faltima instrucci\u00f3n se define en una implementaci\u00f3n por defecto. Casting de tipos El casting de tipos es una forma de comprobar el tipo de una instancia o de tratar esa instancia como de una superclase distinta o conseguir una subclase de alg\u00fan otro sitio en la propia jerarqu\u00eda de clase. La forma de implementarlo es utilizando los operadores is y as . Estos operadores proporcionan una forma simple y expresiva de comprobar el tipo de un valor o transformar un valor en uno de otro tipo. Tambi\u00e9n se puede usar el casting de tipos para comprobar si un tipo se ajusta a un protocolo. Una jerarqu\u00eda de clases para el casting de tipos Vamos a comenzar construyendo una jerarqu\u00eda de clases y subclases con las que trabajar. Utilizaremos el casting de tipos para comprobar el tipo de una instancia particular de una clase y para convertir esa instancia en otra clase dentro de la misma jerarqu\u00eda. En el primer fragmento de c\u00f3digo definimos una clase nueva llamada MediaItem . Esta clase proporciona la funcionalidad b\u00e1sica de cualquier tipo de \u00edtem que aparece en una biblioteca de medios digitales. Espec\u00edficamente, declara una propiedad nombre de tipo String y un inicializador init nombre (suponemos que todos los \u00edtems, incluyendo pel\u00edculas y canciones, tendr\u00e1n un nombre). 1 2 3 4 5 6 class MediaItem { var nombre : String init ( nombre : String ) { self . nombre = nombre } } El siguiente fragmento define dos subclases de MediaItem . La primera subclase, Pelicula , encapsula informaci\u00f3n adicional sobre una pel\u00edcula. A\u00f1ade una propiedad director a la clase base MediaItem , con su correspondiente inicializador. La segunda subclase, Cancion , a\u00f1ade una propiedad artista y un inicializador a la clase base: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Pelicula : MediaItem { var director : String init ( nombre : String , director : String ) { self . director = director super . init ( nombre : nombre ) } } class Cancion : MediaItem { var artista : String init ( nombre : String , artista : String ) { self . artista = artista super . init ( nombre : nombre ) } } Por \u00faltimo, creamos un array constante llamado biblioteca , que contienen dos instancias de Pelicula y tres instancias de Cancion . 1 2 3 4 5 6 7 let biblioteca : [ MediaItem ] = [ Pelicula ( nombre : El Se\u00f1or de los Anillos , director : Peter Jackson ), Cancion ( nombre : Child in Time , artista : Deep Purple ), Pelicula ( nombre : El Puente de los Esp\u00edas , director : Steven Spielberg ), Cancion ( nombre : I Wish You Were Here , artista : Pink Floyd ), Cancion ( nombre : Yellow , artista : Coldplay ) ] Podr\u00edamos tambi\u00e9n dejar que el compilador infiera el tipo del array. Es capaz de deducir que Pelicula y Cancion tienen una superclase com\u00fan MediaItem , por lo que infiere que el tipo del array es [MediaItem] : 1 2 3 4 5 6 7 8 // Declaraci\u00f3n equivalente a la anterior let biblioteca = [ Pelicula ( nombre : El Se\u00f1or de los Anillos , director : Peter Jackson ), Cancion ( nombre : Child in Time , artista : Deep Purple ), Pelicula ( nombre : El Puente de los Esp\u00edas , director : Steven Spielberg ), Cancion ( nombre : I Wish You Were Here , artista : Pink Floyd ), Cancion ( nombre : Yellow , artista : Coldplay ) ] Los \u00edtems almacenados en la biblioteca son todav\u00eda instancias de Pelicula y Cancion . Sin embargo, si iteramos sobre los contenidos de este array, los \u00edtems que recibiremos tendr\u00e1n el tipo MediaItem y no Pelicula o Cancion . Para trabajar con ellos como su tipo nativo, debemos chequear su tipo, y hacer un downcast a su tipo concreto. Comprobaci\u00f3n del tipo Podemos usar el operador de comprobaci\u00f3n ( check operator ) is para comprobar si una instancia es de un cierto tipo subclase. El operador de comprobaci\u00f3n devuelve true si la instancia es del tipo de la subclase y false si no. Lo podemos comprobar en el siguiente ejemplo, en el que contamos las instancias de pel\u00edculas y canciones en el array biblioteca : 1 2 3 4 5 6 7 8 9 10 11 12 13 var contadorPeliculas = 0 var contadorCanciones = 0 for item in biblioteca { if item is Pelicula { contadorPeliculas += 1 } else if item is Cancion { contadorCanciones += 1 } } print ( La biblioteca contiene \\( contadorCanciones ) pel\u00edculas y \\( contadorPeliculas ) canciones ) // Imprime La biblioteca contiene 3 pel\u00edculas y 2 canciones El ejemplo itera por todos los \u00edtems del array biblioteca . En cada paso, el bucle for-in guarda en la constante item el siguiente MediaItem del array. La instrucci\u00f3n item is Pelicula devuelve true si el MediaItem actual es una instancia de Pelicula y false en otro caso. De forma similar, item is Cancion comprueba si el \u00edtem es una instancia de Cancion . Al final del bucle for-in , los valores de contadorPeliculas y contadorCanciones contendr\u00e1n una cuenta de cuantas instancias MediaItem de cada tipo se han encontrado. Downcasting Una constante o variable de un cierto tipo de clase puede referirse (contener) a una instancia de una subclase. Cuando creemos que sucede esto, podemos intentar hacer un downcast al tipo de la subclase con un operador de cast ( as? o as! ). Como el downcast puede fallar, la versi\u00f3n condicional, as? , devuelve un valor opcional del tipo al que estamos intentando hacer el downcasting . La versi\u00f3n forzosa, as! , intenta el downcast y fuerza la desenvoltura del resultado en un \u00fanica acci\u00f3n compuesta. Debemos usar la versi\u00f3n condicional ( as? ) cuando no estamos seguros si el downcast tendr\u00e1 \u00e9xito. Se devolver\u00e1 un valor opcional y el valor ser\u00e1 nil si no es posible hacer el downcast . Esto permitir\u00e1 comprobar si ha habido un downcast con \u00e9xito. La otra versi\u00f3n ( as! ) se usa s\u00f3lo cuando estamos seguros de que el downcast tendr\u00e1 \u00e9xito. Esta versi\u00f3n del operador lanzar\u00e1 un error en tiempo de ejecuci\u00f3n si intentamos hacer un downcast a un tipo incorrecto. El siguiente ejemplo itera sobre cada MediaIyem en biblioteca , e imprime una descripci\u00f3n apropiada para cada \u00edtem. Para hacerlo, necesita acceder a cada \u00edtem como una Pelicula o Cancion y no s\u00f3lo como una MediaItem . Esto es necesario para poder acceder a la propiedad director o artista de una instancia de Pelicula o Cancion . En este ejemplo, cada \u00edtem en el array podr\u00eda ser un Pelicula o podr\u00eda ser una Cancion . No sabemos por anticipado la clase verdadera de cada \u00edtem, por lo que es apropiado usar la versi\u00f3n condicional ( as? ) para comprobar el downcast cada vez a lo largo del bucle: 1 2 3 4 5 6 7 8 9 10 11 12 13 for item in biblioteca { if let pelicula = item as ? Pelicula { print ( Pel\u00edcula: \\( pelicula . nombre ) , dir. \\( pelicula . director ) ) } else if let cancion = item as ? Cancion { print ( Cancion: \\( cancion . nombre ) , de \\( cancion . artista ) ) } } // Pel\u00edcula: El Se\u00f1or de los Anillos, dir. Peter Jackson // Cancion: Child in Time, de Deep Purple // Pel\u00edcula: El Puente de los Esp\u00edas, dir. Steven Spielberg // Cancion: I Wish You Were Here, de Pink Floyd // Cancion: Yellow, de Coldplay El ejemplo comienza intentando hacer downcast del \u00edtem a una Pelicula . Debido a que es una instancia de MediaItme , es posible que sea un Pelicula o una Cancion , o incluso el tipo base MediaItem . Debido a esta incertidumbre, debemos usar la versi\u00f3n as? para devolver un valor opcional. El resultado ser\u00e1 una \"Pelicula opcional\". Podemos desenvolver el valor Pelicula usando un if let como vimos en el apartado de opcionales. Si tiene \u00e9xito el downcasting , las propiedades de la pel\u00edcula se pueden usar para imprimir una descripci\u00f3n de la pel\u00edcula llamando a los correspondientes m\u00e9todos de la clase Pelicula . Igual con Cancion . Casting para Any El tipo Any puede representar una instancia de cualquier tipo, incluyendo tipos funci\u00f3n: 1 2 3 4 5 6 7 8 9 10 var array = [ Any ]() array . append ( 0 ) array . append ( 0.0 ) array . append ( 42 ) array . append ( 3.14159 ) array . append ( hola ) array . append (( 3.0 , 5.0 )) array . append ( Pelicula ( nombre : Ghostbusters , director : Ivan Reitman )) array . append ({ ( name : String ) - String in Hola, \\( name ) }) El array contiene dos valores Int , dos valores Double , un valor String , una tupla del tipo (Double, Double) , la pel\u00edcula \"Ghostbusters\", y una clausura que toma un String y devuelve otro String . Puedes usar los operadores is y as en una sentencia switch para descubrir en tiempo de ejecuci\u00f3n el tipo espec\u00edfico de una constante o variable de la que s\u00f3lo se sabe que es de tipo Any : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 for item in array { switch item { case 0 as Int : print ( cero como un Int ) case 0 as Double : print ( cero como un Double ) case let someInt as Int : print ( un valor entero de \\( someInt ) ) case let unDouble as Double where unDouble 0 : print ( a valor positivo de \\( unDouble ) ) case is Double : print ( alg\u00fan otro valor double que no quier imprimir ) case let someString as String : print ( una cadena con valor de \\ \\( someString ) \\ ) case let ( x , y ) as ( Double , Double ): print ( un punto (x, y) en \\( x ) , \\( y ) ) case let pelicula as Pelicula : print ( una pel\u00edcula: \\( pelicula . nombre ) , dir. \\( pelicula . director ) ) case let stringConverter as ( String ) - String : print ( stringConverter ( Michael )) default : print ( alguna otra cosa ) } } // cero como un Int // cero como un Double // un valor entero de 42 // a valor positivo de 3.14159 // una cadena con valor de hola // un punto (x, y) en 3.0, 5.0 // una pel\u00edcula: Ghostbusters, dir. Ivan Reitman // Hola, Michael Comprobaci\u00f3n de ajustarse a un protocolo Podemos usar tambi\u00e9n los operadores anteriores is y as (y as? y as! ) para comprobar si una instancia se ajusta a un protocolo y para hacer un cast a un protocolo espec\u00edfico. Veamos un ejemplo. Definimos el protocolo TieneArea con el \u00fanico requisito de una propiedad de lectura llamada area de tipo Double : 1 2 3 protocol TieneArea { var area : Double { get } } Definimos dos clases Circulo y Pais que se ajustan ambos al protocolo: 1 2 3 4 5 6 7 8 9 10 11 class Circulo : TieneArea { let pi = 3.1415927 var radio : Double var area : Double { return pi * radio * radio } init ( radio : Double ) { self . radio = radio } } class Pais : TieneArea { var area : Double init ( area : Double ) { self . area = area } } La clase Circulo implementa el requisito como una propiedad calculada, basada en la propiedad almacenada radio . La clase Pais implementa el requisito directamente como una propiedad almacenada. Ambas clases se ajustan correctamente al protocolo TieneArea . Definimos una clase Animal que no se ajusta al protocolo: 1 2 3 4 class Animal { var patas : Int init ( patas : Int ) { self . patas = patas } } Las clases Circulo , Pais y Animal no tienen ninguna clase base compartida. Sin embargo, todas son clases, por lo que las instancias de los tres tipos pueden usarse para inicializar un array que almacena valores de tipo Any : 1 2 3 4 5 let objetos : [ Any ] = [ Circulo ( radio : 2.0 ), Pais ( area : 243_610 ), Animal ( patas : 4 ) ] Y ahora podemos iterar sobre el array de objetos, comprobando para cada \u00edtem si la instancia se ajusta al protocolo TieneArea : 1 2 3 4 5 6 7 8 9 10 11 for objecto in objetos { if let objetoConArea = objecto as ? TieneArea { print ( El \u00e1rea es \\( objetoConArea . area ) ) } else { print ( Algo que no tiene un \u00e1rea ) } } // El \u00e1rea es 12.5663708 // El \u00e1rea es 243610.0 // Algo que no tiene un \u00e1rea Cuando un objeto en el array se ajusta al protocolo TieneArea , el valor opcional devuelto por el operador as? se desenvuelve con un ligado opcional en una constante llamada objetoConArea . Esta constante tiene el tipo TieneArea , por lo que su propiedad area podr\u00e1 ser accedida e impresa. Hay que notar que los objetos subyacentes no cambian en el proceso de casting . Siguen siendo un Circulo , un Pais y un Animal . Sin embargo, en el momento en se almacenan en la constante objetoConArea , s\u00f3lo se sabe que son del tipo TieneArea , por lo que s\u00f3lo podremos acceder a su propiedad area . Extensiones Las extensiones a\u00f1aden nueva funcionalidad a una clase, estructura, enumeraci\u00f3n o protocolo. Esto incluye la posibilidad de extender tipos para los que no tenemos acceso al c\u00f3digo fuente original (esto se conoce como modelado retroactivo ). Entre otras cosas, las extensiones pueden: A\u00f1adir propiedades calculadas de instancia y de tipo Definir m\u00e9todos de instancia y de tipo Proporcionar nuevos inicializadores Hacer que un tipo existente se ajuste a un protocolo Sintaxis Para declarar una extensi\u00f3n hay que usar la palabra clave extension : 1 2 3 extension UnTipo { // nueva funcionalidad para a\u00f1adir a UnTipo } Propiedades calculadas Las extensiones pueden a\u00f1adir propiedades calculadas de instancias y de tipos. Como primer ejemplo, vamos a a\u00f1adir a la clase persona la propiedad calcula mayorEdad , un Bool que indica si la edad de la persona es mayor o igual de 18: 1 2 3 4 5 extension Persona { var mayorEdad : Bool { return edad = 18 } } Una vez definida esta extensi\u00f3n, hemos ampliado la clase con esta nueva propiedad, sin tocar el c\u00f3digo de la clase. Podemos preguntar si una persona es mayor de edad: 1 2 var p = Persona ( edad : 15 , nombreCompleto : Luc\u00eda ) p . mayorEdad // false Es posible incluso extender clases de las librer\u00edas est\u00e1ndar de Swift, como Int , Double , Array , etc. Por ejemplo, podemos a\u00f1adir propiedades calculadas a la clase Double para trabajar con unidades de distancia. Las siguientes propiedades convierten una cantidad en las unidades correspondientes a su equivalente en metros: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 extension Double { var km : Double { return self * 1_000.0 } var m : Double { return self } var cm : Double { return self / 100.0 } var mm : Double { return self / 1_000.0 } var ft : Double { return self / 3.28084 } } let distancia = 11. km // En distancia tendremos 11000 metros let unaPulgada = 25.4 . mm print ( Una pulgada es \\( unaPulgada ) metros ) // Una pulgada es 0.0254 metros let tresPies = 3. ft print ( Tres pies son \\( tresPies ) metros ) // Tres pies son 0.914399970739201 metros Estas propiedades calculadas expresan que un valor Double deber\u00eda considerarse como una cierta unidad de longitud. Aunque se implementan como propiedades calculadas, los nombres de las propiedades pueden a\u00f1adirse a un literal en punto flotante con la sintaxis del punto, como una forma de usar el valor del literal para ejecutar conversiones de distancia. Por ejemplo, cuando se escribe 11.km se pide el valor de la propiedad calculada km de la instancia 11 . La propiedad calculada devuelve el resultado de multiplicar 11 por 1000 , esto es, los metros correspondientes a 11 kil\u00f3metros. De forma similar, hay 3.28084 pies en un metro, por lo que la propiedad calculada ft divide el valor Double subyacente por 3.28084, para conventirlo de pies a metros. Estas propiedades son propiedades calculadas de solo lectura, por lo que se expresan sin la palabra clave get , por brevedad. Sus valores devueltos son de tipo Double , y pueden usarse en c\u00e1lculos matem\u00e1ticos en cualquier sitio que se acepte un Double : 1 2 3 let unMaraton = 42. km + 195. m print ( Un marat\u00f3n tiene una longitud de \\( unMaraton ) metros ) // Un marat\u00f3n tiene una longitud de 42195.0 metros Inicializadores Las extensiones pueden a\u00f1adir nuevos inicializadores a tipos existentes. Esto nos permite extender otros tipos para aceptar nuestros propios tipos como par\u00e1metros de la inicializaci\u00f3n, o para proporcionar opciones adicionales que no estaban incluidos en la implementaci\u00f3n original del tipo. El siguiente ejemplo define una estructura Rectangulo que representa un rect\u00e1ngulo geom\u00e9trico. Este ejemplo tambi\u00e9n define dos estructuras auxiliares llamadas Tama\u00f1o y Punto , que proporcionan valores por defecto de 0.0 a todas sus propiedades: 1 2 3 4 5 6 7 8 9 10 struct Tama \u00f1 o { var ancho = 0.0 , alto = 0.0 } struct Punto { var x = 0.0 , y = 0.0 } struct Rectangulo { var origen = Punto () var tama \u00f1 o = Tama \u00f1 o () } Debido a que la estructura Rectangulo proporciona valores por defecto para todas sus propiedades, tiene un inicializador por defecto que puede utilizarse para crear nuevas instancias. Tambi\u00e9n podemos inicializarlo asignando todas sus propieades: 1 2 3 let rectanguloPorDefecto = Rectangulo () let rectanguloInicializado = Rectangulo ( origen : Punto ( x : 2.0 , y : 2.0 ), tama \u00f1 o : Tama \u00f1 o ( ancho : 5.0 , alto : 5.0 )) Podemos extender la estructura Rectangulo para proporcionar un inicializador adicional que toma un punto espec\u00edfico del centro y un tama\u00f1o: 1 2 3 4 5 6 7 extension Rectangulo { init ( centro : Punto , tama \u00f1 o : Tama \u00f1 o ) { let origenX = centro . x - ( tama \u00f1 o . ancho / 2 ) let origenY = centro . y - ( tama \u00f1 o . alto / 2 ) self . init ( origen : Punto ( x : origenX , y : origenY ), tama \u00f1 o : tama \u00f1 o ) } } Este nuevo inicializador empieza por calcular un punto de origen basado en el centro propuesto y en el tama\u00f1o. El inicializador llama despu\u00e9s al inicializador autom\u00e1tico de la estructura init(origen:tama\u00f1o:) , que almacena los nuevos valores de las propiedades: 1 2 3 let rectanguloCentro = Rectangulo ( centro : Punto ( x : 4.0 , y : 4.0 ), tama \u00f1 o : Tama \u00f1 o ( ancho : 3.0 , alto : 3.0 )) // el origen del rectanguloCentro es is (2.5, 2.5) y su tama\u00f1o es (3.0, 3.0) M\u00e9todos Las extensiones pueden a\u00f1adir nuevos m\u00e9todos de instancia y nuevos m\u00e9todos del tipo. Por ejemplo, podemos a\u00f1adir el m\u00e9todo descripcion() a la estructura Persona : 1 2 3 4 5 6 7 8 extension Persona { func descripcion () - String { return Me llamo \\( nombreCompleto ) y tengo \\( edad ) a\u00f1os } } let reedRichards = Persona ( edad : 40 , nombreCompleto : Reed Richards ) print ( reedRichards . descripcion ()) Tambi\u00e9n podemos a\u00f1adir m\u00e9todos a clases y estructuras importadas. Por ejemplo podemos a\u00f1adir un nuevo m\u00e9todo de instancia llamado repeticiones al tipo Int : 1 2 3 4 5 6 7 extension Int { func repeticiones ( _ tarea : () - Void ) { for _ in 0. . self { tarea () } } } El m\u00e9todo repeticiones(_:) toma un \u00fanico argumento de tipo () - Void , que indica una funci\u00f3n que no tiene par\u00e1metros y no devuelve ning\u00fan valor. Despu\u00e9s de definir esta extensi\u00f3n, podemos llamar al m\u00e9todo repeticiones(_:) en cualquier n\u00famero entero para ejecutar una tarea un cierto n\u00famero de veces: 1 2 3 4 5 6 3. repeticiones ({ print ( Hola! ) }) // Hola! // Hola! // Hola! Usando clausuras por la cola podemos hacer la llamada m\u00e1s concisa: 1 2 3 4 5 6 3. repeticiones { print ( Adios! ) } // Adios! // Adios! // Adios! M\u00e9todos de instancia mutadores Los m\u00e9todos de instancia a\u00f1adidos con una extensi\u00f3n tambi\u00e9n pueden modificar (o mutar) la propia instancia. Los m\u00e9todos de las estructuras y los enumerados que modifican self o sus propiedades deben marcarse como mutating . Por ejemplo: 1 2 3 4 5 6 7 8 extension Int { mutating func cuadrado () { self = self * self } } var unInt = 3 unInt . cuadrado () // unInt es ahora 9 Ajustar un tipo a un protocolo mediante una extensi\u00f3n Una extensi\u00f3n puede extender un tipo existente para hacer que se ajuste a uno o m\u00e1s protocolos. En este caso, los nombres de los protocolos se escriben exactamente de la misma forma que en una clase o estructura: 1 2 3 extension UnTipo : UnProtocolo , OtroProtocolo { // implementaci\u00f3n de los requisitos del protocolo } Las instancias del tipo adoptar\u00e1n autom\u00e1ticamente el protocolo y se ajustar\u00e1n al protocolo con las propiedades y m\u00e9todos a\u00f1adidos por la extensi\u00f3n. Por ejemplo, este protocolo, llamado RepresentableComoTexto puede ser implementado por cualquier tipo que tenga una forma de representarse como texto. Esto puede ser una descripci\u00f3n de si mismo o una versi\u00f3n de texto de su estado actual: 1 2 3 protocol RepresentableComoTexto { var descripcionTextual : String { get } } La clase Dado que vimos anteriormente puede extenderse para ajustarse al protocolo: 1 2 3 4 5 extension Dado : RepresentableComoTexto { var descripcionTextual : String { return Un dado de \\( caras ) caras } } Esta extensi\u00f3n adopta el nuevo protocolo exactamente como si el Dado lo hubiera proporcionado en su implementaci\u00f3n original. El nombre del protocolo se indica tras el nombre del tipo, separado por dos puntos, y se proporciona una implementaci\u00f3n entre llaves. Cualquier instancia de un dado se puede tratar ahora como RepresentableComoTexto : 1 2 3 let d12 = Dado ( caras : 12 , generador : GeneradorLinealCongruente ()) print ( d12 . descripcionTextual ) // Un dado de 12 caras De forma similar, un Rectangulo tambi\u00e9n puede extenderse para adoptar y ajustarse al protocolo: 1 2 3 4 5 6 7 8 9 10 extension Rectangulo : RepresentableComoTexto { var descripcionTextual : String { return Un rect\u00e1ngulo situado en ( \\( origen . x ) , \\( origen . y ) ) } } let rectanguloInicializado = Rectangulo ( origen : Punto ( x : 2.0 , y : 2.0 ), tama \u00f1 o : Tama \u00f1 o ( ancho : 5.0 , alto : 5.0 )) print ( rectanguloInicializado . descripcionTextual ) // Un rect\u00e1ngulo situado en (2.0, 2.0) Declaraci\u00f3n de la adopci\u00f3n de un protocolo con una extensi\u00f3n Si un tipo ya se ajusta a todos los requisitos de un protocolo, pero todav\u00eda no se ha declarado que se ajusta al protocolo, podemos hacer que lo adopte con una extensi\u00f3n vac\u00eda: 1 2 3 4 5 6 7 struct Hamster { var nombre : String var descripcionTextual : String { return Un hamster llamado \\( nombre ) } } extension Hamster : RepresentableComoTexto {} Las instancias de Hamster pueden ahora usarse en cualquier sitio que se requiera un tipo RepresentableComoTexto : 1 2 3 4 let simonElHamster = Hamster ( nombre : Simon ) let algoRepresentableComoTexto : RepresentableComoTexto = simonElHamster print ( algoRepresentableComoTexto . descripcionTextual ) // Un hamster llamado Simon Implementaci\u00f3n de m\u00e9todos de un protocolo Podemos definir extensiones en los protocolos para proporcionar implementaciones de m\u00e9todos y propiedades a todos los tipos que se ajustan a \u00e9l. Esto permite definir conductas en los propios protocolos, m\u00e1s que en cada tipo individual o en una funci\u00f3n global. Por ejemplo, el protocolo GeneradorNumerosAleatorios puede ser extendido para proporcionar un m\u00e9todo boolAleatorio() , que usa el resultado del random() requerido para devolver un valor Bool aleatorio: 1 2 3 4 5 extension GeneradorNumerosAleatorios { func randomBool () - Bool { return random () 0.5 } } Al crear una extensi\u00f3n en el protocolo, todos los tipos que se ajustan a \u00e9l adquieren autom\u00e1ticamente esta implementaci\u00f3n sin ninguna modificaci\u00f3n adicional. 1 2 3 4 5 let generator = GeneradorLinealCongruente() print( Un n\u00famero aleatorio: \\(generator.random()) ) // Imprime Un n\u00famero aleatorio: 0.37464991998171 print( Y un booleano aleatorio: \\(generator.randomBool()) ) // Imprime Un booleano aleatorio: true El tipo que se ajusta al protocolo puede proporcionar su propia implementaci\u00f3n, que se usar\u00e1 en lugar de la proporcionada por la extensi\u00f3n. Restricci\u00f3n en las extensiones de un protocolo En la definici\u00f3n de una extensi\u00f3n de un protocolo es posible definir restricciones que deben cumplir los tipos que lo cumplen. Los m\u00e9todos y propiedades de la extensi\u00f3n s\u00f3lo estar\u00e1n disponibles en aquellos tipos que cumplan estos requisitos. Los requisitos se definen usando una cl\u00e1usula gen\u00e9rica where . Por ejemplo, podemos definir una extensi\u00f3n al protocolo Collection que se aplique a cualquier colecci\u00f3n cuyos elementos cumplen el protocolo Equatable . De esta forma nos aseguramos de que los operadores == y != est\u00e1n definidos y podemos usarlos en la extensi\u00f3n: 1 2 3 4 5 6 7 8 9 10 extension Collection where Element : Equatable { func allEqual () - Bool { for element in self { if element != self . first { return false } } return true } } El m\u00e9todo allEqual() devuelve true si y s\u00f3lo si todos los elementos en la colecci\u00f3n son iguales. Un ejemplo: 1 2 let numerosIguales = [ 100 , 100 , 100 , 100 , 100 ] let numerosDiferentes = [ 100 , 100 , 200 , 100 , 200 ] Dado que ambos arrays cumplen el protocolo Collection y los enteros cumplen el protocolo Equatable podemos usar el m\u00e9todo allEqual() : 1 2 3 4 print(numerosIguales.allEqual()) // Prints true print(numerosDiferentes.allEqual()) // Prints false En una colecci\u00f3n de una clase que no cumple el protocolo Equatable no se puede utilizar el m\u00e9todo de la extensi\u00f3n: 1 2 3 4 let tormenta = Persona ( edad : 32 , nombreCompleto : Ororo Munroe ) let superHeroes = [ tormenta , peterParker , reedRichards ] print ( superHeroes . allEqual ()) //error: type Persona does not conform to protocol Equatable Funciones operadoras Las clases y las estructuras pueden proporcionar sus propias implementaciones de operadores existentes. Esto se conoce como sobrecarga de los operadores existentes. En el siguiente ejemplo se muestra c\u00f3mo implementar el operador de suma ( + ) para una estructura. El operador suma es un operador binario (tiene dos operandos) e infijo (aparece junto entre los dos operandos). Definimos una estructura Vector2D para un vector de posici\u00f3n de dos dimensiones: 1 2 3 4 5 6 struct Vector2D { var x = 0.0 , y = 0.0 static func + ( izquierdo : Vector2D , derecho : Vector2D ) - Vector2D { return Vector2D ( x : izquierdo . x + derecho . x , y : izquierdo . y + derecho . y ) } } La funci\u00f3n operador se define como una funci\u00f3n est\u00e1tica con un un nombre de funci\u00f3n que empareja con el operador a sobrecargar ( + ). Debido a que la suma aritm\u00e9tica se define como un operador binario, esta funci\u00f3n operador toma dos par\u00e1metros de entrada de tipo Vector2D y devuelve un \u00fanico valor de salida, tambi\u00e9n de tipo Vector2D . En esta implementaci\u00f3n, llamamos a los par\u00e1metros de entrada izquierdo y derecho para representar las instancias de Vector2D que estar\u00e1n a la izquierda y a la derecha del operador + . La funci\u00f3n devuelve una nueva instancia de Vector2D , cuyas propiedades x e y se inicializan con la suma de las propiedades x e y de las instancias de Vector2D que se est\u00e1n sumando. La funci\u00f3n se define globalmente, m\u00e1s que como un m\u00e9todo en la estructura Vector2D , para que pueda usarse como un operador infijo entre instancias existentes de Vector2D : 1 2 3 4 let vector = Vector2D ( x : 3.0 , y : 1.0 ) let otroVector = Vector2D ( x : 2.0 , y : 4.0 ) let vectorSuma = vector + otroVector // vectorSuma es una instancia de Vector2D con valores de (5.0, 5.0) Operadores prefijos y postfijos El ejemplo anterior demuestra una implementaci\u00f3n propia de un operador binario infijo. Las clases y las estructuras pueden tambi\u00e9n proporcionar implementaciones de los operadores unarios est\u00e1ndar. Los operadores unarios operan sobre un \u00fanico objetivo. Son prefijos se preceden el objetivo (como -a ) y postfijos si siguen su objetivo (como en b! ). Para implementar un operador unario prefijo o postfijo se debe escribir el modificador prefix o postfix antes de la palabra clave func en la declaraci\u00f3n de la funci\u00f3n operador: 1 2 3 4 5 6 struct Vector2D { ... static prefix func - ( vector : Vector2D ) - Vector2D { return Vector2D ( x : - vector . x , y : - vector . y ) } } El ejemplo anterior implementa el operador unario negaci\u00f3n ( -a ) para instancias de Vector2D . Por ejemplo: 1 2 3 4 5 let positivo = Vector2D ( x : 3.0 , y : 4.0 ) let negativo = - positivo // negativo es una instancia de Vector2D con valores de (-3.0, -4.0) let tambienPositivo = - negativo // tambienPositivo es una instancia de Vector2D con valores de (3.0, 4.0) Operadores de equivalencia Como ya hemos visto, las clases y estructuras construidas no tienen una implementaci\u00f3n por defecto de los operadores \"igual a\" ( == ) y \"no igual a\" ( != ). No es posible para Swift adivinar qu\u00e9 valores ser\u00e1n \"iguales\" en nuestras clases, porque el significado de \"igual\" depende del papel que esos tipos juegan en nuestro c\u00f3digo. Para poder usar los operadores de igualdad en nuestros propios tipos, debemos proporcionar una implementaci\u00f3n de la misma forma que para otros operadores infijos. Lo hacemos definiendo una extensi\u00f3n que cumple el protocolo Equatable . De esta forma, como ya hemos visto anteriormente, conseguimos la implementaci\u00f3n por defecto del operador != : 1 2 3 4 5 extension Vector2D : Equatable { static func == ( izquierdo : Vector2D , derecho : Vector2D ) - Bool { return ( izquierdo . x == derecho . x ) ( izquierdo . y == derecho . y ) } } En el ejemplo anterior se implementa un operador \"igual a\" ( == ) que comprueba si dos instancias de Vector2D tienen valores equivalentes. En el contexto del Vector2D tiene sentido considerar \"igual\" como \"ambas instancias tienen los mismos valores x e y\", por lo que esta es la l\u00f3gica usada por la implementaci\u00f3n. La implementaci\u00f3n por defecto del operador \"no igual a\" ( != ), simplemente devuelve el inversa del resultado del operador \"igual a\". Ahora podemos usar estos operadores para chequear si dos instancias de Vector2D son equivalentes: 1 2 3 4 5 6 7 8 9 let dosTres = Vector2D ( x : 2.0 , y : 3.0 ) let otroDosTres = Vector2D ( x : 2.0 , y : 3.0 ) let unoDos = Vector2D ( x : 1.0 , y : 2.0 ) if dosTres == otroDosTres { print ( Los vectores \\( dosTres ) y \\( otroDosTres ) son equivalentes. ) } if ( unoDos != dosTres ) { print ( Los vectores \\( unoDos ) y \\( dosTres ) son distintos. ) } Gen\u00e9ricos Veamos c\u00f3mo podemos utilizar los gen\u00e9ricos con clases y estructuras. Vamos a utilizar como ejemplo un tipo de dato muy sencillo: una pila ( stack ) en la que se podr\u00e1n a\u00f1adir ( push ) y retirar ( pop ) elementos. La versi\u00f3n no gen\u00e9rica del tipo de dato es la siguiente, en la que se implementa una pila de enteros. 1 2 3 4 5 6 7 8 9 struct IntStack { var items = [ Int ]() mutating func push ( _ item : Int ) { items . append ( item ) } mutating func pop () - Int { return items . removeLast () } } La estructura usa un array para guardar los \u00edtems y los m\u00e9todos push y pop a\u00f1aden y retiran los elementos. El problema de esta estructura es su falta de genericidad; s\u00f3lo puede almacenar enteros. Aqu\u00ed est\u00e1 una versi\u00f3n gen\u00e9rica del mismo c\u00f3digo: 1 2 3 4 5 6 7 8 9 struct Stack Element { var items = [ Element ]() mutating func push ( _ item : Element ) { items . append ( item ) } mutating func pop () - Element { return items . removeLast () } } El par\u00e1metro del tipo Element define un tipo gen\u00e9rico que se utiliza como placeholder del tipo real del que se declare la estructura. Podemos ver que se utiliza en la definici\u00f3n de los distintos elementos de la estructura. Por ejemplo, el array de \u00edtems es un array de Element s. Y los \u00edtems a\u00f1adidos y retirados de la pila son tambi\u00e9n objetos de tipo Element . Por ejemplo, podemos crear una pila de cadenas: 1 2 3 4 5 6 var stackOfStrings = Stack String () stackOfStrings . push ( uno ) stackOfStrings . push ( dos ) stackOfStrings . push ( tres ) stackOfStrings . push ( cuatro ) // la pila contiene ahora 4 cadenas Y podemos retirar la \u00faltima cadena de la pila: 1 let fromTheTop = stackOfStrings . pop () Extensi\u00f3n de un tipo gen\u00e9rico Cuando se extiende un tipo gen\u00e9rico, no hace falta a\u00f1adir el par\u00e1metro del tipo entre . El tipo gen\u00e9rico est\u00e1 disponible a partir de la definici\u00f3n original y se puede usar tal cual en el cuerpo de la extensi\u00f3n. Por ejemplo, podemos extender el tipo gen\u00e9rico Stack para a\u00f1adir una propiedad computable de s\u00f3lo lectura que devuelva el tope de la pila: 1 2 3 4 5 extension Stack { var topItem : Element ? { return items . isEmpty ? nil : items [ items . count - 1 ] } } En la extensi\u00f3n se utiliza el nombre gen\u00e9rico Element sin tener que declararlo despu\u00e9s de Stack , porque est\u00e1 definido en la estructura original. Ahora ya se puede acceder al tope de la pila sin retirar el elemento: 1 2 3 4 if let topItem = stackOfStrings . topItem { print ( El \u00edtem en el tope de la pila es \\( topItem ) . ) } // Imprime El \u00edtem en el tope de la pila es tres. Bibliograf\u00eda Swift Language Guide Classes and Structures Properties Methods Inheritance Initialization Protocolos Casting de tipos Extensiones Funciones operador Gen\u00e9ricos Lenguajes y Paradigmas de Programaci\u00f3n, curso 2018\u201319 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Domingo Gallardo, Cristina Pomares, Antonio Bot\u00eda, Francisco Mart\u00ednez","title":"Tema06 programacion orientada objetos swift"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#tema-6-programacion-orientada-a-objetos-con-swift","text":"","title":"Tema 6: Programaci\u00f3n Orientada a Objetos con Swift"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#introduccion-historia-y-caracteristicas-de-la-programacion-orientada-a-objetos","text":"","title":"Introducci\u00f3n, historia y caracter\u00edsticas de la Programaci\u00f3n Orientada a Objetos"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#nacimiento","text":"La Programaci\u00f3n Orientada a Objetos es un paradigma de programaci\u00f3n que explota en los 80 pero nace a partir de ideas a finales de los 60 y 70 Primer lenguaje con las ideas fundamentales de POO: Simula Smalltalk (1980) como lenguaje paradigm\u00e1tica de POO Alan Kay es el creador del t\u00e9rmino \u201cObject-Oriented\u201d y una de las figuras fundamentales de la historia de la inform\u00e1tica moderna. Trabaj\u00f3 en Xerox Park y desarroll\u00f3 all\u00ed ideas que han sido clave para la inform\u00e1tica personal (como el Dynabook, precursor de tablets y dispositivos m\u00f3viles y el lenguajes de programaci\u00f3n Smalltalk) Art\u00edculo de Alan Kay: \u201cThe Early History of Smalltalk\u201d , ACM SIGPLAN, March 1993","title":"Nacimiento"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#alan-kay","text":"\u201cI invented the term Object-Oriented and I can tell you I did not have C++ in mind.\u201d \u201cSmalltalk is not only NOT its syntax or the class library, it is not even about classes. I'm sorry that I long ago coined the term objects for this topic because it gets many people to focus on the lesser idea. The big idea is messaging.\u201d \u201cSmalltalk's design\u2013and existence\u2013is due to the insight that everything we can describe can be represented by the recursive composition of a single kind of behavioral building block that hides its combination of state and process inside itself and can be dealt with only through the exchange of messages.\u201d","title":"Alan Kay"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#interesados-en-smalltalk","text":"Visitar: http://www.squeak.org/ http://swiki.agro.uba.ar/small_land http://www.squeakland.org","title":"\u00bfInteresados en Smalltalk?"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#lenguajes-oo","text":"Smalltalk, Java, Scala, Ruby, Python, C#, C++, Swift, ...","title":"Lenguajes OO"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#del-paradigma-imperativo-al-oo","text":"Programaci\u00f3n procedural: estado abstracto (tipos de datos y barrera de abstracci\u00f3n) + funciones Siguiente paso: agrupar estado y funciones en una \u00fanica entidad Los objetos son estas entidades","title":"Del paradigma imperativo al OO"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#caracteristicas-de-la-poo","text":"Objetos (creados/instanciados en tiempo de ejecuci\u00f3n) y clases (plantillas est\u00e1ticas/tiempo de compilaci\u00f3n) Los objetos agrupan estado y conducta (m\u00e9todos) Los m\u00e9todos se invocan mediante mensajes Dispatch din\u00e1mico : cuando una operaci\u00f3n es invocada sobre un objeto, el propio objeto determina qu\u00e9 c\u00f3digo se ejecuta. Dos objetos con la misma interfaz pueden tener implementaciones distintas. Herencia: las clases se pueden definir utilizando otras clases como plantillas y modificando sus m\u00e9todos y/o variables de instancia.","title":"Caracter\u00edsticas de la POO"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#clases-y-objetos","text":"Objeto: Un objeto contiene un estado (propiedades, atributos o variables de instancia) y un conjunto de funciones (m\u00e9todos) que se ejecutan en el \u00e1mbito del objeto e implementan las funcionalidades soportadas Al ejecutar un m\u00e9todo, el objeto modifica su estado Pedimos a un objeto que ejecute un m\u00e9todo Clase: Una clase es la plantilla que sirve para definir los objetos En una clase se define los elementos que componen el objeto (sus atributos o campos) y sus m\u00e9todos En algunos lenguajes se pueden definir tambi\u00e9n en las clases variables (variables de clase) compartidas por todos los objetos de esa clase","title":"Clases y objetos"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#lenguajes-poo-dinamicos-vs-estaticos","text":"Dos tendencias: Lenguajes din\u00e1micos : muchas caracter\u00edsticas del programa se obtienen en tiempo de ejecuci\u00f3n Mayor flexibilidad y generalidad del c\u00f3digo Dispatch din\u00e1mico Reflexi\u00f3n (posibilidad de consultar caracter\u00edsticas de la instancia (nombres de m\u00e9todos, propiedades, etc.) en tiempo de ejecuci\u00f3n) Ejemplos: Smalltalk, Ruby, Python, JavaScript, Java (en menor medida) Lenguajes est\u00e1ticos : la mayor\u00eda de caracter\u00edsticas del programa se obtienen en tiempo de compilaci\u00f3n Mayor eficiencia Se conoce a priori el tipo de la mayor parte de instancias del programa Fuertemente tipeado Ejemplos: C++, Swift Vamos a detallar a continuaci\u00f3n las caracter\u00edsticas de Programaci\u00f3n Orientada a Objetos de Swift . Para tener una introducci\u00f3n r\u00e1pida puedes empezar leyendo los \u00faltimos apartados del seminario de Swift (los apartados Objetos, clases y estructuras , Protocolos y extensiones y Gen\u00e9ricos ).","title":"Lenguajes POO din\u00e1micos vs. est\u00e1ticos"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#clases-y-estructuras","text":"En el caso de Swift, las clases y las estructuras son muchas m\u00e1s cercanas en funcionalidad que en otros lenguajes, como C o C++, y tienen muchas caracter\u00edsticas comunes. Muchas caracter\u00edsticas de las instancias de una clase se pueden aplicar tambi\u00e9n a las instancias de una estructura. Por eso en Swift se suele hablar de instancias (un t\u00e9rmino m\u00e1s general) en lugar de objetos . Las clases y las estructuras en Swift tienen muchas cosas en com\u00fan. Ambos pueden: Definir propiedades y almacenar valores Definir m\u00e9todos para proporcionar funcionalidad Definir sub\u00edndices para proporcionar acceso a sus valores usando una sintaxis de sub\u00edndice Definir inicializadores para configurar el estado inicial Ser extendidas para expandir su funcionalidad m\u00e1s all\u00e1 de una implementaci\u00f3n por defecto Ajustarse a un protocolo Las clases tienen caracter\u00edsticas adicionales que no tienen las estructuras: Mediante la herencia una clase puede heredar las caracter\u00edsticas de otra El casting de tipos permite comprobar e interpretar el tipo de una instancia de una clase en tiempo de ejecuci\u00f3n Los deinicializadores permiten a una instancia de una clase liberar los recursos que ha asignado Mediante el conteo de referencias se permite que exista m\u00e1s de una referencia a una instancia de una clase","title":"Clases y estructuras"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#definicion","text":"1 2 3 4 5 6 class UnaClase { // definici\u00f3n de clase } struct UnaEstructura { // definici\u00f3n de una estructura } 1 2 3 4 5 6 7 8 9 10 11 12 struct CoordsPantalla { var posX = 0 var posY = 0 } class Ventana { var esquina = CoordsPantalla () var altura = 0 var anchura = 0 var visible = true var etiqueta : String ? } El ejemplo define una nueva estructura llamada CoordsPantalla , que describe una coordenada de pantalla con posiciones basadas en p\u00edxeles. La estructura tiene dos propiedades almacenadas llamadas posX y posY . Las propiedades son constantes o variables que se almacenan en la instancia de la clase o de la estructura. El compilador infiere que estas dos propiedades son Int al inicializarlas a los valores iniciales de 0. El ejemplo tambi\u00e9n define una nueva clase llamada Ventana que describe una ventana en una pantalla. Esta clase tiene cinco propiedades variables. La primera, esquina , se inicializa con una instancia nueva de una estructura CoorsPantalla y se infiere que es de tipo CoordsPantalla . Representa la posici\u00f3n superior izquierda de la pantalla. Las propiedades altura y anchura representan el n\u00famero de p\u00edxeles de las dimensiones de la pantalla. Se inicializan a 0. La propiedad visible es un Bool que indica si la ventana es visible en pantalla. Por ejemplo, una ventana que est\u00e9 minimizada no ser\u00e1 visible. Por \u00faltimo, etiqueta representa el nombre que aparece en la parte superior de la ventana. Es un String opcional que se inicializa a nil porque no se le asigna un valor inicial.","title":"Definici\u00f3n"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#instancias-de-clases-y-estructuras","text":"La definici\u00f3n de las estructuras y las clases \u00fanicamente definen sus aspectos generales. Para describir una configuraci\u00f3n espec\u00edfica (una resoluci\u00f3n o un modo de v\u00eddeo concreto) es necesario crear una instancia de una estructura o una clase. La sintaxis para crear ambas es similar: 1 2 let unasCoordsPantalla = CoordsPantalla () let unaVentana = Ventana () La forma m\u00e1s sencilla de inicializaci\u00f3n es la anterior. Se utiliza el nombre del tipo de la clase o estructura seguidos de par\u00e9ntesis vac\u00edos. Esto crea una nueva instancia de una clase o estructura, con sus propiedades inicializadas a sus valores por defectos. M\u00e1s adelante comentaremos otras formas m\u00e1s elaboradas de inicializaci\u00f3n. Todas las propiedades de una instancia deben estar definidas despu\u00e9s de haberse inicializado, a no ser que la propiedad se un opcional.","title":"Instancias de clases y estructuras"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#acceso-a-propiedades","text":"Se puede acceder y modificar las propiedades usando la sintaxis de punto : 1 2 3 4 5 6 7 print ( La posici\u00f3n x de unasCoordsPantalla es \\( unasCoordsPantalla . posX ) ) // Imprime La posici\u00f3n x de unasCoordsPantalla es 0 print ( La posici\u00f3n y de la esquina de la venana es \\( unaVentana . esquina . posY ) ) // Imprime La posici\u00f3n y de la esquina de la venana es 0 ) unaVentana . esquina . posY = 900 print ( La posici\u00f3n y de la esquina de la venana es ahora \\( unaVentana . esquina . posY ) ) // Imprime La posici\u00f3n y de la esquina de la venana es ahora 900 )","title":"Acceso a propiedades"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#inicializacion-de-las-estructuras-por-sus-propiedades","text":"Podemos inicializar las estructuras el inicializador por defecto , en el que damos valor a todas sus propiedades. En las clases no se puede usar esta inicializaci\u00f3n por defecto. 1 let coords = CoordsPantalla ( posX : 200 , posY : 400 )","title":"Inicializaci\u00f3n de las estructuras por sus propiedades"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#estructuras-y-enumeraciones-son-tipos-valor","text":"Un tipo valor es un tipo cuyo valor se copia cuando se asigna a una variable o constante, o cuando se pasa a una funci\u00f3n. Todos los tipos b\u00e1sicos de Swift -enteros, n\u00fameros en punto flotante, cadenas, arrays y diccionarios- son tipos valor y se implementan como estructuras. Las estructuras y las enumeraciones son tipos valor en Swift. 1 2 3 4 5 6 7 let coords1 = CoordsPantalla ( posX : 600 , posY : 600 ) var coords2 = coords1 coords2 . posX = 1000 print ( coords2 tiene ahora como posici\u00f3n x: \\( coords2 . posX ) ) // imprime: coords2 tiene ahora como posici\u00f3n x: 1000 print ( coords1 tiene todav\u00eda la posici\u00f3n x: \\( coords1 . posX ) ) // imprime: coords1 tiene todav\u00eda la posici\u00f3n x: 600 En el ejemplo se declara una constante llamada coords1 y se asigna a una instancia de CoordsPantalla inicializada con la posici\u00f3n x de 600 y la posici\u00f3n y de 600. Despu\u00e9s se declara una variable llamada coords2 y se asigna al valor actual de coors1 . Debido a que CoordsPantalla es una estructura, se crea una copia de la instancia existente y esta nueva copia se asigna a coords2 . Aunque ahora coords2 y coords1 tienen las mismas posX y posY , son dos instancias completamente distintas. Despu\u00e9s, la propiedad posX de coords2 se actualiza a 1000. Podemos comprobar que la propiedad se modifica, pero que el valor de posX en coords1 sigue siendo el mismo.","title":"Estructuras y enumeraciones son tipos valor"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#las-clases-son-tipos-referencia","text":"A diferencia de los tipos valor, los tipos de referencias no se copian cuando se asignan o se pasan a funciones. En su lugar se usa una referencia a la misma instancia existente. Veamos un ejemplo: 1 2 3 4 5 6 7 8 9 let ventana1 = Ventana () ventana1 . esquina = coords1 ventana1 . altura = 800 ventana1 . anchura = 800 ventana1 . etiqueta = Finder let ventana2 = ventana1 ventana2 . anchura = 1000 print ( La propiedad anchura de ventana1 es ahora \\( ventana1 . anchura ) ) // imprime La propiedad anchura de ventana1 es ahora 1000 Declaramos una constante llamada ventana1 inicializada con una instancia nueva de la clase Ventana . Le asignamos a la propiedad esquina una copia de la resoluci\u00f3n anterior coords1 . Despu\u00e9s declaramos la altura, anchura y etiqueta de la ventana. Despu\u00e9s, ventana1 se asigna a una nueva constante llamada ventan2 , y la anchura se modifica. Debido a que son tipos de referencia, ventana1 y ventana2 se refieren a la misma instancia de Ventana . Son s\u00f3lo dos nombres distintos para la misma \u00fanica instancia. Hay que hacer notar que ventana1 y ventana2 se declaran con let como constantes. Sin embargo, podemos modificar sus propiedades debido a que no se ha reasignado su instancia a la que se refieren\". Esas variables no \"almacenan\" instancias de Ventana , sino que se \"refieren\" a una instancia de la clase. Es la propiedad anchura de la instancia subyacente la que se cambia, no los valores de las referencias constantes a la instancia de Ventana . A diferencia de las clases, una instancia de un struct definida con un let define como constantes todas sus propiedades. Por ejemplo, el siguiente c\u00f3digo generar\u00eda un error: 1 2 3 let coords3 = CoordsPantalla ( posX : 400 , posY : 400 ) coords3 . posX = 800 // error: cannot assign to property: coords3 is a let constant","title":"Las clases son tipos referencia"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#operadores-de-identidad","text":"A veces puede ser \u00fatil descubrir si dos constantes o variables se refieren exactamente a la misma instancia de una clase. Para permitir esto, Swift proporciona dos operadores de identidad: Id\u00e9ntico a ( === ) No id\u00e9ntico a ( !== ) 1 2 3 4 if ventana1 === ventana2 { print ( ventana1 y ventana2 se refierena a la misma instancia de ventana. ) } // Imprime ventana1 y ventana2 se refierena a la misma instancia de ventana. Estos operadores \"id\u00e9ntico a\" no son los mismos que los de \"igual a\" (representado por dos signos iguales == ): \"Id\u00e9ntico a\" significa que dos constantes o variables de una clase se refieren exactamente a la misma instancia de la clase. \"Igual a\" significa que dos instancias se consideran \"iguales\" o \"equivalentes\" en su valor. Es responsabilidad del dise\u00f1ador de la clase definir la implementaci\u00f3n de estos operadores. Si tienes experiencia con C, C++, o Objective-C, puedes saber que estos lenguajes usan punteros para referirse a una direcci\u00f3n de memoria. Una constante o variable en Swift que se refiere a una instancia de un tipo referencia es similar a un puntero en C, pero no es un puntero que apunta a una direcci\u00f3n de memoria y no requiere que se escriba un asterisco (*) para indicar que estas creando una referencia. En su lugar, estas referencias se definen como cualquier otra constante o variable en Swift.","title":"Operadores de identidad"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#criterios-para-usar-estructuras-y-clases","text":"Podemos usar tanto clases como estructuras para definir nuestros tipos de datos y utilizarlos como bloques de construcci\u00f3n del c\u00f3digo de nuestros programas. Sin embargo, se utilizan para distintos tipos de tareas. Como regla general, utilizaremos una estructura cuando se cumplen una o m\u00e1s de las siguientes condiciones: El principal objetivo de la estructura es encapsular unos pocos datos relativamente sencillos. Es razonable esperar que los valores encapsulados ser\u00e1n copiados, m\u00e1s que referenciados, cuando asignamos o pasamos una instancia de esa estructura. Todas las propiedades almacenadas en la estructura son a su vez tipos valor, que tambi\u00e9n se espera que sean copiados m\u00e1s que referenciados. La estructura no necesita heredar propiedades o conducta de otro tipo existente. Ejemplos de buenos candidatos de estructuras incluyen: El tama\u00f1o de una forma geom\u00e9trica, encapsulando por ejemplo las propiedades ancho y alto de tipo Double . Una forma de referirse a rangos dentro de una serie, encapsulando por ejemplo, una propiedad comienzo y otra longitud , ambos del tipo Int . Un punto en un sistema de coordenadas 3D, encapsulando quiz\u00e1s las propiedades x , y y z , todos ellos de tipo Double . En el resto de casos, definiremos una clase y crearemos instancias de esa clase que tendr\u00e1n que ser gestionadas y pasadas por referencia. En la pr\u00e1ctica, esto representa que la mayor\u00eda de datos que construiremos en nuestros programas deber\u00edan clases, no estructuras. Aunque usaremos muchas de las estructuras est\u00e1ndar de Swift.","title":"Criterios para usar estructuras y clases"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#propiedades","text":"Las propiedades asocian valores con una clase, estructura o enumeraci\u00f3n particular. Las propiedades almacenadas ( stored properties ) almacenan valores constantes y variables como parte de una instancia, mientras que las propiedades calculadas ( computed properties ) calculan (en lugar de almacenar) un valor. Las propiedades calculadas se definen en clases, estructuras y enumeraciones. Las propiedades almacenadas se definen s\u00f3lo en clases y estructuras. Enumeraciones: pueden contener s\u00f3lo propiedades calculadas. Clases y estructuras: pueden contener propiedades almacenadas y calculadas. Las propiedades calculadas y almacenadas se asocian habitualmente con instancias de un tipo particular. Sin embargo, las propiedades tambi\u00e9n pueden asociarse con el propio tipo. Estas propiedades se conocen como propiedades del tipo ( type properties ). Adem\u00e1s, en Swift es posible definir observadores de propiedades que monitoricen cambios en los valores de una propiedad, a los que podemos responder con acciones programadas. Los observadores de propiedades pueden a\u00f1adirse tanto a propiedades almacenadas definidas por nosotros como a propiedades heredadas de la superclase.","title":"Propiedades"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#propiedades-almacenadas","text":"En su forma m\u00e1s simple, una propiedad almacenada es una constante o variable que est\u00e1 almacenada como parte de una instancia de una clase o estructura particular. Las propiedades almacenadas pueden ser o bien variables (usando la palabra clave var ) o bien constantes (usando la palabra clave let ). Podemos proporcionar un valor por defecto para la inicializaci\u00f3n de las propiedades almacenadas, tanto variables como constantes. El siguiente ejemplo define una estructura llamada RangoLongitudFija que describe un rango de valores enteros cuya longitud no puede ser modificada una vez que se crea: 1 2 3 4 5 6 7 8 struct RangoLongitudFija { var primerValor : Int let longitud : Int } var rangoDeTresItemss = RangoLongitudFija ( primerValor : 0 , longitud : 3 ) // el rango representa ahora valores enteros the range represents integer values 0, 1, and 2 rangoDeTresItemss . primerValor = 6 // el rango representa ahora valores enteros 6, 7 y 8 Las instancias de RangoLongitudFija tienen una propiedad almacenada variable llamada primerValor y una propiedad almacenada constante llamada longitud . En el ejemplo, longitud se inicializa cuando se crea el nuevo rango y no puede ser cambiada en el futuro, por ser una propiedad constante. Si creamos una instancia de una estructura y la asignamos a una constante, no podremos modificar las propiedades de la instancia, incluso si han sido declaradas como propiedades variables: 1 2 3 4 let rangoDeCuatroItems = RangoLongitudFija ( primerValor : 0 , longitud : 4 ) // este rango representa valores enteros 0, 1, 2 y 3 rangoDeCuatroItems . primerValor = 6 // esto producir\u00e1 un error, incluso aun siendo primerValor una propiedad variable Debido a que rangoDeCuatroItems se ha declarado como constante (con la palabra clave let ), no es posible cambiar su propiedad primerValor , incluso aunque sea una propiedad variable. Esta conducta se debe a que las estructuras son tipos valor . Cuando una instancia de un tipo valor se marca como constante, tambi\u00e9n lo son todas sus propiedades. Esto no sucede as\u00ed con las clases, que son tipos referencia . Si asignamos una instancia de un tipo referencia a una constante, puedes seguir cambiando las propiedades variables de esa instancia.","title":"Propiedades almacenadas"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#propiedades-calculadas","text":"Adem\u00e1s de las propiedades almacenadas, las clases, estructuras y enumeraciones pueden definir propiedades calculadas , que no almacenan realmente un valor. En su lugar, proporcionan un getter y un opcional setter que devuelven y modifican otras propiedades y valores de forma indirecta. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 struct Punto { var x = 0.0 , y = 0.0 } struct Tama \u00f1 o { var ancho = 0.0 , alto = 0.0 } struct Rectangulo { var origen = Punto () var tama \u00f1 o = Tama \u00f1 o () var centro : Punto { get { let centroX = origen . x + ( tama \u00f1 o . ancho / 2 ) let centroY = origen . y + ( tama \u00f1 o . alto / 2 ) return Punto ( x : centroX , y : centroY ) } set ( centroNuevo ) { origen . x = centroNuevo . x - ( tama \u00f1 o . ancho / 2 ) origen . y = centroNuevo . y - ( tama \u00f1 o . alto / 2 ) } } } var cuadrado = Rectangulo ( origen : Punto ( x : 0.0 , y : 0.0 ), tama \u00f1 o : Tama \u00f1 o ( ancho : 10.0 , alto : 10.0 )) let centroCuadradoInicial = cuadrado . centro cuadrado . centro = Punto ( x : 15.0 , y : 15.0 ) print ( cuadrado.origen est\u00e1 ahora en ( \\( cuadrado . origen . x ) , \\( cuadrado . origen . y ) ) ) // Prints cuadrado.origen est\u00e1 ahora en (10.0, 10.0) Este ejemplo define tres estructuras para trabajar con formas geom\u00e9tricas: Punto encapsula una coordenada (x, y) Tama\u00f1o encapsula un ancho y un alto Rectangulo define una rect\u00e1ngulo por un punto de origen y un tama\u00f1o La estructura Rectangulo proporciona una propiedad calculada llamada centro . La posici\u00f3n actual del centro de un Rectangulo puede ser siempre determinada a partir de su origen y su tama\u00f1o, por lo que no necesitamos almacenarlo como un Punto expl\u00edcito. En su lugar, Rectangulo define un getter y un setter programado para una variable calculada llamada centro , para permitirnos trabajar con el centro del rect\u00e1ngulo como si fuera una propiedad almacenada. En el ejemplo se crea una variable Rectangulo llamada cuadrado . La variable cuadrado se inicializa un un punto origen de (0, 0) y un ancho y tama\u00f1o de 10 . Este cuadrado est\u00e1 representado por el cuadrado azul en el diagrama de abajo. Accedemos entonces a la propiedad centro de la variable cuadrado usando la sintaxis del punto ( square.centro ), lo que causa que se llame al getter de centro para devolver el valor actual de la propiedad. En lugar de devolver los valores existentes, el getter calcula realmente y devuelve un nuevo Punto para representar el centro del cuadrado. Como puede verse arriba, el getter devuelve correctamente un punto con los valores (5, 5) . Despu\u00e9s la propiedad centro se actualiza al nuevo valor de (15, 15) lo que mueve el cuadrado arriba a la derecha, a la nueva posici\u00f3n mostrada por el cuadrado naranja en el diagrama de abajo. Al asignar el nuevo valor a la propiedad se llama al setter del centro, lo que modifica los valores x e y de las propiedades almacenadas originales, y mueve el cuadrado a su nueva posici\u00f3n. Se puede definir una versi\u00f3n acortada del setter usando la variable por defecto newValue que contiene el nuevo valor asignado en el setter : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 struct Rectangulo { var origen = Punto () var tama \u00f1 o = Tama \u00f1 o () var centro : Punto { get { let centroX = origen . x + ( tama \u00f1 o . ancho / 2 ) let centroY = origen . y + ( tama \u00f1 o . alto / 2 ) return Punto ( x : centroX , y : centroY ) } set { origen . x = newValue . x - ( tama \u00f1 o . ancho / 2 ) origen . y = newValue . y - ( tama \u00f1 o . alto / 2 ) } } }","title":"Propiedades calculadas"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#propiedades-solo-lectura","text":"Una propiedad calculada con un getter y sin setter se conoce como una propiedad calculada de solo-lectura. Una propiedad calculada de solo-lectura siempre devuelve un valor, y puede accederse a ella usando la sintaxis de punto, pero no puede modificarse a un valor distinto. Es posible simplificar la declaraci\u00f3n de una propiedad calculada de solo-lectura eliminando la palabra clave get y sus llaves: 1 2 3 4 5 6 7 8 9 struct Cuboide { var ancho = 0.0 , alto = 0.0 , profundo = 0.0 var volumen : Double { return ancho * alto * profundo } } let cuatroPorCincoPorDos = Cuboide ( ancho : 4.0 , alto : 5.0 , profundo : 2.0 ) print ( el volumen de cuatroPorCincoPorDos es \\( cuatroPorCincoPorDos . volumen ) ) // Imprime el volumen de cuatroPorCincoPorDos es 40.0 Este ejemplo define una nueva estructura llamada Cubiode , que representa una caja rectangular 3D con propiedades ancho , alto y profundo . Esta estructura tiene una propiedad calculada llamada volumen , que calcula y devuelve el volumen actual del cuboide. No tendr\u00eda sentido que el volumen fuera modificable, porque no ser\u00eda ambiguo determinar qu\u00e9 valores concretos de ancho, alto y profundo deber\u00edan usarse para un valor particular del volumen.","title":"Propiedades solo-lectura"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#observadores-de-propiedades","text":"Los observadores de propiedades ( property observers ) observan y responden a cambios en el valor de una propiedad. Los observadores de propiedades se llaman cada vez que el valor de una propiedad es actualizado, incluso si el nuevo valor es el mismo que el valor actual de la propiedad. Se pueden a\u00f1adir observadores a cualquier propiedad almacenada que se definan. Se pueden tambi\u00e9n a\u00f1adir observadores a cualquier propiedad heredada (ya sea almacenada o calculada) sobreescribiendo la propiedad en la subclase. No es necesario definir observadores de propiedades calculadas no sobreescritas porque siempre es posible observar y responder a cambios en su valor en el setter de la propiedad. Es posible definir alguno o ambos de estos observadores sobre una propiedad: willSet es llamado justo antes de que el nuevo valor se almacena en la propiedad. didSet es llamado inmediatamente despu\u00e9s de que el nuevo valor es almacenado en la propiedad. Si implementamos un observador willSet , se le pasa el nuevo valor de la propiedad como un par\u00e1metro constante. Podemos especificar un nombre para este par\u00e1metro como parte de la implementaci\u00f3n de willSet . Si no escribimos el nombre del par\u00e1metro y los par\u00e9ntesis dentro de la implementaci\u00f3n, el par\u00e1metro estar\u00e1 disponible con el nombre por defecto de newValue . De forma similar, si implementamos un observador didSet , se pasa como un par\u00e1metro constante que contiene el valor antiguo de la propiedad. Podemos darle nombre al par\u00e1metro o usar el nombre por defecto de oldValue . Si asignamos un valor a la propiedad dentro de su propio observador didSet , el nuevo valor que asignamos reemplaza el que acaba de a\u00f1adirse a la propiedad. A continuaci\u00f3n podemos ver un ejemplo de willSet y didSet en acci\u00f3n. En el definimos una clase nueva llamada CuentaPasos , que hace un seguimiento del n\u00famero total de pasos que una persona hace al caminar. Esta clase puede usarse con datos de entrada de un pod\u00f3metro o cualquier otro sistema de seguir el ejercicio de la persona durante sus rutina diaria. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class ContadorPasos { var totalPasos : Int = 0 { willSet ( nuevoTotalPasos ) { print ( A punto de actualizar totoalPasos a \\( nuevoTotalPasos ) ) } didSet { if totalPasos oldValue { print ( A\u00f1adidos \\( totalPasos - oldValue ) pasos ) } } } } let contadorPasos = ContadorPasos () contadorPasos . totalPasos = 200 // Imprime: A punto de actualizar totalPasos a 200 // Imprime: A\u00f1adidos 200 pasos contadorPasos . totalPasos = 360 // Imprime: A punto de actualizar totalPasos a 360 // Imprime: A\u00f1adidos 160 pasos contadorPasos . totalPasos = 896 // Imprime: A punto de actualizar totalPasos a 896 // Imprime: A\u00f1adidos 536 pasos La clase CuentaPasos declara la propiedad totalPasos de tipo Int . Esta es una propiedad almacenada con observadores willSet y didSet . Los observadores willSet y didSet de totalPasos se llaman siempre que se le asigna un nuevo valor a la propiedad. Esto es as\u00ed incluso si el nuevo valor es el mismo que el valor actual. El observador willSet usa un par\u00e1metro definido por nosotros con el nombre de nuevoTotalPasos para el valor que llega. En el ejemplo, sencillamente imprime el valor que est\u00e1 a punto de establecer. El observador didSet se llama despu\u00e9s de que el valor de totalPasos se ha actualizado. Compara el nuevo valor de totalPasos con el valor antiguo. Si el n\u00famero total de pasos se ha incrementado, se imprime un mensaje indicando cu\u00e1ntos pasos se han tomado. El observador didSet no proporciona un par\u00e1metro definido por nosotros para el valor antiguo, sino que usa el nombre por defecto oldValue .","title":"Observadores de propiedades"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#variables-locales-y-globales","text":"Las capacidades anteriores de propiedades calculadas y de observadores tambi\u00e9n est\u00e1n disponibles para variables globales y locales. El siguiente ejemplo muestra un ejemplo con una variable calculada a partir de otras dos: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 var x = 10 { didSet { print ( El nuevo valor: \\( x ) y el valor antiguo: \\( oldValue ) ) } } var y = 2 * x var z : Int { get { return x + y } set { x = newValue / 2 y = newValue / 2 } } print ( z ) z = 100 print ( x )","title":"Variables locales y globales"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#propiedades-del-tipo","text":"Las propiedades de las instancias son propiedades que pertenecen a una instancia de un tipo particular. Cada vez que creamos una nueva instancia de ese tipo, tiene su propio conjunto de valores de propiedades, separados de los de cualquier otra instancia. Podemos definir tambi\u00e9n propiedades que pertenecen al tipo propiamente dicho, no a ninguna de las instancias de ese tipo. S\u00f3lo habr\u00e1 una copia de estas propiedades, sea cual sea el n\u00famero de instancias de ese tipo que creemos. Estos tipos de propiedades se llaman propiedades del tipo ( type propierties ). Se pueden definir en tanto en estructuras, clases como en enumeraciones. Las propiedades del tipo son \u00fatiles para definir valores que son universales a todas las instancias de un tipo particular, como una propiedad constante que todas las instancias pueden usar (como una constante est\u00e1tica en C), o una propiedad variable que almacena un valor que es global a todas las instancias de ese tipo (como una variable est\u00e1tica en C). Las propiedades del tipo almacenadas pueden ser variables o constantes. Las propiedades del tipo calculadas se declaran siempre como propiedades variables, de la misma forma que las propiedades calculadas de instancias. A diferencia de las propiedades almacenadas de instancias, debemos siempre proporcionar un valor por defecto para las propiedades almacenadas de tipo. Esto es debido a que el tipo por si mismo no tiene un inicializador que pueda asignar un valor en tiempo de inicializaci\u00f3n. En Swift, las propiedades del tipo se definen como parte de la definici\u00f3n del tipo, dentro de las llaves del tipo. Las propiedades del tipo toman valor en el \u00e1mbito del tipo. Para definir una propiedad del tipo hay que usar la palabra clave static . Para propiedades de tipo calculadas de clases, podemos usar en su lugar la palabra clave class para permitir a las subclases que sobreescriban la implementaci\u00f3n de la superclase. Las propiedades del tipo pueden ser tambi\u00e9n constantes ( let ) o variables ( var ). Ejemplo: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 struct UnaEstructura { static let propiedadTipoAlmacenada = Alg\u00fan valor. static var propiedadTipoCalculada : Int { return 1 } } enum UnaEnumeracion { static var propiedadTipoAlmacenada = Alg\u00fan valor. static var propiedadTipoCalculada : Int { return 6 } } class UnaClase { static var propiedadTipoAlmacenada = Alg\u00fan valor. static var propiedadTipoCalculada : Int { return 27 } class var propiedadTipoCalculadaSobreescribible : Int { return 107 } } Las propiedades del tipo se consultan y actualizan usando tambi\u00e9n la sintaxis de punto, pero sobre el tipo , no sobre una instancia: 1 2 3 4 5 6 7 8 9 print ( UnaEstructura . propiedadTipoAlmacenada ) // Imprime Alg\u00fan valor. UnaEstructura . propiedadTipoAlmacenada = Otro valor. print ( UnaEstructura . propiedadTipoAlmacenada ) // Imprime Otro valor. print ( UnaEnumeracion . propiedadTipoCalculada ) // Imprime 6 print ( UnaClase . propiedadTipoCalculada ) // Imprime 27 Un ejemplo: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 struct Valor { var valor : Int = 0 { didSet { Valor . sumaValores += valor } } static var sumaValores = 0 } var c1 = Valor () var c2 = Valor () var c3 = Valor () c1 . valor = 10 c2 . valor = 20 c3 . valor = 30 print ( Suma de los cambios de valores: \\( Valor . sumaValores ) ) // Imprime 60","title":"Propiedades del tipo"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#metodos","text":"Los m\u00e9todos son funciones que est\u00e1n asociadas a un tipo particular. Las clases, estructuras y enumeraciones pueden definir todas ellas m\u00e9todos de instancia, que encapsulan tareas y funcionalidades espec\u00edficas que trabajan con una instancia de un tipo dado. Las clases, estructuras y enumeraciones tambi\u00e9n pueden definir m\u00e9todos del tipo, que est\u00e1n asociados con el propio tipo. Los m\u00e9todos del tipo son similares a los m\u00e9todos de clase en Java. El hecho de que las estructuras y las enumeraciones puedan definir m\u00e9todos en Swift es una diferencia importante con C y Objective-C.","title":"M\u00e9todos"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#metodos-de-instancia","text":"Los m\u00e9todos de instancia son funciones que pertenecen a instancias de una clase, estructura o enumeraci\u00f3n. Proporcionan la funcionalidad de esas instancias, bien proporcionando formas de acceder y modificar propiedades de las instancias, o bien proporcionando funcionalidades relacionadas con el prop\u00f3sito de la instancia. Los m\u00e9todos de instancia tienen exactamente la misma sintaxis que las funciones. Los m\u00e9todos de instancia se escriben dentro de las llaves del tipo al que pertenecen. Un m\u00e9todo de instancia tiene acceso impl\u00edcito a todos los otros m\u00e9todos de instancia y propiedades del tipo. Un m\u00e9todo de instancia puede ser invocado s\u00f3lo sobre una instancia espec\u00edfica del tipo al que pertenece. No puede ser invocado de forma aislada sin una instancia existente. A continuaci\u00f3n podemos ver un ejemplo que define una sencilla clase Contador , que puede usarse para contar el n\u00famero de veces que sucede una acci\u00f3n: 1 2 3 4 5 6 7 8 9 10 11 12 class Contador { var veces = 0 func incrementa () { veces += 1 } func incrementa ( en cantidad : Int ) { veces += cantidad } func reset () { veces = 0 } } Y un ejemplo de uso: 1 2 3 4 5 6 7 8 let contador = Contador () // el valor inicial del contador es 0 contador . incrementa () // el valor del contador es ahora 1 contador . incrementa ( en : 5 ) // el valor del contador es ahora 6 contador . reset () // el valor del contador es ahora 0","title":"M\u00e9todos de instancia"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#nombres-locales-y-externos-de-parametros","text":"Ya vimos que los par\u00e1metros de las funciones pueden tener un nombre interno y un nombre externo. Lo mismo sucede con los m\u00e9todos, porque los m\u00e9todos no son m\u00e1s que funciones asociadas con un tipo. Los nombres de los m\u00e9todos en Swift se refieren normalmente al primer par\u00e1metro usando una preposici\u00f3n como con , en , a o por , como hemos visto en el ejemplo anterior incrementa(en:) . El uso de la preposici\u00f3n permite que el m\u00e9todo se lea como una frase. El nombre de una par\u00e1metro se utiliza tambi\u00e9n como etiqueta del argumento (nombre externo). Al igual que en las funciones, es posible definir dos nombres del par\u00e1metro, uno externo y otro interno. Y el nombre externo puede ser un _ para indicar que no es necesario usar la etiqueta del argumento. Esta forma de invocar a los m\u00e9todos hace que el lenguaje sea m\u00e1s expresivo, sin necesidad de nombres largos de m\u00e9todos o funciones. Consideremos por ejemplo esta versi\u00f3n alternativa de la clase Contador , que define una forma m\u00e1s compleja del m\u00e9todo incrementa(en:) : 1 2 3 4 5 6 class Contador { var valor : Int = 0 func incrementa ( en cantidad : Int , numeroDeVeces : Int ) { valor += cantidad * numeroDeVeces } } El m\u00e9todo incrementa(en:numeroDeVeces:) tiene dos par\u00e1metros: cantidad y numeroDeVeces . El primer par\u00e1metro tiene un nombre externo y otro interno. En el cuerpo del m\u00e9todo se utiliza el nombre interno ( cantidad ). El segundo par\u00e1metro numeroDeVeces es tanto nombre externo como interno. Podemos llamar al m\u00e9todo de la siguiente forma: 1 2 3 let contador = Contador () contador . incrementa ( en : 5 , numeroDeVeces : 3 ) // el valor del contador es ahora 15 Al igual que en las funciones, podemos definir expl\u00edcitamente los nombres externos de los par\u00e1metros y usar el subrayado ( _ ) para indicar que ese par\u00e1metro no tendr\u00e1 nombre externo.","title":"Nombres locales y externos de par\u00e1metros"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#la-propiedad-self","text":"Toda instancia de un tipo tiene una propiedad impl\u00edcita llamada self , que es exactamente equivalente a la instancia misma. Podemos usar la propiedad self para referirnos a la instancia actual dentro de sus propios m\u00e9todos de instancia. El m\u00e9todo increment() en el ejemplo anterior podr\u00eda haberse escrito de esta forma: 1 2 3 func incrementa () { self . veces += 1 } En la pr\u00e1ctica no es necesario usar self casi nunca. Swift asume que cualquier referencia a una propiedad dentro de un m\u00e9todo se refiere a la propiedad de la instancia. El \u00fanico caso en que es obligado usarlo es cuando el nombre de la propiedad coincide con el nombre de un par\u00e1metro. En esta situaci\u00f3n el nombre del par\u00e1metro toma precedencia y es necesario usar self para poder referirse a la propiedad de la instancia. Un ejemplo: 1 2 3 4 5 6 7 8 9 10 11 struct Punto { var x = 0.0 , y = 0.0 func estaAlaDerecha ( de x : Double ) - Bool { return self . x x } } let unPunto = Punto ( x : 4.0 , y : 5.0 ) if unPunto . estaAlaDerecha ( de : 1.0 ) { print ( Este punto est\u00e1 a la derecha de la l\u00ednea donde x == 1.0 ) } // Imprime Este punto est\u00e1 a la derecha de la l\u00ednea donde x == 1.0","title":"La propiedad self"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#modificacion-de-tipos-valor-desde-dentro-de-la-instancia","text":"Las estructuras y las enumeraciones son tipos valor. Por defecto, las propiedades de un tipo valor no pueden ser modificadas desde dentro de los m\u00e9todos de instancia. Sin embargo, si necesitamos modificar las propiedades de nuestra estructura o enumeraci\u00f3n dentro de un m\u00e9todo particular, podemos conseguir una conducta mutadora para ese m\u00e9todo. El m\u00e9todo puede mutar (esto es, cambiar) sus propiedades desde dentro del m\u00e9todo, as\u00ed como asignar una instancia completamente nueva a su propiedad impl\u00edcita self , con lo que esta nueva instancia reemplazar\u00e1 la existente cuando el m\u00e9todo termine. Podemos conseguir esta conducta colocando la palabra clave mutating antes de la palabra func del m\u00e9todo: 1 2 3 4 5 6 7 8 9 10 11 struct Punto { var x = 0.0 , y = 0.0 mutating func incrementa ( incX : Double , incY : Double ) { x += incX y += incY } } var unPunto = Punto ( x : 1.0 , y : 1.0 ) unPunto . incrementa ( incX : 2.0 , incY : 3.0 ) print ( El punto est\u00e1 ahora en ( \\( unPunto . x ) , \\( unPunto . y ) ) ) // Imprime El punto est\u00e1 ahora en (3.0, 4.0) La estructura Punto anterior define un m\u00e9todo mutador increment(incX:incY:) que mueve una instancia de Punto una cierta cantidad. En lugar de devolver un nuevo punto, el m\u00e9todo modifica realmente el punto en el que es llamado. La palabra clave mutating se a\u00f1ade a su definici\u00f3n para permitirle modificar sus propiedades. Hay que hacer notar que no es posible llamar a un m\u00e9todo mutador sobre una constante de un tiempo estructura, porque sus propiedades no se pueden cambiar, incluso aunque sean propiedades variables: 1 2 3 let puntoFijo = Punto ( x : 3.0 , y : 3.0 ) puntoFijo . incrementa ( incX : 2.0 , incY : 3.0 ) // esto provocar\u00e1 un error","title":"Modificaci\u00f3n de tipos valor desde dentro de la instancia"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#asignacion-a-self-en-un-metodo-mutador","text":"Los m\u00e9todos mutadores pueden asignar una nueva instancia completamente nueva a la propiedad self . El anterior ejemplo Punto podr\u00eda habers escrito de la siguiente forma: 1 2 3 4 5 6 struct Punto { var x = 0.0 , y = 0.0 mutating func incrementa ( incX : Double , incY : Double ) { self = Punto ( x : x + incX , y : y + incY ) } } Esta versi\u00f3n del m\u00e9todo mutador incrementa(incX:incY:) crea una estructura nueva cuyos valores x e y se inicializan a los valores desados. El resutado final de llamar a esta versi\u00f3n alternativa ser\u00e1 exactamente el mismo que llamar a la versi\u00f3n anterior (aunque con una peque\u00f1a penalizaci\u00f3n de eficiencia: este m\u00e9todo es 1,3 veces m\u00e1s lento que el anterior en la versi\u00f3n 2.2 del compilador de Swift). Los m\u00e9todos mutadores de enumeraciones pueden establecer el par\u00e1metro self impl\u00edcito para que tenga un subtipo distinto de la misma enumeraci\u00f3n: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 enum InterruptorTriEstado { case apagado , medio , alto mutating func siguiente () { switch self { case . apagado : self = . medio case . medio : self = . alto case . alto : self = . apagado } } } var luzHorno = InterruptorTriEstado . medio luzHorno . siguiente () // luzHorno es ahora .alto luzHorno . siguiente () // luzHorno es ahora .apagado","title":"Asignaci\u00f3n a self en un m\u00e9todo mutador"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#metodos-del-tipo","text":"Los m\u00e9todos de instancia, como los descritos antes, se llaman en instancias de un tipo particular. Es posible tambi\u00e9n definir m\u00e9todos que se llaman en el propio tipo. Esta clase de m\u00e9todos se denominan m\u00e9todos del tipo . Se define un m\u00e9todo del tipo escribiendo la palabra clave static antes de la palabra clave func del m\u00e9todo. Las clases tambi\u00e9n pueden usar la palabra clave class para permitir a las subclases sobreescribir la implementaci\u00f3n del m\u00e9todo. Los m\u00e9todos del tipo se invocan tambi\u00e9n con la sintaxis de punto, escribiendo el nombre del tipo. Por ejemplo: 1 2 3 4 5 6 class NuevaClase { static func unMetodoDelTipo () { print ( Hola desde el tipo ) } } NuevaClase . unMetodoDelTipo () Dentro del cuerpo del m\u00e9todo, la propiedad impl\u00edcita self se refiere al propio tipo, m\u00e1s que a una instancia de ese tipo. Para estructuras y enumeraciones, esto significa que puedes usar self para desambiguar entre propiedades del tipo y los par\u00e1metros del m\u00e9todo, de la misma forma que se hace en los m\u00e9todos de instancias. Cualquier nombre de m\u00e9todo o propiedad que se utilice en el cuerpo de un m\u00e9todo del tipo se referir\u00e1 a otras propiedades o m\u00e9todos de nivel del tipo. Se puede utilizar estos nombres sin necesidad de a\u00f1adir el prefijo del nombre del tipo. Por ejemplo, podemos a\u00f1adir a la clase Ventana una propiedad y m\u00e9todo de clase con la que almacenar instancias de ventanas. Inicialmente guardamos un array vac\u00edo. 1 2 3 4 5 6 7 8 9 10 class Ventana { // Propiedades static var ventanas : [ Ventana ] = [] static func registrar ( ventana : Ventana ) { ventanas . append ( ventana ) } } Cada vez que creamos una ventana podemos llamar al m\u00e9todo registrar de la clase para a\u00f1adirlo a la colecci\u00f3n de ventanas de la clase: 1 2 3 4 let v1 = Ventana () Ventana . registrar ( ventana : v1 ) print ( Se han registrado \\( Ventana . ventanas . count ) ventanas ) // Imprime Se han registrado 1 ventanas","title":"M\u00e9todos del tipo"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#herencia","text":"Una clase puede heredar m\u00e9todos, propiedades y otras caracter\u00edsticas de otra clase. Cuando una clase hereda de otra, la clase que hereda se denomina subclase , y la clase de la que se hereda se denomina su superclase . La herencia es una conducta fundamental que diferencia las clases de otros tipos en Swift. Las clases en Swift pueden llamar y acceder a m\u00e9todos y propiedades que pertenecen a su superclase y pueden proporcionar sus propias versiones que sobreescriben esos m\u00e9todos y propiedades. Para sobreescribir un m\u00e9todo o una propiedad es necesario cumplir con la definici\u00f3n proporcionada por la superclase. Las clases tambi\u00e9n pueden a\u00f1adir observadores a las propiedades heredadas para ser notificadas cuando cambia el valor de una propiedad. A cualquier propiedad se le puede a\u00f1adir un observador de propiedad, independientemente de si es originalmente una propiedad almacenada o calculada.","title":"Herencia"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#definicion-de-una-clase-base","text":"Una clase que no hereda de ninguna otra se denomina una clase base ( base class ). A diferencia de otros lenguajes orientados a objetos, las clases en Swift no heredan de una clase base universal. Tambi\u00e9n a diferencia de otros lenguajes orientados a objetos Swift no permite definir clases abstractas que no permiten crear instancias. Cualquier clase en Swift puede ser instanciada. El siguiente ejemplo define una clase base llamada Vehiculo . Esta clase base define una propiedad almacenada llamada velocidadActual con un valor por defecto de 0.0. Esta propiedad se utiliza por una propiedad String calculada llamada descripcion que crea una descripci\u00f3n del veh\u00edculo. La clase base Vehiculo tambi\u00e9n define un m\u00e9todo llamdo hazRuido . Este m\u00e9todo no hace nada realmente para una instancia de un veh\u00edculo base, pero ser\u00e1 modificado m\u00e1s adelante por las subclases de Vehiculo . 1 2 3 4 5 6 7 8 9 class Vehiculo { var velocidadActual = 0.0 var descripcion : String { return viajando a \\( velocidadActual ) kil\u00f3metros por hora } func hazRuido () { // no hace nada - un veh\u00edculo arbitrario no hace ruido necesariamente } } Creamos una instancia nueva de Vehiculo con la sintaxis de inicializaci\u00f3n que hemos visto, en la que se escribe el nombre del tipo de la clase seguido por par\u00e9ntesis vac\u00edos: 1 let unVehiculo = Vehiculo () Habiendo creado una instancia nueva de Vehiculo , podemos acceder a su descripci\u00f3n: 1 2 print ( Veh\u00edculo: \\( unVehiculo . descripcion ) ) // Veh\u00edculo: viajando a 0.0 kil\u00f3metros por hora La clase Vehiculo define caracter\u00edsticas comunes para un veh\u00edculo arbitrario, pero no es de mucha utilidad por si misma. Para hacerla m\u00e1s \u00fatil, tenemos que refinarla para describir tipos de veh\u00edculos m\u00e1s espec\u00edficos.","title":"Definici\u00f3n de una clase base"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#construccion-de-subclases","text":"La construcci\u00f3n de una subclase ( subclassing ) es la acci\u00f3n de basar una nueva clase en una clase existente. La subclase hereda caracter\u00edsticas de la clase existente, que despu\u00e9s podemos refinar. Tambi\u00e9n podemos a\u00f1adir nuevas caracter\u00edsticas a la subclase. Para indicar que una subclase tiene una superclase hay que escribir el nombre de la subclase antes de el de la superclase, separadas por dos puntos ( : ): 1 2 3 class UnaSubclase : UnaSuperClase { // definici\u00f3n de la subclase } En el ejemplo anterior del Vehiculo podemos definir una subclase Bicicleta : 1 2 3 class Bicicleta : Vehiculo { var tieneCesta = false } La nueva clase Bicicleta obtiene autom\u00e1ticamente todas las caracter\u00edsticas del Vehiculo , como sus propiedades velocidadActual y descripcion y su m\u00e9todo haceRuido() . Adem\u00e1s de las caracter\u00edsticas que hereda, la clase Bicicleta define una nueva propiedad almacenada, tieneCesta , con un valor por defecto de false . Por defecto, cualquier instancia nueva de Bicicleta no tendr\u00e1 una cesta. Puedes establecer la propiedad tieneCesta a true para una instancia particular de Bicicleta despu\u00e9s de crearla: 1 2 let bicicleta = Bicicleta () bicicleta . tieneCesta = true Podemos tambi\u00e9n modificar la propiedad heredada velocidadActual y preguntar por la propiedad descripcion : 1 2 3 bicicleta . velocidadActual = 10.0 print ( Bicicleta: \\( bicicleta . descripcion ) ) // Bicicleta: viajando a 10.0 kil\u00f3metros por hora Podemos construir subclases a partir de otras subclases. El siguiente ejemplo crea una subclase de Bicicleta que representa una bicicleta de dos sillines (un \"tandem\"): 1 2 3 class Tandem : Bicicleta { var numeroActualDePasajeros = 0 } Tandem hereda todas las propiedades y m\u00e9todos de Bicicleta , que a su vez hereda todas sus propiedades y m\u00e9todos de Vehiculo . La subclase Tandem tambi\u00e9n a\u00f1ade una nueva propiedad almacenada llamada numeroActualDePasajeros , con un valor por defecto de 0. Si creamos una instancia de Tandem podremos trabajar con cualquiera de sus propiedades nuevas y heredadas, y preguntar a la descripci\u00f3n de solo lectura que hereda de Vehiculo : 1 2 3 4 5 6 let tandem = Tandem () tandem . tieneCesta = true tandem . numeroActualDePasajeros = 2 tandem . velocidadActual = 18.0 print ( Tandem: \\( tandem . descripcion ) ) // Tandem: viajando a 18.0 kil\u00f3metros por hora","title":"Construcci\u00f3n de subclases"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#sobreescritura","text":"Una subclase puede proporcionar su propia implementaci\u00f3n de un m\u00e9todo de la instancia, m\u00e9todo del tipo, propiedad de la instancia o propiedad del tipo que hereda de su superclase. Esto se conoce como sobreescritura ( overriding ). Para sobreescribir una caracter\u00edstica que ser\u00eda de otra forma heredada debemos usar el prefijo override . De esta forma se clarifica que intentamos proporcionar una sobreescritura y que no lo hacemos por error. Esta palabra clave tambi\u00e9n hace que el compilador comprueba que la superclase (o una de sus clases padre) tiene una declaraci\u00f3n que empareja con la que proporcionamos en la sobreescritura. Cuando proporcionamos una sobreescritura puede ser \u00fatil acceder a los valores proporcionados por la clase padre. Para acceder a ellos podemos usar el prefijo super . El siguiente ejemplo define una nueva subclase de Vehiculo llamada Tren , que sobreescribe el m\u00e9todo hazRuido() : 1 2 3 4 5 class Tren : Vehiculo { override func hazRuido () { print ( Chuu Chuu ) } } Si creamos una nueva instancia de Tren y llamamos al m\u00e9todo hazRuido podemos comprobar que se llama a la versi\u00f3n del m\u00e9todo de la subclase: 1 2 3 let tren = Tren () tren . hazRuido () // Imprime Chuu Chuu Podemos sobreescribir cualquier propiedad heredada del tipo o de la instancia y proporcionar nuestros propios getters y setters para esa propiedad, o a\u00f1adir observadores de propiedades para observar cuando cambian los valores subyacentes de la propiedad. Podemos proporcionar un getter (o setter , si es apropiado) para sobreescribir cualquier propiedad heredada, independientemente de si la propiedad heredada se implementa como una propiedad almacenada o calculada. La naturaleza almacenada o calculada no se conoce por la subclase, que solo conoce su nombre y su tipo. Es posible convertir una propiedad heredada de solo-lectura en una de lectura-escritura. No es posible presentar una propiedad heredada de lectura-escritura como de solo-lectura. El siguiente ejemplo define una nueva clase llamada Coche , que es una subclase de Vehiculo . La clase Coche introduce una nueva propiedad almacenada llamada marcha , con un valor por defecto de 1. Tambi\u00e9n sobreescribe la propiedad heredada descripcion , incluyendo la marcha actual en la descripci\u00f3n: 1 2 3 4 5 6 class Coche : Vehiculo { var marcha = 1 override var descripcion : String { return super . descripcion + con la marcha \\( marcha ) } } Podemos ver el funcionamiento en el siguiente ejemplo: 1 2 3 4 5 let coche = Coche () coche . velocidadActual = 50.0 coche . marcha = 3 print ( Coche: \\( coche . descripcion ) ) // Coche: viajando a 50.0 kil\u00f3metros por hora con la marcha 3 Por \u00faltimo, podemos a\u00f1adir observadores a propiedades heredadas. Esto nos permite ser notificados cuando el valor de una propiedad heredada cambia, independientemente de si esa propiedad se ha implementado en la subclase o en la superclase. El siguiente ejemplo define una nueva clase llamada CocheAutomatico que es una subclase de Coche . La clase CocheAutomatico representa un coche con una caja de cambios autom\u00e1tica, que selecciona autom\u00e1ticamente la marcha bas\u00e1ndose en la velocidad actual: 1 2 3 4 5 6 7 class CocheAutomatico : Coche { override var velocidadActual : Double { didSet { marcha = min ( Int ( velocidadActual / 25.0 ) + 1 , 5 ) } } } En cualquier momento que se modifica la propiedad velocidadActual de una instancia de CocheAutomatico , el observador didSet establece la propiedad marcha a un valor apropiado para la nueva velocidad. Un ejemplo de ejecuci\u00f3n: 1 2 3 4 let automatico = CocheAutomatico () automatico . velocidadActual = 100.0 print ( CocheAutomatico: \\( automatico . descripcion ) ) // CocheAutomatico: viajando a 100.0 kil\u00f3metros por hora con la marcha 5 Por \u00faltimo, es posible prevenir un m\u00e9todo o propiedad de ser sobreescrito declar\u00e1ndolo como final . Para ello, hay que escribir el modificador final antes del nombre de la palabra clave que introduce el m\u00e9todo o la propiedad (como final var , final func o final class ). Tambi\u00e9n es posible marcar la clase completa como final, escribiendo el modificador antes de class ( final class ).","title":"Sobreescritura"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#inicializacion","text":"Inicializaci\u00f3n es el proceso de preparar para su uso una instancia de una clase, estructura o enumeraci\u00f3n. Este proceso incluye la asignaci\u00f3n de un valor inicial para cada propiedad almacenada y la ejecuci\u00f3n de cualquier otra operaci\u00f3n de inicializaci\u00f3n que se necesite para que la nueva instancia est\u00e9 lista para usarse. Para implementar este proceso de inicializaci\u00f3n hay que definir inicializadores , que son como m\u00e9todos especiales que pueden llamarse para crear una nueva instancia de un tipo particular. A diferencia de otros lenguajes, los inicializadores en Swift no devuelven un valor. Su papel principal es que las nuevas instancias del tipo est\u00e9n correctamente inicializadas antes de poder ser usadas por primera vez. Tambi\u00e9n es posible implementar deinicializadores , m\u00e9todos que se ejecutan cuando las instancias son eliminadas de la memoria (no vamos a explicarlos por falta de tiempo). El proceso de inicializaci\u00f3n de una instancia puede resultar un proceso complicado, sobre todo cuando se tienen relaciones de herencia y hay que especificar tambi\u00e9n c\u00f3mo realizar la inicializaci\u00f3n de la subclase utilizando la superclase. Por falta de tiempo no vamos a explicar todo el proceso completo. Recomendamos consultar la documentaci\u00f3n original de Swift .","title":"Inicializaci\u00f3n"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#inicializacion-de-propiedades-almacenadas","text":"Las clases y estructuras deben definir todas sus propiedades almacenadas a un valor inicial en el tiempo en la instancia se crea. Las propiedades almacenadas no pueden dejarse en un estado indeterminado. Podemos definir el valor inicial para una propiedad en un inicializador o asign\u00e1ndole un valor por defecto como parte de la definici\u00f3n de la propiedad. Un inicializador , en su forma m\u00e1s simple, es como un m\u00e9todo de la instancia sin par\u00e1metros, escrito con la palabra clave init : 1 2 3 init () { // realizar alguna inicializaci\u00f3n aqu\u00ed } Por ejemplo, podemos definir la estructura Farenheit que almacena una temperatura en grados Farenheit. Tiene una propiedad almacenada de tipo Double . Definimos un inicializador que inicializa las instancias a 32.0 (equivalente a 0.0 grados Celsius). 1 2 3 4 5 6 7 8 9 struct Fahrenheit { var temperatura : Double init () { temperatura = 32.0 } } var f = Fahrenheit () print ( La temperatura por defecto es \\( f . temperatura ) Fahrenheit ) // Imprime La temperatura por defecto es 32.0\u00b0 Fahrenheit La implementaci\u00f3n anterior es equivalente a la siguiente (que es preferible, por ser m\u00e1s clara): 1 2 3 struct Fahrenheit { var temperatura = 32.0 }","title":"Inicializaci\u00f3n de propiedades almacenadas"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#customizacion-de-la-inicializacion","text":"Es posible customizar el proceso de inicializaci\u00f3n con par\u00e1metros de entrada y tipos opcionales, o asignando propiedades constantes durante la inicializaci\u00f3n. Podemos proporcionar par\u00e1metros de inicializaci\u00f3n como parte de la definici\u00f3n de un inicializador, para definir los tipos y los nombres de los valores que customizan el proceso de inicializaci\u00f3n. Los par\u00e1metros de inicializaci\u00f3n tienen las mismas capacidades y sintaxis que los par\u00e1metros de funciones y m\u00e9todos. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 struct Celsius { var temperaturaEnCelsius : Double init ( desdeFahrenheit fahrenheit : Double ) { temperaturaEnCelsius = ( fahrenheit - 32.0 ) / 1.8 } init ( desdeKelvin kelvin : Double ) { temperaturaEnCelsius = kelvin - 273.15 } } let puntoDeEbullicionDelAgua = Celsius ( desdeFahrenheit : 212.0 ) // puntoDeEbullicionDelAgua.temperaturaEnCelsius es 100.0 let puntoDeCongelacionDelAgua = Celsius ( desdeKelvin : 273.15 ) // puntoDeCongelacionDelAgua.temperaturaEnCelsius is 0.0 Vemos que dependiendo del nombre de par\u00e1metro proporcionado se escoge un inicializador u otro. En los inicializadores es obligatorio proporcionar los nombres de todos los par\u00e1metros: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 struct Color { let rojo , verde , azul : Double init ( rojo : Double , verde : Double , azul : Double ) { self . rojo = rojo self . verde = verde self . azul = azul } init ( blanco : Double ) { rojo = blanco verde = blanco azul = blanco } } let magenta = Color ( rojo : 1.0 , verde : 0.0 , azul : 1.0 ) let medioGris = Color ( blanco : 0.5 ) Podemos evitar proporcionar nombres externos usando un subrayado. Por ejemplo, podemos a\u00f1adir al struct anterior Celsius un inicializador sin nombre externo para el caso en que pasemos la temperatura inicial precisamente en Celsius: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 struct Celsius { var temperaturaEnCelsius : Double init ( desdeFahrenheit fahrenheit : Double ) { temperaturaEnCelsius = ( fahrenheit - 32.0 ) / 1.8 } init ( desdeKelvin kelvin : Double ) { temperaturaEnCelsius = kelvin - 273.15 } init ( _ celsius : Double ) { temperaturaEnCelsius = celsius } } let temperaturaCuerpo = Celsius ( 37.0 ) // temperaturaCuerpo.temperaturaEnCelsius es 37.0 Por \u00faltimo, es posible dejar sin inicializar propiedades opcionales, ya que el valor que tomar\u00edan ser\u00eda nil : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class PreguntaEncuesta { let texto : String var respuesta : String ? init ( texto : String ) { self . texto = texto } func pregunta () { print ( texto ) } } let preguntaQueso = PreguntaEncuesta ( texto : \u00bfTe gusta el queso? ) preguntaQueso . pregunta () // Imprime \u00bfTe gusta el queso? preguntaQueso . respuesta = S\u00ed, me gusta el queso. En el ejemplo anterior se comprueba tambi\u00e9n que es posible inicializar constantes. Por ejemplo, la propiedad text est\u00e1 definida con un let y se inicializa en el inicializador. Por \u00faltimo, es posible definir m\u00e1s de un inicializador, as\u00ed como invocar a inicializadores m\u00e1s b\u00e1sicos desde otros. Si definimos un inicializador en una estructura los inicializadores por defecto dejan de funcionar, es necesario escribirlos tambi\u00e9n. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 struct Rectangulo { var origen = Punto () var tama \u00f1 o = Tama \u00f1 o () init (){} init ( origen : Punto , tama \u00f1 o : Tama \u00f1 o ) { self . origen = origen self . tama \u00f1 o = tama \u00f1 o } init ( centro : Punto , tama \u00f1 o : Tama \u00f1 o ) { let origenX = centro . x - ( tama \u00f1 o . ancho / 2 ) let origenY = centro . y - ( tama \u00f1 o . ancho / 2 ) self . init ( origen : Punto ( x : origenX , y : origenY ), tama \u00f1 o : tama \u00f1 o ) } } let basicRectangulo = Rectangulo () // el origen de basicRectangulo es (0.0, 0.0) y su tama\u00f1o (0.0, 0.0) let origenRectangulo = Rectangulo ( origen : Punto ( x : 2.0 , y : 2.0 ), tama \u00f1 o : Tama \u00f1 o ( ancho : 5.0 , alto : 5.0 )) // el origne de origenRectangulo es (2.0, 2.0) y su tama\u00f1o (5.0, 5.0) let centroRectangulo = Rectangulo ( centro : Punto ( x : 4.0 , y : 4.0 ), tama \u00f1 o : Tama \u00f1 o ( ancho : 3.0 , alto : 3.0 )) // el origen de centroRectangulo es (2.5, 2.5) y su tama\u00f1o (3.0, 3.0)","title":"Customizaci\u00f3n de la inicializaci\u00f3n"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#protocolos","text":"Un protocolo ( protocol ) define un esquema de m\u00e9todos, propiedades y otros requisitos que encajan en una tarea particular o un trozo de funcionalidad. El protocolo puede luego ser adoptado ( adopted ) por una clase, estructura o enumarci\u00f3n para proporcionar una implementaci\u00f3n real de esos requisitos. Cualquier tipo que satisface los requerimientos de un protocolo se dice que se ajusta o cumple ( conform ) ese protocolo. Adem\u00e1s de especificar los requisitos de los tipos que cumplen el protocolo, tambi\u00e9n se puede extender un protocolo (lo veremos m\u00e1s adelante, cuando hablemos de extensiones ) para proporcionar una implementaci\u00f3n de algunos de los m\u00e9todos requeridos por el protocolo.","title":"Protocolos"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#sintaxis","text":"Los protocolos se definen de forma similar a las clases, estructuras y enumeraciones: 1 2 3 protocol UnProtocolo { // definici\u00f3n del protocolo } Para definir un tipo que se ajusta a un protocolo particular se debe poner el nombre del protocolo tras el nombre del tipo, separado por dos puntos. Podemos listar m\u00e1s de un protocolo, y se separan por comas: 1 2 3 struct UnStruct : PrimerProtocolo , OtroProtocolo { // definici\u00f3n del struct } Si una clase tiene una superclase, se escribe el nombre de la superclase antes los protocolos, seguido por una coma: 1 2 3 class UnaClase : UnaSuperClase , PrimerProtocolo , OtroProto { // definici\u00f3n de la clase }","title":"Sintaxis"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#requisitos-de-propiedades","text":"Un protocolo puede requerir a cualquier tipo que se ajuste a \u00e9l que proporcione una propiedad de instancia o de tipo con un nombre y tipo particular. El protocolo no especifica si la propiedad es una propiedad calculada o almacenada, s\u00f3lo especifica el nombre y el tipo de la propiedad requerida. El protocolo tambi\u00e9n especifica si la propiedad debe ser de lectura y escritura o s\u00f3lo de lectura. Si un protocolo requiere que una propiedad sea de lectura y escritura, el requisito no puede ser satisfecho por una propiedad constante almacenada o por una propiedad calculada de s\u00f3lo lectura. Si el protocolo s\u00f3lo requiere que la propiedad sea de lectura, el requisito puede ser satisfecho por cualquier tipo de propiedad, y es v\u00e1lido que la propiedad sea tambi\u00e9n de escritura si es \u00fatil para nuestro propio c\u00f3digo. Los requisitos de la propiedad se declaran siempre como propiedades variables, precedido por la palabra clave var . Las propiedades de lectura y escritura se indican escribiendo { get set } despu\u00e9s de la declaraci\u00f3n de su tipo, y las propiedades de s\u00f3lo lectura se indican escribiendo { get } . 1 2 3 4 protocol UnProtocolo { var debeSerEscribible : Int { get set } var noTienePorQueSerEscribible : Int { get } } Para definir una propiedad de tipo hay que precederla en el protocolo con la palabra clave static : 1 2 3 protocol OtroProtocolo { static var unaPropiedadDeTipo : Int { get set } } Veamos un ejemplo. Definimos el protocolo TieneNombre en el que se requiere que cualquier clase que se ajuste a \u00e9l debe tener una propiedad de instancia de lectura de tipo String que se llame nombreCompleto : 1 2 3 protocol TieneNombre { var nombreCompleto : String { get } } Un ejemplo de una sencilla estructura que adopta el protocolo: 1 2 3 4 5 6 7 struct Persona : TieneNombre { var edad : Int var nombreCompleto : String } let john = Persona ( edad : 35 , nombreCompleto : John Appleseed ) // john.nombreCompleto es John Appleseed Este ejemplo define una estructure llamada Persona , que representa una persona con una edad y un nombre espec\u00edfico. En la primera l\u00ednea se declara que se adopta el protocolo TieneNombre . Cada instancia de Persona tiene la propiedad almacenada llamada nombreCompleto , que es de tipo String . Esto cumple el \u00fanico requisito del protocolo TieneNombre , y signifca que Persona se ajusta correctamente al protocolo (Swift informa de un error en tiempo de compilaci\u00f3n si un requisito de un protocolo no se cumple). Otro ejemplo de una clase m\u00e1s compleja, que tambi\u00e9n adopta el protocolo: 1 2 3 4 5 6 7 8 9 10 11 12 13 class NaveEstelar : TieneNombre { var prefijo : String ? var nombre : String init ( nombre : String , prefijo : String ? = nil ) { self . nombre = nombre self . prefijo = prefijo } var nombreCompleto : String { return ( prefijo != nil ? prefijo ! + : ) + nombre } } var ncc1701 = NaveEstelar ( nombre : Enterprise , prefijo : USS ) // ncc1701.nombreCompleto es USS Enterprise Esta clase implementa el requisito de la propiedad nombreCompleto como una propiedad calculada de solo lectura para una nave estelar. Cada instancia de NavaEstelar almacena un nombre obligatorio y un prefijo opcional. La propiedad nombreCompleto usa el valor del prefijo si existe, y la a\u00f1ade al comienzo del nombre para crear un nombre completo de la nave estelar.","title":"Requisitos de propiedades"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#requisitos-de-metodos","text":"Los protocolos pueden requerir que los tipos que se ajusten a ellos implementen m\u00e9todos de instancia y de tipos espec\u00edficos. Estos m\u00e9todos se escriben como parte de la definici\u00f3n del protocolo de la misma forma que los m\u00e9todos normales, pero sin sus cuerpos. Los m\u00e9todos del tipo en el protocolo deben indicarse con la palabra clave static : 1 2 3 protocol UnProtocolo { static func unMetodoDelTipo () } Por ejemplo: 1 2 3 protocol GeneradorNumerosAleatorios { func random () - Double } Este protocolo, GeneradorNumerosAleatorios , requiere que cualquier tipo que se ajuste a \u00e9l tenga un m\u00e9todo de instancia llamado random , que devuelve un valor Double cada vez que se llama. Aunque no est\u00e1 especificado en el protocolo, se asume que este valor ser\u00e1 un n\u00famero entre 0.0 y 1.0 (sin incluirlo). El protocolo GeneradorNumerosAleatorios no hace ninguna suposici\u00f3n sobre c\u00f3mo ser\u00e1 generado cada n\u00famero aleatorio, simplemente requiere al generador que proporcione una forma est\u00e1ndar de generarlo. Una implementaci\u00f3n de una clase que adopta el protocolo: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class GeneradorLinealCongruente : GeneradorNumerosAleatorios { var ultimoRandom = 42.0 let m = 139968.0 let a = 3877.0 let c = 29573.0 func random () - Double { let number = ultimoRandom * a + c ultimoRandom = number . truncatingRemainder ( dividingBy : m ) return ultimoRandom / m } } let generador = GeneradorLinealCongruente () print ( Un n\u00famero aleatorio: \\( generador . random ()) ) // Imprime Un n\u00famero aleatorio: 0.37464991998171 print ( Y otro: \\( generador . random ()) ) // Imprime Y otro: 0.729023776863283","title":"Requisitos de m\u00e9todos"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#requisito-de-metodo-mutating","text":"Si definimos un protocolo con un requisito de m\u00e9todo de instancia que pretenda mutar las instancias del tipo que adopte el protocolo, se debe marcar el m\u00e9todo con la palabra mutating . Esto permite a las estructuras y enumeraciones que adopten el protocolo definir ese m\u00e9todo como mutating . No es necesario hacerlo con las clases, porque la palabra mutating solo es necesaria en estructuras y enumeraciones. Un ejemplo: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 protocol Conmutable { mutating func conmutar () } enum Interruptor : Conmutable { case apagado , encendido mutating func conmutar () { switch self { case . apagado : self = . encendido case . encendido : self = . apagado } } } var interruptorLampara = Interruptor . apagado interruptorLampara . conmutar () // interruptorLampara es ahora igual a .encendido","title":"Requisito de m\u00e9todo mutating"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#protocolos-como-tipos","text":"Los protocolos no implementan realmente ninguna funcionalidad por ellos mismos. Sin embargo, cualquier protocolo que definamos se convierte autom\u00e1ticamente en un tipo con todas sus propiedades que podemos usar en nuestro c\u00f3digo. Podemos entonces usar el protocolo en cualquier sitio donde permitamos otros tipos, incluyendo: El tipo de un par\u00e1metro de una funci\u00f3n, m\u00e9todo o inicializador o de sus valores devueltos. El tipo de una constante, variable o propiedad El tipo de los \u00edtems de un array, diccionario u otro contenedor 1 2 3 4 5 6 7 8 9 10 11 class Dado { let caras : Int let generador : GeneradorNumerosAleatorios init ( caras : Int , generador : GeneradorNumerosAleatorios ) { self . caras = caras self . generador = generador } func tirar () - Int { return Int ( generador . random () * Double ( caras )) + 1 } } Este ejemplo define una nueva clase llamada Dado , que representa un dado de n caras que se puede usar en un juego de tablero. Las instancias de dados tienen una propiedad llamada caras , que representa cu\u00e1ntas caras tienen, y una propiedad llamada generador , que proporciona un generador a partir del cual crear valores de tiradas. La propiedad generador es del tipo GeneradorNumerosAleatorios . Podemos asignarle una instancia de cualquier tipo que adopte el protocolo GeneradorNumerosAleatorios . Dado tiene tambi\u00e9n un inicializador, para configurar sus estado inicial. El inicializador tiene un par\u00e1metro llamado generador , que tambi\u00e9n es del tipo GeneradorNumerosAleatorios . Podemos pasarle un valor de cualquier instancia que se ajuste a este tipo. Y tambi\u00e9n proporciona un m\u00e9todo de instancia llamado tirar , que devuelve un valor entero entre 1 y el n\u00famero de caras del dado. Este m\u00e9todo llama al m\u00e9todo random() del generador para crear un nuevo n\u00famero aleatorio entre 0.0 y 1.0 y usa este n\u00famero aleatorio para crear un valor de tirada que est\u00e9 dentro del rango correcto. Debido a que sabemos que el generador se ajusta al protocolo GeneradorNumerosAleatorios tenemos la garant\u00eda de que va a existir un m\u00e9todo random() al que llamar. Un ejemplo de uso del c\u00f3digo: 1 2 3 4 5 6 7 8 9 var d6 = Dado ( caras : 6 , generador : GeneradorLinealCongruente ()) for _ in 1. .. 5 { print ( La tirada del dado es \\( d6 . tirar ()) ) } // La tirada del dado es 3 // La tirada del dado es 5 // La tirada del dado es 4 // La tirada del dado es 5 // La tirada del dado es 4","title":"Protocolos como tipos"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#colecciones-de-tipos-protocolo","text":"Como hemos comentado anteriormente, un protocolo puede usarse como el tipo que se almacena un una colecci\u00f3n (array, diccionario, etc.). Veamos un ejemplo: 1 2 3 4 5 6 7 8 9 10 var peterParker = Persona ( edad : 24 , nombreCompleto : Peter Parker ) var ncc1701 = NaveEstelar ( nombre : Enterprise , prefijo : USS ) let cosasConNombre : [ TieneNombre ] = [ peterParker , ncc1701 ] for cosa in cosasConNombre { print ( cosa . nombreCompleto ) } // Peter Parker // USS Enterprise Hay que hacer notar que la constante cosa que itera sobre los elementos del array es de tipo TieneNombre ], no es de tipo Persona ni de tipo NaveEstelar , incluso aunque las instancias que hay tras de escena son do esos tipos. Por ser del tipo TieneNombre sabemos que tiene una propiedad nombreCompleto que podemos usar sobre la variable iteradora.","title":"Colecciones de tipos protocolo"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#protocolos-de-la-biblioteca-estandar-de-swift","text":"En la biblioteca est\u00e1ndar de Swift se definen distintos protocolos como Collection y Equatable que describen abstracciones comunes. Muchos de estos protocolos incorporan implementaciones por defecto de algunos de sus m\u00e9todos mediante extensiones definidas en la propia biblioteca est\u00e1ndar. Veamos por ejemplo el protocolo Equatable . Se trata de un protocolo importante que define las operaciones de igualdad ( == ) y diferencia ( != ). Debemos implementar la operaci\u00f3n de igualdad en cualquier clase que se ajuste al protocolo, pero la operaci\u00f3n de diferencia ya tiene una implementaci\u00f3n por defecto. Un ejemplo: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 struct Punto3D : Equatable { let x , y , z : Double init ( x : Double , y : Double , z : Double ) { self . x = x self . y = y self . z = z } static func == ( izquierda : Punto3D , derecha : Punto3D ) - Bool { return izquierda . x == derecha . x izquierda . y == derecha . y izquierda . z == derecha . z } } let p1 = Punto3D ( x : 0.0 , y : 0.0 , z : 0.0 ) let p2 = Punto3D ( x : 0.0 , y : 0.0 , z : 0.0 ) print ( p1 == p2 ) // Imprime true print ( p1 != p2 ) // Imprime false El operador == se define en la propia estructura. Se utiliza la palabra static para indicar que se trata de un operador que estamos sobrecargando (hablaremos m\u00e1s adelante de los operadores). El operador != que se usa en la \u00faltima instrucci\u00f3n se define en una implementaci\u00f3n por defecto.","title":"Protocolos de la biblioteca est\u00e1ndar de Swift"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#casting-de-tipos","text":"El casting de tipos es una forma de comprobar el tipo de una instancia o de tratar esa instancia como de una superclase distinta o conseguir una subclase de alg\u00fan otro sitio en la propia jerarqu\u00eda de clase. La forma de implementarlo es utilizando los operadores is y as . Estos operadores proporcionan una forma simple y expresiva de comprobar el tipo de un valor o transformar un valor en uno de otro tipo. Tambi\u00e9n se puede usar el casting de tipos para comprobar si un tipo se ajusta a un protocolo.","title":"Casting de tipos"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#una-jerarquia-de-clases-para-el-casting-de-tipos","text":"Vamos a comenzar construyendo una jerarqu\u00eda de clases y subclases con las que trabajar. Utilizaremos el casting de tipos para comprobar el tipo de una instancia particular de una clase y para convertir esa instancia en otra clase dentro de la misma jerarqu\u00eda. En el primer fragmento de c\u00f3digo definimos una clase nueva llamada MediaItem . Esta clase proporciona la funcionalidad b\u00e1sica de cualquier tipo de \u00edtem que aparece en una biblioteca de medios digitales. Espec\u00edficamente, declara una propiedad nombre de tipo String y un inicializador init nombre (suponemos que todos los \u00edtems, incluyendo pel\u00edculas y canciones, tendr\u00e1n un nombre). 1 2 3 4 5 6 class MediaItem { var nombre : String init ( nombre : String ) { self . nombre = nombre } } El siguiente fragmento define dos subclases de MediaItem . La primera subclase, Pelicula , encapsula informaci\u00f3n adicional sobre una pel\u00edcula. A\u00f1ade una propiedad director a la clase base MediaItem , con su correspondiente inicializador. La segunda subclase, Cancion , a\u00f1ade una propiedad artista y un inicializador a la clase base: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Pelicula : MediaItem { var director : String init ( nombre : String , director : String ) { self . director = director super . init ( nombre : nombre ) } } class Cancion : MediaItem { var artista : String init ( nombre : String , artista : String ) { self . artista = artista super . init ( nombre : nombre ) } } Por \u00faltimo, creamos un array constante llamado biblioteca , que contienen dos instancias de Pelicula y tres instancias de Cancion . 1 2 3 4 5 6 7 let biblioteca : [ MediaItem ] = [ Pelicula ( nombre : El Se\u00f1or de los Anillos , director : Peter Jackson ), Cancion ( nombre : Child in Time , artista : Deep Purple ), Pelicula ( nombre : El Puente de los Esp\u00edas , director : Steven Spielberg ), Cancion ( nombre : I Wish You Were Here , artista : Pink Floyd ), Cancion ( nombre : Yellow , artista : Coldplay ) ] Podr\u00edamos tambi\u00e9n dejar que el compilador infiera el tipo del array. Es capaz de deducir que Pelicula y Cancion tienen una superclase com\u00fan MediaItem , por lo que infiere que el tipo del array es [MediaItem] : 1 2 3 4 5 6 7 8 // Declaraci\u00f3n equivalente a la anterior let biblioteca = [ Pelicula ( nombre : El Se\u00f1or de los Anillos , director : Peter Jackson ), Cancion ( nombre : Child in Time , artista : Deep Purple ), Pelicula ( nombre : El Puente de los Esp\u00edas , director : Steven Spielberg ), Cancion ( nombre : I Wish You Were Here , artista : Pink Floyd ), Cancion ( nombre : Yellow , artista : Coldplay ) ] Los \u00edtems almacenados en la biblioteca son todav\u00eda instancias de Pelicula y Cancion . Sin embargo, si iteramos sobre los contenidos de este array, los \u00edtems que recibiremos tendr\u00e1n el tipo MediaItem y no Pelicula o Cancion . Para trabajar con ellos como su tipo nativo, debemos chequear su tipo, y hacer un downcast a su tipo concreto.","title":"Una jerarqu\u00eda de clases para el casting de tipos"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#comprobacion-del-tipo","text":"Podemos usar el operador de comprobaci\u00f3n ( check operator ) is para comprobar si una instancia es de un cierto tipo subclase. El operador de comprobaci\u00f3n devuelve true si la instancia es del tipo de la subclase y false si no. Lo podemos comprobar en el siguiente ejemplo, en el que contamos las instancias de pel\u00edculas y canciones en el array biblioteca : 1 2 3 4 5 6 7 8 9 10 11 12 13 var contadorPeliculas = 0 var contadorCanciones = 0 for item in biblioteca { if item is Pelicula { contadorPeliculas += 1 } else if item is Cancion { contadorCanciones += 1 } } print ( La biblioteca contiene \\( contadorCanciones ) pel\u00edculas y \\( contadorPeliculas ) canciones ) // Imprime La biblioteca contiene 3 pel\u00edculas y 2 canciones El ejemplo itera por todos los \u00edtems del array biblioteca . En cada paso, el bucle for-in guarda en la constante item el siguiente MediaItem del array. La instrucci\u00f3n item is Pelicula devuelve true si el MediaItem actual es una instancia de Pelicula y false en otro caso. De forma similar, item is Cancion comprueba si el \u00edtem es una instancia de Cancion . Al final del bucle for-in , los valores de contadorPeliculas y contadorCanciones contendr\u00e1n una cuenta de cuantas instancias MediaItem de cada tipo se han encontrado.","title":"Comprobaci\u00f3n del tipo"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#downcasting","text":"Una constante o variable de un cierto tipo de clase puede referirse (contener) a una instancia de una subclase. Cuando creemos que sucede esto, podemos intentar hacer un downcast al tipo de la subclase con un operador de cast ( as? o as! ). Como el downcast puede fallar, la versi\u00f3n condicional, as? , devuelve un valor opcional del tipo al que estamos intentando hacer el downcasting . La versi\u00f3n forzosa, as! , intenta el downcast y fuerza la desenvoltura del resultado en un \u00fanica acci\u00f3n compuesta. Debemos usar la versi\u00f3n condicional ( as? ) cuando no estamos seguros si el downcast tendr\u00e1 \u00e9xito. Se devolver\u00e1 un valor opcional y el valor ser\u00e1 nil si no es posible hacer el downcast . Esto permitir\u00e1 comprobar si ha habido un downcast con \u00e9xito. La otra versi\u00f3n ( as! ) se usa s\u00f3lo cuando estamos seguros de que el downcast tendr\u00e1 \u00e9xito. Esta versi\u00f3n del operador lanzar\u00e1 un error en tiempo de ejecuci\u00f3n si intentamos hacer un downcast a un tipo incorrecto. El siguiente ejemplo itera sobre cada MediaIyem en biblioteca , e imprime una descripci\u00f3n apropiada para cada \u00edtem. Para hacerlo, necesita acceder a cada \u00edtem como una Pelicula o Cancion y no s\u00f3lo como una MediaItem . Esto es necesario para poder acceder a la propiedad director o artista de una instancia de Pelicula o Cancion . En este ejemplo, cada \u00edtem en el array podr\u00eda ser un Pelicula o podr\u00eda ser una Cancion . No sabemos por anticipado la clase verdadera de cada \u00edtem, por lo que es apropiado usar la versi\u00f3n condicional ( as? ) para comprobar el downcast cada vez a lo largo del bucle: 1 2 3 4 5 6 7 8 9 10 11 12 13 for item in biblioteca { if let pelicula = item as ? Pelicula { print ( Pel\u00edcula: \\( pelicula . nombre ) , dir. \\( pelicula . director ) ) } else if let cancion = item as ? Cancion { print ( Cancion: \\( cancion . nombre ) , de \\( cancion . artista ) ) } } // Pel\u00edcula: El Se\u00f1or de los Anillos, dir. Peter Jackson // Cancion: Child in Time, de Deep Purple // Pel\u00edcula: El Puente de los Esp\u00edas, dir. Steven Spielberg // Cancion: I Wish You Were Here, de Pink Floyd // Cancion: Yellow, de Coldplay El ejemplo comienza intentando hacer downcast del \u00edtem a una Pelicula . Debido a que es una instancia de MediaItme , es posible que sea un Pelicula o una Cancion , o incluso el tipo base MediaItem . Debido a esta incertidumbre, debemos usar la versi\u00f3n as? para devolver un valor opcional. El resultado ser\u00e1 una \"Pelicula opcional\". Podemos desenvolver el valor Pelicula usando un if let como vimos en el apartado de opcionales. Si tiene \u00e9xito el downcasting , las propiedades de la pel\u00edcula se pueden usar para imprimir una descripci\u00f3n de la pel\u00edcula llamando a los correspondientes m\u00e9todos de la clase Pelicula . Igual con Cancion .","title":"Downcasting"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#casting-para-any","text":"El tipo Any puede representar una instancia de cualquier tipo, incluyendo tipos funci\u00f3n: 1 2 3 4 5 6 7 8 9 10 var array = [ Any ]() array . append ( 0 ) array . append ( 0.0 ) array . append ( 42 ) array . append ( 3.14159 ) array . append ( hola ) array . append (( 3.0 , 5.0 )) array . append ( Pelicula ( nombre : Ghostbusters , director : Ivan Reitman )) array . append ({ ( name : String ) - String in Hola, \\( name ) }) El array contiene dos valores Int , dos valores Double , un valor String , una tupla del tipo (Double, Double) , la pel\u00edcula \"Ghostbusters\", y una clausura que toma un String y devuelve otro String . Puedes usar los operadores is y as en una sentencia switch para descubrir en tiempo de ejecuci\u00f3n el tipo espec\u00edfico de una constante o variable de la que s\u00f3lo se sabe que es de tipo Any : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 for item in array { switch item { case 0 as Int : print ( cero como un Int ) case 0 as Double : print ( cero como un Double ) case let someInt as Int : print ( un valor entero de \\( someInt ) ) case let unDouble as Double where unDouble 0 : print ( a valor positivo de \\( unDouble ) ) case is Double : print ( alg\u00fan otro valor double que no quier imprimir ) case let someString as String : print ( una cadena con valor de \\ \\( someString ) \\ ) case let ( x , y ) as ( Double , Double ): print ( un punto (x, y) en \\( x ) , \\( y ) ) case let pelicula as Pelicula : print ( una pel\u00edcula: \\( pelicula . nombre ) , dir. \\( pelicula . director ) ) case let stringConverter as ( String ) - String : print ( stringConverter ( Michael )) default : print ( alguna otra cosa ) } } // cero como un Int // cero como un Double // un valor entero de 42 // a valor positivo de 3.14159 // una cadena con valor de hola // un punto (x, y) en 3.0, 5.0 // una pel\u00edcula: Ghostbusters, dir. Ivan Reitman // Hola, Michael","title":"Casting para Any"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#comprobacion-de-ajustarse-a-un-protocolo","text":"Podemos usar tambi\u00e9n los operadores anteriores is y as (y as? y as! ) para comprobar si una instancia se ajusta a un protocolo y para hacer un cast a un protocolo espec\u00edfico. Veamos un ejemplo. Definimos el protocolo TieneArea con el \u00fanico requisito de una propiedad de lectura llamada area de tipo Double : 1 2 3 protocol TieneArea { var area : Double { get } } Definimos dos clases Circulo y Pais que se ajustan ambos al protocolo: 1 2 3 4 5 6 7 8 9 10 11 class Circulo : TieneArea { let pi = 3.1415927 var radio : Double var area : Double { return pi * radio * radio } init ( radio : Double ) { self . radio = radio } } class Pais : TieneArea { var area : Double init ( area : Double ) { self . area = area } } La clase Circulo implementa el requisito como una propiedad calculada, basada en la propiedad almacenada radio . La clase Pais implementa el requisito directamente como una propiedad almacenada. Ambas clases se ajustan correctamente al protocolo TieneArea . Definimos una clase Animal que no se ajusta al protocolo: 1 2 3 4 class Animal { var patas : Int init ( patas : Int ) { self . patas = patas } } Las clases Circulo , Pais y Animal no tienen ninguna clase base compartida. Sin embargo, todas son clases, por lo que las instancias de los tres tipos pueden usarse para inicializar un array que almacena valores de tipo Any : 1 2 3 4 5 let objetos : [ Any ] = [ Circulo ( radio : 2.0 ), Pais ( area : 243_610 ), Animal ( patas : 4 ) ] Y ahora podemos iterar sobre el array de objetos, comprobando para cada \u00edtem si la instancia se ajusta al protocolo TieneArea : 1 2 3 4 5 6 7 8 9 10 11 for objecto in objetos { if let objetoConArea = objecto as ? TieneArea { print ( El \u00e1rea es \\( objetoConArea . area ) ) } else { print ( Algo que no tiene un \u00e1rea ) } } // El \u00e1rea es 12.5663708 // El \u00e1rea es 243610.0 // Algo que no tiene un \u00e1rea Cuando un objeto en el array se ajusta al protocolo TieneArea , el valor opcional devuelto por el operador as? se desenvuelve con un ligado opcional en una constante llamada objetoConArea . Esta constante tiene el tipo TieneArea , por lo que su propiedad area podr\u00e1 ser accedida e impresa. Hay que notar que los objetos subyacentes no cambian en el proceso de casting . Siguen siendo un Circulo , un Pais y un Animal . Sin embargo, en el momento en se almacenan en la constante objetoConArea , s\u00f3lo se sabe que son del tipo TieneArea , por lo que s\u00f3lo podremos acceder a su propiedad area .","title":"Comprobaci\u00f3n de ajustarse a un protocolo"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#extensiones","text":"Las extensiones a\u00f1aden nueva funcionalidad a una clase, estructura, enumeraci\u00f3n o protocolo. Esto incluye la posibilidad de extender tipos para los que no tenemos acceso al c\u00f3digo fuente original (esto se conoce como modelado retroactivo ). Entre otras cosas, las extensiones pueden: A\u00f1adir propiedades calculadas de instancia y de tipo Definir m\u00e9todos de instancia y de tipo Proporcionar nuevos inicializadores Hacer que un tipo existente se ajuste a un protocolo","title":"Extensiones"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#sintaxis_1","text":"Para declarar una extensi\u00f3n hay que usar la palabra clave extension : 1 2 3 extension UnTipo { // nueva funcionalidad para a\u00f1adir a UnTipo }","title":"Sintaxis"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#propiedades-calculadas_1","text":"Las extensiones pueden a\u00f1adir propiedades calculadas de instancias y de tipos. Como primer ejemplo, vamos a a\u00f1adir a la clase persona la propiedad calcula mayorEdad , un Bool que indica si la edad de la persona es mayor o igual de 18: 1 2 3 4 5 extension Persona { var mayorEdad : Bool { return edad = 18 } } Una vez definida esta extensi\u00f3n, hemos ampliado la clase con esta nueva propiedad, sin tocar el c\u00f3digo de la clase. Podemos preguntar si una persona es mayor de edad: 1 2 var p = Persona ( edad : 15 , nombreCompleto : Luc\u00eda ) p . mayorEdad // false Es posible incluso extender clases de las librer\u00edas est\u00e1ndar de Swift, como Int , Double , Array , etc. Por ejemplo, podemos a\u00f1adir propiedades calculadas a la clase Double para trabajar con unidades de distancia. Las siguientes propiedades convierten una cantidad en las unidades correspondientes a su equivalente en metros: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 extension Double { var km : Double { return self * 1_000.0 } var m : Double { return self } var cm : Double { return self / 100.0 } var mm : Double { return self / 1_000.0 } var ft : Double { return self / 3.28084 } } let distancia = 11. km // En distancia tendremos 11000 metros let unaPulgada = 25.4 . mm print ( Una pulgada es \\( unaPulgada ) metros ) // Una pulgada es 0.0254 metros let tresPies = 3. ft print ( Tres pies son \\( tresPies ) metros ) // Tres pies son 0.914399970739201 metros Estas propiedades calculadas expresan que un valor Double deber\u00eda considerarse como una cierta unidad de longitud. Aunque se implementan como propiedades calculadas, los nombres de las propiedades pueden a\u00f1adirse a un literal en punto flotante con la sintaxis del punto, como una forma de usar el valor del literal para ejecutar conversiones de distancia. Por ejemplo, cuando se escribe 11.km se pide el valor de la propiedad calculada km de la instancia 11 . La propiedad calculada devuelve el resultado de multiplicar 11 por 1000 , esto es, los metros correspondientes a 11 kil\u00f3metros. De forma similar, hay 3.28084 pies en un metro, por lo que la propiedad calculada ft divide el valor Double subyacente por 3.28084, para conventirlo de pies a metros. Estas propiedades son propiedades calculadas de solo lectura, por lo que se expresan sin la palabra clave get , por brevedad. Sus valores devueltos son de tipo Double , y pueden usarse en c\u00e1lculos matem\u00e1ticos en cualquier sitio que se acepte un Double : 1 2 3 let unMaraton = 42. km + 195. m print ( Un marat\u00f3n tiene una longitud de \\( unMaraton ) metros ) // Un marat\u00f3n tiene una longitud de 42195.0 metros","title":"Propiedades calculadas"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#inicializadores","text":"Las extensiones pueden a\u00f1adir nuevos inicializadores a tipos existentes. Esto nos permite extender otros tipos para aceptar nuestros propios tipos como par\u00e1metros de la inicializaci\u00f3n, o para proporcionar opciones adicionales que no estaban incluidos en la implementaci\u00f3n original del tipo. El siguiente ejemplo define una estructura Rectangulo que representa un rect\u00e1ngulo geom\u00e9trico. Este ejemplo tambi\u00e9n define dos estructuras auxiliares llamadas Tama\u00f1o y Punto , que proporcionan valores por defecto de 0.0 a todas sus propiedades: 1 2 3 4 5 6 7 8 9 10 struct Tama \u00f1 o { var ancho = 0.0 , alto = 0.0 } struct Punto { var x = 0.0 , y = 0.0 } struct Rectangulo { var origen = Punto () var tama \u00f1 o = Tama \u00f1 o () } Debido a que la estructura Rectangulo proporciona valores por defecto para todas sus propiedades, tiene un inicializador por defecto que puede utilizarse para crear nuevas instancias. Tambi\u00e9n podemos inicializarlo asignando todas sus propieades: 1 2 3 let rectanguloPorDefecto = Rectangulo () let rectanguloInicializado = Rectangulo ( origen : Punto ( x : 2.0 , y : 2.0 ), tama \u00f1 o : Tama \u00f1 o ( ancho : 5.0 , alto : 5.0 )) Podemos extender la estructura Rectangulo para proporcionar un inicializador adicional que toma un punto espec\u00edfico del centro y un tama\u00f1o: 1 2 3 4 5 6 7 extension Rectangulo { init ( centro : Punto , tama \u00f1 o : Tama \u00f1 o ) { let origenX = centro . x - ( tama \u00f1 o . ancho / 2 ) let origenY = centro . y - ( tama \u00f1 o . alto / 2 ) self . init ( origen : Punto ( x : origenX , y : origenY ), tama \u00f1 o : tama \u00f1 o ) } } Este nuevo inicializador empieza por calcular un punto de origen basado en el centro propuesto y en el tama\u00f1o. El inicializador llama despu\u00e9s al inicializador autom\u00e1tico de la estructura init(origen:tama\u00f1o:) , que almacena los nuevos valores de las propiedades: 1 2 3 let rectanguloCentro = Rectangulo ( centro : Punto ( x : 4.0 , y : 4.0 ), tama \u00f1 o : Tama \u00f1 o ( ancho : 3.0 , alto : 3.0 )) // el origen del rectanguloCentro es is (2.5, 2.5) y su tama\u00f1o es (3.0, 3.0)","title":"Inicializadores"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#metodos_1","text":"Las extensiones pueden a\u00f1adir nuevos m\u00e9todos de instancia y nuevos m\u00e9todos del tipo. Por ejemplo, podemos a\u00f1adir el m\u00e9todo descripcion() a la estructura Persona : 1 2 3 4 5 6 7 8 extension Persona { func descripcion () - String { return Me llamo \\( nombreCompleto ) y tengo \\( edad ) a\u00f1os } } let reedRichards = Persona ( edad : 40 , nombreCompleto : Reed Richards ) print ( reedRichards . descripcion ()) Tambi\u00e9n podemos a\u00f1adir m\u00e9todos a clases y estructuras importadas. Por ejemplo podemos a\u00f1adir un nuevo m\u00e9todo de instancia llamado repeticiones al tipo Int : 1 2 3 4 5 6 7 extension Int { func repeticiones ( _ tarea : () - Void ) { for _ in 0. . self { tarea () } } } El m\u00e9todo repeticiones(_:) toma un \u00fanico argumento de tipo () - Void , que indica una funci\u00f3n que no tiene par\u00e1metros y no devuelve ning\u00fan valor. Despu\u00e9s de definir esta extensi\u00f3n, podemos llamar al m\u00e9todo repeticiones(_:) en cualquier n\u00famero entero para ejecutar una tarea un cierto n\u00famero de veces: 1 2 3 4 5 6 3. repeticiones ({ print ( Hola! ) }) // Hola! // Hola! // Hola! Usando clausuras por la cola podemos hacer la llamada m\u00e1s concisa: 1 2 3 4 5 6 3. repeticiones { print ( Adios! ) } // Adios! // Adios! // Adios!","title":"M\u00e9todos"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#metodos-de-instancia-mutadores","text":"Los m\u00e9todos de instancia a\u00f1adidos con una extensi\u00f3n tambi\u00e9n pueden modificar (o mutar) la propia instancia. Los m\u00e9todos de las estructuras y los enumerados que modifican self o sus propiedades deben marcarse como mutating . Por ejemplo: 1 2 3 4 5 6 7 8 extension Int { mutating func cuadrado () { self = self * self } } var unInt = 3 unInt . cuadrado () // unInt es ahora 9","title":"M\u00e9todos de instancia mutadores"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#ajustar-un-tipo-a-un-protocolo-mediante-una-extension","text":"Una extensi\u00f3n puede extender un tipo existente para hacer que se ajuste a uno o m\u00e1s protocolos. En este caso, los nombres de los protocolos se escriben exactamente de la misma forma que en una clase o estructura: 1 2 3 extension UnTipo : UnProtocolo , OtroProtocolo { // implementaci\u00f3n de los requisitos del protocolo } Las instancias del tipo adoptar\u00e1n autom\u00e1ticamente el protocolo y se ajustar\u00e1n al protocolo con las propiedades y m\u00e9todos a\u00f1adidos por la extensi\u00f3n. Por ejemplo, este protocolo, llamado RepresentableComoTexto puede ser implementado por cualquier tipo que tenga una forma de representarse como texto. Esto puede ser una descripci\u00f3n de si mismo o una versi\u00f3n de texto de su estado actual: 1 2 3 protocol RepresentableComoTexto { var descripcionTextual : String { get } } La clase Dado que vimos anteriormente puede extenderse para ajustarse al protocolo: 1 2 3 4 5 extension Dado : RepresentableComoTexto { var descripcionTextual : String { return Un dado de \\( caras ) caras } } Esta extensi\u00f3n adopta el nuevo protocolo exactamente como si el Dado lo hubiera proporcionado en su implementaci\u00f3n original. El nombre del protocolo se indica tras el nombre del tipo, separado por dos puntos, y se proporciona una implementaci\u00f3n entre llaves. Cualquier instancia de un dado se puede tratar ahora como RepresentableComoTexto : 1 2 3 let d12 = Dado ( caras : 12 , generador : GeneradorLinealCongruente ()) print ( d12 . descripcionTextual ) // Un dado de 12 caras De forma similar, un Rectangulo tambi\u00e9n puede extenderse para adoptar y ajustarse al protocolo: 1 2 3 4 5 6 7 8 9 10 extension Rectangulo : RepresentableComoTexto { var descripcionTextual : String { return Un rect\u00e1ngulo situado en ( \\( origen . x ) , \\( origen . y ) ) } } let rectanguloInicializado = Rectangulo ( origen : Punto ( x : 2.0 , y : 2.0 ), tama \u00f1 o : Tama \u00f1 o ( ancho : 5.0 , alto : 5.0 )) print ( rectanguloInicializado . descripcionTextual ) // Un rect\u00e1ngulo situado en (2.0, 2.0)","title":"Ajustar un tipo a un protocolo mediante una extensi\u00f3n"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#declaracion-de-la-adopcion-de-un-protocolo-con-una-extension","text":"Si un tipo ya se ajusta a todos los requisitos de un protocolo, pero todav\u00eda no se ha declarado que se ajusta al protocolo, podemos hacer que lo adopte con una extensi\u00f3n vac\u00eda: 1 2 3 4 5 6 7 struct Hamster { var nombre : String var descripcionTextual : String { return Un hamster llamado \\( nombre ) } } extension Hamster : RepresentableComoTexto {} Las instancias de Hamster pueden ahora usarse en cualquier sitio que se requiera un tipo RepresentableComoTexto : 1 2 3 4 let simonElHamster = Hamster ( nombre : Simon ) let algoRepresentableComoTexto : RepresentableComoTexto = simonElHamster print ( algoRepresentableComoTexto . descripcionTextual ) // Un hamster llamado Simon","title":"Declaraci\u00f3n de la adopci\u00f3n de un protocolo con una extensi\u00f3n"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#implementacion-de-metodos-de-un-protocolo","text":"Podemos definir extensiones en los protocolos para proporcionar implementaciones de m\u00e9todos y propiedades a todos los tipos que se ajustan a \u00e9l. Esto permite definir conductas en los propios protocolos, m\u00e1s que en cada tipo individual o en una funci\u00f3n global. Por ejemplo, el protocolo GeneradorNumerosAleatorios puede ser extendido para proporcionar un m\u00e9todo boolAleatorio() , que usa el resultado del random() requerido para devolver un valor Bool aleatorio: 1 2 3 4 5 extension GeneradorNumerosAleatorios { func randomBool () - Bool { return random () 0.5 } } Al crear una extensi\u00f3n en el protocolo, todos los tipos que se ajustan a \u00e9l adquieren autom\u00e1ticamente esta implementaci\u00f3n sin ninguna modificaci\u00f3n adicional. 1 2 3 4 5 let generator = GeneradorLinealCongruente() print( Un n\u00famero aleatorio: \\(generator.random()) ) // Imprime Un n\u00famero aleatorio: 0.37464991998171 print( Y un booleano aleatorio: \\(generator.randomBool()) ) // Imprime Un booleano aleatorio: true El tipo que se ajusta al protocolo puede proporcionar su propia implementaci\u00f3n, que se usar\u00e1 en lugar de la proporcionada por la extensi\u00f3n.","title":"Implementaci\u00f3n de m\u00e9todos de un protocolo"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#restriccion-en-las-extensiones-de-un-protocolo","text":"En la definici\u00f3n de una extensi\u00f3n de un protocolo es posible definir restricciones que deben cumplir los tipos que lo cumplen. Los m\u00e9todos y propiedades de la extensi\u00f3n s\u00f3lo estar\u00e1n disponibles en aquellos tipos que cumplan estos requisitos. Los requisitos se definen usando una cl\u00e1usula gen\u00e9rica where . Por ejemplo, podemos definir una extensi\u00f3n al protocolo Collection que se aplique a cualquier colecci\u00f3n cuyos elementos cumplen el protocolo Equatable . De esta forma nos aseguramos de que los operadores == y != est\u00e1n definidos y podemos usarlos en la extensi\u00f3n: 1 2 3 4 5 6 7 8 9 10 extension Collection where Element : Equatable { func allEqual () - Bool { for element in self { if element != self . first { return false } } return true } } El m\u00e9todo allEqual() devuelve true si y s\u00f3lo si todos los elementos en la colecci\u00f3n son iguales. Un ejemplo: 1 2 let numerosIguales = [ 100 , 100 , 100 , 100 , 100 ] let numerosDiferentes = [ 100 , 100 , 200 , 100 , 200 ] Dado que ambos arrays cumplen el protocolo Collection y los enteros cumplen el protocolo Equatable podemos usar el m\u00e9todo allEqual() : 1 2 3 4 print(numerosIguales.allEqual()) // Prints true print(numerosDiferentes.allEqual()) // Prints false En una colecci\u00f3n de una clase que no cumple el protocolo Equatable no se puede utilizar el m\u00e9todo de la extensi\u00f3n: 1 2 3 4 let tormenta = Persona ( edad : 32 , nombreCompleto : Ororo Munroe ) let superHeroes = [ tormenta , peterParker , reedRichards ] print ( superHeroes . allEqual ()) //error: type Persona does not conform to protocol Equatable","title":"Restricci\u00f3n en las extensiones de un protocolo"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#funciones-operadoras","text":"Las clases y las estructuras pueden proporcionar sus propias implementaciones de operadores existentes. Esto se conoce como sobrecarga de los operadores existentes. En el siguiente ejemplo se muestra c\u00f3mo implementar el operador de suma ( + ) para una estructura. El operador suma es un operador binario (tiene dos operandos) e infijo (aparece junto entre los dos operandos). Definimos una estructura Vector2D para un vector de posici\u00f3n de dos dimensiones: 1 2 3 4 5 6 struct Vector2D { var x = 0.0 , y = 0.0 static func + ( izquierdo : Vector2D , derecho : Vector2D ) - Vector2D { return Vector2D ( x : izquierdo . x + derecho . x , y : izquierdo . y + derecho . y ) } } La funci\u00f3n operador se define como una funci\u00f3n est\u00e1tica con un un nombre de funci\u00f3n que empareja con el operador a sobrecargar ( + ). Debido a que la suma aritm\u00e9tica se define como un operador binario, esta funci\u00f3n operador toma dos par\u00e1metros de entrada de tipo Vector2D y devuelve un \u00fanico valor de salida, tambi\u00e9n de tipo Vector2D . En esta implementaci\u00f3n, llamamos a los par\u00e1metros de entrada izquierdo y derecho para representar las instancias de Vector2D que estar\u00e1n a la izquierda y a la derecha del operador + . La funci\u00f3n devuelve una nueva instancia de Vector2D , cuyas propiedades x e y se inicializan con la suma de las propiedades x e y de las instancias de Vector2D que se est\u00e1n sumando. La funci\u00f3n se define globalmente, m\u00e1s que como un m\u00e9todo en la estructura Vector2D , para que pueda usarse como un operador infijo entre instancias existentes de Vector2D : 1 2 3 4 let vector = Vector2D ( x : 3.0 , y : 1.0 ) let otroVector = Vector2D ( x : 2.0 , y : 4.0 ) let vectorSuma = vector + otroVector // vectorSuma es una instancia de Vector2D con valores de (5.0, 5.0)","title":"Funciones operadoras"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#operadores-prefijos-y-postfijos","text":"El ejemplo anterior demuestra una implementaci\u00f3n propia de un operador binario infijo. Las clases y las estructuras pueden tambi\u00e9n proporcionar implementaciones de los operadores unarios est\u00e1ndar. Los operadores unarios operan sobre un \u00fanico objetivo. Son prefijos se preceden el objetivo (como -a ) y postfijos si siguen su objetivo (como en b! ). Para implementar un operador unario prefijo o postfijo se debe escribir el modificador prefix o postfix antes de la palabra clave func en la declaraci\u00f3n de la funci\u00f3n operador: 1 2 3 4 5 6 struct Vector2D { ... static prefix func - ( vector : Vector2D ) - Vector2D { return Vector2D ( x : - vector . x , y : - vector . y ) } } El ejemplo anterior implementa el operador unario negaci\u00f3n ( -a ) para instancias de Vector2D . Por ejemplo: 1 2 3 4 5 let positivo = Vector2D ( x : 3.0 , y : 4.0 ) let negativo = - positivo // negativo es una instancia de Vector2D con valores de (-3.0, -4.0) let tambienPositivo = - negativo // tambienPositivo es una instancia de Vector2D con valores de (3.0, 4.0)","title":"Operadores prefijos y postfijos"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#operadores-de-equivalencia","text":"Como ya hemos visto, las clases y estructuras construidas no tienen una implementaci\u00f3n por defecto de los operadores \"igual a\" ( == ) y \"no igual a\" ( != ). No es posible para Swift adivinar qu\u00e9 valores ser\u00e1n \"iguales\" en nuestras clases, porque el significado de \"igual\" depende del papel que esos tipos juegan en nuestro c\u00f3digo. Para poder usar los operadores de igualdad en nuestros propios tipos, debemos proporcionar una implementaci\u00f3n de la misma forma que para otros operadores infijos. Lo hacemos definiendo una extensi\u00f3n que cumple el protocolo Equatable . De esta forma, como ya hemos visto anteriormente, conseguimos la implementaci\u00f3n por defecto del operador != : 1 2 3 4 5 extension Vector2D : Equatable { static func == ( izquierdo : Vector2D , derecho : Vector2D ) - Bool { return ( izquierdo . x == derecho . x ) ( izquierdo . y == derecho . y ) } } En el ejemplo anterior se implementa un operador \"igual a\" ( == ) que comprueba si dos instancias de Vector2D tienen valores equivalentes. En el contexto del Vector2D tiene sentido considerar \"igual\" como \"ambas instancias tienen los mismos valores x e y\", por lo que esta es la l\u00f3gica usada por la implementaci\u00f3n. La implementaci\u00f3n por defecto del operador \"no igual a\" ( != ), simplemente devuelve el inversa del resultado del operador \"igual a\". Ahora podemos usar estos operadores para chequear si dos instancias de Vector2D son equivalentes: 1 2 3 4 5 6 7 8 9 let dosTres = Vector2D ( x : 2.0 , y : 3.0 ) let otroDosTres = Vector2D ( x : 2.0 , y : 3.0 ) let unoDos = Vector2D ( x : 1.0 , y : 2.0 ) if dosTres == otroDosTres { print ( Los vectores \\( dosTres ) y \\( otroDosTres ) son equivalentes. ) } if ( unoDos != dosTres ) { print ( Los vectores \\( unoDos ) y \\( dosTres ) son distintos. ) }","title":"Operadores de equivalencia"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#genericos","text":"Veamos c\u00f3mo podemos utilizar los gen\u00e9ricos con clases y estructuras. Vamos a utilizar como ejemplo un tipo de dato muy sencillo: una pila ( stack ) en la que se podr\u00e1n a\u00f1adir ( push ) y retirar ( pop ) elementos. La versi\u00f3n no gen\u00e9rica del tipo de dato es la siguiente, en la que se implementa una pila de enteros. 1 2 3 4 5 6 7 8 9 struct IntStack { var items = [ Int ]() mutating func push ( _ item : Int ) { items . append ( item ) } mutating func pop () - Int { return items . removeLast () } } La estructura usa un array para guardar los \u00edtems y los m\u00e9todos push y pop a\u00f1aden y retiran los elementos. El problema de esta estructura es su falta de genericidad; s\u00f3lo puede almacenar enteros. Aqu\u00ed est\u00e1 una versi\u00f3n gen\u00e9rica del mismo c\u00f3digo: 1 2 3 4 5 6 7 8 9 struct Stack Element { var items = [ Element ]() mutating func push ( _ item : Element ) { items . append ( item ) } mutating func pop () - Element { return items . removeLast () } } El par\u00e1metro del tipo Element define un tipo gen\u00e9rico que se utiliza como placeholder del tipo real del que se declare la estructura. Podemos ver que se utiliza en la definici\u00f3n de los distintos elementos de la estructura. Por ejemplo, el array de \u00edtems es un array de Element s. Y los \u00edtems a\u00f1adidos y retirados de la pila son tambi\u00e9n objetos de tipo Element . Por ejemplo, podemos crear una pila de cadenas: 1 2 3 4 5 6 var stackOfStrings = Stack String () stackOfStrings . push ( uno ) stackOfStrings . push ( dos ) stackOfStrings . push ( tres ) stackOfStrings . push ( cuatro ) // la pila contiene ahora 4 cadenas Y podemos retirar la \u00faltima cadena de la pila: 1 let fromTheTop = stackOfStrings . pop ()","title":"Gen\u00e9ricos"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#extension-de-un-tipo-generico","text":"Cuando se extiende un tipo gen\u00e9rico, no hace falta a\u00f1adir el par\u00e1metro del tipo entre . El tipo gen\u00e9rico est\u00e1 disponible a partir de la definici\u00f3n original y se puede usar tal cual en el cuerpo de la extensi\u00f3n. Por ejemplo, podemos extender el tipo gen\u00e9rico Stack para a\u00f1adir una propiedad computable de s\u00f3lo lectura que devuelva el tope de la pila: 1 2 3 4 5 extension Stack { var topItem : Element ? { return items . isEmpty ? nil : items [ items . count - 1 ] } } En la extensi\u00f3n se utiliza el nombre gen\u00e9rico Element sin tener que declararlo despu\u00e9s de Stack , porque est\u00e1 definido en la estructura original. Ahora ya se puede acceder al tope de la pila sin retirar el elemento: 1 2 3 4 if let topItem = stackOfStrings . topItem { print ( El \u00edtem en el tope de la pila es \\( topItem ) . ) } // Imprime El \u00edtem en el tope de la pila es tres.","title":"Extensi\u00f3n de un tipo gen\u00e9rico"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#bibliografia","text":"Swift Language Guide Classes and Structures Properties Methods Inheritance Initialization Protocolos Casting de tipos Extensiones Funciones operador Gen\u00e9ricos Lenguajes y Paradigmas de Programaci\u00f3n, curso 2018\u201319 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Domingo Gallardo, Cristina Pomares, Antonio Bot\u00eda, Francisco Mart\u00ednez","title":"Bibliograf\u00eda"}]}