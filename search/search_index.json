{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Sitio web con los apuntes de teor\u00eda, seminarios y pr\u00e1cticas de la asignatura \"Lenguajes y paradigmas de programaci\u00f3n\". Despliega el men\u00fa de la izquierda para consultar los apuntes. Otros enlaces: Ficha de la asignatura Plataforma docente Moodle","title":"Index"},{"location":"practicas/practica01/practica01.html","text":"Pr\u00e1ctica 1: Programaci\u00f3n funcional en Scheme \u00b6 Entrega de la pr\u00e1ctica \u00b6 Para entregar la pr\u00e1ctica debes subir a Moodle el fichero practica01.rkt con una cabecera inicial con tu nombre y apellidos, y las soluciones de cada ejercicio separadas por comentarios. Cada soluci\u00f3n debe incluir: La definici\u00f3n de las funciones que resuelven el ejercicio. Un conjunto de pruebas que comprueben su funcionamiento, y el de funciones auxiliares que hayamos definido, utilizando el API RackUnit. Por ejemplo, supongamos que el primer ejercicio de la pr\u00e1ctica 1 sea implementar la funci\u00f3n suma-cuadrados que recibe dos n\u00fameros y devuelve la suma de sus cuadrados y se proponen en el enunciado los siguientes ejemplos: 1 2 ( suma-cuadrados 10 10 ) ; \u21d2 200 ( suma-cuadrados -2 9 ) ; \u21d2 85 La soluci\u00f3n se deber\u00eda entregar de la siguiente forma: practica01.rkt : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 ;; Jos\u00e9 Fernandez Mu\u00f1oz #lang racket ( require rackunit ) ;; ;; Ejercicio 1: suma-cuadrados ;; ;; Funci\u00f3n auxiliar cuadrado ( define ( cuadrado x ) ( * x x )) ( check-equal? ( cuadrado 2 ) 4 ) ( check-equal? ( cuadrado 10 ) 100 ) ( check-equal? ( cuadrado -2 ) 4 ) ;; Funci\u00f3n principal suma-cuadrados ( define ( suma-cuadrados x y ) ( + ( cuadrado x ) ( cuadrado y ))) ( check-equal? ( suma-cuadrados 10 10 ) 200 ) ( check-equal? ( suma-cuadrados -2 9 ) 85 ) ;; ;; Ejercicio 2: ;; ... En los casos de prueba se deben incluir los ejemplos del enunciado del ejercicio. Ejercicios \u00b6 Ejercicio 1 \u00b6 a) Implementa la funci\u00f3n (binario-a-decimal b3 b2 b1 b0) que reciba 4 bits que representan un n\u00famero en binario y devuelva el n\u00famero decimal equivalente. 1 2 3 ( binario-a-decimal 1 1 1 1 ) ; \u21d2 15 ( binario-a-decimal 0 1 1 0 ) ; \u21d2 6 ( binario-a-decimal 0 0 1 0 ) ; \u21d2 2 Nota : recuerda que para realizar esta conversi\u00f3n, se utiliza la siguiente f\u00f3rmula: 1 n = b3 * 2\u02c63 + b2 * 2\u02c62 + b1 * 2\u02c61 + b0 * 2\u02c60 Para la implementaci\u00f3n de la expresi\u00f3n debes utilizar la funci\u00f3n expt . b) Implementa la funci\u00f3n (binario-a-hexadecimal b3 b2 b1 b0) que reciba 4 bits de un n\u00famero representado en binario y devuelva el car\u00e1cter correspondiente a su representaci\u00f3n en hexadecimal. 1 2 3 ( binario-a-hexadecimal 1 1 1 1 ) ; \u21d2 #\\F ( binario-a-hexadecimal 0 1 1 0 ) ; \u21d2 #\\6 ( binario-a-hexadecimal 1 0 1 0 ) ; \u21d2 #\\A Nota : para realizar esta conversi\u00f3n, como paso intermedio debes pasar primero el n\u00famero binario a su representaci\u00f3n decimal (utilizando la funci\u00f3n definida en el apartado anterior) y despu\u00e9s a su correspondiente hexadecimal. Recuerda que la representaci\u00f3n hexadecimal de los n\u00fameros decimales del 0 al 9 es el car\u00e1cter correspondiente a ese n\u00famero, y que el n\u00famero decimal 10 se representa con el car\u00e1cter A, el 11 con el B, y as\u00ed sucesivamente hasta el 15 que es el F en hexadecimal. Para la implementaci\u00f3n de esta funci\u00f3n auxiliar que pasa de decimal a hexadecimal debes usar las funciones integer->char y char->integer . En la funci\u00f3n char->integer los caracteres consecutivos est\u00e1n asociados con n\u00fameros consecutivos. Por ejemplo, el entero correspondiente al car\u00e1cter #\\A es uno menos que el correspondiente al car\u00e1cter #\\B . Los caracteres de n\u00fameros y los de letras no son consecutivos. Ejercicio 2 \u00b6 Implementa la funci\u00f3n (menor-de-tres n1 n2 n3) que reciba tres n\u00fameros como argumento y devuelva el menor de los tres, intentando que el n\u00famero de condiciones sea m\u00ednima. No debes utilizar la funci\u00f3n min . Implementa dos versiones de la funci\u00f3n: versi\u00f3n 1: usando la forma especial if versi\u00f3n 2 (ll\u00e1mala menor-de-tres-v2 ): definiendo una funci\u00f3n auxiliar (menor x y) que devuelva el menor de dos n\u00fameros (deber\u00e1s usar tambi\u00e9n la forma especial if para implementarla) y construyendo la funci\u00f3n menor-de-tres-v2 como una composici\u00f3n de llamadas a esta funci\u00f3n auxiliar. 1 2 ( menor-de-tres 2 8 1 ) ;; \u21d2 1 ( menor-de-tres-v2 3 0 3 ) ;; \u21d2 0 Ejercicio 3 \u00b6 a) Supongamos las definiciones 1 2 3 4 5 ( define ( f x y ) ( cons x y )) ( define ( g x ) ( cons 2 x )) Realiza la evaluaci\u00f3n paso a paso de la siguiente expresi\u00f3n 1 ( f ( g ( + 2 1 )) ( + 1 1 )) mediante el modelo de sustituci\u00f3n , utilizando tanto el orden aplicativo y como el orden normal . Escribe la soluci\u00f3n entre comentarios en el propio fichero .rkt de la pr\u00e1ctica. b) Supongamos las definiciones 1 2 3 4 5 6 7 ( define ( f x ) ( / x 0 )) ( define ( g x y ) ( if ( = x 0 ) 0 y )) Igual que en el apartado anterior, realiza la evaluaci\u00f3n paso a paso de la siguiente expresi\u00f3n 1 ( g 0 ( f 10 )) mediante el modelo de sustituci\u00f3n , utilizando tanto el orden aplicativo y como el orden normal . Y escribe la soluci\u00f3n entre comentarios en el propio fichero .rkt de la pr\u00e1ctica. Ejercicio 4 \u00b6 Implementa la funci\u00f3n (tirada-ganadora t1 t2) que reciba 2 parejas como argumento, donde cada pareja representa una tirada con 2 dados (contiene dos n\u00fameros). La funci\u00f3n debe determinar qu\u00e9 tirada es la ganadora, teniendo en cuenta que ser\u00e1 aquella cuya suma de sus 2 dados est\u00e9 m\u00e1s pr\u00f3xima al n\u00famero 7. La funci\u00f3n devolver\u00e1 1 si t1 es la ganadora, 2 si t2 es la ganadora o bien 0 si hay un empate. Este \u00faltimo caso se producir\u00e1 cuando la diferencia con 7 de ambas tiradas es la misma. 1 2 3 ( tirada-ganadora ( cons 1 3 ) ( cons 1 6 )) ; \u21d2 2 ( tirada-ganadora ( cons 1 5 ) ( cons 2 2 )) ; \u21d2 1 ( tirada-ganadora ( cons 6 2 ) ( cons 3 3 )) ; \u21d2 0 Ejercicio 5 \u00b6 Supongamos que queremos programar un juego de cartas. Lo primero que debemos hacer es definir una forma de representar las cartas y funciones que trabajen con esa representaci\u00f3n. En este ejercicio vamos a implementar esas funciones. Representaremos una carta por un s\u00edmbolo con dos letras: la primera indicar\u00e1 su n\u00famero o figura y la segunda el palo de la carta. Por ejemplo: 1 2 3 ( define tres-de-oros ' 3O ) ( define as-de-copas ' AC ) ( define caballo-de-espadas ' CE ) Debemos definir la funci\u00f3n carta que devuelve una pareja con el valor correspondiente a su orden en la baraja espa\u00f1ola (un n\u00famero) y el palo de la carta (un s\u00edmbolo). 1 2 3 ( carta tres-de-oros ) ; \u21d2 (3 . Oros) ( carta as-de-copas ) ; \u21d2 (1 . Copas) ( carta ' RB ) ; \u21d2 (12 . Bastos) Los valores de las cartas de la baraja espa\u00f1ola son: 1 2 3 4 A (As) \u21d2 1 S (Sota) \u21d2 10 C (Caballo) \u21d2 11 R (Rey) \u21d2 12 Para realizar el ejercicio debes definir en primer lugar las funciones (obten-palo char) y (obten-valor char) que devuelven el palo y el valor, dado un car\u00e1cter. Y debes implementar la funci\u00f3n carta usando estas dos funciones. 1 2 3 4 ( obten-palo #\\O ) ; \u21d2 Oros ( obten-palo #\\E ) ; \u21d2 Espadas ( obten-valor #\\3 ) ; \u21d2 3 ( obten-valor #\\S ) ; \u21d2 10 Pista Puedes utilizar las funciones (symbol->string simbolo) que convierte un s\u00edmbolo en una cadena y (string-ref cadena pos) que devuelve el car\u00e1cter de una cadena situado en una determinada posici\u00f3n. Ejercicio 6 \u00b6 Define la funci\u00f3n tipo-triangulo que recibe como par\u00e1metro las coordenadas en el plano de los v\u00e9rtices de un tri\u00e1ngulo representados con parejas. La funci\u00f3n devuelve una cadena con el tipo de tri\u00e1ngulo correspondiente: equil\u00e1tero, is\u00f3sceles o escaleno. Recuerda que un tri\u00e1ngulo equil\u00e1tero es aquel cuyos tres lados tienen la misma longitud, el is\u00f3sceles el que tiene dos lados iguales y el escaleno el que todos sus lados son diferentes. Ejemplos: 1 2 3 ( tipo-triangulo ( cons 1 1 ) ( cons 1 6 ) ( cons 6 1 )) ; \u21d2 \"is\u00f3sceles\" ( tipo-triangulo ( cons -2 3 ) ( cons 2 6 ) ( cons 5 3 )) ; \u21d2 \"escaleno\" ( tipo-triangulo ( cons -3 0 ) ( cons 3 0 ) ( cons 0 5.1961 )) ; \u21d2 \"equilatero\" Nota Para comparar dos n\u00fameros reales debemos comprobar si la resta entre ambos es menor que una constante epsilon que hemos definido. Por ejemplo, epsilon puede valer 0.0001. Puedes usar la siguiente funci\u00f3n auxiliar: 1 2 3 4 ( define epsilon 0.0001 ) ( define ( iguales-reales? x y ) ( < ( abs ( - x y )) epsilon )) Lenguajes y Paradigmas de Programaci\u00f3n, curso 2019-20 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Domingo Gallardo, Cristina Pomares, Antonio Bot\u00eda, Francisco Mart\u00ednez","title":"Pr\u00e1ctica 1"},{"location":"practicas/practica01/practica01.html#practica-1-programacion-funcional-en-scheme","text":"","title":"Pr\u00e1ctica 1: Programaci\u00f3n funcional en Scheme"},{"location":"practicas/practica01/practica01.html#entrega-de-la-practica","text":"Para entregar la pr\u00e1ctica debes subir a Moodle el fichero practica01.rkt con una cabecera inicial con tu nombre y apellidos, y las soluciones de cada ejercicio separadas por comentarios. Cada soluci\u00f3n debe incluir: La definici\u00f3n de las funciones que resuelven el ejercicio. Un conjunto de pruebas que comprueben su funcionamiento, y el de funciones auxiliares que hayamos definido, utilizando el API RackUnit. Por ejemplo, supongamos que el primer ejercicio de la pr\u00e1ctica 1 sea implementar la funci\u00f3n suma-cuadrados que recibe dos n\u00fameros y devuelve la suma de sus cuadrados y se proponen en el enunciado los siguientes ejemplos: 1 2 ( suma-cuadrados 10 10 ) ; \u21d2 200 ( suma-cuadrados -2 9 ) ; \u21d2 85 La soluci\u00f3n se deber\u00eda entregar de la siguiente forma: practica01.rkt : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 ;; Jos\u00e9 Fernandez Mu\u00f1oz #lang racket ( require rackunit ) ;; ;; Ejercicio 1: suma-cuadrados ;; ;; Funci\u00f3n auxiliar cuadrado ( define ( cuadrado x ) ( * x x )) ( check-equal? ( cuadrado 2 ) 4 ) ( check-equal? ( cuadrado 10 ) 100 ) ( check-equal? ( cuadrado -2 ) 4 ) ;; Funci\u00f3n principal suma-cuadrados ( define ( suma-cuadrados x y ) ( + ( cuadrado x ) ( cuadrado y ))) ( check-equal? ( suma-cuadrados 10 10 ) 200 ) ( check-equal? ( suma-cuadrados -2 9 ) 85 ) ;; ;; Ejercicio 2: ;; ... En los casos de prueba se deben incluir los ejemplos del enunciado del ejercicio.","title":"Entrega de la pr\u00e1ctica"},{"location":"practicas/practica01/practica01.html#ejercicios","text":"","title":"Ejercicios"},{"location":"practicas/practica01/practica01.html#ejercicio-1","text":"a) Implementa la funci\u00f3n (binario-a-decimal b3 b2 b1 b0) que reciba 4 bits que representan un n\u00famero en binario y devuelva el n\u00famero decimal equivalente. 1 2 3 ( binario-a-decimal 1 1 1 1 ) ; \u21d2 15 ( binario-a-decimal 0 1 1 0 ) ; \u21d2 6 ( binario-a-decimal 0 0 1 0 ) ; \u21d2 2 Nota : recuerda que para realizar esta conversi\u00f3n, se utiliza la siguiente f\u00f3rmula: 1 n = b3 * 2\u02c63 + b2 * 2\u02c62 + b1 * 2\u02c61 + b0 * 2\u02c60 Para la implementaci\u00f3n de la expresi\u00f3n debes utilizar la funci\u00f3n expt . b) Implementa la funci\u00f3n (binario-a-hexadecimal b3 b2 b1 b0) que reciba 4 bits de un n\u00famero representado en binario y devuelva el car\u00e1cter correspondiente a su representaci\u00f3n en hexadecimal. 1 2 3 ( binario-a-hexadecimal 1 1 1 1 ) ; \u21d2 #\\F ( binario-a-hexadecimal 0 1 1 0 ) ; \u21d2 #\\6 ( binario-a-hexadecimal 1 0 1 0 ) ; \u21d2 #\\A Nota : para realizar esta conversi\u00f3n, como paso intermedio debes pasar primero el n\u00famero binario a su representaci\u00f3n decimal (utilizando la funci\u00f3n definida en el apartado anterior) y despu\u00e9s a su correspondiente hexadecimal. Recuerda que la representaci\u00f3n hexadecimal de los n\u00fameros decimales del 0 al 9 es el car\u00e1cter correspondiente a ese n\u00famero, y que el n\u00famero decimal 10 se representa con el car\u00e1cter A, el 11 con el B, y as\u00ed sucesivamente hasta el 15 que es el F en hexadecimal. Para la implementaci\u00f3n de esta funci\u00f3n auxiliar que pasa de decimal a hexadecimal debes usar las funciones integer->char y char->integer . En la funci\u00f3n char->integer los caracteres consecutivos est\u00e1n asociados con n\u00fameros consecutivos. Por ejemplo, el entero correspondiente al car\u00e1cter #\\A es uno menos que el correspondiente al car\u00e1cter #\\B . Los caracteres de n\u00fameros y los de letras no son consecutivos.","title":"Ejercicio 1"},{"location":"practicas/practica01/practica01.html#ejercicio-2","text":"Implementa la funci\u00f3n (menor-de-tres n1 n2 n3) que reciba tres n\u00fameros como argumento y devuelva el menor de los tres, intentando que el n\u00famero de condiciones sea m\u00ednima. No debes utilizar la funci\u00f3n min . Implementa dos versiones de la funci\u00f3n: versi\u00f3n 1: usando la forma especial if versi\u00f3n 2 (ll\u00e1mala menor-de-tres-v2 ): definiendo una funci\u00f3n auxiliar (menor x y) que devuelva el menor de dos n\u00fameros (deber\u00e1s usar tambi\u00e9n la forma especial if para implementarla) y construyendo la funci\u00f3n menor-de-tres-v2 como una composici\u00f3n de llamadas a esta funci\u00f3n auxiliar. 1 2 ( menor-de-tres 2 8 1 ) ;; \u21d2 1 ( menor-de-tres-v2 3 0 3 ) ;; \u21d2 0","title":"Ejercicio 2"},{"location":"practicas/practica01/practica01.html#ejercicio-3","text":"a) Supongamos las definiciones 1 2 3 4 5 ( define ( f x y ) ( cons x y )) ( define ( g x ) ( cons 2 x )) Realiza la evaluaci\u00f3n paso a paso de la siguiente expresi\u00f3n 1 ( f ( g ( + 2 1 )) ( + 1 1 )) mediante el modelo de sustituci\u00f3n , utilizando tanto el orden aplicativo y como el orden normal . Escribe la soluci\u00f3n entre comentarios en el propio fichero .rkt de la pr\u00e1ctica. b) Supongamos las definiciones 1 2 3 4 5 6 7 ( define ( f x ) ( / x 0 )) ( define ( g x y ) ( if ( = x 0 ) 0 y )) Igual que en el apartado anterior, realiza la evaluaci\u00f3n paso a paso de la siguiente expresi\u00f3n 1 ( g 0 ( f 10 )) mediante el modelo de sustituci\u00f3n , utilizando tanto el orden aplicativo y como el orden normal . Y escribe la soluci\u00f3n entre comentarios en el propio fichero .rkt de la pr\u00e1ctica.","title":"Ejercicio 3"},{"location":"practicas/practica01/practica01.html#ejercicio-4","text":"Implementa la funci\u00f3n (tirada-ganadora t1 t2) que reciba 2 parejas como argumento, donde cada pareja representa una tirada con 2 dados (contiene dos n\u00fameros). La funci\u00f3n debe determinar qu\u00e9 tirada es la ganadora, teniendo en cuenta que ser\u00e1 aquella cuya suma de sus 2 dados est\u00e9 m\u00e1s pr\u00f3xima al n\u00famero 7. La funci\u00f3n devolver\u00e1 1 si t1 es la ganadora, 2 si t2 es la ganadora o bien 0 si hay un empate. Este \u00faltimo caso se producir\u00e1 cuando la diferencia con 7 de ambas tiradas es la misma. 1 2 3 ( tirada-ganadora ( cons 1 3 ) ( cons 1 6 )) ; \u21d2 2 ( tirada-ganadora ( cons 1 5 ) ( cons 2 2 )) ; \u21d2 1 ( tirada-ganadora ( cons 6 2 ) ( cons 3 3 )) ; \u21d2 0","title":"Ejercicio 4"},{"location":"practicas/practica01/practica01.html#ejercicio-5","text":"Supongamos que queremos programar un juego de cartas. Lo primero que debemos hacer es definir una forma de representar las cartas y funciones que trabajen con esa representaci\u00f3n. En este ejercicio vamos a implementar esas funciones. Representaremos una carta por un s\u00edmbolo con dos letras: la primera indicar\u00e1 su n\u00famero o figura y la segunda el palo de la carta. Por ejemplo: 1 2 3 ( define tres-de-oros ' 3O ) ( define as-de-copas ' AC ) ( define caballo-de-espadas ' CE ) Debemos definir la funci\u00f3n carta que devuelve una pareja con el valor correspondiente a su orden en la baraja espa\u00f1ola (un n\u00famero) y el palo de la carta (un s\u00edmbolo). 1 2 3 ( carta tres-de-oros ) ; \u21d2 (3 . Oros) ( carta as-de-copas ) ; \u21d2 (1 . Copas) ( carta ' RB ) ; \u21d2 (12 . Bastos) Los valores de las cartas de la baraja espa\u00f1ola son: 1 2 3 4 A (As) \u21d2 1 S (Sota) \u21d2 10 C (Caballo) \u21d2 11 R (Rey) \u21d2 12 Para realizar el ejercicio debes definir en primer lugar las funciones (obten-palo char) y (obten-valor char) que devuelven el palo y el valor, dado un car\u00e1cter. Y debes implementar la funci\u00f3n carta usando estas dos funciones. 1 2 3 4 ( obten-palo #\\O ) ; \u21d2 Oros ( obten-palo #\\E ) ; \u21d2 Espadas ( obten-valor #\\3 ) ; \u21d2 3 ( obten-valor #\\S ) ; \u21d2 10 Pista Puedes utilizar las funciones (symbol->string simbolo) que convierte un s\u00edmbolo en una cadena y (string-ref cadena pos) que devuelve el car\u00e1cter de una cadena situado en una determinada posici\u00f3n.","title":"Ejercicio 5"},{"location":"practicas/practica01/practica01.html#ejercicio-6","text":"Define la funci\u00f3n tipo-triangulo que recibe como par\u00e1metro las coordenadas en el plano de los v\u00e9rtices de un tri\u00e1ngulo representados con parejas. La funci\u00f3n devuelve una cadena con el tipo de tri\u00e1ngulo correspondiente: equil\u00e1tero, is\u00f3sceles o escaleno. Recuerda que un tri\u00e1ngulo equil\u00e1tero es aquel cuyos tres lados tienen la misma longitud, el is\u00f3sceles el que tiene dos lados iguales y el escaleno el que todos sus lados son diferentes. Ejemplos: 1 2 3 ( tipo-triangulo ( cons 1 1 ) ( cons 1 6 ) ( cons 6 1 )) ; \u21d2 \"is\u00f3sceles\" ( tipo-triangulo ( cons -2 3 ) ( cons 2 6 ) ( cons 5 3 )) ; \u21d2 \"escaleno\" ( tipo-triangulo ( cons -3 0 ) ( cons 3 0 ) ( cons 0 5.1961 )) ; \u21d2 \"equilatero\" Nota Para comparar dos n\u00fameros reales debemos comprobar si la resta entre ambos es menor que una constante epsilon que hemos definido. Por ejemplo, epsilon puede valer 0.0001. Puedes usar la siguiente funci\u00f3n auxiliar: 1 2 3 4 ( define epsilon 0.0001 ) ( define ( iguales-reales? x y ) ( < ( abs ( - x y )) epsilon )) Lenguajes y Paradigmas de Programaci\u00f3n, curso 2019-20 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Domingo Gallardo, Cristina Pomares, Antonio Bot\u00eda, Francisco Mart\u00ednez","title":"Ejercicio 6"},{"location":"practicas/practica02/practica02.html","text":"Pr\u00e1ctica 2: Recursi\u00f3n, parejas y diagramas box-and-pointer \u00b6 Entrega de la pr\u00e1ctica \u00b6 Para entregar la pr\u00e1ctica debes subir a Moodle el fichero practica02.rkt con una cabecera inicial con tu nombre y apellidos, y las soluciones de cada ejercicio separadas por comentarios. Cada soluci\u00f3n debe incluir: La definici\u00f3n de las funciones que resuelven el ejercicio. Un conjunto de pruebas que comprueben su funcionamiento utilizando el API RackUnit . Ejercicios \u00b6 Ejercicio 1 \u00b6 a.1) Implementa la funci\u00f3n recursiva (minimo lista) que recibe una lista con n\u00fameros como argumento y devuelve el menor n\u00famero de la lista. Suponemos listas de 1 o m\u00e1s elementos. Para la implementaci\u00f3n debes usar la funci\u00f3n menor definida en la pr\u00e1ctica anterior. Pista Podemos expresar el caso general de la recursi\u00f3n de la siguiente forma: El m\u00ednimo de los elementos de una lista es el menor entre el primer elemento de la lista y el m\u00ednimo del resto de la lista. Y el caso base: El m\u00ednimo de una lista con un \u00fanico n\u00famero es ese n\u00famero. Ejemplos: 1 2 ( minimo ' ( 1 8 6 4 3 )) ; \u21d2 1 ( minimo ' ( 1 -1 3 -6 4 )) ; \u21d2 -6 a.2) Vamos a investigar el funcionamiento de la recursi\u00f3n en la funci\u00f3n minimo . Supongamos la siguiente llamada: 1 ( minimo ' ( 1 8 6 4 3 )) ; \u21d2 1 \u00bfQu\u00e9 lista se pasa como par\u00e1metro a la primera llamada recursiva a la funci\u00f3n? \u00bfQu\u00e9 devuelve esa llamada recursiva? \u00bfCon qu\u00e9 argumentos se llama a la funci\u00f3n menor que devuelve el resultado final? b) Implementa la funci\u00f3n recursiva (concatena lista-chars) que recibe una lista de caracteres y devuelve la cadena resultante de concatenarlos. Ejemplos: 1 2 3 ( concatena ' ( #\\H #\\o #\\l #\\a )) ; \u21d2 \"Hola\" ( concatena ' ( #\\S #\\c #\\h #\\e #\\m #\\e #\\space #\\m #\\o #\\l #\\a )) ; \u21d2 \"Scheme mola\" c) Implementa la funci\u00f3n (contiene? cadena char) que comprueba si una cadena contiene un car\u00e1cter determinado. Debes usar la funci\u00f3n string->list e implementar la funci\u00f3n auxiliar recursiva (contiene-lista? lista dato) . Ejemplos: 1 2 3 ( contiene? \"Hola\" #\\o ) ; \u21d2 #t ( contiene? \"Esto es una frase\" #\\space ) ; \u21d2 #t ( contiene? \"Hola\" #\\h ) ; \u21d2 #f Ejercicio 2 \u00b6 a) Implementa la funci\u00f3n recursiva (binario-a-decimal lista-bits) que reciba una lista de bits que representan un n\u00famero en binario (el primer elemento ser\u00e1 el bit m\u00e1s significativo) y devuelva el n\u00famero decimal equivalente. Pista Puedes utilizar la funci\u00f3n length . 1 2 3 ( binario-a-decimal ' ( 1 1 1 1 )) ; \u21d2 15 ( binario-a-decimal ' ( 1 1 0 )) ; \u21d2 6 ( binario-a-decimal ' ( 1 0 )) ; \u21d2 2 b) Implementa la funci\u00f3n recursiva (ordenada-creciente? lista-nums) que recibe como argumento una lista de n\u00fameros y devuelve #t si los n\u00fameros de la lista est\u00e1n ordenados de forma creciente o #f en caso contrario. Suponemos listas de 1 o m\u00e1s elementos. 1 2 3 ( ordenada-creciente? ' ( -1 23 45 59 99 )) ; \u21d2 #t ( ordenada-creciente? ' ( 12 50 -1 293 1000 )) ; \u21d2 #f ( ordenada-creciente? ' ( 3 )) ; \u21d2 #t Ejercicio 3 \u00b6 a.1) Dado el siguiente box & pointer , escribe la expresi\u00f3n en Scheme que define p1 usando el m\u00ednimo n\u00famero de llamadas a list y cons . No debes utilizar expresiones con quote . a.2) Escribe las expresiones que devuelven 2 y 4 a partir de p1 . b.1) Dado el siguiente diagrama caja y puntero, escribe la expresi\u00f3n en Scheme que define p2 usando el m\u00ednimo n\u00famero de llamadas a list y cons . b.2) Escribe las expresiones que devuelven 9 y 2 a partir de p2 . Ejercicio 4 \u00b6 Vamos a programar una versi\u00f3n simplificada del blackjack o 21. Dos jugadores juegan un n\u00famero de cartas y suman todos sus valores. Gana el que se acerque m\u00e1s al 21 sin pasarse. Representaremos las cartas como en la pr\u00e1ctica 1, y podemos usar las funciones all\u00ed definidas para obtener su valor. Suponemos que el valor es el propio de la carta (no seguiremos la regla del juego original en el que las figuras valen 10). Cada jugador tendr\u00e1 una lista de cartas y deber\u00e1 indicar un n\u00famero n que representa el n\u00famero de cartas de esa lista con las que se queda. Tendremos que implementar la funci\u00f3n (blackjack cartas1 n1 cartas2 n2) que recibe la lista de cartas del jugador 1, el n\u00famero de cartas que se queda el jugador 1, la lista de cartas del jugador 2 y el n\u00famero de cartas del jugador 2. Por ejemplo, supongamos las siguientes cartas del jugador 1 y del jugador 2: 1 2 ( define cartas1 ' ( 3O 5E AC 2B 5O 5C 4B )) ( define cartas2 ' ( CE AO 3B AC 2E SC 4C )) Supongamos que el jugador 1 se queda con 5 cartas de su lista y el jugador 2 con 3. Las primeras 5 cartas del jugador 1 suman 16 y las 3 primeras cartas del jugador 2 suman 15. Ganar\u00eda el jugador 1. 1 ( blackjack cartas1 5 cartas2 3 ) ; \u21d2 1 La funci\u00f3n blackjack devolver\u00e1 1 si gana el jugador 1, 2 si gana el jugador 2, 0 si empatan y -1 si los dos jugadores se pasan de 21. Debes implementar la funci\u00f3n blackjack y una funci\u00f3n auxiliar recursiva que sea la que sume los valores de las n primeras cartas de una lista. Si n es mayor que el n\u00famero de cartas, devolver\u00e1 la suma de todas las cartas de la lista. Puedes definir cualquier otra funci\u00f3n auxiliar que necesites. Otros ejemplos: 1 2 3 4 ( blackjack cartas1 5 cartas2 4 ) ; \u21d2 0 ( blackjack cartas1 5 cartas2 3 ) ; \u21d2 1 ( blackjack cartas1 3 cartas2 4 ) ; \u21d2 2 ( blackjack cartas1 7 cartas2 6 ) ; \u21d2 -1 Ejercicio 5 \u00b6 a) Implementa las funciones (suma-izq pareja n) y (suma-der pareja n) definidas de la siguiente forma: (suma-izq pareja n) : devuelve una nueva pareja con la parte izquierda incrementada en n . (suma-der pareja n) : devuelve una nueva pareja con la parte derecha incrementada en n . Ejemplos: 1 2 ( suma-izq ( cons 10 20 ) 3 ) ; \u21d2 (13 . 20) ( suma-der ( cons 10 20 ) 5 ) ; \u21d2 (10 . 25) b) Implementa la funci\u00f3n recursiva (suma-impares-pares lista-num) que devuelva una pareja cuya parte izquierda sea la suma de los n\u00fameros impares de la lista y la parte derecha la suma de los n\u00fameros pares. Debes utilizar las funciones auxiliares definidas en el apartado anterior. Tambi\u00e9n puedes utilizar las funciones predefinidas even? y odd? . Ejemplos: 1 2 ( suma-impares-pares ' ( 3 2 1 4 8 7 6 5 )) ; \u21d2 (16 . 20) ( suma-impares-pares ' ( 3 1 5 )) ; \u21d2 (9 . 0) Ejercicio 6 \u00b6 Implementa la funci\u00f3n recursiva (cadena-mayor lista) que recibe un lista de cadenas y devuelve una pareja con la cadena de mayor longitud y dicha longitud. En el caso de que haya m\u00e1s de una cadena con la m\u00e1xima longitud, se devolver\u00e1 la \u00faltima de ellas que aparezca en la lista. En el caso en que la lista sea vac\u00eda se devolver\u00e1 la pareja con la cadena vac\u00eda y un 0 (la longitud de la cadena vac\u00eda). Pista : puedes utilizar la funci\u00f3n string-length 1 2 3 ( cadena-mayor ' ( \"vamos\" \"a\" \"obtener\" \"la\" \"cadena\" \"mayor\" )) ; \u21d2 (\"obtener\" . 7) ( cadena-mayor ' ( \"prueba\" \"con\" \"maximo\" \"igual\" )) ; \u21d2 (\"maximo\" . 6) ( cadena-mayor ' ()) ; \u21d2 (\"\" . 0) Lenguajes y Paradigmas de Programaci\u00f3n, curso 2019-20 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Domingo Gallardo, Cristina Pomares, Antonio Bot\u00eda, Francisco Mart\u00ednez","title":"Pr\u00e1ctica 2"},{"location":"practicas/practica02/practica02.html#practica-2-recursion-parejas-y-diagramas-box-and-pointer","text":"","title":"Pr\u00e1ctica 2: Recursi\u00f3n, parejas y diagramas box-and-pointer"},{"location":"practicas/practica02/practica02.html#entrega-de-la-practica","text":"Para entregar la pr\u00e1ctica debes subir a Moodle el fichero practica02.rkt con una cabecera inicial con tu nombre y apellidos, y las soluciones de cada ejercicio separadas por comentarios. Cada soluci\u00f3n debe incluir: La definici\u00f3n de las funciones que resuelven el ejercicio. Un conjunto de pruebas que comprueben su funcionamiento utilizando el API RackUnit .","title":"Entrega de la pr\u00e1ctica"},{"location":"practicas/practica02/practica02.html#ejercicios","text":"","title":"Ejercicios"},{"location":"practicas/practica02/practica02.html#ejercicio-1","text":"a.1) Implementa la funci\u00f3n recursiva (minimo lista) que recibe una lista con n\u00fameros como argumento y devuelve el menor n\u00famero de la lista. Suponemos listas de 1 o m\u00e1s elementos. Para la implementaci\u00f3n debes usar la funci\u00f3n menor definida en la pr\u00e1ctica anterior. Pista Podemos expresar el caso general de la recursi\u00f3n de la siguiente forma: El m\u00ednimo de los elementos de una lista es el menor entre el primer elemento de la lista y el m\u00ednimo del resto de la lista. Y el caso base: El m\u00ednimo de una lista con un \u00fanico n\u00famero es ese n\u00famero. Ejemplos: 1 2 ( minimo ' ( 1 8 6 4 3 )) ; \u21d2 1 ( minimo ' ( 1 -1 3 -6 4 )) ; \u21d2 -6 a.2) Vamos a investigar el funcionamiento de la recursi\u00f3n en la funci\u00f3n minimo . Supongamos la siguiente llamada: 1 ( minimo ' ( 1 8 6 4 3 )) ; \u21d2 1 \u00bfQu\u00e9 lista se pasa como par\u00e1metro a la primera llamada recursiva a la funci\u00f3n? \u00bfQu\u00e9 devuelve esa llamada recursiva? \u00bfCon qu\u00e9 argumentos se llama a la funci\u00f3n menor que devuelve el resultado final? b) Implementa la funci\u00f3n recursiva (concatena lista-chars) que recibe una lista de caracteres y devuelve la cadena resultante de concatenarlos. Ejemplos: 1 2 3 ( concatena ' ( #\\H #\\o #\\l #\\a )) ; \u21d2 \"Hola\" ( concatena ' ( #\\S #\\c #\\h #\\e #\\m #\\e #\\space #\\m #\\o #\\l #\\a )) ; \u21d2 \"Scheme mola\" c) Implementa la funci\u00f3n (contiene? cadena char) que comprueba si una cadena contiene un car\u00e1cter determinado. Debes usar la funci\u00f3n string->list e implementar la funci\u00f3n auxiliar recursiva (contiene-lista? lista dato) . Ejemplos: 1 2 3 ( contiene? \"Hola\" #\\o ) ; \u21d2 #t ( contiene? \"Esto es una frase\" #\\space ) ; \u21d2 #t ( contiene? \"Hola\" #\\h ) ; \u21d2 #f","title":"Ejercicio 1"},{"location":"practicas/practica02/practica02.html#ejercicio-2","text":"a) Implementa la funci\u00f3n recursiva (binario-a-decimal lista-bits) que reciba una lista de bits que representan un n\u00famero en binario (el primer elemento ser\u00e1 el bit m\u00e1s significativo) y devuelva el n\u00famero decimal equivalente. Pista Puedes utilizar la funci\u00f3n length . 1 2 3 ( binario-a-decimal ' ( 1 1 1 1 )) ; \u21d2 15 ( binario-a-decimal ' ( 1 1 0 )) ; \u21d2 6 ( binario-a-decimal ' ( 1 0 )) ; \u21d2 2 b) Implementa la funci\u00f3n recursiva (ordenada-creciente? lista-nums) que recibe como argumento una lista de n\u00fameros y devuelve #t si los n\u00fameros de la lista est\u00e1n ordenados de forma creciente o #f en caso contrario. Suponemos listas de 1 o m\u00e1s elementos. 1 2 3 ( ordenada-creciente? ' ( -1 23 45 59 99 )) ; \u21d2 #t ( ordenada-creciente? ' ( 12 50 -1 293 1000 )) ; \u21d2 #f ( ordenada-creciente? ' ( 3 )) ; \u21d2 #t","title":"Ejercicio 2"},{"location":"practicas/practica02/practica02.html#ejercicio-3","text":"a.1) Dado el siguiente box & pointer , escribe la expresi\u00f3n en Scheme que define p1 usando el m\u00ednimo n\u00famero de llamadas a list y cons . No debes utilizar expresiones con quote . a.2) Escribe las expresiones que devuelven 2 y 4 a partir de p1 . b.1) Dado el siguiente diagrama caja y puntero, escribe la expresi\u00f3n en Scheme que define p2 usando el m\u00ednimo n\u00famero de llamadas a list y cons . b.2) Escribe las expresiones que devuelven 9 y 2 a partir de p2 .","title":"Ejercicio 3"},{"location":"practicas/practica02/practica02.html#ejercicio-4","text":"Vamos a programar una versi\u00f3n simplificada del blackjack o 21. Dos jugadores juegan un n\u00famero de cartas y suman todos sus valores. Gana el que se acerque m\u00e1s al 21 sin pasarse. Representaremos las cartas como en la pr\u00e1ctica 1, y podemos usar las funciones all\u00ed definidas para obtener su valor. Suponemos que el valor es el propio de la carta (no seguiremos la regla del juego original en el que las figuras valen 10). Cada jugador tendr\u00e1 una lista de cartas y deber\u00e1 indicar un n\u00famero n que representa el n\u00famero de cartas de esa lista con las que se queda. Tendremos que implementar la funci\u00f3n (blackjack cartas1 n1 cartas2 n2) que recibe la lista de cartas del jugador 1, el n\u00famero de cartas que se queda el jugador 1, la lista de cartas del jugador 2 y el n\u00famero de cartas del jugador 2. Por ejemplo, supongamos las siguientes cartas del jugador 1 y del jugador 2: 1 2 ( define cartas1 ' ( 3O 5E AC 2B 5O 5C 4B )) ( define cartas2 ' ( CE AO 3B AC 2E SC 4C )) Supongamos que el jugador 1 se queda con 5 cartas de su lista y el jugador 2 con 3. Las primeras 5 cartas del jugador 1 suman 16 y las 3 primeras cartas del jugador 2 suman 15. Ganar\u00eda el jugador 1. 1 ( blackjack cartas1 5 cartas2 3 ) ; \u21d2 1 La funci\u00f3n blackjack devolver\u00e1 1 si gana el jugador 1, 2 si gana el jugador 2, 0 si empatan y -1 si los dos jugadores se pasan de 21. Debes implementar la funci\u00f3n blackjack y una funci\u00f3n auxiliar recursiva que sea la que sume los valores de las n primeras cartas de una lista. Si n es mayor que el n\u00famero de cartas, devolver\u00e1 la suma de todas las cartas de la lista. Puedes definir cualquier otra funci\u00f3n auxiliar que necesites. Otros ejemplos: 1 2 3 4 ( blackjack cartas1 5 cartas2 4 ) ; \u21d2 0 ( blackjack cartas1 5 cartas2 3 ) ; \u21d2 1 ( blackjack cartas1 3 cartas2 4 ) ; \u21d2 2 ( blackjack cartas1 7 cartas2 6 ) ; \u21d2 -1","title":"Ejercicio 4"},{"location":"practicas/practica02/practica02.html#ejercicio-5","text":"a) Implementa las funciones (suma-izq pareja n) y (suma-der pareja n) definidas de la siguiente forma: (suma-izq pareja n) : devuelve una nueva pareja con la parte izquierda incrementada en n . (suma-der pareja n) : devuelve una nueva pareja con la parte derecha incrementada en n . Ejemplos: 1 2 ( suma-izq ( cons 10 20 ) 3 ) ; \u21d2 (13 . 20) ( suma-der ( cons 10 20 ) 5 ) ; \u21d2 (10 . 25) b) Implementa la funci\u00f3n recursiva (suma-impares-pares lista-num) que devuelva una pareja cuya parte izquierda sea la suma de los n\u00fameros impares de la lista y la parte derecha la suma de los n\u00fameros pares. Debes utilizar las funciones auxiliares definidas en el apartado anterior. Tambi\u00e9n puedes utilizar las funciones predefinidas even? y odd? . Ejemplos: 1 2 ( suma-impares-pares ' ( 3 2 1 4 8 7 6 5 )) ; \u21d2 (16 . 20) ( suma-impares-pares ' ( 3 1 5 )) ; \u21d2 (9 . 0)","title":"Ejercicio 5"},{"location":"practicas/practica02/practica02.html#ejercicio-6","text":"Implementa la funci\u00f3n recursiva (cadena-mayor lista) que recibe un lista de cadenas y devuelve una pareja con la cadena de mayor longitud y dicha longitud. En el caso de que haya m\u00e1s de una cadena con la m\u00e1xima longitud, se devolver\u00e1 la \u00faltima de ellas que aparezca en la lista. En el caso en que la lista sea vac\u00eda se devolver\u00e1 la pareja con la cadena vac\u00eda y un 0 (la longitud de la cadena vac\u00eda). Pista : puedes utilizar la funci\u00f3n string-length 1 2 3 ( cadena-mayor ' ( \"vamos\" \"a\" \"obtener\" \"la\" \"cadena\" \"mayor\" )) ; \u21d2 (\"obtener\" . 7) ( cadena-mayor ' ( \"prueba\" \"con\" \"maximo\" \"igual\" )) ; \u21d2 (\"maximo\" . 6) ( cadena-mayor ' ()) ; \u21d2 (\"\" . 0) Lenguajes y Paradigmas de Programaci\u00f3n, curso 2019-20 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Domingo Gallardo, Cristina Pomares, Antonio Bot\u00eda, Francisco Mart\u00ednez","title":"Ejercicio 6"},{"location":"practicas/practica03/practica03.html","text":"Pr\u00e1ctica 3: Funciones recursivas sobre listas \u00b6 Entrega de la pr\u00e1ctica \u00b6 Para entregar la pr\u00e1ctica debes subir a Moodle el fichero practica03.rkt con una cabecera inicial con tu nombre y apellidos, y las soluciones de cada ejercicio separadas por comentarios. Cada soluci\u00f3n debe incluir: La definici\u00f3n de las funciones que resuelven el ejercicio. Un conjunto de pruebas que comprueben su funcionamiento utilizando el API RackUnit . Ejercicio 1 \u00b6 a) Implementa la funci\u00f3n recursiva (contiene-prefijo prefijo lista-pal) que recibe una cadena y una lista de palabras. Devuelve una lista con los booleanos resultantes de comprobar si la cadena es prefijo de cada una de las palabras de la lista. Debes definir una funci\u00f3n auxiliar (es-prefijo? pal1 pal2) que compruebe si la palabra 1 es prefijo de la palabra 2. Pista Puedes usar la funci\u00f3n (substring palabra inicio final) que devuelve la subcadena de la palabra que va desde la posici\u00f3n inicio hasta la posici\u00f3n final (sin incluir). Ejemplos: 1 2 3 ( es-prefijo? \"ante\" \"anterior\" ) ; \u21d2 #t ( contiene-prefijo \"ante\" ' ( \"anterior\" \"ant\u00edgona\" \"antena\" \"anatema\" )) ; \u21d2 (#t #f #t #f) b) Implementa la funci\u00f3n recursiva (inserta-pos dato pos lista) que recibe un dato, una posici\u00f3n y una lista e inserta el dato en la posici\u00f3n indicada de la lista. Si la posici\u00f3n es 0, el dato se inserta en cabeza. Suponemos que la posici\u00f3n siempre ser\u00e1 positiva y menor o igual que la longitud de la lista. Ejemplos: 1 2 ( inserta-pos ' b 2 ' ( a a a a )) ; \u21d2 '(a a b a a) ( inserta-pos ' b 0 ' ( a a a a )) ; \u21d2 '(b a a a a) c) Implementa la funci\u00f3n recursiva (inserta-ordenada n lista-ordenada) que recibe un n\u00famero y una lista de n\u00fameros ordenados de menor a mayor y devuelve la lista resultante de insertar el n\u00famero n en la posici\u00f3n correcta para que la lista siga estando ordenada. Ejemplo: 1 ( inserta-ordenada 10 ' ( -8 2 3 11 20 )) ; \u21d2 (-8 2 3 10 11 20) Usando la funci\u00f3n anterior inserta-ordenada implementa la funci\u00f3n recursiva (ordena lista) que recibe una lista de n\u00fameros y devuelve una lista ordenada. Ejemplo: 1 ( ordena ' ( 2 -1 100 4 -6 )) ; \u21d2 (-6 -1 2 4 100) Ejercicio 2 \u00b6 a) Escribe la funci\u00f3n (expande-parejas pareja1 pareja2 ... pareja_n) que recibe un n\u00famero variable de argumentos y devuelve una lista donde se han \"expandido\" las parejas, creando una lista con tantos elementos como el n\u00famero que indique cada pareja. La funci\u00f3n expande-parejas deber\u00e1 llamar a una funci\u00f3n recursiva (expande-lista lista-parejas) que trabaje sobre una lista de parejas. Ejemplo: 1 2 ( expande-parejas ' ( #t . 3 ) ' ( \"LPP\" . 2 ) ' ( b . 4 )) ; \u21d2 (#t #t #t \"LPP\" \"LPP\" b b b b) Pista Puedes definir una funci\u00f3n auxiliar (expande-pareja pareja) que recibe una pareja y devuelve la lista expandida resultante de expandir s\u00f3lo esa pareja. b) Implementa la funci\u00f3n recursiva (expande2 lista) . Recibe una lista en la que hay intercalados algunos n\u00fameros enteros positivos. Devuelve la lista original en la que se han expandido los elementos siguientes a los n\u00fameros, tantas veces como indica el n\u00famero. La lista nunca va a contener dos n\u00fameros consecutivos y siempre va a haber un elemento despu\u00e9s de un n\u00famero. Ejemplo: 1 2 ( expande2 ' ( 4 clase ua 3 lpp aulario )) ; \u21d2 (clase clase clase clase ua lpp lpp lpp aulario)) En el ejemplo, el 4 indica que el siguiente elemento ( clase ) se debe repetir 4 veces en la lista expandida y el 3 indica que el siguiente elemento ( lpp ) se va a repetir 3 veces. Como en los anteriores ejercicios, te recomendamos implementar alguna funci\u00f3n auxiliar. Ejercicio 3 \u00b6 a) En matem\u00e1ticas, el conjunto potencia de un conjunto es el conjunto formado por todos los subconjuntos del conjunto original. Vamos a representar este concepto con listas y dise\u00f1ar una funci\u00f3n recursiva que lo implemente. Dada una lista de elementos, podemos representar su conjunto potencia como la lista de todas las sublistas posibles formadas con elementos de la lista original. Ejemplo: 1 2 ( conjunto-potencia ' ( 1 2 3 )) ; \u21d2 ((1 2 3) (1 2) (1 3) (1) (2 3) (2) (3) ()) Implementa la funci\u00f3n recursiva (conjunto-potencia lista) que devuelva el conjunto potencia de la lista original. Algunas pistas: El conjunto potencia de una lista vac\u00eda es una lista con la lista vac\u00eda como \u00fanico elemento. El conjunto potencia de una lista se puede construir uniendo dos listas: la lista resultante de a\u00f1adir el primer elemento a todas las listas del conjunto potencia sin el primer elemento y el conjunto potencia de la lista sin el primer elemento. 1 2 (conjunto-potencia '(1 2 3)) = ((1 2 3) (1 2) (1 3) (1)) + ((2 3) (2) (3) ()) b) Implementa la funci\u00f3n recursiva (producto-cartesiano lista1 lista2) que devuelva una lista con todas las parejas resultantes de combinar todos los elementos de la lista 1 con todos los elementos de la lista 2. Ejemplo: 1 2 ( producto-cartesiano ' ( 1 2 ) ' ( 1 2 3 )) ; \u21d2 ((1 . 1) (1 . 2) (1 . 3) (2 . 1) (2 . 2) (2 . 3)) Ejercicio 4 \u00b6 a) Indica qu\u00e9 devuelven las siguientes expresiones en Scheme. Puede ser que alguna expresi\u00f3n contenga alg\u00fan error. Ind\u00edcalo tambi\u00e9n en ese caso y explica qu\u00e9 tipo de error. Hazlo sin el int\u00e9rprete, y despu\u00e9s comprueba con el int\u00e9rprete si tu respuesta era correcta. 1 2 3 4 5 6 7 8 9 10 (( lambda ( x ) ( * x x )) 3 ) ; \u21d2 ? (( lambda () ( + 6 4 ))) ; \u21d2 ? (( lambda ( x y ) ( * x ( + 2 y ))) ( + 2 3 ) 4 ) ; \u21d2 ? (( lambda ( x y ) ( * x ( + 2 x ))) 5 ) ; \u21d2 ? ( define f ( lambda ( a b ) ( string-append \"***\" a b \"***\" ))) ( define g f ) ( procedure? g ) ; \u21d2 ? ( g \"Hola\" \"Adios\" ) ; \u21d2 ? b) Hemos visto en teor\u00eda que la forma especial define para construir funciones es azucar sint\u00e1ctico y que el int\u00e9rprete de Scheme la convierte en una expresi\u00f3n equivalente usando la forma especial lambda . Escribe cu\u00e1l ser\u00eda las expresiones equivalentes, usando la forma especial lambda a las siguientes definiciones de funciones: 1 2 3 4 5 6 7 ( define ( suma-3 x ) ( + x 3 )) ( define ( factorial x ) ( if ( = x 0 ) 1 ( * x ( factorial ( - x 1 ))))) c) Suponiendo las siguientes definiciones de funciones indica qu\u00e9 devolver\u00edan las invocaciones. Puede ser que alguna expresi\u00f3n contenga alg\u00fan error. Ind\u00edcalo tambi\u00e9n en ese caso y explica qu\u00e9 tipo de error. Hazlo sin el int\u00e9rprete, y despu\u00e9s comprueba con el int\u00e9rprete si tu respuesta era correcta. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 ( define ( doble x ) ( * 2 x )) ( define ( foo f g x y ) ( f ( g x ) y )) ( define ( bar f p x y ) ( if ( and ( p x ) ( p y )) ( f x y ) ' error )) ( foo + 10 doble 15 ) ; \u21d2 ? ( foo doble + 10 15 ) ; \u21d2 ? ( foo + doble 10 15 ) ; \u21d2 ? ( foo string-append ( lambda ( x ) ( string-append \"***\" x )) \"Hola\" \"Adios\" ) ; \u21d2 ? ( bar doble number? 10 15 ) ; \u21d2 ? ( bar string-append string? \"Hola\" \"Adios\" ) ; \u21d2 ? ( bar + number? \"Hola\" 5 ) ; \u21d2 ? Ejercicio 5 \u00b6 a) Implementa la funci\u00f3n recursiva (crea-baraja lista-parejas) que recibe una lista de parejas con un palo y un valor (ambos caracteres) y devuelve una lista de cartas tal y como se representaban en la pr\u00e1ctica anterior. Por ejemplo: 1 2 3 ( crea-baraja ' (( #\\u2660 . #\\A ) ( #\\u2663 . #\\2 ) ( #\\u2665 . #\\3 ) ( #\\u2666 . #\\R ))) ; \u21d2 (A\u2660 2\u2663 3\u2665 R\u2666) b) Vamos a trabajar con cartas de p\u00f3ker. Los valores posibles son A, 2, 3, ..., 8, 9, 0, J, Q, K (representamos el n\u00famero 10 con el car\u00e1cter y el s\u00edmbolo 0). Y los palos son los s\u00edmbolos correspondientes a los caracteres UTF #\\u2660, #\\u2663, #\\u2665 y #\\u2666: \u2660, \u2663, \u2665 y \u2666. 1 2 ( define palos ' ( #\\u2660 #\\u2663 #\\u2665 #\\u2666 )) ( define valores ' ( #\\A #\\2 #\\3 #\\4 #\\5 #\\6 #\\7 #\\8 #\\9 #\\0 #\\J #\\Q #\\K )) Implementa la funci\u00f3n (baraja-poker) que devuelve una lista con todas las cartas de una baraja de p\u00f3ker. No es una funci\u00f3n recursiva. Debes usar la funci\u00f3n anterior crea-baraja y la funci\u00f3n producto-cartesiano definida en el ejercicio 3. 1 2 ( baraja-poker ) ; \u21d2 (A\u2660 2\u2660 3\u2660 ...K\u2660 A\u2663 2\u2663 ... K\u2663 A\u2665 2\u2665 ... K\u2665 A\u2666 2\u2666 ... Q\u2666 K\u2666) No hace falta que hagas ninguna prueba de la funci\u00f3n. Basta con que dejes en el c\u00f3digo la llamada a la funci\u00f3n y al ejecutar el programa ver\u00e1s por pantalla que la baraja es correcta. c) Implementa la funci\u00f3n recursiva (mezcla lista) que recibe una lista y la devuelve mezclada (sus elementos se han intercambiando en posiciones aleatorias). 1 ( mezcla ' ( 1 2 3 4 5 6 )) ; \u21d2 (2 1 6 4 5 3) Llama a la funci\u00f3n con la baraja de p\u00f3ker para devuelva la baraja mezclada y la muestre por pantalla. Pista Puedes usar la funci\u00f3n inserta-pos definida anteriormente y la funci\u00f3n (random inicial final) que devuelve un n\u00famero aleatorio entre el valor inicial (incluido) y el valor final (sin incluir). Ejercicio 6 \u00b6 Implementa una funci\u00f3n recursiva (filtra-simbolos lista-simbolos lista-num) que recibe una lista de s\u00edmbolos y una lista de n\u00fameros enteros (ambas de la misma longitud) y devuelve una lista de parejas. Cada pareja est\u00e1 formada por el s\u00edmbolo de la i-\u00e9sima posici\u00f3n de lista-simbolos y el n\u00famero entero situado esa posici\u00f3n de lista-num , siempre y cuando dicho n\u00famero se corresponda con la longitud de la cadena correspondiente al s\u00edmbolo. Puedes utilizar las funciones predefinidas string-length y symbol->string . Ejemplo: 1 2 ( filtra-simbolos ' ( este es un ejercicio de examen ) ' ( 2 1 2 9 1 6 )) ; \u21d2 ((un . 2) (ejercicio . 9) (examen . 6)) Lenguajes y Paradigmas de Programaci\u00f3n, curso 2019-20 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Domingo Gallardo, Cristina Pomares, Antonio Bot\u00eda, Francisco Mart\u00ednez","title":"Pr\u00e1ctica 3"},{"location":"practicas/practica03/practica03.html#practica-3-funciones-recursivas-sobre-listas","text":"","title":"Pr\u00e1ctica 3: Funciones recursivas sobre listas"},{"location":"practicas/practica03/practica03.html#entrega-de-la-practica","text":"Para entregar la pr\u00e1ctica debes subir a Moodle el fichero practica03.rkt con una cabecera inicial con tu nombre y apellidos, y las soluciones de cada ejercicio separadas por comentarios. Cada soluci\u00f3n debe incluir: La definici\u00f3n de las funciones que resuelven el ejercicio. Un conjunto de pruebas que comprueben su funcionamiento utilizando el API RackUnit .","title":"Entrega de la pr\u00e1ctica"},{"location":"practicas/practica03/practica03.html#ejercicio-1","text":"a) Implementa la funci\u00f3n recursiva (contiene-prefijo prefijo lista-pal) que recibe una cadena y una lista de palabras. Devuelve una lista con los booleanos resultantes de comprobar si la cadena es prefijo de cada una de las palabras de la lista. Debes definir una funci\u00f3n auxiliar (es-prefijo? pal1 pal2) que compruebe si la palabra 1 es prefijo de la palabra 2. Pista Puedes usar la funci\u00f3n (substring palabra inicio final) que devuelve la subcadena de la palabra que va desde la posici\u00f3n inicio hasta la posici\u00f3n final (sin incluir). Ejemplos: 1 2 3 ( es-prefijo? \"ante\" \"anterior\" ) ; \u21d2 #t ( contiene-prefijo \"ante\" ' ( \"anterior\" \"ant\u00edgona\" \"antena\" \"anatema\" )) ; \u21d2 (#t #f #t #f) b) Implementa la funci\u00f3n recursiva (inserta-pos dato pos lista) que recibe un dato, una posici\u00f3n y una lista e inserta el dato en la posici\u00f3n indicada de la lista. Si la posici\u00f3n es 0, el dato se inserta en cabeza. Suponemos que la posici\u00f3n siempre ser\u00e1 positiva y menor o igual que la longitud de la lista. Ejemplos: 1 2 ( inserta-pos ' b 2 ' ( a a a a )) ; \u21d2 '(a a b a a) ( inserta-pos ' b 0 ' ( a a a a )) ; \u21d2 '(b a a a a) c) Implementa la funci\u00f3n recursiva (inserta-ordenada n lista-ordenada) que recibe un n\u00famero y una lista de n\u00fameros ordenados de menor a mayor y devuelve la lista resultante de insertar el n\u00famero n en la posici\u00f3n correcta para que la lista siga estando ordenada. Ejemplo: 1 ( inserta-ordenada 10 ' ( -8 2 3 11 20 )) ; \u21d2 (-8 2 3 10 11 20) Usando la funci\u00f3n anterior inserta-ordenada implementa la funci\u00f3n recursiva (ordena lista) que recibe una lista de n\u00fameros y devuelve una lista ordenada. Ejemplo: 1 ( ordena ' ( 2 -1 100 4 -6 )) ; \u21d2 (-6 -1 2 4 100)","title":"Ejercicio 1"},{"location":"practicas/practica03/practica03.html#ejercicio-2","text":"a) Escribe la funci\u00f3n (expande-parejas pareja1 pareja2 ... pareja_n) que recibe un n\u00famero variable de argumentos y devuelve una lista donde se han \"expandido\" las parejas, creando una lista con tantos elementos como el n\u00famero que indique cada pareja. La funci\u00f3n expande-parejas deber\u00e1 llamar a una funci\u00f3n recursiva (expande-lista lista-parejas) que trabaje sobre una lista de parejas. Ejemplo: 1 2 ( expande-parejas ' ( #t . 3 ) ' ( \"LPP\" . 2 ) ' ( b . 4 )) ; \u21d2 (#t #t #t \"LPP\" \"LPP\" b b b b) Pista Puedes definir una funci\u00f3n auxiliar (expande-pareja pareja) que recibe una pareja y devuelve la lista expandida resultante de expandir s\u00f3lo esa pareja. b) Implementa la funci\u00f3n recursiva (expande2 lista) . Recibe una lista en la que hay intercalados algunos n\u00fameros enteros positivos. Devuelve la lista original en la que se han expandido los elementos siguientes a los n\u00fameros, tantas veces como indica el n\u00famero. La lista nunca va a contener dos n\u00fameros consecutivos y siempre va a haber un elemento despu\u00e9s de un n\u00famero. Ejemplo: 1 2 ( expande2 ' ( 4 clase ua 3 lpp aulario )) ; \u21d2 (clase clase clase clase ua lpp lpp lpp aulario)) En el ejemplo, el 4 indica que el siguiente elemento ( clase ) se debe repetir 4 veces en la lista expandida y el 3 indica que el siguiente elemento ( lpp ) se va a repetir 3 veces. Como en los anteriores ejercicios, te recomendamos implementar alguna funci\u00f3n auxiliar.","title":"Ejercicio 2"},{"location":"practicas/practica03/practica03.html#ejercicio-3","text":"a) En matem\u00e1ticas, el conjunto potencia de un conjunto es el conjunto formado por todos los subconjuntos del conjunto original. Vamos a representar este concepto con listas y dise\u00f1ar una funci\u00f3n recursiva que lo implemente. Dada una lista de elementos, podemos representar su conjunto potencia como la lista de todas las sublistas posibles formadas con elementos de la lista original. Ejemplo: 1 2 ( conjunto-potencia ' ( 1 2 3 )) ; \u21d2 ((1 2 3) (1 2) (1 3) (1) (2 3) (2) (3) ()) Implementa la funci\u00f3n recursiva (conjunto-potencia lista) que devuelva el conjunto potencia de la lista original. Algunas pistas: El conjunto potencia de una lista vac\u00eda es una lista con la lista vac\u00eda como \u00fanico elemento. El conjunto potencia de una lista se puede construir uniendo dos listas: la lista resultante de a\u00f1adir el primer elemento a todas las listas del conjunto potencia sin el primer elemento y el conjunto potencia de la lista sin el primer elemento. 1 2 (conjunto-potencia '(1 2 3)) = ((1 2 3) (1 2) (1 3) (1)) + ((2 3) (2) (3) ()) b) Implementa la funci\u00f3n recursiva (producto-cartesiano lista1 lista2) que devuelva una lista con todas las parejas resultantes de combinar todos los elementos de la lista 1 con todos los elementos de la lista 2. Ejemplo: 1 2 ( producto-cartesiano ' ( 1 2 ) ' ( 1 2 3 )) ; \u21d2 ((1 . 1) (1 . 2) (1 . 3) (2 . 1) (2 . 2) (2 . 3))","title":"Ejercicio 3"},{"location":"practicas/practica03/practica03.html#ejercicio-4","text":"a) Indica qu\u00e9 devuelven las siguientes expresiones en Scheme. Puede ser que alguna expresi\u00f3n contenga alg\u00fan error. Ind\u00edcalo tambi\u00e9n en ese caso y explica qu\u00e9 tipo de error. Hazlo sin el int\u00e9rprete, y despu\u00e9s comprueba con el int\u00e9rprete si tu respuesta era correcta. 1 2 3 4 5 6 7 8 9 10 (( lambda ( x ) ( * x x )) 3 ) ; \u21d2 ? (( lambda () ( + 6 4 ))) ; \u21d2 ? (( lambda ( x y ) ( * x ( + 2 y ))) ( + 2 3 ) 4 ) ; \u21d2 ? (( lambda ( x y ) ( * x ( + 2 x ))) 5 ) ; \u21d2 ? ( define f ( lambda ( a b ) ( string-append \"***\" a b \"***\" ))) ( define g f ) ( procedure? g ) ; \u21d2 ? ( g \"Hola\" \"Adios\" ) ; \u21d2 ? b) Hemos visto en teor\u00eda que la forma especial define para construir funciones es azucar sint\u00e1ctico y que el int\u00e9rprete de Scheme la convierte en una expresi\u00f3n equivalente usando la forma especial lambda . Escribe cu\u00e1l ser\u00eda las expresiones equivalentes, usando la forma especial lambda a las siguientes definiciones de funciones: 1 2 3 4 5 6 7 ( define ( suma-3 x ) ( + x 3 )) ( define ( factorial x ) ( if ( = x 0 ) 1 ( * x ( factorial ( - x 1 ))))) c) Suponiendo las siguientes definiciones de funciones indica qu\u00e9 devolver\u00edan las invocaciones. Puede ser que alguna expresi\u00f3n contenga alg\u00fan error. Ind\u00edcalo tambi\u00e9n en ese caso y explica qu\u00e9 tipo de error. Hazlo sin el int\u00e9rprete, y despu\u00e9s comprueba con el int\u00e9rprete si tu respuesta era correcta. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 ( define ( doble x ) ( * 2 x )) ( define ( foo f g x y ) ( f ( g x ) y )) ( define ( bar f p x y ) ( if ( and ( p x ) ( p y )) ( f x y ) ' error )) ( foo + 10 doble 15 ) ; \u21d2 ? ( foo doble + 10 15 ) ; \u21d2 ? ( foo + doble 10 15 ) ; \u21d2 ? ( foo string-append ( lambda ( x ) ( string-append \"***\" x )) \"Hola\" \"Adios\" ) ; \u21d2 ? ( bar doble number? 10 15 ) ; \u21d2 ? ( bar string-append string? \"Hola\" \"Adios\" ) ; \u21d2 ? ( bar + number? \"Hola\" 5 ) ; \u21d2 ?","title":"Ejercicio 4"},{"location":"practicas/practica03/practica03.html#ejercicio-5","text":"a) Implementa la funci\u00f3n recursiva (crea-baraja lista-parejas) que recibe una lista de parejas con un palo y un valor (ambos caracteres) y devuelve una lista de cartas tal y como se representaban en la pr\u00e1ctica anterior. Por ejemplo: 1 2 3 ( crea-baraja ' (( #\\u2660 . #\\A ) ( #\\u2663 . #\\2 ) ( #\\u2665 . #\\3 ) ( #\\u2666 . #\\R ))) ; \u21d2 (A\u2660 2\u2663 3\u2665 R\u2666) b) Vamos a trabajar con cartas de p\u00f3ker. Los valores posibles son A, 2, 3, ..., 8, 9, 0, J, Q, K (representamos el n\u00famero 10 con el car\u00e1cter y el s\u00edmbolo 0). Y los palos son los s\u00edmbolos correspondientes a los caracteres UTF #\\u2660, #\\u2663, #\\u2665 y #\\u2666: \u2660, \u2663, \u2665 y \u2666. 1 2 ( define palos ' ( #\\u2660 #\\u2663 #\\u2665 #\\u2666 )) ( define valores ' ( #\\A #\\2 #\\3 #\\4 #\\5 #\\6 #\\7 #\\8 #\\9 #\\0 #\\J #\\Q #\\K )) Implementa la funci\u00f3n (baraja-poker) que devuelve una lista con todas las cartas de una baraja de p\u00f3ker. No es una funci\u00f3n recursiva. Debes usar la funci\u00f3n anterior crea-baraja y la funci\u00f3n producto-cartesiano definida en el ejercicio 3. 1 2 ( baraja-poker ) ; \u21d2 (A\u2660 2\u2660 3\u2660 ...K\u2660 A\u2663 2\u2663 ... K\u2663 A\u2665 2\u2665 ... K\u2665 A\u2666 2\u2666 ... Q\u2666 K\u2666) No hace falta que hagas ninguna prueba de la funci\u00f3n. Basta con que dejes en el c\u00f3digo la llamada a la funci\u00f3n y al ejecutar el programa ver\u00e1s por pantalla que la baraja es correcta. c) Implementa la funci\u00f3n recursiva (mezcla lista) que recibe una lista y la devuelve mezclada (sus elementos se han intercambiando en posiciones aleatorias). 1 ( mezcla ' ( 1 2 3 4 5 6 )) ; \u21d2 (2 1 6 4 5 3) Llama a la funci\u00f3n con la baraja de p\u00f3ker para devuelva la baraja mezclada y la muestre por pantalla. Pista Puedes usar la funci\u00f3n inserta-pos definida anteriormente y la funci\u00f3n (random inicial final) que devuelve un n\u00famero aleatorio entre el valor inicial (incluido) y el valor final (sin incluir).","title":"Ejercicio 5"},{"location":"practicas/practica03/practica03.html#ejercicio-6","text":"Implementa una funci\u00f3n recursiva (filtra-simbolos lista-simbolos lista-num) que recibe una lista de s\u00edmbolos y una lista de n\u00fameros enteros (ambas de la misma longitud) y devuelve una lista de parejas. Cada pareja est\u00e1 formada por el s\u00edmbolo de la i-\u00e9sima posici\u00f3n de lista-simbolos y el n\u00famero entero situado esa posici\u00f3n de lista-num , siempre y cuando dicho n\u00famero se corresponda con la longitud de la cadena correspondiente al s\u00edmbolo. Puedes utilizar las funciones predefinidas string-length y symbol->string . Ejemplo: 1 2 ( filtra-simbolos ' ( este es un ejercicio de examen ) ' ( 2 1 2 9 1 6 )) ; \u21d2 ((un . 2) (ejercicio . 9) (examen . 6)) Lenguajes y Paradigmas de Programaci\u00f3n, curso 2019-20 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Domingo Gallardo, Cristina Pomares, Antonio Bot\u00eda, Francisco Mart\u00ednez","title":"Ejercicio 6"},{"location":"practicas/practica04/practica04.html","text":"Pr\u00e1ctica 4: Funciones como datos de primera clase y funciones de orden superior \u00b6 Entrega de la pr\u00e1ctica \u00b6 Para entregar la pr\u00e1ctica debes subir a Moodle el fichero practica04.rkt con una cabecera inicial con tu nombre y apellidos, y las soluciones de cada ejercicio separadas por comentarios. Cada soluci\u00f3n debe incluir: La definici\u00f3n de las funciones que resuelven el ejercicio. Un conjunto de pruebas que comprueben su funcionamiento utilizando el API RackUnit . Ejercicios \u00b6 Ejercicio 1 \u00b6 a) Indica qu\u00e9 devuelven las siguientes expresiones, sin utilizar el int\u00e9rprete. Comprueba despu\u00e9s si has acertado. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 ( map ( lambda ( x ) ( cond (( symbol? x ) ( symbol->string x )) (( number? x ) ( number->string x )) (( boolean? x ) ( if x \"#t\" \"#f\" )) ( else \"desconocido\" ))) ' ( 1 #t hola #f ( 1 . 2 ))) ; \u21d2 ? ( filter ( lambda ( x ) ( equal? ( string-ref ( symbol->string x ) 1 ) #\\a )) ' ( alicante barcelona madrid almer\u00eda )) ; \u21d2 ? ( foldl ( lambda ( dato resultado ) ( string-append ( symbol->string ( car dato )) ( symbol->string ( cdr dato )) resultado )) \"\" ' (( a . b ) ( hola . adios ) ( una . pareja ))) ; \u21d2 ? ( foldr ( lambda ( dato resultado ) ( cons ( + ( car resultado ) dato ) ( + ( cdr resultado ) 1 ))) ' ( 0 . 0 ) ' ( 1 1 2 2 3 3 )) ; \u21d2 ? b) Sin utilizar el int\u00e9rprete DrRacket, rellena los siguientes huecos para obtener el resultado esperado. Despu\u00e9s usa el int\u00e9rprete para comprobar si has acertado. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 ; Los siguientes ejercicios utilizan esta definici\u00f3n de lista ( define lista ' (( 2 . 7 ) ( 3 . 5 ) ( 10 . 4 ) ( 5 . 5 ))) ; Queremos obtener una lista donde cada n\u00famero es la suma de las ; parejas que son pares ( filter ________ ( ________ ( lambda ( x ) ( + ( car x ) ( cdr x ))) lista )) ; \u21d2 (8 14 10) ; Queremos obtener una lista de parejas invertidas donde la \"nueva\" ; parte izquierda es mayor que la derecha. ( filter ___________ ( map ____________ lista )) ; \u21d2 ((7 . 2) (5 . 3)) ; Queremos obtener una lista cuyos elementos son las partes izquierda ; de aquellas parejas cuya suma sea par. ( foldr __________ ' () ( _________ ( lambda ( x ) ( even? ( + ( car x ) ( cdr x )))) lista )) ; \u21d2 (3 10 5) c) Rellena los siguientes huecos con una \u00fanica expresi\u00f3n . Comprueba con el int\u00e9rprete si lo has hecho correctamente. 1 2 3 4 5 6 7 8 9 10 11 12 13 ( define ( f x ) ( lambda ( y z ) ( string-append y z x ))) ( define g ( f \"a\" )) ( check-equal? ____________________ \"claselppa\" ) ( define ( f x ) ( lambda ( y z ) ( list y x z ))) _____________ ( check-equal? ( g \"hola\" \"clase\" ) ( list \"hola\" \"lpp\" \"clase\" )) ( define ( f g ) ( lambda ( z x ) ( g z x ))) ( check-equal? _____________________ ' ( 3 . 4 )) Ejercicio 2 \u00b6 Implementa utilizando funciones de orden superior las funciones (crea-baraja lista-parejas) y (expande-lista lista-parejas) de la pr\u00e1ctica 3. Para la implementaci\u00f3n de expande-lista debes utilizar la funci\u00f3n expande-pareja usada tambi\u00e9n en la pr\u00e1ctica 3. 1 2 3 4 5 6 ( crea-baraja ' (( #\\u2660 . #\\A ) ( #\\u2663 . #\\2 ) ( #\\u2665 . #\\3 ) ( #\\u2666 . #\\R ))) ; \u21d2 (A\u2660 2\u2663 3\u2665 R\u2666) ( expande-lista ' (( #t . 3 ) ( \"LPP\" . 2 ) ( b . 4 ))) ; \u21d2 '(#t #t #t \"LPP\" \"LPP\" b b b b)) Ejercicio 3 \u00b6 a) Implementa usando funciones de orden superior la funci\u00f3n (suma-n-izq n lista-parejas) que recibe una lista de parejas y devuelve otra lista a la que hemos sumado n a todas las partes izquierdas. Ejemplo 1 2 ( suma-n-izq 10 ' (( 1 . 3 ) ( 0 . 9 ) ( 5 . 8 ) ( 4 . 1 ))) ; \u21d2 ((11 . 3) (10 . 9) (15 . 8) (14 . 1)) b) Implementa usando funciones de orden superior la funci\u00f3n (aplica-2 func lista-parejas) que recibe una funci\u00f3n de dos argumentos y una lista de parejas y devuelve una lista con el resultado de aplicar esa funci\u00f3n a los elementos izquierdo y derecho de cada pareja. Ejemplo: 1 2 3 4 5 6 7 ( aplica-2 + ' (( 2 . 3 ) ( 1 . -1 ) ( 5 . 4 ))) ; \u21d2 (5 0 9) ( aplica-2 ( lambda ( x y ) ( if ( even? x ) y ( * y -1 ))) ' (( 2 . 3 ) ( 1 . 3 ) ( 5 . 4 ) ( 8 . 10 ))) ; \u21d2 (3 -3 -4 10) c) Implementa la funci\u00f3n (filtra-simbolos lista-simbolos lista-num) de de la pr\u00e1ctica 3, usando una composici\u00f3n de funciones en las que se use map . Ejercicio 4 \u00b6 a) La funci\u00f3n de Racket (index-of lista dato) devuelve la posici\u00f3n de un dato en una lista o #f si el dato no est\u00e1 en la lista. Si el dato est\u00e1 repetido en la lista devuelve la posici\u00f3n de su primera aparici\u00f3n. Implementa la funci\u00f3n mi-index-of que haga lo mismo, usando funciones de orden superior. Puedes usar tambi\u00e9n alguna funci\u00f3n auxiliar. Pista Puedes utilizar la funci\u00f3n foldl para recorrer la lista de izquierda a derecha buscando el dato. Puedes usar como resultado del foldl una pareja en cuya parte derecha vayamos calculando la posici\u00f3n y en la parte izquierda haya un booleano que indique si hemos encontrado o no el dato. Ejemplos: 1 2 ( mi-index-of ' ( a b c d c ) ' c ) ; \u21d2 2 ( mi-index-of ' ( 1 2 3 4 5 ) 10 ) ; \u21d2 #f b) Completa la definici\u00f3n de la siguiente funci\u00f3n de orden superior (busca-mayor mayor? lista) que busca el mayor elemento de una lista. Recibe un predicado mayor? que compara dos elementos de la lista y devuelve #t o #f dependiendo de si el primero es mayor que el segundo. 1 2 ( define ( busca-mayor mayor? lista ) ( foldl __________ ( car lista ) ( cdr lista ))) Escribe algunos check-equal? en los que compruebes el funcionamiento de busca-mayor , utilizando funciones mayor? distintas. c) Define la funci\u00f3n (posicion-mayor mayor? lista) que devuelva la posici\u00f3n del mayor elemento de la lista utilizando las dos funciones anteriores. Ejercicio 5 \u00b6 a) Supongamos que vamos a representar una mano de cartas como una lista de cartas. Podemos entonces representar un juego de n manos como una lista de n listas. Por ejemplo, la siguiente lista representar\u00eda un juego con 3 manos de 5 cartas: 1 ((K\u2666 J\u2665 2\u2665 2\u2660 8\u2665) (A\u2665 3\u2660 5\u2666 3\u2663 J\u2666) (3\u2666 Q\u2665 0\u2660 2\u2663 9\u2666)) Para construir este juego vamos a necesitar una funci\u00f3n auxiliar que vaya construyendo las manos, a\u00f1adiendo una carta a la primera mano de la lista si \u00e9sta no tiene todas las cartas necesarias. Tienes que definir la funci\u00f3n (a\u00f1ade-carta carta n-cartas manos) que recibe una carta, un n\u00famero que representa el n\u00famero de cartas que deben tener las manos y una lista de manos, cuya primera mano puede estar incompleta. En ese caso, la funci\u00f3n a\u00f1adir\u00e1 la carta a esa primera mano de la lista. Si la primera mano est\u00e1 completa, o la lista de manos est\u00e1 vac\u00eda, se deber\u00e1 a\u00f1adir una nueva mano a la lista, con la \u00fanica carta que se pasa como par\u00e1metro. Ejemplos: 1 2 3 ( a\u00f1ade-carta ' K\u2666 3 ' ()) ; \u21d2 ((K\u2666)) ( a\u00f1ade-carta ' J\u2665 3 ' (( 2\u2665 2\u2660 ) ( 5\u2666 3\u2663 J\u2666 ))) ; \u21d2 ((J\u2665 2\u2665 2\u2660) (5\u2666 3\u2663 J\u2666)) ( a\u00f1ade-carta ' 3\u2660 3 ' (( 5\u2666 3\u2663 J\u2666 ))) ; \u21d2 ((3\u2660) (5\u2666 3\u2663 J\u2666)) Una vez definida la funci\u00f3n anterior, y utilizando funciones de orden superior, debes implementar la funci\u00f3n (reparte n-manos n-cartas baraja) que devuelva un juego con n manos de n cartas sacadas la parte de arriba de una baraja inicial. Puedes utilizar las funciones baraja-poker y mezcla de la pr\u00e1ctica anterior para crear la baraja inicial. Ejemplo: 1 2 3 4 ( define baraja ( mezcla ( baraja-poker ))) baraja ; \u21d2 (Q\u2660 9\u2665 4\u2663 K\u2660 7\u2665 J\u2666 5\u2660 4\u2660 5\u2666 6\u2666 8\u2666 A\u2666 Q\u2666 0\u2663 7\u2666 3\u2660 Q\u2665 ...) ( reparte 3 5 baraja ) ; \u21d2 ((7\u2666 0\u2663 Q\u2666 A\u2666 8\u2666) (6\u2666 5\u2666 4\u2660 5\u2660 J\u2666) (7\u2665 K\u2660 4\u2663 9\u2665 Q\u2660)) b) La siguiente funci\u00f3n devuelve el valor de una carta: 1 2 ( define ( valor-carta carta orden ) ( + 1 ( index-of orden ( string-ref ( symbol->string carta ) 0 )))) El par\u00e1metro orden es una lista de todos los caracteres que representan los posibles valores de una carta, ordenados de menor a mayor. Por ejemplo: 1 2 3 4 ( define orden ' ( #\\2 #\\3 #\\4 #\\5 #\\6 #\\7 #\\8 #\\9 #\\0 #\\J #\\Q #\\K #\\A )) ( valor-carta ' A\u2660 orden ) ; \u21d2 13 ( valor-carta ' J\u2665 orden ) ; \u21d2 10 ( valor-carta ' 2\u2666 orden ) ; \u21d2 1 Implementa, utilizando funciones de orden superior y funciones definidas anteriormente en esta pr\u00e1ctica, la funci\u00f3n (mano-ganadora lista-manos) que recibe una lista de manos y devuelve la posici\u00f3n de la mano ganadora utilizando la valoraci\u00f3n del p\u00f3ker. La mano ganadora es la que tiene una carta m\u00e1s alta. Si hay empate, deber\u00e1s devolver la posici\u00f3n de la primera mano que participa en el empate. Pista Puedes definir una funci\u00f3n de un \u00fanico par\u00e1metro que devuelve el valor de una carta usando el orden definido por el p\u00f3ker usando la siguiente expresi\u00f3n lambda: 1 2 3 ( lambda ( carta ) ( valor-carta carta ' ( #\\2 #\\3 #\\4 #\\5 #\\6 #\\7 #\\8 #\\9 #\\0 #\\J #\\Q #\\K #\\A ))) Puedes usar cualquier funci\u00f3n definida anteriormente. 1 2 3 ( define lista-manos ( reparte 3 5 ( mezcla ( baraja-poker )))) ; lista-manos \u21d2 ((9\u2666 2\u2666 K\u2665 0\u2666 7\u2665) (6\u2666 4\u2660 7\u2663 5\u2665 4\u2666) (0\u2663 4\u2663 5\u2660 3\u2665 J\u2665)) ( mano-ganadora lista-manos ) ; \u21d2 0 Lenguajes y Paradigmas de Programaci\u00f3n, curso 2019-20 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Domingo Gallardo, Cristina Pomares, Antonio Bot\u00eda, Francisco Mart\u00ednez","title":"Pr\u00e1ctica 4"},{"location":"practicas/practica04/practica04.html#practica-4-funciones-como-datos-de-primera-clase-y-funciones-de-orden-superior","text":"","title":"Pr\u00e1ctica 4: Funciones como datos de primera clase y funciones de orden superior"},{"location":"practicas/practica04/practica04.html#entrega-de-la-practica","text":"Para entregar la pr\u00e1ctica debes subir a Moodle el fichero practica04.rkt con una cabecera inicial con tu nombre y apellidos, y las soluciones de cada ejercicio separadas por comentarios. Cada soluci\u00f3n debe incluir: La definici\u00f3n de las funciones que resuelven el ejercicio. Un conjunto de pruebas que comprueben su funcionamiento utilizando el API RackUnit .","title":"Entrega de la pr\u00e1ctica"},{"location":"practicas/practica04/practica04.html#ejercicios","text":"","title":"Ejercicios"},{"location":"practicas/practica04/practica04.html#ejercicio-1","text":"a) Indica qu\u00e9 devuelven las siguientes expresiones, sin utilizar el int\u00e9rprete. Comprueba despu\u00e9s si has acertado. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 ( map ( lambda ( x ) ( cond (( symbol? x ) ( symbol->string x )) (( number? x ) ( number->string x )) (( boolean? x ) ( if x \"#t\" \"#f\" )) ( else \"desconocido\" ))) ' ( 1 #t hola #f ( 1 . 2 ))) ; \u21d2 ? ( filter ( lambda ( x ) ( equal? ( string-ref ( symbol->string x ) 1 ) #\\a )) ' ( alicante barcelona madrid almer\u00eda )) ; \u21d2 ? ( foldl ( lambda ( dato resultado ) ( string-append ( symbol->string ( car dato )) ( symbol->string ( cdr dato )) resultado )) \"\" ' (( a . b ) ( hola . adios ) ( una . pareja ))) ; \u21d2 ? ( foldr ( lambda ( dato resultado ) ( cons ( + ( car resultado ) dato ) ( + ( cdr resultado ) 1 ))) ' ( 0 . 0 ) ' ( 1 1 2 2 3 3 )) ; \u21d2 ? b) Sin utilizar el int\u00e9rprete DrRacket, rellena los siguientes huecos para obtener el resultado esperado. Despu\u00e9s usa el int\u00e9rprete para comprobar si has acertado. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 ; Los siguientes ejercicios utilizan esta definici\u00f3n de lista ( define lista ' (( 2 . 7 ) ( 3 . 5 ) ( 10 . 4 ) ( 5 . 5 ))) ; Queremos obtener una lista donde cada n\u00famero es la suma de las ; parejas que son pares ( filter ________ ( ________ ( lambda ( x ) ( + ( car x ) ( cdr x ))) lista )) ; \u21d2 (8 14 10) ; Queremos obtener una lista de parejas invertidas donde la \"nueva\" ; parte izquierda es mayor que la derecha. ( filter ___________ ( map ____________ lista )) ; \u21d2 ((7 . 2) (5 . 3)) ; Queremos obtener una lista cuyos elementos son las partes izquierda ; de aquellas parejas cuya suma sea par. ( foldr __________ ' () ( _________ ( lambda ( x ) ( even? ( + ( car x ) ( cdr x )))) lista )) ; \u21d2 (3 10 5) c) Rellena los siguientes huecos con una \u00fanica expresi\u00f3n . Comprueba con el int\u00e9rprete si lo has hecho correctamente. 1 2 3 4 5 6 7 8 9 10 11 12 13 ( define ( f x ) ( lambda ( y z ) ( string-append y z x ))) ( define g ( f \"a\" )) ( check-equal? ____________________ \"claselppa\" ) ( define ( f x ) ( lambda ( y z ) ( list y x z ))) _____________ ( check-equal? ( g \"hola\" \"clase\" ) ( list \"hola\" \"lpp\" \"clase\" )) ( define ( f g ) ( lambda ( z x ) ( g z x ))) ( check-equal? _____________________ ' ( 3 . 4 ))","title":"Ejercicio 1"},{"location":"practicas/practica04/practica04.html#ejercicio-2","text":"Implementa utilizando funciones de orden superior las funciones (crea-baraja lista-parejas) y (expande-lista lista-parejas) de la pr\u00e1ctica 3. Para la implementaci\u00f3n de expande-lista debes utilizar la funci\u00f3n expande-pareja usada tambi\u00e9n en la pr\u00e1ctica 3. 1 2 3 4 5 6 ( crea-baraja ' (( #\\u2660 . #\\A ) ( #\\u2663 . #\\2 ) ( #\\u2665 . #\\3 ) ( #\\u2666 . #\\R ))) ; \u21d2 (A\u2660 2\u2663 3\u2665 R\u2666) ( expande-lista ' (( #t . 3 ) ( \"LPP\" . 2 ) ( b . 4 ))) ; \u21d2 '(#t #t #t \"LPP\" \"LPP\" b b b b))","title":"Ejercicio 2"},{"location":"practicas/practica04/practica04.html#ejercicio-3","text":"a) Implementa usando funciones de orden superior la funci\u00f3n (suma-n-izq n lista-parejas) que recibe una lista de parejas y devuelve otra lista a la que hemos sumado n a todas las partes izquierdas. Ejemplo 1 2 ( suma-n-izq 10 ' (( 1 . 3 ) ( 0 . 9 ) ( 5 . 8 ) ( 4 . 1 ))) ; \u21d2 ((11 . 3) (10 . 9) (15 . 8) (14 . 1)) b) Implementa usando funciones de orden superior la funci\u00f3n (aplica-2 func lista-parejas) que recibe una funci\u00f3n de dos argumentos y una lista de parejas y devuelve una lista con el resultado de aplicar esa funci\u00f3n a los elementos izquierdo y derecho de cada pareja. Ejemplo: 1 2 3 4 5 6 7 ( aplica-2 + ' (( 2 . 3 ) ( 1 . -1 ) ( 5 . 4 ))) ; \u21d2 (5 0 9) ( aplica-2 ( lambda ( x y ) ( if ( even? x ) y ( * y -1 ))) ' (( 2 . 3 ) ( 1 . 3 ) ( 5 . 4 ) ( 8 . 10 ))) ; \u21d2 (3 -3 -4 10) c) Implementa la funci\u00f3n (filtra-simbolos lista-simbolos lista-num) de de la pr\u00e1ctica 3, usando una composici\u00f3n de funciones en las que se use map .","title":"Ejercicio 3"},{"location":"practicas/practica04/practica04.html#ejercicio-4","text":"a) La funci\u00f3n de Racket (index-of lista dato) devuelve la posici\u00f3n de un dato en una lista o #f si el dato no est\u00e1 en la lista. Si el dato est\u00e1 repetido en la lista devuelve la posici\u00f3n de su primera aparici\u00f3n. Implementa la funci\u00f3n mi-index-of que haga lo mismo, usando funciones de orden superior. Puedes usar tambi\u00e9n alguna funci\u00f3n auxiliar. Pista Puedes utilizar la funci\u00f3n foldl para recorrer la lista de izquierda a derecha buscando el dato. Puedes usar como resultado del foldl una pareja en cuya parte derecha vayamos calculando la posici\u00f3n y en la parte izquierda haya un booleano que indique si hemos encontrado o no el dato. Ejemplos: 1 2 ( mi-index-of ' ( a b c d c ) ' c ) ; \u21d2 2 ( mi-index-of ' ( 1 2 3 4 5 ) 10 ) ; \u21d2 #f b) Completa la definici\u00f3n de la siguiente funci\u00f3n de orden superior (busca-mayor mayor? lista) que busca el mayor elemento de una lista. Recibe un predicado mayor? que compara dos elementos de la lista y devuelve #t o #f dependiendo de si el primero es mayor que el segundo. 1 2 ( define ( busca-mayor mayor? lista ) ( foldl __________ ( car lista ) ( cdr lista ))) Escribe algunos check-equal? en los que compruebes el funcionamiento de busca-mayor , utilizando funciones mayor? distintas. c) Define la funci\u00f3n (posicion-mayor mayor? lista) que devuelva la posici\u00f3n del mayor elemento de la lista utilizando las dos funciones anteriores.","title":"Ejercicio 4"},{"location":"practicas/practica04/practica04.html#ejercicio-5","text":"a) Supongamos que vamos a representar una mano de cartas como una lista de cartas. Podemos entonces representar un juego de n manos como una lista de n listas. Por ejemplo, la siguiente lista representar\u00eda un juego con 3 manos de 5 cartas: 1 ((K\u2666 J\u2665 2\u2665 2\u2660 8\u2665) (A\u2665 3\u2660 5\u2666 3\u2663 J\u2666) (3\u2666 Q\u2665 0\u2660 2\u2663 9\u2666)) Para construir este juego vamos a necesitar una funci\u00f3n auxiliar que vaya construyendo las manos, a\u00f1adiendo una carta a la primera mano de la lista si \u00e9sta no tiene todas las cartas necesarias. Tienes que definir la funci\u00f3n (a\u00f1ade-carta carta n-cartas manos) que recibe una carta, un n\u00famero que representa el n\u00famero de cartas que deben tener las manos y una lista de manos, cuya primera mano puede estar incompleta. En ese caso, la funci\u00f3n a\u00f1adir\u00e1 la carta a esa primera mano de la lista. Si la primera mano est\u00e1 completa, o la lista de manos est\u00e1 vac\u00eda, se deber\u00e1 a\u00f1adir una nueva mano a la lista, con la \u00fanica carta que se pasa como par\u00e1metro. Ejemplos: 1 2 3 ( a\u00f1ade-carta ' K\u2666 3 ' ()) ; \u21d2 ((K\u2666)) ( a\u00f1ade-carta ' J\u2665 3 ' (( 2\u2665 2\u2660 ) ( 5\u2666 3\u2663 J\u2666 ))) ; \u21d2 ((J\u2665 2\u2665 2\u2660) (5\u2666 3\u2663 J\u2666)) ( a\u00f1ade-carta ' 3\u2660 3 ' (( 5\u2666 3\u2663 J\u2666 ))) ; \u21d2 ((3\u2660) (5\u2666 3\u2663 J\u2666)) Una vez definida la funci\u00f3n anterior, y utilizando funciones de orden superior, debes implementar la funci\u00f3n (reparte n-manos n-cartas baraja) que devuelva un juego con n manos de n cartas sacadas la parte de arriba de una baraja inicial. Puedes utilizar las funciones baraja-poker y mezcla de la pr\u00e1ctica anterior para crear la baraja inicial. Ejemplo: 1 2 3 4 ( define baraja ( mezcla ( baraja-poker ))) baraja ; \u21d2 (Q\u2660 9\u2665 4\u2663 K\u2660 7\u2665 J\u2666 5\u2660 4\u2660 5\u2666 6\u2666 8\u2666 A\u2666 Q\u2666 0\u2663 7\u2666 3\u2660 Q\u2665 ...) ( reparte 3 5 baraja ) ; \u21d2 ((7\u2666 0\u2663 Q\u2666 A\u2666 8\u2666) (6\u2666 5\u2666 4\u2660 5\u2660 J\u2666) (7\u2665 K\u2660 4\u2663 9\u2665 Q\u2660)) b) La siguiente funci\u00f3n devuelve el valor de una carta: 1 2 ( define ( valor-carta carta orden ) ( + 1 ( index-of orden ( string-ref ( symbol->string carta ) 0 )))) El par\u00e1metro orden es una lista de todos los caracteres que representan los posibles valores de una carta, ordenados de menor a mayor. Por ejemplo: 1 2 3 4 ( define orden ' ( #\\2 #\\3 #\\4 #\\5 #\\6 #\\7 #\\8 #\\9 #\\0 #\\J #\\Q #\\K #\\A )) ( valor-carta ' A\u2660 orden ) ; \u21d2 13 ( valor-carta ' J\u2665 orden ) ; \u21d2 10 ( valor-carta ' 2\u2666 orden ) ; \u21d2 1 Implementa, utilizando funciones de orden superior y funciones definidas anteriormente en esta pr\u00e1ctica, la funci\u00f3n (mano-ganadora lista-manos) que recibe una lista de manos y devuelve la posici\u00f3n de la mano ganadora utilizando la valoraci\u00f3n del p\u00f3ker. La mano ganadora es la que tiene una carta m\u00e1s alta. Si hay empate, deber\u00e1s devolver la posici\u00f3n de la primera mano que participa en el empate. Pista Puedes definir una funci\u00f3n de un \u00fanico par\u00e1metro que devuelve el valor de una carta usando el orden definido por el p\u00f3ker usando la siguiente expresi\u00f3n lambda: 1 2 3 ( lambda ( carta ) ( valor-carta carta ' ( #\\2 #\\3 #\\4 #\\5 #\\6 #\\7 #\\8 #\\9 #\\0 #\\J #\\Q #\\K #\\A ))) Puedes usar cualquier funci\u00f3n definida anteriormente. 1 2 3 ( define lista-manos ( reparte 3 5 ( mezcla ( baraja-poker )))) ; lista-manos \u21d2 ((9\u2666 2\u2666 K\u2665 0\u2666 7\u2665) (6\u2666 4\u2660 7\u2663 5\u2665 4\u2666) (0\u2663 4\u2663 5\u2660 3\u2665 J\u2665)) ( mano-ganadora lista-manos ) ; \u21d2 0 Lenguajes y Paradigmas de Programaci\u00f3n, curso 2019-20 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Domingo Gallardo, Cristina Pomares, Antonio Bot\u00eda, Francisco Mart\u00ednez","title":"Ejercicio 5"},{"location":"practicas/practica05/practica05.html","text":"Pr\u00e1ctica 5: Procedimientos recursivos e iterativos \u00b6 Entrega de la pr\u00e1ctica \u00b6 Para entregar la pr\u00e1ctica debes subir a Moodle el fichero practica05.rkt con una cabecera inicial con tu nombre y apellidos, y las soluciones de cada ejercicio separadas por comentarios. Cada soluci\u00f3n debe incluir: La definici\u00f3n de las funciones que resuelven el ejercicio. Un conjunto de pruebas que comprueben su funcionamiento utilizando el API RackUnit . Ejercicios \u00b6 Ejercicio 1 \u00b6 a) Implementa una versi\u00f3n recursiva iterativa de la funci\u00f3n (concat lista) que toma como argumento una lista de cadenas y devuelve una cadena resultante de concatenar todas las palabras de la lista. La funci\u00f3n concat deber\u00e1 llamar a la funci\u00f3n concat-iter que es la que implementa propiamente la versi\u00f3n iterativa usando recursi\u00f3n por la cola. Ejemplo: 1 2 ( concat ' ( \"hola\" \"y\" \"adi\u00f3s\" )) ; \u21d2 \"holayadi\u00f3s\") ( concat-iter ' ( \"hola\" \"y\" \"adi\u00f3s\" ) \"\" ) ; \u21d2 \"holayadi\u00f3s\") b) Define utilizando recursi\u00f3n por la cola la funci\u00f3n (min-max lista) que recibe una lista num\u00e9rica y devuelve una pareja con el m\u00ednimo y el m\u00e1ximo de sus elementos. Ejemplo: 1 2 ( min-max ' ( 2 5 9 12 5 0 4 )) ; \u21d2 (0 . 12) ( min-max-iter ' ( 5 9 12 5 0 4 ) ( cons 2 2 )) ; \u21d2 (0 . 12) Ejercicio 2 \u00b6 a) Implementa utilizando recursi\u00f3n por la cola las funciones expande-pareja y expande-parejas de la pr\u00e1ctica 3. Ejemplo: 1 2 3 ( expande-pareja ( cons ' a 4 )) ; \u21d2 (a a a a) ( expande-parejas ' ( #t . 3 ) ' ( \"LPP\" . 2 ) ' ( b . 4 )) ; \u21d2 (#t #t #t \"LPP\" \"LPP\" b b b b) b) Implementa utilizando recursi\u00f3n por la cola la funci\u00f3n (rotar k lista) que mueve k elementos de la cabeza de la lista al final. No es necesario utilizar una funci\u00f3n iterativa auxiliar , puedes hacer que la propia funci\u00f3n rotar sea iterativa usando el par\u00e1metro lista como el par\u00e1metro donde acumular el resultado. Ejemplo: 1 ( rotar 4 ' ( a b c d e f g )) ; \u21d2 (e f g a b c d) Ejercicio 3 \u00b6 a) Implementa utilizando recursi\u00f3n por la cola la funci\u00f3n mi-foldl que haga lo mismo que la funci\u00f3n de orden superior foldl . 1 2 ( mi-foldl string-append \"****\" ' ( \"hola\" \"que\" \"tal\" )) \u21d2 \"talquehola****\" ( mi-foldl cons ' () ' ( 1 2 3 4 )) ; \u21d2 (4 3 2 1) b) Implementa una versi\u00f3n con recursi\u00f3n por la cola del predicado (prefijo-lista? lista1 lista2) que comprueba si la primera lista es prefijo de la segunda. Suponemos que siempre la primera lista ser\u00e1 m\u00e1s peque\u00f1a que la segunda. Ejemplos: 1 2 ( prefijo-lista? ' ( a b c ) ' ( a b c d e )) \u21d2 #t ( prefijo-lista? ' ( b c ) ' ( a b c d e )) \u21d2 #f Ejercicio 4 \u00b6 Realiza una implementaci\u00f3n que utilice la t\u00e9cnica de la memoization del algoritmo que devuelve la serie de Pascal . 1 2 3 ( define diccionario ( crea-diccionario )) ( pascal-memo 8 4 diccionario ) ; \u21d2 70 ( pascal-memo 40 20 diccionario ) ; \u21d2 137846528820 Ejercicio 5 \u00b6 a) Usando gr\u00e1ficos de tortuga implementa la figura recursiva conocida como curva de Koch . Debes definir una funci\u00f3n recursiva (koch nivel trazo) que dibuje una curva de Koch de nivel nivel y de longitud trazo . Como pista, para dibujar una curva de Koch de nivel n y longitud l, se deber\u00e1n dibujar 4 curvas de Koch de nivel n-1 y longitud l/3. En estas 4 curvas consecutivas, el \u00e1ngulo de inclinaci\u00f3n de la segunda curva con respecto a la primera es de 60 grados. Puedes ver ejemplos de las curvas de nivel 1, 2 y 3 en las siguientes figuras: b) Implementa la funci\u00f3n (copo-nieve nivel trazo) que, usando la funci\u00f3n anterior, dibuje el copo de nieve de Koch que puedes ver en los siguientes ejemplos. Ejercicio 6 \u00b6 Define la funci\u00f3n (alfombra-sierpinski tam) que construya la Alfombra de Sierpinski (una variante del Tri\u00e1gulo de Sierpinski que hemos visto en teor\u00eda) de lado tam p\u00edxeles utilizando gr\u00e1ficos de tortuga. Por ejemplo, la llamada a (alfombra-sierpinski 500) debe dibujar la siguiente figura: Lenguajes y Paradigmas de Programaci\u00f3n, curso 2019-20 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Domingo Gallardo, Cristina Pomares, Antonio Bot\u00eda, Francisco Mart\u00ednez","title":"Pr\u00e1ctica 5"},{"location":"practicas/practica05/practica05.html#practica-5-procedimientos-recursivos-e-iterativos","text":"","title":"Pr\u00e1ctica 5: Procedimientos recursivos e iterativos"},{"location":"practicas/practica05/practica05.html#entrega-de-la-practica","text":"Para entregar la pr\u00e1ctica debes subir a Moodle el fichero practica05.rkt con una cabecera inicial con tu nombre y apellidos, y las soluciones de cada ejercicio separadas por comentarios. Cada soluci\u00f3n debe incluir: La definici\u00f3n de las funciones que resuelven el ejercicio. Un conjunto de pruebas que comprueben su funcionamiento utilizando el API RackUnit .","title":"Entrega de la pr\u00e1ctica"},{"location":"practicas/practica05/practica05.html#ejercicios","text":"","title":"Ejercicios"},{"location":"practicas/practica05/practica05.html#ejercicio-1","text":"a) Implementa una versi\u00f3n recursiva iterativa de la funci\u00f3n (concat lista) que toma como argumento una lista de cadenas y devuelve una cadena resultante de concatenar todas las palabras de la lista. La funci\u00f3n concat deber\u00e1 llamar a la funci\u00f3n concat-iter que es la que implementa propiamente la versi\u00f3n iterativa usando recursi\u00f3n por la cola. Ejemplo: 1 2 ( concat ' ( \"hola\" \"y\" \"adi\u00f3s\" )) ; \u21d2 \"holayadi\u00f3s\") ( concat-iter ' ( \"hola\" \"y\" \"adi\u00f3s\" ) \"\" ) ; \u21d2 \"holayadi\u00f3s\") b) Define utilizando recursi\u00f3n por la cola la funci\u00f3n (min-max lista) que recibe una lista num\u00e9rica y devuelve una pareja con el m\u00ednimo y el m\u00e1ximo de sus elementos. Ejemplo: 1 2 ( min-max ' ( 2 5 9 12 5 0 4 )) ; \u21d2 (0 . 12) ( min-max-iter ' ( 5 9 12 5 0 4 ) ( cons 2 2 )) ; \u21d2 (0 . 12)","title":"Ejercicio 1"},{"location":"practicas/practica05/practica05.html#ejercicio-2","text":"a) Implementa utilizando recursi\u00f3n por la cola las funciones expande-pareja y expande-parejas de la pr\u00e1ctica 3. Ejemplo: 1 2 3 ( expande-pareja ( cons ' a 4 )) ; \u21d2 (a a a a) ( expande-parejas ' ( #t . 3 ) ' ( \"LPP\" . 2 ) ' ( b . 4 )) ; \u21d2 (#t #t #t \"LPP\" \"LPP\" b b b b) b) Implementa utilizando recursi\u00f3n por la cola la funci\u00f3n (rotar k lista) que mueve k elementos de la cabeza de la lista al final. No es necesario utilizar una funci\u00f3n iterativa auxiliar , puedes hacer que la propia funci\u00f3n rotar sea iterativa usando el par\u00e1metro lista como el par\u00e1metro donde acumular el resultado. Ejemplo: 1 ( rotar 4 ' ( a b c d e f g )) ; \u21d2 (e f g a b c d)","title":"Ejercicio 2"},{"location":"practicas/practica05/practica05.html#ejercicio-3","text":"a) Implementa utilizando recursi\u00f3n por la cola la funci\u00f3n mi-foldl que haga lo mismo que la funci\u00f3n de orden superior foldl . 1 2 ( mi-foldl string-append \"****\" ' ( \"hola\" \"que\" \"tal\" )) \u21d2 \"talquehola****\" ( mi-foldl cons ' () ' ( 1 2 3 4 )) ; \u21d2 (4 3 2 1) b) Implementa una versi\u00f3n con recursi\u00f3n por la cola del predicado (prefijo-lista? lista1 lista2) que comprueba si la primera lista es prefijo de la segunda. Suponemos que siempre la primera lista ser\u00e1 m\u00e1s peque\u00f1a que la segunda. Ejemplos: 1 2 ( prefijo-lista? ' ( a b c ) ' ( a b c d e )) \u21d2 #t ( prefijo-lista? ' ( b c ) ' ( a b c d e )) \u21d2 #f","title":"Ejercicio 3"},{"location":"practicas/practica05/practica05.html#ejercicio-4","text":"Realiza una implementaci\u00f3n que utilice la t\u00e9cnica de la memoization del algoritmo que devuelve la serie de Pascal . 1 2 3 ( define diccionario ( crea-diccionario )) ( pascal-memo 8 4 diccionario ) ; \u21d2 70 ( pascal-memo 40 20 diccionario ) ; \u21d2 137846528820","title":"Ejercicio 4"},{"location":"practicas/practica05/practica05.html#ejercicio-5","text":"a) Usando gr\u00e1ficos de tortuga implementa la figura recursiva conocida como curva de Koch . Debes definir una funci\u00f3n recursiva (koch nivel trazo) que dibuje una curva de Koch de nivel nivel y de longitud trazo . Como pista, para dibujar una curva de Koch de nivel n y longitud l, se deber\u00e1n dibujar 4 curvas de Koch de nivel n-1 y longitud l/3. En estas 4 curvas consecutivas, el \u00e1ngulo de inclinaci\u00f3n de la segunda curva con respecto a la primera es de 60 grados. Puedes ver ejemplos de las curvas de nivel 1, 2 y 3 en las siguientes figuras: b) Implementa la funci\u00f3n (copo-nieve nivel trazo) que, usando la funci\u00f3n anterior, dibuje el copo de nieve de Koch que puedes ver en los siguientes ejemplos.","title":"Ejercicio 5"},{"location":"practicas/practica05/practica05.html#ejercicio-6","text":"Define la funci\u00f3n (alfombra-sierpinski tam) que construya la Alfombra de Sierpinski (una variante del Tri\u00e1gulo de Sierpinski que hemos visto en teor\u00eda) de lado tam p\u00edxeles utilizando gr\u00e1ficos de tortuga. Por ejemplo, la llamada a (alfombra-sierpinski 500) debe dibujar la siguiente figura: Lenguajes y Paradigmas de Programaci\u00f3n, curso 2019-20 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Domingo Gallardo, Cristina Pomares, Antonio Bot\u00eda, Francisco Mart\u00ednez","title":"Ejercicio 6"},{"location":"practicas/practica06/practica06.html","text":"Pr\u00e1ctica 6: Listas estructuradas \u00b6 Entrega de la pr\u00e1ctica \u00b6 Para entregar la pr\u00e1ctica debes subir a Moodle el fichero practica06.rkt con una cabecera inicial con tu nombre y apellidos, y las soluciones de cada ejercicio separadas por comentarios. Cada soluci\u00f3n debe incluir: La definici\u00f3n de las funciones que resuelven el ejercicio. Un conjunto de pruebas que comprueben su funcionamiento utilizando el API RackUnit . Ejercicios \u00b6 Ejercicio 1 \u00b6 a) Escribe la lista estructurada correspondiente a la siguiente representaci\u00f3n gr\u00e1fica por niveles. Para comprobar si la has definido correctamente puedes intentar obtener algunos de los elementos de la lista, como mostramos en el check-equal? que hay a continuaci\u00f3n. 1 2 3 4 5 6 7 8 * / | \\ | | \\ * d * / \\ / / | \\ a b c * * h | / \\ e f g 1 2 ( define lista-a ' ( ________ )) ( check-equal? ( cadddr ( caddr lista-a )) 'h ) b) Dibuja la representaci\u00f3n en niveles de las siguientes listas estructurada 1 2 ( define lista-b1 ' (( 2 ( 3 )) ( 4 2 ) (( 2 ) 3 ))) ( define lista-b2 ' (( b ) ( c ( a )) d ( a ))) c) Dada la definici\u00f3n de cuadrado-estruct vista en teor\u00eda: Indica qu\u00e9 devuelve la expresi\u00f3n (cuadrado-estruct lista-b1) . La lista lista-b1 es la definida en el apartado anterior. En la evaluaci\u00f3n de la expresi\u00f3n anterior, indica cu\u00e1les son los argumentos que se pasan por par\u00e1metro en las llamadas recursivas a cuadrado-estruct marcadas con 1 y 2 . En la evaluaci\u00f3n de la expresi\u00f3n anterior, indican qu\u00e9 devuelven las llamadas recursivas marcadas con 1 y 2 . d) Para entender el funcionamiento de las funciones de orden superior que trabajan sobre listas estructuradas es muy importante entender qu\u00e9 devuelve la expresi\u00f3n map que se aplica a la lista. Dada la definici\u00f3n de (nivel-hoja-fos dato lista) vista en teor\u00eda, indica qu\u00e9 devuelve la siguiente expresi\u00f3n (es la expresi\u00f3n map que hay en su cuerpo). La lista lista-b2 es la definida en el apartado anterior. Utiliza el dibujo que has hecho en el ejercicio anterior para entender el funcionamiento de la expresi\u00f3n. 1 2 3 4 5 ( map ( lambda ( elem ) ( if ( hoja? elem ) ( if ( equal? elem ' a ) 0 -1 ) ( nivel-hoja-fos ' a elem ))) lista-b2 ) Ejercicio 2 \u00b6 a) Implementa la funci\u00f3n recursiva (cuenta-pares lista) que recibe una lista estructurada y cuenta la cantidad de n\u00fameros pares que contiene. Implementa dos versiones de la funci\u00f3n, una con recursi\u00f3n pura y otra con funciones de orden superior . Ejemplos: 1 2 ( cuenta-pares ' ( 1 ( 2 3 ) 4 ( 5 6 ))) ; \u21d2 3 ( cuenta-pares ' ((( 1 2 ) 3 ( 4 ) 5 ) (((( 6 )))))) ; \u21d2 3 b) Implementa la funci\u00f3n recursiva (todos-positivos lista) que recibe una lista estructurada con n\u00fameros y comprueba si todos sus elementos son positivos. Implementa dos versiones de la funci\u00f3n, una con recursi\u00f3n pura y otra con funciones de orden superior . Ejemplos: 1 2 ( todos-positivos-fos ' ( 1 ( 2 ( 3 ( -3 ))) 4 )) ; \u21d2 #f ( todos-positivos-fos ' ( 1 ( 2 ( 3 ( 3 ))) 4 )) ; \u21d2 #t Ejercicio 3 \u00b6 Implementa la funci\u00f3n (cumplen-predicado pred lista) que devuelva una lista con todos los elementos de lista estructurada que cumplen un predicado. Implementa dos versiones, una recursiva pura y otra usando funciones de orden superior . Ejemplo: 1 2 ( cumplen-predicado even? ' ( 1 ( 2 ( 3 ( 4 ))) ( 5 6 ))) ; \u21d2 (2 4 6) ( cumplen-predicado pair? ' ((( 1 . 2 ) 3 ( 4 . 3 ) 5 ) 6 )) ; \u21d2 ((1 . 2) (4 . 3) Utilizando la funci\u00f3n anterior implementa las siguientes funciones: Funci\u00f3n (busca-mayores n lista-num) que recibe una lista estructurada con n\u00fameros y un n\u00famero n y devuelve una lista plana con los n\u00fameros de la lista original mayores que n . 1 ( busca-mayores 10 ' ( -1 ( 20 ( 10 12 ) ( 30 ( 25 ( 15 )))))) ; \u21d2 (20 12 30 25 15) Funci\u00f3n (empieza-por char lista-pal) que recibe una lista estructurada con s\u00edmbolos y un car\u00e1cter char y devuelve una lista plana con los s\u00edmbolos de la lista original que comienzan por el car\u00e1cter char . 1 2 ( empieza-por #\\m ' (( hace ( mucho tiempo )) ( en ) ( una galaxia (( muy muy ) lejana ))) ; \u21d2 (mucho muy muy) Ejercicio 4 \u00b6 a) Implementa la funci\u00f3n recursiva (sustituye-elem elem-old elem-new lista) que recibe como argumentos una lista estructurada y dos elementos, y devuelve otra lista con la misma estructura, pero en la que se ha sustituido las ocurrencias de elem-old por elem-new . Ejemplo: 1 2 ( sustituye-elem ' ( a b ( c d ( e c )) c ( f ( c ) g )) 'c 'h ) ; \u21d2 (a b (h d (e h)) h (f (h) g)) b) Implementa la funci\u00f3n recursiva (diff-listas l1 l2) que tome como argumentos dos listas estructuradas con la misma estructura, pero con diferentes elementos, y devuelva una lista de parejas que contenga los elementos que son diferentes. Ejemplos: 1 2 3 4 5 ( diff-listas ' ( a ( b (( c )) d e ) f ) ' ( 1 ( b (( 2 )) 3 4 ) f )) ; \u21d2 ((a . 1) (c . 2) (d . 3) (e . 4)) ( diff-listas ' (( a b ) c ) ' (( a b ) c )) ; \u21d2 () Ejercicio 5 \u00b6 Dos funciones sobre niveles: a) Define la funci\u00f3n recursiva (mezclar lista1 lista2 n) que reciba dos listas estructuradas con la misma estructura y un n\u00famero que indica un nivel. Devuelve una nueva lista estructurada con la misma estructura que las listas originales, con los elementos de lista1 que tienen un nivel menor o igual que n y los elementos de lista2 que tienen un nivel mayor que n . 1 2 3 ( define lista1 ' ((( a b ) (( c ))) ( d ) e )) ( define lista2 ' ((( 1 2 ) (( 3 ))) ( 4 ) 5 )) ( mezclar lista1 lista2 2 ) \u2192 ((( 1 2 ) (( 3 ))) ( d ) e ) b) Implementa la funci\u00f3n (nivel-elemento lista) que reciba una lista estructurada y devuelva una pareja (elem . nivel) , donde la parte izquierda es el elemento que se encuentra a mayor nivel y la parte derecha el nivel en el que se encuentra. Puedes definir alguna funci\u00f3n auxiliar si lo necesitas. Puedes hacerlo con recursi\u00f3n o con funciones de orden superior. 1 2 ( nivel-elemento ' ( 2 ( 3 ))) ;\u21d2 (3 . 2) ( nivel-elemento ' (( 2 ) ( 3 ( 4 )(((((( 5 ))) 6 )) 7 )) 8 )) ; \u21d2 (5 . 8) Lenguajes y Paradigmas de Programaci\u00f3n, curso 2019-20 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Domingo Gallardo, Cristina Pomares, Antonio Bot\u00eda, Francisco Mart\u00ednez","title":"Pr\u00e1ctica 6"},{"location":"practicas/practica06/practica06.html#practica-6-listas-estructuradas","text":"","title":"Pr\u00e1ctica 6: Listas estructuradas"},{"location":"practicas/practica06/practica06.html#entrega-de-la-practica","text":"Para entregar la pr\u00e1ctica debes subir a Moodle el fichero practica06.rkt con una cabecera inicial con tu nombre y apellidos, y las soluciones de cada ejercicio separadas por comentarios. Cada soluci\u00f3n debe incluir: La definici\u00f3n de las funciones que resuelven el ejercicio. Un conjunto de pruebas que comprueben su funcionamiento utilizando el API RackUnit .","title":"Entrega de la pr\u00e1ctica"},{"location":"practicas/practica06/practica06.html#ejercicios","text":"","title":"Ejercicios"},{"location":"practicas/practica06/practica06.html#ejercicio-1","text":"a) Escribe la lista estructurada correspondiente a la siguiente representaci\u00f3n gr\u00e1fica por niveles. Para comprobar si la has definido correctamente puedes intentar obtener algunos de los elementos de la lista, como mostramos en el check-equal? que hay a continuaci\u00f3n. 1 2 3 4 5 6 7 8 * / | \\ | | \\ * d * / \\ / / | \\ a b c * * h | / \\ e f g 1 2 ( define lista-a ' ( ________ )) ( check-equal? ( cadddr ( caddr lista-a )) 'h ) b) Dibuja la representaci\u00f3n en niveles de las siguientes listas estructurada 1 2 ( define lista-b1 ' (( 2 ( 3 )) ( 4 2 ) (( 2 ) 3 ))) ( define lista-b2 ' (( b ) ( c ( a )) d ( a ))) c) Dada la definici\u00f3n de cuadrado-estruct vista en teor\u00eda: Indica qu\u00e9 devuelve la expresi\u00f3n (cuadrado-estruct lista-b1) . La lista lista-b1 es la definida en el apartado anterior. En la evaluaci\u00f3n de la expresi\u00f3n anterior, indica cu\u00e1les son los argumentos que se pasan por par\u00e1metro en las llamadas recursivas a cuadrado-estruct marcadas con 1 y 2 . En la evaluaci\u00f3n de la expresi\u00f3n anterior, indican qu\u00e9 devuelven las llamadas recursivas marcadas con 1 y 2 . d) Para entender el funcionamiento de las funciones de orden superior que trabajan sobre listas estructuradas es muy importante entender qu\u00e9 devuelve la expresi\u00f3n map que se aplica a la lista. Dada la definici\u00f3n de (nivel-hoja-fos dato lista) vista en teor\u00eda, indica qu\u00e9 devuelve la siguiente expresi\u00f3n (es la expresi\u00f3n map que hay en su cuerpo). La lista lista-b2 es la definida en el apartado anterior. Utiliza el dibujo que has hecho en el ejercicio anterior para entender el funcionamiento de la expresi\u00f3n. 1 2 3 4 5 ( map ( lambda ( elem ) ( if ( hoja? elem ) ( if ( equal? elem ' a ) 0 -1 ) ( nivel-hoja-fos ' a elem ))) lista-b2 )","title":"Ejercicio 1"},{"location":"practicas/practica06/practica06.html#ejercicio-2","text":"a) Implementa la funci\u00f3n recursiva (cuenta-pares lista) que recibe una lista estructurada y cuenta la cantidad de n\u00fameros pares que contiene. Implementa dos versiones de la funci\u00f3n, una con recursi\u00f3n pura y otra con funciones de orden superior . Ejemplos: 1 2 ( cuenta-pares ' ( 1 ( 2 3 ) 4 ( 5 6 ))) ; \u21d2 3 ( cuenta-pares ' ((( 1 2 ) 3 ( 4 ) 5 ) (((( 6 )))))) ; \u21d2 3 b) Implementa la funci\u00f3n recursiva (todos-positivos lista) que recibe una lista estructurada con n\u00fameros y comprueba si todos sus elementos son positivos. Implementa dos versiones de la funci\u00f3n, una con recursi\u00f3n pura y otra con funciones de orden superior . Ejemplos: 1 2 ( todos-positivos-fos ' ( 1 ( 2 ( 3 ( -3 ))) 4 )) ; \u21d2 #f ( todos-positivos-fos ' ( 1 ( 2 ( 3 ( 3 ))) 4 )) ; \u21d2 #t","title":"Ejercicio 2"},{"location":"practicas/practica06/practica06.html#ejercicio-3","text":"Implementa la funci\u00f3n (cumplen-predicado pred lista) que devuelva una lista con todos los elementos de lista estructurada que cumplen un predicado. Implementa dos versiones, una recursiva pura y otra usando funciones de orden superior . Ejemplo: 1 2 ( cumplen-predicado even? ' ( 1 ( 2 ( 3 ( 4 ))) ( 5 6 ))) ; \u21d2 (2 4 6) ( cumplen-predicado pair? ' ((( 1 . 2 ) 3 ( 4 . 3 ) 5 ) 6 )) ; \u21d2 ((1 . 2) (4 . 3) Utilizando la funci\u00f3n anterior implementa las siguientes funciones: Funci\u00f3n (busca-mayores n lista-num) que recibe una lista estructurada con n\u00fameros y un n\u00famero n y devuelve una lista plana con los n\u00fameros de la lista original mayores que n . 1 ( busca-mayores 10 ' ( -1 ( 20 ( 10 12 ) ( 30 ( 25 ( 15 )))))) ; \u21d2 (20 12 30 25 15) Funci\u00f3n (empieza-por char lista-pal) que recibe una lista estructurada con s\u00edmbolos y un car\u00e1cter char y devuelve una lista plana con los s\u00edmbolos de la lista original que comienzan por el car\u00e1cter char . 1 2 ( empieza-por #\\m ' (( hace ( mucho tiempo )) ( en ) ( una galaxia (( muy muy ) lejana ))) ; \u21d2 (mucho muy muy)","title":"Ejercicio 3"},{"location":"practicas/practica06/practica06.html#ejercicio-4","text":"a) Implementa la funci\u00f3n recursiva (sustituye-elem elem-old elem-new lista) que recibe como argumentos una lista estructurada y dos elementos, y devuelve otra lista con la misma estructura, pero en la que se ha sustituido las ocurrencias de elem-old por elem-new . Ejemplo: 1 2 ( sustituye-elem ' ( a b ( c d ( e c )) c ( f ( c ) g )) 'c 'h ) ; \u21d2 (a b (h d (e h)) h (f (h) g)) b) Implementa la funci\u00f3n recursiva (diff-listas l1 l2) que tome como argumentos dos listas estructuradas con la misma estructura, pero con diferentes elementos, y devuelva una lista de parejas que contenga los elementos que son diferentes. Ejemplos: 1 2 3 4 5 ( diff-listas ' ( a ( b (( c )) d e ) f ) ' ( 1 ( b (( 2 )) 3 4 ) f )) ; \u21d2 ((a . 1) (c . 2) (d . 3) (e . 4)) ( diff-listas ' (( a b ) c ) ' (( a b ) c )) ; \u21d2 ()","title":"Ejercicio 4"},{"location":"practicas/practica06/practica06.html#ejercicio-5","text":"Dos funciones sobre niveles: a) Define la funci\u00f3n recursiva (mezclar lista1 lista2 n) que reciba dos listas estructuradas con la misma estructura y un n\u00famero que indica un nivel. Devuelve una nueva lista estructurada con la misma estructura que las listas originales, con los elementos de lista1 que tienen un nivel menor o igual que n y los elementos de lista2 que tienen un nivel mayor que n . 1 2 3 ( define lista1 ' ((( a b ) (( c ))) ( d ) e )) ( define lista2 ' ((( 1 2 ) (( 3 ))) ( 4 ) 5 )) ( mezclar lista1 lista2 2 ) \u2192 ((( 1 2 ) (( 3 ))) ( d ) e ) b) Implementa la funci\u00f3n (nivel-elemento lista) que reciba una lista estructurada y devuelva una pareja (elem . nivel) , donde la parte izquierda es el elemento que se encuentra a mayor nivel y la parte derecha el nivel en el que se encuentra. Puedes definir alguna funci\u00f3n auxiliar si lo necesitas. Puedes hacerlo con recursi\u00f3n o con funciones de orden superior. 1 2 ( nivel-elemento ' ( 2 ( 3 ))) ;\u21d2 (3 . 2) ( nivel-elemento ' (( 2 ) ( 3 ( 4 )(((((( 5 ))) 6 )) 7 )) 8 )) ; \u21d2 (5 . 8) Lenguajes y Paradigmas de Programaci\u00f3n, curso 2019-20 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Domingo Gallardo, Cristina Pomares, Antonio Bot\u00eda, Francisco Mart\u00ednez","title":"Ejercicio 5"},{"location":"practicas/practica07/practica07.html","text":"Pr\u00e1ctica 7: \u00c1rboles \u00b6 Entrega de la pr\u00e1ctica \u00b6 Para entregar la pr\u00e1ctica debes subir a Moodle el fichero practica07.rkt con una cabecera inicial con tu nombre y apellidos, y las soluciones de cada ejercicio separadas por comentarios. Cada soluci\u00f3n debe incluir: La definici\u00f3n de las funciones que resuelven el ejercicio. Un conjunto de pruebas que comprueben su funcionamiento utilizando la librer\u00eda schemeunit . Ejercicios \u00b6 Importante Antes de empezar la pr\u00e1ctica debes haber estudiado los apartados de \u00e1rboles gen\u00e9ricos y \u00e1rboles binarios del tema 4 de teor\u00eda. Copia al principio de la pr\u00e1ctica las funciones de las barreras de abstracci\u00f3n de \u00e1rboles y \u00e1rboles binarios y utiliza esas funciones en todos los ejercicios cuando est\u00e9s realizando operaciones sobre \u00e1rboles. Ejercicio 1 \u00b6 a.1) Escribe la sentencia en Scheme que define el siguiente \u00e1rbol gen\u00e9rico y escribe utilizando las funciones de la barrera de abstracci\u00f3n de \u00e1rboles una expresi\u00f3n que devuelva el n\u00famero 10. 1 2 (define arbol '(------------)) (check-equal? ------------------- 10) a.2) Las funciones que suman los datos de un \u00e1rbol utilizando recursi\u00f3n mutua y que hemos visto en teor\u00eda son las siguientes: 1 2 3 4 5 6 7 8 9 ( define ( suma-datos-arbol arbol ) ( + ( dato-arbol arbol ) ( suma-datos-bosque ( hijos-arbol arbol )))) ( define ( suma-datos-bosque bosque ) ( if ( null? bosque ) 0 ( + ( suma-datos-arbol ( car bosque )) ( suma-datos-bosque ( cdr bosque ))))) Si realizamos la siguiente llamada a la funci\u00f3n suma-datos-bosque , siendo arbol el definido en el apartado anterior: 1 ( suma-datos-bosque ( hijos-arbol arbol )) \u00bfQu\u00e9 devuelve la invocaci\u00f3n a (suma-datos-arbol (car bosque)) que se realiza dentro de la funci\u00f3n? \u00bfQu\u00e9 devuelve la primera llamada recursiva a suma-datos-bosque ? Escribe la contestaci\u00f3n a estas preguntas como comentarios en el fichero de la pr\u00e1ctica. a.3) La funci\u00f3n de orden superior que hemos visto en teor\u00eda y que realiza tambi\u00e9n la suma de los datos de un \u00e1rbol es: 1 2 3 ( define ( suma-datos-arbol-fos arbol ) ( fold-right + ( dato-arbol arbol ) ( map suma-datos-arbol-fos ( hijos-arbol arbol )))) Si realizamos la siguiente llamada a la funci\u00f3n, siendo arbol el definido en el apartado anterior: 1 ( suma-datos-arbol-fos arbol ) \u00bfQu\u00e9 devuelve la invocaci\u00f3n a map dentro de la funci\u00f3n? \u00bfQu\u00e9 invocaciones se realizan a la funci\u00f3n + durante la ejecuci\u00f3n de fold-right sobre la lista devuelta por la invocaci\u00f3n a map ? Enum\u00e9ralas en orden, indicando sus par\u00e1metros y el valor devuelto en cada una de ellas. b.1) Escribe la sentencia en Scheme que define el siguiente \u00e1rbol binario y escribe utilizando las funciones de la barrera de abstracci\u00f3n de \u00e1rboles binarios una expresi\u00f3n que devuelva el n\u00famero 29. 1 2 (define arbolb '(------------------)) (check-equal? ---------------------- 29) Ejercicio 2 \u00b6 a) Implementa dos versiones de la funci\u00f3n (to-string-arbol arbol) que recibe un \u00e1rbol de s\u00edmbolos y devuelve la cadena resultante de concatenar todos los s\u00edmbolos en recorrido preorden. Debes implementar una versi\u00f3n con recursi\u00f3n mutua y otra (llamada to-string-arbol-fos ) con una \u00fanica funci\u00f3n en la que se use funciones de orden superior. Ejemplo: 1 2 ( define arbol2 ' ( a ( b ( c ( d )) ( e )) ( f ))) ( to-string-arbol arbol2 ) ; \u21d2 \"abcdef\" b) Implementa dos versiones de la funci\u00f3n (veces-arbol dato arbol) que recibe un \u00e1rbol y un dato y comprueba el n\u00famero de veces que aparece el dato en el \u00e1rbol. Debes implementar una funci\u00f3n con recursi\u00f3n mutua y otra con funciones de orden superior. 1 2 ( veces-arbol 'b ' ( a ( b ( c ) ( d )) ( b ( b ) ( f )))) ; \u21d2 3 ( veces-arbol 'g ' ( a ( b ( c ) ( d )) ( b ( b ) ( f )))) ; \u21d2 0 Ejercicio 3 \u00b6 a) Implementa, utilizando funciones de orden superior, la funci\u00f3n (suma-raices-hijos arbol) que devuelva la suma de las ra\u00edces de los hijos de un \u00e1rbol gen\u00e9rico. Ejemplo: 1 2 3 ( define arbol3 ' ( 20 ( 2 ) ( 8 ( 4 ) ( 2 )) ( 9 ( 5 )))) ( suma-raices-hijos arbol3 ) ; \u21d2 19 ( suma-raices-hijos ( cadr ( hijos-arbol arbol3 ))) ; \u21d2 6 b) Implementa dos versiones, una con recursi\u00f3n mutua y otra con funciones de orden superior, de la funci\u00f3n (raices-mayores-arbol? arbol) que recibe un \u00e1rbol y comprueba que su ra\u00edz sea mayor que la suma de las ra\u00edces de los hijos y que todos los hijos cumplen tambi\u00e9n esta propiedad. Ejemplos: 1 2 ( raices-mayores-arbol? arbol3 ) ; \u21d2 #t ( raices-mayores-arbol? ' ( 20 ( 2 ) ( 8 ( 4 ) ( 5 )) ( 9 ( 5 )))) ; \u21d2 #f c) Define la funci\u00f3n (comprueba-raices-arbol arbol) que recibe un arbol y que devuelve otro arbol en el que los nodos se han sustituido por 1 o 0 seg\u00fan si son mayores que la suma de las ra\u00edces de sus hijos o no. Ejemplos: 1 2 3 ( comprueba-raices-arbol arbol3 ) ; \u21d2 {1 {1} {1 {1} {1}} {1 {1}}} ( comprueba-raices-arbol ' ( 20 ( 2 ) ( 8 ( 4 ) ( 5 )) ( 9 ( 5 )))) ; \u21d2 {1 {1} {0 {1} {1}} {1 {1}}} Ejercicio 4 \u00b6 a) Define la funci\u00f3n (es-camino? lista arbol) que debe comprobar si la secuencia de elementos de la lista se corresponde con un camino del \u00e1rbol que empieza en la ra\u00edz y que termina exactamente en una hoja. Suponemos que lista contiene al menos un elemento Por ejemplo, la lista '(a b a) s\u00ed que es camino en el siguiente \u00e1rbol, pero la lista '(a b) no. Ejemplos: suponiendo que arbol es el \u00e1rbol definido por la figura anterior: 1 2 3 ( es-camino? ' ( a b a ) arbol ) \u21d2 #t ( es-camino? ' ( a b ) arbol ) \u21d2 #f ( es-camino? ' ( a b a b ) arbol ) \u21d2 #f b) Escribe la funci\u00f3n (nodos-nivel nivel arbol) que reciba un nivel y un \u00e1rbol gen\u00e9rico y devuelva una lista con todos los nodos que se encuentran en ese nivel. Ejemplos, suponiendo que arbol es el \u00e1rbol definido por la figura anterior: 1 2 3 4 ( nodos-nivel 0 arbol ) \u21d2 ' ( 1 ) ( nodos-nivel 1 arbol ) \u21d2 ' ( 2 6 ) ( nodos-nivel 2 arbol ) \u21d2 ' ( 3 5 7 ) ( nodos-nivel 3 arbol ) \u21d2 ' ( 4 2 ) Ejercicio 5 \u00b6 Dado un \u00e1rbol binario y un camino definido como una lista de s\u00edmbolos: '(< > = > > =) en el que: < : indica que nos vamos por la rama izquierda > : indica que nos vamos por la rama derecha = : indica que nos quedamos con el dato de ese nodo. Implementa la funci\u00f3n (camino-b-tree b-tree camino) que devuelva una lista con los datos recogidos por el camino. 1 2 ( camino-b-tree b-tree ' ( = < < = > = )) \u21d2 ' ( 9 3 4 ) ( camino-b-tree b-tree ' ( > = < < = )) \u21d2 ' ( 15 10 ) Lenguajes y Paradigmas de Programaci\u00f3n, curso 2018-19 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Domingo Gallardo, Cristina Pomares, Antonio Bot\u00eda, Francisco Mart\u00ednez","title":"Pr\u00e1ctica 7: \u00c1rboles"},{"location":"practicas/practica07/practica07.html#practica-7-arboles","text":"","title":"Pr\u00e1ctica 7: \u00c1rboles"},{"location":"practicas/practica07/practica07.html#entrega-de-la-practica","text":"Para entregar la pr\u00e1ctica debes subir a Moodle el fichero practica07.rkt con una cabecera inicial con tu nombre y apellidos, y las soluciones de cada ejercicio separadas por comentarios. Cada soluci\u00f3n debe incluir: La definici\u00f3n de las funciones que resuelven el ejercicio. Un conjunto de pruebas que comprueben su funcionamiento utilizando la librer\u00eda schemeunit .","title":"Entrega de la pr\u00e1ctica"},{"location":"practicas/practica07/practica07.html#ejercicios","text":"Importante Antes de empezar la pr\u00e1ctica debes haber estudiado los apartados de \u00e1rboles gen\u00e9ricos y \u00e1rboles binarios del tema 4 de teor\u00eda. Copia al principio de la pr\u00e1ctica las funciones de las barreras de abstracci\u00f3n de \u00e1rboles y \u00e1rboles binarios y utiliza esas funciones en todos los ejercicios cuando est\u00e9s realizando operaciones sobre \u00e1rboles.","title":"Ejercicios"},{"location":"practicas/practica07/practica07.html#ejercicio-1","text":"a.1) Escribe la sentencia en Scheme que define el siguiente \u00e1rbol gen\u00e9rico y escribe utilizando las funciones de la barrera de abstracci\u00f3n de \u00e1rboles una expresi\u00f3n que devuelva el n\u00famero 10. 1 2 (define arbol '(------------)) (check-equal? ------------------- 10) a.2) Las funciones que suman los datos de un \u00e1rbol utilizando recursi\u00f3n mutua y que hemos visto en teor\u00eda son las siguientes: 1 2 3 4 5 6 7 8 9 ( define ( suma-datos-arbol arbol ) ( + ( dato-arbol arbol ) ( suma-datos-bosque ( hijos-arbol arbol )))) ( define ( suma-datos-bosque bosque ) ( if ( null? bosque ) 0 ( + ( suma-datos-arbol ( car bosque )) ( suma-datos-bosque ( cdr bosque ))))) Si realizamos la siguiente llamada a la funci\u00f3n suma-datos-bosque , siendo arbol el definido en el apartado anterior: 1 ( suma-datos-bosque ( hijos-arbol arbol )) \u00bfQu\u00e9 devuelve la invocaci\u00f3n a (suma-datos-arbol (car bosque)) que se realiza dentro de la funci\u00f3n? \u00bfQu\u00e9 devuelve la primera llamada recursiva a suma-datos-bosque ? Escribe la contestaci\u00f3n a estas preguntas como comentarios en el fichero de la pr\u00e1ctica. a.3) La funci\u00f3n de orden superior que hemos visto en teor\u00eda y que realiza tambi\u00e9n la suma de los datos de un \u00e1rbol es: 1 2 3 ( define ( suma-datos-arbol-fos arbol ) ( fold-right + ( dato-arbol arbol ) ( map suma-datos-arbol-fos ( hijos-arbol arbol )))) Si realizamos la siguiente llamada a la funci\u00f3n, siendo arbol el definido en el apartado anterior: 1 ( suma-datos-arbol-fos arbol ) \u00bfQu\u00e9 devuelve la invocaci\u00f3n a map dentro de la funci\u00f3n? \u00bfQu\u00e9 invocaciones se realizan a la funci\u00f3n + durante la ejecuci\u00f3n de fold-right sobre la lista devuelta por la invocaci\u00f3n a map ? Enum\u00e9ralas en orden, indicando sus par\u00e1metros y el valor devuelto en cada una de ellas. b.1) Escribe la sentencia en Scheme que define el siguiente \u00e1rbol binario y escribe utilizando las funciones de la barrera de abstracci\u00f3n de \u00e1rboles binarios una expresi\u00f3n que devuelva el n\u00famero 29. 1 2 (define arbolb '(------------------)) (check-equal? ---------------------- 29)","title":"Ejercicio 1"},{"location":"practicas/practica07/practica07.html#ejercicio-2","text":"a) Implementa dos versiones de la funci\u00f3n (to-string-arbol arbol) que recibe un \u00e1rbol de s\u00edmbolos y devuelve la cadena resultante de concatenar todos los s\u00edmbolos en recorrido preorden. Debes implementar una versi\u00f3n con recursi\u00f3n mutua y otra (llamada to-string-arbol-fos ) con una \u00fanica funci\u00f3n en la que se use funciones de orden superior. Ejemplo: 1 2 ( define arbol2 ' ( a ( b ( c ( d )) ( e )) ( f ))) ( to-string-arbol arbol2 ) ; \u21d2 \"abcdef\" b) Implementa dos versiones de la funci\u00f3n (veces-arbol dato arbol) que recibe un \u00e1rbol y un dato y comprueba el n\u00famero de veces que aparece el dato en el \u00e1rbol. Debes implementar una funci\u00f3n con recursi\u00f3n mutua y otra con funciones de orden superior. 1 2 ( veces-arbol 'b ' ( a ( b ( c ) ( d )) ( b ( b ) ( f )))) ; \u21d2 3 ( veces-arbol 'g ' ( a ( b ( c ) ( d )) ( b ( b ) ( f )))) ; \u21d2 0","title":"Ejercicio 2"},{"location":"practicas/practica07/practica07.html#ejercicio-3","text":"a) Implementa, utilizando funciones de orden superior, la funci\u00f3n (suma-raices-hijos arbol) que devuelva la suma de las ra\u00edces de los hijos de un \u00e1rbol gen\u00e9rico. Ejemplo: 1 2 3 ( define arbol3 ' ( 20 ( 2 ) ( 8 ( 4 ) ( 2 )) ( 9 ( 5 )))) ( suma-raices-hijos arbol3 ) ; \u21d2 19 ( suma-raices-hijos ( cadr ( hijos-arbol arbol3 ))) ; \u21d2 6 b) Implementa dos versiones, una con recursi\u00f3n mutua y otra con funciones de orden superior, de la funci\u00f3n (raices-mayores-arbol? arbol) que recibe un \u00e1rbol y comprueba que su ra\u00edz sea mayor que la suma de las ra\u00edces de los hijos y que todos los hijos cumplen tambi\u00e9n esta propiedad. Ejemplos: 1 2 ( raices-mayores-arbol? arbol3 ) ; \u21d2 #t ( raices-mayores-arbol? ' ( 20 ( 2 ) ( 8 ( 4 ) ( 5 )) ( 9 ( 5 )))) ; \u21d2 #f c) Define la funci\u00f3n (comprueba-raices-arbol arbol) que recibe un arbol y que devuelve otro arbol en el que los nodos se han sustituido por 1 o 0 seg\u00fan si son mayores que la suma de las ra\u00edces de sus hijos o no. Ejemplos: 1 2 3 ( comprueba-raices-arbol arbol3 ) ; \u21d2 {1 {1} {1 {1} {1}} {1 {1}}} ( comprueba-raices-arbol ' ( 20 ( 2 ) ( 8 ( 4 ) ( 5 )) ( 9 ( 5 )))) ; \u21d2 {1 {1} {0 {1} {1}} {1 {1}}}","title":"Ejercicio 3"},{"location":"practicas/practica07/practica07.html#ejercicio-4","text":"a) Define la funci\u00f3n (es-camino? lista arbol) que debe comprobar si la secuencia de elementos de la lista se corresponde con un camino del \u00e1rbol que empieza en la ra\u00edz y que termina exactamente en una hoja. Suponemos que lista contiene al menos un elemento Por ejemplo, la lista '(a b a) s\u00ed que es camino en el siguiente \u00e1rbol, pero la lista '(a b) no. Ejemplos: suponiendo que arbol es el \u00e1rbol definido por la figura anterior: 1 2 3 ( es-camino? ' ( a b a ) arbol ) \u21d2 #t ( es-camino? ' ( a b ) arbol ) \u21d2 #f ( es-camino? ' ( a b a b ) arbol ) \u21d2 #f b) Escribe la funci\u00f3n (nodos-nivel nivel arbol) que reciba un nivel y un \u00e1rbol gen\u00e9rico y devuelva una lista con todos los nodos que se encuentran en ese nivel. Ejemplos, suponiendo que arbol es el \u00e1rbol definido por la figura anterior: 1 2 3 4 ( nodos-nivel 0 arbol ) \u21d2 ' ( 1 ) ( nodos-nivel 1 arbol ) \u21d2 ' ( 2 6 ) ( nodos-nivel 2 arbol ) \u21d2 ' ( 3 5 7 ) ( nodos-nivel 3 arbol ) \u21d2 ' ( 4 2 )","title":"Ejercicio 4"},{"location":"practicas/practica07/practica07.html#ejercicio-5","text":"Dado un \u00e1rbol binario y un camino definido como una lista de s\u00edmbolos: '(< > = > > =) en el que: < : indica que nos vamos por la rama izquierda > : indica que nos vamos por la rama derecha = : indica que nos quedamos con el dato de ese nodo. Implementa la funci\u00f3n (camino-b-tree b-tree camino) que devuelva una lista con los datos recogidos por el camino. 1 2 ( camino-b-tree b-tree ' ( = < < = > = )) \u21d2 ' ( 9 3 4 ) ( camino-b-tree b-tree ' ( > = < < = )) \u21d2 ' ( 15 10 ) Lenguajes y Paradigmas de Programaci\u00f3n, curso 2018-19 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Domingo Gallardo, Cristina Pomares, Antonio Bot\u00eda, Francisco Mart\u00ednez","title":"Ejercicio 5"},{"location":"practicas/practica08/practica08.html","text":"Pr\u00e1ctica 8: Programaci\u00f3n funcional en Swift (1) \u00b6 Entrega de la pr\u00e1ctica \u00b6 Para entregar la pr\u00e1ctica debes subir a Moodle el fichero practica08.swift con una cabecera inicial con tu nombre y apellidos, y las soluciones de cada ejercicio separadas por comentarios. Cada soluci\u00f3n debe incluir: La definici\u00f3n de las funciones que resuelven el ejercicio. Una visualizaci\u00f3n por pantalla de todos los ejemplos incluidos en el enunciado que demuestren qu\u00e9 hace la funci\u00f3n . Importante Antes de proceder a realizar los ejercicios de la pr\u00e1ctica te recomendamos que realices y pruebes los ejemplos presentados en el seminario de Swift . Tambi\u00e9n, como siempre, los apuntes de teor\u00eda de la semana pasada. Ejercicios \u00b6 Ejercicio 1 \u00b6 En la clase de teor\u00eda hemos presentado un ejemplo de la funci\u00f3n minMax(array: [Int]) -> (min: Int, max: Int)? que devuelve una tupla opcional. Se trata de una implementaci\u00f3n que no es funcional, porque utiliza dos variables mutables definidas con var . Realiza una implementaci\u00f3n funcional de la funci\u00f3n, defini\u00e9ndola de forma recursiva . Ejemplo de funcionamiento: 1 2 3 4 5 6 7 let array = [ - 1 , 10 , 200 , - 20 , 300 , 4 ] print ( \"minMax( \\( array ) ): \\( minMax ( array : array ) ! ) \" ) let array2 : [ Int ] = [] print ( \"minMax( \\( array2 ) ): \\( String ( describing : minMax ( array : array2 ))) \" ) \\\\ Imprime : \\\\ minMax ([ - 1 , 10 , 200 , - 20 , 300 , 4 ]): ( min : - 20 , max : 300 ) \\\\ minMax ([]): nil Ejercicio 2 \u00b6 Pista Para resolver el ejercicio necesitar\u00e1s concatenar dos arrays, de forma similar a la funci\u00f3n append de Scheme para las listas. Puedes utilizar para ello el operador + : 1 2 3 4 let array1 = [ 1 , 2 , 3 ] let array2 = [ 4 , 5 , 6 ] let array3 = array1 + array2 // array3 contiene [1,2,3,4,5,6] a) Implementa en Swift la funci\u00f3n recursiva compruebaParejas(_:funcion:) con el siguiente perfil: 1 ( [ Int ] , ( Int ) -> Int ) -> [ (Int, Int) ] La funci\u00f3n recibe dos par\u00e1metros: un Array de enteros y una funci\u00f3n que recibe un entero y devuelve un entero. La funci\u00f3n devolver\u00e1 un array de tuplas que contiene las tuplas formadas por aquellos n\u00fameros contiguos del primer array que cumplan que el n\u00famero es el resultado de aplicar la funci\u00f3n al n\u00famero situado en la posici\u00f3n anterior. Ejemplo: 1 2 3 4 5 func cuadrado ( x : Int ) -> Int { return x * x } print ( compruebaParejas ([ 2 , 4 , 16 , 5 , 10 , 100 , 105 ], funcion : cuadrado )) // Imprime [(2,4), (4,16), (10,100)] b) Implementa en Swift la funci\u00f3n recursiva coinciden(parejas: [(Int,Int)], funcion: (Int)->Int) que devuelve un array de booleanos que indica si el resultado de aplicar la funci\u00f3n al primer n\u00famero de cada pareja coincide con el segundo. 1 2 3 4 5 6 let array = [( 2 , 4 ), ( 4 , 14 ), ( 4 , 16 ), ( 5 , 25 ), ( 10 , 100 )] func cuadrado ( x : Int ) -> Int { return x * x } print ( \"Resultado coinciden: \\( coinciden ( parejas : array , funcion : cuadrado )) \\n \" ) // Imprime: Resultado coinciden: [true, false, true, true, true] Ejercicio 3 \u00b6 Supongamos que estamos escribiendo un programa que debe tratar movimientos de cuentas bancarias. Define un enumerado Movimiento con valores asociados con el que podamos representar: Dep\u00f3sito (valor asociado: (Double) ) Cargo de un recibo (valor asociado: (String, Double) ) Cajero (valor asociado: (Double) ) Y define la funci\u00f3n aplica(movimientos:[Movimiento]) que reciba un array de movimientos y devuelva una pareja con el dinero resultante de acumular todos los movimientos y un array de Strings con todos los cargos realizados. Ejemplo: 1 2 3 let movimientos : [ Movimiento ] = [. deposito ( 830.0 ), . cargoRecibo ( \"Gimnasio\" , 45.0 ), . deposito ( 400.0 ), . cajero ( 100.0 ), . cargoRecibo ( \"Fnac\" , 38.70 )] print ( aplica ( movimientos : movimientos )) //Imprime (1046.3, [\"Gimnasio\", \"Fnac\"]) Ejercicio 4 \u00b6 Implementa en Swift un tipo enumerado recursivo que permita construir \u00e1rboles binarios de enteros. El enumerado debe tener un caso en el que guardar tres valores: un Int y dos \u00e1rboles binarios (el hijo izquierdo y el hijo derecho) otro caso constante: un \u00e1rbol binario vac\u00edo Llamaremos al tipo ArbolBinario y a los casos nodo y vacio . Implem\u00e9ntalo de forma que el siguiente ejemplo funcione correctamente: 1 let arbol : ArbolBinario = . nodo ( 8 , . nodo ( 2 , . vacio , . vacio ), . nodo ( 12 , . vacio , . vacio )) Implementa tambi\u00e9n la funci\u00f3n suma(arbolb:) que reciba una instancia de \u00e1rbol binario y devuelva la suma de todos sus nodos: 1 2 print ( suma ( arbolb : arbol )) // Imprime: 22 Ejercicio 5 \u00b6 Implementa en Swift un tipo enumerado recursivo que permita construir \u00e1rboles gen\u00e9ricos de enteros usando el mismo enfoque que en Scheme: un nodo est\u00e1 formado por un dato (un Int ) y una colecci\u00f3n de \u00e1rboles hijos. Llamaremos al tipo Arbol . Implem\u00e9ntalo de forma que el siguiente ejemplo funcione correctamente: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 /* Definimos el \u00e1rbol 10 / | \\ 3 5 8 | 1 */ let arbol1 = Arbol . nodo ( 1 , []) let arbol3 = Arbol . nodo ( 3 , [ arbol1 ]) let arbol5 = Arbol . nodo ( 5 , []) let arbol8 = Arbol . nodo ( 8 , []) let arbol10 = Arbol . nodo ( 10 , [ arbol3 , arbol5 , arbol8 ]) Implementa tambi\u00e9n la funci\u00f3n suma(arbol:cumplen:) que reciba una instancia de \u00e1rbol gen\u00e9rico y una funci\u00f3n (Int) -> Bool que comprueba una condici\u00f3n sobre el nodo. La funci\u00f3n debe devolver la suma de todos los nodos del \u00e1rbol que cumplan la condici\u00f3n. Implementa la funci\u00f3n usando la misma estrategia que ya utilizamos en Scheme de definir una funci\u00f3n auxiliar suma(bosque:cumplen:) y una recursi\u00f3n mutua. 1 2 3 4 5 6 func esPar ( x : Int ) -> Bool { return x % 2 == 0 } print ( \"La suma del \u00e1rbol gen\u00e9rico es: \\( suma ( arbol : arbol10 , cumplen : esPar )) \" ) // Imprime: La suma del \u00e1rbol gen\u00e9rico es: 18 Lenguajes y Paradigmas de Programaci\u00f3n, curso 2018-19 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Domingo Gallardo, Cristina Pomares, Antonio Bot\u00eda, Francisco Mart\u00ednez","title":"Pr\u00e1ctica 8: Programaci\u00f3n funcional en Swift (1)"},{"location":"practicas/practica08/practica08.html#practica-8-programacion-funcional-en-swift-1","text":"","title":"Pr\u00e1ctica 8: Programaci\u00f3n funcional en Swift (1)"},{"location":"practicas/practica08/practica08.html#entrega-de-la-practica","text":"Para entregar la pr\u00e1ctica debes subir a Moodle el fichero practica08.swift con una cabecera inicial con tu nombre y apellidos, y las soluciones de cada ejercicio separadas por comentarios. Cada soluci\u00f3n debe incluir: La definici\u00f3n de las funciones que resuelven el ejercicio. Una visualizaci\u00f3n por pantalla de todos los ejemplos incluidos en el enunciado que demuestren qu\u00e9 hace la funci\u00f3n . Importante Antes de proceder a realizar los ejercicios de la pr\u00e1ctica te recomendamos que realices y pruebes los ejemplos presentados en el seminario de Swift . Tambi\u00e9n, como siempre, los apuntes de teor\u00eda de la semana pasada.","title":"Entrega de la pr\u00e1ctica"},{"location":"practicas/practica08/practica08.html#ejercicios","text":"","title":"Ejercicios"},{"location":"practicas/practica08/practica08.html#ejercicio-1","text":"En la clase de teor\u00eda hemos presentado un ejemplo de la funci\u00f3n minMax(array: [Int]) -> (min: Int, max: Int)? que devuelve una tupla opcional. Se trata de una implementaci\u00f3n que no es funcional, porque utiliza dos variables mutables definidas con var . Realiza una implementaci\u00f3n funcional de la funci\u00f3n, defini\u00e9ndola de forma recursiva . Ejemplo de funcionamiento: 1 2 3 4 5 6 7 let array = [ - 1 , 10 , 200 , - 20 , 300 , 4 ] print ( \"minMax( \\( array ) ): \\( minMax ( array : array ) ! ) \" ) let array2 : [ Int ] = [] print ( \"minMax( \\( array2 ) ): \\( String ( describing : minMax ( array : array2 ))) \" ) \\\\ Imprime : \\\\ minMax ([ - 1 , 10 , 200 , - 20 , 300 , 4 ]): ( min : - 20 , max : 300 ) \\\\ minMax ([]): nil","title":"Ejercicio 1"},{"location":"practicas/practica08/practica08.html#ejercicio-2","text":"Pista Para resolver el ejercicio necesitar\u00e1s concatenar dos arrays, de forma similar a la funci\u00f3n append de Scheme para las listas. Puedes utilizar para ello el operador + : 1 2 3 4 let array1 = [ 1 , 2 , 3 ] let array2 = [ 4 , 5 , 6 ] let array3 = array1 + array2 // array3 contiene [1,2,3,4,5,6] a) Implementa en Swift la funci\u00f3n recursiva compruebaParejas(_:funcion:) con el siguiente perfil: 1 ( [ Int ] , ( Int ) -> Int ) -> [ (Int, Int) ] La funci\u00f3n recibe dos par\u00e1metros: un Array de enteros y una funci\u00f3n que recibe un entero y devuelve un entero. La funci\u00f3n devolver\u00e1 un array de tuplas que contiene las tuplas formadas por aquellos n\u00fameros contiguos del primer array que cumplan que el n\u00famero es el resultado de aplicar la funci\u00f3n al n\u00famero situado en la posici\u00f3n anterior. Ejemplo: 1 2 3 4 5 func cuadrado ( x : Int ) -> Int { return x * x } print ( compruebaParejas ([ 2 , 4 , 16 , 5 , 10 , 100 , 105 ], funcion : cuadrado )) // Imprime [(2,4), (4,16), (10,100)] b) Implementa en Swift la funci\u00f3n recursiva coinciden(parejas: [(Int,Int)], funcion: (Int)->Int) que devuelve un array de booleanos que indica si el resultado de aplicar la funci\u00f3n al primer n\u00famero de cada pareja coincide con el segundo. 1 2 3 4 5 6 let array = [( 2 , 4 ), ( 4 , 14 ), ( 4 , 16 ), ( 5 , 25 ), ( 10 , 100 )] func cuadrado ( x : Int ) -> Int { return x * x } print ( \"Resultado coinciden: \\( coinciden ( parejas : array , funcion : cuadrado )) \\n \" ) // Imprime: Resultado coinciden: [true, false, true, true, true]","title":"Ejercicio 2"},{"location":"practicas/practica08/practica08.html#ejercicio-3","text":"Supongamos que estamos escribiendo un programa que debe tratar movimientos de cuentas bancarias. Define un enumerado Movimiento con valores asociados con el que podamos representar: Dep\u00f3sito (valor asociado: (Double) ) Cargo de un recibo (valor asociado: (String, Double) ) Cajero (valor asociado: (Double) ) Y define la funci\u00f3n aplica(movimientos:[Movimiento]) que reciba un array de movimientos y devuelva una pareja con el dinero resultante de acumular todos los movimientos y un array de Strings con todos los cargos realizados. Ejemplo: 1 2 3 let movimientos : [ Movimiento ] = [. deposito ( 830.0 ), . cargoRecibo ( \"Gimnasio\" , 45.0 ), . deposito ( 400.0 ), . cajero ( 100.0 ), . cargoRecibo ( \"Fnac\" , 38.70 )] print ( aplica ( movimientos : movimientos )) //Imprime (1046.3, [\"Gimnasio\", \"Fnac\"])","title":"Ejercicio 3"},{"location":"practicas/practica08/practica08.html#ejercicio-4","text":"Implementa en Swift un tipo enumerado recursivo que permita construir \u00e1rboles binarios de enteros. El enumerado debe tener un caso en el que guardar tres valores: un Int y dos \u00e1rboles binarios (el hijo izquierdo y el hijo derecho) otro caso constante: un \u00e1rbol binario vac\u00edo Llamaremos al tipo ArbolBinario y a los casos nodo y vacio . Implem\u00e9ntalo de forma que el siguiente ejemplo funcione correctamente: 1 let arbol : ArbolBinario = . nodo ( 8 , . nodo ( 2 , . vacio , . vacio ), . nodo ( 12 , . vacio , . vacio )) Implementa tambi\u00e9n la funci\u00f3n suma(arbolb:) que reciba una instancia de \u00e1rbol binario y devuelva la suma de todos sus nodos: 1 2 print ( suma ( arbolb : arbol )) // Imprime: 22","title":"Ejercicio 4"},{"location":"practicas/practica08/practica08.html#ejercicio-5","text":"Implementa en Swift un tipo enumerado recursivo que permita construir \u00e1rboles gen\u00e9ricos de enteros usando el mismo enfoque que en Scheme: un nodo est\u00e1 formado por un dato (un Int ) y una colecci\u00f3n de \u00e1rboles hijos. Llamaremos al tipo Arbol . Implem\u00e9ntalo de forma que el siguiente ejemplo funcione correctamente: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 /* Definimos el \u00e1rbol 10 / | \\ 3 5 8 | 1 */ let arbol1 = Arbol . nodo ( 1 , []) let arbol3 = Arbol . nodo ( 3 , [ arbol1 ]) let arbol5 = Arbol . nodo ( 5 , []) let arbol8 = Arbol . nodo ( 8 , []) let arbol10 = Arbol . nodo ( 10 , [ arbol3 , arbol5 , arbol8 ]) Implementa tambi\u00e9n la funci\u00f3n suma(arbol:cumplen:) que reciba una instancia de \u00e1rbol gen\u00e9rico y una funci\u00f3n (Int) -> Bool que comprueba una condici\u00f3n sobre el nodo. La funci\u00f3n debe devolver la suma de todos los nodos del \u00e1rbol que cumplan la condici\u00f3n. Implementa la funci\u00f3n usando la misma estrategia que ya utilizamos en Scheme de definir una funci\u00f3n auxiliar suma(bosque:cumplen:) y una recursi\u00f3n mutua. 1 2 3 4 5 6 func esPar ( x : Int ) -> Bool { return x % 2 == 0 } print ( \"La suma del \u00e1rbol gen\u00e9rico es: \\( suma ( arbol : arbol10 , cumplen : esPar )) \" ) // Imprime: La suma del \u00e1rbol gen\u00e9rico es: 18 Lenguajes y Paradigmas de Programaci\u00f3n, curso 2018-19 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Domingo Gallardo, Cristina Pomares, Antonio Bot\u00eda, Francisco Mart\u00ednez","title":"Ejercicio 5"},{"location":"practicas/practica09/practica09.html","text":"Pr\u00e1ctica 9: Programaci\u00f3n funcional en Swift: clausuras y funciones de orden superior \u00b6 Entrega de la pr\u00e1ctica \u00b6 Para entregar la pr\u00e1ctica debes subir a Moodle el fichero practica09.swift con una cabecera inicial con tu nombre y apellidos, y las soluciones de cada ejercicio separadas por comentarios. Cada soluci\u00f3n debe incluir: La definici\u00f3n de las funciones que resuelven el ejercicio. Una visualizaci\u00f3n por pantalla de todos los ejemplos incluidos en el enunciado que demuestren qu\u00e9 hace la funci\u00f3n . Ejercicios \u00b6 Importante Antes de empezar la pr\u00e1ctica debes estudiar los apartados de teor\u00eda del tema de Programaci\u00f3n Funcional en Swift: Opcionales Clausuras Funciones de orden superior Gen\u00e9ricos Ejercicio 1 \u00b6 a) Indica qu\u00e9 devuelven las siguientes expresiones: a.1) 1 2 let nums = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] nums . filter { $0 % 3 == 0 }. count a.2) 1 2 let nums2 = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] nums2 . map { $0 + 100 }. filter { $0 % 5 == 0 }. reduce ( 0 , + ) a.3) 1 2 let cadenas = [ \"En\" , \"un\" , \"lugar\" , \"de\" , \"La\" , \"Mancha\" ] cadenas . sorted { $0 . count < $1 . count }. map { $0 . count } a.4) 1 2 3 let cadenas2 = [ \"En\" , \"un\" , \"lugar\" , \"de\" , \"La\" , \"Mancha\" ] cadenas2 . reduce ([]) {( res : [( String , Int )], c : String ) -> [( String , Int )] in res + [( c , c . count )]}. sorted ( by : { $0 . 1 < $1 . 1 }) b) Explica qu\u00e9 hacen las siguientes funciones y pon un ejemplo de su funcionamiento: b.1) 1 2 3 func f ( nums : [ Int ], n : Int ) -> Int { return nums . filter { $0 == n }. count } b.2) 1 2 3 4 5 6 7 8 9 func g ( nums : [ Int ]) -> [ Int ] { return nums . reduce ([], {( res : [ Int ], n : Int ) -> [ Int ] in if ! res . contains ( n ) { return res + [ n ] } else { return res } }) } b.3) 1 2 3 4 5 6 7 8 9 func h ( nums : [ Int ], n : Int ) -> ([ Int ], [ Int ]) { return nums . reduce (([],[]), {( res : ([ Int ],[ Int ]), num : Int ) -> ([ Int ],[ Int ]) in if ( num >= n ) { return ( res . 0 , res . 1 + [ num ]) } else { return (( res . 0 + [ num ], res . 1 )) } }) } c) Implementa las siguientes funciones con funciones de orden superior. c.1) Funci\u00f3n suma(palabras:contienen:) : 1 suma ( palabras : [ String ], contienen : Character ) -> Int que recibe una array de cadenas y devuelve la suma de las longitudes de las cadenas que contiene el car\u00e1cter que se pasa como par\u00e1metro. c.2) Funci\u00f3n sumaMenoresMayores(nums:pivote:) : 1 sumaMenoresMayores ( nums : [ Int ], pivote : Int ) -> ( Int , Int ) que recibe un array de n\u00fameros y un n\u00famero pivote y devuelve una tupla con la suma de los n\u00fameros menores y mayores o iguales que el pivote. Ejercicio 2 \u00b6 Define un tipo enumerado con un \u00e1rbol gen\u00e9rico, tal y como hicimos en el \u00faltimo ejercicio de la pr\u00e1ctica anterior, que tenga como gen\u00e9rico el tipo de dato que contiene. En el siguiente ejemplo vemos c\u00f3mo deber\u00eda poderse definir con el mismo tipo gen\u00e9rico un \u00e1rbol de enteros y un \u00e1rbol de cadenas: 1 2 3 let arbolInt : Arbol = . nodo ( 53 , [. nodo ( 13 , []), . nodo ( 32 , []), . nodo ( 41 , [. nodo ( 36 , []), . nodo ( 39 , [])])]) let arbolString : Arbol = . nodo ( \"Zamora\" , [. nodo ( \"Buend\u00eda\" , [. nodo ( \"Albeza\" , []), . nodo ( \"Berenguer\" , []), . nodo ( \"Bolardo\" , [])]), . nodo ( \"Galv\u00e1n\" , [])]) Define las funciones gen\u00e9ricas toArray y toArrayFOS que devuelvan un array con todos los componentes del \u00e1rbol usando un recorrido preorden (primero la ra\u00edz y despu\u00e9s los hijos). La primera la debes implementar con recursi\u00f3n mutua y la segunda usando funciones de orden superior. Ejemplo: 1 2 3 4 print ( toArray ( arbol : arbolInt )) // Imprime: [53, 13, 32, 41, 36, 39] print ( toArrayFOS ( arbol : arbolString )) // Imprime: [\"Zamora\", \"Buend\u00eda\", \"Albeza\", \"Berenguer\", \"Bolardo\", \"Galv\u00e1n\"] Ejercicio 3 \u00b6 Implementa en Swift la funci\u00f3n imprimirListadosNotas(alumnos:) que recibe un array de tuplas, en donde cada tupla contiene informaci\u00f3n de la evaluaci\u00f3n de un alumno de LPP (nombreAlumno, notaParcial1, notaParcial2, notaCuestionarios, a\u00f1osMatriculacion) y que debe imprimir por pantalla los siguientes listados: listado 1: array ordenado por nombre del alumno (orden alfab\u00e9tico creciente) listado 2: array ordenado por la nota del parcial 1 (orden decreciente de nota) listado 3: array ordenado por la nota del parcial 2 (orden creciente de nota) listado 4: array ordenado por a\u00f1o de matriculaci\u00f3n y nota del cuestionario (orden decreciente de a\u00f1o y nota) listado 5: array ordenado por nota que necesita obtener en el parcial 3 para aprobar la asignatura en la convocatoria de Junio (orden decreciente de nota necesaria) Las ordenaciones hay que realizarlas usando la funci\u00f3n sorted . Nota Para que los listados se muestren formateados con espacios, puedes usar la siguiente funci\u00f3n (para ello tambi\u00e9n debes incluir el import que se indica) 1 2 3 4 5 6 7 8 9 10 import Foundation func imprimirListadoAlumnos ( _ alumnos : [( String , Double , Double , Double , Int )]) { print ( \"Alumno Parcial1 Parcial2 Cuest A\u00f1os\" ) for alu in alumnos { alu . 0. withCString { print ( String ( format : \"%-10s %5.2f %5.2f %5.2f %3d\" , $0 , alu . 1 , alu . 2 , alu . 3 , alu . 4 )) } } } Ejemplo: 1 2 3 4 5 6 7 8 9 let listaAlumnos = [( \"Pepe\" , 8.45 , 3.75 , 6.05 , 1 ), ( \"Maria\" , 9.1 , 7.5 , 8.18 , 1 ), ( \"Jose\" , 8.0 , 6.65 , 7.96 , 1 ), ( \"Carmen\" , 6.25 , 1.2 , 5.41 , 2 ), ( \"Felipe\" , 5.65 , 0.25 , 3.16 , 3 ), ( \"Carla\" , 6.25 , 1.25 , 4.23 , 2 ), ( \"Luis\" , 6.75 , 0.25 , 4.63 , 2 ), ( \"Loli\" , 3.0 , 1.25 , 2.19 , 3 )] imprimirListadosNotas ( listaAlumnos ) Algunos de los listados que se deben mostrar ser\u00edan los siguientes: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 LISTADO ORIGINAL Alumno Parcial1 Parcial2 Cuest A\u00f1os Pepe 8 . 45 3 . 75 6 . 05 1 Maria 9 . 10 7 . 50 8 . 18 1 Jose 8 . 00 6 . 65 7 . 96 1 Carmen 6 . 25 1 . 20 5 . 41 2 Felipe 5 . 65 0 . 25 3 . 16 3 Carla 6 . 25 1 . 25 4 . 23 2 Luis 6 . 75 0 . 25 4 . 63 2 Loli 3 . 00 1 . 25 2 . 19 3 LISTADO ORDENADO por Parcial1 Alumno Parcial1 Parcial2 Cuest A\u00f1os Maria 9 . 10 7 . 50 8 . 18 1 Pepe 8 . 45 3 . 75 6 . 05 1 Jose 8 . 00 6 . 65 7 . 96 1 Luis 6 . 75 0 . 25 4 . 63 2 Carmen 6 . 25 1 . 20 5 . 41 2 Carla 6 . 25 1 . 25 4 . 23 2 Felipe 5 . 65 0 . 25 3 . 16 3 Loli 3 . 00 1 . 25 2 . 19 3 LISTADO ORDENADO por Nota para aprobar en Junio Alumno Parcial1 Parcial2 Cuest A\u00f1os Maria 9 . 10 7 . 50 8 . 18 1 Jose 8 . 00 6 . 65 7 . 96 1 Pepe 8 . 45 3 . 75 6 . 05 1 Carmen 6 . 25 1 . 20 5 . 41 2 Carla 6 . 25 1 . 25 4 . 23 2 Luis 6 . 75 0 . 25 4 . 63 2 Felipe 5 . 65 0 . 25 3 . 16 3 Loli 3 . 00 1 . 25 2 . 19 3 Ejercicio 4 \u00b6 Dado el array listaAlumnos del ejercicio anterior, utiliza funciones de orden superior para obtener los datos requeridos en cada caso A) N\u00famero de alumnos que han aprobado primer parcial y suspendido el segundo 1 2 print ( listaAlumnos . ________________________________ ) // Resultado: 5 B) Nota que deben tener en el parcial 3 para sacar un 5 en la nota final 1 2 3 4 print ( listaAlumnos . _______________________________ ) // Resultado: // [1.8370370370370388, -4.1407407407407391, -2.0277777777777768, 7.0611111111111127, 10.277777777777777, 7.8851851851851862, 8.0888888888888903, 12.646296296296295] C) Nota media de todos los alumnos en forma de tupla (media_p1, media_p2, media_cuest) 1 2 3 4 var tupla = listaAlumnos . _____________________________________ ) tupla = ( tupla . 0 / Double ( listaAlumnos . count ), tupla . 1 / Double ( listaAlumnos . count ), tupla . 2 / Double ( listaAlumnos . count )) print ( tupla ) // Resultado: (6.6812499999999995, 2.7624999999999997, 5.2262500000000003) Ejercicio 5 \u00b6 Implementa la funci\u00f3n construye con el siguiente perfil: 1 func construye ( operador : Character ) -> ( Int , Int ) -> Int La funci\u00f3n recibe un operador que puede ser uno de los siguientes caracteres: + , - , * , / y debe devolver una clausura que reciba dos argumentos y realice la operaci\u00f3n indicada sobre ellos. Ejemplo: 1 2 3 4 5 6 var f = construye ( operador : \"+\" ) print ( f ( 2 , 3 )) // Imprime 5 f = construye ( operador : \"-\" ) print ( f ( 2 , 3 )) // Imprime -1 Lenguajes y Paradigmas de Programaci\u00f3n, curso 2018-19 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Domingo Gallardo, Cristina Pomares, Antonio Bot\u00eda, Francisco Mart\u00ednez","title":"Pr\u00e1ctica 9: Programaci\u00f3n funcional en Swift: clausuras y funciones de orden superior"},{"location":"practicas/practica09/practica09.html#practica-9-programacion-funcional-en-swift-clausuras-y-funciones-de-orden-superior","text":"","title":"Pr\u00e1ctica 9: Programaci\u00f3n funcional en Swift: clausuras y funciones de orden superior"},{"location":"practicas/practica09/practica09.html#entrega-de-la-practica","text":"Para entregar la pr\u00e1ctica debes subir a Moodle el fichero practica09.swift con una cabecera inicial con tu nombre y apellidos, y las soluciones de cada ejercicio separadas por comentarios. Cada soluci\u00f3n debe incluir: La definici\u00f3n de las funciones que resuelven el ejercicio. Una visualizaci\u00f3n por pantalla de todos los ejemplos incluidos en el enunciado que demuestren qu\u00e9 hace la funci\u00f3n .","title":"Entrega de la pr\u00e1ctica"},{"location":"practicas/practica09/practica09.html#ejercicios","text":"Importante Antes de empezar la pr\u00e1ctica debes estudiar los apartados de teor\u00eda del tema de Programaci\u00f3n Funcional en Swift: Opcionales Clausuras Funciones de orden superior Gen\u00e9ricos","title":"Ejercicios"},{"location":"practicas/practica09/practica09.html#ejercicio-1","text":"a) Indica qu\u00e9 devuelven las siguientes expresiones: a.1) 1 2 let nums = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] nums . filter { $0 % 3 == 0 }. count a.2) 1 2 let nums2 = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] nums2 . map { $0 + 100 }. filter { $0 % 5 == 0 }. reduce ( 0 , + ) a.3) 1 2 let cadenas = [ \"En\" , \"un\" , \"lugar\" , \"de\" , \"La\" , \"Mancha\" ] cadenas . sorted { $0 . count < $1 . count }. map { $0 . count } a.4) 1 2 3 let cadenas2 = [ \"En\" , \"un\" , \"lugar\" , \"de\" , \"La\" , \"Mancha\" ] cadenas2 . reduce ([]) {( res : [( String , Int )], c : String ) -> [( String , Int )] in res + [( c , c . count )]}. sorted ( by : { $0 . 1 < $1 . 1 }) b) Explica qu\u00e9 hacen las siguientes funciones y pon un ejemplo de su funcionamiento: b.1) 1 2 3 func f ( nums : [ Int ], n : Int ) -> Int { return nums . filter { $0 == n }. count } b.2) 1 2 3 4 5 6 7 8 9 func g ( nums : [ Int ]) -> [ Int ] { return nums . reduce ([], {( res : [ Int ], n : Int ) -> [ Int ] in if ! res . contains ( n ) { return res + [ n ] } else { return res } }) } b.3) 1 2 3 4 5 6 7 8 9 func h ( nums : [ Int ], n : Int ) -> ([ Int ], [ Int ]) { return nums . reduce (([],[]), {( res : ([ Int ],[ Int ]), num : Int ) -> ([ Int ],[ Int ]) in if ( num >= n ) { return ( res . 0 , res . 1 + [ num ]) } else { return (( res . 0 + [ num ], res . 1 )) } }) } c) Implementa las siguientes funciones con funciones de orden superior. c.1) Funci\u00f3n suma(palabras:contienen:) : 1 suma ( palabras : [ String ], contienen : Character ) -> Int que recibe una array de cadenas y devuelve la suma de las longitudes de las cadenas que contiene el car\u00e1cter que se pasa como par\u00e1metro. c.2) Funci\u00f3n sumaMenoresMayores(nums:pivote:) : 1 sumaMenoresMayores ( nums : [ Int ], pivote : Int ) -> ( Int , Int ) que recibe un array de n\u00fameros y un n\u00famero pivote y devuelve una tupla con la suma de los n\u00fameros menores y mayores o iguales que el pivote.","title":"Ejercicio 1"},{"location":"practicas/practica09/practica09.html#ejercicio-2","text":"Define un tipo enumerado con un \u00e1rbol gen\u00e9rico, tal y como hicimos en el \u00faltimo ejercicio de la pr\u00e1ctica anterior, que tenga como gen\u00e9rico el tipo de dato que contiene. En el siguiente ejemplo vemos c\u00f3mo deber\u00eda poderse definir con el mismo tipo gen\u00e9rico un \u00e1rbol de enteros y un \u00e1rbol de cadenas: 1 2 3 let arbolInt : Arbol = . nodo ( 53 , [. nodo ( 13 , []), . nodo ( 32 , []), . nodo ( 41 , [. nodo ( 36 , []), . nodo ( 39 , [])])]) let arbolString : Arbol = . nodo ( \"Zamora\" , [. nodo ( \"Buend\u00eda\" , [. nodo ( \"Albeza\" , []), . nodo ( \"Berenguer\" , []), . nodo ( \"Bolardo\" , [])]), . nodo ( \"Galv\u00e1n\" , [])]) Define las funciones gen\u00e9ricas toArray y toArrayFOS que devuelvan un array con todos los componentes del \u00e1rbol usando un recorrido preorden (primero la ra\u00edz y despu\u00e9s los hijos). La primera la debes implementar con recursi\u00f3n mutua y la segunda usando funciones de orden superior. Ejemplo: 1 2 3 4 print ( toArray ( arbol : arbolInt )) // Imprime: [53, 13, 32, 41, 36, 39] print ( toArrayFOS ( arbol : arbolString )) // Imprime: [\"Zamora\", \"Buend\u00eda\", \"Albeza\", \"Berenguer\", \"Bolardo\", \"Galv\u00e1n\"]","title":"Ejercicio 2"},{"location":"practicas/practica09/practica09.html#ejercicio-3","text":"Implementa en Swift la funci\u00f3n imprimirListadosNotas(alumnos:) que recibe un array de tuplas, en donde cada tupla contiene informaci\u00f3n de la evaluaci\u00f3n de un alumno de LPP (nombreAlumno, notaParcial1, notaParcial2, notaCuestionarios, a\u00f1osMatriculacion) y que debe imprimir por pantalla los siguientes listados: listado 1: array ordenado por nombre del alumno (orden alfab\u00e9tico creciente) listado 2: array ordenado por la nota del parcial 1 (orden decreciente de nota) listado 3: array ordenado por la nota del parcial 2 (orden creciente de nota) listado 4: array ordenado por a\u00f1o de matriculaci\u00f3n y nota del cuestionario (orden decreciente de a\u00f1o y nota) listado 5: array ordenado por nota que necesita obtener en el parcial 3 para aprobar la asignatura en la convocatoria de Junio (orden decreciente de nota necesaria) Las ordenaciones hay que realizarlas usando la funci\u00f3n sorted . Nota Para que los listados se muestren formateados con espacios, puedes usar la siguiente funci\u00f3n (para ello tambi\u00e9n debes incluir el import que se indica) 1 2 3 4 5 6 7 8 9 10 import Foundation func imprimirListadoAlumnos ( _ alumnos : [( String , Double , Double , Double , Int )]) { print ( \"Alumno Parcial1 Parcial2 Cuest A\u00f1os\" ) for alu in alumnos { alu . 0. withCString { print ( String ( format : \"%-10s %5.2f %5.2f %5.2f %3d\" , $0 , alu . 1 , alu . 2 , alu . 3 , alu . 4 )) } } } Ejemplo: 1 2 3 4 5 6 7 8 9 let listaAlumnos = [( \"Pepe\" , 8.45 , 3.75 , 6.05 , 1 ), ( \"Maria\" , 9.1 , 7.5 , 8.18 , 1 ), ( \"Jose\" , 8.0 , 6.65 , 7.96 , 1 ), ( \"Carmen\" , 6.25 , 1.2 , 5.41 , 2 ), ( \"Felipe\" , 5.65 , 0.25 , 3.16 , 3 ), ( \"Carla\" , 6.25 , 1.25 , 4.23 , 2 ), ( \"Luis\" , 6.75 , 0.25 , 4.63 , 2 ), ( \"Loli\" , 3.0 , 1.25 , 2.19 , 3 )] imprimirListadosNotas ( listaAlumnos ) Algunos de los listados que se deben mostrar ser\u00edan los siguientes: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 LISTADO ORIGINAL Alumno Parcial1 Parcial2 Cuest A\u00f1os Pepe 8 . 45 3 . 75 6 . 05 1 Maria 9 . 10 7 . 50 8 . 18 1 Jose 8 . 00 6 . 65 7 . 96 1 Carmen 6 . 25 1 . 20 5 . 41 2 Felipe 5 . 65 0 . 25 3 . 16 3 Carla 6 . 25 1 . 25 4 . 23 2 Luis 6 . 75 0 . 25 4 . 63 2 Loli 3 . 00 1 . 25 2 . 19 3 LISTADO ORDENADO por Parcial1 Alumno Parcial1 Parcial2 Cuest A\u00f1os Maria 9 . 10 7 . 50 8 . 18 1 Pepe 8 . 45 3 . 75 6 . 05 1 Jose 8 . 00 6 . 65 7 . 96 1 Luis 6 . 75 0 . 25 4 . 63 2 Carmen 6 . 25 1 . 20 5 . 41 2 Carla 6 . 25 1 . 25 4 . 23 2 Felipe 5 . 65 0 . 25 3 . 16 3 Loli 3 . 00 1 . 25 2 . 19 3 LISTADO ORDENADO por Nota para aprobar en Junio Alumno Parcial1 Parcial2 Cuest A\u00f1os Maria 9 . 10 7 . 50 8 . 18 1 Jose 8 . 00 6 . 65 7 . 96 1 Pepe 8 . 45 3 . 75 6 . 05 1 Carmen 6 . 25 1 . 20 5 . 41 2 Carla 6 . 25 1 . 25 4 . 23 2 Luis 6 . 75 0 . 25 4 . 63 2 Felipe 5 . 65 0 . 25 3 . 16 3 Loli 3 . 00 1 . 25 2 . 19 3","title":"Ejercicio 3"},{"location":"practicas/practica09/practica09.html#ejercicio-4","text":"Dado el array listaAlumnos del ejercicio anterior, utiliza funciones de orden superior para obtener los datos requeridos en cada caso A) N\u00famero de alumnos que han aprobado primer parcial y suspendido el segundo 1 2 print ( listaAlumnos . ________________________________ ) // Resultado: 5 B) Nota que deben tener en el parcial 3 para sacar un 5 en la nota final 1 2 3 4 print ( listaAlumnos . _______________________________ ) // Resultado: // [1.8370370370370388, -4.1407407407407391, -2.0277777777777768, 7.0611111111111127, 10.277777777777777, 7.8851851851851862, 8.0888888888888903, 12.646296296296295] C) Nota media de todos los alumnos en forma de tupla (media_p1, media_p2, media_cuest) 1 2 3 4 var tupla = listaAlumnos . _____________________________________ ) tupla = ( tupla . 0 / Double ( listaAlumnos . count ), tupla . 1 / Double ( listaAlumnos . count ), tupla . 2 / Double ( listaAlumnos . count )) print ( tupla ) // Resultado: (6.6812499999999995, 2.7624999999999997, 5.2262500000000003)","title":"Ejercicio 4"},{"location":"practicas/practica09/practica09.html#ejercicio-5","text":"Implementa la funci\u00f3n construye con el siguiente perfil: 1 func construye ( operador : Character ) -> ( Int , Int ) -> Int La funci\u00f3n recibe un operador que puede ser uno de los siguientes caracteres: + , - , * , / y debe devolver una clausura que reciba dos argumentos y realice la operaci\u00f3n indicada sobre ellos. Ejemplo: 1 2 3 4 5 6 var f = construye ( operador : \"+\" ) print ( f ( 2 , 3 )) // Imprime 5 f = construye ( operador : \"-\" ) print ( f ( 2 , 3 )) // Imprime -1 Lenguajes y Paradigmas de Programaci\u00f3n, curso 2018-19 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Domingo Gallardo, Cristina Pomares, Antonio Bot\u00eda, Francisco Mart\u00ednez","title":"Ejercicio 5"},{"location":"practicas/practica10/practica10.html","text":"Pr\u00e1ctica 10: Programaci\u00f3n Orientada a Objetos en Swift 1 \u00b6 Entrega de la pr\u00e1ctica \u00b6 Para entregar la pr\u00e1ctica debes subir a Moodle el fichero practica10.swift con una cabecera inicial con tu nombre y apellidos, y las soluciones de cada ejercicio separadas por comentarios. Ejercicio 1 \u00b6 a) \u00bfQu\u00e9 se imprime al ejecutar el siguiente programa? Reflexiona sobre el funcionamiento del c\u00f3digo, compru\u00e9balo con el compilador y experimenta haciendo cambios y comprobando el resultado. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 var x = 0 func construye () -> () -> Int { var x = 10 return { x = x + 5 return x } } func usa ( funcion : () -> Int ) { var x = 20 print ( funcion ()) } let g = construye () usa ( funcion : g ) usa ( funcion : g ) b) El siguiente c\u00f3digo tiene errores, pero los comentarios indican correctamente su intenci\u00f3n. Indica cu\u00e1les son los errores, c\u00f3mo solucionarlos y qu\u00e9 se imprimir\u00e1 al ejecutarlo. Despu\u00e9s compru\u00e9balo con el compilador y experimenta haciendo cambios y comprobando el resultado. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 var y = 0 var almacen : [() -> Int ] = [] func usa2 ( funcion : () -> Int ) { var y = 20 almacen . append ( funcion ) } usa2 { y = y + 5 return y } // Obtenemos la clausura guardada en almacen let h = almacen [ 0 ]() // Invocamos a la clausura print ( h ) print ( h ) c) El siguiente c\u00f3digo usa observadores de propiedades y una variable del tipo (est\u00e1tica). \u00bfQu\u00e9 se imprime al final de su ejecuci\u00f3n? Reflexiona sobre el funcionamiento del c\u00f3digo, compru\u00e9balo con el compilador y experimenta haciendo cambios y comprobando el resultado. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 struct Valor { var valor : Int = 0 { willSet { Valor . z += newValue } didSet { if valor > 10 { valor = 10 } } } static var z = 0 } var c1 = Valor () var c2 = Valor () c1 . valor = 20 c2 . valor = 8 print ( c1 . valor + c2 . valor + Valor . z ) Ejercicio 2 \u00b6 Supongamos la siguiente clase MisPalabras : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class MisPalabras { var guardadas : [ String ] = [] func guarda ( palabra : String ) { guardadas = guardadas + [ palabra ] } } let palabras = MisPalabras () palabras . guarda ( palabra : \"Hola\" ) palabras . guarda ( palabra : \"me\" ) palabras . guarda ( palabra : \"llamo\" ) palabras . guarda ( palabra : \"Yolanda\" ) print ( palabras . guardadas ) // [\"Hola\", \"me\", \"llamo\", \"Yolanda\"] Debes a\u00f1adir una propiedad calculada logitud que devuelva la suma de las longitudes de todas las palabras guardadas (usa una funci\u00f3n de orden superior para calcular esta suma). Haz tambi\u00e9n que sea una propiedad modificable de la siguiente forma: Si se intenta asignar un valor mayor o igual que la longitud de las cadenas guardadas, o un n\u00famero negativo, no se hace nada. Si se asigna un valor menor que la longitud de las cadenas se deben dejar guardadas s\u00f3lo las palabras que suman esa longitud, recortando la \u00faltima de ellas si es necesario. Ejemplo: 1 2 3 4 5 print ( palabras . longitud ) // 18 palabras . longitud = 10 print ( palabras . guardadas ) // [\"Hola\", \"me\", \"llam\"] Ayuda Puedes utilizar la siguiente funci\u00f3n recorta para recortar una palabra: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 func recorta ( _ palabra : String , hasta : Int ) -> String { if hasta >= palabra . count { return palabra } else { let start = palabra . startIndex let end = palabra . index ( start , offsetBy : hasta ) return String ( palabra [ start ..< end ]) } } print ( recorta ( \"Hola\" , hasta : 2 )) // Ho print ( recorta ( \"Hola\" , hasta : 3 )) // Hol print ( recorta ( \"Hola\" , hasta : 4 )) // Hola print ( recorta ( \"Hola\" , hasta : 5 )) // Hola Ejercicio 3 \u00b6 En este ejercicio vamos a trabajar con estructuras y clases geom\u00e9tricas: Punto , Tama\u00f1o , Rectangulo y Circulo . Vamos a definir propiedades almacenadas y propiedades calculadas para todas las figuras geom\u00e9tricas. Para usar la funci\u00f3n sqrt debes importar la librer\u00eda Foundation : 1 import Foundation El valor de la constante matem\u00e1tica pi lo puedes obtener con la propiedad Double.pi . Estructuras Punto y Tama\u00f1o Las debes declarar tal y como aparecen en los apuntes. Estructura Rectangulo Propiedades de instancia almacenadas: origen ( Punto ) que contiene las coordenadas de la esquina inferior izquierda del rect\u00e1ngulo. tama\u00f1o ( Tama\u00f1o ) que contiene las dimensiones del rect\u00e1ngulo. Propiedades de instancia calculadas: centro ( Punto , de lectura y escritura) que devuelve el centro del rect\u00e1ngulo. El setter modifica la posici\u00f3n del rect\u00e1ngulo manteniendo fijo su tama\u00f1o. area ( Double , s\u00f3lo lectura ) que devuelve el \u00e1rea del rect\u00e1ngulo. Estructura Circulo Propiedades de instancia almacenadas: centro ( Punto ) que contiene las coordenadas del centro del c\u00edrculo. radio ( Double ) que contiene la longitud del radio. Propiedades de instancia calculadas: area ( Double , de lectura y escritura) que devuelve el \u00e1rea del c\u00edrculo. El setter modifica el tama\u00f1o del c\u00edrculo (su radio), manteni\u00e9ndolo en la misma posici\u00f3n. Estructura AlmacenFiguras Propiedades almacenadas: rectangulos y circulos que contienen respectivamente arrays de rect\u00e1ngulos y c\u00edrculos inicializados a arrays vac\u00edos. Propiedades calculadas: numFiguras ( Int ) que devuelve el n\u00famero total de figuras creadas. areaTotal ( Double ) que devuelve la suma total de las \u00e1reas de todas las figuras creadas. M\u00e9todos: a\u00f1ade(rectangulo:) y a\u00f1ade(circulo:) que a\u00f1aden un rect\u00e1ngulo y un c\u00edrculo al array correspondiente. Nota La definici\u00f3n anterior del almac\u00e9n de figuras no es demasiado correcta, porque se utiliza una variable distinta para cada tipo de figura, sin generalizar. En la pr\u00e1ctica de la semana que viene veremos c\u00f3mo mejorarlo utilizando protocolos. Implementa las estructuras anteriores y escribe alg\u00fan ejemplo de c\u00f3digo en el que se creen al menos un rect\u00e1ngulo y un c\u00edrculo, se prueben sus propiedades, se a\u00f1adan al almac\u00e9n de figuras y se prueben sus m\u00e9todos. Ejercicio 4 \u00b6 Tenemos que escribir un programa que permita definir resultados de partidos de f\u00fatbol y calcular la puntuaci\u00f3n de un conjunto de equipos una vez que se han jugado esos partidos. Escribe c\u00f3digo en Swift que permita resolver el problema, utilizando structs . Un ejemplo de ejecuci\u00f3n del c\u00f3digo deber\u00eda ser c\u00f3mo sigue: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 -------------- Puntuaci\u00f3n antes de los partidos: Real Madrid: 0 puntos Barcelona: 0 puntos Atl\u00e9tico Madrid: 0 puntos Valencia: 0 puntos Athl\u00e9tic Bilbao: 0 puntos Sevilla: 0 puntos -------------- Resultados: Real Madrid 0 - Barcelona 3 Sevilla 1 - Athl\u00e9tic Bilbao 1 Valencia 2 - Atl\u00e9tico Madrid 1 -------------- Puntuaci\u00f3n despu\u00e9s de los partidos: Real Madrid: 0 puntos Barcelona: 3 puntos Atl\u00e9tico Madrid: 0 puntos Valencia: 3 puntos Athl\u00e9tic Bilbao: 1 puntos Sevilla: 1 puntos Lenguajes y Paradigmas de Programaci\u00f3n, curso 2018-19 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Domingo Gallardo, Cristina Pomares, Antonio Bot\u00eda, Francisco Mart\u00ednez","title":"Pr\u00e1ctica 10: Programaci\u00f3n Orientada a Objetos en Swift 1"},{"location":"practicas/practica10/practica10.html#practica-10-programacion-orientada-a-objetos-en-swift-1","text":"","title":"Pr\u00e1ctica 10: Programaci\u00f3n Orientada a Objetos en Swift 1"},{"location":"practicas/practica10/practica10.html#entrega-de-la-practica","text":"Para entregar la pr\u00e1ctica debes subir a Moodle el fichero practica10.swift con una cabecera inicial con tu nombre y apellidos, y las soluciones de cada ejercicio separadas por comentarios.","title":"Entrega de la pr\u00e1ctica"},{"location":"practicas/practica10/practica10.html#ejercicio-1","text":"a) \u00bfQu\u00e9 se imprime al ejecutar el siguiente programa? Reflexiona sobre el funcionamiento del c\u00f3digo, compru\u00e9balo con el compilador y experimenta haciendo cambios y comprobando el resultado. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 var x = 0 func construye () -> () -> Int { var x = 10 return { x = x + 5 return x } } func usa ( funcion : () -> Int ) { var x = 20 print ( funcion ()) } let g = construye () usa ( funcion : g ) usa ( funcion : g ) b) El siguiente c\u00f3digo tiene errores, pero los comentarios indican correctamente su intenci\u00f3n. Indica cu\u00e1les son los errores, c\u00f3mo solucionarlos y qu\u00e9 se imprimir\u00e1 al ejecutarlo. Despu\u00e9s compru\u00e9balo con el compilador y experimenta haciendo cambios y comprobando el resultado. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 var y = 0 var almacen : [() -> Int ] = [] func usa2 ( funcion : () -> Int ) { var y = 20 almacen . append ( funcion ) } usa2 { y = y + 5 return y } // Obtenemos la clausura guardada en almacen let h = almacen [ 0 ]() // Invocamos a la clausura print ( h ) print ( h ) c) El siguiente c\u00f3digo usa observadores de propiedades y una variable del tipo (est\u00e1tica). \u00bfQu\u00e9 se imprime al final de su ejecuci\u00f3n? Reflexiona sobre el funcionamiento del c\u00f3digo, compru\u00e9balo con el compilador y experimenta haciendo cambios y comprobando el resultado. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 struct Valor { var valor : Int = 0 { willSet { Valor . z += newValue } didSet { if valor > 10 { valor = 10 } } } static var z = 0 } var c1 = Valor () var c2 = Valor () c1 . valor = 20 c2 . valor = 8 print ( c1 . valor + c2 . valor + Valor . z )","title":"Ejercicio 1"},{"location":"practicas/practica10/practica10.html#ejercicio-2","text":"Supongamos la siguiente clase MisPalabras : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class MisPalabras { var guardadas : [ String ] = [] func guarda ( palabra : String ) { guardadas = guardadas + [ palabra ] } } let palabras = MisPalabras () palabras . guarda ( palabra : \"Hola\" ) palabras . guarda ( palabra : \"me\" ) palabras . guarda ( palabra : \"llamo\" ) palabras . guarda ( palabra : \"Yolanda\" ) print ( palabras . guardadas ) // [\"Hola\", \"me\", \"llamo\", \"Yolanda\"] Debes a\u00f1adir una propiedad calculada logitud que devuelva la suma de las longitudes de todas las palabras guardadas (usa una funci\u00f3n de orden superior para calcular esta suma). Haz tambi\u00e9n que sea una propiedad modificable de la siguiente forma: Si se intenta asignar un valor mayor o igual que la longitud de las cadenas guardadas, o un n\u00famero negativo, no se hace nada. Si se asigna un valor menor que la longitud de las cadenas se deben dejar guardadas s\u00f3lo las palabras que suman esa longitud, recortando la \u00faltima de ellas si es necesario. Ejemplo: 1 2 3 4 5 print ( palabras . longitud ) // 18 palabras . longitud = 10 print ( palabras . guardadas ) // [\"Hola\", \"me\", \"llam\"] Ayuda Puedes utilizar la siguiente funci\u00f3n recorta para recortar una palabra: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 func recorta ( _ palabra : String , hasta : Int ) -> String { if hasta >= palabra . count { return palabra } else { let start = palabra . startIndex let end = palabra . index ( start , offsetBy : hasta ) return String ( palabra [ start ..< end ]) } } print ( recorta ( \"Hola\" , hasta : 2 )) // Ho print ( recorta ( \"Hola\" , hasta : 3 )) // Hol print ( recorta ( \"Hola\" , hasta : 4 )) // Hola print ( recorta ( \"Hola\" , hasta : 5 )) // Hola","title":"Ejercicio 2"},{"location":"practicas/practica10/practica10.html#ejercicio-3","text":"En este ejercicio vamos a trabajar con estructuras y clases geom\u00e9tricas: Punto , Tama\u00f1o , Rectangulo y Circulo . Vamos a definir propiedades almacenadas y propiedades calculadas para todas las figuras geom\u00e9tricas. Para usar la funci\u00f3n sqrt debes importar la librer\u00eda Foundation : 1 import Foundation El valor de la constante matem\u00e1tica pi lo puedes obtener con la propiedad Double.pi . Estructuras Punto y Tama\u00f1o Las debes declarar tal y como aparecen en los apuntes. Estructura Rectangulo Propiedades de instancia almacenadas: origen ( Punto ) que contiene las coordenadas de la esquina inferior izquierda del rect\u00e1ngulo. tama\u00f1o ( Tama\u00f1o ) que contiene las dimensiones del rect\u00e1ngulo. Propiedades de instancia calculadas: centro ( Punto , de lectura y escritura) que devuelve el centro del rect\u00e1ngulo. El setter modifica la posici\u00f3n del rect\u00e1ngulo manteniendo fijo su tama\u00f1o. area ( Double , s\u00f3lo lectura ) que devuelve el \u00e1rea del rect\u00e1ngulo. Estructura Circulo Propiedades de instancia almacenadas: centro ( Punto ) que contiene las coordenadas del centro del c\u00edrculo. radio ( Double ) que contiene la longitud del radio. Propiedades de instancia calculadas: area ( Double , de lectura y escritura) que devuelve el \u00e1rea del c\u00edrculo. El setter modifica el tama\u00f1o del c\u00edrculo (su radio), manteni\u00e9ndolo en la misma posici\u00f3n. Estructura AlmacenFiguras Propiedades almacenadas: rectangulos y circulos que contienen respectivamente arrays de rect\u00e1ngulos y c\u00edrculos inicializados a arrays vac\u00edos. Propiedades calculadas: numFiguras ( Int ) que devuelve el n\u00famero total de figuras creadas. areaTotal ( Double ) que devuelve la suma total de las \u00e1reas de todas las figuras creadas. M\u00e9todos: a\u00f1ade(rectangulo:) y a\u00f1ade(circulo:) que a\u00f1aden un rect\u00e1ngulo y un c\u00edrculo al array correspondiente. Nota La definici\u00f3n anterior del almac\u00e9n de figuras no es demasiado correcta, porque se utiliza una variable distinta para cada tipo de figura, sin generalizar. En la pr\u00e1ctica de la semana que viene veremos c\u00f3mo mejorarlo utilizando protocolos. Implementa las estructuras anteriores y escribe alg\u00fan ejemplo de c\u00f3digo en el que se creen al menos un rect\u00e1ngulo y un c\u00edrculo, se prueben sus propiedades, se a\u00f1adan al almac\u00e9n de figuras y se prueben sus m\u00e9todos.","title":"Ejercicio 3"},{"location":"practicas/practica10/practica10.html#ejercicio-4","text":"Tenemos que escribir un programa que permita definir resultados de partidos de f\u00fatbol y calcular la puntuaci\u00f3n de un conjunto de equipos una vez que se han jugado esos partidos. Escribe c\u00f3digo en Swift que permita resolver el problema, utilizando structs . Un ejemplo de ejecuci\u00f3n del c\u00f3digo deber\u00eda ser c\u00f3mo sigue: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 -------------- Puntuaci\u00f3n antes de los partidos: Real Madrid: 0 puntos Barcelona: 0 puntos Atl\u00e9tico Madrid: 0 puntos Valencia: 0 puntos Athl\u00e9tic Bilbao: 0 puntos Sevilla: 0 puntos -------------- Resultados: Real Madrid 0 - Barcelona 3 Sevilla 1 - Athl\u00e9tic Bilbao 1 Valencia 2 - Atl\u00e9tico Madrid 1 -------------- Puntuaci\u00f3n despu\u00e9s de los partidos: Real Madrid: 0 puntos Barcelona: 3 puntos Atl\u00e9tico Madrid: 0 puntos Valencia: 3 puntos Athl\u00e9tic Bilbao: 1 puntos Sevilla: 1 puntos Lenguajes y Paradigmas de Programaci\u00f3n, curso 2018-19 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Domingo Gallardo, Cristina Pomares, Antonio Bot\u00eda, Francisco Mart\u00ednez","title":"Ejercicio 4"},{"location":"practicas/practica11/practica11.html","text":"Pr\u00e1ctica 11: Programaci\u00f3n Orientada a Objetos en Swift (2) \u00b6 Entrega de la pr\u00e1ctica \u00b6 Para entregar la pr\u00e1ctica debes subir a Moodle el fichero practica11.swift con una cabecera inicial con tu nombre y apellidos, y las soluciones de cada ejercicio separadas por comentarios. Ejercicios \u00b6 Ejercicio 1 \u00b6 a) Escribe un ejemplo de c\u00f3digo en el que definas una relaci\u00f3n de herencia entre una clase base y una clase derivada. Comprueba en el c\u00f3digo que un objeto de la clase derivada hereda las propiedades y m\u00e9todos de la clase base. Investiga sobre el funcionamiento de la herencia en Swift. Escribe ejemplos en donde compruebes este funcionamiento. Algunos ejemplos de preguntas que puedes investigar (puedes a\u00f1adir t\u00fa m\u00e1s preguntas): \u00bfSe puede sobreescribir el valor de una propiedad almacenada? \u00bfY calculada? \u00bfSe puede a\u00f1adir un observador a una propiedad de la clase base en una clase derivada? \u00bfHereda la clase derivada propiedades y m\u00e9todos est\u00e1ticos de la clase base? \u00bfC\u00f3mo se puede llamar a la implementaci\u00f3n de un m\u00e9todo de la clase base en una sobreescritura de ese mismo m\u00e9todo en la clase derivada? b) El siguiente c\u00f3digo tiene errores. Intenta descubrir cu\u00e1les son sin utilizar el compilador. Prueba distintas formas de arreglar el c\u00f3digo cambiando lo m\u00ednimo posible de lo ya definido (por ejemplo, no debes a\u00f1adir nuevas propiedades en MiStruct ). Compru\u00e9balo con el compilador. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 protocol A { var a : String { get set } func foo ( a : Int , b : Int ) -> Int ? } protocol B { mutating func bar () } struct MiStruct : A , B { let a = 10 func foo ( valor1 a : Int , valor2 b : Int ) -> Int { let res = a > 10 ? a : b return res } } c) Repasa el protocolo GeneradorNumerosAleatorios visto en teor\u00eda. Define otra implementaci\u00f3n del protocol llamada GeneradorFake en la que siempre se devuelva el n\u00famero 0.1 . Cambia el ejemplo del dado para que utilice este generador y comprueba que siempre devuelve el n\u00famero 1. c) Supongamos la estructura Equipo que aparece a continuaci\u00f3n que representa un equipo en una competici\u00f3n deportiva: 1 2 3 4 struct Equipo { let puntos : Int let nombre : String } Debes hacer que la estructura se ajuste al protocolo Comparable para poder comparar dos equipos . Consulta el protocolo en documentaci\u00f3n de Swift . Un equipo ser\u00e1 menor que otro cuando tenga menos puntos. En el caso en que ambos tengan los mismos puntos, ser\u00e1 menor el que tenga menor nombre en orden alfab\u00e9tico. Una vez definidos los operadores necesarios comprueba que funcionan correctamente creando varios equipos, insert\u00e1ndolos en un array y llamando al m\u00e9todo sorted . Ejercicio 2 \u00b6 En este ejercicio deber\u00e1s implementar un conjunto de clases con las que podamos \"simular\" una carrera de coches. Funci\u00f3n random Utilizaremos la funci\u00f3n del sistema random() que devuelve un n\u00famero aleatorio. Hay que importar la librer\u00eda Glibc (en Linux) y Foundation (en iOS) para usarla. A continuaci\u00f3n puedes ver un ejemplo de su utilizaci\u00f3n en un m\u00e9todo de tipo del enumerado MarcaCoche para devolver una marca aleatoria de coche: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import Glibc func rand ( n : Int ) -> Int { return random () % n } enum MarcaCoche : Int { case Mercedes = 0 , Ferrari , RedBull , McLaren static func random () -> MarcaCoche { let maxValue = McLaren . rawValue let r = rand ( maxValue + 1 ) return MarcaCoche ( rawValue : r ) ! } } Enumerados y clases que gestionan los veh\u00edculos Deber\u00e1s implementar los siguientes enumerados y clases, con las propiedades indicadas. Enumerado MarcaCoche Posibles valores: Mercedes , Ferrari , RedBull y McLaren M\u00e9todo del tipo random() que devuelva aleatoriamente uno de los valores (consultar el c\u00f3digo anterior). Enumerado TipoCambio Posibles valores: Automatico o Manual M\u00e9todo del tipo random() que devuelve uno de esos valores. Clase base Coche Propiedades de instancia almacenadas: velocidadActual ( Double ), marcha ( Int ), distanciaRecorrida ( Double ) y marca ( MarcaCoche ). Propiedad de instancia calculada: descripcion ( String ), que devuelve la marca del coche. Propiedades del tipo: Constantes velocidadMaxima ( Double ) y marchaMaxima ( Int ) inicializadas a 150.0 y 6 Subclase CocheAutomatico Hereda de Coche y sobreescribe la descripci\u00f3n, a\u00f1adiendo la cadena \"Autom\u00e1tico\". Subclase CocheManual Hereda de Coche y sobreescribe la descripci\u00f3n, a\u00f1adiendo la cadena \"Manual\". Observadores de propiedades en las subclases La velocidad de un coche manual se modifica cambiando su propiedad marcha y la de un coche autom\u00e1tico cambiando su propiedad velocidadActual . En cada caso hay que definir observadores de propiedades que modifiquen la otra propiedad. La velocidad se calcula a partir de la marcha seg\u00fan la siguiente expresi\u00f3n: 1 velocidadActual = 25.0 * marcha Y la marcha se calcula a partir de la velocidad con la expresi\u00f3n que puedes encontrar en los apuntes de teor\u00eda, en la definici\u00f3n de la clase CocheAutomatico . Distancia recorrida e informaci\u00f3n en pantalla Suponemos que se cambia la velocidad del coche cada hora y que en cada cambio de velocidad se actualiza la propiedad distanciaRecorrida , que ir\u00e1 acumulando la distancia recorrida por el coche desde su inicializaci\u00f3n. Cada vez que se cambia la velocidad tambi\u00e9n se imprimir\u00e1 la velocidad actual y la marca del coche en pantalla (ver el ejemplo al final del ejercicio). Esto se puede implementar tambi\u00e9n en los observadores. Clase Carrera Debes implementar las clases anteriores y una clase Carrera con la que simular una carrera de n coches que conducen durante k horas. Un ejemplo de uso de la clase Carrera : 1 2 3 4 5 6 7 let carrera = Carrera ( numCoches : 2 , horas : 3 ) print ( \" \\n Descripci\u00f3n de la carrera:\" ) carrera . descripcion () print ( \" \\n !!! Comienza la carrera !!!\" ) carrera . empezar () print ( \" \\n !!! Clasificaci\u00f3n !!!\" ) carrera . clasificacion () Y su correspondiente salida por pantalla: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 Descripci\u00f3n de la carrera: 2 coches con una duraci\u00f3n de 3 horas McLaren Automatico Mercedes Manual !!! Comienza la carrera !!! Horas transcurridas 1 McLaren Automatico viajando a 141.0 kil\u00f3metros por hora con la marcha 6 Mercedes Manual viajando a 25.0 kil\u00f3metros por hora con la marcha 1 Horas transcurridas 2 McLaren Automatico viajando a 114.0 kil\u00f3metros por hora con la marcha 5 Mercedes Manual viajando a 25.0 kil\u00f3metros por hora con la marcha 1 Horas transcurridas 3 McLaren Automatico viajando a 105.0 kil\u00f3metros por hora con la marcha 5 Mercedes Manual viajando a 100.0 kil\u00f3metros por hora con la marcha 4 !!! Clasificaci\u00f3n !!! 1. McLaren Automatico (360.0 kil\u00f3metros recorridos) 2. Mercedes Manual (150.0 kil\u00f3metros recorridos) Ejercicio 3 \u00b6 a) Completa el bucle con el c\u00f3digo que comprueba el tipo de la variable i e imprime su propiedad x y su propiedad b o c , dependiendo de su tipo. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 protocol X { var x : Int { get } } class Xb : A { var x = 0 var b = 0 } class Xc : A { var x = 1 var c = 0 } var array : [ X ] = [ Xb (), Xc ()] for i in array { // // C\u00f3digo a completar // } // debe imprimir: // x: 0, b: 0 // x: 1, c: 0 b) Completa el c\u00f3digo que hay a continuaci\u00f3n para que compile correctamente y aparezca en pantalla el resultado que se muestra. Resultado: 1 2 0.0 300.0 C\u00f3digo: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 protocol TieneVelocidad { func velocidadActual () -> Double } class Vehiculo { var velocidad = 0.0 func velocidadActual () -> Double { return velocidad } } class Tren { static let velocidadEnMarcha = 300.0 var pasajeros = 0 var enMarcha = false } // // C\u00f3digo a completar // var vehiculo1 = Vehiculo () var tren1 = Tren () tren1 . enMarcha = true let transportes : [ TieneVelocidad ] = [ vehiculo1 , tren1 ] for i in transportes { print ( i . velocidadActual ()) } c) Define una extensi\u00f3n del enum Arbol del ejercicio 2 de la pr\u00e1ctica 9 en la que se implemente el m\u00e9todo min que devuelva el menor elemento del \u00e1rbol. En la extensi\u00f3n debes especificar que el tipo de los elementos del \u00e1rbol deben cumplir el protocolo Comparable , para poder realizar la comparaci\u00f3n y obtener el m\u00ednimo. Haz una prueba con un \u00e1rbol de equipos, objetos de la estructura Equipo definida en el apartado anterior. Ejercicio 4 \u00b6 Continuamos con el ejercicio de las figuras geom\u00e9tricas de la pr\u00e1ctica anterior. Comienza incluyendo en la pr\u00e1ctica el c\u00f3digo de todas las definiciones de las estructuras y clases geom\u00e9tricas: Punto , Tama\u00f1o , Rectangulo y Circulo . Una vez incluido debes realizar lo siguiente. Protocolo figura Define el protocolo Figura que contiene: Propiedad de lectura y escritura centro ( Punto ), que define el centro de la figura. Propiedades de s\u00f3lo lectura area ( Double ) y tama\u00f1o ( Tama\u00f1o ) que devuelven el tama\u00f1o (alto y ancho) de la figura. Extensiones Define las extensiones necesarias para que las clases Rectangulo , y Circulo se ajusten al protocolo Figura , a\u00f1adiendo el c\u00f3digo de implementaci\u00f3n necesario. A\u00f1ade mediante una extensi\u00f3n al protocolo Figura la propiedad calculada descripcion que devuelva un String con el centro y el \u00e1rea de la figura. Clase AlmacenFiguras Reescribe la clase AlmacenFiguras y define en ella una \u00fanica propiedad figuras que contenga todas las figuras que se vayan creando. Reescribe tambi\u00e9n la implementaci\u00f3n de areaTotal . Modifica los inicializadores en las clases geom\u00e9tricas para que se incluya la figura reci\u00e9n creada en esta propiedad. Escribe el m\u00e9todo de clase cuentaTipos() -> (Int, Int) que recorra el array de figuras y devuelva una tupla con dos enteros: n\u00famero de rect\u00e1ngulos y n\u00famero de c\u00edrculos. La funci\u00f3n debe imprimir por cada figura del array, su descripci\u00f3n por defecto proporcionada por el protocolo y el tipo de figura y sus caracter\u00edsticas espec\u00edficas. Por ejemplo: 1 2 3 4 - Descripci\u00f3n de la figura: Una figura con centro Punto(x: 7.0, y: 3.5) y \u00e1rea 50.0 Rectangulo con origen Punto(x: 2.0, y: 1.0) y tama\u00f1o Tama\u00f1o(ancho: 10.0, alto: 5.0) - Descripci\u00f3n de la figura: Una figura con centro Punto(x: 0.0, y: 2.0) y \u00e1rea 78.5398163397448 Circulo con centro Punto(x: 0.0, y: 2.0) y radio 5.0 Lenguajes y Paradigmas de Programaci\u00f3n, curso 2018-19 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Domingo Gallardo, Cristina Pomares, Antonio Bot\u00eda, Francisco Mart\u00ednez","title":"Pr\u00e1ctica 11: Programaci\u00f3n Orientada a Objetos en Swift (2)"},{"location":"practicas/practica11/practica11.html#practica-11-programacion-orientada-a-objetos-en-swift-2","text":"","title":"Pr\u00e1ctica 11: Programaci\u00f3n Orientada a Objetos en Swift (2)"},{"location":"practicas/practica11/practica11.html#entrega-de-la-practica","text":"Para entregar la pr\u00e1ctica debes subir a Moodle el fichero practica11.swift con una cabecera inicial con tu nombre y apellidos, y las soluciones de cada ejercicio separadas por comentarios.","title":"Entrega de la pr\u00e1ctica"},{"location":"practicas/practica11/practica11.html#ejercicios","text":"","title":"Ejercicios"},{"location":"practicas/practica11/practica11.html#ejercicio-1","text":"a) Escribe un ejemplo de c\u00f3digo en el que definas una relaci\u00f3n de herencia entre una clase base y una clase derivada. Comprueba en el c\u00f3digo que un objeto de la clase derivada hereda las propiedades y m\u00e9todos de la clase base. Investiga sobre el funcionamiento de la herencia en Swift. Escribe ejemplos en donde compruebes este funcionamiento. Algunos ejemplos de preguntas que puedes investigar (puedes a\u00f1adir t\u00fa m\u00e1s preguntas): \u00bfSe puede sobreescribir el valor de una propiedad almacenada? \u00bfY calculada? \u00bfSe puede a\u00f1adir un observador a una propiedad de la clase base en una clase derivada? \u00bfHereda la clase derivada propiedades y m\u00e9todos est\u00e1ticos de la clase base? \u00bfC\u00f3mo se puede llamar a la implementaci\u00f3n de un m\u00e9todo de la clase base en una sobreescritura de ese mismo m\u00e9todo en la clase derivada? b) El siguiente c\u00f3digo tiene errores. Intenta descubrir cu\u00e1les son sin utilizar el compilador. Prueba distintas formas de arreglar el c\u00f3digo cambiando lo m\u00ednimo posible de lo ya definido (por ejemplo, no debes a\u00f1adir nuevas propiedades en MiStruct ). Compru\u00e9balo con el compilador. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 protocol A { var a : String { get set } func foo ( a : Int , b : Int ) -> Int ? } protocol B { mutating func bar () } struct MiStruct : A , B { let a = 10 func foo ( valor1 a : Int , valor2 b : Int ) -> Int { let res = a > 10 ? a : b return res } } c) Repasa el protocolo GeneradorNumerosAleatorios visto en teor\u00eda. Define otra implementaci\u00f3n del protocol llamada GeneradorFake en la que siempre se devuelva el n\u00famero 0.1 . Cambia el ejemplo del dado para que utilice este generador y comprueba que siempre devuelve el n\u00famero 1. c) Supongamos la estructura Equipo que aparece a continuaci\u00f3n que representa un equipo en una competici\u00f3n deportiva: 1 2 3 4 struct Equipo { let puntos : Int let nombre : String } Debes hacer que la estructura se ajuste al protocolo Comparable para poder comparar dos equipos . Consulta el protocolo en documentaci\u00f3n de Swift . Un equipo ser\u00e1 menor que otro cuando tenga menos puntos. En el caso en que ambos tengan los mismos puntos, ser\u00e1 menor el que tenga menor nombre en orden alfab\u00e9tico. Una vez definidos los operadores necesarios comprueba que funcionan correctamente creando varios equipos, insert\u00e1ndolos en un array y llamando al m\u00e9todo sorted .","title":"Ejercicio 1"},{"location":"practicas/practica11/practica11.html#ejercicio-2","text":"En este ejercicio deber\u00e1s implementar un conjunto de clases con las que podamos \"simular\" una carrera de coches.","title":"Ejercicio 2"},{"location":"practicas/practica11/practica11.html#ejercicio-3","text":"a) Completa el bucle con el c\u00f3digo que comprueba el tipo de la variable i e imprime su propiedad x y su propiedad b o c , dependiendo de su tipo. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 protocol X { var x : Int { get } } class Xb : A { var x = 0 var b = 0 } class Xc : A { var x = 1 var c = 0 } var array : [ X ] = [ Xb (), Xc ()] for i in array { // // C\u00f3digo a completar // } // debe imprimir: // x: 0, b: 0 // x: 1, c: 0 b) Completa el c\u00f3digo que hay a continuaci\u00f3n para que compile correctamente y aparezca en pantalla el resultado que se muestra. Resultado: 1 2 0.0 300.0 C\u00f3digo: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 protocol TieneVelocidad { func velocidadActual () -> Double } class Vehiculo { var velocidad = 0.0 func velocidadActual () -> Double { return velocidad } } class Tren { static let velocidadEnMarcha = 300.0 var pasajeros = 0 var enMarcha = false } // // C\u00f3digo a completar // var vehiculo1 = Vehiculo () var tren1 = Tren () tren1 . enMarcha = true let transportes : [ TieneVelocidad ] = [ vehiculo1 , tren1 ] for i in transportes { print ( i . velocidadActual ()) } c) Define una extensi\u00f3n del enum Arbol del ejercicio 2 de la pr\u00e1ctica 9 en la que se implemente el m\u00e9todo min que devuelva el menor elemento del \u00e1rbol. En la extensi\u00f3n debes especificar que el tipo de los elementos del \u00e1rbol deben cumplir el protocolo Comparable , para poder realizar la comparaci\u00f3n y obtener el m\u00ednimo. Haz una prueba con un \u00e1rbol de equipos, objetos de la estructura Equipo definida en el apartado anterior.","title":"Ejercicio 3"},{"location":"practicas/practica11/practica11.html#ejercicio-4","text":"Continuamos con el ejercicio de las figuras geom\u00e9tricas de la pr\u00e1ctica anterior. Comienza incluyendo en la pr\u00e1ctica el c\u00f3digo de todas las definiciones de las estructuras y clases geom\u00e9tricas: Punto , Tama\u00f1o , Rectangulo y Circulo . Una vez incluido debes realizar lo siguiente.","title":"Ejercicio 4"},{"location":"seminarios/seminario1-scheme/seminario1-scheme.html","text":"Seminario 1: Seminario de Scheme \u00b6 Bibliograf\u00eda \u00b6 Este seminario est\u00e1 basado en los siguientes materiales. Os recomendamos que les ech\u00e9is un vistazo y, si os interesa y os queda tiempo, que explor\u00e9is tambi\u00e9n en los enlaces que hemos dejado en los apuntes para ampliar informaci\u00f3n. The Racket Guide The Racket Reference Simply Scheme El lenguaje de programaci\u00f3n Scheme \u00b6 Scheme es un lenguaje de programaci\u00f3n que surgi\u00f3 en los laboratorios del MIT en 1975, cuando Guy L. Steele y Gerarld J. Sussman buscaban un lenguaje con una sem\u00e1ntica muy clara y sencilla. Scheme es un dialecto de Lisp, es un lenguaje interpretado, muy expresivo y soporta varios paradigmas. Estuvo influenciado por el c\u00e1lculo lambda. El desarrollo de Scheme ha sido lento, ya que la gente que estandariz\u00f3 Scheme es muy conservadora en cuanto a a\u00f1adirle nuevas caracter\u00edsticas,porque la calidad ha sido siempre m\u00e1s importante que la utilidad empresarial. Por eso Scheme es considerado como uno de los lenguajes mejor dise\u00f1ados de prop\u00f3sito general. Aprender Scheme har\u00e1 que se\u00e1is mejores programadores cuando utilic\u00e9is otros lenguajes de programaci\u00f3n. El lenguaje de programaci\u00f3n Racket \u00b6 \u00bfQu\u00e9 vamos a aprender? \u00bfRacket o Scheme? La respuesta es: Scheme trabajando en Racket. Racket se dise\u00f1\u00f3 en 1995 bas\u00e1ndose en Scheme y ampli\u00e1ndolo con nuevas funcionalidades, como la posibilidad de extenderlo con librer\u00edas. El lenguaje contiene librer\u00edas muy \u00fatiles (librer\u00edas gr\u00e1ficas, de conexi\u00f3n a servidores HTTP, de conexi\u00f3n a bases de datos, etc.) con las que se moderniza el lenguaje original y se convierte en un lenguaje pr\u00e1ctico para desarrollar todo tipo de aplicaciones, desde videojuegos a servidores web. Sin embargo, nosotros s\u00f3lo vamos a usar Racket para aprender la parte que corresponde al n\u00facleo original de Scheme. El entorno de programaci\u00f3n DrRacket \u00b6 Veamos una peque\u00f1a introducci\u00f3n al entorno de programaci\u00f3n que proporciona DrRacket. Puedes encontrar m\u00e1s informaci\u00f3n en la documentaci\u00f3n original . Descarga de DrRacket DrRacket es multiplataforma y puede ejecutarse en Linux, MacOS o Windows. Vamos a utilizar la versi\u00f3n 7.5. Puedes descargarla desde el siguiente enlace: Descarga de DrRacket Configuraci\u00f3n de DrRacket Para poder trabajar correctamente con DrRacket debemos asegurarnos que el lenguaje activo es The Racket Language y que la sintaxis de la salida tiene activada la opci\u00f3n write , como aparece en la siguiente imagen: Podemos modificar esa opci\u00f3n con los siguientes men\u00fas: Language > Choose Language (seleccionamos The Racket Language) > Show details > Output Syntax > write Esta opci\u00f3n determina la sintaxis de la salida del int\u00e9rprete del lenguaje, que va a ser uno de los elementos fundamentales para aprender Scheme. Aviso Una vez seleccionadas estas opciones, la configuraci\u00f3n se guarda en las preferencias del usuario. En los laboratorios de la EPS hay que realizar la configuraci\u00f3n al comienzo de cada sesi\u00f3n. Cuando lanzamos DrRacket, vemos que tiene tres partes: una fila de botones arriba, dos paneles de edici\u00f3n en el medio y una barra de estado abajo. El panel de edici\u00f3n superior es la ventana de definiciones. Se utiliza para implementar funciones, como la funci\u00f3n cuadrado en el ejemplo. El panel inferior, llamado ventana de interacci\u00f3n , se utiliza para evaluar expresiones interactivamente, usando el int\u00e9rprete de Racket. Pulsando el bot\u00f3n Run , se eval\u00faa el programa de la ventana de definiciones , haciendo que esas definiciones est\u00e9n disponibles en la ventana de interacci\u00f3n. As\u00ed, dada la definici\u00f3n de cuadrado , despu\u00e9s de pulsar Run , podemos teclear la expresi\u00f3n (cuadrado 2) en el int\u00e9rprete, se evaluar\u00e1 y mostrar\u00e1 el resultado, en este caso 4. DrRacket soporta muchos lenguajes y dialectos de Scheme. Nosotros vamos a utilizar el lenguaje por defecto, el lenguaje Racket . Para ello no es necesario realizar nada, s\u00f3lo asegurarnos de lo siguiente: En la parte inferior de la ventana aparece \" Determine language from source \" El fichero que se est\u00e1 editando en el panel de edici\u00f3n comienza con la l\u00ednea: 1 #lang racket Finalmente, si pulsamos el bot\u00f3n Run (Ejecutar) comprobaremos que se carga ese lenguaje en el int\u00e9rprete. Cambiar el idioma del entorno Podemos interactuar con el entorno en el idioma que queramos. Si queremos tenerlo por ejemplo en espa\u00f1ol, vamos al men\u00fa Help -> Interact\u00faa con DrRacket en espa\u00f1ol . Nos aparecer\u00e1 un di\u00e1logo que nos obligar\u00e1 a reiniciar el int\u00e9rprete para aceptar los cambios. C\u00f3mo escribir en el int\u00e9rprete En la ventana inferior se encuentra el int\u00e9rprete de Racket. El int\u00e9rprete realiza un bucle en el que se lee una expresi\u00f3n, se eval\u00faa su resultado y se imprime. A este tipo de bucle se denomina en ingl\u00e9s REPL ( Read-Evaluate-Print Loop ). Las expresiones que escribimos en el int\u00e9rprete se guardan en un hist\u00f3rico. Podemos recuperar las expresiones anteriores y movernos por ese hist\u00f3rico usando las siguientes combinaciones de teclas: CTRL + flecha arriba/abajo Puede ser que esa combinaci\u00f3n de teclas est\u00e9 asignada a otras funciones en tu configuraci\u00f3n de sistema operativo. Puedes cambiar esa configuraci\u00f3n o usar la combinaci\u00f3n alternativa de DrRacket: ESC + p (previous) / n (next) Tambi\u00e9n podemos seleccionar con el cursor una expresi\u00f3n y al pulsar RETURN se copia autom\u00e1ticamente en el prompt . El lenguaje Scheme \u00b6 Vamos a empezar probando algunos ejemplos \u00b6 Scheme es un lenguaje interpretado. Vamos a lanzar DrRacket y teclear en la ventana de interacci\u00f3n algunas expresiones. El int\u00e9rprete analizar\u00e1 la expresi\u00f3n y mostrar\u00e1 el valor resultante de evaluarla. 1 2 3 4 5 2 ; \u21d2 2 ( + 2 3 ) ; \u21d2 5 ( + ) ; \u21d2 0 ( + 2 4 5 6 ) ; \u21d2 17 ( + ( * 2 3 ) ( - 3 1 )) ; \u21d2 8 Las expresiones en Scheme tienen una forma denominada notaci\u00f3n prefija de Cambridge (el nombre de Cambridge es por la localidad Cambridge, Massachusets, donde reside el MIT, lugar en el que se ide\u00f3 el Lisp), en la que la expresi\u00f3n est\u00e1 delimitada por par\u00e9ntesis y el operador va seguido de los operandos. La sintaxis es la siguiente: 1 ( <funci\u00f3n> <arg1> ... <argn> ) En Scheme podemos interpretar los par\u00e9ntesis abiertos \u2018(\u2019 como evaluadores o lanzadores de la funci\u00f3n que hay a continuaci\u00f3n. La forma que tiene Scheme de evaluar una expresi\u00f3n es muy sencilla: Eval\u00faa cada uno de los argumentos Aplica la funci\u00f3n nombrada tras el par\u00e9ntesis a los valores resultantes de la evaluaci\u00f3n anterior 1 2 3 4 5 (+ (* 2 3) (- 3 (/ 12 3))) \u21d2 (+ 6 (- 3 (/ 12 3))) \u21d2 (+ 6 (- 3 4)) \u21d2 (+ 6 -1) \u21d2 5 En Scheme los t\u00e9rminos funci\u00f3n y procedimiento significan lo mismo y se usan de forma intercambiable. Son ejemplos de funciones o procedimientos: +, -, *. En Scheme la evaluaci\u00f3n de una funci\u00f3n siempre devuelve un valor, a no ser que se produzca un error que detiene la evaluaci\u00f3n: 1 2 ( * ( + 3 4 ) ( / 3 0 )) ; Error /: division by zero Definiendo variables y funciones \u00b6 Scheme es un lenguaje multiparadigma pero principalmente funcional, y una de sus caracter\u00edsticas principales es que los programas se construyen mediante la definici\u00f3n de funciones. Podemos utilizar en el int\u00e9rprete la forma especial define para definir variables y funciones. En clase de teor\u00eda veremos c\u00f3mo es el funcionamiento del define , pero por el momento lo utilizaremos para definir variables asociadas a valores, y para implementar funciones. Podemos definir variables en la ventana de interacci\u00f3n para facilitar la escritura de expresiones: 1 2 3 4 5 ( define pi 3.14159 ) pi ; \u21d2 3.14159 ( sin ( / pi 2 )) ; \u21d2 0.9999999999991198 ( define a ( + 2 ( * 3 4 ))) a ; \u21d2 14 Para implementar una funci\u00f3n tambi\u00e9n se utiliza define, con la siguiente sintaxis: 1 2 3 ( define ( <nombre-funcion> <args> ) <cuerpo-funcion> ) Por ejemplo, vamos a implementar una funci\u00f3n que toma dos n\u00fameros como par\u00e1metros y devuelve la suma de sus cuadrados: 1 2 ( define ( suma-cuadrados x y ) ( + ( * x x ) ( * y y ))) Si llamamos a la funci\u00f3n pasando el 2 y el 3 como par\u00e1metros, la funci\u00f3n devuelve el n\u00famero 13: 1 ( suma-cuadrados 2 3 ) ; \u21d2 13 Nota A diferencia de la mayor\u00eda de lenguajes de programaci\u00f3n, en Scheme no se utiliza la palabra return para indicar que una funci\u00f3n devuelve un valor. Las funciones se definen con una \u00fanica expresi\u00f3n y el resultado calculado en esa expresi\u00f3n es el que siempre se devuelve. Lenguaje d\u00e9bilmente tipado \u00b6 Vamos a comprobar una caracter\u00edstica muy importante de Scheme: ser un lenguaje d\u00e9bilmente tipado . Por esto entendemos, entre otras cosas, que las variables, funciones y argumentos no tienen un tipo declarado. Es posible usar valores de distintos tipos de datos para asignar sucesivamente a una misma variable (en el caso de un lenguaje imperativo) o para pasar como par\u00e1metro a una misma funci\u00f3n (en el caso de un lenguaje funcional). Por ejemplo, JavaScript o PHP son tambi\u00e9n lenguajes d\u00e9bilmente tipados imperativos. Veamos c\u00f3mo funciona esto en Scheme usando la funci\u00f3n anterior como ejemplo. 1 2 ( define ( suma-cuadrados x y ) ( + ( * x x ) ( * y y ))) Vemos que los argumentos x e y no tienen ning\u00fan tipo. Si se invoca a la funci\u00f3n pasando alg\u00fan dato que no sea un n\u00famero, el int\u00e9rprete no detectar\u00e1 ning\u00fan error y permitir\u00e1 asignar a los argumentos x e y esos datos. El error se produce en el momento en que se intenta evaluar la multiplicaci\u00f3n. Lo podemos comprobar con el siguiente ejemplo, en el que se muestra el mensaje de error resultante: 1 2 3 4 5 6 > ( suma-cuadrados 10 \"hola\" ) *: contract violation expected: number? given: \"hola\" argument position: 1st other arguments...: Veremos m\u00e1s adelante que hay distintos tipos de n\u00fameros que podemos operar usando la divisi\u00f3n, la suma y la multiplicaci\u00f3n. La funci\u00f3n definida va a funcionar bien para todos ello. Podemos pasar a la funci\u00f3n n\u00fameros enteros, n\u00fameros reales o incluso fracciones: 1 2 3 ( suma-cuadrados 2 5 ) ; \u21d2 29 ( suma-cuadrados 2.4 5.8 ) ; \u21d2 39.4 ( suma-cuadrados ( / 2 3 ) ( / 3 5 )) ; \u21d2 181/225 En la \u00faltima expresi\u00f3n tambi\u00e9n pueden pasarse directamente los n\u00fameros fracionales, el int\u00e9rprete de Scheme entiende esa notaci\u00f3n: 1 ( suma-cuadrados 2/3 3/5 ) ; \u21d2 181/225 Tipos de datos simples \u00b6 Las primitivas de Scheme consisten en un conjunto de tipos de datos, formas especiales y funciones incluidas en el lenguaje. A lo largo del curso iremos introduciendo estas primitivas. Vamos a revisar algunos tipos de datos simples de Scheme, as\u00ed como algunas funciones primitivas para trabajar con valores de esos tipos. Booleanos N\u00fameros Caracteres Booleanos Un booleano es un valor de verdad, que puede ser verdadero o falso. En Scheme, tenemos los s\u00edmbolos #t y #f para expresar verdadero y falso respectivamente, pero en muchas operaciones se considera que cualquier valor distinto de #f es verdadero. Ejemplos: 1 2 3 4 5 6 7 8 9 10 #t ; verdadero #f ; falso ( > 3 1.5 ) ; \u21d2 #t ( = 3 3.0 ) ; \u21d2 #t (igualdad matem\u00e1tica) ( equal? 3 3.0 ) ; \u21d2 #f (igualdad de tipo) ( or ( < 3 1.5 ) #t ) ; \u21d2 #t ( and #t #t #f ) ; \u21d2 #f ( not #f ) ; \u21d2 #t ( not 3 ) ; \u21d2 #f (permite cualquier argumento; ; s\u00f3lo devuelve #t cuando el argumento es #f) N\u00fameros La cantidad de tipos num\u00e9ricos que soporta Scheme es grande, incluyendo enteros de diferente precisi\u00f3n, n\u00fameros racionales, complejos e inexactos. Por ejemplo: 1 2 3 4 5 6 7 ( / 1 3 ) ; \u21d2 Devuelve la fracci\u00f3n 1/3 ( + 1/3 1/3 ) ; \u21d2 2/3 ( + 2 3 4 ) ; \u21d2 11 (la funci\u00f3n + admite un n\u00famero variable de argumentos) ( + 1/3 0.0 ) ; n\u00famero real con infinita precisi\u00f3n \u21d2 0.3333333333333333 ( * ( + 1/3 0.0 ) 3 ) ; \u21d2 1 ( sqrt -1 ) ; \u21d2 0+1i (n\u00famero imaginario) ( + 3+2i 2-i ) ; \u21d2 5+1i (operaciones con n\u00fameros imaginarios) Algunas primitivas sobre n\u00fameros 1 2 3 4 5 6 7 8 9 ( <= 2 3 3 4 5 ) ; \u21d2 #t (los argumentos est\u00e1n en orden creciente) ( max 3 5 10 1000 ) ; \u21d2 #1000 ( / 22 4 ) ; Devuelve una fracci\u00f3n ( quotient 22 4 ) ; \u21d2 5 (cociente de la divisi\u00f3n entera) ( remainder 22 4 ) ; \u21d2 2 (resto de la divisi\u00f3n entera) ( equal? 0.5 ( / 1 2 )) ; \u21d2 #f (distintos tipos de datos) ( = 0.5 ( / 1 2 )) ; \u21d2 #t (igualdad matem\u00e1tica) ( abs ( * 3 -2 )) ; \u21d2 6 (valor absoluto) ( sin 2.2 ) ; relacionados: cos, tan, asin, acos, ata Funciones de redondeo 1 2 3 4 5 6 7 8 9 10 11 12 13 ; (floor x) devuelve el entero m\u00e1s grande no mayor que x ; (ceiling x) devuelve el entero m\u00e1s peque\u00f1o no menor que x ; (truncate x) devuelve el entero m\u00e1s cercano a x cuyo valor absoluto ; no es mayor que el valor absoluto de x ; (round x) devuelve el entero m\u00e1s cercano a x, redondeado ( floor -4.3 ) ; \u21d2 -5.0 ( floor 3.5 ) ; \u21d2 3.0 ( ceiling -4.3 ) ; \u21d2 -4.0 ( ceiling 3.5 ) ; \u21d2 4.0 ( truncate -4.3 ) ; \u21d2 -4.0 ( truncate 3.5 ) ; \u21d2 3.0 ( round -4.3 ) ; \u21d2 -4.0 ( round 3.5 ) ; \u21d2 4.0 Predicados sobre n\u00fameros Se denominan predicados a funciones que devuelven un booleano. 1 2 3 4 5 ( positive? -4 ) ; \u21d2 #f (-4 no es positivo) ( negative? -4 ) ; \u21d2 #t (-4 es negativo) ( zero? 0.2 ) ; \u21d2 #f (comprueba si el resultado es cero) ( even? 2 ) ; \u21d2 #t (comprueba si es par) ( odd? 3 ) ; \u21d2 #t (comprueba si es impar) En Scheme tenemos predicados que nos permiten comprobar el tipo de un par\u00e1metro. En el caso de los n\u00fameros, el tipo de n\u00famero: 1 2 3 4 5 ( number? 1 ) ; \u21d2 #t (el argumento 1 es un n\u00famero) ( integer? 2.3 ) ; \u21d2 #f (el argumento 2.3 no es un entero) ( integer? 4.0 ) ; \u21d2 #t (el n\u00famero 4.0 matem\u00e1ticamente es id\u00e9ntico ; al n\u00famero 4) ( real? 1 ) ; \u21d2 #t Caracteres Se soportan caracteres internacionales y se codifican en UTF-8. 1 2 3 4 5 #\\a #\\A #\\space #\\\u00f1 #\\\u00e1 Operaciones sobre caracteres 1 2 3 4 5 6 7 8 9 10 11 12 13 ( char<? #\\a #\\b ) ; \u21d2 #t (el car\u00e1cter #\\a es anterior al #\\b) ( char-numeric? #\\1 ) ; \u21d2 #t (el car\u00e1cter #\\1 es un n\u00famero) ( char-alphabetic? #\\3 ) ; \u21d2 #f (el car\u00e1cter #\\3 es un n\u00famero) ( char-whitespace? #\\tab ) ; \u21d2 #t (el car\u00e1cter tabulador es un espacio ; en blanco) ( char-upper-case? #\\A ) ; \u21d2 #t (el car\u00e1cter #\\A es una letra may\u00fascula) ( char-lower-case? #\\a ) ; \u21d2 #t (el car\u00e1cter #\\a es una letra min\u00fascula) ( char-upcase #\\\u00f1 ) ; \u21d2 #\\\u00d1 (transforma la letra a may\u00fasculas) ( char-downcase #\\A ) ; \u21d2 #\\a (transforma la letra a min\u00fasculas) ( char->integer #\\space ) ; \u21d2 32 (el car\u00e1cter espacio ocupa la posici\u00f3n ; 32 en la lista de caracteres) ( integer->char 32 ) ; \u21d2 #\\space (igual que antes pero a la inversa) ( char->integer ( integer->char 5000 )) ; \u21d2 5000 Tipos de datos compuestos \u00b6 Scheme tiene tambi\u00e9n un conjunto de tipos de datos compuestos, que permiten aglutinar elementos simples de los tipos de datos vistos anteriormente. Cadenas Parejas Listas Estos dos \u00faltimos los veremos en detalle en futuras clases de teor\u00eda. Cadenas Las cadenas son secuencias finitas de caracteres. 1 2 \"hola\" \"La palabra \\\" hola \\\" tiene 4 letras\" Constructores de cadenas 1 2 3 4 ( make-string 5 #\\o ) ; \u21d2 \"ooooo\" (funci\u00f3n constructora que recibe un ; entero y un car\u00e1cter) ( string #\\h #\\o #\\l #\\a ) ; \u21d2 \"hola\" (funci\u00f3n constructora que recibe ; un n\u00famero variable de caracteres) Operaciones con cadenas 1 2 3 4 5 6 7 8 9 ( substring \"Hola que tal\" 2 4 ) ; \u21d2 \"la\" (subcadena que va de la ; posici\u00f3n 2 a la 4, sin llegar a ella) ( string? \"hola\" ) ; \u21d2 #t (predicado que comprueba que el argumento es ; una cadena) ( string->list \"hola\" ) ; \u21d2 (#\\h #\\o #\\l #\\a) (devuelve una lista de ; caracteres) ( string-length \"hola\" ) ; \u21d2 4 (longitud de la cadena) ( string-ref \"hola\" 0 ) ; \u21d2 #\\h (car\u00e1cter en la posici\u00f3n 0) ( string-append \"hola\" \"adios\" ) ; \u21d2 \"holaadios\" (concatenaci\u00f3n de cadenas) Comparadores de cadenas 1 2 3 4 ( string=? \"Hola\" \"hola\" ) ; \u21d2 #f ( string=? \"hola\" \"hola\" ) ; \u21d2 #t ( string<? \"aab\" \"cde\" ) ; \u21d2 #t (se compara usando el orden lexicogr\u00e1fico) ( string>=? \"www\" \"qqq\" ) ; \u21d2 #t Parejas Elemento fundamental de Scheme. Es un tipo compuesto formado por dos elementos (no necesariamente del mismo tipo). 1 2 3 4 ( cons 1 2 ) ; \u21d2 (1 . 2) (cons crea una pareja) ( cons #t 3 ) ; \u21d2 (#t . 3) (elementos de tipos diferentes) ( car ( cons \"hola\" 2 )) ; \u21d2 \"hola\" (elemento izquierdo de la pareja) ( cdr ( cons \"bye\" 5 )) ; \u21d2 5 (elemento derecho de la pareja) Cuando evaluamos las expresiones anteriores en el int\u00e9rprete, Scheme muestra el resultado de construir la pareja con la sintaxis: 1 (elemento izquierdo . elemento derecho) Por ejemplo: 1 ( cons 1 2 ) ; \u21d2 (1 . 2) La caracter\u00edstica de Scheme de que las expresiones se eval\u00faan de dentro a afuera se aplica a todas las funciones, incluyendo esta funci\u00f3n cons que construye parejas: 1 2 ( cons ( + 2 3 ) ( string-append \"hola\" \"adios\" )) ; \u21d2 (5 . \"holaadios\") ( cons ( = 2 2.0 ) ( * 2 ( + 1 3 ))) ; \u21d2 (#t . 8) Las parejas pueden contener tambi\u00e9n otras parejas. Veremos que esta es la forma de definir estructuras de datos en Scheme: 1 2 3 4 5 ( define p1 ( cons 1 2 )) ; definimos una pareja formada por 1 y 2 ( cons p1 3 ) ; definimos una pareja formada por la pareja (1 . 2) y 3 ; \u21d2 ((1 . 2) . 3) ( cons ( cons 1 2 ) 3 ) ; igual que la expresi\u00f3n anterior ; \u21d2 ((1 . 2) . 3) Hay veces que el trabajo de imprimir una pareja no es tan sencillo para Scheme. Si la pareja est\u00e1 en la parte derecha de la pareja principal el int\u00e9rprete imprime esto, que no se corresponde con lo que esperamos: 1 ( cons 1 ( cons 2 3 )) ; \u21d2 (1 2 . 3) M\u00e1s adelante explicaremos por qu\u00e9. Listas Uno de los elementos fundamentales de Scheme, y de Lisp, son las listas. Es un tipo compuesto formado por un conjunto finito de elementos (no necesariamente del mismo tipo). Vamos a ver c\u00f3mo definir, crear, recorrer y concatenar listas: Podemos crear una lista con la funci\u00f3n list : 1 ( list 1 2 3 4 ) ;list crea una lista Las listas se representan entre par\u00e9ntesis: 1 ( list 1 2 3 4 ) ; \u21d2 (1 2 3 4) La forma m\u00e1s b\u00e1sica de trabajar con una lista es usando las funciones car para obtener su primer elemento y cdr para obtener el resto de la lista. Son las mismas funciones de las parejas, pero ahora se aplican a listas. Tambi\u00e9n veremos m\u00e1s adelante por qu\u00e9 estas funciones pueden trabajar tanto sobre parejas como sobre listas. 1 2 3 4 ( define l1 ( list 1 2 3 4 )) ; se crea la lista (1 2 3 4) y se guarda en l1 ( car l1 ) ; \u21d2 1 (primer elemento de l1) ( cdr l1 ) ; \u21d2 (2 3 4) (resto de la lista, resultado de quitar a la ; lista su primer elemento) Las operaciones sobre listas construyen listas nuevas y no modifican la lista que se pasa como argumento. En el ejemplo anterior, la lista l1 sigue conteniendo la lista original (1 2 3 4) . El cdr de una lista siempre devuelve otra lista. El cdr de una lista de un elemento es la lista vac\u00eda , que en Scheme se representa con () : 1 2 3 4 ( define l2 ( list 1 2 3 )) ( cdr l2 ) ; \u21d2 (2 3) ( cdr ( cdr l2 )) ; \u21d2 (3) ( cdr ( cdr ( cdr l2 ))) ; \u21d2 () lista vac\u00eda Otra forma de definir una lista es usando el quote , una comilla colocada al comienzo de la lista. Veremos en teor\u00eda una explicaci\u00f3n m\u00e1s detallada de c\u00f3mo funciona este quote . Por ejemplo, podemos definir listas usando las las siguientes expresiones: 1 2 3 ' ( 1 2 3 ) ; \u21d2 Construye la lista (1 2 3) ( cdr ' ( 1 2 3 )) ; \u21d2 (2 3) ( define l3 ' ( 1 2 3 )) ; Construye la lista (1 2 3) y la guarda en l3 Durante el seminario usaremos tanto la funci\u00f3n list como el quote para construir listas. La funci\u00f3n list sin argumentos devuelve una lista vac\u00eda y la funci\u00f3n null? comprueba si una lista es vac\u00eda. La lista vac\u00eda tambi\u00e9n se puede definir usando quote : '() . Veremos m\u00e1s adelante que la lista vac\u00eda es el caso base de gran parte de funciones recursivas que recorren listas. 1 2 3 4 ( list ) ; \u21d2 () ( null? ( list )) ; \u21d2 #t ( null? ' ()) ; \u21d2 #t ( null? ( list 1 2 3 )) ; \u21d2 #f Tambi\u00e9n podemos construir una nueva lista a\u00f1adiendo un elemento a la cabeza de una lista existente, usando la funci\u00f3n cons (la misma funci\u00f3n sobre pareja, ya explicaremos tambi\u00e9n por qu\u00e9) usando como par\u00e1metro un elemento y una lista: 1 ( cons elemento lista ) Por ejemplo: 1 2 3 4 5 ( cons 1 ' ( 2 3 4 5 )) ; \u21d2 (1 2 3 4 5) (se a\u00f1ade 1 a la cabeza de ; la lista (2 3 4 5) ( cons 1 ' ()) ; \u21d2 (1) (se a\u00f1ade 1 a la lista vac\u00eda ( cons 1 ( cons 2 ( list ))) ; \u21d2 (1 2) ( cons 1 ( cons 2 ( cons 3 ' ()))) ; \u21d2 (1 2 3) Importante Cuando queramos a\u00f1adir un dato a la cabeza de una lista la lista siempre debe ser el segundo par\u00e1metro de la llamada a la funci\u00f3n. Si nos equivocamos y pasamos la lista como primer par\u00e1metro y el dato a a\u00f1adir como segundo, Scheme no da un error sino que construye una pareja cuyo primer elemento es una lista y su segundo elemento es el dato. Por ejemplo: 1 ( cons ' ( 1 2 3 ) 4 ) ; \u21d2 ((1 2 3) . 4) Tambi\u00e9n podemos usar la funci\u00f3n append para concatenar dos o m\u00e1s listas 1 2 3 4 5 6 ( define l3 ( list 1 )) ( define l4 ( list 2 3 4 )) ( define l5 ( list 5 6 )) ( append l3 l4 l5 ) ; \u21d2 (1 2 3 4 5 6) ( append l3 ' ()) ; \u21d2 (1) ( append ( list 1 2 3 ) ( list 4 )) ; \u21d2 (1 2 3 4) Nota Si queremos a\u00f1adir un dato al final de una lista podemos hacerlo convirti\u00e9ndolo en una lista y usando append para concatenar la lista resultante al final de la primera: 1 2 3 4 5 6 ;;; Definimos la funci\u00f3n cons-al-final ( define ( a\u00f1ade-al-final x lista ) ( append lista ( list x ))) ;;; La probamos ( a\u00f1ade-al-final 10 ( list 1 2 3 )) ; \u21d2 (1 2 3 10) Igual que las parejas, las listas pueden contener distintos tipos de datos: 1 2 3 ( list \"hola\" \"que\" \"tal\" ) ; \u21d2 (\"hola\" \"que\" \"tal\") (lista de cadenas) ( cons \"hola\" ( list #t #\\a 3 4 )) ; \u21d2 (\"hola\" #t #\\a 3 4) lista de distintos ; tipos de datos) Una lista puede incluso contener otras listas: 1 2 3 4 5 ( list ( list 1 2 ) 3 4 ( list 5 6 )) ; \u21d2 ((1 2) 3 4 (5 6)) (lista que contiene listas) ' (( 1 2 ) 3 4 ( 5 6 )) ; \u21d2 La misma lista, definida con quote ( cons ( list 1 2 ) ( list 3 4 5 )) ; \u21d2 ((1 2) 3 4 5)) (se a\u00f1ade una ; lista como primer elemento) ( cons ' ( 1 2 ) ' ( 3 4 5 )) ; \u21d2 La misma expresi\u00f3n anterior, con quote La caracter\u00edstica de Scheme de que las expresiones se eval\u00faan de dentro a afuera se aplica a todas las funciones, incluyendo est\u00e1 funci\u00f3n list que construye listas: 1 2 ( list ( + 1 2 ) ( string-append \"hola\" \"adios\" ) ( * 2 3 )) ; \u21d2 (3 \"holaadios\" 6) ( list ( cons 1 2 ) ( cons 3 4 )) ; \u21d2 ((1 . 2) (3 . 4)) (lista que contiene parejas) En clase de teor\u00eda estudiaremos con m\u00e1s profundidad las listas en Scheme, c\u00f3mo est\u00e1n implementadas y c\u00f3mo se utilizan para crear otras estructuras de datos m\u00e1s complejas como \u00e1rboles. Para este seminario de introducci\u00f3n es suficiente con estas funciones b\u00e1sicas que nos permiten crear, combinar y obtener elementos de listas. Estructuras de control \u00b6 Como en cualquier lenguaje de programaci\u00f3n, las estructuras de control en Scheme nos permiten seleccionar qu\u00e9 parte de una expresi\u00f3n evaluamos en funci\u00f3n de la evaluaci\u00f3n de una expresi\u00f3n condicional. Las estructuras de control las veremos con m\u00e1s detenimiento en las clases de teor\u00eda, ahora por el momento vamos a ver ejemplos de funcionamiento. En Scheme tenemos dos tipos de estructuras de control: if y cond . if \u00b6 Realiza una evaluaci\u00f3n condicional de las expresiones que la siguen, seg\u00fan el resultado de una condici\u00f3n. Una expresi\u00f3n if tiene siempre cuatro elementos: el propio if , la condici\u00f3n, la expresi\u00f3n que se eval\u00faa si la condici\u00f3n es verdadera y la expresi\u00f3n que se eval\u00faa si la expresi\u00f3n es falsa: 1 ( if ( > 2 3 ) \"2 es mayor que 3\" \"2 es menor o igual que 3\" ) Al escribir c\u00f3digo en Scheme es habitual colocar el if y la condici\u00f3n en una l\u00ednea y las otras dos expresiones en las siguientes l\u00edneas: 1 2 3 ( if ( > 2 3 ) \"2 es mayor que 3\" \"2 es menor o igual que 3\" ) En las expresiones que devuelven el valor cuando la condici\u00f3n es cierta o falsa se puede escribir cualquier expresi\u00f3n de Scheme, incluido otro if : 1 2 3 4 5 ( if ( > 2 3 ) ( if ( < 10 5 ) \"2 es mayor que 3 y 10 es menor que 5\" \"2 es mayor que 3 y 10 es mayor o igual que 5\" ) \"2 es menor o igual que 3\" ) Un ejemplo en el que vemos una funci\u00f3n que contiene un if . La siguiente funci\u00f3n de tres argumentos devuelve la suma de los \u00faltimos si el primero es positivo o la resta en caso contrario: 1 2 3 4 5 6 7 ( define ( suma-si-x-positivo x y z ) ( if ( >= x 0 ) ( + y z ) ( - y z ))) ( suma-si-x-positivo 2 3 5 ) ; \u21d2 8 ( suma-si-x-positivo -3 3 5 ) ; \u21d2 -2 cond \u00b6 Cuando tenemos un conjunto de alternativas o para evitar usar ifs anidados. cond eval\u00faa una serie de condiciones y devuelve el valor de la expresi\u00f3n asociada a la primera condici\u00f3n verdadera. 1 2 3 4 5 ( cond (( > 3 4 ) \"3 es mayor que 4\" ) (( < 2 1 ) \"2 es menor que 1\" ) (( > 3 2 ) \"3 es mayor que 2\" ) ( else \"ninguna condicion es cierta\" )) Comentarios \u00b6 Para comentar una l\u00ednea de c\u00f3digo en la ventana de definiciones, se escribe el s\u00edmbolo punto y coma ; al comienzo de la l\u00ednea. Si queremos comentar m\u00e1s de una l\u00ednea, podemos utilizar el men\u00fa de DrRacket: seleccionamos las l\u00edneas a comentar y pinchamos en la opci\u00f3n Racket -> comentar con punto y coma. Ejemplos completos \u00b6 Ra\u00edz de segundo grado \u00b6 Vamos a resolver la ecuaci\u00f3n de segundo grado en Scheme. Vamos a implementar el procedimiento (ecuacion a b c) que devuelva una pareja con las dos ra\u00edces de la soluci\u00f3n. Nos vamos a ayudar de funciones auxiliares. Recordamos la f\u00f3rmula: x = {-b \\pm \\sqrt{b^2-4ac} \\over 2a} x = {-b \\pm \\sqrt{b^2-4ac} \\over 2a} Nota En lugar de definir una funci\u00f3n con una expresi\u00f3n muy larga compuesta de muchas expresiones anidadas, vamos a implementar la soluci\u00f3n de forma modular, definiendo funciones auxiliares . Primer definimos la funci\u00f3n que define el discriminante: 1 2 ( define ( discriminante a b c ) ( - ( * b b ) ( * 4 a c ))) Despu\u00e9s definimos las funciones que devuelven la ra\u00edz positiva y la ra\u00edz negativa, usando la funci\u00f3n discriminante anterior: 1 2 3 4 5 ( define ( raiz-pos a b c ) ( / ( + ( * b -1 ) ( sqrt ( discriminante a b c ))) ( * 2 a ))) ( define ( raiz-neg a b c ) ( / ( - ( * b -1 ) ( sqrt ( discriminante a b c ))) ( * 2 a ))) Por \u00faltimo, definimos la funci\u00f3n ecuacion que invoca a las funciones anteriores y devuelve una pareja con los valores resultantes: 1 2 ( define ( ecuacion a b c ) ( cons ( raiz-pos a b c ) ( raiz-neg a b c ))) Lo probamos: 1 2 3 4 5 6 ( ecuacion 1 -5 6 ) ; \u21d2 (3 . 2) ( ecuacion 2 -7 3 ) ; \u21d2 (3 . 1/2) ( ecuacion -1 7 -10 ) ; \u21d2 (2 . 5) Conversi\u00f3n de grados Celsius a Farenheit \u00b6 Vamos a definir una funci\u00f3n llamada convertir-temperatura que permite realizar una conversi\u00f3n de grados Fahrenheit a Cent\u00edgrados o vicerversa. La funci\u00f3n toma dos argumentos, el primero ser\u00e1 un n\u00famero que representa los grados y el segundo ser\u00e1 un car\u00e1cter ( F o C ) que indica la unidad de medida en la que est\u00e1n expresados los grados. Las f\u00f3rmulas de conversi\u00f3n son las siguientes: C = (F - 32) * 5/9 C = (F - 32) * 5/9 F = (C * 9/5) + 32 F = (C * 9/5) + 32 Primero definimos unas funciones auxiliares que calculan las expresiones anteriores: 1 2 3 4 5 ( define ( a-grados-fahrenheit grados-centigrados ) ( + ( * ( / 9 5 ) grados-centigrados ) 32 )) ( define ( a-grados-centigrados grados-fahrenheit ) ( * ( / 5 9 ) ( - grados-fahrenheit 32 ))) Y ahora ya podemos definir la funci\u00f3n principal: 1 2 3 4 5 6 ( define ( convertir-temperatura grados tipo ) ( cond (( equal? tipo #\\F ) ( list ( a-grados-centigrados grados ) \"grados centigrados\" )) (( equal? tipo #\\C ) ( list ( a-grados-fahrenheit grados ) \"grados fahrenheit\" )) ( else \"tipo de cambio incorrecto\" ))) Por ejemplo: 1 2 ( convertir-temperatura 50 #\\F ) ; \u21d2 (10 \"grados centigrados\") ( convertir-temperatura 50 #\\C ) ; \u21d2 (122 \"grados fahrenheit\") Pruebas unitarias en Scheme \u00b6 Para verificar que las funciones que definimos tienen un funcionamiento correcto, es decir, \"hacen lo que tienen que hacer\" , podemos dise\u00f1ar distintos casos de prueba. Cada caso de prueba se caracteriza por unos datos de entrada de la funci\u00f3n y por el resultado que esperamos que devuelva dicha funci\u00f3n con esos valores de entrada. Por ejemplo, en las pruebas de la funci\u00f3n convertir-temperatura , hemos dise\u00f1ado dos casos de prueba: Datos de Entrada Resultado Esperado 50 , #\\F (10 \"grados centigrados\") 50 , #\\C (122 \"grados fahrenheit\") El resultado esperado a partir de unos valores concretos de entrada, se determina entendiendo qu\u00e9 debe hacer la funci\u00f3n. Es decir, se obtiene a partir de la especificaci\u00f3n del problema, antes de plantearnos c\u00f3mo solucionarlo. Os aconsejamos tener siempre presente la siguiente idea aunque resulte obvia: Para implementar una funci\u00f3n, primero es imprescindible entender qu\u00e9 debe hacer la funci\u00f3n . Despu\u00e9s, seremos capaces de dise\u00f1ar casos de prueba y ocuparnos de c\u00f3mo implementarla . En las pr\u00e1cticas de la asignatura, para realizar pruebas usaremos la librer\u00eda RackUnit . Para ello, lo primero que tendremos que hacer es importar esta nueva librer\u00eda. Por tanto, debemos a\u00f1adir en nuestros ficheros de pr\u00e1cticas lo siguiente: 1 2 #lang racket ( require rackunit ) Una vez importada la librer\u00eda, ya podemos hacer uso de algunas de sus funciones. En concreto, utilizaremos las siguientes: check-true 1 2 3 ( check-true expr ) ;; Comprueba si su argumento es #t. ;; En caso contrario, se imprime un mensaje de error. check-false 1 2 3 ( check-false expr ) ;; Comprueba si su argumento es #f. ;; En caso contrario, se imprime un mensaje de error. check-equal? 1 2 3 ( check-equal? resultado-real resultado-esperado ) ;; Comprueba si sus dos argumentos son iguales. ;; En caso contrario, se imprime un mensaje de error. Con las funciones check-true y check-false validaremos predicados (recuerda que en Scheme son funciones que devuelven un valor booleano) que hayamos implementado, comprobando si el resultado esperado es true o false , respectivamente. Con la funci\u00f3n check-equal? podremos validar si el resultado de la invocaci\u00f3n a la funci\u00f3n con unos determinados valores de entrada, representado por el argumento resultado-real , es igual al resultado que esperamos, dado por el argumento resultado-esperado . Ejemplo de pruebas de la funci\u00f3n ecuacion definida anteriormente \u00b6 Las siguientes pruebas no mostrar\u00e1n ning\u00fan mensaje de error, lo que significa que nuestra funci\u00f3n ecuacion es 'CORRECTA' para estas pruebas, es decir, que con los valores de entrada utilizados, su resultado se corresponde con el esperado. 1 2 3 ( check-equal? ( ecuacion 1 -5 6 ) ( cons 3 2 )) ( check-equal? ( ecuacion 2 -7 3 ) ( cons 3 ( / 1 2 ))) ( check-equal? ( ecuacion -1 7 -10 ) ( cons 2 5 )) Ahora vamos a suponer que nos hemos equivocado en la definici\u00f3n de la funci\u00f3n ecuacion , por ejemplo en el orden de los argumentos al invocar a la funci\u00f3n auxiliar raiz-pos , en la llamada que se hace en la parte izquierda de la pareja resultante. 1 2 ( define ( ecuacion a b c ) ( cons ( raiz-pos b a c ) ( raiz-neg a b c ))) Con esta nueva definici\u00f3n, si ejecutamos la siguiente prueba: 1 ( check-equal? ( ecuacion 1 -5 6 ) ( cons 3 2 )) el resultado ser\u00e1: 1 2 3 4 5 6 7 8 -------------------- FAILURE actual: (-1 . 2) expected: (3 . 2) name: check-equal? location: (#<path:/.../filename.rkt>) expression: (check-equal? (ecuacion 1 -5 6) (cons 3 2)) -------------------- Esta prueba muestra un mensaje de error, lo que significa que la nueva definici\u00f3n de ecuacion 'FALLA', es decir, que el resultado que devuelve (-1 . 2) no coincide con el resultado esperado (3 . 2) . Ejercicios \u00b6 Ejercicio 1 \u00b6 Lanza DrRacket y escribe cada una de las siguientes instrucciones en el int\u00e9rprete, intentado adivinar el resultado que va devolver. Est\u00e1n ordenadas por dificultad de arriba abajo y de izquierda a derecha. \u00a1\u00a1Piensa en los resultados!!. Intenta entender c\u00f3mo interpreta Scheme lo que escribes. Instrucci\u00f3n Instrucci\u00f3n 3 (+ (- 4 (* 3 (/ 4 2) 4)) 3) (+ 1 2 ) (* (+ (+ 2 3) 4) (* (* 3 3) 2)) (+ 1 2 3 4) (* (+ 2 3 4 5) 3 (- 5 2 1)) (+) (+ (- (+ (- (+ 2 3) 5) 1) 2) 3) (sqrt 25) (- (sqrt (* 5 ( + 3 2))) (+ 1 1 1 1)) (* (+ 2 3) 5) (> (* 3 (+ 2 (+ 3 1)) (+ 1 1)) (+ (* 2 2) 3)) + (= (* 3 2) (+ 1 (+ 2 2) 1)) #\\+ (not (> (+ 3 2) 5)) \"+\" (and (even? 2) (odd? (+ 3 2))) \"hola\" (remainder (+ 6 2) (+ 1 1)) Ejercicio 2 \u00b6 Predice lo que devolver\u00e1 Scheme cuando escribas las siguientes expresiones. Est\u00e1n ordenadas por dificultad de arriba abajo y de izquierda a derecha. Despu\u00e9s, pru\u00e9balas y comprueba si tu predicci\u00f3n era correcta. Si no lo era, intenta comprender por qu\u00e9. Instrucci\u00f3n Instrucci\u00f3n (equal? \"hola\" \"hola\") (+ (char->integer(integer->char 1200)) (char->integer #\\A)) (string-ref \"pepe\" 1) (string-length (make-string 7 #\\E)) (substring \"buenos dias\" 1 4) (define a 3) (define b (+ a 1)) (= \"hola\" \"hola\") (+ a b (* a b)) (string-ref (substring \"buenos dias\" 2 5) 1) (= a b) (define pi 3.14159) (if (and (> a b) (< b (* a b))) b a) pi (cond ((= a 4) 6) ((= b 4) (+ 6 7 a)) (else 25)) \"pi\" (+ 2 (if (> b a) b a)) (+ pi (+ pi pi)) (* (cond ((> a b) a) ((< a b) b) (else -1)) (+ a 1)) (+ (* pi pi) (- 2 pi pi pi pi)) ((if (< a b) + -) a b) Ejercicio 3 \u00b6 Ejercicios con parejas. Predice lo que hace Scheme cuando escribas las siguientes expresiones. Est\u00e1n ordenadas por dificultad de arriba abajo y de izquierda a derecha. Despu\u00e9s, pru\u00e9balas y comprueba si tu predicci\u00f3n era correcta. Si no lo era, intenta comprender por qu\u00e9. Instrucci\u00f3n Instrucci\u00f3n (cons 1 2) (car (car (cons (cons 1 2) 3))) (car (cons 1 2)) (car (cons (cons 3 4) 2)) (cdr (cons 1 2)) (cdr (cons (cons 3 4) 2)) (cons (* 2 3) (/ 4 2)) (cdr (cons 1 (cons 2 3))) (cons (+ 2 1) (if (> 2 3) \"2\" \"3\")) (cdr (car (cons (cons 1 2) 3))) Ejercicio 4 \u00b6 Ejercicios con listas. Predice lo que hace Scheme cuando escribas las siguientes expresiones. Despu\u00e9s, pru\u00e9balas y comprueba si tu predicci\u00f3n era correcta. Si no lo era, intenta comprender por qu\u00e9. Instrucci\u00f3n Instrucci\u00f3n (list 1 2 3 4) (cons 3 '(1 2 3)) (cdr (list 1 2 3 4)) (cdr (cons #t (cons \"Hola\" (list 1)))) (car '(1 2 3 4)) (car (list (list 1 2) 1 2 3 4)) (car (list #t 1 \"Hola\")) (car (cdr '((1 2) 1 2))) (car (cdr (list 1 2 3 4))) (cons '(1 2 3) '(4 5 6)) (cdr (cdr '(1 2 3 4))) (car (cdr (list 1 2 3 4))) (car (cdr (cdr (list 1 2 3 4)))) (cdr (cdr (list 1 2 3 4))) (list (* 2 2) (+ 1 2) (/ 4 2)) (car (cdr (cdr (cdr '(1 2 3 4))))) (list (+ 2 3) (- 3 4) (string-ref \"hola\" 3)) Ejercicio 5 \u00b6 Los siguientes apartados intenta hacerlos sin utilizar el int\u00e9rprete de Scheme. a) Dada la siguiente lista, indica la expresi\u00f3n correcta para que Scheme devuelva 5: 1 ( list 1 2 3 4 5 6 7 8 ) b) Dada la siguiente lista, indica la expresi\u00f3n correcta para que Scheme devuelva (8). 1 ( list 1 2 3 4 5 6 7 8 ) c) Dada la siguiente lista, indica la expresi\u00f3n correcta para que Scheme devuelva 8. 1 ( list 1 2 3 4 5 6 7 8 ) d) Dada la siguiente expresi\u00f3n, \u00bfqu\u00e9 devuelve Scheme? 1 ( car ( cdr ( cdr ( list 1 ( list 2 3 ) ( list 4 5 ) 6 )))) e) Dada la siguiente expresi\u00f3n, \u00bfqu\u00e9 devuelve Scheme? 1 ( cdr ( cdr ' ( 1 ( 2 3 ) 4 5 ))) Lenguajes y Paradigmas de Programaci\u00f3n, curso 2019-20 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Domingo Gallardo, Cristina Pomares, Antonio Bot\u00eda, Francisco Mart\u00ednez","title":"Seminario de Scheme"},{"location":"seminarios/seminario1-scheme/seminario1-scheme.html#seminario-1-seminario-de-scheme","text":"","title":"Seminario 1: Seminario de Scheme"},{"location":"seminarios/seminario1-scheme/seminario1-scheme.html#bibliografia","text":"Este seminario est\u00e1 basado en los siguientes materiales. Os recomendamos que les ech\u00e9is un vistazo y, si os interesa y os queda tiempo, que explor\u00e9is tambi\u00e9n en los enlaces que hemos dejado en los apuntes para ampliar informaci\u00f3n. The Racket Guide The Racket Reference Simply Scheme","title":"Bibliograf\u00eda"},{"location":"seminarios/seminario1-scheme/seminario1-scheme.html#el-lenguaje-de-programacion-scheme","text":"Scheme es un lenguaje de programaci\u00f3n que surgi\u00f3 en los laboratorios del MIT en 1975, cuando Guy L. Steele y Gerarld J. Sussman buscaban un lenguaje con una sem\u00e1ntica muy clara y sencilla. Scheme es un dialecto de Lisp, es un lenguaje interpretado, muy expresivo y soporta varios paradigmas. Estuvo influenciado por el c\u00e1lculo lambda. El desarrollo de Scheme ha sido lento, ya que la gente que estandariz\u00f3 Scheme es muy conservadora en cuanto a a\u00f1adirle nuevas caracter\u00edsticas,porque la calidad ha sido siempre m\u00e1s importante que la utilidad empresarial. Por eso Scheme es considerado como uno de los lenguajes mejor dise\u00f1ados de prop\u00f3sito general. Aprender Scheme har\u00e1 que se\u00e1is mejores programadores cuando utilic\u00e9is otros lenguajes de programaci\u00f3n.","title":"El lenguaje de programaci\u00f3n Scheme"},{"location":"seminarios/seminario1-scheme/seminario1-scheme.html#el-lenguaje-de-programacion-racket","text":"\u00bfQu\u00e9 vamos a aprender? \u00bfRacket o Scheme? La respuesta es: Scheme trabajando en Racket. Racket se dise\u00f1\u00f3 en 1995 bas\u00e1ndose en Scheme y ampli\u00e1ndolo con nuevas funcionalidades, como la posibilidad de extenderlo con librer\u00edas. El lenguaje contiene librer\u00edas muy \u00fatiles (librer\u00edas gr\u00e1ficas, de conexi\u00f3n a servidores HTTP, de conexi\u00f3n a bases de datos, etc.) con las que se moderniza el lenguaje original y se convierte en un lenguaje pr\u00e1ctico para desarrollar todo tipo de aplicaciones, desde videojuegos a servidores web. Sin embargo, nosotros s\u00f3lo vamos a usar Racket para aprender la parte que corresponde al n\u00facleo original de Scheme.","title":"El lenguaje de programaci\u00f3n Racket"},{"location":"seminarios/seminario1-scheme/seminario1-scheme.html#el-entorno-de-programacion-drracket","text":"Veamos una peque\u00f1a introducci\u00f3n al entorno de programaci\u00f3n que proporciona DrRacket. Puedes encontrar m\u00e1s informaci\u00f3n en la documentaci\u00f3n original .","title":"El entorno de programaci\u00f3n DrRacket"},{"location":"seminarios/seminario1-scheme/seminario1-scheme.html#el-lenguaje-scheme","text":"","title":"El lenguaje Scheme"},{"location":"seminarios/seminario1-scheme/seminario1-scheme.html#vamos-a-empezar-probando-algunos-ejemplos","text":"Scheme es un lenguaje interpretado. Vamos a lanzar DrRacket y teclear en la ventana de interacci\u00f3n algunas expresiones. El int\u00e9rprete analizar\u00e1 la expresi\u00f3n y mostrar\u00e1 el valor resultante de evaluarla. 1 2 3 4 5 2 ; \u21d2 2 ( + 2 3 ) ; \u21d2 5 ( + ) ; \u21d2 0 ( + 2 4 5 6 ) ; \u21d2 17 ( + ( * 2 3 ) ( - 3 1 )) ; \u21d2 8 Las expresiones en Scheme tienen una forma denominada notaci\u00f3n prefija de Cambridge (el nombre de Cambridge es por la localidad Cambridge, Massachusets, donde reside el MIT, lugar en el que se ide\u00f3 el Lisp), en la que la expresi\u00f3n est\u00e1 delimitada por par\u00e9ntesis y el operador va seguido de los operandos. La sintaxis es la siguiente: 1 ( <funci\u00f3n> <arg1> ... <argn> ) En Scheme podemos interpretar los par\u00e9ntesis abiertos \u2018(\u2019 como evaluadores o lanzadores de la funci\u00f3n que hay a continuaci\u00f3n. La forma que tiene Scheme de evaluar una expresi\u00f3n es muy sencilla: Eval\u00faa cada uno de los argumentos Aplica la funci\u00f3n nombrada tras el par\u00e9ntesis a los valores resultantes de la evaluaci\u00f3n anterior 1 2 3 4 5 (+ (* 2 3) (- 3 (/ 12 3))) \u21d2 (+ 6 (- 3 (/ 12 3))) \u21d2 (+ 6 (- 3 4)) \u21d2 (+ 6 -1) \u21d2 5 En Scheme los t\u00e9rminos funci\u00f3n y procedimiento significan lo mismo y se usan de forma intercambiable. Son ejemplos de funciones o procedimientos: +, -, *. En Scheme la evaluaci\u00f3n de una funci\u00f3n siempre devuelve un valor, a no ser que se produzca un error que detiene la evaluaci\u00f3n: 1 2 ( * ( + 3 4 ) ( / 3 0 )) ; Error /: division by zero","title":"Vamos a empezar probando algunos ejemplos"},{"location":"seminarios/seminario1-scheme/seminario1-scheme.html#definiendo-variables-y-funciones","text":"Scheme es un lenguaje multiparadigma pero principalmente funcional, y una de sus caracter\u00edsticas principales es que los programas se construyen mediante la definici\u00f3n de funciones. Podemos utilizar en el int\u00e9rprete la forma especial define para definir variables y funciones. En clase de teor\u00eda veremos c\u00f3mo es el funcionamiento del define , pero por el momento lo utilizaremos para definir variables asociadas a valores, y para implementar funciones. Podemos definir variables en la ventana de interacci\u00f3n para facilitar la escritura de expresiones: 1 2 3 4 5 ( define pi 3.14159 ) pi ; \u21d2 3.14159 ( sin ( / pi 2 )) ; \u21d2 0.9999999999991198 ( define a ( + 2 ( * 3 4 ))) a ; \u21d2 14 Para implementar una funci\u00f3n tambi\u00e9n se utiliza define, con la siguiente sintaxis: 1 2 3 ( define ( <nombre-funcion> <args> ) <cuerpo-funcion> ) Por ejemplo, vamos a implementar una funci\u00f3n que toma dos n\u00fameros como par\u00e1metros y devuelve la suma de sus cuadrados: 1 2 ( define ( suma-cuadrados x y ) ( + ( * x x ) ( * y y ))) Si llamamos a la funci\u00f3n pasando el 2 y el 3 como par\u00e1metros, la funci\u00f3n devuelve el n\u00famero 13: 1 ( suma-cuadrados 2 3 ) ; \u21d2 13 Nota A diferencia de la mayor\u00eda de lenguajes de programaci\u00f3n, en Scheme no se utiliza la palabra return para indicar que una funci\u00f3n devuelve un valor. Las funciones se definen con una \u00fanica expresi\u00f3n y el resultado calculado en esa expresi\u00f3n es el que siempre se devuelve.","title":"Definiendo variables y funciones"},{"location":"seminarios/seminario1-scheme/seminario1-scheme.html#lenguaje-debilmente-tipado","text":"Vamos a comprobar una caracter\u00edstica muy importante de Scheme: ser un lenguaje d\u00e9bilmente tipado . Por esto entendemos, entre otras cosas, que las variables, funciones y argumentos no tienen un tipo declarado. Es posible usar valores de distintos tipos de datos para asignar sucesivamente a una misma variable (en el caso de un lenguaje imperativo) o para pasar como par\u00e1metro a una misma funci\u00f3n (en el caso de un lenguaje funcional). Por ejemplo, JavaScript o PHP son tambi\u00e9n lenguajes d\u00e9bilmente tipados imperativos. Veamos c\u00f3mo funciona esto en Scheme usando la funci\u00f3n anterior como ejemplo. 1 2 ( define ( suma-cuadrados x y ) ( + ( * x x ) ( * y y ))) Vemos que los argumentos x e y no tienen ning\u00fan tipo. Si se invoca a la funci\u00f3n pasando alg\u00fan dato que no sea un n\u00famero, el int\u00e9rprete no detectar\u00e1 ning\u00fan error y permitir\u00e1 asignar a los argumentos x e y esos datos. El error se produce en el momento en que se intenta evaluar la multiplicaci\u00f3n. Lo podemos comprobar con el siguiente ejemplo, en el que se muestra el mensaje de error resultante: 1 2 3 4 5 6 > ( suma-cuadrados 10 \"hola\" ) *: contract violation expected: number? given: \"hola\" argument position: 1st other arguments...: Veremos m\u00e1s adelante que hay distintos tipos de n\u00fameros que podemos operar usando la divisi\u00f3n, la suma y la multiplicaci\u00f3n. La funci\u00f3n definida va a funcionar bien para todos ello. Podemos pasar a la funci\u00f3n n\u00fameros enteros, n\u00fameros reales o incluso fracciones: 1 2 3 ( suma-cuadrados 2 5 ) ; \u21d2 29 ( suma-cuadrados 2.4 5.8 ) ; \u21d2 39.4 ( suma-cuadrados ( / 2 3 ) ( / 3 5 )) ; \u21d2 181/225 En la \u00faltima expresi\u00f3n tambi\u00e9n pueden pasarse directamente los n\u00fameros fracionales, el int\u00e9rprete de Scheme entiende esa notaci\u00f3n: 1 ( suma-cuadrados 2/3 3/5 ) ; \u21d2 181/225","title":"Lenguaje d\u00e9bilmente tipado"},{"location":"seminarios/seminario1-scheme/seminario1-scheme.html#tipos-de-datos-simples","text":"Las primitivas de Scheme consisten en un conjunto de tipos de datos, formas especiales y funciones incluidas en el lenguaje. A lo largo del curso iremos introduciendo estas primitivas. Vamos a revisar algunos tipos de datos simples de Scheme, as\u00ed como algunas funciones primitivas para trabajar con valores de esos tipos. Booleanos N\u00fameros Caracteres","title":"Tipos de datos simples"},{"location":"seminarios/seminario1-scheme/seminario1-scheme.html#tipos-de-datos-compuestos","text":"Scheme tiene tambi\u00e9n un conjunto de tipos de datos compuestos, que permiten aglutinar elementos simples de los tipos de datos vistos anteriormente. Cadenas Parejas Listas Estos dos \u00faltimos los veremos en detalle en futuras clases de teor\u00eda.","title":"Tipos de datos compuestos"},{"location":"seminarios/seminario1-scheme/seminario1-scheme.html#estructuras-de-control","text":"Como en cualquier lenguaje de programaci\u00f3n, las estructuras de control en Scheme nos permiten seleccionar qu\u00e9 parte de una expresi\u00f3n evaluamos en funci\u00f3n de la evaluaci\u00f3n de una expresi\u00f3n condicional. Las estructuras de control las veremos con m\u00e1s detenimiento en las clases de teor\u00eda, ahora por el momento vamos a ver ejemplos de funcionamiento. En Scheme tenemos dos tipos de estructuras de control: if y cond .","title":"Estructuras de control"},{"location":"seminarios/seminario1-scheme/seminario1-scheme.html#if","text":"Realiza una evaluaci\u00f3n condicional de las expresiones que la siguen, seg\u00fan el resultado de una condici\u00f3n. Una expresi\u00f3n if tiene siempre cuatro elementos: el propio if , la condici\u00f3n, la expresi\u00f3n que se eval\u00faa si la condici\u00f3n es verdadera y la expresi\u00f3n que se eval\u00faa si la expresi\u00f3n es falsa: 1 ( if ( > 2 3 ) \"2 es mayor que 3\" \"2 es menor o igual que 3\" ) Al escribir c\u00f3digo en Scheme es habitual colocar el if y la condici\u00f3n en una l\u00ednea y las otras dos expresiones en las siguientes l\u00edneas: 1 2 3 ( if ( > 2 3 ) \"2 es mayor que 3\" \"2 es menor o igual que 3\" ) En las expresiones que devuelven el valor cuando la condici\u00f3n es cierta o falsa se puede escribir cualquier expresi\u00f3n de Scheme, incluido otro if : 1 2 3 4 5 ( if ( > 2 3 ) ( if ( < 10 5 ) \"2 es mayor que 3 y 10 es menor que 5\" \"2 es mayor que 3 y 10 es mayor o igual que 5\" ) \"2 es menor o igual que 3\" ) Un ejemplo en el que vemos una funci\u00f3n que contiene un if . La siguiente funci\u00f3n de tres argumentos devuelve la suma de los \u00faltimos si el primero es positivo o la resta en caso contrario: 1 2 3 4 5 6 7 ( define ( suma-si-x-positivo x y z ) ( if ( >= x 0 ) ( + y z ) ( - y z ))) ( suma-si-x-positivo 2 3 5 ) ; \u21d2 8 ( suma-si-x-positivo -3 3 5 ) ; \u21d2 -2","title":"if"},{"location":"seminarios/seminario1-scheme/seminario1-scheme.html#cond","text":"Cuando tenemos un conjunto de alternativas o para evitar usar ifs anidados. cond eval\u00faa una serie de condiciones y devuelve el valor de la expresi\u00f3n asociada a la primera condici\u00f3n verdadera. 1 2 3 4 5 ( cond (( > 3 4 ) \"3 es mayor que 4\" ) (( < 2 1 ) \"2 es menor que 1\" ) (( > 3 2 ) \"3 es mayor que 2\" ) ( else \"ninguna condicion es cierta\" ))","title":"cond"},{"location":"seminarios/seminario1-scheme/seminario1-scheme.html#comentarios","text":"Para comentar una l\u00ednea de c\u00f3digo en la ventana de definiciones, se escribe el s\u00edmbolo punto y coma ; al comienzo de la l\u00ednea. Si queremos comentar m\u00e1s de una l\u00ednea, podemos utilizar el men\u00fa de DrRacket: seleccionamos las l\u00edneas a comentar y pinchamos en la opci\u00f3n Racket -> comentar con punto y coma.","title":"Comentarios"},{"location":"seminarios/seminario1-scheme/seminario1-scheme.html#ejemplos-completos","text":"","title":"Ejemplos completos"},{"location":"seminarios/seminario1-scheme/seminario1-scheme.html#raiz-de-segundo-grado","text":"Vamos a resolver la ecuaci\u00f3n de segundo grado en Scheme. Vamos a implementar el procedimiento (ecuacion a b c) que devuelva una pareja con las dos ra\u00edces de la soluci\u00f3n. Nos vamos a ayudar de funciones auxiliares. Recordamos la f\u00f3rmula: x = {-b \\pm \\sqrt{b^2-4ac} \\over 2a} x = {-b \\pm \\sqrt{b^2-4ac} \\over 2a} Nota En lugar de definir una funci\u00f3n con una expresi\u00f3n muy larga compuesta de muchas expresiones anidadas, vamos a implementar la soluci\u00f3n de forma modular, definiendo funciones auxiliares . Primer definimos la funci\u00f3n que define el discriminante: 1 2 ( define ( discriminante a b c ) ( - ( * b b ) ( * 4 a c ))) Despu\u00e9s definimos las funciones que devuelven la ra\u00edz positiva y la ra\u00edz negativa, usando la funci\u00f3n discriminante anterior: 1 2 3 4 5 ( define ( raiz-pos a b c ) ( / ( + ( * b -1 ) ( sqrt ( discriminante a b c ))) ( * 2 a ))) ( define ( raiz-neg a b c ) ( / ( - ( * b -1 ) ( sqrt ( discriminante a b c ))) ( * 2 a ))) Por \u00faltimo, definimos la funci\u00f3n ecuacion que invoca a las funciones anteriores y devuelve una pareja con los valores resultantes: 1 2 ( define ( ecuacion a b c ) ( cons ( raiz-pos a b c ) ( raiz-neg a b c ))) Lo probamos: 1 2 3 4 5 6 ( ecuacion 1 -5 6 ) ; \u21d2 (3 . 2) ( ecuacion 2 -7 3 ) ; \u21d2 (3 . 1/2) ( ecuacion -1 7 -10 ) ; \u21d2 (2 . 5)","title":"Ra\u00edz de segundo grado"},{"location":"seminarios/seminario1-scheme/seminario1-scheme.html#conversion-de-grados-celsius-a-farenheit","text":"Vamos a definir una funci\u00f3n llamada convertir-temperatura que permite realizar una conversi\u00f3n de grados Fahrenheit a Cent\u00edgrados o vicerversa. La funci\u00f3n toma dos argumentos, el primero ser\u00e1 un n\u00famero que representa los grados y el segundo ser\u00e1 un car\u00e1cter ( F o C ) que indica la unidad de medida en la que est\u00e1n expresados los grados. Las f\u00f3rmulas de conversi\u00f3n son las siguientes: C = (F - 32) * 5/9 C = (F - 32) * 5/9 F = (C * 9/5) + 32 F = (C * 9/5) + 32 Primero definimos unas funciones auxiliares que calculan las expresiones anteriores: 1 2 3 4 5 ( define ( a-grados-fahrenheit grados-centigrados ) ( + ( * ( / 9 5 ) grados-centigrados ) 32 )) ( define ( a-grados-centigrados grados-fahrenheit ) ( * ( / 5 9 ) ( - grados-fahrenheit 32 ))) Y ahora ya podemos definir la funci\u00f3n principal: 1 2 3 4 5 6 ( define ( convertir-temperatura grados tipo ) ( cond (( equal? tipo #\\F ) ( list ( a-grados-centigrados grados ) \"grados centigrados\" )) (( equal? tipo #\\C ) ( list ( a-grados-fahrenheit grados ) \"grados fahrenheit\" )) ( else \"tipo de cambio incorrecto\" ))) Por ejemplo: 1 2 ( convertir-temperatura 50 #\\F ) ; \u21d2 (10 \"grados centigrados\") ( convertir-temperatura 50 #\\C ) ; \u21d2 (122 \"grados fahrenheit\")","title":"Conversi\u00f3n de grados Celsius a Farenheit"},{"location":"seminarios/seminario1-scheme/seminario1-scheme.html#pruebas-unitarias-en-scheme","text":"Para verificar que las funciones que definimos tienen un funcionamiento correcto, es decir, \"hacen lo que tienen que hacer\" , podemos dise\u00f1ar distintos casos de prueba. Cada caso de prueba se caracteriza por unos datos de entrada de la funci\u00f3n y por el resultado que esperamos que devuelva dicha funci\u00f3n con esos valores de entrada. Por ejemplo, en las pruebas de la funci\u00f3n convertir-temperatura , hemos dise\u00f1ado dos casos de prueba: Datos de Entrada Resultado Esperado 50 , #\\F (10 \"grados centigrados\") 50 , #\\C (122 \"grados fahrenheit\") El resultado esperado a partir de unos valores concretos de entrada, se determina entendiendo qu\u00e9 debe hacer la funci\u00f3n. Es decir, se obtiene a partir de la especificaci\u00f3n del problema, antes de plantearnos c\u00f3mo solucionarlo. Os aconsejamos tener siempre presente la siguiente idea aunque resulte obvia: Para implementar una funci\u00f3n, primero es imprescindible entender qu\u00e9 debe hacer la funci\u00f3n . Despu\u00e9s, seremos capaces de dise\u00f1ar casos de prueba y ocuparnos de c\u00f3mo implementarla . En las pr\u00e1cticas de la asignatura, para realizar pruebas usaremos la librer\u00eda RackUnit . Para ello, lo primero que tendremos que hacer es importar esta nueva librer\u00eda. Por tanto, debemos a\u00f1adir en nuestros ficheros de pr\u00e1cticas lo siguiente: 1 2 #lang racket ( require rackunit ) Una vez importada la librer\u00eda, ya podemos hacer uso de algunas de sus funciones. En concreto, utilizaremos las siguientes: check-true 1 2 3 ( check-true expr ) ;; Comprueba si su argumento es #t. ;; En caso contrario, se imprime un mensaje de error. check-false 1 2 3 ( check-false expr ) ;; Comprueba si su argumento es #f. ;; En caso contrario, se imprime un mensaje de error. check-equal? 1 2 3 ( check-equal? resultado-real resultado-esperado ) ;; Comprueba si sus dos argumentos son iguales. ;; En caso contrario, se imprime un mensaje de error. Con las funciones check-true y check-false validaremos predicados (recuerda que en Scheme son funciones que devuelven un valor booleano) que hayamos implementado, comprobando si el resultado esperado es true o false , respectivamente. Con la funci\u00f3n check-equal? podremos validar si el resultado de la invocaci\u00f3n a la funci\u00f3n con unos determinados valores de entrada, representado por el argumento resultado-real , es igual al resultado que esperamos, dado por el argumento resultado-esperado .","title":"Pruebas unitarias en Scheme"},{"location":"seminarios/seminario1-scheme/seminario1-scheme.html#ejemplo-de-pruebas-de-la-funcion-ecuacion-definida-anteriormente","text":"Las siguientes pruebas no mostrar\u00e1n ning\u00fan mensaje de error, lo que significa que nuestra funci\u00f3n ecuacion es 'CORRECTA' para estas pruebas, es decir, que con los valores de entrada utilizados, su resultado se corresponde con el esperado. 1 2 3 ( check-equal? ( ecuacion 1 -5 6 ) ( cons 3 2 )) ( check-equal? ( ecuacion 2 -7 3 ) ( cons 3 ( / 1 2 ))) ( check-equal? ( ecuacion -1 7 -10 ) ( cons 2 5 )) Ahora vamos a suponer que nos hemos equivocado en la definici\u00f3n de la funci\u00f3n ecuacion , por ejemplo en el orden de los argumentos al invocar a la funci\u00f3n auxiliar raiz-pos , en la llamada que se hace en la parte izquierda de la pareja resultante. 1 2 ( define ( ecuacion a b c ) ( cons ( raiz-pos b a c ) ( raiz-neg a b c ))) Con esta nueva definici\u00f3n, si ejecutamos la siguiente prueba: 1 ( check-equal? ( ecuacion 1 -5 6 ) ( cons 3 2 )) el resultado ser\u00e1: 1 2 3 4 5 6 7 8 -------------------- FAILURE actual: (-1 . 2) expected: (3 . 2) name: check-equal? location: (#<path:/.../filename.rkt>) expression: (check-equal? (ecuacion 1 -5 6) (cons 3 2)) -------------------- Esta prueba muestra un mensaje de error, lo que significa que la nueva definici\u00f3n de ecuacion 'FALLA', es decir, que el resultado que devuelve (-1 . 2) no coincide con el resultado esperado (3 . 2) .","title":"Ejemplo de pruebas de la funci\u00f3n ecuacion definida anteriormente"},{"location":"seminarios/seminario1-scheme/seminario1-scheme.html#ejercicios","text":"","title":"Ejercicios"},{"location":"seminarios/seminario1-scheme/seminario1-scheme.html#ejercicio-1","text":"Lanza DrRacket y escribe cada una de las siguientes instrucciones en el int\u00e9rprete, intentado adivinar el resultado que va devolver. Est\u00e1n ordenadas por dificultad de arriba abajo y de izquierda a derecha. \u00a1\u00a1Piensa en los resultados!!. Intenta entender c\u00f3mo interpreta Scheme lo que escribes. Instrucci\u00f3n Instrucci\u00f3n 3 (+ (- 4 (* 3 (/ 4 2) 4)) 3) (+ 1 2 ) (* (+ (+ 2 3) 4) (* (* 3 3) 2)) (+ 1 2 3 4) (* (+ 2 3 4 5) 3 (- 5 2 1)) (+) (+ (- (+ (- (+ 2 3) 5) 1) 2) 3) (sqrt 25) (- (sqrt (* 5 ( + 3 2))) (+ 1 1 1 1)) (* (+ 2 3) 5) (> (* 3 (+ 2 (+ 3 1)) (+ 1 1)) (+ (* 2 2) 3)) + (= (* 3 2) (+ 1 (+ 2 2) 1)) #\\+ (not (> (+ 3 2) 5)) \"+\" (and (even? 2) (odd? (+ 3 2))) \"hola\" (remainder (+ 6 2) (+ 1 1))","title":"Ejercicio 1"},{"location":"seminarios/seminario1-scheme/seminario1-scheme.html#ejercicio-2","text":"Predice lo que devolver\u00e1 Scheme cuando escribas las siguientes expresiones. Est\u00e1n ordenadas por dificultad de arriba abajo y de izquierda a derecha. Despu\u00e9s, pru\u00e9balas y comprueba si tu predicci\u00f3n era correcta. Si no lo era, intenta comprender por qu\u00e9. Instrucci\u00f3n Instrucci\u00f3n (equal? \"hola\" \"hola\") (+ (char->integer(integer->char 1200)) (char->integer #\\A)) (string-ref \"pepe\" 1) (string-length (make-string 7 #\\E)) (substring \"buenos dias\" 1 4) (define a 3) (define b (+ a 1)) (= \"hola\" \"hola\") (+ a b (* a b)) (string-ref (substring \"buenos dias\" 2 5) 1) (= a b) (define pi 3.14159) (if (and (> a b) (< b (* a b))) b a) pi (cond ((= a 4) 6) ((= b 4) (+ 6 7 a)) (else 25)) \"pi\" (+ 2 (if (> b a) b a)) (+ pi (+ pi pi)) (* (cond ((> a b) a) ((< a b) b) (else -1)) (+ a 1)) (+ (* pi pi) (- 2 pi pi pi pi)) ((if (< a b) + -) a b)","title":"Ejercicio 2"},{"location":"seminarios/seminario1-scheme/seminario1-scheme.html#ejercicio-3","text":"Ejercicios con parejas. Predice lo que hace Scheme cuando escribas las siguientes expresiones. Est\u00e1n ordenadas por dificultad de arriba abajo y de izquierda a derecha. Despu\u00e9s, pru\u00e9balas y comprueba si tu predicci\u00f3n era correcta. Si no lo era, intenta comprender por qu\u00e9. Instrucci\u00f3n Instrucci\u00f3n (cons 1 2) (car (car (cons (cons 1 2) 3))) (car (cons 1 2)) (car (cons (cons 3 4) 2)) (cdr (cons 1 2)) (cdr (cons (cons 3 4) 2)) (cons (* 2 3) (/ 4 2)) (cdr (cons 1 (cons 2 3))) (cons (+ 2 1) (if (> 2 3) \"2\" \"3\")) (cdr (car (cons (cons 1 2) 3)))","title":"Ejercicio 3"},{"location":"seminarios/seminario1-scheme/seminario1-scheme.html#ejercicio-4","text":"Ejercicios con listas. Predice lo que hace Scheme cuando escribas las siguientes expresiones. Despu\u00e9s, pru\u00e9balas y comprueba si tu predicci\u00f3n era correcta. Si no lo era, intenta comprender por qu\u00e9. Instrucci\u00f3n Instrucci\u00f3n (list 1 2 3 4) (cons 3 '(1 2 3)) (cdr (list 1 2 3 4)) (cdr (cons #t (cons \"Hola\" (list 1)))) (car '(1 2 3 4)) (car (list (list 1 2) 1 2 3 4)) (car (list #t 1 \"Hola\")) (car (cdr '((1 2) 1 2))) (car (cdr (list 1 2 3 4))) (cons '(1 2 3) '(4 5 6)) (cdr (cdr '(1 2 3 4))) (car (cdr (list 1 2 3 4))) (car (cdr (cdr (list 1 2 3 4)))) (cdr (cdr (list 1 2 3 4))) (list (* 2 2) (+ 1 2) (/ 4 2)) (car (cdr (cdr (cdr '(1 2 3 4))))) (list (+ 2 3) (- 3 4) (string-ref \"hola\" 3))","title":"Ejercicio 4"},{"location":"seminarios/seminario1-scheme/seminario1-scheme.html#ejercicio-5","text":"Los siguientes apartados intenta hacerlos sin utilizar el int\u00e9rprete de Scheme. a) Dada la siguiente lista, indica la expresi\u00f3n correcta para que Scheme devuelva 5: 1 ( list 1 2 3 4 5 6 7 8 ) b) Dada la siguiente lista, indica la expresi\u00f3n correcta para que Scheme devuelva (8). 1 ( list 1 2 3 4 5 6 7 8 ) c) Dada la siguiente lista, indica la expresi\u00f3n correcta para que Scheme devuelva 8. 1 ( list 1 2 3 4 5 6 7 8 ) d) Dada la siguiente expresi\u00f3n, \u00bfqu\u00e9 devuelve Scheme? 1 ( car ( cdr ( cdr ( list 1 ( list 2 3 ) ( list 4 5 ) 6 )))) e) Dada la siguiente expresi\u00f3n, \u00bfqu\u00e9 devuelve Scheme? 1 ( cdr ( cdr ' ( 1 ( 2 3 ) 4 5 ))) Lenguajes y Paradigmas de Programaci\u00f3n, curso 2019-20 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Domingo Gallardo, Cristina Pomares, Antonio Bot\u00eda, Francisco Mart\u00ednez","title":"Ejercicio 5"},{"location":"seminarios/seminario2-swift/seminario2-swift.html","text":"Seminario 2: Seminario de Swift \u00b6 El lenguaje de programaci\u00f3n Swift \u00b6 Swift es un lenguaje de programaci\u00f3n compilado, de prop\u00f3sito general y multi-paradigma desarrollado por Apple. Swift se present\u00f3 en la Conferencia de Desarrolladores de Apple (WWDC) de 2014. Durante el a\u00f1o 2014 se desarroll\u00f3 la versi\u00f3n 1.2 y en la WWDC 2015 se present\u00f3 Swift 2, una actualizaci\u00f3n importante del lenguaje. Inicialmente fue un lenguaje propietario, pero el 3 de diciembre de 2015 se hizo open source bajo la licencia Apache 2.0, para las plataformas Apple y Linux. Los cambios en el lenguaje son propuestos y discutidos por la comunidad en un proceso denominado Swift evolution . En la actualidad se ha estabilizado la versi\u00f3n 5 del lenguaje, que es la que utilizaremos para realizar las pr\u00e1cticas. La siguiente descripci\u00f3n se ha extra\u00eddo del repositorio GitHub de Swift: Swift es un lenguaje de programaci\u00f3n de sistemas de alta eficiencia. Tiene una sintaxis limpia y moderna, ofrece acceso transparente a c\u00f3digo y librer\u00edas existentes en C y Objective-C, y es seguro en el uso de memoria ( memory safe ). Aunque est\u00e1 inspirado en Objective-C y en muchos otros lenguajes, Swift no es en si mismo un lenguaje derivado de C. Como lenguaje completo e independiente, Swift proporciona caracter\u00edsticas fundamentales como control de flujo, estructuras de datos y funciones, junto con construcciones de alto nivel como objetos, protocolos, clausuras y gen\u00e9ricos. Swift se apoya en m\u00f3dulos, eliminando la necesidad de cabeceras y la duplicaci\u00f3n de c\u00f3digo que \u00e9stas inducen. Ejecuci\u00f3n de programas Swift \u00b6 Es posible descargar el compilador de Swift en los sistemas operativos Mac (utilizando el entorno de desarrollo Xcode) o Linux. Para la asignatura recomendamos utilizar una m\u00e1quina Docker basada en la distribuci\u00f3n Linux. La utilizaci\u00f3n de la m\u00e1quina Docker hace posible su utilizaci\u00f3n en Windows y Mac sin instalar Xcode y permite un entorno unificado en el que hacer las pr\u00e1cticas. A continuaci\u00f3n explicamos las distintas formas de ejecutar programas Swift. Ejecuci\u00f3n on-line \u00b6 Existen varios sitios on-line en los que es posible ejecutar c\u00f3digo Swift. Recomendamos la direcci\u00f3n http://online.swiftplayground.run . Ejecuci\u00f3n en una m\u00e1quina Docker \u00b6 Docker es una tecnolog\u00eda que ha tenido una gran expansi\u00f3n en los \u00faltimos a\u00f1os. Permite construir m\u00e1quinas virtuales ligeras que utilizan el mismo sistema operativo de la m\u00e1quina host. Estas m\u00e1quinas virtuales se denominan contenedores y, al compartir el propio sistema operativo en el que se est\u00e1n ejecutando, su gesti\u00f3n (construcci\u00f3n, arranque, parada, etc.) es much\u00edsimo m\u00e1s r\u00e1pida que las m\u00e1quinas virtuales tradicionales. Docker se controla desde l\u00ednea de comando, desde la aplicaci\u00f3n Terminal de Mac o el PowerShell de Windows. Existen comandos docker para descargar im\u00e1genes, lanzar y parar contenedores, montar directorios de la m\u00e1quina host en contenedores, etc. Nosotros s\u00f3lo utilizaremos el comando docker run para lanzar un contenedor, pero te recomendamos que investigues y pruebes m\u00e1s comandos y que conozcas mejor esta interesante tecnolog\u00eda. Puedes empezar por la gu\u00eda Get started with Docker . Usaremos la imagen Docker swift:5.1.2 , que contiene el comando swift necesario para compilar y ejecutar aplicaciones Swift. Instalaci\u00f3n de Docker Debes instalar la versi\u00f3n de Docker CE ( Community Edition ) correspondiente a tu sistema operativo. Desc\u00e1rgalo desde esta p\u00e1gina y sigue las instrucciones correspondientes a tu sistema operativo. Cuidado Si tienes Windows 10, la instalaci\u00f3n nativa de Docker es incompatible con la de Virtual Box. Puedes instalar Docker Toolbox , que utiliza una m\u00e1quina Virtual Box para lanzar Docker. Si ya tienes instalada una versi\u00f3n de Virtual Box no lo reinstales con Docker Toolbox. Cuando la instalaci\u00f3n te lo pida deschequ\u00e9alo. Una vez instalado Docker Toolbox debes abrir un Docker Quickstart Terminal que contiene un entorno bash similar al de Linux. Desde ese terminal puedes continuar la instalaci\u00f3n de la imagen Swift tal y como se explica a continuaci\u00f3n. Instalaci\u00f3n y ejecuci\u00f3n de la imagen Swift Una vez instalado Docker, abre un terminal y lanza el siguiente comando: 1 $ docker pull swift:5.1.2 El comando descarga la imagen swift:5.1.2 a nuestro ordenador. Una vez descargada lanzamos el contenedor con el siguiente comando: 1 $ docker run --privileged -it --rm -v \"${PWD}:/home\" swift:5.1.2 /bin/bash El contenedor arranca en muy pocos segundos y aparece su prompt, indicando que ya est\u00e1s dentro de \u00e9l y puedes ejecutar cualquier comando linux: 1 2 3 root@97265a262a58:/# ls bin boot dev etc home lib lib64 media mnt opt proc root run sbin srv sys tmp usr var root@97265a262a58:/# Lanzamos el int\u00e9rprete de Swift con el comando swift : 1 2 3 4 5 6 root@97265a262a58:/# swift Welcome to Swift version 5.1.2 (swift-5.1.2-RELEASE). Type :help for assistance. 1> \"hola\".uppercased() $R0: String = \"HOLA\" 2> Una vez hayamos terminado de trabajar podemos salir del int\u00e9rprete de Swift y del contenedor de la siguiente forma: 1 2 3> :quit root@97265a262a58:/# exit Directorio compartido entre el ordenador host y el contenedor El argumento -v \"${PWD}:/home\" del comando docker run hace que el contenedor monte el directorio actual del ordenador anfitri\u00f3n en el directorio /home de la m\u00e1quina docker. De esta forma podemos editar los programas Swift en el ordenador anfitri\u00f3n y ejecutarlos desde l\u00ednea de comando en el contenedor. Recomendamos utilizar un editor de textos orientado a la programaci\u00f3n para editar los programas Swift en el ordenador anfitri\u00f3n. M\u00e1s adelante hablaremos de los editores Atom y Visual Studio Code, pero cualquier otro editor orientado a programaci\u00f3n te puede valer (Sublime, Xcode en el Mac, etc.) Vamos a probar a usar el directorio compartido: Nos movemos en el ordenador anfitri\u00f3n a un directorio en el que trabajaremos con los programas en Swift: 1 2 ~ $ cd swift ~/swift $ Aviso Si est\u00e1s en Windows, por una cuesti\u00f3n de permisos, el directorio de trabajo es recomendable que se encuentre bajo la ruta C:\\Users\\<usuario>\\ . Por ejemplo: 1 $ cd /c/Users/<usuario>/Documents/Ejercicios/Swift Creamos en el directorio actual un programa llamado holaMundo.swift . Fichero holaMundo.swift : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // Primer programa Swift var str = \"Mensaje\" str = \"Hola mundo!\" print ( str ) // Vamos a sumar dos n\u00fameros var firstNumber = 2 var secondNumber = 3 var totalSum = firstNumber + secondNumber firstNumber = firstNumber + 1 secondNumber = secondNumber + 1 totalSum = firstNumber + secondNumber print ( \"El resultado de la suma es = \\( totalSum ) \" ) Arrancamos el contenedor swift: 1 $ docker run --privileged -it -v \"${PWD}:/home\" swift:5.1.2 /bin/bash Compilamos y ejecutamos el programa desde el contenedor, cambiando al directorio /home (el directorio compartido) y ejecutando el comando swift: 1 2 3 4 root@3131534ce480:/# cd /home root@3131534ce480:~# swift holaMundo.swift Hola mundo! El resultado de la suma es = 7 Prueba a cambiar cualquier cosa en el programa desde el editor en el ordenador anfitri\u00f3n y a volver a ejecutar el programa desde el contenedor. Ver\u00e1s que el directorio est\u00e1 realmente compartido y que el programa se ejecuta con las modificaciones que has introducido. 1 2 3 root@3131534ce480:~# exit exit ~/swift $ Script El siguiente script realiza la llamada a la m\u00e1quina docker y ejecuta el fichero que recibe como par\u00e1metro. Es muy c\u00f3modo para ejecutar ficheros .swift en el directorio actual. Lo puedes ejecutar en Linux , MacOS o en Windows con el Docker Quickstart Terminal . Fichero swift.sh : 1 2 3 4 SWIFT_VER = 5 .1.2 docker run --privileged -it --rm -v \" ${ PWD } :/home\" \"swift: ${ SWIFT_VER } \" /bin/bash -c \" cd /home swift $* \" Puedes guardarlo en el directorio actual, hacerlo ejecutable con 1 $ chmod +x swift.sh y llamarlo pas\u00e1ndole como par\u00e1metro el fichero swift a ejecutar: 1 $ ./swift.sh holaMundo.swift Si est\u00e1s en Windows y quieres ejecutar el script desde un terminal normal puedes hacer el siguiente fichero .bat que ejecuta el script anterior en el terminal Docker. Fichero swift.bat : 1 \"C:\\Program Files\\Git\\bin\\bash.exe\" --login -i \"C:\\Program Files\\Docker Toolbox\\start.sh\" \"./swift.sh %*\" Uso: 1 > swift holaMundo.swift Instalaci\u00f3n en MacOS \u00b6 Para instalar la \u00faltima versi\u00f3n de Swift en MacOs debes instalar Xcode. Una vez instalado puedes ejecutar Swift desde el terminal. Instalaci\u00f3n en Linux Ubuntu \u00b6 Existe una distribuci\u00f3n oficial de Swift para Ubuntu de 64 bits (distribuciones 14.04, 16.04 y 16.10). Puedes encontrar la informaci\u00f3n completa en la web oficial de Apple . Brevemente, los pasos son los siguientes: 1 2 3 4 5 $ sudo apt-get install clang libicu-dev // Descargar la versi\u00f3n y plataforma deseada ( fichero swift-<VERSION>-<PLATFORM>.tar.gz ) $ tar xzf swift-<VERSION>-<PLATFORM>.tar.gz // Esto crea el directorio usr/ en la localizaci\u00f3n del archivo // Actualizar el PATH o mover usr/bin/swift al directorio /usr/bin Visual Studio Code \u00b6 Para editar c\u00f3digo Swift puedes usar cualquier editor orientado a programaci\u00f3n como Visual Studio Code o Atom. Aconsejamos Visual Studio Code . Es recomendable instalar la extensi\u00f3n Swift Language que realiza un coloreado de sintaxis de Swift. Para trabajar de forma m\u00e1s c\u00f3moda podemos abrir el terminal integrado Ver > Terminal integrado y lanzar el contenedor de Swift en ese terminal. Puedes consultar los conceptos b\u00e1sicos de Visual Studio Code y el manual completo en este enlace . Integraci\u00f3n del Docker Quickstart Terminal en Visual Studio Code (Windows) Abre un Docker Quickstart Terminal , ejecuta el siguiente comando y anota los valores de las variables de entorno: 1 2 3 4 5 6 $ set | grep DOCKER_ DOCKER_CERT_PATH = 'C:\\Users\\<usuario>\\.docker\\machine\\machines\\default' DOCKER_HOST = tcp://192.168.99.100:2376 DOCKER_MACHINE_NAME = default DOCKER_TLS_VERIFY = 1 DOCKER_TOOLBOX_INSTALL_PATH = 'C:\\Program Files\\Docker Toolbox' Abre la carpeta de trabajo como \u00e1rea de trabajo: Archivo -> Abrir \u00e1rea de trabajo... . Abre el Terminal integrado (Crtl+\u00f1). Te d\u00e1 a elegir entre tres shells (PowerShell, CMD, o Git bash). Elige el que mejor te venga por defecto, ya que en cualquier caso, para trabajar con el Swift de Docker hay que ajustar la configuraci\u00f3n. Abre la configuraci\u00f3n ( Crl+ , o Archivo->Preferencias->Configuraci\u00f3n ). F\u00edjate que son tres los ficheros de configuraci\u00f3n posibles: Configuraci\u00f3n predeterminada Configuraci\u00f3n de usuario Configuraci\u00f3n de \u00e1rea de trabajo En la Configuraci\u00f3n de usuario o en la de \u00e1rea de trabajo, dependiendo de en cu\u00e1l te convenga m\u00e1s, pon entre las {} los siguientes valores de configuraci\u00f3n: 1 2 3 4 5 6 7 8 9 10 11 { \"terminal.integrated.shell.windows\": \"C:\\\\Program Files\\\\Git\\\\bin\\\\bash.exe\", \"terminal.integrated.env.windows\": { \"DOCKER_CERT_PATH\": \"C:\\\\Users\\\\<usuario>\\\\.docker\\\\machine\\\\machines\\\\default\", \"DOCKER_HOST\": \"tcp://192.168.99.100:2376\", \"DOCKER_MACHINE_NAME\": \"default\", \"DOCKER_TLS_VERIFY\": \"1\", \"DOCKER_TOOLBOX_INSTALL_PATH\": \"C:\\\\Program Files\\\\Docker Toolbox\" }, \"terminal.integrated.shellArgs.windows\": [\"--login\", \"-i\", \"C:\\\\Program Files\\\\Docker Toolbox\\\\start.sh\"] } F\u00edjate que el valor de terminal.integrated.env.windows depende de los valores que obtuvistes en el Docker Quickstart Terminal cuando probamos las Docker Tools. Si eliges cambiar la Configuraci\u00f3n de \u00e1rea de trabajo, en lugar de la de Usuario, la configuraci\u00f3n se guarda en una subcarpeta \".vscode\" de la carpeta de trabajo, y este tipo de Terminal interactivo se abrir\u00e1 solo cuando trabajes en esa carpeta. Por defecto, en otras carpetas podr\u00e1s tener el terminal que elijas. Un tour de Swift \u00b6 Aqu\u00ed empieza el seminario de Swift. El texto que hay a continuaci\u00f3n es una traducci\u00f3n del documento de Apple A Swift Tour en el que se presenta una introducci\u00f3n r\u00e1pida a los conceptos fundamentales del lenguaje. En los temas siguientes de la asignatura (Tema 5 - Programaci\u00f3n Funcional con Swift y Tema 6 - Programaci\u00f3n Orientada a Objetos con Swift) profundizaremos en aspectos como funciones, gen\u00e9ricos, clases o protocolos. Te recomendamos que crees un fichero llamado seminario.swift y que vayas copiando y probando en \u00e9l todos los ejemplos que aparecen a continuaci\u00f3n. La tradici\u00f3n sugiere que el primer programa en un nuevo lenguaje deber\u00eda imprimir las palabras \"Hello, world!\" en la pantalla. En Swift, esto puede hacerse con una \u00fanica l\u00ednea: 1 print ( \"Hello, world!\" ) Si has escrito c\u00f3digo en C o en Objective-C, esta sintaxis te parecer\u00e1 familiar. En Swift, esta l\u00ednea de c\u00f3digo es un programa completo. No necesitas importar una biblioteca separada para funcionaliades como entrada/salida o manejo de cadenas. El c\u00f3digo escrito en el \u00e1mbito global se usa como el punto de entrada del programa, por lo que no necesitas una funci\u00f3n main() . Tampoco tienes que escribir puntos y comas al final de cada sentencia. Este tour te da informaci\u00f3n suficiente para empezar a escribir c\u00f3digo in Swift ense\u00f1\u00e1ndote c\u00f3mo conseguir una variedad de tareas de programaci\u00f3n. No te preocupes si no entiendes algo, todo lo que se introduce en este tour se explica en detalle en el resto del libro . Valores simples Usa let para crear una constante y var para crear una variable. No es necesario que se conozca en tiempo de compilaci\u00f3n el valor de una constante, pero debes asignarle un valor exactamente una vez. Esto significa que puedes usar constantes para nombrar un valor que determinas una vez pero que usas en muchos lugares. 1 2 3 var miVariable = 42 miVariable = 50 let miConstante = 42 Una constante o variable debe tener el mismo tipo que el valor que quieres asignarle. Sin embargo, no siempre tienes que escribir el tipo expl\u00edcitamente. Cuando se proporciona un valor al crear una constante o una variable el compilador infiere su tipo. En el ejemplo anterior, el compilador infiere que myVariable es un entero porque su valor inicial es un entero. Si el valor inicial no proporciona informaci\u00f3n suficiente (o si no hay valor inicial), especifica el tipo escribi\u00e9ndolo despu\u00e9s de la variable, separ\u00e1ndolo por dos puntos. 1 2 3 let implicitoInteger = 70 let implicitoDouble = 70.0 let explicitoDouble : Double = 70 EXPERIMENTO Crea una constante con el tipo expl\u00edcito de Float y un valor de 4. Los valores nunca se convierten impl\u00edcitamente a otro tipo. Si necesitas convertir un valor a un tipo diferente, construye expl\u00edcitamente una instancia del tipo deseado. 1 2 3 let etiqueta = \"El ancho es \" let ancho = 94 let anchoEtiqueta = etiqueta + String ( ancho ) EXPERIMENTO Intenta eliminar la conversi\u00f3n a String en la \u00faltima l\u00ednea. \u00bfQu\u00e9 error obtienes? Hay una forma a\u00fan m\u00e1s sencilla de incluir valores en cadenas: escribe el valor entre par\u00e9ntesis, y escribe una barra invertida ( \\ ) antes de los par\u00e9ntesis. Por ejemplo: 1 2 3 4 let manzanas = 3 let naranjas = 5 let resumenManzanas = \"Tengo \\( manzanas ) manzanas.\" let resumenFrutas = \"Tengo \\( manzanas + naranjas ) frutas.\" EXPERIMENTO Usa \\() para incluir un c\u00e1lculo en punto flotante en una cadena y para incluir el nombre de alguien en un saludo. Crea arrays y diccionarios utilizando corchetes ( [] ), y accede a sus elementos escribiendo el \u00edndice o la clave en los corchetes. Se permite una coma despu\u00e9s del \u00faltimo elemento. 1 2 3 4 5 6 7 8 var listaCompra = [ \"huevos\" , \"agua\" , \"tomates\" , \"pan\" ] listaCompra [ 1 ] = \"botella de agua\" var trabajos = [ \"Malcolm\" : \"Capit\u00e1n\" , \"Kaylee\" : \"Mec\u00e1nico\" , ] trabajos [ \"Jayne\" ] = \"Relaciones p\u00fablicas\" Para crear un array o diccionario vac\u00edo, usa la sintaxis de inicializaci\u00f3n. 1 2 let arrayVacio = [ String ]() let diccionarioVacio = [ String : Float ]() Si el tipo de informaci\u00f3n puede ser inferido, puedes escribir un array vac\u00edo como [] y un diccionario vac\u00edo como [:] ; por ejemplo, cuando estableces un nuevo valor para una variable o pasas un argumento a una funci\u00f3n. 1 2 listaCompra = [] trabajos = [:] Tuplas Una tupla agrupa varios valores en un \u00fanico valor compuesto. 1 let http404Error = ( 404 , \"Not Found\" ) El tipo de la tupla es (Int, String) . Para obtener los valores de la tupla podemos descomponerla . Si queremos ignorar una parte podemos utilizar un subrrayado ( _ ). 1 2 let ( statusCode , statusMensaje ) = http404Error let ( soloStatusCode , _ ) = http404Error Tambi\u00e9n podemos acceder por posici\u00f3n: 1 print ( \"El c\u00f3digo de estado es \\( http404Error . 0 ) \" ) Control de flujo Usa if y switch para hacer condicionales y usa for-in , for , while y repeat-while para hacer bucles. Los par\u00e9ntesis alrededor de las condiciones o de la variable del bucle son opcionales. Se requieren llaves alrededor del cuerpo. 1 2 3 4 5 6 7 8 9 10 let puntuacionesIndividuales = [ 75 , 43 , 103 , 87 , 12 ] var puntuacionEquipo = 0 for puntuacion in puntuacionesIndividuales { if puntuacion > 50 { puntuacionEquipo += 3 } else { puntuacionEquipo += 1 } } print ( puntuacionEquipo ) En una sentencia if , el condicional debe ser una expresi\u00f3n booleana; esto significa que c\u00f3digo como if score { ... } es un error, no una comparaci\u00f3n impl\u00edcita con cero. Puedes usar if y let juntos para trabajar con valores que pueden faltar. Estos valores se representan como opcionales. Un valor opcional o bien contiene un valor o contiene nil para indicar que el valor falta. Escribe una interrogaci\u00f3n ( ? ) despu\u00e9s del tipo de un valor para marcar el valor como opcional. 1 2 3 4 5 6 7 8 var cadenaOpcional : String ? = \"Hola\" print ( cadenaOpcional == nil ) var nombreOpcional : String ? = \"John Appleseed\" var saludo = \"Hola!\" if let nombre = nombreOpcional { saludo = \"Hola, \\( nombre ) \" } EXPERIMENTO Cambia nombreOpcional a nil . \u00bfQu\u00e9 saludo obtienes? A\u00f1ade una cl\u00e1usula else que establezca un saludo diferente si nombreOpcional es nil . Si el valor opcional es nil , el condicional es false y el c\u00f3digo en las llaves se salta. En otro caso, el valor opcional se desenvuelve y se asigna a la constante despu\u00e9s del let , lo que hace que el valor desenvuelto est\u00e9 disponible dentro del bloque de c\u00f3digo. Otra forma de manejar valores opcionales es proporcionar un valor por defecto usando el operador ?? . Si falta el valor valor opcional, se usa el valor por defecto en su lugar. 1 2 3 let nombrePila : String ? = nil let nombreCompleto : String = \"John Appleseed\" let saludoInformal = \"\u00bfQu\u00e9 tal, \\( nombrePila ?? nombreCompleto ) ?\" Las sentencias switch permiten cualquier tipo de datos y una amplia variedad de operaciones de comparaci\u00f3n; no est\u00e1n limitados a enteros y pruebas de igualdad. 1 2 3 4 5 6 7 8 9 let verdura = \"pimiento rojo\" switch verdura { case \"zanahoria\" : print ( \"Buena para la vista.\" ) case \"lechuga\" , \"tomates\" : print ( \"Podr\u00edas hacer una buena ensalada.\" ) default : print ( \"Siempre puedes hacer una buena sopa.\" ) } EXPERIMENTO Intenta eliminar el caso por defecto. \u00bfQu\u00e9 error obtienes? Despu\u00e9s de ejecutar el c\u00f3digo dentro del caso que se empareja, el programa sale de la sentencia switch . La ejecuci\u00f3n no continua con el siguiente caso, por lo que no hay necesidad de romper el switch al final del c\u00f3digo de cada caso. Usa for-in para iterar sobre elementos en un diccionario proporcionando una pareja de nombres para usar en cada pareja clave-valor. Los diccionarios son colecciones desordenadas, por lo que sus claves y valores se iteran en un orden arbitrario. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 let numerosInteresantes = [ \"Primos\" : [ 2 , 3 , 5 , 7 , 11 , 13 ], \"Fibonacci\" : [ 1 , 1 , 2 , 3 , 5 , 8 ], \"Cuadrados\" : [ 1 , 4 , 9 , 16 , 25 ], ] var mayor = 0 for ( clase , numeros ) in numerosInteresantes { for numero in numeros { if numero > mayor { mayor = numero } } } print ( mayor ) EXPERIMENTO A\u00f1ade otra variable para seguir qu\u00e9 clase de n\u00famero es el mayor. Usa while para repetir un bloque de c\u00f3digo hasta que una condici\u00f3n cambie. La condici\u00f3n de un bucle puede estar tambi\u00e9n al final, asegurando que el bucle se ejecuta al menos una vez. 1 2 3 4 5 6 7 8 9 10 11 var n = 2 while n < 100 { n *= 2 } print ( n ) var m = 2 repeat { m *= 2 } while m < 100 print ( m ) Puedes definir un \u00edndice en un bucle usando ..< para construir un rango de \u00edndices. 1 2 3 4 5 var total = 0 for i in 0. .< 4 { total += i } print ( total ) Usa ..< para construir un rango que omita su valor superior, y usa ... para construir un rango que incluya ambos valores. Funciones y clausuras Usa func para declarar una funci\u00f3n. Usa -> para separar los nombres de los par\u00e1metros y sus tipos del tipo devuelto de la funci\u00f3n. 1 2 3 4 func saluda ( nombre : String , dia : String ) -> String { return \"Hola \\( nombre ) , hoy es \\( dia ) .\" } saluda ( nombre : \"Bob\" , dia : \"Martes\" ) EXPERIMENTO Elimina el par\u00e1metro d\u00eda. A\u00f1ade un par\u00e1metro para incluir la comida de hoy en el saludo. Por defecto, las funciones usan los nombres de los par\u00e1metros como etiquetas de los argumentos. Es posible definir una etiqueta escribi\u00e9ndola antes del nombre del par\u00e1metro, o no usar etiqueta escribiendo _ : 1 2 3 4 func saluda ( _ nombre : String , el dia : String ) -> String { return \"Hola \\( nombre ) , hoy es \\( dia ) .\" } saluda ( \"Bob\" , el : \"Martes\" ) Las funciones pueden devolver cualquier tipo de dato, como tuplas. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 func calculaEstadisticas ( puntuaciones : [ Int ]) -> ( min : Int , max : Int , sum : Int ) { var min = puntuaciones [ 0 ] var max = puntuaciones [ 0 ] var sum = 0 for puntuacion in puntuaciones { if puntuacion > max { max = puntuacion } else if puntuacion < min { min = puntuacion } sum += puntuacion } return ( min , max , sum ) } let estadisticas = calculaEstadisticas ( puntuaciones : [ 5 , 3 , 100 , 3 , 9 ]) print ( estadisticas . sum ) print ( estadisticas . 2 ) Las funciones tambi\u00e9n pueden tener un n\u00famero variable de argumentos, agrup\u00e1ndose todos ellos en un array. 1 2 3 4 5 6 7 8 9 func suma ( numeros : Int ...) -> Int { var suma = 0 for numeros in numeros { suma += numeros } return suma } print ( suma ()) print ( suma ( numeros : 42 , 597 , 12 )) EXPERIMENTO Escribe una funci\u00f3n que calcule la media de sus argumentos. Las funciones pueden anidarse. Las funciones pueden acceder variables declaradas en la funci\u00f3n exterior. Puedes usar funciones anidadas para organizar el c\u00f3digo en una funci\u00f3n que es larga o complicada. 1 2 3 4 5 6 7 8 9 func devuelveQuince () -> Int { var y = 10 func suma () { y += 5 } suma () return y } print ( devuelveQuince ()) Las funciones son un tipo de primera clase. Esto significa que una funci\u00f3n puede devolver otra funci\u00f3n como resultado. 1 2 3 4 5 6 7 8 func construyeIncrementador () -> (( Int ) -> Int ) { func sumaUno ( numero : Int ) -> Int { return 1 + numero } return sumaUno } var incrementa = construyeIncrementador () print ( incrementa ( 7 )) Podemos modificar el ejemplo devuelveQuince para que se devuelva una versi\u00f3n modificada de la funci\u00f3n suma . Llamamos a la funci\u00f3n devuelveSuma . 1 2 3 4 5 6 7 8 9 10 11 12 func devuelveSuma () -> (() -> Int ) { var y = 10 func suma () -> Int { y += 5 return y } return suma } let f = devuelveSuma () print ( f ()) print ( f ()) Una funci\u00f3n puede tomar otra funci\u00f3n como uno de sus argumentos. 1 2 3 4 5 6 7 8 9 10 11 12 13 func cumpleCondicion ( lista : [ Int ], condicion : ( Int ) -> Bool ) -> Bool { for item in lista { if condicion ( item ) { return true } } return false } func menorQueDiez ( numero : Int ) -> Bool { return numero < 10 } var numeros = [ 20 , 19 , 7 , 12 ] print ( cumpleCondicion ( lista : numeros , condicion : menorQueDiez )) Las funciones son en la realidad un caso especial de clausuras: bloques de c\u00f3digo que pueden ser llamados despu\u00e9s. El c\u00f3digo en la clausura tiene acceso a cosas como variables y funciones que estaban disponibles en el \u00e1mbito ( scope ) en el que se cre\u00f3 la clausura, incluso si la clausura est\u00e1 en un \u00e1mbito distinto cuando se ejecuta; ya viste un ejemplo de esto con las funciones anidadas. Puedes escribir una clausura rodeando el c\u00f3digo con llaves ( {} ). Usa in para separar los argumentos del cuerpo. 1 2 3 4 5 numeros . map ({ ( numero : Int ) -> Int in let resultado = 3 * numero return resultado }) EXPERIMENTO Reescribe la clausura para que devuelva cero para todos los n\u00fameros impares. Tienes bastantes opciones para escribir clausuras de forma m\u00e1s concisa. Cuando ya se conoce el tipo de una clausura puedes omitir el tipo de sus par\u00e1metros, el tipo devuelto o ambos. Las clausuras escritas en una sentencia devuelven impl\u00edcitamente el valor de esa \u00fanica sentencia. 1 2 let numerosMapeados = numeros . map ({ numero in 3 * numero }) print ( numerosMapeados ) Puedes referirte a los par\u00e1metros por n\u00famero en lugar de por nombre; este enfoque es especialmente \u00fatil en clausuras muy cortas. Una clausura pasada como \u00faltimo argumento puede aparecer inmediatamente despu\u00e9s de los par\u00e9ntesis. Cuando una clausura es el \u00fanico argumento de una funci\u00f3n, puedes omitir los par\u00e9ntesis por completo. 1 2 let numerosOrdenados = numeros . sorted { $0 > $1 } print ( numerosOrdenados ) Objetos y clases Usa class seguido por el nombre de la clase para crear una clase. Una declaraci\u00f3n de una propiedad en una clase se escribe de la misma forma que la declaraci\u00f3n de una constante o una variable, excepto que est\u00e1 en el contexto de una clase. De la misma forma, las declaraciones de los m\u00e9todos se escriben de la misma forma que las funciones. 1 2 3 4 5 6 class Figura { var numeroDeLados = 0 func descripcionSencilla () -> String { return \"Una figura con \\( numeroDeLados ) lados.\" } } EXPERIMENTO A\u00f1ade una propiedad constante con let , y a\u00f1ade otro m\u00e9todo que tome un argumento. Crea una instancia de una clase poniendo par\u00e9ntesis despu\u00e9s del nombre de la clase. Usa la sintaxis de punto para acceder a las propiedades y los m\u00e9todos de la instancia. 1 2 3 var figura = Figura () figura . numeroDeLados = 7 var descripcionFigura = figura . descripcionSencilla () A esta versi\u00f3n de la clase Figura le falta algo importante: un inicializador para preparar la clase cuando se crea una instancia. Usa init para crear uno. 1 2 3 4 5 6 7 8 9 10 11 12 class FiguraConNombre { var numeroDeLados : Int = 0 var nombre : String init ( nombre : String ) { self . nombre = nombre } func descripcionSencilla () -> String { return \"Una figura con \\( numeroDeLados ) lados.\" } } F\u00edjate en c\u00f3mo se utiliza self para distinguir la propiedad nombre del argumento nombre al inicializador. Los argumentos al inicializador se pasan como una llamada a una funci\u00f3n cuando creas una instancia de la clase. Cada propiedad necesita un valor asignado; ya sea en su declaraci\u00f3n (como numeroDeLados ) o en el inicializador (como nombre ). Usa deinit para crear un desinicializador si necesitas realizar alguna limpieza antes de que el objeto sea eliminado. Las subclases incluyen el nombre de su subclase despu\u00e9s del nombre de la clase, separado por dos puntos. No hay ning\u00fan requisito de que las clases deban ser subclases de alguna clase ra\u00edz, por lo que puedes omitir una superclase si as\u00ed lo necesitas. Los m\u00e9todos en una subclase que sobreescriben la implementaci\u00f3n de la superclase se marcan con override ; la sobreescritura de un m\u00e9todo por accidente, sin override , se detecta por el compilador como un error. El compilador tambi\u00e9n detecta m\u00e9todos con override que realmente no sobreescriben ning\u00fan m\u00e9todo de la superclase. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Cuadrado : FiguraConNombre { var longitudLado : Double init ( longitudLado : Double , nombre : String ) { self . longitudLado = longitudLado super . init ( nombre : nombre ) numeroDeLados = 4 } func area () -> Double { return longitudLado * longitudLado } override func descripcionSencilla () -> String { return \"Un cuadrado con lados de longitud \\( longitudLado ) .\" } } let test = Cuadrado ( longitudLado : 5.2 , nombre : \"Mi cuadrado de prueba\" ) print ( test . area ()) print ( test . descripcionSencilla ()) EXPERIMENTO Construye otra subclase de FiguraConNombre llamada Circulo que tome un radio y un nombre como argumentos de su inicializador. Implementa un m\u00e9todo area() y descripcionSencilla() en la clase Circulo . Adem\u00e1s de propiedades simples que se almacenan, las propiedades pueden tener un getter y un setter . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class TrianguloEquilatero : FiguraConNombre { var longitudLado : Double = 0.0 init ( longitudLado : Double , nombre : String ) { self . longitudLado = longitudLado super . init ( nombre : nombre ) numeroDeLados = 3 } var perimetro : Double { get { return 3.0 * longitudLado } set { longitudLado = newValue / 3.0 } } override func descripcionSencilla () -> String { return \"Un triangulo equil\u00e1tero con lados de longitud \\( longitudLado ) .\" } } var triangulo = TrianguloEquilatero ( longitudLado : 3.1 , nombre : \"un tri\u00e1ngulo\" ) print ( triangulo . perimetro ) triangulo . perimetro = 9.9 print ( triangulo . longitudLado ) En el setter de perimetro , el nuevo valor tiene el nombre impl\u00edcito newValue . Puedes proporcionar un nombre expl\u00edcito en el par\u00e9ntesis despu\u00e9s de set . Date cuenta de que el inicializador de la clase TrianguloEquilatero tiene tres pasos diferentes: Establecer el valor de las propiedades que declara la subclase. Llamar al inicializador de la superclase. Cambiar el valor de las propiedades definidas por la superclase. Cualquier trabajo adicional que use m\u00e9todos, getters o setters puede hacerse tambi\u00e9n en este punto. Si no necesitas calcular la propiedad pero necesitas proporcionar c\u00f3digo que se ejecuta antes y despu\u00e9s de establecer un nuevo valor, usa willSet y didSet . El c\u00f3digo que proporcionas se ejecuta cada vez que el valor cambia fuera de un inicializador. Por ejemplo, la siguiente clase se asegura de que la longitud del lado de su tri\u00e1ngulo siempre es la misma que la longitud del lado de su cuadrado. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class TrianguloYCuadrado { var triangulo : TrianguloEquilatero { willSet { cuadrado . longitudLado = newValue . longitudLado } } var cuadrado : Cuadrado { willSet { triangulo . longitudLado = newValue . longitudLado } } init ( tama\u00f1o : Double , nombre : String ) { cuadrado = Cuadrado ( longitudLado : tama\u00f1o , nombre : nombre ) triangulo = TrianguloEquilatero ( longitudLado : tama\u00f1o , nombre : nombre ) } } var trianguloYCuadrado = TrianguloYCuadrado ( tama\u00f1o : 10 , nombre : \"Otra figura de prueba\" ) print ( trianguloYCuadrado . cuadrado . longitudLado ) print ( trianguloYCuadrado . triangulo . longitudLado ) trianguloYCuadrado . cuadrado = Cuadrado ( longitudLado : 50 , nombre : \"Cuadrado mayor\" ) print ( trianguloYCuadrado . triangulo . longitudLado ) Cuando trabajamos con valores opcionales, puedes escribir ? antes de operaciones como m\u00e9todos, propiedades y sub\u00edndices. Si el valor antes del ? es nil , todo lo que hay despu\u00e9s se ignora y el valor de la expresi\u00f3n completa es nil . En otro caso, el valor opcional se desenvuelve, y todo lo que hay despu\u00e9s del ? se realiza sobre el valor desenvuelto. En ambos casos, el valor de la expresi\u00f3n completa es un valor opcional. 1 2 let cuadradoOpcional : Cuadrado ? = Cuadrado ( longitudLado : 2.5 , nombre : \"Cuadrado opcional\" ) let longitudLado = cuadradoOpcional ?. longitudLado Enumeraciones y estructuras Usa enum para crear una enumeraci\u00f3n. Como las clases y otros tipos con nombre, las enumeraciones pueden tener m\u00e9todos asociados. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 enum Valor : Int { case uno = 1 case dos , tres , cuatro , cinco , seis , siete , ocho , nueve , diez case sota , caballo , rey func descripcionSencilla () -> String { switch self { case . uno : return \"as\" case . sota : return \"sota\" case . caballo : return \"caballo\" case . rey : return \"rey\" default : return String ( self . rawValue ) } } } let carta = Valor . uno let valorBrutoCarta = carta . rawValue EXPERIMENTO Escribe una funci\u00f3n que compare dos valores Valor a trav\u00e9s de una comparaci\u00f3n de sus valores brutos. Por defecto, Swift asigna los valores brutos comenzando en cero e increment\u00e1ndolos por uno cada vez, pero puedes cambiar esta conducta especificando expl\u00edcitamente los valores. En el ejemplo anterior, a As se le da un valor bruto de 1 y el resto de los valores brutos se asignan en orden. Puedes tambi\u00e9n usar cadenas o n\u00fameros en punto flotante como valores brutos de una enumeraci\u00f3n. Utiliza la propiedad rawValue para acceder al valor bruto de una enumeraci\u00f3n. Usa el inicializador para construir un valor de una enumeraci\u00f3n a trav\u00e9s de un valor bruto. Si el valor bruto no existe, el inicializador devolver\u00e1 nil . 1 2 3 4 if let valorConvertido = Valor ( rawValue : 3 ) { let descripcionTres = valorConvertido . descripcionSencilla () print ( descripcionTres ) } Los valores case de una enumeraci\u00f3n son valores reales, no una forma nueva de escribir sus valores brutos. De hecho, en los casos en los que no hay un valor bruto que tenga sentido, no tienes que proporcionar uno. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 enum Palo { case oros , bastos , copas , espadas func descripcionSencilla () -> String { switch self { case . oros : return \"oros\" case . bastos : return \"bastos\" case . copas : return \"copas\" case . espadas : return \"espadas\" } } } let copas = Palo . copas let descripcionCopas = copas . descripcionSencilla () EXPERIMENTO A\u00f1ade un m\u00e9todo color() a Palo que devuelva \"agresivo\" para bastos y espadas y devuelva \"reflexivo\" para oros y copas . Date cuenta de las dos formas en las que nos referimos al caso copas de la enumeraci\u00f3n anterior: cuando se asigna un valor a la constante copas , nos referimos al caso de la enumeraci\u00f3n Palo.copas usando su nombre completo porque la constante no tiene un tipo expl\u00edcito especificado. Dentro del switch , nos referimos al caso de la enumeraci\u00f3n con la forma abreviada .copas porque ya se sabe que el valor de self es un Palo . Puedes usar la forma abreviada en cualquier momento en que el tipo del valor ya se conozca. Una instancia de un caso de enumeraci\u00f3n puede tener valores asociados con la instancia. Instancias del mismo caso de enumeraci\u00f3n pueden tener asociados valores diferentes. Proporcionas los valores asociados cuando creas la instancia. Los valores asociados y los valores brutos son distintos: el valor bruto de un caso de enumeraci\u00f3n es el mismo para todas las instancias, mientras que proporcionas el valor asociado cuando defines la enumeraci\u00f3n. Por ejemplo, considera el caso de realizar una petici\u00f3n a un servidor de la hora de salir el sol y de la hora de ponerse el sol. El servidor responde con la informaci\u00f3n o responde con alguna informaci\u00f3n de error. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 enum RespuestaServidor { case resultado ( String , String ) case error ( String ) } let exito = RespuestaServidor . resultado ( \"6:00 am\" , \"8:09 pm\" ) let fallo = RespuestaServidor . error ( \"Sin queso.\" ) switch exito { case let . resultado ( salidaSol , puestaSol ): print ( \"La salida del sol es a las \\( salidaSol ) y la puesta es a \\( puestaSol ) .\" ) case let . error ( error ): print ( \"Fallo... \\( error ) \" ) } EXPERIMENTO A\u00f1ade un tercer caso al ServerResponse y al switch. Date cuenta de c\u00f3mo la hora de salir el sol y de ponerse el sol se extraen del ServerResponse como parte del emparejamiento entre el valor y los casos switch. Usa struct para crear una estructura. Las estructuras comparten muchas caracter\u00edsticas de las clases, incluyendo m\u00e9todos e inicializadores. Una de las diferencias m\u00e1s importantes entre estructuras y clases es que las estructuras siempre se copian cuando las pasas en tu c\u00f3digo, mientras que las clases se pasan por referencia. 1 2 3 4 5 6 7 8 9 struct Carta { var valor : Valor var palo : Palo func descripcionSencilla () -> String { return \"El \\( valor . descripcionSencilla ()) de \\( palo . descripcionSencilla ()) \" } } let tresDeEspadas = Carta ( valor : . tres , palo : . espadas ) let descripcionTresDeEspadas = tresDeEspadas . descripcionSencilla () EXPERIMENTO A\u00f1ade un m\u00e9todo a Carta que cree un mazo completo de cartas, con una carta de cada combinaci\u00f3n de valor y palo. Protocolos y extensiones Usa protocol para declarar un protocolo. 1 2 3 4 protocol ProtocoloEjemplo { var descripcionSencilla : String { get } mutating func ajustar () } Clases, enumeraciones y estructuras pueden todas adoptar protocolos. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class ClaseSencilla : ProtocoloEjemplo { var descripcionSencilla : String = \"Una clase muy simple.\" var otraPropiedad : Int = 69105 func ajustar () { descripcionSencilla += \" Ahora 100% ajustada.\" } } var a = ClaseSencilla () a . ajustar () let descripcionA = a . descripcionSencilla struct EstructuraSencilla : ProtocoloEjemplo { var descripcionSencilla : String = \"Una estructura sencilla\" mutating func ajustar () { descripcionSencilla += \" (ajustada)\" } } var b = EstructuraSencilla () b . ajustar () let descripcionB = b . descripcionSencilla EXPERIMENTO Escribe una enumeraci\u00f3n que cumpla el protocolo. Date cuenta del uso de la palabra clave mutating en la declaraci\u00f3n de EstructuraSencilla para marcar el m\u00e9todo que modifica la estructura. La declaraci\u00f3n de ClaseSencilla no necesita que se marquen como mutadores ninguno de sus m\u00e9todos porque los m\u00e9todos en una clase siempre pueden modificar la clase. Usa extension para a\u00f1adir funcionalidad a un tipo existente, como m\u00e9todos nuevos y propiedades calculadas. Puedes utilizar una extensi\u00f3n para a\u00f1adir un cumplimiento de un protocolo a un tipo que se declara en otro lugar, o incluso a un tipo que hayas importado de una biblioteca o un framework . 1 2 3 4 5 6 7 8 9 extension Int : ProtocoloEjemplo { var descripcionSencilla : String { return \"El n\u00famero \\( self ) \" } mutating func ajustar () { self += 42 } } print ( 7. descripcionSencilla ) Otro ejemplo usando una funci\u00f3n: 1 2 3 4 5 6 7 8 9 extension Int { func repetir ( task : () -> ()) { for _ in 0. .. self { task () } } } 10. repetir { print ( \"Hola\" )} EXPERIMENTO Escribe una extensi\u00f3n para el tipo Double que a\u00f1ada una propiedad absoluteValue . Puedes usar un nombre de un protocolo de la misma forma que cualquier otro tipo con nombre; por ejemplo, para crear una colecci\u00f3n de objetos que tienen tipos diferentes pero que cumplen un \u00fanico protocolo. Cuando trabajas con valores cuyo tipo es un tipo de protocolo, no est\u00e1n disponibles los m\u00e9todos fuera del protocolo. 1 2 3 let valorProtocolo : ProtocoloEjemplo = a print ( valorProtocolo . descripcionSencilla ) // print(valorProtocolo.otraPropiedad) // Descomentar para comprobar el error Incluso aunque la variable valorProtocolo tenga un tipo en tiempo de ejecuci\u00f3n de ClaseSencilla , el compilador lo trata como uno del tipo ProtocoloEjemplo . De esta forma no es posible acceder accidentalmente a m\u00e9todos o propiedades que implemente la clase de forma adicional al cumplimiento del protocolo. Gen\u00e9ricos Escribe un nombre dentro de par\u00e9ntesis angulares para construir una funci\u00f3n o un tipo gen\u00e9rico. 1 2 3 4 5 6 7 8 func itemRepetido < Item >( _ item : Item , numeroDeVeces : Int ) -> [ Item ] { var resultado = [ Item ]() for _ in 0. .< numeroDeVeces { resultado . append ( item ) } return resultado } print ( itemRepetido ( \"knock\" , numeroDeVeces : 4 )) Puedes hacer formas gen\u00e9ricas de funciones y m\u00e9todos, as\u00ed como de clases, enumeraciones y estructuras. 1 2 3 4 5 6 7 // Reimplementamos el tipo Optional de la biblioteca est\u00e1ndar de Swift enum ValorOpcional < Envuelto > { case ninguno case alguno ( Envuelto ) } var posibleInteger : ValorOpcional < Int > = . ninguno posibleInteger = . alguno ( 100 ) Es posible usar where justo antes del cuerpo para especificar una lista de requisitos. Por ejemplo, para requerir el tipo que debe implementar un protocolo, para requerir que dos tipos sean los mismos o para requerir que una clase tenga una superclase determinada. 1 2 3 4 5 6 7 8 9 10 11 12 13 func elementosComunes < T : Sequence , U : Sequence >( _ izq : T , _ der : U ) -> Bool where T . Iterator . Element : Equatable , T . Iterator . Element == U . Iterator . Element { for izqItem in izq { for derItem in der { if izqItem == derItem { return true } } } return false } print ( elementosComunes ([ 1 , 2 , 3 ], [ 3 ])) Si se escribe <T: Equatable> es equivalente a escribir <T> ... where T: Equatable . Bibliograf\u00eda y referencias \u00b6 Documentaci\u00f3n sobre Swift The Swift Programming Language (html) Recursos Swift en Apple swift.org Swift Open Source Repositorio swift en GitHub : repositorio principal de Swift, que contiene el c\u00f3digo fuente del compilador Swift, la biblioteca est\u00e1ndar y SourceKit. Repositorio swift-evolution en GitHub : documentos relacionados con la evoluci\u00f3n continua de Swift, incluyendo objetivos de las pr\u00f3ximas versiones y propuestas de cambios y extensiones de Swift. Lenguajes y Paradigmas de Programaci\u00f3n, curso 2018-19 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante","title":"Seminario 2: Seminario de Swift"},{"location":"seminarios/seminario2-swift/seminario2-swift.html#seminario-2-seminario-de-swift","text":"","title":"Seminario 2: Seminario de Swift"},{"location":"seminarios/seminario2-swift/seminario2-swift.html#el-lenguaje-de-programacion-swift","text":"Swift es un lenguaje de programaci\u00f3n compilado, de prop\u00f3sito general y multi-paradigma desarrollado por Apple. Swift se present\u00f3 en la Conferencia de Desarrolladores de Apple (WWDC) de 2014. Durante el a\u00f1o 2014 se desarroll\u00f3 la versi\u00f3n 1.2 y en la WWDC 2015 se present\u00f3 Swift 2, una actualizaci\u00f3n importante del lenguaje. Inicialmente fue un lenguaje propietario, pero el 3 de diciembre de 2015 se hizo open source bajo la licencia Apache 2.0, para las plataformas Apple y Linux. Los cambios en el lenguaje son propuestos y discutidos por la comunidad en un proceso denominado Swift evolution . En la actualidad se ha estabilizado la versi\u00f3n 5 del lenguaje, que es la que utilizaremos para realizar las pr\u00e1cticas. La siguiente descripci\u00f3n se ha extra\u00eddo del repositorio GitHub de Swift: Swift es un lenguaje de programaci\u00f3n de sistemas de alta eficiencia. Tiene una sintaxis limpia y moderna, ofrece acceso transparente a c\u00f3digo y librer\u00edas existentes en C y Objective-C, y es seguro en el uso de memoria ( memory safe ). Aunque est\u00e1 inspirado en Objective-C y en muchos otros lenguajes, Swift no es en si mismo un lenguaje derivado de C. Como lenguaje completo e independiente, Swift proporciona caracter\u00edsticas fundamentales como control de flujo, estructuras de datos y funciones, junto con construcciones de alto nivel como objetos, protocolos, clausuras y gen\u00e9ricos. Swift se apoya en m\u00f3dulos, eliminando la necesidad de cabeceras y la duplicaci\u00f3n de c\u00f3digo que \u00e9stas inducen.","title":"El lenguaje de programaci\u00f3n Swift"},{"location":"seminarios/seminario2-swift/seminario2-swift.html#ejecucion-de-programas-swift","text":"Es posible descargar el compilador de Swift en los sistemas operativos Mac (utilizando el entorno de desarrollo Xcode) o Linux. Para la asignatura recomendamos utilizar una m\u00e1quina Docker basada en la distribuci\u00f3n Linux. La utilizaci\u00f3n de la m\u00e1quina Docker hace posible su utilizaci\u00f3n en Windows y Mac sin instalar Xcode y permite un entorno unificado en el que hacer las pr\u00e1cticas. A continuaci\u00f3n explicamos las distintas formas de ejecutar programas Swift.","title":"Ejecuci\u00f3n de programas Swift"},{"location":"seminarios/seminario2-swift/seminario2-swift.html#ejecucion-on-line","text":"Existen varios sitios on-line en los que es posible ejecutar c\u00f3digo Swift. Recomendamos la direcci\u00f3n http://online.swiftplayground.run .","title":"Ejecuci\u00f3n on-line"},{"location":"seminarios/seminario2-swift/seminario2-swift.html#ejecucion-en-una-maquina-docker","text":"Docker es una tecnolog\u00eda que ha tenido una gran expansi\u00f3n en los \u00faltimos a\u00f1os. Permite construir m\u00e1quinas virtuales ligeras que utilizan el mismo sistema operativo de la m\u00e1quina host. Estas m\u00e1quinas virtuales se denominan contenedores y, al compartir el propio sistema operativo en el que se est\u00e1n ejecutando, su gesti\u00f3n (construcci\u00f3n, arranque, parada, etc.) es much\u00edsimo m\u00e1s r\u00e1pida que las m\u00e1quinas virtuales tradicionales. Docker se controla desde l\u00ednea de comando, desde la aplicaci\u00f3n Terminal de Mac o el PowerShell de Windows. Existen comandos docker para descargar im\u00e1genes, lanzar y parar contenedores, montar directorios de la m\u00e1quina host en contenedores, etc. Nosotros s\u00f3lo utilizaremos el comando docker run para lanzar un contenedor, pero te recomendamos que investigues y pruebes m\u00e1s comandos y que conozcas mejor esta interesante tecnolog\u00eda. Puedes empezar por la gu\u00eda Get started with Docker . Usaremos la imagen Docker swift:5.1.2 , que contiene el comando swift necesario para compilar y ejecutar aplicaciones Swift.","title":"Ejecuci\u00f3n en una m\u00e1quina Docker"},{"location":"seminarios/seminario2-swift/seminario2-swift.html#instalacion-en-macos","text":"Para instalar la \u00faltima versi\u00f3n de Swift en MacOs debes instalar Xcode. Una vez instalado puedes ejecutar Swift desde el terminal.","title":"Instalaci\u00f3n en MacOS"},{"location":"seminarios/seminario2-swift/seminario2-swift.html#instalacion-en-linux-ubuntu","text":"Existe una distribuci\u00f3n oficial de Swift para Ubuntu de 64 bits (distribuciones 14.04, 16.04 y 16.10). Puedes encontrar la informaci\u00f3n completa en la web oficial de Apple . Brevemente, los pasos son los siguientes: 1 2 3 4 5 $ sudo apt-get install clang libicu-dev // Descargar la versi\u00f3n y plataforma deseada ( fichero swift-<VERSION>-<PLATFORM>.tar.gz ) $ tar xzf swift-<VERSION>-<PLATFORM>.tar.gz // Esto crea el directorio usr/ en la localizaci\u00f3n del archivo // Actualizar el PATH o mover usr/bin/swift al directorio /usr/bin","title":"Instalaci\u00f3n en Linux Ubuntu"},{"location":"seminarios/seminario2-swift/seminario2-swift.html#visual-studio-code","text":"Para editar c\u00f3digo Swift puedes usar cualquier editor orientado a programaci\u00f3n como Visual Studio Code o Atom. Aconsejamos Visual Studio Code . Es recomendable instalar la extensi\u00f3n Swift Language que realiza un coloreado de sintaxis de Swift. Para trabajar de forma m\u00e1s c\u00f3moda podemos abrir el terminal integrado Ver > Terminal integrado y lanzar el contenedor de Swift en ese terminal. Puedes consultar los conceptos b\u00e1sicos de Visual Studio Code y el manual completo en este enlace .","title":"Visual Studio Code"},{"location":"seminarios/seminario2-swift/seminario2-swift.html#un-tour-de-swift","text":"Aqu\u00ed empieza el seminario de Swift. El texto que hay a continuaci\u00f3n es una traducci\u00f3n del documento de Apple A Swift Tour en el que se presenta una introducci\u00f3n r\u00e1pida a los conceptos fundamentales del lenguaje. En los temas siguientes de la asignatura (Tema 5 - Programaci\u00f3n Funcional con Swift y Tema 6 - Programaci\u00f3n Orientada a Objetos con Swift) profundizaremos en aspectos como funciones, gen\u00e9ricos, clases o protocolos. Te recomendamos que crees un fichero llamado seminario.swift y que vayas copiando y probando en \u00e9l todos los ejemplos que aparecen a continuaci\u00f3n. La tradici\u00f3n sugiere que el primer programa en un nuevo lenguaje deber\u00eda imprimir las palabras \"Hello, world!\" en la pantalla. En Swift, esto puede hacerse con una \u00fanica l\u00ednea: 1 print ( \"Hello, world!\" ) Si has escrito c\u00f3digo en C o en Objective-C, esta sintaxis te parecer\u00e1 familiar. En Swift, esta l\u00ednea de c\u00f3digo es un programa completo. No necesitas importar una biblioteca separada para funcionaliades como entrada/salida o manejo de cadenas. El c\u00f3digo escrito en el \u00e1mbito global se usa como el punto de entrada del programa, por lo que no necesitas una funci\u00f3n main() . Tampoco tienes que escribir puntos y comas al final de cada sentencia. Este tour te da informaci\u00f3n suficiente para empezar a escribir c\u00f3digo in Swift ense\u00f1\u00e1ndote c\u00f3mo conseguir una variedad de tareas de programaci\u00f3n. No te preocupes si no entiendes algo, todo lo que se introduce en este tour se explica en detalle en el resto del libro .","title":"Un tour de Swift"},{"location":"seminarios/seminario2-swift/seminario2-swift.html#bibliografia-y-referencias","text":"Documentaci\u00f3n sobre Swift The Swift Programming Language (html) Recursos Swift en Apple swift.org Swift Open Source Repositorio swift en GitHub : repositorio principal de Swift, que contiene el c\u00f3digo fuente del compilador Swift, la biblioteca est\u00e1ndar y SourceKit. Repositorio swift-evolution en GitHub : documentos relacionados con la evoluci\u00f3n continua de Swift, incluyendo objetivos de las pr\u00f3ximas versiones y propuestas de cambios y extensiones de Swift. Lenguajes y Paradigmas de Programaci\u00f3n, curso 2018-19 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante","title":"Bibliograf\u00eda y referencias"},{"location":"teoria/tema00-descripcion-asignatura/tema00-descripcion-asignatura.html","text":"Lenguajes y Paradigmas de Programaci\u00f3n \u00b6 Datos acad\u00e9micos de la asignatura \u00b6 Departamento de Ciencia de la Computaci\u00f3n e Inteligencia Artificial 6 cr\u00e9ditos ECTS : 1 clase de teor\u00eda de 2 h. y 1 clase de pr\u00e1cticas de 2 h. a la semana Profesores : Antonio Bot\u00eda ( e-mail ): Grupos de pr\u00e1cticas: 2, 9 y 401 Domingo Gallardo ( e-mail ): Profesor coordinador de la asignatura. Grupos de teor\u00eda: 3, 4 y 40. Grupos de pr\u00e1cticas: 402 Francisco Mart\u00ednez ( e-mail ): Grupos de pr\u00e1cticas: 4, 5, 6 y 8 Cristina Pomares ( e-mail ): Grupos de teor\u00eda: 1 y 2. Grupos de pr\u00e1cticas: 1, 3 y 7. Recursos de la asignatura \u00b6 Ficha de la asignatura Apuntes de la asignatura (teor\u00eda, seminarios y pr\u00e1cticas) Sitio Moodle abierto y accesible a toda la comunidad educativa, contiene los apuntes, transparencias, pr\u00e1cticas y otros materiales docentes Foro de consultas y anuncios en el sitio Moodle (s\u00f3lo accesible a estudiantes) Objetivos y competencias \u00b6 Objetivos : \u00bfQu\u00e9 elementos son comunes a los lenguajes de programaci\u00f3n? \u00bfQu\u00e9 familias o paradigmas de lenguajes podemos identificar? \u00bfQu\u00e9 es la programaci\u00f3n funcional? \u00bfC\u00f3mo es un lenguaje multi-paradigma que combina la programaci\u00f3n funcional y la programaci\u00f3n orientada a objetos? Dominando estos contenidos ser\u00e1 mucho m\u00e1s f\u00e1cil aprender nuevos lenguajes de programaci\u00f3n, identificar sus aspectos esenciales e incluso ser capaz de dise\u00f1ar lenguajes espec\u00edficos orientados a dominios concretos. Competencias : Conocer y diferenciar las caracter\u00edsticas de los distintos paradigmas de programaci\u00f3n (programaci\u00f3n funcional, procedural y orientada a objetos) e identificarlas en lenguajes de programaci\u00f3n concretos. Diferenciar entre tiempo de ejecuci\u00f3n y tiempo de compilaci\u00f3n en distintos \u00e1mbitos: detecci\u00f3n de errores o definici\u00f3n, creaci\u00f3n o \u00e1mbito de vida de variables. Conocer los principios b\u00e1sicos de la programaci\u00f3n funcional: recursi\u00f3n, inmutabilidad, funciones como objetos de primera clase, funciones de orden superior, expresiones lambda (clausuras). Conocer los problemas derivados del uso de la mutaci\u00f3n en los lenguajes de programaci\u00f3n imperativos y la forma de trabajar con estructuras inmutables en lenguajes declarativos y funcionales. Utilizar la abstracci\u00f3n y la recursi\u00f3n para dise\u00f1ar correctamente procedimientos y estructuras de datos (listas y \u00e1rboles). Ser capaz de dise\u00f1ar, implementar y corregir programas funcionales, en concreto utilizando el lenguaje de programaci\u00f3n Scheme. Ser capaz de implementar programas sencillos en Swift, en los que se utilicen las caracter\u00edsticas multi-paradigma del lenguaje. Comparar el paradigma orientado a objetos con el paradigma procedural cl\u00e1sico, reconociendo las ventajas que aporta en cuanto a abstracci\u00f3n, reutilizaci\u00f3n y modificaci\u00f3n de c\u00f3digo. Temario \u00b6 Bloques tem\u00e1ticos \u00b6 La asignatura se divide en 3 bloques tem\u00e1ticos, todos ellos de igual duraci\u00f3n, en los que se utilizar\u00e1 el lenguaje de programaci\u00f3n que aparece entre par\u00e9ntesis: Programaci\u00f3n funcional (Scheme): temas 1 y 2 Procesos y estructuras recursivas (Scheme): temas 3 y 4 Programaci\u00f3n funcional en Swift y programaci\u00f3n orientada a objetos (Swift): temas 5 y 6 Los lenguajes de programaci\u00f3n se introducir\u00e1n mediante seminarios impartidos en las clases de pr\u00e1cticas. Seminario 1. El lenguaje de programaci\u00f3n Scheme : Primitivas. Tipos de datos b\u00e1sicos. S\u00edmbolos. Cadenas. Listas. Definici\u00f3n de funciones. Seminario 2. El lenguaje de programaci\u00f3n Swift . Int\u00e9rprete y scripts. Tipos de datos b\u00e1sicos. Operadores. Estructuras de control. \u00c1mbito de variables. Tipos de datos compuestos: tuplas, arrays y colecciones. Recorriendo colecciones. Valores mutables e inmutables. Inicializaci\u00f3n. Tipos de referencia y valor en Swift. Temas \u00b6 Tema 1. Lenguajes de programaci\u00f3n : Historia de los lenguajes de programaci\u00f3n. Elementos de los lenguajes de programaci\u00f3n. Abstracci\u00f3n. Paradigmas de programaci\u00f3n. Compiladores e int\u00e9rpretes. Tema 2. Programaci\u00f3n Funcional : Caracter\u00edsticas e historia del paradigma de Programaci\u00f3n Funcional. Diferencias con el paradigma imperativo. Caracter\u00edsticas declarativas del paradigma funcional. Definici\u00f3n de funciones. Funciones como datos de primer orden. La forma especial lambda. \u00c1mbito de variables y clausuras. Datos compuestos en Scheme: parejas. Construcci\u00f3n, recorrido y operaciones sobre listas. Listas con elementos compuestos. Listas de listas. Tema 3. Procedimientos recursivos : Dise\u00f1o de funciones recursivas. Recursi\u00f3n mutua. Procesos recursivos e iterativos. Memoization. Recursi\u00f3n y gr\u00e1ficos de tortuga. Tema 4. Estructuras recursivas : Estructuras de datos recursivas: listas estructuradas y \u00e1rboles. Tema 5. Programaci\u00f3n funcional en Swift : Lenguajes multiparadigma. Programaci\u00f3n funcional en Swift. Valores opcionales. Listas. Recursi\u00f3n pura y recursi\u00f3n por la cola. Funciones como datos de primer orden. Clausuras y funciones an\u00f3nimas. Funciones de orden superior: mappings y filtros de colecciones. Tema 6. Programaci\u00f3n Orientada a Objetos en Swift : Caracter\u00edsticas e historia del paradigma de Programaci\u00f3n Orientada a Objetos. Estructuras y clases en Swift. Herencia. Conceptos avanzados de POO en Swift: Extensiones, Protocolos y Gen\u00e9ricos. Gesti\u00f3n de errores. El calendario de temas, pr\u00e1cticas y ex\u00e1menes se puede ver en la siguiente figura. Pr\u00e1cticas \u00b6 Las pr\u00e1cticas son fundamentales en la asignatura y sirven para comprender, trabajar y profundizar los conceptos y competencias estudiados en las clases de teor\u00eda. Para el desarrollo de las pr\u00e1cticas utilizaremos los siguientes lenguajes de programaci\u00f3n y entornos de desarrollo: Racket (versi\u00f3n de Scheme, lenguaje de programaci\u00f3n funcional) Swift (lenguaje multiparadigma creado por Apple, con conceptos modernos de programaci\u00f3n funcional y programaci\u00f3n orientada a objetos) Cada pr\u00e1ctica consistir\u00e1 en la resoluci\u00f3n de una hoja de ejercicios con 5 o 6 peque\u00f1os problemas de programaci\u00f3n relacionados con la teor\u00eda vista durante la semana. Se realizar\u00e1n 11 sesiones de ejercicios de pr\u00e1cticas de una semana de duraci\u00f3n y 2 seminarios sobre los anteriores lenguajes de programaci\u00f3n. La hoja de ejercicios estar\u00e1 disponible el viernes y se dispondr\u00e1 de toda la semana siguiente para su realizaci\u00f3n y su entrega en Moodle. La entrega se cerrar\u00e1 el viernes por la noche. En la clase de pr\u00e1cticas se trabajar\u00e1 en esa hoja de ejercicios. Durante la sesi\u00f3n de pr\u00e1cticas el profesor estar\u00e1 disponible para resolver dudas y dar pistas sobre c\u00f3mo atacar los problemas. Tambi\u00e9n durante la semana se podr\u00e1n consultar las dudas que puedan surgir en el foro de la asignatura (en Moodle) y con tutor\u00edas a los profesores. Es preferible el foro, porque de esta forma las contestaciones y aclaraciones ser\u00e1n compartidas con el resto de compa\u00f1eros. Al final de la semana de realizaci\u00f3n de la hoja de ejercicios se publicar\u00e1 su soluci\u00f3n. Cuestionarios \u00b6 Al comienzo de cada sesi\u00f3n de pr\u00e1cticas se realizar\u00e1 un cuestionario sobre la hoja de ejercicios de la semana anterior . La superaci\u00f3n de los cuestionarios de cada bloque sumar\u00e1 0,5 puntos a la nota del parcial de ese bloque (ver el apartado de evaluaci\u00f3n). Los cuestionarios constar\u00e1n de 3 preguntas cortas sobre la pr\u00e1ctica y sobre los conceptos de teor\u00eda asociados . Dentro de cada bloque tem\u00e1tico deber\u00e1s haber aprobado los cuestionarios previos para poder realizar el cuestionario actual . Se permitir\u00e1 recuperar los cuestionarios previos suspendidos, una vez por sesi\u00f3n y siempre dentro del tiempo destinado a la realizaci\u00f3n de los mismos. S\u00f3lo se podr\u00e1n recuperar cuestionarios del bloque tem\u00e1tico actual. El cuestionario se realizar\u00e1 en Moodle y se evaluar\u00e1 con una calificaci\u00f3n de 0 a 10 (aprobando con una nota >= 5). Constar\u00e1 de 3 preguntas de igual puntuaci\u00f3n (3,333 puntos). En cada pregunta se permitir\u00e1n 3 intentos y cada intento fallado descontar\u00e1 1/3 de la puntuaci\u00f3n de la pregunta (1,111 puntos). De esta forma, para aprobar un cuestionario se podr\u00e1n fallar como m\u00e1ximo 4 intentos. Tendr\u00e1s que tener cuidado al escribir las respuestas de los cuestionarios. Deber\u00e1s escribirlas de forma totalmente correcta, incluyendo los espacios en blanco . Deber\u00e1s fijarte en los ejemplos que proporcionamos en teor\u00eda y en los resultados de la ejecuci\u00f3n de expresiones en el int\u00e9rprete del lenguaje. A continuaci\u00f3n puedes ver ejemplos incorrectos y correctos de contestaci\u00f3n de un cuestionario. Normas para realizaci\u00f3n de los cuestionarios \u00b6 Cada cuestionario tendr\u00e1 una duraci\u00f3n m\u00e1xima de 10 minutos. La realizaci\u00f3n de cuestionarios comenzar\u00e1 puntualmente a los 5 minutos de empezar la clase de pr\u00e1cticas y durar\u00e1 20 minutos, para permitir recuperar alg\u00fan cuestionario anterior suspendido. Deber\u00e1s realizar los cuestionarios en el grupo de pr\u00e1cticas en el que est\u00e1 matriculado y en el aula en la que se imparte ese grupo de pr\u00e1cticas. Se deber\u00e1n realizar en los ordenadores del aula. De forma excepcional, si no hay ordenadores libres, podr\u00e1s utilizar tu port\u00e1til, pero sentado cerca de la mesa del profesor y con la pantalla en su direcci\u00f3n. Durante la realizaci\u00f3n del cuestionario \u00fanicamente deber\u00e1s tener abierta la ventana del navegador en la que est\u00e1s realiz\u00e1ndolo. Est\u00e1 prohibido abrir cualquier otra ventana o aplicaci\u00f3n. Durante la realizaci\u00f3n del cuestionario no deber\u00e1s tener acceso al m\u00f3vil. Una vez realizado un cuestionario, quedar\u00e1 bloqueado y no se podr\u00e1 repetir hasta que haya pasado exactamente una semana. Por ello es muy importante que todas las semanas asistas al mismo grupo de pr\u00e1cticas. Una vez comenzados los cuestionarios no ser\u00e1 posible realizar cambios de grupo en las pr\u00e1cticas. Comportamiento indebido en la realizaci\u00f3n de cuestionarios \u00b6 Cualquiera de las siguientes acciones se consideran un comportamiento indebido, y se penalizar\u00e1n con la anulaci\u00f3n de todos los cuestionarios del bloque tem\u00e1tico: Realizar un cuestionario fuera de tu grupo de pr\u00e1cticas. Tener abiertas otras aplicaciones mientras se est\u00e1 realizando el cuestionario. Realizar fotograf\u00edas o capturas de pantallas de las preguntas del cuestionario. Uso del software iTALC \u00b6 Durante el desarrollo de las sesiones pr\u00e1cticas es obligatorio usar el ordenador del aula y no el port\u00e1til personal. El profesor de pr\u00e1cticas abrir\u00e1 el programa iTALC, con el que podr\u00e1 comprobar c\u00f3mo est\u00e1is desarrollando los ejercicios y podr\u00e1 haceros recomendaciones cuando lo considere oportuno. Adem\u00e1s se utilizar\u00e1 iTALC para vigilar la contestaci\u00f3n de los cuestionarios. Horarios \u00b6 La distribuci\u00f3n de grupos del curso 2019-20 es la siguiente: Evaluaci\u00f3n \u00b6 Convocatoria normal C3 (evaluaci\u00f3n continua) \u00b6 Para cada bloque tem\u00e1tico se realizar\u00e1 un examen parcial. En cada bloque tem\u00e1tico se pueden obtener 0,5 puntos adicionales que se suman a la nota del parcial. Los puntos adicionales se obtienen si se aprueban n-1 cuestionarios del bloque. Cada bloque pondera 1/3 en la nota final. No hay nota m\u00ednima en ning\u00fan bloque. La siguiente figura resume la evaluaci\u00f3n: Sobre los dispositivos m\u00f3viles Como norma b\u00e1sica de todas las pruebas de evaluaci\u00f3n de esta asignatura (cuestionarios y ex\u00e1menes escritos), durante la realizaci\u00f3n de los mismos no est\u00e1 permitido que llev\u00e9is encima ning\u00fan dispositivo con conexi\u00f3n a internet (smart phones, smart watches, tablets, etc). Antes de empezar la prueba, se deber\u00e1n dejar dentro de las mochilas, y \u00e9stas en el suelo. En caso de no cumplir alguna esta norma, la prueba queda invalidada con calificaci\u00f3n de 0. Convocatoria extraordinaria C4 \u00b6 En la convocatoria extraordinaria se realizar\u00e1 un examen final sobre todos los bloques tem\u00e1ticos cuya calificaci\u00f3n representar\u00e1 el 100% de la nota de la asignatura. Consejos para aprender con \u00e9xito los contenidos de la asignatura \u00b6 El consejo fundamental para aprobar la asignatura es trabajar todas las semanas e intentar seguir el ritmo de la asignatura . Los conceptos de la asignatura se van construyendo de forma progresiva y lo visto en una semana depende muchas veces de lo aprendido en semanas anteriores. \u00bfC\u00f3mo estudiar estos conceptos? Con la excepci\u00f3n de algunos temas y apartados concretos (como la historia de los lenguajes de programaci\u00f3n o las caracter\u00edsticas de los distintos paradigmas) la asignatura es fundamentalmente pr\u00e1ctica. Cuando hablamos de estudiar los ejemplos de c\u00f3digo queremos decir entenderlos, no aprenderlos de memoria . No tiene sentido aprender de memoria los ejercicios y los ejemplos vistos en clase. Hay que trabajarlos . Eso significa que, primero, hay que entenderlos sobre el papel y muy importante hay que probar todos los ejemplos en el int\u00e9rprete . Y probar significa escribir los ejemplos y jugar con ellos, proponiendo peque\u00f1as variantes, pregunt\u00e1ndose \u00bfqu\u00e9 pasar\u00eda si...? y prob\u00e1ndolo. En cuanto a las pr\u00e1cticas y a los ejercicios propuestos es fundamental pelearse con ellos e intentar hacerlos por uno mismo sin ver ninguna soluci\u00f3n . Es la \u00fanica forma de aprender: probando, equivoc\u00e1ndose y encontrando la soluci\u00f3n por uno mismo. A la hora de enfrentarse con un problema es fundamental tambi\u00e9n usar l\u00e1piz y papel para probar enfoques y encontrar la soluci\u00f3n m\u00e1s sencilla sobre el papel antes de probarla en el int\u00e9rprete. Los ejercicios que proponemos no son excesivamente complicados. Todos se resuelven con muy pocas l\u00edneas de c\u00f3digo y su codificaci\u00f3n en el ordenador no tiene dificultad, una vez que se ha encontrado la soluci\u00f3n que lo resuelve. Al usar el l\u00e1piz y papel tambi\u00e9n estar\u00e1s practicando una situaci\u00f3n similar a la que te vas a encontrar en los ex\u00e1menes de la asignatura. Resumiendo: trabajar todas las semanas, hacer uno mismo todos los ejercicios y no desanimarse ni descolgarse. Son muy interesantes algunos comentarios de antiguos estudiantes que han aprobado la asignatura. C\u00f3mo dominar los conceptos Para superar la asignatura lo que hice fue estudiar mucho. Hay que practicar y sobre todo entender los ejercicios y no sabe\u0301rselos de memoria. Una vez dominados los ejercicios yo mismo me propuse variantes de los mismos. Asi\u0301 es como se domina. El problema del cambio de paradigma El problema principal de la asignatura es enfrentarse a un cambio del paradigma de programacio\u0301n.\" Trabajar d\u00eda a d\u00eda Lo que hice fue tratar de llevar al di\u0301a toda la asignatura, adema\u0301s de trabajar con material adicional para poder ampliar y profundizar conocimientos. LPP es una asignatura de fondo en la que tienes que mantener el ritmo de trabajo de principio a fin de cuatrimestre.\" No copiar las pr\u00e1cticas El mayor problema que creo que existe es que muchas personas se relajan y se copian las pra\u0301cticas en cuanto les resultan un poco difi\u0301ciles o les lleva algo mas del tiempo que les gustari\u0301a. Esta asignatura si no haces tu los ejercicios y te peleas con ellos es pra\u0301cticamente imposible de sacar. No memorizar Otra de las cosas es que tienes que cambiar la forma de estudiar, no vale memorizar, ni hacer muchos ejercicios sin ma\u0301s. Tienes que entender bien el funcionamiento de la recursio\u0301n para luego poder practicar con ejercicios, sino no sirve. [...] En mi opinio\u0301n el problema de LPP para mucha gente es que para los exa\u0301menes se memorizan los ejercicios de pra\u0301cticas de las soluciones que se dan en clase. Plantearse uno mismo problemas Los problemas que me encontre\u0301 a la hora de cursar LPP fue que eran dos lenguajes completamente nuevos, otro tipo de programacio\u0301n que nunca habi\u0301a visto, otra forma de estudiar distinta. Para poder superarla simplemente tienes que hacer ejercicios y tambie\u0301n plantearte tu\u0301 mismo nuevos ejercicios. Bibliograf\u00eda \u00b6 En Moodle se publican los apuntes de la asignatura, con ejercicios, explicaciones y ejemplos de todos los conceptos estudiados, tanto en teor\u00eda como en pr\u00e1ctica. Para ampliar algunos conceptos se recomiendan los dos siguientes manuales: Harold Abelson y Gerald Jay Sussman, Structure and Interpretation of Computer Programs , MIT Press, 1996 Enlace a la edici\u00f3n on-line Signatura en la Biblioteca Polit\u00e9cnica: I.06/ABE/STR Apple, The Swift Programming Language (Swift 4.2) , 2019 Web Lenguajes y Paradigmas de Programaci\u00f3n, curso 2019-20 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Domingo Gallardo, Cristina Pomares, Antonio Bot\u00eda, Francisco Mart\u00ednez","title":"Descripci\u00f3n de la asignatura"},{"location":"teoria/tema00-descripcion-asignatura/tema00-descripcion-asignatura.html#lenguajes-y-paradigmas-de-programacion","text":"","title":"Lenguajes y Paradigmas de Programaci\u00f3n"},{"location":"teoria/tema00-descripcion-asignatura/tema00-descripcion-asignatura.html#datos-academicos-de-la-asignatura","text":"Departamento de Ciencia de la Computaci\u00f3n e Inteligencia Artificial 6 cr\u00e9ditos ECTS : 1 clase de teor\u00eda de 2 h. y 1 clase de pr\u00e1cticas de 2 h. a la semana Profesores : Antonio Bot\u00eda ( e-mail ): Grupos de pr\u00e1cticas: 2, 9 y 401 Domingo Gallardo ( e-mail ): Profesor coordinador de la asignatura. Grupos de teor\u00eda: 3, 4 y 40. Grupos de pr\u00e1cticas: 402 Francisco Mart\u00ednez ( e-mail ): Grupos de pr\u00e1cticas: 4, 5, 6 y 8 Cristina Pomares ( e-mail ): Grupos de teor\u00eda: 1 y 2. Grupos de pr\u00e1cticas: 1, 3 y 7.","title":"Datos acad\u00e9micos de la asignatura"},{"location":"teoria/tema00-descripcion-asignatura/tema00-descripcion-asignatura.html#recursos-de-la-asignatura","text":"Ficha de la asignatura Apuntes de la asignatura (teor\u00eda, seminarios y pr\u00e1cticas) Sitio Moodle abierto y accesible a toda la comunidad educativa, contiene los apuntes, transparencias, pr\u00e1cticas y otros materiales docentes Foro de consultas y anuncios en el sitio Moodle (s\u00f3lo accesible a estudiantes)","title":"Recursos de la asignatura"},{"location":"teoria/tema00-descripcion-asignatura/tema00-descripcion-asignatura.html#objetivos-y-competencias","text":"Objetivos : \u00bfQu\u00e9 elementos son comunes a los lenguajes de programaci\u00f3n? \u00bfQu\u00e9 familias o paradigmas de lenguajes podemos identificar? \u00bfQu\u00e9 es la programaci\u00f3n funcional? \u00bfC\u00f3mo es un lenguaje multi-paradigma que combina la programaci\u00f3n funcional y la programaci\u00f3n orientada a objetos? Dominando estos contenidos ser\u00e1 mucho m\u00e1s f\u00e1cil aprender nuevos lenguajes de programaci\u00f3n, identificar sus aspectos esenciales e incluso ser capaz de dise\u00f1ar lenguajes espec\u00edficos orientados a dominios concretos. Competencias : Conocer y diferenciar las caracter\u00edsticas de los distintos paradigmas de programaci\u00f3n (programaci\u00f3n funcional, procedural y orientada a objetos) e identificarlas en lenguajes de programaci\u00f3n concretos. Diferenciar entre tiempo de ejecuci\u00f3n y tiempo de compilaci\u00f3n en distintos \u00e1mbitos: detecci\u00f3n de errores o definici\u00f3n, creaci\u00f3n o \u00e1mbito de vida de variables. Conocer los principios b\u00e1sicos de la programaci\u00f3n funcional: recursi\u00f3n, inmutabilidad, funciones como objetos de primera clase, funciones de orden superior, expresiones lambda (clausuras). Conocer los problemas derivados del uso de la mutaci\u00f3n en los lenguajes de programaci\u00f3n imperativos y la forma de trabajar con estructuras inmutables en lenguajes declarativos y funcionales. Utilizar la abstracci\u00f3n y la recursi\u00f3n para dise\u00f1ar correctamente procedimientos y estructuras de datos (listas y \u00e1rboles). Ser capaz de dise\u00f1ar, implementar y corregir programas funcionales, en concreto utilizando el lenguaje de programaci\u00f3n Scheme. Ser capaz de implementar programas sencillos en Swift, en los que se utilicen las caracter\u00edsticas multi-paradigma del lenguaje. Comparar el paradigma orientado a objetos con el paradigma procedural cl\u00e1sico, reconociendo las ventajas que aporta en cuanto a abstracci\u00f3n, reutilizaci\u00f3n y modificaci\u00f3n de c\u00f3digo.","title":"Objetivos y competencias"},{"location":"teoria/tema00-descripcion-asignatura/tema00-descripcion-asignatura.html#temario","text":"","title":"Temario"},{"location":"teoria/tema00-descripcion-asignatura/tema00-descripcion-asignatura.html#bloques-tematicos","text":"La asignatura se divide en 3 bloques tem\u00e1ticos, todos ellos de igual duraci\u00f3n, en los que se utilizar\u00e1 el lenguaje de programaci\u00f3n que aparece entre par\u00e9ntesis: Programaci\u00f3n funcional (Scheme): temas 1 y 2 Procesos y estructuras recursivas (Scheme): temas 3 y 4 Programaci\u00f3n funcional en Swift y programaci\u00f3n orientada a objetos (Swift): temas 5 y 6 Los lenguajes de programaci\u00f3n se introducir\u00e1n mediante seminarios impartidos en las clases de pr\u00e1cticas. Seminario 1. El lenguaje de programaci\u00f3n Scheme : Primitivas. Tipos de datos b\u00e1sicos. S\u00edmbolos. Cadenas. Listas. Definici\u00f3n de funciones. Seminario 2. El lenguaje de programaci\u00f3n Swift . Int\u00e9rprete y scripts. Tipos de datos b\u00e1sicos. Operadores. Estructuras de control. \u00c1mbito de variables. Tipos de datos compuestos: tuplas, arrays y colecciones. Recorriendo colecciones. Valores mutables e inmutables. Inicializaci\u00f3n. Tipos de referencia y valor en Swift.","title":"Bloques tem\u00e1ticos"},{"location":"teoria/tema00-descripcion-asignatura/tema00-descripcion-asignatura.html#temas","text":"Tema 1. Lenguajes de programaci\u00f3n : Historia de los lenguajes de programaci\u00f3n. Elementos de los lenguajes de programaci\u00f3n. Abstracci\u00f3n. Paradigmas de programaci\u00f3n. Compiladores e int\u00e9rpretes. Tema 2. Programaci\u00f3n Funcional : Caracter\u00edsticas e historia del paradigma de Programaci\u00f3n Funcional. Diferencias con el paradigma imperativo. Caracter\u00edsticas declarativas del paradigma funcional. Definici\u00f3n de funciones. Funciones como datos de primer orden. La forma especial lambda. \u00c1mbito de variables y clausuras. Datos compuestos en Scheme: parejas. Construcci\u00f3n, recorrido y operaciones sobre listas. Listas con elementos compuestos. Listas de listas. Tema 3. Procedimientos recursivos : Dise\u00f1o de funciones recursivas. Recursi\u00f3n mutua. Procesos recursivos e iterativos. Memoization. Recursi\u00f3n y gr\u00e1ficos de tortuga. Tema 4. Estructuras recursivas : Estructuras de datos recursivas: listas estructuradas y \u00e1rboles. Tema 5. Programaci\u00f3n funcional en Swift : Lenguajes multiparadigma. Programaci\u00f3n funcional en Swift. Valores opcionales. Listas. Recursi\u00f3n pura y recursi\u00f3n por la cola. Funciones como datos de primer orden. Clausuras y funciones an\u00f3nimas. Funciones de orden superior: mappings y filtros de colecciones. Tema 6. Programaci\u00f3n Orientada a Objetos en Swift : Caracter\u00edsticas e historia del paradigma de Programaci\u00f3n Orientada a Objetos. Estructuras y clases en Swift. Herencia. Conceptos avanzados de POO en Swift: Extensiones, Protocolos y Gen\u00e9ricos. Gesti\u00f3n de errores. El calendario de temas, pr\u00e1cticas y ex\u00e1menes se puede ver en la siguiente figura.","title":"Temas"},{"location":"teoria/tema00-descripcion-asignatura/tema00-descripcion-asignatura.html#practicas","text":"Las pr\u00e1cticas son fundamentales en la asignatura y sirven para comprender, trabajar y profundizar los conceptos y competencias estudiados en las clases de teor\u00eda. Para el desarrollo de las pr\u00e1cticas utilizaremos los siguientes lenguajes de programaci\u00f3n y entornos de desarrollo: Racket (versi\u00f3n de Scheme, lenguaje de programaci\u00f3n funcional) Swift (lenguaje multiparadigma creado por Apple, con conceptos modernos de programaci\u00f3n funcional y programaci\u00f3n orientada a objetos) Cada pr\u00e1ctica consistir\u00e1 en la resoluci\u00f3n de una hoja de ejercicios con 5 o 6 peque\u00f1os problemas de programaci\u00f3n relacionados con la teor\u00eda vista durante la semana. Se realizar\u00e1n 11 sesiones de ejercicios de pr\u00e1cticas de una semana de duraci\u00f3n y 2 seminarios sobre los anteriores lenguajes de programaci\u00f3n. La hoja de ejercicios estar\u00e1 disponible el viernes y se dispondr\u00e1 de toda la semana siguiente para su realizaci\u00f3n y su entrega en Moodle. La entrega se cerrar\u00e1 el viernes por la noche. En la clase de pr\u00e1cticas se trabajar\u00e1 en esa hoja de ejercicios. Durante la sesi\u00f3n de pr\u00e1cticas el profesor estar\u00e1 disponible para resolver dudas y dar pistas sobre c\u00f3mo atacar los problemas. Tambi\u00e9n durante la semana se podr\u00e1n consultar las dudas que puedan surgir en el foro de la asignatura (en Moodle) y con tutor\u00edas a los profesores. Es preferible el foro, porque de esta forma las contestaciones y aclaraciones ser\u00e1n compartidas con el resto de compa\u00f1eros. Al final de la semana de realizaci\u00f3n de la hoja de ejercicios se publicar\u00e1 su soluci\u00f3n.","title":"Pr\u00e1cticas"},{"location":"teoria/tema00-descripcion-asignatura/tema00-descripcion-asignatura.html#cuestionarios","text":"Al comienzo de cada sesi\u00f3n de pr\u00e1cticas se realizar\u00e1 un cuestionario sobre la hoja de ejercicios de la semana anterior . La superaci\u00f3n de los cuestionarios de cada bloque sumar\u00e1 0,5 puntos a la nota del parcial de ese bloque (ver el apartado de evaluaci\u00f3n). Los cuestionarios constar\u00e1n de 3 preguntas cortas sobre la pr\u00e1ctica y sobre los conceptos de teor\u00eda asociados . Dentro de cada bloque tem\u00e1tico deber\u00e1s haber aprobado los cuestionarios previos para poder realizar el cuestionario actual . Se permitir\u00e1 recuperar los cuestionarios previos suspendidos, una vez por sesi\u00f3n y siempre dentro del tiempo destinado a la realizaci\u00f3n de los mismos. S\u00f3lo se podr\u00e1n recuperar cuestionarios del bloque tem\u00e1tico actual. El cuestionario se realizar\u00e1 en Moodle y se evaluar\u00e1 con una calificaci\u00f3n de 0 a 10 (aprobando con una nota >= 5). Constar\u00e1 de 3 preguntas de igual puntuaci\u00f3n (3,333 puntos). En cada pregunta se permitir\u00e1n 3 intentos y cada intento fallado descontar\u00e1 1/3 de la puntuaci\u00f3n de la pregunta (1,111 puntos). De esta forma, para aprobar un cuestionario se podr\u00e1n fallar como m\u00e1ximo 4 intentos. Tendr\u00e1s que tener cuidado al escribir las respuestas de los cuestionarios. Deber\u00e1s escribirlas de forma totalmente correcta, incluyendo los espacios en blanco . Deber\u00e1s fijarte en los ejemplos que proporcionamos en teor\u00eda y en los resultados de la ejecuci\u00f3n de expresiones en el int\u00e9rprete del lenguaje. A continuaci\u00f3n puedes ver ejemplos incorrectos y correctos de contestaci\u00f3n de un cuestionario.","title":"Cuestionarios"},{"location":"teoria/tema00-descripcion-asignatura/tema00-descripcion-asignatura.html#normas-para-realizacion-de-los-cuestionarios","text":"Cada cuestionario tendr\u00e1 una duraci\u00f3n m\u00e1xima de 10 minutos. La realizaci\u00f3n de cuestionarios comenzar\u00e1 puntualmente a los 5 minutos de empezar la clase de pr\u00e1cticas y durar\u00e1 20 minutos, para permitir recuperar alg\u00fan cuestionario anterior suspendido. Deber\u00e1s realizar los cuestionarios en el grupo de pr\u00e1cticas en el que est\u00e1 matriculado y en el aula en la que se imparte ese grupo de pr\u00e1cticas. Se deber\u00e1n realizar en los ordenadores del aula. De forma excepcional, si no hay ordenadores libres, podr\u00e1s utilizar tu port\u00e1til, pero sentado cerca de la mesa del profesor y con la pantalla en su direcci\u00f3n. Durante la realizaci\u00f3n del cuestionario \u00fanicamente deber\u00e1s tener abierta la ventana del navegador en la que est\u00e1s realiz\u00e1ndolo. Est\u00e1 prohibido abrir cualquier otra ventana o aplicaci\u00f3n. Durante la realizaci\u00f3n del cuestionario no deber\u00e1s tener acceso al m\u00f3vil. Una vez realizado un cuestionario, quedar\u00e1 bloqueado y no se podr\u00e1 repetir hasta que haya pasado exactamente una semana. Por ello es muy importante que todas las semanas asistas al mismo grupo de pr\u00e1cticas. Una vez comenzados los cuestionarios no ser\u00e1 posible realizar cambios de grupo en las pr\u00e1cticas.","title":"Normas para realizaci\u00f3n de los cuestionarios"},{"location":"teoria/tema00-descripcion-asignatura/tema00-descripcion-asignatura.html#comportamiento-indebido-en-la-realizacion-de-cuestionarios","text":"Cualquiera de las siguientes acciones se consideran un comportamiento indebido, y se penalizar\u00e1n con la anulaci\u00f3n de todos los cuestionarios del bloque tem\u00e1tico: Realizar un cuestionario fuera de tu grupo de pr\u00e1cticas. Tener abiertas otras aplicaciones mientras se est\u00e1 realizando el cuestionario. Realizar fotograf\u00edas o capturas de pantallas de las preguntas del cuestionario.","title":"Comportamiento indebido en la realizaci\u00f3n de cuestionarios"},{"location":"teoria/tema00-descripcion-asignatura/tema00-descripcion-asignatura.html#uso-del-software-italc","text":"Durante el desarrollo de las sesiones pr\u00e1cticas es obligatorio usar el ordenador del aula y no el port\u00e1til personal. El profesor de pr\u00e1cticas abrir\u00e1 el programa iTALC, con el que podr\u00e1 comprobar c\u00f3mo est\u00e1is desarrollando los ejercicios y podr\u00e1 haceros recomendaciones cuando lo considere oportuno. Adem\u00e1s se utilizar\u00e1 iTALC para vigilar la contestaci\u00f3n de los cuestionarios.","title":"Uso del software iTALC"},{"location":"teoria/tema00-descripcion-asignatura/tema00-descripcion-asignatura.html#horarios","text":"La distribuci\u00f3n de grupos del curso 2019-20 es la siguiente:","title":"Horarios"},{"location":"teoria/tema00-descripcion-asignatura/tema00-descripcion-asignatura.html#evaluacion","text":"","title":"Evaluaci\u00f3n"},{"location":"teoria/tema00-descripcion-asignatura/tema00-descripcion-asignatura.html#convocatoria-normal-c3-evaluacion-continua","text":"Para cada bloque tem\u00e1tico se realizar\u00e1 un examen parcial. En cada bloque tem\u00e1tico se pueden obtener 0,5 puntos adicionales que se suman a la nota del parcial. Los puntos adicionales se obtienen si se aprueban n-1 cuestionarios del bloque. Cada bloque pondera 1/3 en la nota final. No hay nota m\u00ednima en ning\u00fan bloque. La siguiente figura resume la evaluaci\u00f3n: Sobre los dispositivos m\u00f3viles Como norma b\u00e1sica de todas las pruebas de evaluaci\u00f3n de esta asignatura (cuestionarios y ex\u00e1menes escritos), durante la realizaci\u00f3n de los mismos no est\u00e1 permitido que llev\u00e9is encima ning\u00fan dispositivo con conexi\u00f3n a internet (smart phones, smart watches, tablets, etc). Antes de empezar la prueba, se deber\u00e1n dejar dentro de las mochilas, y \u00e9stas en el suelo. En caso de no cumplir alguna esta norma, la prueba queda invalidada con calificaci\u00f3n de 0.","title":"Convocatoria normal C3 (evaluaci\u00f3n continua)"},{"location":"teoria/tema00-descripcion-asignatura/tema00-descripcion-asignatura.html#convocatoria-extraordinaria-c4","text":"En la convocatoria extraordinaria se realizar\u00e1 un examen final sobre todos los bloques tem\u00e1ticos cuya calificaci\u00f3n representar\u00e1 el 100% de la nota de la asignatura.","title":"Convocatoria extraordinaria C4"},{"location":"teoria/tema00-descripcion-asignatura/tema00-descripcion-asignatura.html#consejos-para-aprender-con-exito-los-contenidos-de-la-asignatura","text":"El consejo fundamental para aprobar la asignatura es trabajar todas las semanas e intentar seguir el ritmo de la asignatura . Los conceptos de la asignatura se van construyendo de forma progresiva y lo visto en una semana depende muchas veces de lo aprendido en semanas anteriores. \u00bfC\u00f3mo estudiar estos conceptos? Con la excepci\u00f3n de algunos temas y apartados concretos (como la historia de los lenguajes de programaci\u00f3n o las caracter\u00edsticas de los distintos paradigmas) la asignatura es fundamentalmente pr\u00e1ctica. Cuando hablamos de estudiar los ejemplos de c\u00f3digo queremos decir entenderlos, no aprenderlos de memoria . No tiene sentido aprender de memoria los ejercicios y los ejemplos vistos en clase. Hay que trabajarlos . Eso significa que, primero, hay que entenderlos sobre el papel y muy importante hay que probar todos los ejemplos en el int\u00e9rprete . Y probar significa escribir los ejemplos y jugar con ellos, proponiendo peque\u00f1as variantes, pregunt\u00e1ndose \u00bfqu\u00e9 pasar\u00eda si...? y prob\u00e1ndolo. En cuanto a las pr\u00e1cticas y a los ejercicios propuestos es fundamental pelearse con ellos e intentar hacerlos por uno mismo sin ver ninguna soluci\u00f3n . Es la \u00fanica forma de aprender: probando, equivoc\u00e1ndose y encontrando la soluci\u00f3n por uno mismo. A la hora de enfrentarse con un problema es fundamental tambi\u00e9n usar l\u00e1piz y papel para probar enfoques y encontrar la soluci\u00f3n m\u00e1s sencilla sobre el papel antes de probarla en el int\u00e9rprete. Los ejercicios que proponemos no son excesivamente complicados. Todos se resuelven con muy pocas l\u00edneas de c\u00f3digo y su codificaci\u00f3n en el ordenador no tiene dificultad, una vez que se ha encontrado la soluci\u00f3n que lo resuelve. Al usar el l\u00e1piz y papel tambi\u00e9n estar\u00e1s practicando una situaci\u00f3n similar a la que te vas a encontrar en los ex\u00e1menes de la asignatura. Resumiendo: trabajar todas las semanas, hacer uno mismo todos los ejercicios y no desanimarse ni descolgarse. Son muy interesantes algunos comentarios de antiguos estudiantes que han aprobado la asignatura. C\u00f3mo dominar los conceptos Para superar la asignatura lo que hice fue estudiar mucho. Hay que practicar y sobre todo entender los ejercicios y no sabe\u0301rselos de memoria. Una vez dominados los ejercicios yo mismo me propuse variantes de los mismos. Asi\u0301 es como se domina. El problema del cambio de paradigma El problema principal de la asignatura es enfrentarse a un cambio del paradigma de programacio\u0301n.\" Trabajar d\u00eda a d\u00eda Lo que hice fue tratar de llevar al di\u0301a toda la asignatura, adema\u0301s de trabajar con material adicional para poder ampliar y profundizar conocimientos. LPP es una asignatura de fondo en la que tienes que mantener el ritmo de trabajo de principio a fin de cuatrimestre.\" No copiar las pr\u00e1cticas El mayor problema que creo que existe es que muchas personas se relajan y se copian las pra\u0301cticas en cuanto les resultan un poco difi\u0301ciles o les lleva algo mas del tiempo que les gustari\u0301a. Esta asignatura si no haces tu los ejercicios y te peleas con ellos es pra\u0301cticamente imposible de sacar. No memorizar Otra de las cosas es que tienes que cambiar la forma de estudiar, no vale memorizar, ni hacer muchos ejercicios sin ma\u0301s. Tienes que entender bien el funcionamiento de la recursio\u0301n para luego poder practicar con ejercicios, sino no sirve. [...] En mi opinio\u0301n el problema de LPP para mucha gente es que para los exa\u0301menes se memorizan los ejercicios de pra\u0301cticas de las soluciones que se dan en clase. Plantearse uno mismo problemas Los problemas que me encontre\u0301 a la hora de cursar LPP fue que eran dos lenguajes completamente nuevos, otro tipo de programacio\u0301n que nunca habi\u0301a visto, otra forma de estudiar distinta. Para poder superarla simplemente tienes que hacer ejercicios y tambie\u0301n plantearte tu\u0301 mismo nuevos ejercicios.","title":"Consejos para aprender con \u00e9xito los contenidos de la asignatura"},{"location":"teoria/tema00-descripcion-asignatura/tema00-descripcion-asignatura.html#bibliografia","text":"En Moodle se publican los apuntes de la asignatura, con ejercicios, explicaciones y ejemplos de todos los conceptos estudiados, tanto en teor\u00eda como en pr\u00e1ctica. Para ampliar algunos conceptos se recomiendan los dos siguientes manuales: Harold Abelson y Gerald Jay Sussman, Structure and Interpretation of Computer Programs , MIT Press, 1996 Enlace a la edici\u00f3n on-line Signatura en la Biblioteca Polit\u00e9cnica: I.06/ABE/STR Apple, The Swift Programming Language (Swift 4.2) , 2019 Web Lenguajes y Paradigmas de Programaci\u00f3n, curso 2019-20 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Domingo Gallardo, Cristina Pomares, Antonio Bot\u00eda, Francisco Mart\u00ednez","title":"Bibliograf\u00eda"},{"location":"teoria/tema01-historia-lenguajes-programacion/tema01-historia-lenguajes-programacion.html","text":"Tema 1: Historia y conceptos de los lenguajes de programaci\u00f3n \u00b6 Historia de los lenguajes de programaci\u00f3n \u00b6 De las m\u00e1quinas de calcular a los computadores programables \u00b6 M\u00e1quina de Schickard (1623) Calculadora de Pascal (1650) Desde las primeras calculadoras mec\u00e1nicas dise\u00f1adas en el siglo XVII hasta los a\u00f1os 40 del siglo pasado se han inventado multitud de m\u00e1quinas y computadores mec\u00e1nicos, anal\u00f3gicos o electr\u00f3nicos que han intentado acelerar y mejorar la precisi\u00f3n de los c\u00e1lculos. El punto culminante de todos los enfoques mec\u00e1nicos para realizar c\u00e1lculos fue el famoso Motor Anal\u00edtico dise\u00f1ado por Charles Babbage en 1840. La diferencia fundamental con todos los artefactos anteriores es que se trataba de una m\u00e1quina de calcular programable mediante tarjetas perforadas (Babbage se inspir\u00f3 en el telar de Jackquard en el que el dise\u00f1o de los dibujos de las telas se pod\u00edan configurar usando tarjetas perforadas). La m\u00e1quina estaba dise\u00f1ada para trabajar en base 10 y se pod\u00eda conseguir que sus c\u00e1lculos realizaran saltos condicionales y bucles. Babbage trabaj\u00f3 durante m\u00e1s de 30 a\u00f1os para intentar construir la m\u00e1quina. Ten\u00eda una enorme complejidad para la \u00e9poca y necesitaba much\u00edsima financiaci\u00f3n. En 1871 muri\u00f3 habiendo podido construir s\u00f3lo una parte. La matem\u00e1tica Ada Lovelace tuvo un papel fundamental en la divulgaci\u00f3n de la m\u00e1quina, de su sistema de programaci\u00f3n y fue la primera que entendi\u00f3 sus posibilidades m\u00e1s all\u00e1 del c\u00e1lculo de f\u00f3rmulas. De forma poco habitual para la \u00e9poca, Ada fue educada en el campo de las ciencias y de las matem\u00e1ticas. A principios de 1840, con veinticico a\u00f1os, conoci\u00f3 el trabajo de Babbage y colabor\u00f3 con \u00e9l, dedic\u00e1ndose durante varios a\u00f1os a conocer y estudiar el dise\u00f1o y el funcionamiento del motor anal\u00edtico. En 1843 public\u00f3 el trabajo \"Sketch of the analytical engine invented by Charles Babbage\" en el que describe el Motor Anal\u00edtico, a\u00f1ade reflexiones propias sobre el alcance del invento y construye un ejemplo completo, con tablas y diagramas, de c\u00f3mo hacer que la m\u00e1quina produzca la secuencia de los n\u00fameros de Bernoulli. Se puede considerar estas tablas y diagramas como el primer programa de un computador . Antes de que existiera ning\u00fan computador real, en 1936, el matem\u00e1tico ingl\u00e9s Alan Turing formaliz\u00f3 la idea abstracta de computador, utilizando un modelo muy sencillo de procesamiento: una m\u00e1quina abstracta con un scanner que lee y escribe 0s y 1s de una cinta infinita (memoria) y se mueve y los escribe en funci\u00f3n de una tabla definida en la m\u00e1quina (programa). Con esta m\u00e1quina abstracta ( M\u00e1quina de Turing ) Turing explora la idea de lo computable y lo no computable. \u00bfExisten problemas no computables para los que no es posible inventar un algoritmo que los resuelva? Turing demuestra que s\u00ed y establece con su trabajo los l\u00edmites de la computaci\u00f3n. En el mismo trabajo Turing define el concepto de m\u00e1quina universal que es capaz de leer de la cinta un programa cualquiera y simular su comportamiento en otra parte de la cinta. Esta idea tuvo un profundo impacto en el desarrollo de los computadores, porque mostraba que es posible escribir programas que tomen como datos otros programas. Esto abre la puerta a la idea de los programas almacenados en memoria (ya que son otros datos m\u00e1s) y a la creaci\u00f3n de compiladores e int\u00e9rpretes. En la d\u00e9cada de 1940 hubo una explosi\u00f3n de m\u00e1quinas de computaci\u00f3n electr\u00f3nicas y electromec\u00e1nicas. Fue una d\u00e9cada prodigiosa en la que se desarrollaron tecnolog\u00edas cada vez m\u00e1s r\u00e1pidas y resistentes, y se consiguieron enormes avances en la velocidad y precisi\u00f3n de los c\u00e1lculos. A mitad de esa d\u00e9cada, en 1945, John Von Neumann , que trabajaba en la construcci\u00f3n del ENIAC , introdujo un avance fundamental. Propuso su famosa arquitectura en la que por primera vez se proponen las dos ideas claves de los computadores de prop\u00f3sito general: el programa almacenado en memoria y un conjunto de instrucciones de procesamiento que incluye el direccionamiento indirecto. Y en 1948, tres a\u00f1os despu\u00e9s, se construy\u00f3 en la universidad de Manchester el primer computador electr\u00f3nico digital de prop\u00f3sito general que utilizaba esta arquitectura (llamado Baby ). Fue dise\u00f1ado por Max Newmann usando la tecnolog\u00eda proporcionada por los ingenieros F.C. Williams y Tom Kilburn. Williams hab\u00eda inventado un dispositivo de memoria electr\u00f3nico (la v\u00e1lvula de Williams ) capaz de sustituir las lentas l\u00edneas de retardo de mercurio utilizadas hasta ese momento. La m\u00e1quina de Manchester fue el primer computador con un conjunto de instrucciones completo, capaz de realizar saltos, condicionales y direccionamiento indirecto. La primera ejecuci\u00f3n de un programa fue el 21 de junio de 1948. En ese a\u00f1o Alan Turing se incorpor\u00f3 a la universidad de Manchester, como director del Laboratorio de Computaci\u00f3n. Tres a\u00f1os despu\u00e9s, con un dise\u00f1o ampliado en el que tambi\u00e9n influy\u00f3 Turing, una versi\u00f3n mucho mayor de la m\u00e1quina se convirti\u00f3 en el primer computador disponible comercialmente, el Ferranti Mark I. El primero se instal\u00f3 en la universidad de Manchester en febrero de 1951, un mes antes que el UNIVAC I fuera entregado al Departamento de Censo de los EEUU. Se vendieron otras 10 m\u00e1quinas a Gran Breta\u00f1a, Canad\u00e1, Holanda e Italia. El primer programa complejo de Inteligencia Artificial, un jugador de damas escrito por Christopher Strachey, se ejecut\u00f3 en el verano de 1952 en el Ferranti Mark I en el Laboratorio de Computaci\u00f3n de Manchester. Strachey escribi\u00f3 el programa animado por Turing y usando el manual de programaci\u00f3n del Ferranti que Turing acababa de escribir. Turing particip\u00f3 tambi\u00e9n en el desarrollo de otros programas de IA, como un jugador de ajedrez basado en heur\u00edsticas. Los primeros lenguajes de programaci\u00f3n \u00b6 Los primeros computadores electr\u00f3nicos se programaban directamente usando el conjunto de instrucciones del procesador, en c\u00f3digo m\u00e1quina, c\u00f3digo hexadecimal El primer lenguaje de un nivel algo m\u00e1s elevado que el c\u00f3digo m\u00e1quina es el ensamblador. Comienzan a crearse los primeros programas que procesan lenguajes de programaci\u00f3n, aunque se trata de programas muy sencillos, ya que hay una relaci\u00f3n casi directa entre la notaci\u00f3n en ensamblador y el c\u00f3digo hexadecimal que produce el ensamblador. A finales de la d\u00e9cada de los 40 se empiezan a intentar resolver con los primeros computadores los primeros problemas matem\u00e1ticos distintos de operaciones num\u00e9ricas: codificaci\u00f3n y descodificaci\u00f3n, problemas combinatorios como el coloreado del mapa o problemas de ordenaci\u00f3n. Uno de los primeros algoritmos de von Neumann realiza una ordenaci\u00f3n de un conjunto de n\u00fameros. Von Neumann lo describe en una carta fechada en 1945. Utiliza el conjunto de instrucciones del EDSAC cuando todav\u00eda no se hab\u00eda construido. El programa fue estudiado por Donald Knuth en el art\u00edculo Von Neumann's first Computer Program , en donde documenta que hab\u00eda un bug en las primeras instrucciones. Es el primer bug escrito del que se tiene historia. Si Von Neumann hubiera podido ejecutar el programa en el EDSAC se hubiera dado cuenta del error y hubiera sido la primera depuraci\u00f3n de un programa. Primer programa de Von Neumann (Donald Knuth, \"Von Neumann's first Computer Program\", Journal of the ACM Computing Surveys (CSUR) Surveys, Volume 2 Issue 4, Dec. 1970, Pages 247-260) El nacimiento de los computadores comerciales \u00b6 UNIVAC El UNIVAC fue el primer computador comercial (1951). Con este computadora aparece por primera vez la figura del programador: manuales, cursos de formaci\u00f3n, ofertas de empleo, etc. UNIVAC Instalaciones comerciales del UNIVAC IBM 704 El IBM 704 fue el otro gran ordenador comercial de la d\u00e9cada de los 50. Tuvo una difusi\u00f3n mucho mayor que el UNIVAC: centros gubernamentales, universidades. Los primeros lenguajes de programaci\u00f3n de alto nivel se desarrollan para este computador. Foto IBM 704 Programando los primeros computadores El UNIVAC I era una m\u00e1quina interesante para programar, con su almacenamiento basado en l\u00edneas de retardo de mercurio y su propensi\u00f3n a fallar. Los programas se introduc\u00edan en el computador tecle\u00e1ndolos en cintas magn\u00e9ticas, una innovaci\u00f3n importante en ese tiempo. El trabajo con el IBM 704 en la Universidad de NY fue una experiencia radicalmente distinta de la del UNIVAC I. Fue construido para ejecutar aplicaciones cient\u00edficas, y su principal innovaci\u00f3n era una memoria de n\u00facleo magn\u00e9tico, reemplazando la memoria de tubos Williams del IBM 701. Tambi\u00e9n ten\u00eda una unidad aritm\u00e9tica en punto flotante. La m\u00e1quina ten\u00eda el equivalente a 128 KB de memoria principal, 32 KB de memoria secundaria y cintas magn\u00e9ticas que pod\u00eda almacenar 5 MB de datos. Operaba a 0.04 MIPS y cost\u00f3 3 millones de d\u00f3lares en 1957. George Sadowsky, My Second Computer was a UNIVAC I Los primeros lenguajes de alto nivel \u00b6 Los primeros lenguajes de alto nivel se desarrollaron a finales de la d\u00e9cada de los 50: FORTRAN en 1956 Lisp en 1958 Ambos lenguajes planteaban dos enfoques muy distintos desde el principio: FORTRAN Primer lenguaje comercial, equipo de IBM dirigido por John W. Backus Lenguaje imperativo: estado, estructuras de control, contador de programa, celdas de memoria Lenguaje compilado Lisp Lenguaje dise\u00f1ado en un departamento de investigaci\u00f3n, un equipo del MIT dirigido por John McCarthy Lenguaje funcional: funciones, recursi\u00f3n, listas, s\u00edmbolos Lenguaje interpretado FORTRAN Desarrollado por IBM para programar el IBM 704. Algunos datos: Su nombre proviene de FORmula TRANslating system . El primer manual de FORTRAN se imprime en octubre de 1956 para el IBM 704. El primer compilador se comercializa en abril de 1956. Cita de John Backus ( Wikipedia sobre FORTRAN ): Una gran parte de mi trabajo viene del hecho de que soy perezoso. No me gustaba escribir programas, y cuando estaba trabajando en el IBM 701, escribiendo programas para calcular la trayectoria de misiles, comenc\u00e9 a trabajar en un sistema de programaci\u00f3n que hiciera m\u00e1s f\u00e1cil escribir programas. John Backus Ejemplo FORTRAN Tomado del manual de FORTRAN del IBM 704 Lisp El otro lenguaje de alto nivel desarrollado en esa \u00e9poca es el Lisp. Desarrollado a finales de los 50 en el MIT por John McCarthy. Aunque hist\u00f3ricamente el nombre del lenguaje se sol\u00eda escribir con letras may\u00fasculas (LISP), posteriormente se ha popularizado el uso de la may\u00fascula s\u00f3lo para la primera letra (Lisp). Esta forma es m\u00e1s fiel al origen del nombre del lenguaje. Lisp no es un acr\u00f3nimo, sino la contracci\u00f3n de la expresi\u00f3n List Processing . El procesamiento de listas es una de las caracter\u00edsticas principales del Lisp. McCarthy explica en un art\u00edculo de 1979 la historia inicial del Lisp: [...] En el verano de 1956 durante el Dartmouth Summer Research Project on Artificial Intelligence, el primer estudio organizado de Inteligencia Artificial, tuve la idea de desarrollar un lenguaje algebraico para el procesamiento de listas. Quer\u00eda usarlo para el desarrollo de trabajo en inteligencia artificial en el IBM 704. [...] John McCarthy, History of LISP John McCarthy Uno de los primeros manuales de Lisp publicados es el manual de LISP de 1960 para el IBM 704 escrito por Phyllis A. Fox. del grupo de investigaci\u00f3n del MIT dirigido por McCarthy. Un ejemplo de c\u00f3digo Lisp: Ejemplo LISP Tomado de \" The Programming Language LISP \", MIT Press, 1964 La explosi\u00f3n de los lenguajes de programaci\u00f3n \u00b6 Desde 1954 hasta la actualidad se han documentado m\u00e1s de 2.500 (consultar en The Language List ). Entre 1952 y 1972 alrededor de 200 lenguajes. Una decena fueron realmente siginificativos y tuvieron influencia en el desarrollo de lenguajes posteriores. Genealog\u00eda de los lenguajes de programaci\u00f3n Genealog\u00eda de los LP Algunas notas sobre la genealog\u00eda: APL es un lenguaje algebraico declarativo de especificaci\u00f3n de funciones y circuitos l\u00f3gicos. Su car\u00e1cter declarativo ha tenido influencia en lenguajes como Prolog o Haskell. Lisp no s\u00f3lo es un lenguaje funcional, sino que tambi\u00e9n es el primer lenguaje interpretado, con muchas caracter\u00edsticas de tiempo de ejecuci\u00f3n y poco chequeo est\u00e1tico. En esos aspectos ha influido en lenguajes din\u00e1micos no funcionales como Python o Smalltalk. Lenguajes como Smalltalk o Objective-C tambi\u00e9n heredan de Lisp algunas caracter\u00edsticas funcionales como la posibilidad de usar un bloque de c\u00f3digo como un objeto primitivo que se crea en tiempo de ejecuci\u00f3n y que se puede asignar o pasar como par\u00e1metro. Es lo que se denomina clausura en el paradigma de programaci\u00f3n funcional. SIMULA es el primer lenguaje que define conceptos como clase u objeto. Es el origen de la programaci\u00f3n orientada a objetos est\u00e1tica y fuertemente tipeada. Lenguajes como C++, Eiffel, o Java toman esta idea. Frente a esta tendencia se encuentra otra visi\u00f3n de la programaci\u00f3n orientada a objetos de lenguajes como Smalltalk u Objective-C en la que se enfatiza m\u00e1s aspectos din\u00e1micos como el paso de mensajes o la modificaci\u00f3n de clases en tiempo de ejecuci\u00f3n. Algunos lenguajes importantes y su fecha de creaci\u00f3n 1950-1960 1970 1980 1990 2000 1957 FORTRAN 1970 Pascal 1980 Smalltalk-80 1990 Haskell 2000 C# 1958 ALGOL 1972 Prolog 1983 Objective-C 1991 Python 2003 Scala 1960 Lisp 1972 C 1983 Ada 1993 Ruby 2003 Groovy 1960 COBOL 1975 Scheme 1986 C++ 1995 Java 2009 Go 1962 APL 1975 Modula 1986 Eiffel 1995 Racket 2014 Swift 1964 BASIC 1987 Perl 1967 SIMULA Los creadores de los LPs Si comprobamos la historia de los lenguajes de programaci\u00f3n, podemos clasificar a sus creadores en tres grandes categor\u00edas: Investigadores trabajando en empresas ( Backus /IBM-FORTRAN, Gosling /Sun-Java) Investigadores en universidades y departamentos de Inform\u00e1tica ( McCarthy /MIT-Lisp, Wirth /ETH-Pascal, Odersky /EHT-Scala) Desarrolladores open source que distribuyen su trabajo a la comunidad ( Wall /Perl, Matsumoto /Ruby) Lenguajes de programaci\u00f3n en la actualidad \u00b6 El \u00edndice TIOBE es un indicador de la popularidad de los lenguajes de programaci\u00f3n. El \u00edndice se actualiza una vez al mes. Las puntaciones se basan en estad\u00edsticas no reveladas que incluyen el n\u00famero de ingenieros en todo el mundo, cursos y aplicaciones desarrolladas. Tambi\u00e9n se utilizan resultados obtenidos en los motores de b\u00fasqueda m\u00e1s usados. El \u00edndice TIOBE no trata de medir el n\u00famero de l\u00edneas escritas en los lenguajes de programaci\u00f3n sino su popularidad e importancia en la comunidad. Lista TIOBE Tambi\u00e9n es muy interesante comprobar la evoluci\u00f3n de los 10 lenguajes m\u00e1s populares en los \u00faltimos 10 a\u00f1os. Evoluci\u00f3n TIOBE La evoluci\u00f3n no se detiene Es interesante comprobar que cada vez es m\u00e1s f\u00e1cil desarrollar nuevos lenguajes de programaci\u00f3n. Las t\u00e9cnicas y herramientas de procesamiento de lenguajes se han popularizado cada vez m\u00e1s y son accesibles a mayor n\u00famero de personas. Los lenguajes ya no s\u00f3lo se crean en departamentos con un gran n\u00famero de investigadores, sino tambi\u00e9n en comunidades open source formadas por voluntarios interesados y motivados Ejemplos de nuevos lenguajes y sus creadores: Ruby Yukihiro Matsumoto Ruby ( Wikipedia ), un lenguaje de programaci\u00f3n ideado en 1993 por el desarrollador japon\u00e9s Yukihiro Matsumoto Lenguaje multi-paradigma interpretado y muy expresivo que actualmente se utiliza tanto para desarrollar aplicaciones web como videojuegos. Proyecto vivo, cada a\u00f1o aparecen nuevas versiones Scala Martin Odersky Scala ( Wikipedia ), dise\u00f1ado en 2003 por el profesor alem\u00e1n Martin Odersky Respuesta a los problemas de los lenguajes tradicionales imperativos para manejar la concurrencia Est\u00e1 implementado sobre Java y corre en la M\u00e1quina Virtual Java Go Ken Thompson Go ( Wikipedia ), el nuevo lenguaje de programaci\u00f3n de Google lanzado en 2009 Desarrollado, entre otros, por Ken Thompson, uno de los padres del UNIX Una mezcla de C y Python que intenta conseguir un lenguaje de programaci\u00f3n de sistemas muy eficiente, expresivo y tambi\u00e9n multiparadigma. Swift Chris Lattner Swift ( Wikipedia ), el nuevo lenguaje de programaci\u00f3n de Apple lanzado en 2014 Proyecto open source en el que se puede observar su evoluci\u00f3n y roadmap futuro Desarrollado, entre otros, por Chris Lattner , autor del sistema LLVM Compiler Infrastructure , conjunto de compilador, depurador, optimizador, etc. de c\u00f3digo C, C++ y Objective-C. Lenguaje moderno, multiparadigma (programaci\u00f3n orientada a objetos y funcional) fuertemente tipeado y compilado. Elementos de los lenguajes de programaci\u00f3n \u00b6 Definici\u00f3n de la Encyclopedia of Computer Science \u00b6 Un lenguaje de programaci\u00f3n es un conjunto de caracteres, reglas para combinarlos y reglas para especificar sus efectos cuando sean ejecutados por un computador, que tienen las siguientes cuatro caracter\u00edsticas: No requiere ning\u00fan conocimiento de c\u00f3digo m\u00e1quina por parte del usuario. Tiene independencia de la m\u00e1quina. Se traduce a lenguaje m\u00e1guina. Utiliza una notaci\u00f3n que es m\u00e1s cercana al problema espec\u00edfico que se est\u00e1 resolviendo que al c\u00f3digo m\u00e1quina. Definici\u00f3n de Abelson y Sussman \u00b6 Vamos a estudiar la idea de un proceso computacional . Los procesos computacionales son seres abstractos que habitan los computadores. Cuando est\u00e1n en marcha, los procesos manipulan otras cosas abstractas denominadas datos . La evoluci\u00f3n de un proceso est\u00e1 dirigida por un patr\u00f3n de reglas denominado un programa. [...] Y otra idea fundamental Un lenguaje de programaci\u00f3n potente es m\u00e1s que s\u00f3lo una forma de pedir a un computador que realice tareas. El lenguaje tambi\u00e9n sirve como un marco dentro del que organizamos nuestras ideas acerca de los procesos. As\u00ed, cuando describimos un lenguaje, deber\u00edamos prestar atenci\u00f3n particular a los medios que proporciona el lenguaje para combinar ideas simples para formar ideas m\u00e1s complejas. Caracter\u00edsticas de un LP \u00b6 Define un proceso que se ejecuta en un computador Es de alto nivel, cercano a los problemas que se quieren resolver (abstracci\u00f3n) Permite construir nuevas abstracciones que se adapten al dominio que se programa Elementos de un LP \u00b6 Para Abelson y Sussman, todos los lenguajes de progamaci\u00f3n permiten combinar ideas simples en ideas m\u00e1s complejas mediante los siguientes tres mecanismos Expresiones primitivas que representan las entidades m\u00e1s simples del lenguaje Mecanismos de combinaci\u00f3n con los que se construyen elementos compuestos a partir de elementos m\u00e1s simples Mecanismos de abstracci\u00f3n con los que dar nombre a los elementos compuestos y manipularlos como unidades Sintaxis y sem\u00e1ntica \u00b6 Sintaxis : conjunto de reglas que definen qu\u00e9 expresiones de texto son correctas. Por ejemplo, en C todas las sentencias deben terminar en ';'. Sem\u00e1ntica : conjunto de reglas que define cu\u00e1l ser\u00e1 el resultado de la ejecuci\u00f3n de un programa en el computador. Los lenguajes son para las personas \u00b6 Los lenguajes de programaci\u00f3n deben ser precisos, deben poder traducirse sin ambig\u00fcedad en lenguaje m\u00e1quina para que sean ejecutados por computadores. Pero deben ser utilizados (le\u00eddos, comentados, probados, etc.) por personas. La programaci\u00f3n es una actividad colaborativa y debe basarse en la comunicaci\u00f3n. Importancia del aprendizaje de t\u00e9cnicas de LPs \u00b6 Es importante conocer c\u00f3mo funciona \"por dentro\" un lenguaje de programaci\u00f3n y sus caracter\u00edsticas comparadas. Mejora el uso del lenguaje de programaci\u00f3n Incrementa el vocabulario de los elementos de programaci\u00f3n Permite una mejor elecci\u00f3n del lenguaje de programaci\u00f3n Mejora la habilidad para desarrollar programas efectivos y eficientes Facilita el aprendizaje de un nuevo lenguaje de programaci\u00f3n Facilita el dise\u00f1o de nuevos lenguajes de programaci\u00f3n Abstracci\u00f3n \u00b6 Una misi\u00f3n fundamental de los lenguajes de programaci\u00f3n es proporcionar herramientas que sirvan para construir abstracciones. Por ejemplo, estamos construyendo una abstracci\u00f3n cuando damos un nombre a una entidad del lenguaje (una variable, una funci\u00f3n, una clase, etc.). Escoger un buen nombre para los elementos que vamos construyendo en nuestro programas es fundamental para conseguir un c\u00f3digo legible y reutilizable. Modelar como una actividad fundamental \u00b6 Para escribir un programa que preste unos servicios es fundamental modelar el dominio sobre el que va a trabajar Es necesario definir distintas abstracciones (tanto APIs, como datos) que nos permitan tratar sus elementos y comunicarnos correctamente con los usuarios que van a utilizar el programa. Las abstracciones que vamos construyendo van apoy\u00e1ndose unas en otras y permiten hacer compresible y comunicable un problema complejo Ejemplo: el modelado del funcionamiento de una biblioteca contiene abstracciones como \"libros\", \"pr\u00e9stamo\", \"reserva\", o \"libros disponibles\" que representan conceptos del dominio que deben ser implementados en nuestra soluci\u00f3n Casos de uso biblioteca Abstracciones computacionales \u00b6 Existen abstracciones propias de la inform\u00e1tica ( computer science ), que se utilizan en m\u00faltiples dominios. Por ejemplo, abstracciones de datos como: Listas \u00c1rboles Grafos Tablas hash Tambi\u00e9n existen abstracciones que nos permiten tratar con dispositivos y ordenadores externos: Fichero Raster gr\u00e1fico Protocolo TCP/IP Construcci\u00f3n de abstracciones \u00b6 Uno de los trabajos principales de un inform\u00e1tico es la construcci\u00f3n de abstracciones que permitan ahorrar tiempo y esfuerzo a la hora de tratar con la complejidad del mundo real. Cita de Joel Spolsky en su blog Joel on Software TCP es lo que los cient\u00edficos de computaci\u00f3n llaman una abstracci\u00f3n: una simplificaci\u00f3n de algo mucho m\u00e1s complicado que va por debajo de la cubierta. Resulta que una gran parte de la programaci\u00f3n de computadores consiste en construir abstracciones. \u00bfQu\u00e9 es una librer\u00eda de cadenas? Es una forma de hacer creer que los computadores pueden manipular cadenas tan f\u00e1cilmente como manipulan los n\u00fameros. \u00bfQu\u00e9 es un sistema de ficheros? Es una forma de hacer creer que un disco duro no es en realidad un mont\u00f3n de platos magn\u00e9ticos en rotaci\u00f3n que pueden almacenar bits en ciertas posiciones, sino en su lugar, un sistema jer\u00e1rquico de carpetas-dentro-de-carpetas que contiene ficheros individuales. Distintos aspectos de los lenguajes de programaci\u00f3n \u00b6 La programaci\u00f3n es una disciplina compleja, que tiene que tener en cuenta m\u00faltiples aspectos de los lenguajes de programaci\u00f3n y las API: Programas como procesos runtime que se ejecutan en un computador. Tenemos que entender qu\u00e9 pasa cuando se crea un objeto, cu\u00e1nto tiempo permanece en memoria, cu\u00e1l es el \u00e1mbito de una variable, etc. Herramientas: depuradores, analizadores de rendimiento. Programas como declaraciones est\u00e1ticas. Hay que considerar un programa desde el punto de vista de una declaraci\u00f3n de nuevos tipos, nuevos m\u00e9todos, tipos gen\u00e9ricos, herencia entre clases, etc. Herramientas: entornos de programaci\u00f3n con autocompletado de c\u00f3digo, detecci\u00f3n de errores sint\u00e1cticos. Programas como comunicaci\u00f3n y actividad social. Tenemos que tener en cuenta que un programa va a ser usado por otras personas, le\u00eddo, extendido, mantenido, modificado. Los programas siempre se van a modificar. Herramientas: sistemas de control de versiones (Git, Mercurial, Github, Bitbucket), de gesti\u00f3n incidencias (Jira) , tests que evitan errores de regresi\u00f3n, ... Paradigmas de programaci\u00f3n \u00b6 \u00bfQu\u00e9 es un paradigma de programaci\u00f3n? \u00b6 Un paradigma define un conjunto de caracter\u00edsticas, patrones y estilos de programaci\u00f3n basados en alguna idea fundamental. Por ejemplo el paradigma funcional se basa en la idea que una computaci\u00f3n se puede especificar como un conjunto de funciones que transforman valores de entrada en valores de salida. Es conveniente ver un paradigma como un estilo de programaci\u00f3n que puede usarse en distintos lenguajes de programaci\u00f3n y expresarse con distintas sintaxis. Por ejemplo, se puede escribir c\u00f3digo que use programaci\u00f3n l\u00f3gica en Prolog (ser\u00eda lo m\u00e1s natural), pero tambi\u00e9n en Java, usando alg\u00fan API espec\u00edfica. Normalmente todos los lenguajes tienen caracter\u00edsticas de m\u00e1s de un paradigma. Por motivos pr\u00e1cticos los lenguajes m\u00e1s populares no se limitan de forma estricta o pura a un \u00fanico paradigma de programaci\u00f3n. Por ejemplo, el Prolog es un lenguaje en su mayor parte l\u00f3gico y declarativo, pero tiene operadores imperativos como el corte . A pesar de ello, es normal adscribir un lenguaje al paradigma en el que es m\u00e1s sencillo o natural escribir c\u00f3digo usando sus construcciones. Existen lenguajes que refuerzan y promueven la expresi\u00f3n de c\u00f3digo en m\u00e1s de un paradigma de programaci\u00f3n. Y lo hacen no por necesidad o accidente, sino con el intento expl\u00edcito de fusionar m\u00e1s de un paradigma en una forma \u00fanica de programar. Estos lenguajes se denominan lenguajes multi-paradigma . Por ejemplo, Scala es lenguaje multi-paradigma en el que Martin Odersky, su creador, mezcla caracter\u00edsticas de programaci\u00f3n orientada a objetos con programaci\u00f3n funcional. Prolog o Lisp, aunque tienen caracter\u00edsticas no l\u00f3gicas o no funcionales, no pueden ser considerados multi-paradigma porque no fueron creados con la idea de integrar paradigmas variados en una forma coherente de expresi\u00f3n. Los paradigmas m\u00e1s importantes son: Paradigma funcional Paradigma l\u00f3gico Paradigma imperativo o procedural Paradigma orientado a objetos Paradigma funcional \u00b6 Resumen de las caracter\u00edsticas principales: La computaci\u00f3n se realiza mediante la evaluaci\u00f3n de expresiones Definici\u00f3n de funciones Funciones como datos primitivos Valores sin efectos laterales, no existen referencias a celdas de memoria en las que se guarda un estado modificable Programaci\u00f3n declarativa (en la programaci\u00f3n funcional pura ) Lenguajes: Lisp, Scheme, Haskell, Scala, Clojure. Ejemplo de c\u00f3digo (Lisp): 1 2 3 4 5 6 7 8 9 ( define ( factorial x ) ( if ( = x 0 ) 1 ( * x ( factorial ( - x 1 ))))) ( factorial 8 ) 40320 ( factorial 30 ) 265252859812191058636308480000000 Paradigma l\u00f3gico \u00b6 Caracter\u00edsticas: Definici\u00f3n de reglas Unificaci\u00f3n como elemento de computaci\u00f3n Programaci\u00f3n declarativa Lenguajes: Prolog, Mercury, Oz. Ejemplo de c\u00f3digo (Prolog): 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 padrede ( 'juan' , 'maria' ). % juan es padre de maria padrede ( 'pablo' , 'juan' ). % pablo es padre de juan padrede ( 'pablo' , 'marcela' ). padrede ( 'carlos' , 'debora' ). hijode ( A , B ) :- padrede ( B , A ). abuelode ( A , B ) :- padrede ( A , C ), padrede ( C , B ). hermanode ( A , B ) :- padrede ( C , A ) , padrede ( C , B ), A \\== B . familiarde ( A , B ) :- padrede ( A , B ). familiarde ( A , B ) :- hijode ( A , B ). familiarde ( A , B ) :- hermanode ( A , B ). ?- hermanode ( 'juan' , 'marcela' ). yes ?- hermanode ( 'carlos' , 'juan' ). no ?- abuelode ( 'pablo' , 'maria' ). yes ?- abuelode ( 'maria' , 'pablo' ). no Paradigma imperativo \u00b6 Los lenguajes de programaci\u00f3n que cumplen el paradigma imperativo se caracterizan por tener un estado impl\u00edcito que es modificado mediante instrucciones o comandos del lenguaje. Como resultado, estos lenguajes tienen una noci\u00f3n de secuenciaci\u00f3n de los comandos para permitir un control preciso y determinista del estado. Caracter\u00edsticas: Definici\u00f3n de procedimientos Definici\u00f3n de tipos de datos Chequeo de tipos en tiempo de compilaci\u00f3n Cambio de estado de variables Pasos de ejecuci\u00f3n de un proceso Ejemplo (Pascal): 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 type tDimension = 1 . . 100 ; eMatriz ( f , c : tDimension ) = array [ 1 .. f , 1 .. c ] of real ; tRango = record f , c : tDimension value 1 ; end ; tpMatriz = ^ eMatriz ; procedure EscribirMatriz ( var m : tpMatriz ); var filas , col : integer ; begin for filas := 1 to m ^ . f do begin for col := 1 to m ^ . c do write ( m ^ [ filas , col ] : 7 : 2 ); writeln ( resultado ); writeln ( resultado ) end ; end ; Paradigma orientado a objetos \u00b6 Caracter\u00edsticas: Definici\u00f3n de clases y herencia Objetos como abstracci\u00f3n de datos y procedimientos Polimorfismo y chequeo de tipos en tiempo de ejecuci\u00f3n Ejemplo (Java): 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 public class Bicicleta { public int marcha ; public int velocidad ; public Bicicleta ( int velocidadInicial , int marchaInicial ) { marcha = marchaInicial ; velocidad = velocidadInicial ; } public void setMarcha ( int nuevoValor ) { marcha = nuevoValor ; } public void frenar ( int decremento ) { velocidad -= decremento ; } public void acelerar ( int incremento ) { velocidad += incremento ; } } public class MountainBike extends Bicicleta { public int alturaSillin ; public MountainBike ( int alturaInicial , int velocidadInicial , int marchaInicial ) { super ( velocidadInicial , marchaInicial ); alturaSillin = alturaInicial ; } public void setAltura ( int nuevoValor ) { alturaSillin = nuevoValor ; } } public class Excursion { public static void main ( String [] args ) { MountainBike miBicicleta = new MoutainBike ( 10 , 10 , 3 ); miBicicleta . acelerar ( 10 ); miBicicleta . setMarcha ( 4 ); miBicicleta . frenar ( 10 ); } } Compiladores e int\u00e9rpretes \u00b6 En el nivel de abstracci\u00f3n m\u00e1s bajo, la ejecuci\u00f3n de un programa en un computador consiste en la ejecuci\u00f3n de un conjunto de instrucciones del c\u00f3digo m\u00e1quina del procesador. Por ejemplo, la siguiente figura muestra un ejemplo de un programa en ensamblador para un antiguo procesador (el Z80, procesador de 8 bits del m\u00edtico ZX Spectrum , uno de los primeros ordenadores personales en Europa): Ensamblador Z80 Dependiendo del tipo de lenguaje de programaci\u00f3n en el que est\u00e9 escrito este programa, el c\u00f3digo m\u00e1quina que se estar\u00e1 ejecutando ser\u00e1: el resultado de la compilaci\u00f3n del programa original (en el caso de un lenguaje compilado) el c\u00f3digo de un programa (int\u00e9rprete) que realiza la interpretaci\u00f3n del programa original (en el caso de un lenguaje interpretado) Compilaci\u00f3n \u00b6 La siguiente figura (tomada, como las dem\u00e1s de este apartado del Programming Language Pragmatics ) muestra el proceso de generaci\u00f3n y ejecuci\u00f3n de un programa compilado. Compilaci\u00f3n El proceso de compilaci\u00f3n de un programa consiste en la traducci\u00f3n del c\u00f3digo fuente original en el lenguaje de alto nivel al c\u00f3digo m\u00e1quina espec\u00edfico del procesador en el que va a ejecutarse el programa. El c\u00f3digo m\u00e1quina resultante s\u00f3lo corre en el procesador para el que se ha generado. Por ejemplo, un programa C compilado para un procesador Intel no puede ejecutarse en un procesador ARM, como los Ax de Apple . Ejemplos: C, C++ Diferentes momentos en la vida de un programa: tiempo de compilaci\u00f3n y tiempo de ejecuci\u00f3n Mayor eficiencia Interpretaci\u00f3n \u00b6 Interpretaci\u00f3n Ejemplos: BASIC, Lisp, Scheme, Python, Ruby No hay diferencia entre el tiempo de compilaci\u00f3n y el tiempo de ejecuci\u00f3n Mayor flexibilidad: el c\u00f3digo se puede construir y ejecutar \"on the fly\" (funciones lambda o clousures) Los lenguajes interpretados suelen proporcionar un shell o int\u00e9rprete. Se trata de un entorno interactivo en el que podemos definir y evaluar expresiones. Este entorno se denomina en los c\u00edrculos de programaci\u00f3n funcional un REPL ( Read , Eval , Print , Loop ) y ya se utiliz\u00f3 en los primeros a\u00f1os de implementaci\u00f3n del Lisp. El uso del REPL promueve una programaci\u00f3n interactiva en la que continuamente evaluamos y comprobamos el c\u00f3digo que desarrollamos. Enfoques mixtos \u00b6 Existen tambi\u00e9n enfoques mixtos, como el usado por el lenguaje de programaci\u00f3n Java, en el que se realizan ambos procesos. En una primera fase el compilador de Java ( javac ) realiza una traducci\u00f3n del c\u00f3digo fuente original a un c\u00f3digo intermedio binario independiente del procesado, denominado bytecode . Este c\u00f3digo binario es multiplataforma. El c\u00f3digo intermedio es interpretado despu\u00e9s por un el int\u00e9rprete ( java ) que ya s\u00ed que es dependiente de la plataforma. En la figura el int\u00e9rprete se denomina Virtual machine (no confundir con el concepto de m\u00e1quina virtual que permite emular un sistema operativo, por ejemplo VirtualBox). Enfoque mixto (Java) Ejemplos: Java, Scala Bibliograf\u00eda \u00b6 Introducci\u00f3n y cap\u00edtulo 1 del Structure and Interpretation of Computer Programs: Building Abstractions with Procedures Cap\u00edtulo 1.2 Programming Language Pragmatics: The Programming Language Spectrum Cap\u00edtulo 1.3 Programming Language Pragmatics, Why Study Programming Languages Cap\u00edtulo 1.4 Programming Language Pragmatics, Compilation and Interpretation Raul Rojas, \"Konrad Zuse's legacy the architecture of the Z1 and Z3\", IEEE Annals of the History of Computing, Vol. 19, No. 2, 1997 Charles Petzold, \"Code\", Microsoft Press, 2000 (Cap\u00edtulo 18: \"From Abaci to Chips\") Jack Copeland, \"The Modern History of Computing\", The Stanford Encyclopedia of Philosophy (Fall 2008 Edition), URL = http://plato.stanford.edu/archives/fall2008/entries/computing-history/ Georgi Dalakov, \"History of Computers\", URL = http://history-computer.com Lenguajes y Paradigmas de Programaci\u00f3n, curso 2019-20 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Domingo Gallardo, Cristina Pomares, Antonio Bot\u00eda, Francisco Mart\u00ednez","title":"Tema 1: Historia de los lenguajes de programaci\u00f3n"},{"location":"teoria/tema01-historia-lenguajes-programacion/tema01-historia-lenguajes-programacion.html#tema-1-historia-y-conceptos-de-los-lenguajes-de-programacion","text":"","title":"Tema 1: Historia y conceptos de los lenguajes de programaci\u00f3n"},{"location":"teoria/tema01-historia-lenguajes-programacion/tema01-historia-lenguajes-programacion.html#historia-de-los-lenguajes-de-programacion","text":"","title":"Historia de los lenguajes de programaci\u00f3n"},{"location":"teoria/tema01-historia-lenguajes-programacion/tema01-historia-lenguajes-programacion.html#de-las-maquinas-de-calcular-a-los-computadores-programables","text":"M\u00e1quina de Schickard (1623) Calculadora de Pascal (1650) Desde las primeras calculadoras mec\u00e1nicas dise\u00f1adas en el siglo XVII hasta los a\u00f1os 40 del siglo pasado se han inventado multitud de m\u00e1quinas y computadores mec\u00e1nicos, anal\u00f3gicos o electr\u00f3nicos que han intentado acelerar y mejorar la precisi\u00f3n de los c\u00e1lculos. El punto culminante de todos los enfoques mec\u00e1nicos para realizar c\u00e1lculos fue el famoso Motor Anal\u00edtico dise\u00f1ado por Charles Babbage en 1840. La diferencia fundamental con todos los artefactos anteriores es que se trataba de una m\u00e1quina de calcular programable mediante tarjetas perforadas (Babbage se inspir\u00f3 en el telar de Jackquard en el que el dise\u00f1o de los dibujos de las telas se pod\u00edan configurar usando tarjetas perforadas). La m\u00e1quina estaba dise\u00f1ada para trabajar en base 10 y se pod\u00eda conseguir que sus c\u00e1lculos realizaran saltos condicionales y bucles. Babbage trabaj\u00f3 durante m\u00e1s de 30 a\u00f1os para intentar construir la m\u00e1quina. Ten\u00eda una enorme complejidad para la \u00e9poca y necesitaba much\u00edsima financiaci\u00f3n. En 1871 muri\u00f3 habiendo podido construir s\u00f3lo una parte. La matem\u00e1tica Ada Lovelace tuvo un papel fundamental en la divulgaci\u00f3n de la m\u00e1quina, de su sistema de programaci\u00f3n y fue la primera que entendi\u00f3 sus posibilidades m\u00e1s all\u00e1 del c\u00e1lculo de f\u00f3rmulas. De forma poco habitual para la \u00e9poca, Ada fue educada en el campo de las ciencias y de las matem\u00e1ticas. A principios de 1840, con veinticico a\u00f1os, conoci\u00f3 el trabajo de Babbage y colabor\u00f3 con \u00e9l, dedic\u00e1ndose durante varios a\u00f1os a conocer y estudiar el dise\u00f1o y el funcionamiento del motor anal\u00edtico. En 1843 public\u00f3 el trabajo \"Sketch of the analytical engine invented by Charles Babbage\" en el que describe el Motor Anal\u00edtico, a\u00f1ade reflexiones propias sobre el alcance del invento y construye un ejemplo completo, con tablas y diagramas, de c\u00f3mo hacer que la m\u00e1quina produzca la secuencia de los n\u00fameros de Bernoulli. Se puede considerar estas tablas y diagramas como el primer programa de un computador . Antes de que existiera ning\u00fan computador real, en 1936, el matem\u00e1tico ingl\u00e9s Alan Turing formaliz\u00f3 la idea abstracta de computador, utilizando un modelo muy sencillo de procesamiento: una m\u00e1quina abstracta con un scanner que lee y escribe 0s y 1s de una cinta infinita (memoria) y se mueve y los escribe en funci\u00f3n de una tabla definida en la m\u00e1quina (programa). Con esta m\u00e1quina abstracta ( M\u00e1quina de Turing ) Turing explora la idea de lo computable y lo no computable. \u00bfExisten problemas no computables para los que no es posible inventar un algoritmo que los resuelva? Turing demuestra que s\u00ed y establece con su trabajo los l\u00edmites de la computaci\u00f3n. En el mismo trabajo Turing define el concepto de m\u00e1quina universal que es capaz de leer de la cinta un programa cualquiera y simular su comportamiento en otra parte de la cinta. Esta idea tuvo un profundo impacto en el desarrollo de los computadores, porque mostraba que es posible escribir programas que tomen como datos otros programas. Esto abre la puerta a la idea de los programas almacenados en memoria (ya que son otros datos m\u00e1s) y a la creaci\u00f3n de compiladores e int\u00e9rpretes. En la d\u00e9cada de 1940 hubo una explosi\u00f3n de m\u00e1quinas de computaci\u00f3n electr\u00f3nicas y electromec\u00e1nicas. Fue una d\u00e9cada prodigiosa en la que se desarrollaron tecnolog\u00edas cada vez m\u00e1s r\u00e1pidas y resistentes, y se consiguieron enormes avances en la velocidad y precisi\u00f3n de los c\u00e1lculos. A mitad de esa d\u00e9cada, en 1945, John Von Neumann , que trabajaba en la construcci\u00f3n del ENIAC , introdujo un avance fundamental. Propuso su famosa arquitectura en la que por primera vez se proponen las dos ideas claves de los computadores de prop\u00f3sito general: el programa almacenado en memoria y un conjunto de instrucciones de procesamiento que incluye el direccionamiento indirecto. Y en 1948, tres a\u00f1os despu\u00e9s, se construy\u00f3 en la universidad de Manchester el primer computador electr\u00f3nico digital de prop\u00f3sito general que utilizaba esta arquitectura (llamado Baby ). Fue dise\u00f1ado por Max Newmann usando la tecnolog\u00eda proporcionada por los ingenieros F.C. Williams y Tom Kilburn. Williams hab\u00eda inventado un dispositivo de memoria electr\u00f3nico (la v\u00e1lvula de Williams ) capaz de sustituir las lentas l\u00edneas de retardo de mercurio utilizadas hasta ese momento. La m\u00e1quina de Manchester fue el primer computador con un conjunto de instrucciones completo, capaz de realizar saltos, condicionales y direccionamiento indirecto. La primera ejecuci\u00f3n de un programa fue el 21 de junio de 1948. En ese a\u00f1o Alan Turing se incorpor\u00f3 a la universidad de Manchester, como director del Laboratorio de Computaci\u00f3n. Tres a\u00f1os despu\u00e9s, con un dise\u00f1o ampliado en el que tambi\u00e9n influy\u00f3 Turing, una versi\u00f3n mucho mayor de la m\u00e1quina se convirti\u00f3 en el primer computador disponible comercialmente, el Ferranti Mark I. El primero se instal\u00f3 en la universidad de Manchester en febrero de 1951, un mes antes que el UNIVAC I fuera entregado al Departamento de Censo de los EEUU. Se vendieron otras 10 m\u00e1quinas a Gran Breta\u00f1a, Canad\u00e1, Holanda e Italia. El primer programa complejo de Inteligencia Artificial, un jugador de damas escrito por Christopher Strachey, se ejecut\u00f3 en el verano de 1952 en el Ferranti Mark I en el Laboratorio de Computaci\u00f3n de Manchester. Strachey escribi\u00f3 el programa animado por Turing y usando el manual de programaci\u00f3n del Ferranti que Turing acababa de escribir. Turing particip\u00f3 tambi\u00e9n en el desarrollo de otros programas de IA, como un jugador de ajedrez basado en heur\u00edsticas.","title":"De las m\u00e1quinas de calcular a los computadores programables"},{"location":"teoria/tema01-historia-lenguajes-programacion/tema01-historia-lenguajes-programacion.html#los-primeros-lenguajes-de-programacion","text":"Los primeros computadores electr\u00f3nicos se programaban directamente usando el conjunto de instrucciones del procesador, en c\u00f3digo m\u00e1quina, c\u00f3digo hexadecimal El primer lenguaje de un nivel algo m\u00e1s elevado que el c\u00f3digo m\u00e1quina es el ensamblador. Comienzan a crearse los primeros programas que procesan lenguajes de programaci\u00f3n, aunque se trata de programas muy sencillos, ya que hay una relaci\u00f3n casi directa entre la notaci\u00f3n en ensamblador y el c\u00f3digo hexadecimal que produce el ensamblador. A finales de la d\u00e9cada de los 40 se empiezan a intentar resolver con los primeros computadores los primeros problemas matem\u00e1ticos distintos de operaciones num\u00e9ricas: codificaci\u00f3n y descodificaci\u00f3n, problemas combinatorios como el coloreado del mapa o problemas de ordenaci\u00f3n. Uno de los primeros algoritmos de von Neumann realiza una ordenaci\u00f3n de un conjunto de n\u00fameros. Von Neumann lo describe en una carta fechada en 1945. Utiliza el conjunto de instrucciones del EDSAC cuando todav\u00eda no se hab\u00eda construido. El programa fue estudiado por Donald Knuth en el art\u00edculo Von Neumann's first Computer Program , en donde documenta que hab\u00eda un bug en las primeras instrucciones. Es el primer bug escrito del que se tiene historia. Si Von Neumann hubiera podido ejecutar el programa en el EDSAC se hubiera dado cuenta del error y hubiera sido la primera depuraci\u00f3n de un programa. Primer programa de Von Neumann (Donald Knuth, \"Von Neumann's first Computer Program\", Journal of the ACM Computing Surveys (CSUR) Surveys, Volume 2 Issue 4, Dec. 1970, Pages 247-260)","title":"Los primeros lenguajes de programaci\u00f3n"},{"location":"teoria/tema01-historia-lenguajes-programacion/tema01-historia-lenguajes-programacion.html#el-nacimiento-de-los-computadores-comerciales","text":"UNIVAC El UNIVAC fue el primer computador comercial (1951). Con este computadora aparece por primera vez la figura del programador: manuales, cursos de formaci\u00f3n, ofertas de empleo, etc. UNIVAC Instalaciones comerciales del UNIVAC IBM 704 El IBM 704 fue el otro gran ordenador comercial de la d\u00e9cada de los 50. Tuvo una difusi\u00f3n mucho mayor que el UNIVAC: centros gubernamentales, universidades. Los primeros lenguajes de programaci\u00f3n de alto nivel se desarrollan para este computador. Foto IBM 704","title":"El nacimiento de los computadores comerciales"},{"location":"teoria/tema01-historia-lenguajes-programacion/tema01-historia-lenguajes-programacion.html#los-primeros-lenguajes-de-alto-nivel","text":"Los primeros lenguajes de alto nivel se desarrollaron a finales de la d\u00e9cada de los 50: FORTRAN en 1956 Lisp en 1958 Ambos lenguajes planteaban dos enfoques muy distintos desde el principio: FORTRAN Primer lenguaje comercial, equipo de IBM dirigido por John W. Backus Lenguaje imperativo: estado, estructuras de control, contador de programa, celdas de memoria Lenguaje compilado Lisp Lenguaje dise\u00f1ado en un departamento de investigaci\u00f3n, un equipo del MIT dirigido por John McCarthy Lenguaje funcional: funciones, recursi\u00f3n, listas, s\u00edmbolos Lenguaje interpretado","title":"Los primeros lenguajes de alto nivel"},{"location":"teoria/tema01-historia-lenguajes-programacion/tema01-historia-lenguajes-programacion.html#la-explosion-de-los-lenguajes-de-programacion","text":"Desde 1954 hasta la actualidad se han documentado m\u00e1s de 2.500 (consultar en The Language List ). Entre 1952 y 1972 alrededor de 200 lenguajes. Una decena fueron realmente siginificativos y tuvieron influencia en el desarrollo de lenguajes posteriores.","title":"La explosi\u00f3n de los lenguajes de programaci\u00f3n"},{"location":"teoria/tema01-historia-lenguajes-programacion/tema01-historia-lenguajes-programacion.html#lenguajes-de-programacion-en-la-actualidad","text":"El \u00edndice TIOBE es un indicador de la popularidad de los lenguajes de programaci\u00f3n. El \u00edndice se actualiza una vez al mes. Las puntaciones se basan en estad\u00edsticas no reveladas que incluyen el n\u00famero de ingenieros en todo el mundo, cursos y aplicaciones desarrolladas. Tambi\u00e9n se utilizan resultados obtenidos en los motores de b\u00fasqueda m\u00e1s usados. El \u00edndice TIOBE no trata de medir el n\u00famero de l\u00edneas escritas en los lenguajes de programaci\u00f3n sino su popularidad e importancia en la comunidad. Lista TIOBE Tambi\u00e9n es muy interesante comprobar la evoluci\u00f3n de los 10 lenguajes m\u00e1s populares en los \u00faltimos 10 a\u00f1os. Evoluci\u00f3n TIOBE","title":"Lenguajes de programaci\u00f3n en la actualidad"},{"location":"teoria/tema01-historia-lenguajes-programacion/tema01-historia-lenguajes-programacion.html#elementos-de-los-lenguajes-de-programacion","text":"","title":"Elementos de los lenguajes de programaci\u00f3n"},{"location":"teoria/tema01-historia-lenguajes-programacion/tema01-historia-lenguajes-programacion.html#definicion-de-la-encyclopedia-of-computer-science","text":"Un lenguaje de programaci\u00f3n es un conjunto de caracteres, reglas para combinarlos y reglas para especificar sus efectos cuando sean ejecutados por un computador, que tienen las siguientes cuatro caracter\u00edsticas: No requiere ning\u00fan conocimiento de c\u00f3digo m\u00e1quina por parte del usuario. Tiene independencia de la m\u00e1quina. Se traduce a lenguaje m\u00e1guina. Utiliza una notaci\u00f3n que es m\u00e1s cercana al problema espec\u00edfico que se est\u00e1 resolviendo que al c\u00f3digo m\u00e1quina.","title":"Definici\u00f3n de la Encyclopedia of Computer Science"},{"location":"teoria/tema01-historia-lenguajes-programacion/tema01-historia-lenguajes-programacion.html#definicion-de-abelson-y-sussman","text":"Vamos a estudiar la idea de un proceso computacional . Los procesos computacionales son seres abstractos que habitan los computadores. Cuando est\u00e1n en marcha, los procesos manipulan otras cosas abstractas denominadas datos . La evoluci\u00f3n de un proceso est\u00e1 dirigida por un patr\u00f3n de reglas denominado un programa. [...] Y otra idea fundamental Un lenguaje de programaci\u00f3n potente es m\u00e1s que s\u00f3lo una forma de pedir a un computador que realice tareas. El lenguaje tambi\u00e9n sirve como un marco dentro del que organizamos nuestras ideas acerca de los procesos. As\u00ed, cuando describimos un lenguaje, deber\u00edamos prestar atenci\u00f3n particular a los medios que proporciona el lenguaje para combinar ideas simples para formar ideas m\u00e1s complejas.","title":"Definici\u00f3n de Abelson y Sussman"},{"location":"teoria/tema01-historia-lenguajes-programacion/tema01-historia-lenguajes-programacion.html#caracteristicas-de-un-lp","text":"Define un proceso que se ejecuta en un computador Es de alto nivel, cercano a los problemas que se quieren resolver (abstracci\u00f3n) Permite construir nuevas abstracciones que se adapten al dominio que se programa","title":"Caracter\u00edsticas de un LP"},{"location":"teoria/tema01-historia-lenguajes-programacion/tema01-historia-lenguajes-programacion.html#elementos-de-un-lp","text":"Para Abelson y Sussman, todos los lenguajes de progamaci\u00f3n permiten combinar ideas simples en ideas m\u00e1s complejas mediante los siguientes tres mecanismos Expresiones primitivas que representan las entidades m\u00e1s simples del lenguaje Mecanismos de combinaci\u00f3n con los que se construyen elementos compuestos a partir de elementos m\u00e1s simples Mecanismos de abstracci\u00f3n con los que dar nombre a los elementos compuestos y manipularlos como unidades","title":"Elementos de un LP"},{"location":"teoria/tema01-historia-lenguajes-programacion/tema01-historia-lenguajes-programacion.html#sintaxis-y-semantica","text":"Sintaxis : conjunto de reglas que definen qu\u00e9 expresiones de texto son correctas. Por ejemplo, en C todas las sentencias deben terminar en ';'. Sem\u00e1ntica : conjunto de reglas que define cu\u00e1l ser\u00e1 el resultado de la ejecuci\u00f3n de un programa en el computador.","title":"Sintaxis y sem\u00e1ntica"},{"location":"teoria/tema01-historia-lenguajes-programacion/tema01-historia-lenguajes-programacion.html#los-lenguajes-son-para-las-personas","text":"Los lenguajes de programaci\u00f3n deben ser precisos, deben poder traducirse sin ambig\u00fcedad en lenguaje m\u00e1quina para que sean ejecutados por computadores. Pero deben ser utilizados (le\u00eddos, comentados, probados, etc.) por personas. La programaci\u00f3n es una actividad colaborativa y debe basarse en la comunicaci\u00f3n.","title":"Los lenguajes son para las personas"},{"location":"teoria/tema01-historia-lenguajes-programacion/tema01-historia-lenguajes-programacion.html#importancia-del-aprendizaje-de-tecnicas-de-lps","text":"Es importante conocer c\u00f3mo funciona \"por dentro\" un lenguaje de programaci\u00f3n y sus caracter\u00edsticas comparadas. Mejora el uso del lenguaje de programaci\u00f3n Incrementa el vocabulario de los elementos de programaci\u00f3n Permite una mejor elecci\u00f3n del lenguaje de programaci\u00f3n Mejora la habilidad para desarrollar programas efectivos y eficientes Facilita el aprendizaje de un nuevo lenguaje de programaci\u00f3n Facilita el dise\u00f1o de nuevos lenguajes de programaci\u00f3n","title":"Importancia del aprendizaje de t\u00e9cnicas de LPs"},{"location":"teoria/tema01-historia-lenguajes-programacion/tema01-historia-lenguajes-programacion.html#abstraccion","text":"Una misi\u00f3n fundamental de los lenguajes de programaci\u00f3n es proporcionar herramientas que sirvan para construir abstracciones. Por ejemplo, estamos construyendo una abstracci\u00f3n cuando damos un nombre a una entidad del lenguaje (una variable, una funci\u00f3n, una clase, etc.). Escoger un buen nombre para los elementos que vamos construyendo en nuestro programas es fundamental para conseguir un c\u00f3digo legible y reutilizable.","title":"Abstracci\u00f3n"},{"location":"teoria/tema01-historia-lenguajes-programacion/tema01-historia-lenguajes-programacion.html#modelar-como-una-actividad-fundamental","text":"Para escribir un programa que preste unos servicios es fundamental modelar el dominio sobre el que va a trabajar Es necesario definir distintas abstracciones (tanto APIs, como datos) que nos permitan tratar sus elementos y comunicarnos correctamente con los usuarios que van a utilizar el programa. Las abstracciones que vamos construyendo van apoy\u00e1ndose unas en otras y permiten hacer compresible y comunicable un problema complejo Ejemplo: el modelado del funcionamiento de una biblioteca contiene abstracciones como \"libros\", \"pr\u00e9stamo\", \"reserva\", o \"libros disponibles\" que representan conceptos del dominio que deben ser implementados en nuestra soluci\u00f3n Casos de uso biblioteca","title":"Modelar como una actividad fundamental"},{"location":"teoria/tema01-historia-lenguajes-programacion/tema01-historia-lenguajes-programacion.html#abstracciones-computacionales","text":"Existen abstracciones propias de la inform\u00e1tica ( computer science ), que se utilizan en m\u00faltiples dominios. Por ejemplo, abstracciones de datos como: Listas \u00c1rboles Grafos Tablas hash Tambi\u00e9n existen abstracciones que nos permiten tratar con dispositivos y ordenadores externos: Fichero Raster gr\u00e1fico Protocolo TCP/IP","title":"Abstracciones computacionales"},{"location":"teoria/tema01-historia-lenguajes-programacion/tema01-historia-lenguajes-programacion.html#construccion-de-abstracciones","text":"Uno de los trabajos principales de un inform\u00e1tico es la construcci\u00f3n de abstracciones que permitan ahorrar tiempo y esfuerzo a la hora de tratar con la complejidad del mundo real. Cita de Joel Spolsky en su blog Joel on Software TCP es lo que los cient\u00edficos de computaci\u00f3n llaman una abstracci\u00f3n: una simplificaci\u00f3n de algo mucho m\u00e1s complicado que va por debajo de la cubierta. Resulta que una gran parte de la programaci\u00f3n de computadores consiste en construir abstracciones. \u00bfQu\u00e9 es una librer\u00eda de cadenas? Es una forma de hacer creer que los computadores pueden manipular cadenas tan f\u00e1cilmente como manipulan los n\u00fameros. \u00bfQu\u00e9 es un sistema de ficheros? Es una forma de hacer creer que un disco duro no es en realidad un mont\u00f3n de platos magn\u00e9ticos en rotaci\u00f3n que pueden almacenar bits en ciertas posiciones, sino en su lugar, un sistema jer\u00e1rquico de carpetas-dentro-de-carpetas que contiene ficheros individuales.","title":"Construcci\u00f3n de abstracciones"},{"location":"teoria/tema01-historia-lenguajes-programacion/tema01-historia-lenguajes-programacion.html#distintos-aspectos-de-los-lenguajes-de-programacion","text":"La programaci\u00f3n es una disciplina compleja, que tiene que tener en cuenta m\u00faltiples aspectos de los lenguajes de programaci\u00f3n y las API: Programas como procesos runtime que se ejecutan en un computador. Tenemos que entender qu\u00e9 pasa cuando se crea un objeto, cu\u00e1nto tiempo permanece en memoria, cu\u00e1l es el \u00e1mbito de una variable, etc. Herramientas: depuradores, analizadores de rendimiento. Programas como declaraciones est\u00e1ticas. Hay que considerar un programa desde el punto de vista de una declaraci\u00f3n de nuevos tipos, nuevos m\u00e9todos, tipos gen\u00e9ricos, herencia entre clases, etc. Herramientas: entornos de programaci\u00f3n con autocompletado de c\u00f3digo, detecci\u00f3n de errores sint\u00e1cticos. Programas como comunicaci\u00f3n y actividad social. Tenemos que tener en cuenta que un programa va a ser usado por otras personas, le\u00eddo, extendido, mantenido, modificado. Los programas siempre se van a modificar. Herramientas: sistemas de control de versiones (Git, Mercurial, Github, Bitbucket), de gesti\u00f3n incidencias (Jira) , tests que evitan errores de regresi\u00f3n, ...","title":"Distintos aspectos de los lenguajes de programaci\u00f3n"},{"location":"teoria/tema01-historia-lenguajes-programacion/tema01-historia-lenguajes-programacion.html#paradigmas-de-programacion","text":"","title":"Paradigmas de programaci\u00f3n"},{"location":"teoria/tema01-historia-lenguajes-programacion/tema01-historia-lenguajes-programacion.html#que-es-un-paradigma-de-programacion","text":"Un paradigma define un conjunto de caracter\u00edsticas, patrones y estilos de programaci\u00f3n basados en alguna idea fundamental. Por ejemplo el paradigma funcional se basa en la idea que una computaci\u00f3n se puede especificar como un conjunto de funciones que transforman valores de entrada en valores de salida. Es conveniente ver un paradigma como un estilo de programaci\u00f3n que puede usarse en distintos lenguajes de programaci\u00f3n y expresarse con distintas sintaxis. Por ejemplo, se puede escribir c\u00f3digo que use programaci\u00f3n l\u00f3gica en Prolog (ser\u00eda lo m\u00e1s natural), pero tambi\u00e9n en Java, usando alg\u00fan API espec\u00edfica. Normalmente todos los lenguajes tienen caracter\u00edsticas de m\u00e1s de un paradigma. Por motivos pr\u00e1cticos los lenguajes m\u00e1s populares no se limitan de forma estricta o pura a un \u00fanico paradigma de programaci\u00f3n. Por ejemplo, el Prolog es un lenguaje en su mayor parte l\u00f3gico y declarativo, pero tiene operadores imperativos como el corte . A pesar de ello, es normal adscribir un lenguaje al paradigma en el que es m\u00e1s sencillo o natural escribir c\u00f3digo usando sus construcciones. Existen lenguajes que refuerzan y promueven la expresi\u00f3n de c\u00f3digo en m\u00e1s de un paradigma de programaci\u00f3n. Y lo hacen no por necesidad o accidente, sino con el intento expl\u00edcito de fusionar m\u00e1s de un paradigma en una forma \u00fanica de programar. Estos lenguajes se denominan lenguajes multi-paradigma . Por ejemplo, Scala es lenguaje multi-paradigma en el que Martin Odersky, su creador, mezcla caracter\u00edsticas de programaci\u00f3n orientada a objetos con programaci\u00f3n funcional. Prolog o Lisp, aunque tienen caracter\u00edsticas no l\u00f3gicas o no funcionales, no pueden ser considerados multi-paradigma porque no fueron creados con la idea de integrar paradigmas variados en una forma coherente de expresi\u00f3n. Los paradigmas m\u00e1s importantes son: Paradigma funcional Paradigma l\u00f3gico Paradigma imperativo o procedural Paradigma orientado a objetos","title":"\u00bfQu\u00e9 es un paradigma de programaci\u00f3n?"},{"location":"teoria/tema01-historia-lenguajes-programacion/tema01-historia-lenguajes-programacion.html#paradigma-funcional","text":"Resumen de las caracter\u00edsticas principales: La computaci\u00f3n se realiza mediante la evaluaci\u00f3n de expresiones Definici\u00f3n de funciones Funciones como datos primitivos Valores sin efectos laterales, no existen referencias a celdas de memoria en las que se guarda un estado modificable Programaci\u00f3n declarativa (en la programaci\u00f3n funcional pura ) Lenguajes: Lisp, Scheme, Haskell, Scala, Clojure. Ejemplo de c\u00f3digo (Lisp): 1 2 3 4 5 6 7 8 9 ( define ( factorial x ) ( if ( = x 0 ) 1 ( * x ( factorial ( - x 1 ))))) ( factorial 8 ) 40320 ( factorial 30 ) 265252859812191058636308480000000","title":"Paradigma funcional"},{"location":"teoria/tema01-historia-lenguajes-programacion/tema01-historia-lenguajes-programacion.html#paradigma-logico","text":"Caracter\u00edsticas: Definici\u00f3n de reglas Unificaci\u00f3n como elemento de computaci\u00f3n Programaci\u00f3n declarativa Lenguajes: Prolog, Mercury, Oz. Ejemplo de c\u00f3digo (Prolog): 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 padrede ( 'juan' , 'maria' ). % juan es padre de maria padrede ( 'pablo' , 'juan' ). % pablo es padre de juan padrede ( 'pablo' , 'marcela' ). padrede ( 'carlos' , 'debora' ). hijode ( A , B ) :- padrede ( B , A ). abuelode ( A , B ) :- padrede ( A , C ), padrede ( C , B ). hermanode ( A , B ) :- padrede ( C , A ) , padrede ( C , B ), A \\== B . familiarde ( A , B ) :- padrede ( A , B ). familiarde ( A , B ) :- hijode ( A , B ). familiarde ( A , B ) :- hermanode ( A , B ). ?- hermanode ( 'juan' , 'marcela' ). yes ?- hermanode ( 'carlos' , 'juan' ). no ?- abuelode ( 'pablo' , 'maria' ). yes ?- abuelode ( 'maria' , 'pablo' ). no","title":"Paradigma l\u00f3gico"},{"location":"teoria/tema01-historia-lenguajes-programacion/tema01-historia-lenguajes-programacion.html#paradigma-imperativo","text":"Los lenguajes de programaci\u00f3n que cumplen el paradigma imperativo se caracterizan por tener un estado impl\u00edcito que es modificado mediante instrucciones o comandos del lenguaje. Como resultado, estos lenguajes tienen una noci\u00f3n de secuenciaci\u00f3n de los comandos para permitir un control preciso y determinista del estado. Caracter\u00edsticas: Definici\u00f3n de procedimientos Definici\u00f3n de tipos de datos Chequeo de tipos en tiempo de compilaci\u00f3n Cambio de estado de variables Pasos de ejecuci\u00f3n de un proceso Ejemplo (Pascal): 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 type tDimension = 1 . . 100 ; eMatriz ( f , c : tDimension ) = array [ 1 .. f , 1 .. c ] of real ; tRango = record f , c : tDimension value 1 ; end ; tpMatriz = ^ eMatriz ; procedure EscribirMatriz ( var m : tpMatriz ); var filas , col : integer ; begin for filas := 1 to m ^ . f do begin for col := 1 to m ^ . c do write ( m ^ [ filas , col ] : 7 : 2 ); writeln ( resultado ); writeln ( resultado ) end ; end ;","title":"Paradigma imperativo"},{"location":"teoria/tema01-historia-lenguajes-programacion/tema01-historia-lenguajes-programacion.html#paradigma-orientado-a-objetos","text":"Caracter\u00edsticas: Definici\u00f3n de clases y herencia Objetos como abstracci\u00f3n de datos y procedimientos Polimorfismo y chequeo de tipos en tiempo de ejecuci\u00f3n Ejemplo (Java): 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 public class Bicicleta { public int marcha ; public int velocidad ; public Bicicleta ( int velocidadInicial , int marchaInicial ) { marcha = marchaInicial ; velocidad = velocidadInicial ; } public void setMarcha ( int nuevoValor ) { marcha = nuevoValor ; } public void frenar ( int decremento ) { velocidad -= decremento ; } public void acelerar ( int incremento ) { velocidad += incremento ; } } public class MountainBike extends Bicicleta { public int alturaSillin ; public MountainBike ( int alturaInicial , int velocidadInicial , int marchaInicial ) { super ( velocidadInicial , marchaInicial ); alturaSillin = alturaInicial ; } public void setAltura ( int nuevoValor ) { alturaSillin = nuevoValor ; } } public class Excursion { public static void main ( String [] args ) { MountainBike miBicicleta = new MoutainBike ( 10 , 10 , 3 ); miBicicleta . acelerar ( 10 ); miBicicleta . setMarcha ( 4 ); miBicicleta . frenar ( 10 ); } }","title":"Paradigma orientado a objetos"},{"location":"teoria/tema01-historia-lenguajes-programacion/tema01-historia-lenguajes-programacion.html#compiladores-e-interpretes","text":"En el nivel de abstracci\u00f3n m\u00e1s bajo, la ejecuci\u00f3n de un programa en un computador consiste en la ejecuci\u00f3n de un conjunto de instrucciones del c\u00f3digo m\u00e1quina del procesador. Por ejemplo, la siguiente figura muestra un ejemplo de un programa en ensamblador para un antiguo procesador (el Z80, procesador de 8 bits del m\u00edtico ZX Spectrum , uno de los primeros ordenadores personales en Europa): Ensamblador Z80 Dependiendo del tipo de lenguaje de programaci\u00f3n en el que est\u00e9 escrito este programa, el c\u00f3digo m\u00e1quina que se estar\u00e1 ejecutando ser\u00e1: el resultado de la compilaci\u00f3n del programa original (en el caso de un lenguaje compilado) el c\u00f3digo de un programa (int\u00e9rprete) que realiza la interpretaci\u00f3n del programa original (en el caso de un lenguaje interpretado)","title":"Compiladores e int\u00e9rpretes"},{"location":"teoria/tema01-historia-lenguajes-programacion/tema01-historia-lenguajes-programacion.html#compilacion","text":"La siguiente figura (tomada, como las dem\u00e1s de este apartado del Programming Language Pragmatics ) muestra el proceso de generaci\u00f3n y ejecuci\u00f3n de un programa compilado. Compilaci\u00f3n El proceso de compilaci\u00f3n de un programa consiste en la traducci\u00f3n del c\u00f3digo fuente original en el lenguaje de alto nivel al c\u00f3digo m\u00e1quina espec\u00edfico del procesador en el que va a ejecutarse el programa. El c\u00f3digo m\u00e1quina resultante s\u00f3lo corre en el procesador para el que se ha generado. Por ejemplo, un programa C compilado para un procesador Intel no puede ejecutarse en un procesador ARM, como los Ax de Apple . Ejemplos: C, C++ Diferentes momentos en la vida de un programa: tiempo de compilaci\u00f3n y tiempo de ejecuci\u00f3n Mayor eficiencia","title":"Compilaci\u00f3n"},{"location":"teoria/tema01-historia-lenguajes-programacion/tema01-historia-lenguajes-programacion.html#interpretacion","text":"Interpretaci\u00f3n Ejemplos: BASIC, Lisp, Scheme, Python, Ruby No hay diferencia entre el tiempo de compilaci\u00f3n y el tiempo de ejecuci\u00f3n Mayor flexibilidad: el c\u00f3digo se puede construir y ejecutar \"on the fly\" (funciones lambda o clousures) Los lenguajes interpretados suelen proporcionar un shell o int\u00e9rprete. Se trata de un entorno interactivo en el que podemos definir y evaluar expresiones. Este entorno se denomina en los c\u00edrculos de programaci\u00f3n funcional un REPL ( Read , Eval , Print , Loop ) y ya se utiliz\u00f3 en los primeros a\u00f1os de implementaci\u00f3n del Lisp. El uso del REPL promueve una programaci\u00f3n interactiva en la que continuamente evaluamos y comprobamos el c\u00f3digo que desarrollamos.","title":"Interpretaci\u00f3n"},{"location":"teoria/tema01-historia-lenguajes-programacion/tema01-historia-lenguajes-programacion.html#enfoques-mixtos","text":"Existen tambi\u00e9n enfoques mixtos, como el usado por el lenguaje de programaci\u00f3n Java, en el que se realizan ambos procesos. En una primera fase el compilador de Java ( javac ) realiza una traducci\u00f3n del c\u00f3digo fuente original a un c\u00f3digo intermedio binario independiente del procesado, denominado bytecode . Este c\u00f3digo binario es multiplataforma. El c\u00f3digo intermedio es interpretado despu\u00e9s por un el int\u00e9rprete ( java ) que ya s\u00ed que es dependiente de la plataforma. En la figura el int\u00e9rprete se denomina Virtual machine (no confundir con el concepto de m\u00e1quina virtual que permite emular un sistema operativo, por ejemplo VirtualBox). Enfoque mixto (Java) Ejemplos: Java, Scala","title":"Enfoques mixtos"},{"location":"teoria/tema01-historia-lenguajes-programacion/tema01-historia-lenguajes-programacion.html#bibliografia","text":"Introducci\u00f3n y cap\u00edtulo 1 del Structure and Interpretation of Computer Programs: Building Abstractions with Procedures Cap\u00edtulo 1.2 Programming Language Pragmatics: The Programming Language Spectrum Cap\u00edtulo 1.3 Programming Language Pragmatics, Why Study Programming Languages Cap\u00edtulo 1.4 Programming Language Pragmatics, Compilation and Interpretation Raul Rojas, \"Konrad Zuse's legacy the architecture of the Z1 and Z3\", IEEE Annals of the History of Computing, Vol. 19, No. 2, 1997 Charles Petzold, \"Code\", Microsoft Press, 2000 (Cap\u00edtulo 18: \"From Abaci to Chips\") Jack Copeland, \"The Modern History of Computing\", The Stanford Encyclopedia of Philosophy (Fall 2008 Edition), URL = http://plato.stanford.edu/archives/fall2008/entries/computing-history/ Georgi Dalakov, \"History of Computers\", URL = http://history-computer.com Lenguajes y Paradigmas de Programaci\u00f3n, curso 2019-20 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Domingo Gallardo, Cristina Pomares, Antonio Bot\u00eda, Francisco Mart\u00ednez","title":"Bibliograf\u00eda"},{"location":"teoria/tema02-programacion-funcional/tema02-programacion-funcional.html","text":"Tema 2: Programaci\u00f3n funcional \u00b6 El paradigma de Programaci\u00f3n Funcional \u00b6 Pasado y presente del paradigma funcional \u00b6 Definici\u00f3n y caracter\u00edsticas En una definici\u00f3n muy breve y concisa la programaci\u00f3n funcional define un programa de la siguiente forma: Definici\u00f3n de programa funcional En programaci\u00f3n funcional un programa es un conjunto de funciones matem\u00e1ticas que convierten unas entradas en unas salidas, sin ning\u00fan estado interno y ning\u00fan efecto lateral. Hablaremos m\u00e1s adelante de la no existencia de estado interno (variables en las que se guardan y se modifican valores) y de la ausencia de efectos laterales. Avancemos que estas son tambi\u00e9n caracter\u00edsticas de la programaci\u00f3n declarativa (frente a la programaci\u00f3n tradicional imperativa que es la que se utiliza en lenguajes como C o Java). En este sentido, la programaci\u00f3n funcional es un tipo concreto de programaci\u00f3n declarativa. Las caracter\u00edsticas principales del paradigma funcional son: Definiciones de funciones matem\u00e1ticas puras, sin estado interno ni efectos laterales Valores inmutables Uso profuso de la recursi\u00f3n en la definici\u00f3n de las funciones Uso de listas como estructuras de datos fundamentales Funciones como tipos de datos primitivos: expresiones lambda y funciones de orden superior Explicaremos estas propiedades a continuaci\u00f3n. Or\u00edgenes hist\u00f3ricos En los a\u00f1os 30, junto con la m\u00e1quina de Turing, se propusieron distintos modelos computacionales equivalentes que formalizaban el concepto de algoritmo . Uno de estos modelos fue el denominado C\u00e1lculo lambda propuesto por Alonzo Church en los a\u00f1os 30 y basado en la evaluaci\u00f3n de expresiones matem\u00e1ticas. En este formalismo los algoritmos se expresan mediante funciones matem\u00e1ticas en las que puede ser usada la recursi\u00f3n. Una funci\u00f3n matem\u00e1tica recibe par\u00e1metros de entrada y devuelve un valor. La evaluaci\u00f3n de la funci\u00f3n se realiza evaluando sus expresiones matem\u00e1ticas mediante la sustituci\u00f3n de los par\u00e1metros formales por los valores reales que se utilizan en la invocaci\u00f3n (el denominado modelo de sustituci\u00f3n que veremos m\u00e1s adelante). El c\u00e1lculo lambda es un formalismo matem\u00e1tico, basado en operaciones abstractas. Dos d\u00e9cadas despu\u00e9s, cuando los primeros computadores electr\u00f3nicos estaban empezando a utilizarse en grandes empresas y en universidades, este formalismo dio origen a algo mucho m\u00e1s tangible y pr\u00e1ctico: un lenguaje de alto nivel, mucho m\u00e1s expresivo que el ensamblador, con el que expresar operaciones y funciones que pueden ser definidas y evaluadas en el computador , el lenguaje de programaci\u00f3n Lisp. Historia y caracter\u00edsticas del Lisp Lisp es el primer lenguaje de programaci\u00f3n de alto nivel basado en el paradigma funcional. Creado en 1958 por John McCarthy. Lisp fue en su \u00e9poca un lenguaje revolucionario que introdujo nuevos conceptos de programaci\u00f3n no existentes entonces: funciones como objetos primitivos, funciones de orden superior, polimorfismo, listas, recursi\u00f3n, s\u00edmbolos, homogeneidad de datos y programas, bucle REPL ( Read-Eval-Print Loop ) La herencia del Lisp llega a lenguajes derivados de \u00e9l (Scheme, Golden Common Lisp) y a nuevos lenguajes de paradigmas no estrictamente funcionales, como C#, Python, Ruby, Objective-C o Scala. Lisp fue el primer lenguaje de programaci\u00f3n interpretado, con muchas caracter\u00edsticas din\u00e1micas que se ejecutan en tiempo de ejecuci\u00f3n ( run-time ). Entre estas caracter\u00edsticas podemos destacar la gesti\u00f3n de la memoria (creaci\u00f3n y destrucci\u00f3n autom\u00e1tica de memoria reservada para datos), la detecci\u00f3n de excepciones y errores en tiempo de ejecuci\u00f3n o la creaci\u00f3n en tiempo de ejecuci\u00f3n de funciones an\u00f3nimas (expresiones lambda ). Todas estas caracter\u00edsticas se ejecutan mediante un sistema de tiempo de ejecuci\u00f3n ( runtime system ) presente en la ejecuci\u00f3n de los programas. A partir del Lisp muchos otros lenguajes han usado estas caracter\u00edsticas de interpretaci\u00f3n o de sistemas de tiempo de ejecuci\u00f3n. Por ejemplo, lenguajes como BASIC, Python, Ruby o JavaScript son lenguajes interpretados. Y lenguajes como Java o C# tienen una avanzada plataforma de tiempo de ejecuci\u00f3n con soporte para la gesti\u00f3n de la memoria din\u00e1mica ( recolecci\u00f3n de basura , garbage collection ) o la compilaci\u00f3n just in time . Lisp no es un lenguaje exclusivamente funcional. Lisp se dise\u00f1\u00f3 con el objetivo de ser un lenguaje de alto nivel capaz de resolver problemas pr\u00e1cticos de Inteligencia Artificial, no con la idea de ser un lenguaje formal basado un \u00fanico modelo de computaci\u00f3n. Por ello en Lisp (y en Scheme) existen primitivas que se salen del paradigma funcional puro y permiten programar de formar imperativa (no declarativa), usando mutaci\u00f3n de estado y pasos de ejecuci\u00f3n. Sin embargo, durante la primera parte de la asignatura en la que estudiaremos la programaci\u00f3n funcional, no utilizaremos las instrucciones imperativas de Scheme sino que escribiremos c\u00f3digo exclusivamente funcional. Lenguajes de programaci\u00f3n funcional En los a\u00f1os 60 la programaci\u00f3n funcional definida por el Lisp fue dominante en departamentos de investigaci\u00f3n en Inteligencia Artificial (MIT por ejemplo). En los a\u00f1os 70, 80 y 90 se fue relegando cada vez m\u00e1s a los nichos acad\u00e9micos y de investigaci\u00f3n; en la empresa se impusieron los lenguajes imperativos y orientados a objetos. En la primera d\u00e9cada del 2000 han aparecido lenguajes que evolucionan de Lisp y que resaltan sus aspectos funcionales, aunque actualizando su sintaxis. Destacamos entre ellos: Clojure Erlang Tambi\u00e9n hay una tendencia desde mediados de la d\u00e9cada de 2000 de incluir aspectos funcionales como las expresiones lambda o las funciones de orden superior en lenguajes imperativos orientados a objetos, dando lugar a lenguajes multi-paradigma : Ruby Python Groovy Scala Swift Por \u00faltimo, en la d\u00e9cada del 2010 tambi\u00e9n se ha hecho popular un lenguaje exclusivamente funcional como Haskell . Este lenguaje, a diferencia de Scheme y de otros lenguajes multi-paradigma, no tienen ning\u00fan elemento imperativo y consigue que todas sus expresiones sean puramente funcionales. Aplicaciones pr\u00e1cticas de la programaci\u00f3n funcional En la actualidad el paradigma funcional es un paradigma de moda , como se puede comprobar observando la cantidad de art\u00edculos, charlas y blogs en los que se habla de \u00e9l, as\u00ed como la cantidad de lenguajes que est\u00e1n aplicando sus conceptos. Por ejemplo, solo como muestra, a continuaci\u00f3n puedes encontrar algunos enlaces a charlas y art\u00edculos interesantes publicados recientemente sobre programaci\u00f3n funcional: Lupo Montero - Introducci\u00f3n a la programaci\u00f3n funcional en JavaScript (Blog) Andr\u00e9s Marzal - Por qu\u00e9 deber\u00edas aprender programaci\u00f3n funcional ya mismo (Charla en YouTube) Mary Rose Cook - A practical introduction to functional programming (Blog) Ben Christensen - Functional Reactive Programming in the Netflix API (Charla en InfoQ) El auge reciente de estos lenguajes y del paradigma funcional se debe a varios factores, entre ellos que es un paradigma que facilita: la programaci\u00f3n de sistemas concurrentes, con m\u00faltiples hilos de ejecuci\u00f3n o con m\u00faltiples computadores ejecutando procesos conectados concurrentes. la definici\u00f3n y composici\u00f3n de m\u00faltiples operaciones sobre streams de forma muy concisa y compacta, aplicable a la programaci\u00f3n de sistemas distribuidos en Internet. la programaci\u00f3n interactiva y evolutiva. Programaci\u00f3n de sistemas concurrentes Veremos m\u00e1s adelante que una de las caracter\u00edsticas principales de la programaci\u00f3n funcional es que no se usa la mutaci\u00f3n (no se modifican los valores asignados a variables ni par\u00e1metros). Esta propiedad lo hace un paradigma excelente para implementar programas concurrentes, en los que existen m\u00faltiples hilos de ejecuci\u00f3n. La programaci\u00f3n de sistemas concurrentes es muy complicada con el paradigma imperativo tradicional, en el que la modificaci\u00f3n del estado de una variable compartida por m\u00e1s de un hilo puede provocar condiciones de carrera y errores dif\u00edcilmente localizables y reproducibles. Como dice Bartosz Milewski , investigador y te\u00f3rico de ciencia de computaci\u00f3n, en su respuesta en Quora a la pregunta \u00bfpor qu\u00e9 a los ingenieros de software les gusta la programaci\u00f3n funcional? : Bartosz Milewski: \u00bfPor qu\u00e9 es popular la programaci\u00f3n funcional? Porque es la \u00fanica forma pr\u00e1ctica de escribir programas concurrentes. Intentar escribir programas concurrentes en lenguajes imperativos, no s\u00f3lo es dif\u00edcil, sino que lleva a bugs que son muy dif\u00edciles de descubrir, reproducir y arreglar. En los lenguajes imperativos y, en particular, en los lenguajes orientados a objetos se ocultan las mutaciones y se comparten datos sin darse cuenta, por lo que son extremadamente propensos a los errores de concurrencia producidos por las condiciones de carrera. Definici\u00f3n y composici\u00f3n de operaciones sobre streams El paradigma funcional ha originado un estilo de programaci\u00f3n sobre streams de datos, en el que se concatenan operaciones como filter o map para definir de forma sencilla procesos y transformaciones as\u00edncronas aplicables a los elementos del stream . Este estilo de programaci\u00f3n ha hecho posible nuevas ideas de programaci\u00f3n, como la programaci\u00f3n reactiva , basada en eventos, o los futuros o promesas muy utilizados en lenguajes muy populares como JavaScript para realizar peticiones as\u00edncronas a servicios web. Por ejemplo, en el art\u00edculo Exploring the virtues of microservices with Play and Akka se explica con detalle las ventajas del uso de lenguajes y primitivas para trabajar con sistemas as\u00edncronos basados en eventos en servicios como Tumblr o Netflix. Otro ejemplo es el uso de Scala en Tumblr con el que se consigue crear c\u00f3digo que no tiene estado compartido y que es f\u00e1cilmente paralelizable entre los m\u00e1s de 800 servidores necesarios para atender picos de m\u00e1s de 40.000 peticiones por segundo: Uso de Scala en Tumblr Scala promueve que no haya estado compartido. El estado mutable se evita usando sentencias en Scala. No se usan m\u00e1quinas de estado de larga duraci\u00f3n. El estado se saca de la base de datos, se usa, y se escribe de nuevo en la base de datos. La ventaja principal es que los desarrolladores no tienen que preocuparse sobre hilos o bloqueos. Programaci\u00f3n evolutiva En la metodolog\u00eda de programaci\u00f3n denominada programaci\u00f3n evolutiva o iterativa los programas complejos se construyen a base de ir definiendo y probando elementos computacionales cada vez m\u00e1s complicados. Los lenguajes de programaci\u00f3n funcional encajan perfectamente en esta forma de construir programas. Como Abelson y Sussman comentan en el libro Structure and Implementation of Computer Programs (SICP): Abelson y Sussman sobre la programaci\u00f3n incremental En general, los objetos computacionales pueden tener estructuras muy complejas, y ser\u00eda extremadamente inconveniente tener que recordar y repetir sus detalles cada vez que queremos usarlas. En lugar de ello, se construyen programas complejos componiendo, paso a paso, objetos computacionales de creciente complejidad. El int\u00e9rprete hace esta construcci\u00f3n paso-a-paso de los programas particularmente conveniente porque las asociaciones nombre-objeto se pueden crear de forma incremental en interacciones sucesivas. Esta caracter\u00edstica favorece el desarrollo y prueba incremental de programas, y es en gran medida responsable del hecho de que un programa Lisp consiste normalmente de un gran n\u00famero de procedimientos relativamente simples. No hay que confundir una metodolog\u00eda de programaci\u00f3n con un paradigma de programaci\u00f3n. Una metodolog\u00eda de programaci\u00f3n proporciona sugerencias sobre c\u00f3mo debemos dise\u00f1ar, desarrollar y mantener una aplicaci\u00f3n que va a ser usada por usuarios finales. La programaci\u00f3n funcional se puede usar con m\u00faltiples metodolog\u00edas de programaci\u00f3n, debido a que los programas resultantes son muy claros, expresivos y f\u00e1ciles de probar. Evaluaci\u00f3n de expresiones y definici\u00f3n de funciones \u00b6 En la asignatura usaremos Scheme como primer lenguaje en el que exploraremos la programaci\u00f3n funcional. En el seminario de Scheme que se imparte en pr\u00e1cticas se estudiar\u00e1 en m\u00e1s profundidad los conceptos m\u00e1s importantes del lenguaje: tipos de datos, operadores, estructuras de control, int\u00e9rprete, etc. Evaluaci\u00f3n de expresiones Empezamos este apartado viendo c\u00f3mo se definen y eval\u00faan expresiones Scheme. Y despu\u00e9s veremos c\u00f3mo construir nuevas funciones. Scheme es un lenguaje que viene del Lisp. Una de sus caracter\u00edsticas principales es que las expresiones se construyen utilizando par\u00e9ntesis. Ejemplos de expresiones en Scheme, junto con el resultado de su ejecuci\u00f3n: 1 2 3 4 5 2 ; \u21d2 2 ( + 2 3 ) ; \u21d2 5 ( + ) ; \u21d2 0 ( + 2 4 5 6 ) ; \u21d2 17 ( + ( * 2 3 ) ( - 3 1 )) ; \u21d2 8 En programaci\u00f3n funcional en lugar de decir \"ejecutar una expresi\u00f3n\" se dice \" evaluar una expresi\u00f3n \", para reforzar la idea de que se tratan de expresiones matem\u00e1ticas que siempre devuelven uno y s\u00f3lo un resultado . Las expresiones se definen con una notaci\u00f3n prefija: el primer elemento despu\u00e9s del par\u00e9ntesis de apertura es el operador de la expresi\u00f3n y el resto de elementos (hasta el par\u00e9ntesis de cierre) son sus operandos. Por ejemplo, en la expresi\u00f3n (+ 2 4 5 6) el operador es el s\u00edmbolo + que representa funci\u00f3n suma y los operandos son los n\u00fameros 2, 4, 5 y 6. Puede haber expresiones que no tengan operandos, como el ejemplo (+) , cuya evaluaci\u00f3n devuelve 0. Una idea fundamental de Lisp y Scheme es que los par\u00e9ntesis se eval\u00faan de dentro a fuera. Por ejemplo, la expresi\u00f3n 1 ( + ( * 2 3 ) ( - 3 ( / 12 3 ))) que devuelve 5, se eval\u00faa as\u00ed: 1 2 3 4 5 ( + ( * 2 3 ) ( - 3 ( / 12 3 ))) \u21d2 ( + 6 ( - 3 ( / 12 3 ))) \u21d2 ( + 6 ( - 3 4 )) \u21d2 ( + 6 -1 ) \u21d2 5 La evaluaci\u00f3n de cada expresi\u00f3n devuelve un valor que se utiliza para continuar calculando la expresi\u00f3n exterior. En el caso anterior primero se eval\u00faa la expresi\u00f3n (* 2 3) que devuelve 6, despu\u00e9s se eval\u00faa (/ 12 3) que devuelve 4, despu\u00e9s se eval\u00faa (- 3 4) que devuelve -1 y por \u00faltimo se eval\u00faa (+ 6 -1) que devuelve 5 Cuando se eval\u00faa una expresi\u00f3n en el int\u00e9rprete de Scheme el resultado aparece en la siguiente l\u00ednea. Definici\u00f3n de funciones En programaci\u00f3n funcional las funciones son similares a las funciones matem\u00e1ticas: reciben par\u00e1metros y devuelven siempre un \u00fanico resultado de operar con esos par\u00e1metros. Por ejemplo, podemos definir la funci\u00f3n (cuadrado x) que devuelve el cuadrado de un n\u00famero que pasamos como par\u00e1metro: 1 2 ( define ( cuadrado x ) ( * x x )) Despu\u00e9s del nombre de la funci\u00f3n se declaran sus argumentos. El n\u00famero de argumentos de una funci\u00f3n se denomina aridad de la funci\u00f3n . Por ejemplo, la funci\u00f3n cuadrado es una funci\u00f3n de aridad 1, o unaria . Despu\u00e9s de declarar los par\u00e1metros, se define el cuerpo de la funci\u00f3n. Es una expresi\u00f3n que se evaluar\u00e1 con el valor que se pase como par\u00e1metro. En el caso anterior la expresi\u00f3n es (* x x) y multiplicar\u00e1 el par\u00e1metro por si mismo. Hay que hacer notar que en Scheme no existe la palabra clave return , sino que las funciones siempre se definen con una \u00fanica expresi\u00f3n cuya evaluaci\u00f3n es el resultado que se devuelve. Una vez definida la funci\u00f3n cuadrado podemos usarla de la misma forma que las funciones primitivas de Scheme: 1 2 ( cuadrado 10 ) ; \u21d2 100 ( cuadrado ( + 10 ( cuadrado ( + 2 4 )))) ; \u21d2 2116 La evaluaci\u00f3n de la \u00faltima expresi\u00f3n se hace de la siguiente forma: 1 2 3 4 5 ( cuadrado ( + 10 ( cuadrado ( + 2 4 )))) \u21d2 ( cuadrado ( + 10 ( cuadrado 6 ))) \u21d2 ( cuadrado ( + 10 36 )) \u21d2 ( cuadrado 46 ) \u21d2 2116 Definici\u00f3n de funciones auxiliares Las funciones definidas se pueden utilizar a su vez para construir otras funciones. Lo habitual en programaci\u00f3n funcional es definir funciones muy peque\u00f1as e ir construyendo funciones cada vez de mayor nivel usando las anteriores. Ejemplo: suma de cuadrados Por ejemplo, supongamos que tenemos que definir una funci\u00f3n que devuelva la suma del cuadrado de dos n\u00fameros. Podr\u00edamos definirla escribiendo la expresi\u00f3n completa, pero queda una definici\u00f3n poco legible. 1 2 3 4 5 ; Definici\u00f3n poco legible de la suma de cuadrados ( define ( suma-cuadrados x y ) ( + ( * x x ) ( * y y ))) Podemos hacer una definici\u00f3n mucho m\u00e1s legible si usamos la funci\u00f3n cuadrado definida anteriormente: 1 2 3 4 5 6 7 8 9 ; Definici\u00f3n de suma de cuadrados m\u00e1s legible. ; Usamos la funci\u00f3n auxiliar 'cuadrado' ( define ( cuadrado x ) ( * x x )) ( define ( suma-cuadrados x y ) ( + ( cuadrado x ) ( cuadrado y ))) Esta segunda definici\u00f3n es mucho m\u00e1s expresiva. Leyendo el c\u00f3digo queda muy claro qu\u00e9 es lo que queremos hacer. Ejemplo: tiempo de impacto Veamos otro ejemplo de uso de funciones auxiliares. Supongamos que estamos programando un juego de guerra de barcos y submarinos, en el que utilizamos las coordenadas del plano para situar todos los elementos de nuestra flota. Supongamos que necesitamos calcular el tiempo que tarda un torpedo en llegar desde una posici\u00f3n (x1, y1) a otra (x2, y2) . Suponemos que la velocidad del torpedo es otro par\u00e1metro v . \u00bfC\u00f3mo calcular\u00edamos este tiempo de impacto? La forma menos correcta de hacerlo es definir todo el c\u00e1lculo en una \u00fanica expresi\u00f3n. Como en programaci\u00f3n funcional las funciones deben definirse con una \u00fanica expresi\u00f3n debemos realizar todo el c\u00e1lculo en forma de expresiones anidadas, unas dentro de otras. Esto construye una funci\u00f3n que calcula bien el resultado. El problema que tiene es que es muy dif\u00edcil de leer y entender para un compa\u00f1ero (o para nosotros mismos, cuando pasen unos meses): 1 2 3 4 5 6 7 8 9 10 11 12 ; ; Definici\u00f3n incorrecta: muy poco legible ; ; La funci\u00f3n tiempo-impacto devuelve el tiempo que tarda ; en llegar un torpedo a la velocidad v desde la posici\u00f3n ; (x1, y1) a la posici\u00f3n (x2, y2) ; ( define ( tiempo-impacto x1 y1 x2 y2 v ) ( / ( sqrt ( + ( * ( - x2 x1 ) ( - x2 x1 )) ( * ( - y2 y1 ) ( - y2 y1 )))) v )) La funci\u00f3n anterior hace bien el c\u00e1lculo pero es muy complicada de modificar y de entender. La forma m\u00e1s correcta de definir la funci\u00f3n ser\u00eda usando varias funciones auxiliares. F\u00edjate que es muy importante tambi\u00e9n poner los nombres correctos a cada funci\u00f3n, para entender qu\u00e9 hace. Scheme es un lenguaje d\u00e9bilmente tipado y no tenemos la ayuda de los tipos que nos dan m\u00e1s contexto de qu\u00e9 es cada par\u00e1metro y qu\u00e9 devuelve la funci\u00f3n. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 ; Definici\u00f3n correcta, modular y legible de la funci\u00f3n tiempo-impacto ; ; La funci\u00f3n 'cuadrado' devuelve el cuadrado de un n\u00famero ; ( define ( cuadrado x ) ( * x x )) ; ; La funci\u00f3n 'distancia' devuelve la distancia entre dos ; coordenadas (x1, y1) y (x2, y2) ; ( define ( distancia x1 y1 x2 y2 ) ( sqrt ( + ( cuadrado ( - x2 x1 )) ( cuadrado ( - y2 y1 ))))) ; ; La funci\u00f3n 'tiempo' devuelve el tiempo que ; tarda en recorrer un m\u00f3vil una distancia d a un velocidad v ; ( define ( tiempo distancia velocidad ) ( / distancia velocidad )) ; ; La funci\u00f3n 'tiempo-impacto' devuelve el tiempo que tarda ; en llegar un torpedo a la velocidad v desde la posici\u00f3n ; (x1, y1) a la posici\u00f3n (x2, y2) ; ( define ( tiempo-impacto x1 y1 x2 y2 velocidad ) ( tiempo ( distancia x1 y1 x2 y2 ) velocidad )) En esta segunda versi\u00f3n definimos m\u00e1s funciones, pero cada una es mucho m\u00e1s legible. Adem\u00e1s las funciones como cuadrado , distancia o tiempo las vamos a poder reutilizar para otros c\u00e1lculos. Funciones puras A diferencia de lo que hemos visto en programaci\u00f3n imperativa, en programaci\u00f3n funcional no es posible definir funciones con estado local. Las funciones que se definen son funciones matem\u00e1ticas puras, que cumplen las siguientes condiciones: No modifican los par\u00e1metros que se les pasa Devuelven un \u00fanico resultado No tienen estado local ni el resultado depende de un estado exterior mutable Esta \u00faltima propiedad es muy importante y quiere decir que la funci\u00f3n siempre devuelve el mismo valor cuando se le pasan los mismos par\u00e1metros. Las funciones puras son muy f\u00e1ciles de entender porque no es necesario tener en cuenta ning\u00fan contexto a la hora de describir su funcionamiento. El valor devuelto \u00fanicamente depende de los par\u00e1metros de entrada. Por ejemplo, funciones matem\u00e1ticas como suma, resta, cuadrado, sin, cos, etc. cumplen esta propiedad. Composici\u00f3n de funciones Una idea fundamental de la programaci\u00f3n funcional es la composici\u00f3n de funciones que transforman unos datos de entrada en otros de salida. Es una idea muy actual, porque es la forma en la que est\u00e1n planteados muchos algoritmos de procesamiento de datos en inteligencia artificial. Por ejemplo, podemos representar de la siguiente forma el algoritmo que maneja un veh\u00edculo aut\u00f3nomo: Las cajas representa funciones que transforman los datos de entrada (im\u00e1genes tomadas por las c\u00e1maras del veh\u00edculo) en los datos de salida (acciones a realizar sobre la direcci\u00f3n y el motor del veh\u00edculo). Las funciones intermedias representan transformaciones que se realizan sobre los datos de entrada y obtienen los datos de salida. En un lenguaje de programaci\u00f3n funcional como Scheme el diagrama anterior se escribir\u00eda con el siguiente c\u00f3digo: 1 2 3 4 5 ( define ( conduce-vehiculo imagenes ) ( obten-acciones ( reconoce ( filtra ( obten-caracteristicas imagenes ))))) Veremos m\u00e1s adelante que las expresiones en Scheme se eval\u00faan de dentro a fuera y que tienen notaci\u00f3n prefija. El resultado de cada funci\u00f3n constituye la entrada de la siguiente. En el caso de la funci\u00f3n conduce-vehiculo primero se obtienen las caracter\u00edsticas de las im\u00e1genes, despu\u00e9s se filtran, despu\u00e9s se reconoce la escena y, por \u00faltimo, se obtienen las acciones para conducir el veh\u00edculo. Programaci\u00f3n declarativa vs. imperativa \u00b6 Hemos dicho que la programaci\u00f3n funcional es un estilo de programaci\u00f3n declarativa, frente a la programaci\u00f3n tradicional de los lenguajes denominados imperativos. Vamos a explicar esto un poco m\u00e1s. Programaci\u00f3n declarativa Empecemos con lo que conocemos todos: un programa imperativo . Se trata de un conjunto de instrucciones que se ejecutan una tras otra (pasos de ejecuci\u00f3n) de forma secuencial. En la ejecuci\u00f3n de estas instrucciones se van cambiando los valores de las variables y, dependiendo de estos valores, se modifica el flujo de control de la ejecuci\u00f3n del programa. Para entender el funcionamiento de un programa imperativo debemos imaginar toda la evoluci\u00f3n del programa, los pasos que se ejecutan y cu\u00e1l es el flujo de control en funci\u00f3n de los cambios de los valores en las variables. En la programaci\u00f3n declarativa , sin embargo, utilizamos un paradigma totalmente distinto. Hablamos de programaci\u00f3n declarativa para referirnos a lenguajes de programaci\u00f3n (o sentencias de c\u00f3digo) en los que se declaran los valores, objetivos o caracter\u00edsticas de los elementos del programa y en cuya ejecuci\u00f3n no existe mutaci\u00f3n (modificaci\u00f3n de valores de variables) ni secuencias de pasos de ejecuci\u00f3n. De esta forma, la ejecuci\u00f3n de un programa declarativo tiene que ver m\u00e1s con alg\u00fan modelo formal o matem\u00e1tico que con un programa tradicional imperativo. Define un conjunto de reglas y definiciones de estilo matem\u00e1tico . La programaci\u00f3n declarativa no es exclusiva de los lenguajes funcionales. Existen muchos lenguajes no funcionales con caracter\u00edsticas declarativas. Por ejemplo Prolog, en el que un programa se define como un conjunto de reglas l\u00f3gicas y su ejecuci\u00f3n realiza una deducci\u00f3n l\u00f3gica matem\u00e1tica que devuelve un resultado. En dicha ejecuci\u00f3n no son relevantes los pasos internos que realiza el sistema sino las relaciones l\u00f3gicas entre los datos y los resultados finales. Un ejemplo claro de programaci\u00f3n declarativa es una hoja de c\u00e1lculo . Las celdas contiene valores o expresiones matem\u00e1ticas que se actualizan autom\u00e1ticamente cuando cambiamos los valores de entrada. La relaci\u00f3n entre valores y resultados es totalmente matem\u00e1tica y para su c\u00e1lculo no tenemos que tener en cuenta pasos de ejecuci\u00f3n. Evidente, por debajo de la hoja de c\u00e1lculo existe un programa que realiza el su c\u00e1lculo de la hoja, pero cuando estamos us\u00e1ndola no nos preocupa esa implementaci\u00f3n. Podemos no preocuparnos de ella y usar \u00fanicamente el modelo matem\u00e1tico definido en la hoja. Otro ejemplo muy actual de programaci\u00f3n declarativa es SwiftUI, el nuevo API creado por Apple para definir las interfaces de usuario de las aplicaciones iOS. En el c\u00f3digo de la imagen vemos una descripci\u00f3n de c\u00f3mo est\u00e1 definida la aplicaci\u00f3n: una lista de lugares ( landmarks ) apilada verticalmente. Para cada lugar se define su imagen, su texto, y una estrella si el lugar es favorito. El c\u00f3digo es declarativo porque no hay pasos de ejecuci\u00f3n para definir la interfaz. No existe un bucle que va a\u00f1adiendo elementos a la interfaz. Vemos una declaraci\u00f3n de c\u00f3mo la interfaz va estar definida. El compilador del lenguaje y el API son los responsables de construir esa declaraci\u00f3n y mostrar la interfaz tal y como nosotros queremos. Declaraci\u00f3n de funciones La programaci\u00f3n funcional utiliza un estilo de programaci\u00f3n declarativo. Declaramos funciones en las que se transforman unos datos de entrada en unos datos de salida. Veremos que esta transformaci\u00f3n se realiza mediante la evaluaci\u00f3n de expresiones, sin definir valores intermedios, ni variables auxiliares, ni pasos de ejecuci\u00f3n. \u00danicamente se van componiendo llamadas a funciones auxiliares que construyen el valor resultante. Tal y como ya hemos visto, el siguiente ejemplo es una declaraci\u00f3n en Scheme de una funci\u00f3n que toma como entrada un n\u00famero y devuelve su cuadrado: 1 2 ( define ( cuadrado x ) ( * x x )) En el cuerpo de la funci\u00f3n cuadrado vemos que no se utiliza ninguna variable auxiliar, sino que \u00fanicamente se llama a la funci\u00f3n * (multiplicaci\u00f3n) pasando el valor de x . El valor resultante es el que se devuelve. Por ejemplo, si llamamos a la funci\u00f3n pas\u00e1ndole el par\u00e1metro 4 devuelve el resultado de multiplicar 4 por si mismo, 16. 1 ( cuadrado 4 ) ; \u21d2 16 Programaci\u00f3n imperativa Repasemos un algunas caracter\u00edsticas propias de la programaci\u00f3n imperativa que no existen en la programaci\u00f3n funcional . Son caracter\u00edsticas a las que estamos muy habituados porque son propias de los lenguajes m\u00e1s populares y con los que hemos aprendido a programar (C, C++, Java, python, etc.) Pasos de ejecuci\u00f3n Mutaci\u00f3n Efectos laterales Estado local mutable en las funciones Veremos que, aunque parece imposible, es posible programar sin utilizar estas caracter\u00edsticas. Lo demuestran lenguajes de programaci\u00f3n funcional como Haskell, Clojure o el propio Scheme. Pasos de ejecuci\u00f3n Una de las caracter\u00edsticas b\u00e1sicas de la programaci\u00f3n imperativa es la utilizaci\u00f3n de pasos de ejecuci\u00f3n. Por ejemplo, en C podemos realizar los siguientes pasos de ejecuci\u00f3n: 1 2 3 4 int a = cuadrado ( 8 ); int b = doble ( a ); int c = cuadrado ( b ); return c O, por ejemplo, si queremos filtrar y procesar una lista de pedidos en Swift podemos hacerlo en dos sentencias: 1 2 3 filtrados = filtra ( pedidos ); procesados = procesa ( filtrados ); return procesados ; Sin embargo, en programaci\u00f3n funcional (por ejemplo, Scheme) no existen pasos de ejecuci\u00f3n separados por sentencias. Como hemos visto antes, la forma t\u00edpica de expresar las instrucciones anteriores es componer todas las operaciones en una \u00fanica instrucci\u00f3n: 1 ( cuadrado ( doble ( cuadrado 8 ))) ; \u21d2 16384 El segundo ejemplo lo podemos componer de la misma forma: 1 ( procesa ( filtra pedidos )) Mutaci\u00f3n En los lenguajes imperativos es com\u00fan modificar el valor de las variables en los pasos de ejecuci\u00f3n: 1 2 int x = 10 ; int x = x + 1 ; La expresi\u00f3n x = x + 1 es una expresi\u00f3n de asignaci\u00f3n que modifica el valor anterior de una variable por un nuevo valor. El estado de las variables (su valor) cambia con la ejecuci\u00f3n de los pasos del programa. A esta asignaci\u00f3n que modifica un valor ya existente se le denomina asignaci\u00f3n destructiva o mutaci\u00f3n . En programaci\u00f3n imperativa tambi\u00e9n se puede modificar (mutar) el valor de componentes de estructuras de datos, como posiciones de un array, de una lista o de un diccionario. En programaci\u00f3n funcional, por contra, las definiciones son inmutables , y una vez asignado un valor a un identificador no se puede modificar \u00e9ste. En programaci\u00f3n funcional no existe sentencia de asignaci\u00f3n que pueda modificar un valor ya definido. Se entienden las variables como variables matem\u00e1ticas, no como referencias a una posiciones de memoria que puede ser modificada. Por ejemplo, la forma especial define en Scheme crea un nuevo identificador y le da el valor definido de forma permanente. Si escribimos el siguiente c\u00f3digo en un programa en Scheme R6RS: 1 2 3 4 #lang racket ( define a 12 ) ( define a 200 ) tendremos el siguiente error: 1 module: identifier already defined in: a Nota En el int\u00e9rprete REPL del DrRacket s\u00ed que podemos definir m\u00e1s de una vez la misma funci\u00f3n o identificador. Se ha dise\u00f1ado as\u00ed para facilitar el uso del int\u00e9rprete para la prueba de expresiones en Scheme. En los lenguajes de programaci\u00f3n imperativos es habitual introducir tambi\u00e9n sentencias declarativas. Por ejemplo, en el siguiente c\u00f3digo Java las l\u00edneas 1 y 3 las podr\u00edamos considerar declarativas y las 2 y 4 imperativas: 1 2 3 4 1. int x = 1; 2. x = x+1; 3. int y = x+1; 4. y = x; Mutaci\u00f3n y efectos laterales En programaci\u00f3n imperativa es habitual tambi\u00e9n trabajar con referencias y hacer que m\u00e1s de un identificador referencie el mismo valor. Esto produce la posibilidad de que la mutaci\u00f3n del valor a trav\u00e9s de uno de los identificadores produzca un efecto lateral ( side effect en ingl\u00e9s) en el que el valor de un identificador cambia sin ejecutar ninguna expresi\u00f3n en la que se utilice expl\u00edcitamente el propio identificador. Por ejemplo, en la mayor\u00eda de lenguajes orientados a objetos los identificadores guardan referencias a objetos. De forma que si asignamos un objeto a m\u00e1s de un identificador, todos los identificadores est\u00e1n accediendo al mismo objeto. Si mutamos alg\u00fan valor del objeto a trav\u00e9s de un identificador provocamos un efecto lateral en los otros identificadores. Por ejemplo, lo siguiente es un ejemplo de una mutaci\u00f3n en programaci\u00f3n imperativa, en la que se modifican los atributos de un objeto en Java: 1 2 3 4 Point2D p1 = new Point2D ( 3.0 , 2.0 ); // creamos un punto 2D con coordX=3.0 y coordY=2.0 p1 . getCoordX (); // la coord x de p2 es 3.0 p1 . setCoordX ( 10.0 ); p1 . getCoordX (); // la coord x de p1 es 10.0 Si el objeto est\u00e1 asignado a m\u00e1s de una variable tendremos el efecto lateral ( side effect ) en el que el dato guardado en una variable cambia despu\u00e9s de una sentencia en la que no se ha usado esa variable: 1 2 3 4 5 Point2D p1 = new Point2D ( 3.0 , 2.0 ); // la coord x de p1 es 3.0 p1 . getCoordX (); // la coord x de p1 es 3.0 Point2D p2 = p1 ; p2 . setCoordX ( 10.0 ); p1 . getCoordX (); // la coord x de p1 es 10.0, sin que ninguna sentencia haya modificado directamente p1 El mismo ejemplo anterior, en C: 1 2 3 4 5 6 7 8 9 10 typedef struct { float x ; float y ; } TPunto ; TPunto p1 = { 3.0 , 2.0 }; printf ( \"Coordenada x: %f\" , p1 . x ); // 3.0 TPunto * p2 = & p1 ; p2 -> x = 10.0 ; printf ( \"Coordenada x: %f\" , p1 . x ); // 10.0 Efecto lateral Los efectos laterales son los responsables de muchos bugs y hay que ser muy consciente de su uso. Son especialmente complicados de depurar los bugs debidos a efectos laterales en programas concurrentes con m\u00faltiples hilos de ejecuci\u00f3n, en los que varios hilos pueden acceder a las mismas referencias y provocar condiciones de carrera . Por otro lado, tambi\u00e9n existen situaciones en las que su utilizaci\u00f3n permite ganar mucha eficiencia porque podemos definir estructuras de datos en el que los valores son compartidos por varias referencias y modificando un \u00fanico valor se actualizan de forma instant\u00e1nea esas referencias. En los lenguajes en los que no existe la mutaci\u00f3n no se producen efectos laterales, ya que no es posible modificar el valor de una variable una vez establecido. Los programas que escribamos en estos lenguajes van a estar libres de este tipo de bugs y van a poder ser ejecutado sin problemas en hilos de ejecuci\u00f3n concurrente. Por otro lado, la ausencia de mutaci\u00f3n hace que sean algo m\u00e1s costosas ciertas operaciones, como la construcci\u00f3n de estructuras de datos nuevas a partir de estructuras ya existentes. Veremos, por ejemplo, que la \u00fanica forma de a\u00f1adir un elemento al final de una lista ser\u00e1 construir una lista nueva con todos los elementos de la lista original y el nuevo elemento. Esta operaci\u00f3n tiene un coste lineal con el n\u00famero de elementos de la lista. Sin embargo, en una lista en la que pudi\u00e9ramos utilizar la mutaci\u00f3n podr\u00edamos implementar esta operaci\u00f3n con coste constante. Estado local mutable Otra caracter\u00edstica de la programaci\u00f3n imperativa es lo que se denomina estado local mutable en funciones, procedimientos o m\u00e9todos. Se trata la posibilidad de que una invocaci\u00f3n a un m\u00e9todo o una funci\u00f3n modifique un cierto estado, de forma que la siguiente invocaci\u00f3n devuelva un valor distinto. Es una caracter\u00edstica b\u00e1sica de la programaci\u00f3n orientada a objetos, donde los objetos guardan valores que se modifican con la invocaciones a sus m\u00e9todos. Por ejemplo, en Java, podemos definir un contador que incrementa su valor: 1 2 3 4 5 6 7 8 9 10 11 12 public class Contador { int c ; public Contador ( int valorInicial ) { c = valorInicial ; } public int valor () { c ++ ; return c ; } } Cada llamada al m\u00e9todo valor() devolver\u00e1 un valor distinto: 1 2 3 4 Contador cont = new Contador ( 10 ); cont . valor (); // 11 cont . valor (); // 12 cont . valor (); // 13 Tambi\u00e9n se pueden definir funciones con estado local mutable en C: 1 2 3 4 5 6 int function contador () { static int c = 0 ; c ++ ; return c ; } Cada llamada a la funci\u00f3n contador() devolver\u00e1 un valor distinto: 1 2 3 contador () ;; 1 contador () ;; 2 contador () ;; 3 Por el contrario, los lenguajes funcionales tienen la propiedad de transparencia referencial : es posible sustituir cualquier aparici\u00f3n de una expresi\u00f3n por su resultado sin que cambia el resultado final del programa. Dicho de otra forma, en programaci\u00f3n funcional, una funci\u00f3n siempre devuelve el mismo valor cuando se le llama con los mismos par\u00e1metros . Las funciones no modifican ning\u00fan estado, no acceden a ninguna variable ni objeto global y modifican su valor. Resumen Un resumen de las caracter\u00edsticas fundamentales de la programaci\u00f3n declarativa frente a la programaci\u00f3n imperativa. En los siguientes apartados explicaremos m\u00e1s estas caracter\u00edsticas. Caracter\u00edsticas de la programaci\u00f3n declarativa Variable = nombre dado a un valor (declaraci\u00f3n) En lugar de pasos de ejecuci\u00f3n se utiliza la composici\u00f3n de funciones No existe asignaci\u00f3n ni cambio de estado No existe mutaci\u00f3n, se cumple la transferencia referencial : dentro de un mismo \u00e1mbito todas las ocurrencias de una variable y las llamadas a funciones devuelven el mismo valor Caracter\u00edsticas de la programaci\u00f3n imperativa Variable = nombre de una zona de memoria Asignaci\u00f3n Referencias Pasos de ejecuci\u00f3n Modelo de computaci\u00f3n de sustituci\u00f3n \u00b6 Un modelo computacional es un formalismo (conjunto de reglas) que definen el funcionamiento de un programa. En el caso de los lenguajes funcionales basados en la evaluaci\u00f3n de expresiones, el modelo computacional define cu\u00e1l ser\u00e1 el resultado de evaluar una expresi\u00f3n. El modelo de sustituci\u00f3n es un modelo muy sencillo que permite definir la sem\u00e1ntica de la evaluaci\u00f3n de expresiones en lenguajes funcionales como Scheme. Se basa en una versi\u00f3n simplificada de la regla de reducci\u00f3n del c\u00e1lculo lambda. Es un modelo basado en la reescritura de unos t\u00e9rminos por otros. Aunque se trata de un modelo abstracto, ser\u00eda posible escribir un int\u00e9rprete que, bas\u00e1ndose en este modelo, eval\u00fae expresiones funcionales. Supongamos un conjunto de definiciones en Scheme: 1 2 3 4 5 6 7 8 9 10 ( define ( doble x ) ( + x x )) ( define ( cuadrado y ) ( * y y )) ( define ( f z ) ( + ( cuadrado ( doble z )) 1 )) ( define a 2 ) Supongamos que, una vez realizadas esas definiciones, se eval\u00faa la siguiente expresi\u00f3n: 1 ( f ( + a 1 )) \u00bfCu\u00e1l ser\u00e1 su resultado? Si lo hacemos de forma intuitiva podemos pensar que 37 . Si lo comprobamos en el int\u00e9rprete de Scheme veremos que devuelve 37. \u00bfHemos seguido algunas reglas espec\u00edficas? \u00bfQu\u00e9 reglas son las que sigue el int\u00e9rprete? \u00bfPodr\u00edamos implementar nosotros un int\u00e9rprete similar? S\u00ed, usando las reglas del modelo de sustituci\u00f3n. El modelo de sustituci\u00f3n define cuatro reglas sencillas para evaluar una expresi\u00f3n. Llamemos a la expresi\u00f3n e . Las reglas son las siguientes: Si e es un valor primitivo (por ejemplo, un n\u00famero), devolvemos ese mismo valor. Si e es un identificador, devolvemos su valor asociado con un define (se lanzar\u00e1 un error si no existe ese valor). Si e es una expresi\u00f3n del tipo (f arg1 ... argn) , donde f es el nombre de una funci\u00f3n primitiva ( + , - , ...), evaluamos uno a uno los argumentos arg1 ... argn (con estas mismas reglas) y evaluamos la funci\u00f3n primitiva con los resultados. La regla 4 tiene dos variantes, dependiendo del orden de evaluaci\u00f3n que utilizamos. Orden aplicativo Si e es una expresi\u00f3n del tipo (f arg1 ... argn) , donde f es el nombre de una funci\u00f3n definida con un define , tenemos que evaluar primero los argumentos arg1 ... argn y despu\u00e9s sustituir f por su cuerpo , reemplazando cada par\u00e1metro formal de la funci\u00f3n por el correspondiente argumento evaluado . Despu\u00e9s evaluaremos la expresi\u00f3n resultante usando estas mismas reglas. Orden normal Si e es una expresi\u00f3n del tipo (f arg1 ... argn) , donde f es el nombre de una funci\u00f3n definida con un define , tenemos que sustituir f por su cuerpo , reemplazando cada par\u00e1metro formal de la funci\u00f3n por el correspondiente argumento sin evaluar . Despu\u00e9s evaluar la expresi\u00f3n resultante usando estas mismas reglas. En el orden aplicativo se realizan las evaluaciones antes de realizar las sustituciones, lo que define una evaluaci\u00f3n de dentro a fuera de los par\u00e9ntesis. Cuando se llega a una expresi\u00f3n primitiva se eval\u00faa. En el orden normal se realizan todas las sustituciones hasta que se tiene una larga expresi\u00f3n formada por expresiones primitivas; se eval\u00faa entonces. Ambas formas de evaluaci\u00f3n dar\u00e1n el mismo resultado en programaci\u00f3n funcional. Scheme utiliza el orden aplicativo. Ejemplo 1 Vamos a empezar con un ejemplo sencillo para comprobar c\u00f3mo se eval\u00faa una misma expresi\u00f3n utilizando ambos modelos de sustituci\u00f3n. Supongamos las siguientes definiciones: 1 2 3 4 5 6 7 ( define ( doble x ) ( + x x )) ( define ( cuadrado y ) ( * y y )) ( define a 2 ) Queremos evaluar la siguiente expresi\u00f3n: 1 ( doble ( cuadrado a )) La evaluaci\u00f3n utilizando el modelo de sustituci\u00f3n aplicativo , usando paso a paso las reglas anteriores, es la siguiente (en cada l\u00ednea se indica entre par\u00e9ntesis la regla usada): 1 2 3 4 5 6 (doble (cuadrado a)) \u21d2 ; Sustituimos a por su valor (R2) (doble (cuadrado 2)) \u21d2 ; Sustitumos cuadrado por su cuerpo (R4) (doble (* 2 2)) \u21d2 ; Evaluamos (* 2 2) (R3) (doble 4) \u21d2 ; Sustituimos doble por su cuerpo (R4) (+ 4 4) \u21d2 ; Evaluamos (+ 4 4) (R3) 8 Podemos comprobar que en el modelo aplicativo se intercalan las sustituciones de una funci\u00f3n por su cuerpo (regla 4) y las evaluaciones de expresiones (regla 3). Por el contrario, la evaluaci\u00f3n usando el modelo de sustituci\u00f3n normal es: 1 2 3 4 5 6 7 (doble (cuadrado a)) \u21d2 ; Sustituimos doble por su cuerpo (R4) (+ (cuadrado a) (cuadrado a) \u21d2 ; Sustituimos cuadrado por su cuerpo (R4) (+ (* a a) (* a a) \u21d2 ; Sustitumos a por su valor (R2) (+ (* 2 2) (* 2 2) \u21d2 ; Evaluamos (* 2 2) (R3) (+ 4 (* 2 2)) \u21d2 ; Evaluamos (* 2 2) (R3) (+ 4 4) \u21d2 ; Evaluamos (+ 4 4) (R3) 8 Al usar este modelo de evaluaci\u00f3n primero se realizan todas las sustituciones (regla 4) y despu\u00e9s todas las evaluaciones (regla 3). Las sustituciones se hacen de izquierda a derecha (de fuera a dentro de los par\u00e9ntesis). Primero se sustituye doble por su cuerpo y despu\u00e9s cuadrado . Ejemplo 2 Veamos la evaluaci\u00f3n del ejemplo algo m\u00e1s complicado que hemos planteado al comienzo: 1 2 3 4 5 6 7 8 9 10 ( define ( doble x ) ( + x x )) ( define ( cuadrado y ) ( * y y )) ( define ( f z ) ( + ( cuadrado ( doble z )) 1 )) ( define a 2 ) Expresi\u00f3n a evaluar: 1 ( f ( + a 1 )) Resultado de la evaluaci\u00f3n usando el modelo de sustituci\u00f3n aplicativo : 1 2 3 4 5 6 7 8 9 10 (f (+ a 1)) \u21d2 ; Para evaluar f, evaluamos primero su argumento (+ a 1) (R4) ; y sustituimos a por 2 (R2) (f (+ 2 1)) \u21d2 ; Evaluamos (+ 2 1) (R3) (f 3) \u21d2 ; (R4) (+ (cuadrado (doble 3)) 1) \u21d2 ; Sustituimos (doble 3) (R4) (+ (cuadrado (+ 3 3)) 1) \u21d2 ; Evaluamos (+ 3 3) (R3) (+ (cuadrado 6) 1) \u21d2 ; Sustitumos (cuadrado 6) (R4) (+ (* 6 6) 1) \u21d2 ; Evaluamos (* 6 6) (R3) (+ 36 1) \u21d2 ; Evaluamos (+ 36 1) (R3) 37 Y veamos el resultado de usar el modelo de sustituci\u00f3n normal : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 (f (+ a 1)) \u21d2 ; Sustituimos (f (+ a 1)) ; por su definici\u00f3n, con z = (+ a 1) (R4) (+ (cuadrado (doble (+ a 1))) 1) \u21d2 ; Sustituimos (cuadrado ...) (R4) (+ (* (doble (+ a 1)) (doble (+ a 1))) 1) ; Sustituimos (doble ...) (R4) (+ (* (+ (+ a 1) (+ a 1)) (+ (+ a 1) (+ a 1))) 1) \u21d2 ; Evaluamos a (R2) (+ (* (+ (+ 2 1) (+ 2 1)) (+ (+ 2 1) (+ 2 1))) 1) \u21d2 ; Evaluamos (+ 2 1) (R3) (+ (* (+ 3 3) (+ 3 3)) 1) \u21d2 ; Evaluamos (+ 3 3) (R3) (+ (* 6 6) 1) \u21d2 ; Evaluamos (* 6 6) (R3) (+ 36 1) \u21d2 ; Evaluamos (+ 36 1) (R3) 37 En programaci\u00f3n funcional el resultado de evaluar una expresi\u00f3n es el mismo independientemente del tipo de orden. Pero si estamos fuera del paradigma funcional y las funciones tienen estado y cambian de valor entre distintas invocaciones s\u00ed que importan si escogemos un orden. Por ejemplo, supongamos una funci\u00f3n (random x) que devuelve un entero aleatorio entre 0 y x . Esta funci\u00f3n no cumplir\u00eda el paradigma funcional, porque devuelve un valor distinto con el mismo par\u00e1metro de entrada. Evaluamos las siguientes expresiones con orden aplicativo y normal, para comprobar que el resultado es distinto. 1 2 ( define ( zero x ) ( - x x )) ( zero ( random 10 )) Si evaluamos la \u00faltima expresi\u00f3n en orden aplicativo: 1 2 3 4 (zero (random 10)) \u21d2 ; Evaluamos (random 10) (R3) (zero 3) \u21d2 ; Sustituimos (zero ...) (R4) (- 3 3) \u21d2 ; Evaluamos - (R3) 0 Si lo evaluamos en orden normal: 1 2 3 4 (zero (random 10)) \u21d2 ; Sustituimos (zero ...) (R4) (- (random 10) (random 10)) \u21d2 ; Evaluamos (random 10) (R3) (- 5 3) \u21d2 ; Evaluamos - (R3) 2 Scheme como lenguaje de programaci\u00f3n funcional \u00b6 Ya hemos visto c\u00f3mo definir funciones y evaluar expresiones en Scheme. Vamos continuar con ejemplos concretos de otras caracter\u00edsticas funcionales caracter\u00edsticas funcionales de Scheme. En concreto, veremos: S\u00edmbolos y primitiva quote Uso de listas Definici\u00f3n de funciones recursivas en Scheme Funciones y formas especiales \u00b6 En el seminario de Scheme hemos visto un conjunto de primitivas que podemos utilizar en Scheme. Podemos clasificar las primitivas en funciones y formas especiales . Las funciones se eval\u00faan usando el modelo de sustituci\u00f3n aplicativo ya visto: Primero se eval\u00faan los argumentos y despu\u00e9s se sustituye la llamada a la funci\u00f3n por su cuerpo y se vuelve a evaluar la expresi\u00f3n resultante. Las expresiones siempre se eval\u00faan desde los par\u00e9ntesis interiores a los exteriores. Las formas especiales son expresiones primitivas de Scheme que tienen una forma de evaluarse propia, distinta de las funciones. Formas especiales en Scheme: define, if, cond \u00b6 Veamos la forma de evaluar las distintas formas especiales en Scheme. En estas formas especiales no se aplica el modelo de sustituci\u00f3n, al no ser invocaciones de funciones, sino que cada una se eval\u00faa de una forma diferente. Forma especial define Sintaxis 1 ( define <identificador> <expresi\u00f3n> ) Evaluaci\u00f3n Evaluar expresi\u00f3n Asociar el valor resultante con el identificador Ejemplo 1 2 3 ( define base 10 ) ; Asociamos a 'base' el valor 10 ( define altura 12 ) ; Asociamos a 'altura' el valor 12 ( define area ( / ( * base altura ) 2 )) ; Asociamos a 'area' el valor 60 Forma especial define para definir funciones Sintaxis 1 2 (define (<nombre-funcion> <argumentos>) <cuerpo>) Evaluaci\u00f3n La semana que viene veremos con m\u00e1s detalle la sem\u00e1ntica, y explicaremos la forma especial lambda que es la que realmente crea la funci\u00f3n. Hoy nos quedamos en la siguiente descripci\u00f3n de alto nivel de la sem\u00e1ntica: Crear la funci\u00f3n con el cuerpo Dar a la funci\u00f3n el nombre nombre-funci\u00f3n Ejemplo 1 2 3 4 ( define ( factorial x ) ( if ( = x 0 ) 1 ( * x ( factorial ( - x 1 ))))) Forma especial if Sintaxis 1 ( if <condici\u00f3n> <expresi\u00f3n-true> <expresi\u00f3n-false> ) Evaluaci\u00f3n Evaluar condici\u00f3n Si el resultado es #t evaluar la expresi\u00f3n-true , en otro caso, evaluar la expresi\u00f3n-false Ejemplo 1 2 3 4 ( if ( > 10 5 ) ( substring \"Hola qu\u00e9 tal\" ( + 1 1 ) 4 ) ( / 12 0 )) ;; Evaluamos (> 10 5). Como el resultado es #t, evaluamos ;; (substring \"Hola qu\u00e9 tal\" (+ 1 1) 4), que devuelve \"la\" Nota Al ser if una forma especial, no se eval\u00faa utilizando el modelo de sustituci\u00f3n, sino usando las reglas propias de la forma especial. Por ejemplo, veamos la siguiente expresi\u00f3n: 1 ( if ( > 3 0 ) ( + 2 3 ) ( / 1 0 )) ; \u21d2 5 Si se evaluara con el modelo de sustituci\u00f3n se lanzar\u00eda un error de divisi\u00f3n por cero al intentar evaluar (/ 1 0) . Sin embargo, esa expresi\u00f3n no llega a evaluarse, porque la condici\u00f3n (> 3 0) es cierta y s\u00f3lo se eval\u00faa la suma (+ 2 3) . Forma especial cond Sintaxis 1 2 3 4 5 ( cond ( <exp-cond-1> <exp-consec-1> ) ( <exp-cond-2> <exp-consec-2> ) ... ( else <exp-consec-else> )) Evaluaci\u00f3n Se eval\u00faan de forma ordenada todas las exp-cond-i hasta que una de ellas devuelva #t Si alguna exp-cond-i devuelve #t , se devuelve el valor de la exp-consec-i . Si ninguna exp-cond-i es cierta, se devuelve el valor resultante de evaluar exp-consec-else . Ejemplo 1 2 3 4 5 6 7 8 9 10 ( cond (( > 3 4 ) \"3 es mayor que 4\" ) (( < 2 1 ) \"2 es menor que 1\" ) (( = 3 1 ) \"3 es igual que 1\" ) (( > 3 5 ) \"3 es mayor que 2\" ) ( else \"ninguna condici\u00f3n es cierta\" )) ;; Se eval\u00faan una a una las expresiones (> 3 4), ;; (< 2 1), (= 3 1) y (> 3 5). Como ninguna de ella ;; es cierta se devuelve la cadena \"ninguna condici\u00f3n es cierta\". Forma especial quote y s\u00edmbolos \u00b6 Sintaxis 1 ( quote <identificador> ) Evaluaci\u00f3n Se devuelve el identificador sin evaluar (un s\u00edmbolo). Se abrevia en con el car\u00e1cter ' . Ejemplos 1 2 ( quote x ) ; el s\u00edmbolo x ' hola ; el s\u00edmbolo hola A diferencia de los lenguajes imperativos, Scheme trata a los identificadores (nombres que se les da a las variables) como datos del lenguaje de tipo symbol . En el paradigma funcional a los identificadores se les denomina s\u00edmbolos . Los s\u00edmbolos son distintos de las cadenas. Una cadena es un tipo de dato compuesto y se guardan en memoria todos y cada uno de los caracteres que la forman. Sin embargo, los s\u00edmbolos son tipos at\u00f3micos, que se representan en memoria con un \u00fanico valor determinado por el c\u00f3digo hash del identificador. Ejemplos de funciones Scheme con s\u00edmbolos: 1 2 3 4 5 6 7 8 9 10 11 12 13 ( define x 12 ) ( symbol? ' x ) ; \u21d2 #t ( symbol? x ) ; \u21d2 #f \u00bfPor qu\u00e9? ( symbol? ' hola-que<> ) ( symbol->string ' hola-que<> ) ' ma\u00f1ana ' l\u00e1piz ; aunque sea posible, no vamos a usar acentos en los s\u00edmbolos ; pero s\u00ed en los comentarios ( symbol? \"hola\" ) ; #f ( symbol? #f ) ; #f ( symbol? ( car ' ( hola c\u00f3mo est\u00e1s ))) ; #t ( equal? ' hola ' hola ) ( equal? ' hola \"hola\" ) Como hemos visto anteriormente, un s\u00edmbolo puede asociarse o ligarse ( bind ) a un valor (cualquier dato de primera clase ) con la forma especial define . 1 ( define pi 3.14159 ) Nota No es correcto escribir (define 'pi 3.14156) porque la forma especial define debe recibir un identificador sin quote . Cuando escribimos un s\u00edmbolo en el prompt de Scheme el int\u00e9rprete lo eval\u00faa y devuelve su valor: 1 2 > pi 3.14159 Los nombres de las funciones ( equal? , sin , + , ...) son tambi\u00e9n s\u00edmbolos y Scheme tambi\u00e9n los eval\u00faa (en un par de semanas hablaremos de las funciones como objetos primitivos en Scheme): 1 2 3 4 5 6 7 > sin #<procedure:sin> > + #<procedure:+> > (define (cuadrado x) (* x x)) > cuadrado #<procedure:cuadrado> Los s\u00edmbolos son tipos primitivos del lenguaje: pueden pasarse como par\u00e1metros o ligarse a variables. 1 2 3 > (define x 'hola) > x hola Forma expecial quote con expresiones \u00b6 Sintaxis 1 ( quote <expresi\u00f3n> ) Evaluaci\u00f3n Si quote recibe una expresi\u00f3n correcta de Scheme (una expresi\u00f3n entre par\u00e9ntesis) se devuelve la lista o pareja pareja definida por la expresi\u00f3n (sin evaluar sus elementos). Ejemplos 1 2 3 4 5 6 7 ' ( 1 2 3 ) ; \u21d2 (1 2 3) Una lista ' ( + 1 2 3 4 ) ; La lista formada por el s\u00edmbolo + y los n\u00fameros 1 2 3 4 ( quote ( 1 2 3 4 )) ; La lista formada por los n\u00fameros 1 2 3 4 ' ( a b c ) ; \u21d2 La lista con los s\u00edmbolos a, b, y c ' ( * ( + 1 ( + 2 3 )) 5 ) ; Una lista con 3 elementos, el segundo de ellos otra lista ' ( 1 . 2 ) ; \u21d2 La pareja (1 . 2) ' (( 1 . 2 ) ( 2 . 3 )) ; \u21d2 Una lista con las parejas (1 . 2) y (2 . 3) Listas \u00b6 Otra de las caracter\u00edsticas fundamentales del paradigma funcional es la utilizaci\u00f3n de listas. Ya hemos visto en el seminario de Scheme las funciones m\u00e1s importantes para trabajar con ellas. Vamos a repasarlas de nuevo en este apartado, antes de ver alg\u00fan ejemplo de c\u00f3mo usar la recursi\u00f3n con listas. Ya hemos visto en dicho seminario que Scheme es un lenguaje d\u00e9bilmente tipado. Una variable o par\u00e1metro no se declara de un tipo y puede contener cualquier valor. Sucede igual con las listas: una lista en Scheme puede contener cualquier valor, incluyendo otras listas. Diferencia entre la funci\u00f3n list y la forma especial quote En el seminario de Scheme explicamos que podemos crear listas de forma din\u00e1mica, llamando a la funci\u00f3n list y pas\u00e1ndole un n\u00famero variable de par\u00e1metros que son los elementos que se incluir\u00e1n en la lista: 1 2 3 4 ( list 1 2 3 4 5 ) ; \u21d2 (1 2 3 4) ( list ' a ' b ' c ) ; \u21d2 (a b c) ( list 1 ' a 2 ' b 3 ' c #t ) ; \u21d2 (1 a 2 b 3 c #t) ( list 1 ( + 1 1 ) ( * 2 ( + 1 2 ))) ; \u21d2 (1 2 6) Las expresiones interiores se eval\u00faan y se llama a la funci\u00f3n list con los valores resultantes. Otro ejemplo: 1 2 3 4 ( define a 1 ) ( define b 2 ) ( define c 3 ) ( list a b c ) ; \u21d2 (1 2 3) Como hemos visto cuando hemos hablado de quote , esta forma especial tambi\u00e9n puede construir una lista. Pero lo hace sin evaluar sus elementos. Por ejemplo: 1 2 3 4 5 6 ' ( 1 2 3 4 ) ; \u21d2 (1 2 3 4) ( define a 1 ) ( define b 2 ) ( define c 3 ) ' ( a b c ) ; \u21d2 (a b c) ' ( 1 ( + 1 1 ) ( * 2 ( + 1 2 ))) ; \u21d2 (1 (+ 1 1) (* 2 (+ 1 2))) La \u00faltima lista tiene 3 elementos: El n\u00famero 1 La lista (+ 1 1) La lista (* 2 (+ 1 2)) Es posible definir una lista vac\u00eda (sin elementos) realizando una llamada sin argumentos a la funci\u00f3n list o utilizando el s\u00edmbolo `(): 1 2 ( list ) ; \u21d2 () ` () ; \u21d2 () La diferencia entre creaci\u00f3n de listas con la funci\u00f3n list y con la forma especial quote se puede comprobar en los ejemplos. La evaluaci\u00f3n de la funci\u00f3n list funciona como cualquier funci\u00f3n, primero se eval\u00faan los argumentos y despu\u00e9s se invoca a la funci\u00f3n con los argumentos evaluados. Por ejemplo, en la siguiente invocaci\u00f3n se obtiene una lista con cuatro elementos resultantes de las invocaciones de las funciones dentro del par\u00e9ntesis: 1 ( list 1 ( / 2 3 ) ( + 2 3 )) ; \u21d2 (1 2/3 5) Sin embargo, usamos quote obtenemos una lista con sublistas con s\u00edmbolos en sus primeras posiciones: 1 ' ( 1 ( / 2 3 ) ( + 2 3 )) ; \u21d2 (1 (/ 2 3) (+ 2 3)) Selecci\u00f3n de elementos de una lista: car y cdr En el seminario vimos tambi\u00e9n c\u00f3mo obtener los elementos de una lista. Primer elemento: funci\u00f3n car Resto de elementos: funci\u00f3n cdr (los devuelve en forma de lista) Ejemplos: 1 2 3 4 5 6 ( define lista1 ' ( 1 2 3 4 )) ( car lista1 ) ; \u21d2 1 ( cdr lista1 ) ; \u21d2 (2 3 4) ( define lista2 ' (( 1 2 ) 3 4 )) ( car lista2 ) \u21d2 ( 1 2 ) ( cdr lista2 ) \u21d2 ( 3 4 ) Composici\u00f3n de listas: cons y append Por \u00faltimo, en el seminario vimos tambi\u00e9n c\u00f3mo crear nuevas listas a partir de ya existentes con las funciones cons y append . La funci\u00f3n cons crea una lista nueva resultante de a\u00f1adir un elemento al comienzo de la lista. Esta funci\u00f3n es la forma habitual de construir nuevas listas a partir de una lista ya existente y un nuevo elemento. 1 2 3 ( cons 1 ' ( 1 2 3 4 )) ; \u21d2 (1 1 2 3 4) ( cons ' hola ' ( como est\u00e1s )) ; \u21d2 (hola como est\u00e1s) ( cons ' ( 1 2 ) ' ( 1 2 3 4 )) ; \u21d2 ((1 2) 1 2 3 4) La funci\u00f3n append se usa para crear una lista nueva resultado de concatenar dos o m\u00e1s listas 1 2 3 ( define list1 ' ( 1 2 3 4 )) ( define list2 ' ( hola como est\u00e1s )) ( append list1 list2 ) ; \u21d2 (1 2 3 4 hola como est\u00e1s) Recursi\u00f3n \u00b6 Otra caracter\u00edstica fundamental de la programaci\u00f3n funcional es la no existencia de bucles. Un bucle implica la utilizaci\u00f3n de pasos de ejecuci\u00f3n en el programa y esto es caracter\u00edstico de la programaci\u00f3n imperativa. En programaci\u00f3n funcional las iteraciones se realizan con recursi\u00f3n. Funci\u00f3n (suma-hasta x) Por ejemplo, podemos definir la funci\u00f3n (suma-hasta x) que devuelve la suma de los n\u00fameros hasta el par\u00e1metro x cuyo valor pasamos en la invocaci\u00f3n de la funci\u00f3n. Por ejemplo, (suma-hasta 5) devolver\u00e1 0+1+2+3+4+5 = 15 . La definici\u00f3n de la funci\u00f3n es la siguiente: 1 2 3 4 ( define ( suma-hasta x ) ( if ( = 0 x ) 0 ( + ( suma-hasta ( - x 1 )) x ))) En una definici\u00f3n recursiva siempre tenemos un caso general y un caso base . El caso base define el valor que devuelve la funci\u00f3n en el caso elemental en el que no hay que hacer ning\u00fan c\u00e1lculo. El caso general define una expresi\u00f3n que contiene una llamada a la propia funci\u00f3n que estamos definiendo. El caso base es el caso en el que x vale 0. En este caso devolvemos el propio 0, no hay que realizar ning\u00fan c\u00e1lculo. El caso general es en el que se realiza la llamada recursiva. Esta llamada devuelve un valor que se utiliza para c\u00e1lculo final evaluando la expresi\u00f3n del caso general con valores concretos. En programaci\u00f3n funcional, al no existir efectos laterales, lo \u00fanico que importa cuando realizamos una recursi\u00f3n es el valor devuelto por la llamada recursiva. Ese valor devuelto se combina con el resto de la expresi\u00f3n del caso general para construir el valor resultante. Importante Para entender la recursi\u00f3n no es conveniente utilizar el depurador, ni hacer trazas, ni entrar en la recursi\u00f3n , sino que hay que suponer que la llamada recursiva se ejecuta y devuelve el valor que deber\u00eda. \u00a1Debemos confiar en la recursi\u00f3n! . El caso general del ejemplo anterior indica lo siguiente: 1 2 3 4 5 Para calcular la suma hasta x: Llamamos a la recursi\u00f3n para que calcule la suma hasta x-1 (confiamos en que la implementaci\u00f3n funciona bien y esta llamada nos devolver\u00e1 el resultado hasta x-1) y a ese resultado le sumamos el propio n\u00famero x. Siempre es aconsejable usar un ejemplo concreto para probar el caso general. Por ejemplo, el caso general de la suma hasta 5 se calcular\u00e1 de la siguiente forma: 1 2 3 4 5 ( + ( suma-hasta ( - 5 1 )) 5 ) ; \u21d2 ( + ( suma-hasta 4 ) 5 ) ; \u21d2 confiamos en la recursi\u00f3n: ; (suma-hasta 4) = 4+3+2+1 = 10 \u21d2 ( + 10 5 ) ; \u21d2 15 La evaluaci\u00f3n de esta funci\u00f3n calcular\u00e1 la llamada recursiva (suma-hasta 4) . Ah\u00ed es donde debemos confiar en que la recursi\u00f3n hace bien su trabajo y que esa llamada devuelve el valor resultante de 4+3+2+1, o sea, 10. Una vez obtenido ese valor hay que terminar el c\u00e1lculo sum\u00e1ndole el propio n\u00famero 5. Otra caracter\u00edstica necesaria del caso general en una definici\u00f3n recursiva, que tambi\u00e9n vemos en este ejemplo, es que la llamada recursiva debe trabajar sobre un caso m\u00e1s sencillo que la llamada general . De esta forma la recursi\u00f3n va descomponiendo el problema hasta llegar al caso base y construye la soluci\u00f3n a partir de ah\u00ed. En nuestro caso, la llamada recursiva para calcular la suma hasta 5 se hace calculando la suma hasta 4 (un caso m\u00e1s sencillo). Dise\u00f1o de la funci\u00f3n (suma-hasta x) \u00bfC\u00f3mo hemos dise\u00f1ado esta funci\u00f3n? \u00bfC\u00f3mo hemos llegado a la soluci\u00f3n? Debemos empezar teniendo claro qu\u00e9 es lo que queremos calcular. Lo mejor es utilizar un ejemplo. Por ejemplo, (suma-hasta 5) devolver\u00e1 0+1+2+3+4+5 = 15 . Una vez que tenemos esta expresi\u00f3n de un ejemplo concreto debemos dise\u00f1ar el caso general de la recursi\u00f3n. Para ello tenemos que encontrar una expresi\u00f3n para el c\u00e1lculo de (suma-hasta 5) que use una llamada recursiva a un problema m\u00e1s peque\u00f1o. O, lo que es lo mismo, \u00bfpodemos obtener el resultado 15 con lo que nos devuelve una llamada recursiva que obtenga la suma hasta un n\u00famero m\u00e1s peque\u00f1o y haciendo algo m\u00e1s? Pues s\u00ed: para calcular la suma hasta 5, esto es, para obtener 15, podemos llamar a la recursi\u00f3n para calcular la suma hasta 4 (devuelve 10) y a este resultado sumarle el propio 5. Lo podemos expresar con el siguiente dibujo: Generalizamos este ejemplo y lo expresamos en Scheme de la siguiente forma: 1 2 ( define ( suma-hasta x ) ( + ( suma-hasta ( - x 1 )) x )) Nos falta el caso base de la recursi\u00f3n. Debemos preguntarnos \u00bfcu\u00e1l es el caso m\u00e1s sencillo del problema, que podemos calcular sin hacer ninguna llamada recursiva? . En este caso podr\u00eda ser el caso en el que x es 0, en el que devolver\u00edamos 0. Podemos ya escribirlo todo en Scheme: 1 2 3 4 ( define ( suma-hasta x ) ( if ( = 0 x ) 0 ( + ( suma-hasta ( - x 1 )) x ))) Una aclaraci\u00f3n sobre el caso general. En la implementaci\u00f3n anterior la llamada recursiva a suma-hasta se realiza en el primer argumento de la suma: 1 ( + ( suma-hasta ( - x 1 )) x ) La expresi\u00f3n anterior es totalmente equivalente a la siguiente en la que la llamada recursiva aparece como segundo argumento 1 ( + x ( suma-hasta ( - x 1 ))) Ambas expresiones son equivalentes porque en programaci\u00f3n funcional no importa el orden en el que se eval\u00faan los argumentos. Da lo mismo evaluarlos de derecha a izquierda que de izquierda a derecha. La transparencia referencial garantiza que el resultado es el mismo. Funci\u00f3n (alfabeto-hasta char) Vamos con otro ejemplo. Queremos dise\u00f1ar una funci\u00f3n (alfabeto-hasta char) que devuelva una cadena que empieza en la letra a y termina en el car\u00e1cter que le pasamos como par\u00e1metro. Por ejemplo: 1 2 ( alfabeto-hasta #\\h ) ; \u21d2 \"abcdefgh\" ( alfabeto-hasta #\\z ) ; \u21d2 \"abcdefghijklmnopqrstuvwxyz\" Pensamos en el caso general: \u00bfc\u00f3mo podr\u00edamos invocar a la propia funci\u00f3n alfabeto-hasta para que (confiando en la recursi\u00f3n) nos haga gran parte del trabajo (construya casi toda la cadena con el alfabeto)? Podr\u00edamos hacer que la llamada recursiva devolviera el alfabeto hasta el car\u00e1cter previo al que nos pasan como par\u00e1metro y despu\u00e9s nosotros a\u00f1adir ese car\u00e1cter a la cadena que devuelve la recursi\u00f3n. Veamos un ejemplo concreto: 1 (alfabeto-hasta #\\h) = (alfabeto-hasta #\\g) + \\#h La llamada recursiva (alfabeto-hasta #\\g) devolver\u00eda la cadena \"abcdefg\" (confiando en la recursi\u00f3n) y s\u00f3lo faltar\u00eda a\u00f1adir la \u00faltima letra. Para implementar esta idea en Scheme lo \u00fanico que necesitamos es usar la funci\u00f3n string-append para concatenar cadenas y una funci\u00f3n auxiliar (anterior char) que devuelve el car\u00e1cter anterior a uno dado. 1 2 ( define ( anterior char ) ( integer->char ( - ( char->integer char ) 1 ))) El caso general quedar\u00eda como sigue: 1 2 ( define ( alfabeto-hasta char ) ( string-append ( alfabeto-hasta ( anterior char )) ( string char ))) Faltar\u00eda el caso base. \u00bfCu\u00e1l es el caso m\u00e1s sencillo posible que nos pueden pedir? El caso del alfabeto hasta la #\\a . En ese caso basta con devolver la cadena \"a\" . La funci\u00f3n completa quedar\u00eda as\u00ed: 1 2 3 4 ( define ( alfabeto-hasta char ) ( if ( equal? char #\\a ) \"a\" ( string-append ( alfabeto-hasta ( anterior char )) ( string char )))) Recursi\u00f3n y listas \u00b6 La utilizaci\u00f3n de la recursi\u00f3n es muy \u00fatil para trabajar con estructuras secuenciales, como listas. Vamos a empezar viendo unos sencillos ejemplos y m\u00e1s adelante veremos algunos m\u00e1s complicadas. Funci\u00f3n recursiva suma-lista Veamos un primer ejemplo, la funci\u00f3n (suma-lista lista-nums) que recibe como par\u00e1metro una lista de n\u00fameros y devuelve la suma de todos ellos. Siempre debemos empezar escribiendo un ejemplo de la funci\u00f3n, para entenderla bien: 1 ( suma-lista ' ( 12 3 5 1 8 )) ; \u21d2 29 Para dise\u00f1ar una implementaci\u00f3n recursiva de la funci\u00f3n tenemos que pensar en c\u00f3mo descomponer el ejemplo en una llamada recursiva a un problema m\u00e1s peque\u00f1o y en c\u00f3mo tratar el valor devuelto por la recursi\u00f3n para obtener el valor esperado. Por ejemplo, en este caso podemos pensar que para sumar la lista de n\u00fameros (12 3 5 1 8) podemos obtener un problema m\u00e1s sencillo (una lista m\u00e1s peque\u00f1a) haciendo el cdr de la lista de n\u00fameros y llamando a la recursi\u00f3n con el resultado. La llamada recursiva devolver\u00e1 la suma de esos n\u00fameros (confiamos en la recursi\u00f3n) y a ese valor basta con sumarle el primer n\u00famero de la lista. Lo podemos representar en el siguiente dibujo: Podemos generalizar este ejemplo y expresarlo en Scheme de la siguiente forma: 1 2 ( define ( suma-lista lista ) ( + ( car lista ) ( suma-lista ( cdr lista )))) Falta el caso base. \u00bfCu\u00e1l es la lista m\u00e1s sencilla con la que podemos calcular la suma de sus elementos sin llamar a la recursi\u00f3n?. Podr\u00eda ser una lista sin elementos, y devolvemos 0. O una lista con un \u00fanico elemento, y devolvemos el propio elemento. Escogemos como caso base el primero de ellos. Con todo junto, la recursi\u00f3n quedar\u00eda como sigue: 1 2 3 4 ( define ( suma-lista lista ) ( if ( null? lista ) 0 ( + ( car lista ) ( suma-lista ( cdr lista ))))) Funci\u00f3n recursiva longitud Veamos c\u00f3mo definir la funci\u00f3n recursiva que devuelve la longitud de una lista, el n\u00famero de elementos que contiene. Comencemos como siempre con un ejemplo: 1 ( longitud ' ( a b c d e )) ; \u21d2 5 Suponiendo que la funci\u00f3n longitud funciona correctamente, \u00bfc\u00f3mo podr\u00edamos formular el caso general de la recursi\u00f3n? \u00bfc\u00f3mo podr\u00edamos llamar a la recursi\u00f3n con un problema m\u00e1s peque\u00f1o y c\u00f3mo podemos aprovechar el resultado de esta llamada para obtener el resultado final? En este caso es bastante sencillo. Si a la lista le quitamos un elemento, cuando llamemos a la recursi\u00f3n nos va a devolver la longitud original menos uno. En este caso: 1 2 ( longitud ( cdr ' ( a b c d e ))) ; \u21d2 ( longitud ' ( b c d e )) \u21d2 ( confiamos en la recursi\u00f3n ) 4 De esta forma, para conseguir la longitud de la lista inicial, s\u00f3lo habr\u00eda que sumarle 1 a lo que nos devuelve la llamada recursiva. Si expresamos en Scheme este caso general: 1 2 3 ; S\u00f3lo se define el caso general, falta el caso base ( define ( longitud lista ) ( + ( longitud ( cdr lista )) 1 )) Para definir el caso base debemos preguntarnos cu\u00e1l es el caso m\u00e1s simple que le podemos pasar a la funci\u00f3n. Si en cada llamada recursiva vamos reduciendo la longitud de la lista, el caso base recibir\u00e1 la lista vac\u00eda. \u00bfCu\u00e1l es la longitud de una lista vac\u00eda? Una lista vac\u00eda no tiene elementos, por lo que es 0. De esta forma completamos la definici\u00f3n de la funci\u00f3n: 1 2 3 4 ( define ( longitud lista ) ( if ( null? lista ) 0 ( + ( longitud ( cdr lista )) 1 ))) En Scheme existe la funci\u00f3n length que hace lo mismo. Devuelve la longitud de una lista: 1 ( length ' ( a b c d e )) ; \u21d2 5 C\u00f3mo comprobar si una lista tiene un \u00fanico elemento En el caso base de algunas funciones recursivas es necesario comprobar que la lista que se pasa como par\u00e1metro tiene un \u00fanico elemento. Por ejemplo, en el caso base de la funci\u00f3n recursiva que comprueba si una lista est\u00e1 ordenada. Al estar definida la funci\u00f3n length en Scheme la primera idea que se nos puede ocurrir es comprobar si la longitud de la lista es 1. Sin embargo es una mala idea. 1 2 3 4 5 6 7 8 9 ; Ejemplo de funci\u00f3n recursiva con un caso ; base en el que se comprueba si la lista tienen ; un \u00fanico elemento ; \u00a1\u00a1MALA IDEA, NO HACERLO AS\u00cd!! ( define ( foo lista ) ( if ( = ( length lista ) 1 ) ; devuelve caso base ; caso general )) El problema de la implementaci\u00f3n anterior es que el coste de la funci\u00f3n length es lineal. Tal y como hemos visto en el apartado anterior, para calcular la longitud de la lista es necesario recorrer todos sus elementos. Adem\u00e1s, la funci\u00f3n recursiva hace esa comprobaci\u00f3n en cada llamada recursiva. El coste resultante de la funci\u00f3n foo , por tanto, es cuadr\u00e1tico. \u00bfC\u00f3mo mejorar el coste? Hay que tener en cuenta que la comprobaci\u00f3n anterior est\u00e1 haciendo cosas de m\u00e1s. Realmente no queremos saber la longitud de la lista sino \u00fanicamente si esa longitud es mayor que uno. Esta comprobaci\u00f3n s\u00ed que puede hacerse en tiempo constante. Lo \u00fanico que debemos hacer es comprobar si el cdr de la lista es la lista vac\u00eda. Si lo es, ya sabemos que la lista original ten\u00eda un \u00fanico elemento. Por tanto, la versi\u00f3n correcto del c\u00f3digo anterior ser\u00eda la siguiente: 1 2 3 4 5 6 7 ; Versi\u00f3n correcta para comprobar si una lista tiene ; un \u00fanico elemento ( define ( foo lista ) ( if ( null? ( cdr lista )) ; devuelve caso base ; caso general )) El coste de la comprobaci\u00f3n (null? (cdr lista)) es constante. No depende de la longitud de la lista. Funci\u00f3n recursiva veces Como \u00faltimo ejemplo vamos a definir la funci\u00f3n 1 ( veces lista id ) que cuenta el n\u00famero de veces que aparece un identificador en una lista. Por ejemplo, 1 ( veces ' ( a b c a d a ) ' a ) ; \u21d2 3 \u00bfC\u00f3mo planteamos el caso general? Llamaremos a la recursi\u00f3n con el resto de la lista. Esta llamada nos devolver\u00e1 el n\u00famero de veces que aparece el identificador en este resto de la lista. Y sumaremos al valor devuelto 1 si el primer elemento de la lista coincide con el identificador. En Scheme hay que definir este caso general en una \u00fanica expresi\u00f3n: 1 2 3 ( if ( equal? ( car lista ) id ) ( + 1 ( veces ( cdr lista ) id )) ( veces ( cdr lista ) id )) Como caso base, si la lista es vac\u00eda devolvemos 0. La versi\u00f3n completa: 1 2 3 4 5 6 7 ( define ( veces lista id ) ( cond (( null? lista ) 0 ) (( equal? ( car lista ) id ) ( + 1 ( veces ( cdr lista ) id ))) ( else ( veces ( cdr lista ) id )))) ( veces ' ( a b a a b b ) ' a ) ; \u21d2 3 Tipos de datos compuestos en Scheme \u00b6 El tipo de dato pareja \u00b6 Funci\u00f3n de construcci\u00f3n de parejas cons Ya hemos visto en el seminario de Scheme que el tipo de dato compuesto m\u00e1s simple es la pareja: una entidad formada por dos elementos. Se utiliza la funci\u00f3n cons para construirla: 1 2 ( cons 1 2 ) ; \u21d2 (1 . 2) ( define c ( cons 1 2 )) Dibujamos la pareja anterior y la variable c que la referencia de la siguiente forma: Tipo compuesto pareja La instrucci\u00f3n cons construye un dato compuesto a partir de otros dos datos (que llamaremos izquierdo y derecho). La expresi\u00f3n (1 . 2) es la forma que el int\u00e9rprete tiene de imprimir las parejas. Construcci\u00f3n de parejas con quote Al igual que las listas, es posible construir parejas con la forma especial quote , definiendo la pareja entre par\u00e9ntesis y separando su parte izquierda y derecha con un punto: 1 ' ( 1 . 2 ) ; \u21d2 (1 . 2) Utilizaremos a veces cons y otras veces quote para definir parejas. Pero hay que tener en cuenta que, al igual que con las listas, quote no eval\u00faa sus par\u00e1metros, por lo que no lo deberemos utilizar por ejemplo dentro de una funci\u00f3n en la que queremos construir una pareja con los resultados de evaluar expresiones. Por ejemplo: 1 2 3 4 ( define a 1 ) ( define b 2 ) ( cons a b ) ; \u21d2 (1 . 2) ' ( a . b ) ; \u21d2 (a . b) Funciones de acceso car y cdr Una vez construida una pareja, podemos obtener el elemento correspondiente a su parte izquierda con la funci\u00f3n car y su parte derecha con la funci\u00f3n cdr : 1 2 3 ( define c ( cons 1 2 )) ( car c ) ; \u21d2 1 ( cdr c ) ; \u21d2 2 Definici\u00f3n declarativa Las funciones cons , car y cdr quedan perfectamente definidas con las siguientes ecuaciones algebraicas: 1 2 ( car ( cons x y )) = x ( cdr ( cons x y )) = y \u00bfDe d\u00f3nde vienen los nombres car y cdr ? Inicialmente los nombres eran CAR y CDR (en may\u00fasculas). La historia se remonta al a\u00f1o 1959, en los or\u00edgenes del Lisp y tiene que ver con el nombre que se les daba a ciertos registros de la memoria del IBM 709. Podemos leer la explicaci\u00f3n completa en The origin of CAR and CDR in LISP . Funci\u00f3n pair? La funci\u00f3n pair? nos dice si un objeto es at\u00f3mico o es una pareja: 1 2 ( pair? 3 ) ; \u21d2 #f ( pair? ( cons 3 4 )) ; \u21d2 #t Las parejas pueden contener cualquier tipo de dato Ya hemos comprobado que Scheme es un lenguaje d\u00e9bilmente tipado . Las funciones pueden devolver y recibir distintos tipos de datos. Por ejemplo, podr\u00edamos definir la siguiente funci\u00f3n suma que sume tanto n\u00fameros como cadenas: 1 2 3 4 5 ( define ( suma x y ) ( cond (( and ( number? x ) ( number? y )) ( + x y )) (( and ( string? x ) ( string? y )) ( string-append x y )) ( else ' error ))) En la funci\u00f3n anterior los par\u00e1metros x e y pueden ser n\u00fameros o cadenas (o incluso de cualquier otro tipo). Y el valor devuelto por la funci\u00f3n ser\u00e1 un n\u00famero, una cadena o el s\u00edmbolo 'error . Sucede lo mismo con el contenido de las parejas. Es posible guardar en las parejas cualquier tipo de dato y combinar distintos tipos. Por ejemplo: 1 2 3 ( define c ( cons ' hola #f )) ( car c ) ; \u21d2 'hola ( cdr c ) ; \u21d2 #f Las parejas son objetos inmutables Recordemos que en los paradigmas de programaci\u00f3n declarativa y funcional no existe el estado mutable . Una vez declarado un valor, no se puede modificar. Esto debe suceder tambi\u00e9n con las parejas: una vez creada una pareja no se puede modificar su contenido. En Lisp y Scheme est\u00e1ndar las parejas s\u00ed que pueden ser mutadas. Pero durante toda esta primera parte de la asignatura no lo contemplaremos, para no salirnos del paradigma funcional. En Swift y otros lenguajes de programaci\u00f3n es posible definir estructuras de datos inmutables que no pueden ser modificadas una vez creadas. Lo veremos tambi\u00e9n m\u00e1s adelante. Las parejas son objetos de primera clase \u00b6 En un lenguaje de programaci\u00f3n un elemento es de primera clase cuando puede: Asignarse a variables Pasarse como argumento Devolverse por una funci\u00f3n Guardarse en una estructura de datos mayor Las parejas son objetos de primera clase. Una pareja puede asignarse a una variable: 1 2 ( define p1 ( cons 1 2 )) ( define p2 ( cons #f \"hola\" )) Una pareja puede pasarse como argumento y devolverse en una funci\u00f3n: 1 2 3 4 5 ( define ( suma-parejas p1 p2 ) ( cons ( + ( car p1 ) ( car p2 )) ( + ( cdr p1 ) ( cdr p2 )))) ( suma-parejas ' ( 1 . 5 ) ' ( 4 . 12 )) ; \u21d2 (5 . 17) Una vez definida esta funci\u00f3n suma-parejas podr\u00edamos ampliar la funci\u00f3n suma que vimos previamente con este nuevo tipo de datos: 1 2 3 4 5 6 ( define ( suma x y ) ( cond (( and ( number? x ) ( number? y )) ( + x y )) (( and ( string? x ) ( string? y )) ( string-append x y )) (( and ( pair? x ) ( pair? y )) ( suma-parejas p1 p2 )) ( else ' error ))) Y, por \u00faltimo, las parejas pueden formar parte de otras parejas . Es lo que se denomina la propiedad de clausura de la funci\u00f3n cons : el resultado de un cons puede usarse como par\u00e1metro de nuevas llamadas a cons . Ejemplo: 1 2 3 ( define p1 ( cons 1 2 )) ( define p2 ( cons 3 4 )) ( define p ( cons p1 p2 )) Expresi\u00f3n equivalente: 1 2 ( define p ( cons ( cons 1 2 ) ( cons 3 4 ))) Podr\u00edamos representar esta estructura as\u00ed: Propiedad de clausura: las parejas pueden contener parejas Pero se har\u00eda muy complicado representar muchos niveles de anidamiento. Por eso utilizamos la siguiente representaci\u00f3n: Llamamos a estos diagramas diagramas caja-y-puntero ( box-and-pointer en ingl\u00e9s). Diagramas caja-y-puntero \u00b6 Al escribir expresiones complicadas con cons anidados es conveniente para mejorar su legibilidad utilizar el siguiente formato: 1 2 3 ( define p ( cons ( cons 1 ( cons 3 4 )) 2 )) Para entender la construcci\u00f3n de estas estructuras es importante recordar que las expresiones se eval\u00faan de dentro a afuera . \u00bfQu\u00e9 figura representar\u00eda la estructura anterior? Soluci\u00f3n: Es importante tener en cuenta que cada caja del diagrama representa una pareja creada en la memoria del int\u00e9rprete con la instrucci\u00f3n cons y que el resultado de evaluar una variable en la que se ha guardado una pareja devuelve la pareja reci\u00e9n creada. Por ejemplo, si el int\u00e9rprete eval\u00faa p despu\u00e9s de haber hecho la sentencia anterior devuelve la pareja contenida en p , no se crea una pareja nueva. Por ejemplo, si despu\u00e9s de haber evaluado la sentencia anterior evaluamos la siguiente: 1 ( define p2 ( cons 5 ( cons p 6 ))) El diagrama caja y puntero resultante ser\u00eda el siguiente: Vemos que en la pareja que se crea con (cons p 6) se guarda en la parte izquierda la misma pareja que hay en p . Lo representamos con una flecha que apunta a la misma pareja que p . Nota El funcionamiento de la evaluaci\u00f3n de variables que contienen parejas es similar al de las variables que contienen objetos en lenguajes orientados a objetos como Java. Cuando se eval\u00faa una variable que contiene una pareja se devuelve la propia pareja, no una copia. En programaci\u00f3n funcional, como el contenido de las parejas es inmutable, no hay problemas de efectos laterales por el hecho de que una pareja est\u00e9 compartida. Es conveniente que pruebes a crear distintas estructuras de parejas con parejas y a dibujar su diagrama caja y puntero. Y tambi\u00e9n a recuperar un determinado dato (pareja o dato at\u00f3mico) una vez creada la estructura. La siguiente funci\u00f3n print-pareja puede ser \u00fatil a la hora de mostrar por pantalla los elementos de una pareja 1 2 3 4 5 6 7 8 9 10 11 12 13 14 ( define ( print-pareja pareja ) ( if ( pair? pareja ) ( begin ( display \"(\" ) ( print-dato ( car pareja )) ( display \" . \" ) ( print-dato ( cdr pareja )) ( display \")\" )) ( display \"\" ))) ( define ( print-dato dato ) ( if ( pair? dato ) ( print-pareja dato ) ( display dato ))) \u00a1Cuidado! La funci\u00f3n anterior contiene pasos de ejecuci\u00f3n con sentencias como begin y llamadas a display dentro del c\u00f3digo de la funci\u00f3n. Estas sentencias son propias de la programaci\u00f3n imperativa. No hacerlo en programaci\u00f3n funcional . Funciones c????r Al trabajar con estructuras de parejas anidades es muy habitual realizar llamadas del tipo: 1 ( cdr ( cdr ( car p ))) ; \u21d2 4 Es equivalente a la funci\u00f3n cadar de Scheme: 1 ( cddar p ) ; \u21d2 4 El nombre de la funci\u00f3n se obtiene concatenando a la letra \"c\", las letras \"a\" o \"d\" seg\u00fan hagamos un car o un cdr y terminando con la letra \"r\". Hay definidas 2^4 funciones de este tipo: caaaar , caaadr , \u2026, cddddr . Listas en Scheme \u00b6 Implementaci\u00f3n de listas en Scheme \u00b6 Recordemos que Scheme permite manejar listas como un tipo de datos b\u00e1sico. Hemos visto funciones para crear, a\u00f1adir y recorrer listas. Como repaso, podemos ver las siguientes expresiones. Fijaros que las funciones car , cdr y cons son exactamente las mismas funciones que las vistas anteriormente. \u00bfPor qu\u00e9? \u00bfQu\u00e9 relaci\u00f3n hay entre las parejas y las listas? Hagamos algunas pruebas, probando si los resultados son listas o parejas usando las funciones list? y pair? . Por ejemplo, una pareja formada por dos n\u00fameros es una pareja, pero no es una lista: 1 2 3 ( define p1 ( cons 1 2 )) ( pair? p1 ) ; \u21d2 #t ( list? p1 ) ; \u21d2 #f Y una lista vac\u00eda es una lista, pero no es una pareja: 1 2 ( list? ' ()) ; \u21d2 #t ( pair? ' ()) ; \u21d2 #f \u00bfUna lista es una pareja? Pues s\u00ed: 1 2 3 ( define lista ' ( 1 2 3 )) ( list? lista ) ; \u21d2 #t ( pair? lista ) ; \u21d2 #t Por \u00faltimo, una pareja con una lista vac\u00eda como segundo elemento es una pareja y una lista: 1 2 3 ( define p1 ( cons 1 ' ())) ( pair? p1 ) ; \u21d2 #t ( list? p1 ) ; \u21d2 #t Con estos ejemplos ya tenemos pistas para deducir la relaci\u00f3n entre listas y parejas en Scheme (y Lisp). Vamos a explicarlo. Definici\u00f3n de listas con parejas Una lista es (definici\u00f3n recursiva): Una pareja que contiene en su parte izquierda el primer elemento de la lista y en su parte derecha el resto de la lista Un s\u00edmbolo especial '() que denota la lista vac\u00eda Por ejemplo, una lista muy sencilla con un solo elemento, (1) , se define con la siguiente pareja: 1 ( cons 1 ' ()) La pareja cumple las condiciones anteriores: La parte izquierda de la pareja es el primer elemento de la lista (el n\u00famero 1) La parte derecha es el resto de la lista (la lista vac\u00eda) La lista (1) El objeto es al mismo tiempo una pareja y una lista. La funci\u00f3n list? permite comprobar si un objeto es una lista: 1 2 3 ( define l ( cons 1 ' ())) ( pair? l ) ( list? l ) Por ejemplo, la lista '(1 2 3 4) se construye con la siguiente secuencia de parejas: 1 2 3 4 5 ( cons 1 ( cons 2 ( cons 3 ( cons 4 ' ())))) La primera pareja cumple las condiciones de ser una lista: Su primer elemento es el 1 Su parte derecha es la lista '(2 3 4) Parejas formando una lista Al comprobar la implementaci\u00f3n de las listas en Scheme, entendemos por qu\u00e9 las funciones car y cdr nos devuelven el primer elemento y el resto de la lista. Lista vac\u00eda La lista vac\u00eda es una lista: 1 ( list? ' ()) ; \u21d2 #t Y no es un s\u00edmbolo ni una pareja: 1 2 ( symbol? ' ()) ; \u21d2 #f ( pair? ' ()) ; \u21d2 #f Para saber si un objeto es la lista vac\u00eda, podemos utilizar la funci\u00f3n null? : 1 ( null? ' ()) ; \u21d2 #t Listas con elementos compuestos \u00b6 Las listas pueden contener cualquier tipo de elementos, incluyendo otras parejas. La siguiente estructura se denomina lista de asociaci\u00f3n . Son listas cuyos elementos son parejas ( clave , valor ): 1 2 3 ( list ( cons ' a 1 ) ( cons ' b 2 ) ( cons ' c 3 )) ; \u21d2 ((a . 1) (b . 2) (c . 2)) \u00bfCu\u00e1l ser\u00eda el diagrama box and pointer de la estructura anterior? La expresi\u00f3n equivalente utilizando conses es: 1 2 3 4 ( cons ( cons ' a 1 ) ( cons ( cons ' b 2 ) ( cons ( cons ' c 3 ) ' ()))) Listas de listas Hemos visto que podemos construir listas que contienen otras listas: 1 ( define lista ( list 1 ( list 1 2 3 ) 3 )) La lista anterior tambi\u00e9n se puede definir con quote: 1 ( define lista ' ( 1 ( 1 2 3 ) 3 )) La lista resultante contiene tres elementos: el primero y el \u00faltimo son elementos at\u00f3micos (n\u00fameros) y el segundo es otra lista. Si preguntamos por la longitud de la lista Scheme nos dir\u00e1 que es una lista de 3 elementos: 1 ( length lista ) ; \u21d2 3 Y el segundo elemento de la lista es otra lista: 1 ( car ( cdr lista )) ; \u21d2 (1 2 3) \u00bfC\u00f3mo implementa Scheme esta lista usando parejas? Al ser una lista de tres elementos lo har\u00e1 con tres parejas enlazadas que terminan en una lista vac\u00eda en la parte derecha de la \u00faltima pareja. En las partes izquierdas de esas tres parejas tendremos los elementos de la lista propiamente dichos: un 1 y un 3 en la primera y \u00faltima pareja y una lista en la segunda pareja. El diagrama box and pointer : Lista que contiene otra lista como segundo elemento Impresi\u00f3n de listas y parejas por el int\u00e9rprete de Scheme El int\u00e9rprete de Scheme siempre intenta mostrar una lista cuando encuentra una pareja cuyo siguiente elemento es otra pareja. Por ejemplo, si tenemos la siguiente estructura: 1 ( define p ( cons 1 ( cons 2 3 ))) Cuando se eval\u00fae p el int\u00e9rprete imprimir\u00e1 por pantalla lo siguiente: 1 ( 1 2 . 3 ) \u00bfPor qu\u00e9? Porque el int\u00e9rprete va construyendo la salida conforme recorre la pareja p . Como encuentra una pareja cuya parte derecha es otra pareja, lo interpreta como el comienzo de una lista, y por eso escribe (1 2 en lugar de (1 . 2 . Pero inmediatamente despu\u00e9s se encuentra con el 3 en lugar de una lista vac\u00eda. En ese momento el int\u00e9rprete \"se da cuenta\" de que no tenemos una lista y termina la expresi\u00f3n escribiendo el . 3 y el par\u00e9ntesis final. Si queremos comprobar la estructura de parejas podemos utilizar la funci\u00f3n print-pareja definida anteriormente, que imprimir\u00eda lo siguiente: 1 ( print-pareja p ) ; \u21d2 (1 . (2 . 3)) Funciones de alto nivel sobre listas Es importante conocer c\u00f3mo se implementan las listas usando parejas y su representaci\u00f3n con diagramas caja y puntero para definir funciones de alto nivel. Algunas de estas funciones ya las conocemos, otras las vemos por primera vez en los siguientes ejemplos: 1 2 3 4 5 ( append ' ( a ( b ) c ) ' (( d ) e f )) ; \u21d2 (a (b) c (d) e f) ( list-ref ' ( a ( b ) c d ) 2 ) ; \u21d2 c ( length ' ( a ( b ( c ))) ; \u21d2 2 ( reverse ' ( a b c )) ; \u200c\u21d2 (c b a) ( list-tail ' ( a b c d ) 2 ) ; \u200c\u21d2 (c d) En los siguientes apartados veremos c\u00f3mo est\u00e1n implementadas. Funciones recursivas que construyen listas \u00b6 Para terminar el apartado sobre las listas en Scheme vamos a ver ejemplos adicionales de funciones recursivas que trabajan con listas. Veremos alguna funci\u00f3n que recibe una lista y, como antes, usa la recursi\u00f3n para recorrerla. Pero veremos tambi\u00e9n funciones que usan la recursi\u00f3n para construir nuevas listas . Algunas de las funciones que presentamos son implementaciones de las ya existentes en Scheme. Para no solapar con las definiciones de Scheme pondremos el prefijo mi- en todas ellas. Vamos a ver las siguientes funciones: mi-list-ref : implementaci\u00f3n de la funci\u00f3n list-ref mi-list-tail : implementaci\u00f3n de la funci\u00f3n list-tail mi-append : implementaci\u00f3n de la funi\u00f3n append mi-reverse : implementaci\u00f3n de la funci\u00f3n reverse cuadrados-hasta : devuelve la lista de cuadrados hasta uno dado filtra-pares : devuelve la lista de los n\u00fameros pares de la lista que se recibe primo? : comprueba si un n\u00famero es o no primo Funci\u00f3n mi-list-ref La funci\u00f3n (mi-list-ref n lista) devuelve el elemento n de una lista (empezando a contar por 0): 1 2 ( define lista ' ( a b c d e f g )) ( mi-list-ref lista 2 ) ; \u21d2 c Veamos con el ejemplo anterior c\u00f3mo hacer la formulaci\u00f3n recursiva. Hemos visto que, en general, cuando queremos resolver un problema de forma recursiva tenemos que hacer una llamada recursiva a un problema m\u00e1s sencillo, confiar en que la llamada nos devuelva el resultado correcto y usar ese resultado para resolver el problema original. En este caso nuestro problema es obtener el n\u00famero que est\u00e1 en la posici\u00f3n 2 de la lista (a b c d e f g) . Suponemos que la funci\u00f3n que nos devuelve una posici\u00f3n de la lista ya la tenemos implementada y que la llamada recursiva nos va a devolver el resultado correcto. \u00bfC\u00f3mo podemos simplificar el problema original? Veamos la soluci\u00f3n para este caso concreto: 1 2 3 4 Para devolver el elemento 2 de la lista (a b c d e f g): Hacemos el cdr de la lista (obtenemos (b c d e f g)) y devolvemos su elemento 1. Ser\u00e1 el valor c (empezamos a contar por 0). Generalizamos el ejemplo anterior, para cualquier n y cualquier lista: 1 2 Para devolver el elemento que est\u00e1 en la posici\u00f3n `n` de una lista, devuelvo el elemento n-1 de su cdr. Y, por \u00faltimo, formulamos el caso base de la recursi\u00f3n, el problema m\u00e1s sencillo que se puede resolver directamente, sin hacer una llamada recursiva: 1 2 Para devolver el elemento que est\u00e1 en la posici\u00f3n 0 de una lista, devuelvo el `car` de la lista. La implementaci\u00f3n de todo esto en Scheme ser\u00eda la siguiente: 1 2 3 4 ( define ( mi-list-ref lista n ) ( if ( = n 0 ) ( car lista ) ( mi-list-ref ( cdr lista ) ( - n 1 )))) Funci\u00f3n mi-list-tail La funci\u00f3n (mi-list-tail lista n) devuelve la lista resultante de quitar n elementos de la cabeza de la lista original: 1 ( mi-list-tail ' ( 1 2 3 4 5 6 7 ) 2 ) ; \u21d2 (3 4 5 6 7) Piensa en c\u00f3mo se implementar\u00eda de forma recursiva. Esta vez vamos a mostrar directamente la implementaci\u00f3n, sin dar explicaciones de c\u00f3mo se ha llegado a ella: 1 2 3 4 ( define ( mi-list-tail lista n ) ( if ( = n 0 ) lista ( mi-list-tail ( cdr lista ) ( - n 1 )))) Funci\u00f3n mi-append Veamos ahora c\u00f3mo podr\u00edamos implementar de forma recursiva la funci\u00f3n append que une dos listas. La llamaremos (mi-append lista1 lista2) . Por ejemplo: 1 ( mi-append ' ( a b c ) ' ( d e f )) ; \u21d2 (a b c d e f) Para resolver el problema de forma recursiva, debemos confiar en la recursi\u00f3n para que resuelva un problema m\u00e1s sencillo y despu\u00e9s terminar de arreglar el resultado devuelto por la recursi\u00f3n. En este caso, podemos pasarle a la recursi\u00f3n un problema m\u00e1s sencillo quitando el primer elemento de la primera lista (con la funci\u00f3n cdr ) y llamando a la recursi\u00f3n para que concatene esta lista m\u00e1s peque\u00f1a con la segunda. Confiamos en que la recursi\u00f3n funciona correctamente y nos devuelve la concatenaci\u00f3n de ambas listas 1 (mi-append (cdr '(a b c)) '(d e f)) => (b c d e f) Y a\u00f1adiremos el primer elemento a la lista resultante usando un cons : 1 2 3 4 (mi-append '(a b c) '(d e f)) = (cons 'a (mi-append '(b c)) '(d e f)) = (cons 'a '(b c d e f)) = (a b c d e f) En general: 1 2 ( define ( mi-append lista1 lista2 ) ( cons ( car lista1 ) ( mi-append ( cdr lista1 ) lista2 ))) El caso base, el caso en el que la funci\u00f3n puede devolver un valor directamente sin llamar a la recursi\u00f3n, es aquel en el que lista1 es null? . En ese caso devolvemos lista2 : 1 (mi-append '() '(a b c)) => '(a b c) La formulaci\u00f3n recursiva completa queda como sigue: 1 2 3 4 5 ( define ( mi-append l1 l2 ) ( if ( null? l1 ) l2 ( cons ( car l1 ) ( mi-append ( cdr l1 ) l2 )))) Funci\u00f3n mi-reverse Veamos c\u00f3mo implementar de forma recursiva la funci\u00f3n mi-reverse que invierte una lista 1 ( mi-reverse ' ( 1 2 3 4 5 6 )) ; \u21d2 (6 5 4 3 2 1) La idea es sencilla: llamamos a la recursi\u00f3n para hacer la inversa del cdr de la lista y a\u00f1adimos el primer elemento a la lista resultante que devuelve ya invertida la llamada recursiva. Podemos definir una funci\u00f3n auxiliar (a\u00f1ade-al-final dato lista) que a\u00f1ade un dato al final de una lista usando append : Veamos directamente su implementaci\u00f3n, usando mi-append para a\u00f1adir un elemento al final de la lista: 1 2 ( define ( a\u00f1ade-al-final dato lista ) ( append lista ( list dato ))) La funci\u00f3n mi-reverse quedar\u00eda entonces como sigue: 1 2 3 ( define ( mi-reverse lista ) ( if ( null? lista ) ' () ( a\u00f1ade-al-final ( car lista ) ( mi-reverse ( cdr lista ))))) Funci\u00f3n cuadrados-hasta La funci\u00f3n (cuadrados-hasta x) devuelve una lista con los cuadrados de los n\u00fameros hasta x : 1 2 Para construir una lista de los cuadrados hasta x: construyo la lista de los cuadrados hasta x-1 y le a\u00f1ado el cuadrado de x El caso base de la recursi\u00f3n es el caso en el que x es 1, entonces devolvemos una lista formada por el 1. En Scheme: 1 2 3 4 5 ( define ( cuadrados-hasta x ) ( if ( = x 1 ) ' ( 1 ) ( cons ( cuadrado x ) ( cuadrados-hasta ( - x 1 ))))) Ejemplo: 1 ( cuadrados-hasta 10 ) ; \u21d2 (100 81 64 49 36 25 16 9 4 1) Funci\u00f3n filtra-pares Es muy habitual recorrer una lista y comprobar condiciones de sus elementos, construyendo una lista con los que cumplan una determinada condici\u00f3n. Por ejemplo, la siguiente funci\u00f3n filtra-pares construye una lista con los n\u00fameros pares de la lista que le pasamos como par\u00e1metro: 1 2 3 4 5 6 ( define ( filtra-pares lista ) ( cond (( null? lista ) ' ()) (( even? ( car lista )) ( cons ( car lista ) ( filtra-pares ( cdr lista )))) ( else ( filtra-pares ( cdr lista ))))) En el caso general, llamamos de forma recursiva a la funci\u00f3n para que filtre el cdr de la lista. Y le a\u00f1adimos el primer elemento si es par. Cada vez llamaremos a la recursi\u00f3n con una lista m\u00e1s peque\u00f1a, por lo que en el caso base tendremos que comprobar si la lista que recibimos. En ese caso devolvemos la lista vac\u00eda. Ejemplo: 1 ( filtra-pares ' ( 1 2 3 4 5 6 )) ; \u21d2 (2 4 6) Funci\u00f3n primo? El uso de listas es uno de los elementos fundamentales de la programaci\u00f3n funcional. Como ejemplo, vamos a ver c\u00f3mo trabajar con listas para construir una funci\u00f3n que calcula si un n\u00famero es primo. La forma de hacerlo ser\u00e1 calcular la lista de divisores del n\u00famero y comprobar si su longitud es dos. En ese caso ser\u00e1 primo. Por ejemplo: 1 2 3 ( divisores 8 ) ; \u21d2 (1 2 4 8) longitud = 4, no primo ( divisores 9 ) ; \u21d2 (1 3 9) longitud = 3, no primo ( divisores 11 ) ; \u21d2 (1 11) longitud = 2, primo Podemos definir entonces la funci\u00f3n (primo? x) de la siguiente forma: 1 2 3 ( define ( primo? x ) ( = 2 ( length ( divisores x )))) \u00bfC\u00f3mo implementamos la funci\u00f3n (divisores x) que nos devuelve la lista de los divisores de un n\u00famero x . Vamos a construirla de la siguiente forma: Creamos una lista de todos los n\u00fameros del 1 a x Filtramos la lista para dejar los divisores de x La funci\u00f3n (lista-hasta x) devuelve una lista de n\u00fameros 1..x: 1 2 3 4 ( define ( lista-hasta x ) ( if ( = x 0 ) ' () ( cons x ( lista-hasta ( - x 1 ))))) Ejemplos: 1 2 ( lista-hasta 2 ) ; \u21d2 (1 2) ( lista-hasta 10 ) ; \u21d2 (1 2 3 4 5 6 7 8 9 10) Definimos la funci\u00f3n (divisor? x y) que nos diga si x es divisor de y: 1 2 ( define ( divisor? x y ) ( = 0 ( mod y x ))) Ejemplos: 1 2 ( divisor 2 10 ) ; \u21d2 #t ( divisor 3 10 ) ; \u21d2 #f Una vez que hemos definido La funci\u00f3n divisor? podemos utilizarla para definir la funci\u00f3n recursiva (filtra-divisores lista x) que devuelve una lista con los n\u00fameros de lista que son divisores de x : 1 2 3 4 5 6 ( define ( filtra-divisores lista x ) ( cond (( null? lista ) ' ()) (( divisor? ( car lista ) x ) ( cons ( car lista ) ( filtra-divisores ( cdr lista ) x ))) ( else ( filtra-divisores ( cdr lista ) x )))) Ya podemos implementar la funci\u00f3n que devuelve los divisores de un n\u00famero x generando los n\u00fameros hasta x y filtrando los divisores de ese n\u00famero. Por ejemplo, para calcular los divisores de 10: 1 ( filtra-divisores ( 1 2 3 4 5 6 7 8 9 10 ) 10 ) ; \u21d2 (1 2 5 10) Se puede implementar de una forma muy sencilla: 1 2 ( define ( divisores x ) ( filtra-divisores ( lista-hasta x ) x )) Y una vez definida esta funci\u00f3n, ya puede funcionar correctamente la funci\u00f3n primo? . Funciones con n\u00famero variable de argumentos \u00b6 Hemos visto algunas funciones primitivas de Scheme, como + o max que admiten un n\u00famero variable de argumentos. \u00bfPodemos hacerlo tambi\u00e9n en funciones definidas por nosotros? La respuesta es s\u00ed, utilizando lo que se denomina notaci\u00f3n dotted-tail (punto-cola) para definir los par\u00e1metros de la funci\u00f3n. En esta notaci\u00f3n se coloca un punto antes del \u00faltimo par\u00e1metro. Los par\u00e1metros antes del punto (si existen) tendr\u00e1n como valores los argumentos usados en la llamada y el resto de argumentos se pasar\u00e1n en forma de lista en el \u00faltimo par\u00e1metro. Por ejemplo, si tenemos la definici\u00f3n 1 2 ( define ( funcion-dos-o-mas-args x y . lista-args ) <cuerpo> ) podemos llamar a la funci\u00f3n anterior con dos o m\u00e1s argumentos: 1 ( funcion-dos-o-mas-args 1 2 3 4 5 6 ) En la llamada, los par\u00e1metros x e y tomar\u00e1n los valores 1 y 2. El par\u00e1metro lista-args tomar\u00e1 como valor una lista con los argumentos restantes (3 4 5 6) . Tambi\u00e9n es posible permitir que todos los argumentos sean opcionales no poniendo ning\u00fan argumento antes del punto:: 1 2 ( define ( funcion-cualquier-numero-args . lista-args ) <cuerpo> ) Si hacemos la llamada 1 ( funcion-cualquier-numero-args 1 2 3 4 5 6 ) el par\u00e1metro lista-args tomar\u00e1 como valor la lista (1 2 3 4 5 6) . Veamos un sencillo ejemplo. Podemos implementar una funci\u00f3n mi-suma que tome al menos dos argumentos y despu\u00e9s un n\u00famero variable de argumentos y devuelva la suma de todos ellos. Es muy sencillo: recogemos todos los argumentos en la lista de argumentos variables y llamamos a la funci\u00f3n suma-lista que suma una lista de n\u00fameros: 1 2 3 4 ( define ( mi-suma x y . lista-nums ) ( if ( null? lista-nums ) ( + x y ) ( + x ( + y ( suma-lista lista-nums ))))) Funci\u00f3n apply \u00b6 Con la funci\u00f3n (apply funcion lista) podemos aplicar una funci\u00f3n de aridad n a una lista de datos de n datos, haciendo que cada uno de los datos se pasen a la funci\u00f3n en orden como par\u00e1metros. Por ejemplo, podemos definir la funci\u00f3n (suma-cuadrados x y) de aridad 2 de la siguiente forma: 1 2 ( define ( suma-cuadrados x y ) ( + ( * x x ) ( * y y ))) Para invocar a suma-cuadrados hay que pasarle 2 par\u00e1metros: 1 ( suma-cuadrados 10 5 ) ; \u21d2 100 Podemos usar la funci\u00f3n apply para aplicar esta funci\u00f3n a los dos elementos de una lista: 1 ( apply suma-cuadrados ' ( 10 5 )) ; \u21d2 100 Usando apply podemos definir funciones recursivas con n\u00famero variable de argumentos. Por ejemplo la funci\u00f3n suma-parejas que suma un n\u00famero variable de parejas: 1 2 3 4 5 6 7 8 9 10 ( define ( suma-pareja p1 p2 ) ( cons ( + ( car p1 ) ( car p2 )) ( + ( cdr p1 ) ( cdr p2 )))) ( define ( suma-parejas . parejas ) ( if ( null? parejas ) ' ( 0 . 0 ) ( suma-pareja ( car parejas ) ( apply suma-parejas ( cdr parejas ))))) ( suma-parejas ' ( 1 . 2 ) ' ( 3 . 4 ) ' ( 5 . 6 )) ; \u21d2 '(9 . 12) Hay que hacer notar en que la llamada recursiva es necesario usar apply porque (cdr parejas) es una lista. No podemos invocar a suma-parejas pasando una lista como par\u00e1metro, sino que hay que pasarle todos los argumentos por separado (recibe un n\u00famero variable de argumentos). Eso lo conseguimos hacer con apply . Funciones como tipos de datos de primera clase \u00b6 Hemos visto que la caracter\u00edstica fundamental de la programaci\u00f3n funcional es la definici\u00f3n de funciones. Hemos visto tambi\u00e9n que no producen efectos laterales y no tienen estado. Una funci\u00f3n toma unos datos como entrada y produce un resultado como salida. Una de las caracter\u00edsticas fundamentales de la programaci\u00f3n funcional es considerar a las funciones como objetos de primera clase . Recordemos que un tipo de primera clase es aquel que: Puede ser asignado a una variable Puede ser pasado como argumento a una funci\u00f3n Puede ser devuelto como resultado de una invocaci\u00f3n a una funci\u00f3n Puede ser parte de un tipo mayor Vamos a ver que las funciones son ejemplos de todos los casos anteriores: vamos a poder crear funciones sin nombre y asignarlas a variables, pasarlas como par\u00e1metro de otras funciones, devolverlas como resultado de invocar a otra funci\u00f3n y guardarlas en tipos de datos compuestos como listas. La posibilidad de usar funciones como objetos de primera clase es una caracter\u00edstica fundamental de los lenguajes funcionales. Es una caracter\u00edstica de muchos lenguajes multi-paradigma con caracter\u00edsticas funcionales como JavaScript , Python , Swift o a partir de la versi\u00f3n 8 de Java, Java 8 , (donde se denominan expresiones lambda ). Forma especial lambda \u00b6 Vamos a empezar explicando la forma especial lambda de Scheme, que nos permite crear funciones an\u00f3nimas en tiempo de ejecuci\u00f3n. De la misma forma que podemos usar cadenas o enteros sin darles un nombre, en Scheme es posible usar una funci\u00f3n sin darle un nombre mediante esta forma especial. Sintaxis de la forma especial lambda La sintaxis de la forma especial lambda es: 1 2 (lambda (<arg1> ... <argn>) <cuerpo>) El cuerpo del lambda define un bloque de c\u00f3digo y sus argumentos son los par\u00e1metros necesarios para ejecutar ese bloque de c\u00f3digo. Llamamos a la funci\u00f3n resultante una funci\u00f3n an\u00f3nima . Algunos ejemplos: Una funci\u00f3n an\u00f3nima que suma dos parejas: 1 2 3 ( lambda ( p1 p2 ) ( cons ( + ( car p1 ) ( car p2 )) ( + ( cdr p1 ) ( cdr p2 )))) Una funci\u00f3n an\u00f3nima que devuelve el mayor de dos n\u00fameros: 1 2 3 4 ( lambda ( a b ) ( if ( > a b ) a b )) Sem\u00e1ntica de la forma especial lambda La invocaci\u00f3n a la forma especial lambda construye una funci\u00f3n an\u00f3nima en tiempo de ejecuci\u00f3n. Por ejemplo, si ejecutamos una expresi\u00f3n lambda en el int\u00e9rprete veremos que devuelve un procedimiento: 1 ( lambda ( x ) ( * x x )) ; \u21d2 #<procedure> El procedimiento construido es un bloque de c\u00f3digo que devuelve el cuadrado de un n\u00famero. \u00bfQu\u00e9 podemos hacer con este procedimiento? Podemos asignarlo a un identificador. Por ejemplo, en la siguiente expresi\u00f3n, primero se eval\u00faa la expresi\u00f3n lambda y el procedimiento resultante se asocia al identificador f . 1 ( define f ( lambda ( x ) ( * x x ))) El ejemplo anterior funciona de una forma id\u00e9ntica al siguiente: 1 ( define x ( + 2 3 )) En ambos casos se eval\u00faa la expresi\u00f3n derecha y el resultado se guarda en un identificador. En el primer caso la expresi\u00f3n que se eval\u00faa devuelve un procedimiento, que se guarda en la variable f y en el segundo un n\u00famero, que se guarda en la variable x . Si escribimos los identificadores f y x en el int\u00e9rprete Scheme los eval\u00faa y muestra los valores guardados: 1 2 f ; \u21d2 #<procedure:f> x ; \u21d2 5 En el primer caso se devuelve un procedimiento y en el segundo un n\u00famero. F\u00edjate que Scheme trata a los procedimientos y a los n\u00fameros de la misma forma; son lo que se denominan datos de primera clase. Una vez asignado un procedimiento a un identificador, lo podemos utilizar como de la misma forma que invocamos habitualmente a una funci\u00f3n: 1 ( f 3 ) ; \u21d2 9 No es necesario un identificador para invocar a una funci\u00f3n; podemos crear la funci\u00f3n con una expresi\u00f3n lambda e invocar a la funci\u00f3n an\u00f3nima reci\u00e9n creada: 1 (( lambda ( x ) ( * x x )) 3 ) ; \u21d2 9 La llamada a lambda crea un procedimiento y el par\u00e9ntesis a su izquierda lo invoca con el par\u00e1metro 3: 1 (( lambda ( x ) ( * x x )) 3 ) = ( #<procedure> 3 ) \u21d2 9 Es importante remarcar que con lambda estamos creando una funci\u00f3n en tiempo de ejecuci\u00f3n . Es c\u00f3digo que creamos para su posterior invocaci\u00f3n. Cada lenguaje de programaci\u00f3n tiene su sintaxis propia de expresiones lambda. Por ejemplo, las siguientes expresiones crean una funci\u00f3n que devuelve el cuadrado de un n\u00famero: Java 8 1 Integer x -> { x * x } Scala 1 ( x : Int ) => { x * x } Objective C 1 2 3 4 ^ int ( int x ) { x * x }; Swift 1 { ( x : Int ) -> Int in return x * x } Identificadores y funciones Tras conocer lambda ya podemos explicarnos por qu\u00e9 cuando escribimos en el int\u00e9rprete de Scheme el nombre de una funci\u00f3n, se eval\u00faa a un procedure : 1 + ; \u21d2 <procedure:+> El identificador se eval\u00faa y devuelve el objeto funci\u00f3n al que est\u00e1 ligado. En Scheme los nombres de las funciones son realmente s\u00edmbolos a los que est\u00e1n ligados objetos de tipo funci\u00f3n . Podemos asignar funciones ya existentes a nuevos identificadores usando define , como en el ejemplo siguiente: 1 2 3 + ; \u21d2 <procedure:+> ( define suma + ) ( suma 1 2 3 4 ) ; \u21d2 10 Es muy importante darse cuenta que la expresi\u00f3n (define suma +) se eval\u00faa de forma id\u00e9ntica a (define y x) . Primero se eval\u00faa el identificador + , que devuelve el objeto funci\u00f3n suma, que se asigna a la variable suma . El resultado final es que tanto + como suma tienen como valor el mismo procedimiento: La forma especial define para definir una funci\u00f3n no es m\u00e1s que azucar sint\u00e1ctico . 1 2 (define (<nombre> <args>) <cuerpo>) siempre se convierte internamente en: 1 2 3 (define <nombre> (lambda (<args>) <cuerpo>)) Por ejemplo 1 2 ( define ( cuadrado x ) ( * x x )) es equivalente a: 1 2 ( define cuadrado ( lambda ( x ) ( * x x ))) Predicado procedure? Podemos comprobar si algo es una funci\u00f3n utilizando el predicado de Scheme procedure? . Por ejemplo: 1 2 3 4 ( procedure? ( lambda ( x ) ( * x x ))) ; \u21d2 #t ( define suma + ) ( procedure? suma ) ; \u21d2 #t ( procedure? ' + ) ; \u21d2 #f Hemos visto que las funciones pueden asignarse a variables. Tambi\u00e9n cumplen las otras condiciones necesarias para ser consideradas objetos de primera clase. Funciones argumentos de otras funciones \u00b6 Hemos visto ya un ejemplo de c\u00f3mo pasar una funci\u00f3n como par\u00e1metro de otra. Veamos alg\u00fan otro. Por ejemplo, podemos definir la funci\u00f3n aplica que recibe una funci\u00f3n en el par\u00e1metro func y dos valores en los par\u00e1metros x e y y devuelve el resultado de invocar a la funci\u00f3n que pasamos como par\u00e1metro con x e y . La funci\u00f3n que se pase como par\u00e1metro debe tener dos argumentos Para realizar la invocaci\u00f3n a la funci\u00f3n que se pasa como par\u00e1metro basta con usar func como su nombre. La funci\u00f3n se ha ligado al nombre func en el momento de la invocaci\u00f3n a aplica , de la misma forma que los argumentos se ligan a los par\u00e1metros x e y : 1 2 ( define ( aplica f x y ) ( f x y )) Algunos ejemplos de invocaci\u00f3n, usando funciones primitivas, funciones definidas y expresiones lambda: 1 2 3 4 5 6 7 8 9 10 ( aplica + 2 3 ) ; \u21d2 5 ( aplica * 4 5 ) ; \u21d2 10 ( aplica string-append \"hola\" \"adios\" ) ; \u21d2 \"holaadios\" ( define ( string-append-con-guion s1 s2 ) ( string-append s1 \"-\" s2 )) ( aplica string-append-con-guion \"hola\" \"adios\" ) ; \u21d2 \"hola-adios\" ( aplica ( lambda ( x y ) ( sqrt ( + ( * x x ) ( * y y )))) 3 4 ) ; \u21d2 5 Otro ejemplo, la funci\u00f3n aplica-2 que toma dos funciones f y g y un argumento x y devuelve el resultado de aplicar f a lo que devuelve la invocaci\u00f3n de g con x : 1 2 3 4 5 6 7 8 ( define ( aplica-2 f g x ) ( f ( g x ))) ( define ( suma-5 x ) ( + x 5 )) ( define ( doble x ) ( + x x )) ( aplica-2 suma-5 doble 3 ) ; \u21d2 11 Generalizaci\u00f3n \u00b6 La posibilidad de pasar funciones como par\u00e1metros de otras es una poderosa herramienta de abstracci\u00f3n. Nos va a permitir dise\u00f1ar funciones m\u00e1s gen\u00e9ricas. Veamos un ejemplo. Supongamos que queremos calcular el sumatorio de a hasta b : 1 2 3 4 5 6 ( define ( sum-x a b ) ( if ( > a b ) 0 ( + a ( sum-x ( + a 1 ) b )))) ( sum-x 1 10 ) ; \u21d2 55 Supongamos ahora que queremos calcular el sumatorio de a hasta b sumando los n\u00fameros al cuadrado: 1 2 3 4 5 6 ( define ( sum-cuadrado-x a b ) ( if ( > a b ) 0 ( + ( * a a ) ( sum-cuadrado-x ( + a 1 ) b )))) ( sum-cuadrado-x 1 10 ) ; \u21d2 385 Y el sumatorio de a hasta b sumando los cubos: 1 2 3 4 5 6 ( define ( sum-cubo-x a b ) ( if ( > a b ) 0 ( + ( * a a a ) ( sum-cubo-x ( + a 1 ) b )))) ( sum-cubo-x 1 10 ) ; \u21d2 3025 Vemos que el c\u00f3digo de las tres funciones anteriores es muy similar, cada funci\u00f3n la podemos obtener haciendo un copy-paste de otra previa. Lo \u00fanico que cambia es la funci\u00f3n a aplicar a cada n\u00famero de la serie. Siempre que hagamos copy-paste al programar tenemos que empezar a sospechar que no estamos generalizando suficientemente el c\u00f3digo. Un copy-paste arrastra tambi\u00e9n bugs y obliga a realizar m\u00faltiples modificaciones del c\u00f3digo cuando en el futuro tengamos que cambiar cosas. La posibilidad de pasar una funci\u00f3n como par\u00e1metro viene a nuestra ayuda para generalizar el c\u00f3digo anterior. En este caso, lo \u00fanico que cambia en las tres funciones anteriores es la funci\u00f3n a aplicar a los n\u00fameros de la serie. En primer caso no se hace nada, en el segundo se eleva al cuadrado y en el tercer caso al cubo. Podemos tomar esa funci\u00f3n como un par\u00e1metro adicional y definir una funci\u00f3n gen\u00e9rica sum-f-x que generaliza las tres funciones anteriores. Tendr\u00edamos el sumatorio desde a hasta b de f(x) : 1 2 3 4 ( define ( sum-f-x f a b ) ( if ( > a b ) 0 ( + ( f a ) ( sum-f-x f ( + a 1 ) b )))) Las funciones anteriores son casos particulares de esta funci\u00f3n que las generaliza. Por ejemplo, para calcular el sumatorio desde 1 hasta 10 de x al cubo: 1 2 3 4 ( define ( cubo x ) ( * x x x )) ( sum-f-x cubo 1 10 ) ; \u21d2 3025 Tambi\u00e9n podemos utilizar una expresi\u00f3n lambda en la invocaci\u00f3n a sum-f que construya la funci\u00f3n que queremos aplicar a cada n\u00famero. Por ejemplo, podemos sumar la expresi\u00f3n (n/(n-1)) para todos los n\u00fameros del 2 al 100: 1 ( sum-f-x ( lambda ( n ) ( / n ( - n 1 ))) 2 100 ) Veremos m\u00e1s adelante muchos m\u00e1s ejemplos de funciones pasadas como par\u00e1metros y de la generalidad que permite este patr\u00f3n, cuando estudiemos las funciones de orden superior. Funciones que devuelven funciones \u00b6 Cualquier objeto de primera clase puede ser devuelto por una funci\u00f3n; enteros, booleanos, parejas, etc. son objetos primitivos y podemos definir funciones que los devuelven. En el paradigma funcional lo mismo sucede con las funciones. Podemos definir una funci\u00f3n que cuando se invoque construya otra funci\u00f3n y la devuelva como resultado. Esta es una de la caracter\u00edsticas m\u00e1s importantes que diferencia los lenguajes de programaci\u00f3n funcionales de otros que no lo son. En lenguajes como C, C++ o Java (antes de Java 8) no es posible hacer esto. Para devolver una funci\u00f3n en Scheme debemos usar la forma especial lambda en el cuerpo de una funci\u00f3n. As\u00ed, cuando se invoca a esta funci\u00f3n se eval\u00faa lambda y se devuelve la funci\u00f3n resultante. Es una funci\u00f3n que creamos en tiempo de ejecuci\u00f3n, durante la evaluaci\u00f3n de la funci\u00f3n principal. La funci\u00f3n que se devuelve se denomina clausura ( Wikipedia ). Y decimos que la funci\u00f3n que ha construido la clausura es una funci\u00f3n constructora . Funci\u00f3n sumador Vamos a empezar con un ejemplo muy sencillo. Definimos una funci\u00f3n constructora que crea en su ejecuci\u00f3n una funci\u00f3n que suma k a un n\u00famero: 1 2 3 ( define ( construye-sumador k ) ( lambda ( x ) ( + x k ))) El cuerpo de la funci\u00f3n (construye-sumador k) est\u00e1 formado por una expresi\u00f3n lambda. Cuando se invoca a construye-sumador se eval\u00faa esta expresi\u00f3n lambda y se devuelve el procedimiento creado. En este caso se construye otra funci\u00f3n de 1 argumento que suma k al argumento. Por ejemplo, podemos invocar a construye-sumador pasando 10 como par\u00e1metro: 1 ( construye-sumador 10 ) ; \u21d2 #<procedure> Como hemos dicho, se devuelve un procedimiento, una funci\u00f3n. Esta funci\u00f3n devuelta debe invocarse con un argumento y devolver\u00e1 el resultado de sumar 10 a ese argumento: 1 2 ( define f ( construye-sumador 10 )) ( f 3 ) ; \u21d2 13 Tambi\u00e9n podemos invocar directamente a la funci\u00f3n que devuelve la funci\u00f3n constructora, sin guardarla en una variable: 1 (( construye-sumador 10 ) 3 ) ; \u21d2 13 Dependiendo del par\u00e1metro que le pasemos a la funci\u00f3n constructora obtendremos una funci\u00f3n sumadora que sume un n\u00famero u otro. Por ejemplo para obtener una funci\u00f3n sumadora que suma 100: 1 2 ( define g ( construye-sumador 100 )) ( g 3 ) ; \u21d2 103 \u00bfC\u00f3mo funciona la clausura? \u00bfPor qu\u00e9 la invocaci\u00f3n a (g 3) devuelve 103?. Aqu\u00ed hay que apartarse bastante del modelo de evaluaci\u00f3n de sustituci\u00f3n que hemos visto y utilizar un nuevo modelo en el que se tiene en cuenta los \u00e1mbitos de las variables. No vamos a explicar en detalle este modelo, pero s\u00ed dar unas breves pinceladas. Recordemos la definici\u00f3n de construye-sumador : 1 2 3 ( define ( construye-sumador k ) ( lambda ( x ) ( + x k ))) Y supongamos que realizamos las siguientes invocaciones: 1 2 ( define g ( construye-sumador 100 )) ( g 3 ) ; \u21d2 103 Podemos explicar lo que sucede en la evaluaci\u00f3n de estas funciones de la siguiente forma: Cuando invocamos a construye-sumador con un valor concreto para k (por ejemplo 100), queda vinculado el valor de 100 al par\u00e1metro k en el \u00e1mbito local de la funci\u00f3n. En este \u00e1mbito local la expresi\u00f3n lambda crea una funci\u00f3n. Esta funci\u00f3n creada en el \u00e1mbito local captura este \u00e1mbito local, con sus variables y sus valores (en este caso la variable k y su valor 100). Cuando se invoca a la funci\u00f3n desde fuera (cuando llamamos a g en el ejemplo) se ejecuta el cuerpo de la funci\u00f3n (+ x k) con x valiendo el par\u00e1metro (3) y el valor de k se obtiene del \u00e1mbito capturado (100). El hecho de que funci\u00f3n creada en el \u00e1mbito local capture este \u00e1mbito es lo que hace que se denomine una clausura (del ingl\u00e9s closure ). La funci\u00f3n se cierra sobre el \u00e1mbito capturado y puede utilizar sus variables. Funci\u00f3n composicion Otro ejemplo de una funci\u00f3n que devuelve otra funci\u00f3n es la funci\u00f3n siguiente (composicion f g) que recibe dos funciones de un argumento y devuelve otra funci\u00f3n que realiza la composici\u00f3n de ambas: 1 2 3 ( define ( composicion f g ) ( lambda ( x ) ( f ( g x )))) La funci\u00f3n devuelta invoca primero a g y el resultado se lo pasa a f . Veamos un ejemplo. Supongamos que tenemos definidas la funci\u00f3n cuadrado y doble que calculan el cuadrado y el doble de un n\u00famero respectivamente. Podremos entonces llamar a composicion con esas dos funciones para construir otra funci\u00f3n que primero calcule el cuadrado y despu\u00e9s el doble de una n\u00famero: 1 ( define h ( composicion doble cuadrado )) La variable h contiene la funci\u00f3n devuelta por composicion . Una funci\u00f3n de un argumento que devuelve el doble del cuadrado de un n\u00famero: 1 ( h 4 ) ; \u21d2 32 Funci\u00f3n construye-segura Vamos a ver un \u00faltimo ejemplo en el que definimos una funci\u00f3n constructora que extiende funciones ya existentes. Recordemos la funci\u00f3n lista-hasta : 1 2 3 4 ( define ( lista-hasta x ) ( if ( = x 0 ) ' () ( cons x ( lista-hasta ( - x 1 ))))) Un problema de la funci\u00f3n anterior es que si le pasamos un n\u00famero negativo entra en un bucle infinito. Definimos la funci\u00f3n (construye-segura condicion f) que recibe dos funciones: un predicado y otra funci\u00f3n, ambos de 1 argumento. Devuelve otra funci\u00f3n en la que s\u00f3lo se llamar\u00e1 a f si el argumento cumple la condicion . 1 2 3 4 5 ( define ( construye-segura condicion f ) ( lambda ( x ) ( if ( condicion x ) ( f x ) ' error ))) La funci\u00f3n construye una funci\u00f3n an\u00f3nima de un argumento x (igual que f ) en cuyo cuerpo se comprueba si el argumento cumple la condici\u00f3n y s\u00f3lo en ese caso se llama a f . Podemos entonces construir una funci\u00f3n segura a partir de la funci\u00f3n lista-hasta en la que se devuelva error si el argumento es un n\u00famero negativo: 1 2 3 4 ( define lista-hasta-segura ( construye-segura ( lambda ( x ) ( >= x 0 )) lista-hasta )) ( lista-hasta-segura 8 ) ; \u21d2 (8 7 6 5 4 3 2 1) ( lista-hasta-segura -1 ) ; \u21d2 error Podr\u00edamos usar construye-segura con cualquier funci\u00f3n de 1 argumento que queramos hacer segura. Por ejemplo, la funci\u00f3n sqrt : 1 2 3 ( define sqrt-segura ( construye-segura ( lambda ( x ) ( >= x 0 ) sqrt )) ( sqrt-segura 100 ) ; \u21d2 10 ( sqrt-segura -100 ) ; \u21d2 error La potencia de las funciones constructoras viene del hecho de que es posible crear nuevas funciones en tiempo de ejecuci\u00f3n. No es necesario conocer las condiciones y las caracter\u00edsticas de estas nuevas funciones a priori, cuando estamos compilando nuestro programa. Sino que pueden depender de datos obtenidos del usuario o de otros m\u00f3dulos del programa en tiempo de ejecuci\u00f3n. Por ejemplo, la condici\u00f3n de construye-segura podr\u00eda contener valores obtenidos en tiempo de ejecuci\u00f3n, de forma que solo se llamara a la funci\u00f3n que queremos hacer segura si el n\u00famero est\u00e1 en un rango definido esos valores: 1 2 ( construye-segura ( lambda ( x ) ( and ( >= x limite-inf ) ( <= x limite-sup ))) f ) ) Funciones en estructuras de datos \u00b6 La \u00faltima caracter\u00edstica de los tipos de primera clase es que pueden formar parte de tipos de datos compuestos, como listas. Para construir una lista de funciones debemos llamar a list con las funciones: 1 2 3 4 5 6 7 ( define ( cuadrado x ) ( * x x )) ( define ( suma-1 x ) ( + x 1 )) ( define ( doble x ) ( * x 2 )) ( define lista ( list cuadrado suma-1 doble )) lista ; \u21d2 (#<procedure:cuadrado> #<procedure:suma-1> #<procedure:doble>) Tambi\u00e9n podemos definir las funciones con expresiones lambda. Por ejemplo, podemos a\u00f1adir a la lista una funci\u00f3n que suma 5 a un n\u00famero: 1 2 3 ( define lista2 ( cons ( lambda ( x ) ( + x 5 )) lista )) lista2 ; \u21d2 (#<procedure> #<procedure:cuadrado> #<procedure:suma-1> #<procedure:doble>) Una vez creada una lista con funciones, \u00bfc\u00f3mo podemos invocar a alguna de ellas?. Debemos tratarlas de la misma forma que tratamos cualquier otro dato guardado en la lista, las recuperamos con las funciones car o list-ref y las invocamos. Por ejemplo, para invocar a la primera funci\u00f3n de lista2 : 1 (( car lista2 ) 10 ) ; \u21d2 15 O a la tercera: 1 (( list-ref lista2 2 ) 10 ) ; \u21d2 11 Funciones que trabajan con listas de funciones Veamos un ejemplo de una funci\u00f3n (aplica-funcs lista-funcs x) que recibe una lista de funciones en el par\u00e1metro lista-funcs y las aplica todas de derecha a izquierda al n\u00famero que pasamos en el par\u00e1metro x . Por ejemplo, supongamos la lista anterior, que contiene las funciones cuadrado , cubo y suma-1 : 1 ( define lista ( list cuadrado cubo suma-1 )) la llamada a (aplica-funcs lista 5) deber\u00eda devolver el resultado de aplicar primero suma-1 a 5, despu\u00e9s cubo al resultado y despu\u00e9s cuadrado : 1 ( cuadrado ( cubo ( suma-1 5 )) ; \u21d2 46656 Para implementar aplica-funcs tenemos que usar una recursi\u00f3n. Si vemos el ejemplo, podemos comprobar que es sencillo definir el caso general: 1 2 3 (aplica-funcs (cuadrado cubo suma-1) 5) = (cuadrado (aplica-funcs (cubo suma-1) 5)) = (cuadrado 216) = 46656 El caso general de la recursi\u00f3n de la funci\u00f3n aplica-funcs se define entonces como: 1 2 3 ( define ( aplica-funcs lista-funcs x ) ; falta el caso base (( car lista-funcs ) ( aplica-funcs ( cdr lista-funcs ) x ))) El caso base ser\u00eda en el que la lista de funciones es vac\u00eda, en cuyo caso se devuelve el propio n\u00famero: 1 2 3 ( if ( null? lista-funcs ) ; la lista de funciones est\u00e1 vac\u00eda x ; devolvemos el propio n\u00famero ... La implementaci\u00f3n completa es: 1 2 3 4 5 ( define ( aplica-funcs lista-funcs x ) ( if ( null? lista-funcs ) x (( car lista-funcs ) ( aplica-funcs ( cdr lista-funcs ) x )))) Un ejemplo de uso: 1 2 3 4 ( define lista-funcs ( list ( lambda ( x ) ( * x x )) ( lambda ( x ) ( * x x x )) ( lambda ( x ) ( + x 1 )))) ( aplica-funcs lista-funcs 5 ) ; \u21d2 46656 Funciones de orden superior \u00b6 Llamamos funciones de orden superior ( higher order functions en ingl\u00e9s) a las funciones que toman otras como par\u00e1metro o devuelven otra funci\u00f3n. Permiten generalizar soluciones con un alto grado de abstracci\u00f3n. Ya hemos visto algunas funciones de orden superior, unas construidas por nostros y otras propias de Scheme, como apply . Adem\u00e1s de apply , los lenguajes de programaci\u00f3n funcional como Scheme, Scala o Java 8 tienen ya predefinidas algunas otras funciones de orden superior que trabajan con listas. Estas funciones permiten definir operaciones sobre las listas de una forma muy concisa y compacta. Son muy usadas, porque tambi\u00e9n se pueden utilizar sobre streams de datos obtenidos en operaciones de entrada/salida (por ejemplo, datos JSON resultantes de una petici\u00f3n HTTP). Vamos a ver las funciones m\u00e1s importantes, su uso y su implementaci\u00f3n. map filter exists? for-all? foldr y foldl Despu\u00e9s de explicar estas funciones terminaremos con un ejemplo de su aplicaci\u00f3n en el que comprobaremos c\u00f3mo la utilizaci\u00f3n de funciones de orden superior es una excelente herramienta de la programaci\u00f3n funcional que permite hacer c\u00f3digo muy conciso y expresivo. La combinaci\u00f3n de funciones de nivel superior con listas es una de las caracter\u00edsticas m\u00e1s potentes de la programaci\u00f3n funcional. Funci\u00f3n map Comenzamos con la funci\u00f3n map . La palabra map viene del ingl\u00e9s mapping o transformaci\u00f3n. Se trata de una funci\u00f3n que transforma una lista aplicando a todos sus elementos una funci\u00f3n de transformaci\u00f3n que se pasa como par\u00e1metro. En concreto, la funci\u00f3n recibe otra funci\u00f3n y una lista: 1 (map transforma lista) -> lista Y devuelve la lista resultante de aplicar la funci\u00f3n a todos los elementos de la lista. La funci\u00f3n de transformaci\u00f3n recibe como argumentos elementos de la lista y devuelve el resultado de transformar ese elemento. 1 (transforma elemento) -> elemento Por ejemplo: 1 ( map cuadrado ' ( 1 2 3 4 5 )) ; \u21d2 (1 4 9 16 25) La lista resultante es el resultado de construir una lista nueva aplicando la funci\u00f3n cuadrado a todos los elementos de la lista original. La funci\u00f3n de transformaci\u00f3n debe ser compatible con los elementos de la lista original. Por ejemplo, si la lista es una lista de parejas, la funci\u00f3n de transformaci\u00f3n debe recibir una pareja. Veamos un ejemplo de este caso, en el que a partir de una lista de parejas obtenemos una lista con las sumas de cada pareja: 1 2 3 4 ( define ( suma-pareja pareja ) ( + ( car pareja ) ( cdr pareja ))) ( map suma-pareja ' (( 2 . 4 ) ( 3 . 6 ) ( 5 . 3 ))) ; \u21d2 (6 9 8) Tambi\u00e9n podr\u00edamos hacerlo con una expresi\u00f3n lambda: 1 2 3 ( map ( lambda ( pareja ) ( + ( car pareja ) ( cdr pareja ))) ' (( 2 . 4 ) ( 3 . 6 ) ( 5 . 3 ))) ; \u21d2 (6 9 8) Un \u00faltimo ejemplo, en el que usamos map para transformar una lista de s\u00edmbolos en una lista con sus longitudes: 1 2 3 ( map ( lambda ( s ) ( string-length ( symbol->string s ))) ' ( Esta es una lista de s\u00edmbolos )) ; \u21d2 (4 2 3 5 2 8) Implementaci\u00f3n de map \u00bfC\u00f3mo se podr\u00eda implementar map de forma recursiva? Definimos la funci\u00f3n mi-map . La implementaci\u00f3n es la siguiente: 1 2 3 4 5 ( define ( mi-map f lista ) ( if ( null? lista ) ' () ( cons ( f ( car lista )) ( mi-map f ( cdr lista ))))) Funci\u00f3n map con m\u00e1s de una lista La funci\u00f3n map puede recibir un n\u00famero variable de listas, todas ellas de la misma longitud: 1 (map transforma lista_1 ... lista_n) -> lista En este caso la funci\u00f3n de transforma debe recibir tantos argumentos como listas recibe map : 1 (transforma dato_1 ... dato_n) -> dato La funci\u00f3n map aplica transforma a los elementos cogidos de las n listas y construye as\u00ed la lista resultante. Ejemplos: 1 2 3 4 5 6 7 8 9 10 11 12 ( map + ' ( 1 2 3 ) ' ( 10 20 30 )) ; \u21d2 (11 22 33) ( map cons ' ( 1 2 3 ) ' ( 10 20 30 )) ; \u21d2 ((1 . 10) (2 . 20) (3 . 30)) ( map > ' ( 12 3 40 ) ' ( 20 0 10 )) ; \u21d2 (#f #t #t) ( define ( mayor a b ) ( if ( > a b ) a b )) ( define ( mayor-de-tres a b c ) ( mayor a ( mayor b c ))) ( map mayor-de-tres ' ( 10 2 20 -1 34 ) ' ( 2 3 12 89 0 ) ' ( 100 -10 23 45 8 )) ; \u21d2 (100 3 23 89 34) Consejo La funci\u00f3n map recibe una lista de n elementos y devuelve otra de n elementos transformados. Funci\u00f3n filter Veamos otra funci\u00f3n de orden superior que trabaja sobre listas. La funci\u00f3n (filter predicado lista) toma como par\u00e1metro un predicado y una lista y devuelve como resultado los elementos de la lista que cumplen el predicado. 1 (filter predicado lista) -> lista La funci\u00f3n (predicado elem) que usa filter recibe elementos de la lista y devuelve #t o #f . 1 (predicado elem) -> boolean Un ejemplo de uso: 1 ( filter even? ' ( 1 2 3 4 5 6 7 8 )) ; \u21d2 (2 4 6 8) Otro ejemplo: supongamos que queremos filtrar una lista de parejas de n\u00fameros, devolviendo aquellas que parejas que cumplen que su parte izquierda es mayor o igual que la derecha. Lo podr\u00edamos hacer con la siguiente expresi\u00f3n: 1 2 3 4 ( filter ( lambda ( pareja ) ( >= ( car pareja ) ( cdr pareja ))) ' (( 10 . 4 ) ( 2 . 4 ) ( 8 . 8 ) ( 10 . 20 ))) ; \u21d2 ((10 . 4) (8 . 8)) Y un \u00faltimo ejemplo: filtramos todos los s\u00edmbolos con longitud menor de 4. 1 2 3 4 ( filter ( lambda ( s ) ( >= ( string-length ( symbol->string s )) 4 )) ' ( Esta es una lista de s\u00edmbolos )) ; \u21d2 (Esta lista s\u00edmbolos) Consejo La funci\u00f3n filter recibe una lista de n elementos y devuelve otra de con n o menos elementos originales filtrados por una condici\u00f3n. Implementaci\u00f3n de filter Podemos implementar la funci\u00f3n filter de forma recursiva: 1 2 3 4 5 6 ( define ( mi-filter pred lista ) ( cond (( null? lista ) ' ()) (( pred ( car lista )) ( cons ( car lista ) ( mi-filter pred ( cdr lista )))) ( else ( mi-filter pred ( cdr lista ))))) Funci\u00f3n exists? La funci\u00f3n de orden superior exists recibe un predicado y una lista y comprueba si alg\u00fan elemento de la lista cumple ese predicado. 1 (exists? predicado lista) -> boolean Igual que en filter el predicado recibe elementos de la lista y devuelve #t o #f . 1 (predicado elem) -> boolean La funci\u00f3n exists no est\u00e1 definida con este nombre en Racket, aunque s\u00ed en Scheme. En Racket se llama ormap . Ejemplo de uso: 1 2 3 ( ormap even? ' ( 1 2 3 4 5 6 )) ; \u21d2 #t ( ormap ( lambda ( x ) ( > x 10 )) ' ( 1 3 5 8 )) ; \u21d2 #f La implementaci\u00f3n recursiva de exists? es la siguiente: 1 2 3 4 5 ( define ( exists? predicado lista ) ( if ( null? lista ) #f ( or ( predicado ( car lista )) ( exists? predicado ( cdr lista ))))) Funci\u00f3n for-all? La funci\u00f3n de orden superior for-all? recibe un predicado y una lista y comprueba que todos los elementos de la lista cumplen ese predicado. La funci\u00f3n tampoco est\u00e1 definida con este nombre en Racket, aunque s\u00ed en Scheme. En Racket existe una funci\u00f3n equivalente que se llama andmap . Ejemplo de uso: 1 2 3 ( andmap even? ' ( 2 4 6 )) ; \u21d2 #t ( andmap ( lambda ( x ) ( > x 10 )) ' ( 12 30 50 80 )) ; \u21d2 #t La implementaci\u00f3n recursiva de for-all? es la siguiente: 1 2 3 4 ( define ( for-all? predicado lista ) ( or ( null? lista ) ( and ( predicado ( car lista )) ( for-all? predicado ( cdr lista ))))) La llamada recursiva comprueba que todos los elementos del resto de la lista cumplen el predicado y tambi\u00e9n lo debe cumplir el primer elemento. Una lista vac\u00eda cumple siempre devuelve #t (al no tener elementos, podemos decir que todos sus elementos cumplen el predicado). Funci\u00f3n foldr Veamos ahora la funci\u00f3n (foldr combina base lista) que permite recorrer una lista aplicando una funci\u00f3n binaria de forma acumulativa a sus elementos y devolviendo un \u00fanico valor como resultado. 1 (foldr combina base lista) -> valor El nombre fold significa plegado , indicando que la lista a la que se aplica se va \"plegando\" y al final se devuelve un \u00fanico resultado. El plegado lo realiza la funci\u00f3n de plegado (combina dato resultado) , que recibe un dato de la lista y lo acumula con el otro par\u00e1metro resultado (al que debemos dar un valor inicial y es el par\u00e1metro base de la funci\u00f3n foldr ). 1 (combina dato resultado) -> resultado La funci\u00f3n combina se aplica a los elementos de la lista de derecha a izquierda , empezando por el \u00faltimo elemento de la lista y el valor inicial base y aplic\u00e1ndose sucesivamente a los resultados que se van obteniendo. Veamos un ejemplo. Supongamos que la funci\u00f3n de plegado es una funci\u00f3n que suma el dato que viene de la lista con el valor acumulado: 1 2 ( define ( suma dato resultado ) ( + dato resultado )) Llamamos a los par\u00e1metros dato y resultado para remarcar que el primer par\u00e1metro se va a coger de la lista y el segundo del resultado calculado. Veamos qu\u00e9 pasa cuando hacemos un foldr con esta funci\u00f3n suma y la lista '(1 2 3) y con el n\u00famero 0 como base: 1 ( foldr suma 0 ' ( 1 2 3 )) ; \u21d2 6 La funci\u00f3n suma se va a ir aplicando a todos los elementos de la lista de derecha a izquierda , empezando por el valor base (0) y el \u00faltimo elemento de la lista (3) y cogiendo el resultado obtenido y utiliz\u00e1ndolo como nuevo par\u00e1metro resultado en la siguiente llamada. En concreto, la secuencia de llamadas a la funci\u00f3n suma ser\u00e1n las siguientes: 1 2 3 ( suma 3 0 ) ; \u21d2 3 ( suma 2 3 ) ; \u21d2 5 ( suma 1 5 ) ; \u21d2 6 Otro ejemplo de uso: 1 ( foldr string-append \"****\" ' ( \"hola\" \"que\" \"tal\" )) ; \u21d2 \"holaquetal****\" En este caso la secuencia de llamadas a string-append que se van a producir son: 1 2 3 ( string-append \"tal\" \"****\" ) ; \u21d2 \"tal****\" ( string-append \"que\" \"tal****\" ) ; \u21d2 \"quetal****\" ( string-append \"hola\" \"quetal****\" ) ; \u21d2 \"holaquetal****\" Otros ejemplos: 1 2 ( foldr ( lambda ( x y ) ( * x y )) 1 ' ( 1 2 3 4 5 6 7 8 )) ; \u21d2 40320 ( foldr cons ' () ' ( 1 2 3 4 )) ; \u21d2 (1 2 3 4) Un \u00faltimo ejemplo: 1 2 3 4 5 ( define ( suma-parejas lista-parejas ) ( foldr ( lambda ( pareja resultado ) ( + ( car pareja ) ( cdr pareja ) resultado )) 0 lista-parejas )) ( suma-parejas ( list ( cons 3 6 ) ( cons 2 9 ) ( cons -1 8 ) ( cons 9 3 ))) ; \u21d2 39 Implementaci\u00f3n de foldr Podemos implementar de forma recursiva la funci\u00f3n foldr : 1 2 3 4 ( define ( mi-foldr func base lista ) ( if ( null? lista ) base ( func ( car lista ) ( mi-foldr func base ( cdr lista ))))) Funci\u00f3n foldl La funci\u00f3n (foldl combina base lista) ( fold left ) es similar a foldr con la diferencia de que la secuencia de aplicaciones de la funci\u00f3n de plegado se hace de izquierda a derecha en lugar de derecha a izquierda. El perfil de la funci\u00f3n de plegado es el mismo que en foldr : 1 (func dato resultado) -> resultado Por ejemplo, si la funci\u00f3n de combinaci\u00f3n es string-append : 1 2 ( foldl string-append \"****\" ' ( \"hola\" \"que\" \"tal\" )) ; \u21d2 \"talquehola****\" La secuencia de llamadas a string-append es: 1 2 3 ( string-append \"hola\" \"****\" ) ; \u21d2 \"hola****\" ( string-append \"que\" \"hola****\" ) ; \u21d2 \"quehola****\" ( string-append \"tal\" \"quehola****\" ) ; \u21d2 \"talquehola****\" Otro ejemplo: 1 ( foldl cons ' () ' ( 1 2 3 4 )) ; \u21d2 (4 3 2 1) La implementaci\u00f3n de foldl la veremos cuando hablemos de recursi\u00f3n por la cola ( tail recursion ) en el pr\u00f3ximo tema. Consejo Las funciones foldr o foldl reciben una lista de datos y devuelven un \u00fanico resultado. Funciones recursivas con FOS y expresiones lambda El uso de funciones de orden superior (FOS) y expresiones lambda proporciona much\u00edsima expresividad en un lenguaje de programaci\u00f3n. Es posible escribir c\u00f3digo muy conciso y construir funciones recursivas que trabajan sobre listas sin usar la recursividad de forma expl\u00edcita. Funci\u00f3n (suma-n n lista) Supongamos que queremos definir una funci\u00f3n (suma-n n lista) que devuelve la lista resultante el resultado de sumar un n\u00famero n a todos los elementos de una lista. Podemos hacerlo de forma recursiva: 1 2 3 4 5 ( define ( suma-n n lista ) ( if ( null? lista ) ' () ( cons ( + ( car lista ) n ) ( suma-n n ( cdr lista ))))) Funciona de la siguiente manera: 1 ( suma-n 10 ' ( 1 2 3 4 )) ; \u21d2 (11 12 13 14) Implementacion con map Pero si utilizamos funciones de orden superior, podemos implementar la misma funci\u00f3n de una forma mucho m\u00e1s concisa y expresiva. Lo podemos hacer utilizando la funci\u00f3n de orden superior map y una expresi\u00f3n lambda que sume el n\u00famero n a los elementos de la lista: 1 2 ( define ( suma-n n lista ) ( map ( lambda ( x ) ( + x n )) lista )) Vemos que utilizamos el par\u00e1metro n en el cuerpo de la expresi\u00f3n lambda. De esta forma la funci\u00f3n que se aplica a los elementos de la lista es una funci\u00f3n que suma este n\u00famero a cada elemento. La variable x en el par\u00e1metro de la expresi\u00f3n lambda es la que va tomando el valor de los elementos de la lista. 1 2 (suma-n 10 '(1 2 3 4) 10) => (map #<prodedure-que-suma-10-a-x> (1 2 3 4)) = (11 12 13 14) Composici\u00f3n de funciones de orden superior Dado que muchas de las anteriores funciones de orden superior devuelven listas, es muy com\u00fan componer las llamadas, de forma que la salida de funci\u00f3n se utilice como entrada de otra. Por ejemplo, podemos implementar una funci\u00f3n que sume un n\u00famero n a todos los elementos de una lista (igual que la anterior) y despu\u00e9s que sume todos los elementos resultantes. Lo podr\u00edamos hacer reutilizando el c\u00f3digo del ejemplo anterior, y a\u00f1adiendo una llamada a foldr para que haga la suma: 1 2 3 ( define ( suma-n-total n lista ) ( foldr + 0 ( map ( lambda ( x ) ( + x n )) lista ))) Funcionar\u00eda de la siguiente forma: 1 ( suma-n-total 100 ' ( 1 2 3 4 )) ; \u21d2 410 Otro ejemplo. Supongamos que tenemos una lista de parejas de n\u00fameros y queremos contar aquellas parejas cuya suma de ambos n\u00fameros es mayor que un umbral (por ejemplo, 10). 1 2 3 4 5 ( define lista-parejas ( list ( cons 1 2 ) ( cons 3 8 ) ( cons 2 3 ) ( cons 9 6 ))) ( cuenta-mayores-que 10 lista-parejas ) ; \u21d2 2 Se podr\u00eda implementar de una forma muy concisa componiendo una llamada a map para realizar la suma de cada pareja junto con una llamada a filter que compruebe que el resultado sea mayor de n . Y al final llamamos a length para contar la longitud de la lista resultante: 1 2 3 4 5 ( define ( cuenta-mayores-que n lista-parejas ) ( length ( filter ( lambda ( x ) ( > x n )) ( map ( lambda ( pareja ) ( + ( car pareja ) ( cdr pareja ))) lista-parejas )))) Funci\u00f3n (contienen-letra caracter lista-pal) Veamos otro ejemplo. Supongamos que queremos definir la funci\u00f3n (contienen-letra caracter lista-pal) que devuelve las palabras de una lista que contienen un determinado car\u00e1cter. Por ejemplo: 1 2 ( contienen-letra #\\a ' ( \"En\" \"un\" \"lugar\" \"de\" \"la\" \"Mancha\" )) ; \u21d2 (\"lugar\" \"la\" \"Mancha\") Podemos implementar contienen-letra usando la funci\u00f3n de orden superior filter , con una expresi\u00f3n lambda que se aplicar\u00e1 a cada una de las palabras de la lista para comprobar si la palabra contiene el car\u00e1cter: 1 2 3 ( define ( contienen-letra caracter lista-pal ) ( filter ( lambda ( pal ) ( letra-en-pal? caracter pal )) lista-pal )) El par\u00e1metro pal de la expresi\u00f3n lambda ir\u00e1 cogiendo el valor de todas las palabras de lista-pal y la funci\u00f3n (letra-en-pal? caracter pal) comprobar\u00e1 si la cadena contiene el car\u00e1cter. La funci\u00f3n (letra-en-pal? caracter pal) es una funci\u00f3n auxiliar que tenemos que implementar. Por ejemplo: 1 2 ( letra-en-pal? #\\a \"Hola\" ) ; \u21d2 #t ( letra-en-pal? #\\a \"Pepe\" ) ; \u21d2 #f La podemos implementar de una forma muy elegante obteniendo una lista de caracteres a partir de la cadena y usando la funci\u00f3n de orden superior exists? : 1 2 3 ( define ( letra-en-pal? caracter palabra ) ( exists? ( lambda ( c ) ( equal? c caracter )) ( string->list palabra ))) Funci\u00f3n divisores Un \u00faltimo ejemplo en el que implementamos la funci\u00f3n (divisores n) utilizando una funci\u00f3n de orden superior. Suponemos que tenemos definidas las funciones (numeros-hasta n) y (divisor? x n) : 1 2 3 4 5 6 7 ( define ( numeros-hasta n ) ( if ( = 0 n ) ' () ( cons n ( numeros-hasta ( - n 1 ))))) ( define ( divisor? x n ) ( = 0 ( mod n x ))) Entonces la funci\u00f3n (divisores n) se implementar\u00eda de la siguiente forma: 1 2 3 ( define ( divisores n ) ( filter ( lambda ( x ) ( divisor? x n )) ( numeros-hasta n ))) Bibliograf\u00eda - SICP \u00b6 En este tema hemos explicado conceptos de los siguientes cap\u00edtulos del libro Structure and Intepretation of Computer Programs : 1.1.1 - Expressions 1.1.2 - Naming and environment 1.1.3 - Evaluating combinations 1.1.4 - Compound procedures 1.1.5 - The Substitution Model for Procedure Application 1.1.6 - Conditional Expressions and Predicates 1.3 - Formulating Abstractions with Higher-Order Procedures 2.2 - Hierarchical Data and the Closure Property (Introducci\u00f3n de la secci\u00f3n) 2.2.1 - Representing Sequences 2.3.1 - Quotation Lenguajes y Paradigmas de Programaci\u00f3n, curso 2019-20 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Domingo Gallardo, Cristina Pomares, Antonio Bot\u00eda, Francisco Mart\u00ednez","title":"Tema 2: Programaci\u00f3n funcional"},{"location":"teoria/tema02-programacion-funcional/tema02-programacion-funcional.html#tema-2-programacion-funcional","text":"","title":"Tema 2: Programaci\u00f3n funcional"},{"location":"teoria/tema02-programacion-funcional/tema02-programacion-funcional.html#el-paradigma-de-programacion-funcional","text":"","title":"El paradigma de Programaci\u00f3n Funcional"},{"location":"teoria/tema02-programacion-funcional/tema02-programacion-funcional.html#pasado-y-presente-del-paradigma-funcional","text":"","title":"Pasado y presente del paradigma funcional"},{"location":"teoria/tema02-programacion-funcional/tema02-programacion-funcional.html#evaluacion-de-expresiones-y-definicion-de-funciones","text":"En la asignatura usaremos Scheme como primer lenguaje en el que exploraremos la programaci\u00f3n funcional. En el seminario de Scheme que se imparte en pr\u00e1cticas se estudiar\u00e1 en m\u00e1s profundidad los conceptos m\u00e1s importantes del lenguaje: tipos de datos, operadores, estructuras de control, int\u00e9rprete, etc.","title":"Evaluaci\u00f3n de expresiones y definici\u00f3n de funciones"},{"location":"teoria/tema02-programacion-funcional/tema02-programacion-funcional.html#programacion-declarativa-vs-imperativa","text":"Hemos dicho que la programaci\u00f3n funcional es un estilo de programaci\u00f3n declarativa, frente a la programaci\u00f3n tradicional de los lenguajes denominados imperativos. Vamos a explicar esto un poco m\u00e1s.","title":"Programaci\u00f3n declarativa vs. imperativa"},{"location":"teoria/tema02-programacion-funcional/tema02-programacion-funcional.html#modelo-de-computacion-de-sustitucion","text":"Un modelo computacional es un formalismo (conjunto de reglas) que definen el funcionamiento de un programa. En el caso de los lenguajes funcionales basados en la evaluaci\u00f3n de expresiones, el modelo computacional define cu\u00e1l ser\u00e1 el resultado de evaluar una expresi\u00f3n. El modelo de sustituci\u00f3n es un modelo muy sencillo que permite definir la sem\u00e1ntica de la evaluaci\u00f3n de expresiones en lenguajes funcionales como Scheme. Se basa en una versi\u00f3n simplificada de la regla de reducci\u00f3n del c\u00e1lculo lambda. Es un modelo basado en la reescritura de unos t\u00e9rminos por otros. Aunque se trata de un modelo abstracto, ser\u00eda posible escribir un int\u00e9rprete que, bas\u00e1ndose en este modelo, eval\u00fae expresiones funcionales. Supongamos un conjunto de definiciones en Scheme: 1 2 3 4 5 6 7 8 9 10 ( define ( doble x ) ( + x x )) ( define ( cuadrado y ) ( * y y )) ( define ( f z ) ( + ( cuadrado ( doble z )) 1 )) ( define a 2 ) Supongamos que, una vez realizadas esas definiciones, se eval\u00faa la siguiente expresi\u00f3n: 1 ( f ( + a 1 )) \u00bfCu\u00e1l ser\u00e1 su resultado? Si lo hacemos de forma intuitiva podemos pensar que 37 . Si lo comprobamos en el int\u00e9rprete de Scheme veremos que devuelve 37. \u00bfHemos seguido algunas reglas espec\u00edficas? \u00bfQu\u00e9 reglas son las que sigue el int\u00e9rprete? \u00bfPodr\u00edamos implementar nosotros un int\u00e9rprete similar? S\u00ed, usando las reglas del modelo de sustituci\u00f3n. El modelo de sustituci\u00f3n define cuatro reglas sencillas para evaluar una expresi\u00f3n. Llamemos a la expresi\u00f3n e . Las reglas son las siguientes: Si e es un valor primitivo (por ejemplo, un n\u00famero), devolvemos ese mismo valor. Si e es un identificador, devolvemos su valor asociado con un define (se lanzar\u00e1 un error si no existe ese valor). Si e es una expresi\u00f3n del tipo (f arg1 ... argn) , donde f es el nombre de una funci\u00f3n primitiva ( + , - , ...), evaluamos uno a uno los argumentos arg1 ... argn (con estas mismas reglas) y evaluamos la funci\u00f3n primitiva con los resultados. La regla 4 tiene dos variantes, dependiendo del orden de evaluaci\u00f3n que utilizamos. Orden aplicativo Si e es una expresi\u00f3n del tipo (f arg1 ... argn) , donde f es el nombre de una funci\u00f3n definida con un define , tenemos que evaluar primero los argumentos arg1 ... argn y despu\u00e9s sustituir f por su cuerpo , reemplazando cada par\u00e1metro formal de la funci\u00f3n por el correspondiente argumento evaluado . Despu\u00e9s evaluaremos la expresi\u00f3n resultante usando estas mismas reglas. Orden normal Si e es una expresi\u00f3n del tipo (f arg1 ... argn) , donde f es el nombre de una funci\u00f3n definida con un define , tenemos que sustituir f por su cuerpo , reemplazando cada par\u00e1metro formal de la funci\u00f3n por el correspondiente argumento sin evaluar . Despu\u00e9s evaluar la expresi\u00f3n resultante usando estas mismas reglas. En el orden aplicativo se realizan las evaluaciones antes de realizar las sustituciones, lo que define una evaluaci\u00f3n de dentro a fuera de los par\u00e9ntesis. Cuando se llega a una expresi\u00f3n primitiva se eval\u00faa. En el orden normal se realizan todas las sustituciones hasta que se tiene una larga expresi\u00f3n formada por expresiones primitivas; se eval\u00faa entonces. Ambas formas de evaluaci\u00f3n dar\u00e1n el mismo resultado en programaci\u00f3n funcional. Scheme utiliza el orden aplicativo.","title":"Modelo de computaci\u00f3n de sustituci\u00f3n"},{"location":"teoria/tema02-programacion-funcional/tema02-programacion-funcional.html#scheme-como-lenguaje-de-programacion-funcional","text":"Ya hemos visto c\u00f3mo definir funciones y evaluar expresiones en Scheme. Vamos continuar con ejemplos concretos de otras caracter\u00edsticas funcionales caracter\u00edsticas funcionales de Scheme. En concreto, veremos: S\u00edmbolos y primitiva quote Uso de listas Definici\u00f3n de funciones recursivas en Scheme","title":"Scheme como lenguaje de programaci\u00f3n funcional"},{"location":"teoria/tema02-programacion-funcional/tema02-programacion-funcional.html#funciones-y-formas-especiales","text":"En el seminario de Scheme hemos visto un conjunto de primitivas que podemos utilizar en Scheme. Podemos clasificar las primitivas en funciones y formas especiales . Las funciones se eval\u00faan usando el modelo de sustituci\u00f3n aplicativo ya visto: Primero se eval\u00faan los argumentos y despu\u00e9s se sustituye la llamada a la funci\u00f3n por su cuerpo y se vuelve a evaluar la expresi\u00f3n resultante. Las expresiones siempre se eval\u00faan desde los par\u00e9ntesis interiores a los exteriores. Las formas especiales son expresiones primitivas de Scheme que tienen una forma de evaluarse propia, distinta de las funciones.","title":"Funciones y formas especiales"},{"location":"teoria/tema02-programacion-funcional/tema02-programacion-funcional.html#formas-especiales-en-scheme-define-if-cond","text":"Veamos la forma de evaluar las distintas formas especiales en Scheme. En estas formas especiales no se aplica el modelo de sustituci\u00f3n, al no ser invocaciones de funciones, sino que cada una se eval\u00faa de una forma diferente.","title":"Formas especiales en Scheme: define, if, cond"},{"location":"teoria/tema02-programacion-funcional/tema02-programacion-funcional.html#forma-especial-quote-y-simbolos","text":"Sintaxis 1 ( quote <identificador> ) Evaluaci\u00f3n Se devuelve el identificador sin evaluar (un s\u00edmbolo). Se abrevia en con el car\u00e1cter ' . Ejemplos 1 2 ( quote x ) ; el s\u00edmbolo x ' hola ; el s\u00edmbolo hola A diferencia de los lenguajes imperativos, Scheme trata a los identificadores (nombres que se les da a las variables) como datos del lenguaje de tipo symbol . En el paradigma funcional a los identificadores se les denomina s\u00edmbolos . Los s\u00edmbolos son distintos de las cadenas. Una cadena es un tipo de dato compuesto y se guardan en memoria todos y cada uno de los caracteres que la forman. Sin embargo, los s\u00edmbolos son tipos at\u00f3micos, que se representan en memoria con un \u00fanico valor determinado por el c\u00f3digo hash del identificador. Ejemplos de funciones Scheme con s\u00edmbolos: 1 2 3 4 5 6 7 8 9 10 11 12 13 ( define x 12 ) ( symbol? ' x ) ; \u21d2 #t ( symbol? x ) ; \u21d2 #f \u00bfPor qu\u00e9? ( symbol? ' hola-que<> ) ( symbol->string ' hola-que<> ) ' ma\u00f1ana ' l\u00e1piz ; aunque sea posible, no vamos a usar acentos en los s\u00edmbolos ; pero s\u00ed en los comentarios ( symbol? \"hola\" ) ; #f ( symbol? #f ) ; #f ( symbol? ( car ' ( hola c\u00f3mo est\u00e1s ))) ; #t ( equal? ' hola ' hola ) ( equal? ' hola \"hola\" ) Como hemos visto anteriormente, un s\u00edmbolo puede asociarse o ligarse ( bind ) a un valor (cualquier dato de primera clase ) con la forma especial define . 1 ( define pi 3.14159 ) Nota No es correcto escribir (define 'pi 3.14156) porque la forma especial define debe recibir un identificador sin quote . Cuando escribimos un s\u00edmbolo en el prompt de Scheme el int\u00e9rprete lo eval\u00faa y devuelve su valor: 1 2 > pi 3.14159 Los nombres de las funciones ( equal? , sin , + , ...) son tambi\u00e9n s\u00edmbolos y Scheme tambi\u00e9n los eval\u00faa (en un par de semanas hablaremos de las funciones como objetos primitivos en Scheme): 1 2 3 4 5 6 7 > sin #<procedure:sin> > + #<procedure:+> > (define (cuadrado x) (* x x)) > cuadrado #<procedure:cuadrado> Los s\u00edmbolos son tipos primitivos del lenguaje: pueden pasarse como par\u00e1metros o ligarse a variables. 1 2 3 > (define x 'hola) > x hola","title":"Forma especial quote y s\u00edmbolos"},{"location":"teoria/tema02-programacion-funcional/tema02-programacion-funcional.html#forma-expecial-quote-con-expresiones","text":"Sintaxis 1 ( quote <expresi\u00f3n> ) Evaluaci\u00f3n Si quote recibe una expresi\u00f3n correcta de Scheme (una expresi\u00f3n entre par\u00e9ntesis) se devuelve la lista o pareja pareja definida por la expresi\u00f3n (sin evaluar sus elementos). Ejemplos 1 2 3 4 5 6 7 ' ( 1 2 3 ) ; \u21d2 (1 2 3) Una lista ' ( + 1 2 3 4 ) ; La lista formada por el s\u00edmbolo + y los n\u00fameros 1 2 3 4 ( quote ( 1 2 3 4 )) ; La lista formada por los n\u00fameros 1 2 3 4 ' ( a b c ) ; \u21d2 La lista con los s\u00edmbolos a, b, y c ' ( * ( + 1 ( + 2 3 )) 5 ) ; Una lista con 3 elementos, el segundo de ellos otra lista ' ( 1 . 2 ) ; \u21d2 La pareja (1 . 2) ' (( 1 . 2 ) ( 2 . 3 )) ; \u21d2 Una lista con las parejas (1 . 2) y (2 . 3)","title":"Forma expecial quote con expresiones"},{"location":"teoria/tema02-programacion-funcional/tema02-programacion-funcional.html#listas","text":"Otra de las caracter\u00edsticas fundamentales del paradigma funcional es la utilizaci\u00f3n de listas. Ya hemos visto en el seminario de Scheme las funciones m\u00e1s importantes para trabajar con ellas. Vamos a repasarlas de nuevo en este apartado, antes de ver alg\u00fan ejemplo de c\u00f3mo usar la recursi\u00f3n con listas. Ya hemos visto en dicho seminario que Scheme es un lenguaje d\u00e9bilmente tipado. Una variable o par\u00e1metro no se declara de un tipo y puede contener cualquier valor. Sucede igual con las listas: una lista en Scheme puede contener cualquier valor, incluyendo otras listas.","title":"Listas"},{"location":"teoria/tema02-programacion-funcional/tema02-programacion-funcional.html#recursion","text":"Otra caracter\u00edstica fundamental de la programaci\u00f3n funcional es la no existencia de bucles. Un bucle implica la utilizaci\u00f3n de pasos de ejecuci\u00f3n en el programa y esto es caracter\u00edstico de la programaci\u00f3n imperativa. En programaci\u00f3n funcional las iteraciones se realizan con recursi\u00f3n.","title":"Recursi\u00f3n"},{"location":"teoria/tema02-programacion-funcional/tema02-programacion-funcional.html#recursion-y-listas","text":"La utilizaci\u00f3n de la recursi\u00f3n es muy \u00fatil para trabajar con estructuras secuenciales, como listas. Vamos a empezar viendo unos sencillos ejemplos y m\u00e1s adelante veremos algunos m\u00e1s complicadas.","title":"Recursi\u00f3n y listas"},{"location":"teoria/tema02-programacion-funcional/tema02-programacion-funcional.html#tipos-de-datos-compuestos-en-scheme","text":"","title":"Tipos de datos compuestos en Scheme"},{"location":"teoria/tema02-programacion-funcional/tema02-programacion-funcional.html#el-tipo-de-dato-pareja","text":"","title":"El tipo de dato pareja"},{"location":"teoria/tema02-programacion-funcional/tema02-programacion-funcional.html#las-parejas-son-objetos-de-primera-clase","text":"En un lenguaje de programaci\u00f3n un elemento es de primera clase cuando puede: Asignarse a variables Pasarse como argumento Devolverse por una funci\u00f3n Guardarse en una estructura de datos mayor Las parejas son objetos de primera clase. Una pareja puede asignarse a una variable: 1 2 ( define p1 ( cons 1 2 )) ( define p2 ( cons #f \"hola\" )) Una pareja puede pasarse como argumento y devolverse en una funci\u00f3n: 1 2 3 4 5 ( define ( suma-parejas p1 p2 ) ( cons ( + ( car p1 ) ( car p2 )) ( + ( cdr p1 ) ( cdr p2 )))) ( suma-parejas ' ( 1 . 5 ) ' ( 4 . 12 )) ; \u21d2 (5 . 17) Una vez definida esta funci\u00f3n suma-parejas podr\u00edamos ampliar la funci\u00f3n suma que vimos previamente con este nuevo tipo de datos: 1 2 3 4 5 6 ( define ( suma x y ) ( cond (( and ( number? x ) ( number? y )) ( + x y )) (( and ( string? x ) ( string? y )) ( string-append x y )) (( and ( pair? x ) ( pair? y )) ( suma-parejas p1 p2 )) ( else ' error ))) Y, por \u00faltimo, las parejas pueden formar parte de otras parejas . Es lo que se denomina la propiedad de clausura de la funci\u00f3n cons : el resultado de un cons puede usarse como par\u00e1metro de nuevas llamadas a cons . Ejemplo: 1 2 3 ( define p1 ( cons 1 2 )) ( define p2 ( cons 3 4 )) ( define p ( cons p1 p2 )) Expresi\u00f3n equivalente: 1 2 ( define p ( cons ( cons 1 2 ) ( cons 3 4 ))) Podr\u00edamos representar esta estructura as\u00ed: Propiedad de clausura: las parejas pueden contener parejas Pero se har\u00eda muy complicado representar muchos niveles de anidamiento. Por eso utilizamos la siguiente representaci\u00f3n: Llamamos a estos diagramas diagramas caja-y-puntero ( box-and-pointer en ingl\u00e9s).","title":"Las parejas son objetos de primera clase"},{"location":"teoria/tema02-programacion-funcional/tema02-programacion-funcional.html#diagramas-caja-y-puntero","text":"Al escribir expresiones complicadas con cons anidados es conveniente para mejorar su legibilidad utilizar el siguiente formato: 1 2 3 ( define p ( cons ( cons 1 ( cons 3 4 )) 2 )) Para entender la construcci\u00f3n de estas estructuras es importante recordar que las expresiones se eval\u00faan de dentro a afuera . \u00bfQu\u00e9 figura representar\u00eda la estructura anterior? Soluci\u00f3n: Es importante tener en cuenta que cada caja del diagrama representa una pareja creada en la memoria del int\u00e9rprete con la instrucci\u00f3n cons y que el resultado de evaluar una variable en la que se ha guardado una pareja devuelve la pareja reci\u00e9n creada. Por ejemplo, si el int\u00e9rprete eval\u00faa p despu\u00e9s de haber hecho la sentencia anterior devuelve la pareja contenida en p , no se crea una pareja nueva. Por ejemplo, si despu\u00e9s de haber evaluado la sentencia anterior evaluamos la siguiente: 1 ( define p2 ( cons 5 ( cons p 6 ))) El diagrama caja y puntero resultante ser\u00eda el siguiente: Vemos que en la pareja que se crea con (cons p 6) se guarda en la parte izquierda la misma pareja que hay en p . Lo representamos con una flecha que apunta a la misma pareja que p . Nota El funcionamiento de la evaluaci\u00f3n de variables que contienen parejas es similar al de las variables que contienen objetos en lenguajes orientados a objetos como Java. Cuando se eval\u00faa una variable que contiene una pareja se devuelve la propia pareja, no una copia. En programaci\u00f3n funcional, como el contenido de las parejas es inmutable, no hay problemas de efectos laterales por el hecho de que una pareja est\u00e9 compartida. Es conveniente que pruebes a crear distintas estructuras de parejas con parejas y a dibujar su diagrama caja y puntero. Y tambi\u00e9n a recuperar un determinado dato (pareja o dato at\u00f3mico) una vez creada la estructura. La siguiente funci\u00f3n print-pareja puede ser \u00fatil a la hora de mostrar por pantalla los elementos de una pareja 1 2 3 4 5 6 7 8 9 10 11 12 13 14 ( define ( print-pareja pareja ) ( if ( pair? pareja ) ( begin ( display \"(\" ) ( print-dato ( car pareja )) ( display \" . \" ) ( print-dato ( cdr pareja )) ( display \")\" )) ( display \"\" ))) ( define ( print-dato dato ) ( if ( pair? dato ) ( print-pareja dato ) ( display dato ))) \u00a1Cuidado! La funci\u00f3n anterior contiene pasos de ejecuci\u00f3n con sentencias como begin y llamadas a display dentro del c\u00f3digo de la funci\u00f3n. Estas sentencias son propias de la programaci\u00f3n imperativa. No hacerlo en programaci\u00f3n funcional .","title":"Diagramas caja-y-puntero"},{"location":"teoria/tema02-programacion-funcional/tema02-programacion-funcional.html#listas-en-scheme","text":"","title":"Listas en Scheme"},{"location":"teoria/tema02-programacion-funcional/tema02-programacion-funcional.html#implementacion-de-listas-en-scheme","text":"Recordemos que Scheme permite manejar listas como un tipo de datos b\u00e1sico. Hemos visto funciones para crear, a\u00f1adir y recorrer listas. Como repaso, podemos ver las siguientes expresiones. Fijaros que las funciones car , cdr y cons son exactamente las mismas funciones que las vistas anteriormente. \u00bfPor qu\u00e9? \u00bfQu\u00e9 relaci\u00f3n hay entre las parejas y las listas? Hagamos algunas pruebas, probando si los resultados son listas o parejas usando las funciones list? y pair? . Por ejemplo, una pareja formada por dos n\u00fameros es una pareja, pero no es una lista: 1 2 3 ( define p1 ( cons 1 2 )) ( pair? p1 ) ; \u21d2 #t ( list? p1 ) ; \u21d2 #f Y una lista vac\u00eda es una lista, pero no es una pareja: 1 2 ( list? ' ()) ; \u21d2 #t ( pair? ' ()) ; \u21d2 #f \u00bfUna lista es una pareja? Pues s\u00ed: 1 2 3 ( define lista ' ( 1 2 3 )) ( list? lista ) ; \u21d2 #t ( pair? lista ) ; \u21d2 #t Por \u00faltimo, una pareja con una lista vac\u00eda como segundo elemento es una pareja y una lista: 1 2 3 ( define p1 ( cons 1 ' ())) ( pair? p1 ) ; \u21d2 #t ( list? p1 ) ; \u21d2 #t Con estos ejemplos ya tenemos pistas para deducir la relaci\u00f3n entre listas y parejas en Scheme (y Lisp). Vamos a explicarlo.","title":"Implementaci\u00f3n de listas en Scheme"},{"location":"teoria/tema02-programacion-funcional/tema02-programacion-funcional.html#listas-con-elementos-compuestos","text":"Las listas pueden contener cualquier tipo de elementos, incluyendo otras parejas. La siguiente estructura se denomina lista de asociaci\u00f3n . Son listas cuyos elementos son parejas ( clave , valor ): 1 2 3 ( list ( cons ' a 1 ) ( cons ' b 2 ) ( cons ' c 3 )) ; \u21d2 ((a . 1) (b . 2) (c . 2)) \u00bfCu\u00e1l ser\u00eda el diagrama box and pointer de la estructura anterior? La expresi\u00f3n equivalente utilizando conses es: 1 2 3 4 ( cons ( cons ' a 1 ) ( cons ( cons ' b 2 ) ( cons ( cons ' c 3 ) ' ())))","title":"Listas con elementos compuestos"},{"location":"teoria/tema02-programacion-funcional/tema02-programacion-funcional.html#funciones-recursivas-que-construyen-listas","text":"Para terminar el apartado sobre las listas en Scheme vamos a ver ejemplos adicionales de funciones recursivas que trabajan con listas. Veremos alguna funci\u00f3n que recibe una lista y, como antes, usa la recursi\u00f3n para recorrerla. Pero veremos tambi\u00e9n funciones que usan la recursi\u00f3n para construir nuevas listas . Algunas de las funciones que presentamos son implementaciones de las ya existentes en Scheme. Para no solapar con las definiciones de Scheme pondremos el prefijo mi- en todas ellas. Vamos a ver las siguientes funciones: mi-list-ref : implementaci\u00f3n de la funci\u00f3n list-ref mi-list-tail : implementaci\u00f3n de la funci\u00f3n list-tail mi-append : implementaci\u00f3n de la funi\u00f3n append mi-reverse : implementaci\u00f3n de la funci\u00f3n reverse cuadrados-hasta : devuelve la lista de cuadrados hasta uno dado filtra-pares : devuelve la lista de los n\u00fameros pares de la lista que se recibe primo? : comprueba si un n\u00famero es o no primo","title":"Funciones recursivas que construyen listas"},{"location":"teoria/tema02-programacion-funcional/tema02-programacion-funcional.html#funciones-con-numero-variable-de-argumentos","text":"Hemos visto algunas funciones primitivas de Scheme, como + o max que admiten un n\u00famero variable de argumentos. \u00bfPodemos hacerlo tambi\u00e9n en funciones definidas por nosotros? La respuesta es s\u00ed, utilizando lo que se denomina notaci\u00f3n dotted-tail (punto-cola) para definir los par\u00e1metros de la funci\u00f3n. En esta notaci\u00f3n se coloca un punto antes del \u00faltimo par\u00e1metro. Los par\u00e1metros antes del punto (si existen) tendr\u00e1n como valores los argumentos usados en la llamada y el resto de argumentos se pasar\u00e1n en forma de lista en el \u00faltimo par\u00e1metro. Por ejemplo, si tenemos la definici\u00f3n 1 2 ( define ( funcion-dos-o-mas-args x y . lista-args ) <cuerpo> ) podemos llamar a la funci\u00f3n anterior con dos o m\u00e1s argumentos: 1 ( funcion-dos-o-mas-args 1 2 3 4 5 6 ) En la llamada, los par\u00e1metros x e y tomar\u00e1n los valores 1 y 2. El par\u00e1metro lista-args tomar\u00e1 como valor una lista con los argumentos restantes (3 4 5 6) . Tambi\u00e9n es posible permitir que todos los argumentos sean opcionales no poniendo ning\u00fan argumento antes del punto:: 1 2 ( define ( funcion-cualquier-numero-args . lista-args ) <cuerpo> ) Si hacemos la llamada 1 ( funcion-cualquier-numero-args 1 2 3 4 5 6 ) el par\u00e1metro lista-args tomar\u00e1 como valor la lista (1 2 3 4 5 6) . Veamos un sencillo ejemplo. Podemos implementar una funci\u00f3n mi-suma que tome al menos dos argumentos y despu\u00e9s un n\u00famero variable de argumentos y devuelva la suma de todos ellos. Es muy sencillo: recogemos todos los argumentos en la lista de argumentos variables y llamamos a la funci\u00f3n suma-lista que suma una lista de n\u00fameros: 1 2 3 4 ( define ( mi-suma x y . lista-nums ) ( if ( null? lista-nums ) ( + x y ) ( + x ( + y ( suma-lista lista-nums )))))","title":"Funciones con n\u00famero variable de argumentos"},{"location":"teoria/tema02-programacion-funcional/tema02-programacion-funcional.html#funcion-apply","text":"Con la funci\u00f3n (apply funcion lista) podemos aplicar una funci\u00f3n de aridad n a una lista de datos de n datos, haciendo que cada uno de los datos se pasen a la funci\u00f3n en orden como par\u00e1metros. Por ejemplo, podemos definir la funci\u00f3n (suma-cuadrados x y) de aridad 2 de la siguiente forma: 1 2 ( define ( suma-cuadrados x y ) ( + ( * x x ) ( * y y ))) Para invocar a suma-cuadrados hay que pasarle 2 par\u00e1metros: 1 ( suma-cuadrados 10 5 ) ; \u21d2 100 Podemos usar la funci\u00f3n apply para aplicar esta funci\u00f3n a los dos elementos de una lista: 1 ( apply suma-cuadrados ' ( 10 5 )) ; \u21d2 100 Usando apply podemos definir funciones recursivas con n\u00famero variable de argumentos. Por ejemplo la funci\u00f3n suma-parejas que suma un n\u00famero variable de parejas: 1 2 3 4 5 6 7 8 9 10 ( define ( suma-pareja p1 p2 ) ( cons ( + ( car p1 ) ( car p2 )) ( + ( cdr p1 ) ( cdr p2 )))) ( define ( suma-parejas . parejas ) ( if ( null? parejas ) ' ( 0 . 0 ) ( suma-pareja ( car parejas ) ( apply suma-parejas ( cdr parejas ))))) ( suma-parejas ' ( 1 . 2 ) ' ( 3 . 4 ) ' ( 5 . 6 )) ; \u21d2 '(9 . 12) Hay que hacer notar en que la llamada recursiva es necesario usar apply porque (cdr parejas) es una lista. No podemos invocar a suma-parejas pasando una lista como par\u00e1metro, sino que hay que pasarle todos los argumentos por separado (recibe un n\u00famero variable de argumentos). Eso lo conseguimos hacer con apply .","title":"Funci\u00f3n apply"},{"location":"teoria/tema02-programacion-funcional/tema02-programacion-funcional.html#funciones-como-tipos-de-datos-de-primera-clase","text":"Hemos visto que la caracter\u00edstica fundamental de la programaci\u00f3n funcional es la definici\u00f3n de funciones. Hemos visto tambi\u00e9n que no producen efectos laterales y no tienen estado. Una funci\u00f3n toma unos datos como entrada y produce un resultado como salida. Una de las caracter\u00edsticas fundamentales de la programaci\u00f3n funcional es considerar a las funciones como objetos de primera clase . Recordemos que un tipo de primera clase es aquel que: Puede ser asignado a una variable Puede ser pasado como argumento a una funci\u00f3n Puede ser devuelto como resultado de una invocaci\u00f3n a una funci\u00f3n Puede ser parte de un tipo mayor Vamos a ver que las funciones son ejemplos de todos los casos anteriores: vamos a poder crear funciones sin nombre y asignarlas a variables, pasarlas como par\u00e1metro de otras funciones, devolverlas como resultado de invocar a otra funci\u00f3n y guardarlas en tipos de datos compuestos como listas. La posibilidad de usar funciones como objetos de primera clase es una caracter\u00edstica fundamental de los lenguajes funcionales. Es una caracter\u00edstica de muchos lenguajes multi-paradigma con caracter\u00edsticas funcionales como JavaScript , Python , Swift o a partir de la versi\u00f3n 8 de Java, Java 8 , (donde se denominan expresiones lambda ).","title":"Funciones como tipos de datos de primera clase"},{"location":"teoria/tema02-programacion-funcional/tema02-programacion-funcional.html#forma-especial-lambda","text":"Vamos a empezar explicando la forma especial lambda de Scheme, que nos permite crear funciones an\u00f3nimas en tiempo de ejecuci\u00f3n. De la misma forma que podemos usar cadenas o enteros sin darles un nombre, en Scheme es posible usar una funci\u00f3n sin darle un nombre mediante esta forma especial.","title":"Forma especial lambda"},{"location":"teoria/tema02-programacion-funcional/tema02-programacion-funcional.html#funciones-argumentos-de-otras-funciones","text":"Hemos visto ya un ejemplo de c\u00f3mo pasar una funci\u00f3n como par\u00e1metro de otra. Veamos alg\u00fan otro. Por ejemplo, podemos definir la funci\u00f3n aplica que recibe una funci\u00f3n en el par\u00e1metro func y dos valores en los par\u00e1metros x e y y devuelve el resultado de invocar a la funci\u00f3n que pasamos como par\u00e1metro con x e y . La funci\u00f3n que se pase como par\u00e1metro debe tener dos argumentos Para realizar la invocaci\u00f3n a la funci\u00f3n que se pasa como par\u00e1metro basta con usar func como su nombre. La funci\u00f3n se ha ligado al nombre func en el momento de la invocaci\u00f3n a aplica , de la misma forma que los argumentos se ligan a los par\u00e1metros x e y : 1 2 ( define ( aplica f x y ) ( f x y )) Algunos ejemplos de invocaci\u00f3n, usando funciones primitivas, funciones definidas y expresiones lambda: 1 2 3 4 5 6 7 8 9 10 ( aplica + 2 3 ) ; \u21d2 5 ( aplica * 4 5 ) ; \u21d2 10 ( aplica string-append \"hola\" \"adios\" ) ; \u21d2 \"holaadios\" ( define ( string-append-con-guion s1 s2 ) ( string-append s1 \"-\" s2 )) ( aplica string-append-con-guion \"hola\" \"adios\" ) ; \u21d2 \"hola-adios\" ( aplica ( lambda ( x y ) ( sqrt ( + ( * x x ) ( * y y )))) 3 4 ) ; \u21d2 5 Otro ejemplo, la funci\u00f3n aplica-2 que toma dos funciones f y g y un argumento x y devuelve el resultado de aplicar f a lo que devuelve la invocaci\u00f3n de g con x : 1 2 3 4 5 6 7 8 ( define ( aplica-2 f g x ) ( f ( g x ))) ( define ( suma-5 x ) ( + x 5 )) ( define ( doble x ) ( + x x )) ( aplica-2 suma-5 doble 3 ) ; \u21d2 11","title":"Funciones argumentos de otras funciones"},{"location":"teoria/tema02-programacion-funcional/tema02-programacion-funcional.html#generalizacion","text":"La posibilidad de pasar funciones como par\u00e1metros de otras es una poderosa herramienta de abstracci\u00f3n. Nos va a permitir dise\u00f1ar funciones m\u00e1s gen\u00e9ricas. Veamos un ejemplo. Supongamos que queremos calcular el sumatorio de a hasta b : 1 2 3 4 5 6 ( define ( sum-x a b ) ( if ( > a b ) 0 ( + a ( sum-x ( + a 1 ) b )))) ( sum-x 1 10 ) ; \u21d2 55 Supongamos ahora que queremos calcular el sumatorio de a hasta b sumando los n\u00fameros al cuadrado: 1 2 3 4 5 6 ( define ( sum-cuadrado-x a b ) ( if ( > a b ) 0 ( + ( * a a ) ( sum-cuadrado-x ( + a 1 ) b )))) ( sum-cuadrado-x 1 10 ) ; \u21d2 385 Y el sumatorio de a hasta b sumando los cubos: 1 2 3 4 5 6 ( define ( sum-cubo-x a b ) ( if ( > a b ) 0 ( + ( * a a a ) ( sum-cubo-x ( + a 1 ) b )))) ( sum-cubo-x 1 10 ) ; \u21d2 3025 Vemos que el c\u00f3digo de las tres funciones anteriores es muy similar, cada funci\u00f3n la podemos obtener haciendo un copy-paste de otra previa. Lo \u00fanico que cambia es la funci\u00f3n a aplicar a cada n\u00famero de la serie. Siempre que hagamos copy-paste al programar tenemos que empezar a sospechar que no estamos generalizando suficientemente el c\u00f3digo. Un copy-paste arrastra tambi\u00e9n bugs y obliga a realizar m\u00faltiples modificaciones del c\u00f3digo cuando en el futuro tengamos que cambiar cosas. La posibilidad de pasar una funci\u00f3n como par\u00e1metro viene a nuestra ayuda para generalizar el c\u00f3digo anterior. En este caso, lo \u00fanico que cambia en las tres funciones anteriores es la funci\u00f3n a aplicar a los n\u00fameros de la serie. En primer caso no se hace nada, en el segundo se eleva al cuadrado y en el tercer caso al cubo. Podemos tomar esa funci\u00f3n como un par\u00e1metro adicional y definir una funci\u00f3n gen\u00e9rica sum-f-x que generaliza las tres funciones anteriores. Tendr\u00edamos el sumatorio desde a hasta b de f(x) : 1 2 3 4 ( define ( sum-f-x f a b ) ( if ( > a b ) 0 ( + ( f a ) ( sum-f-x f ( + a 1 ) b )))) Las funciones anteriores son casos particulares de esta funci\u00f3n que las generaliza. Por ejemplo, para calcular el sumatorio desde 1 hasta 10 de x al cubo: 1 2 3 4 ( define ( cubo x ) ( * x x x )) ( sum-f-x cubo 1 10 ) ; \u21d2 3025 Tambi\u00e9n podemos utilizar una expresi\u00f3n lambda en la invocaci\u00f3n a sum-f que construya la funci\u00f3n que queremos aplicar a cada n\u00famero. Por ejemplo, podemos sumar la expresi\u00f3n (n/(n-1)) para todos los n\u00fameros del 2 al 100: 1 ( sum-f-x ( lambda ( n ) ( / n ( - n 1 ))) 2 100 ) Veremos m\u00e1s adelante muchos m\u00e1s ejemplos de funciones pasadas como par\u00e1metros y de la generalidad que permite este patr\u00f3n, cuando estudiemos las funciones de orden superior.","title":"Generalizaci\u00f3n"},{"location":"teoria/tema02-programacion-funcional/tema02-programacion-funcional.html#funciones-que-devuelven-funciones","text":"Cualquier objeto de primera clase puede ser devuelto por una funci\u00f3n; enteros, booleanos, parejas, etc. son objetos primitivos y podemos definir funciones que los devuelven. En el paradigma funcional lo mismo sucede con las funciones. Podemos definir una funci\u00f3n que cuando se invoque construya otra funci\u00f3n y la devuelva como resultado. Esta es una de la caracter\u00edsticas m\u00e1s importantes que diferencia los lenguajes de programaci\u00f3n funcionales de otros que no lo son. En lenguajes como C, C++ o Java (antes de Java 8) no es posible hacer esto. Para devolver una funci\u00f3n en Scheme debemos usar la forma especial lambda en el cuerpo de una funci\u00f3n. As\u00ed, cuando se invoca a esta funci\u00f3n se eval\u00faa lambda y se devuelve la funci\u00f3n resultante. Es una funci\u00f3n que creamos en tiempo de ejecuci\u00f3n, durante la evaluaci\u00f3n de la funci\u00f3n principal. La funci\u00f3n que se devuelve se denomina clausura ( Wikipedia ). Y decimos que la funci\u00f3n que ha construido la clausura es una funci\u00f3n constructora .","title":"Funciones que devuelven funciones"},{"location":"teoria/tema02-programacion-funcional/tema02-programacion-funcional.html#funciones-en-estructuras-de-datos","text":"La \u00faltima caracter\u00edstica de los tipos de primera clase es que pueden formar parte de tipos de datos compuestos, como listas. Para construir una lista de funciones debemos llamar a list con las funciones: 1 2 3 4 5 6 7 ( define ( cuadrado x ) ( * x x )) ( define ( suma-1 x ) ( + x 1 )) ( define ( doble x ) ( * x 2 )) ( define lista ( list cuadrado suma-1 doble )) lista ; \u21d2 (#<procedure:cuadrado> #<procedure:suma-1> #<procedure:doble>) Tambi\u00e9n podemos definir las funciones con expresiones lambda. Por ejemplo, podemos a\u00f1adir a la lista una funci\u00f3n que suma 5 a un n\u00famero: 1 2 3 ( define lista2 ( cons ( lambda ( x ) ( + x 5 )) lista )) lista2 ; \u21d2 (#<procedure> #<procedure:cuadrado> #<procedure:suma-1> #<procedure:doble>) Una vez creada una lista con funciones, \u00bfc\u00f3mo podemos invocar a alguna de ellas?. Debemos tratarlas de la misma forma que tratamos cualquier otro dato guardado en la lista, las recuperamos con las funciones car o list-ref y las invocamos. Por ejemplo, para invocar a la primera funci\u00f3n de lista2 : 1 (( car lista2 ) 10 ) ; \u21d2 15 O a la tercera: 1 (( list-ref lista2 2 ) 10 ) ; \u21d2 11","title":"Funciones en estructuras de datos"},{"location":"teoria/tema02-programacion-funcional/tema02-programacion-funcional.html#funciones-de-orden-superior","text":"Llamamos funciones de orden superior ( higher order functions en ingl\u00e9s) a las funciones que toman otras como par\u00e1metro o devuelven otra funci\u00f3n. Permiten generalizar soluciones con un alto grado de abstracci\u00f3n. Ya hemos visto algunas funciones de orden superior, unas construidas por nostros y otras propias de Scheme, como apply . Adem\u00e1s de apply , los lenguajes de programaci\u00f3n funcional como Scheme, Scala o Java 8 tienen ya predefinidas algunas otras funciones de orden superior que trabajan con listas. Estas funciones permiten definir operaciones sobre las listas de una forma muy concisa y compacta. Son muy usadas, porque tambi\u00e9n se pueden utilizar sobre streams de datos obtenidos en operaciones de entrada/salida (por ejemplo, datos JSON resultantes de una petici\u00f3n HTTP). Vamos a ver las funciones m\u00e1s importantes, su uso y su implementaci\u00f3n. map filter exists? for-all? foldr y foldl Despu\u00e9s de explicar estas funciones terminaremos con un ejemplo de su aplicaci\u00f3n en el que comprobaremos c\u00f3mo la utilizaci\u00f3n de funciones de orden superior es una excelente herramienta de la programaci\u00f3n funcional que permite hacer c\u00f3digo muy conciso y expresivo. La combinaci\u00f3n de funciones de nivel superior con listas es una de las caracter\u00edsticas m\u00e1s potentes de la programaci\u00f3n funcional.","title":"Funciones de orden superior"},{"location":"teoria/tema02-programacion-funcional/tema02-programacion-funcional.html#bibliografia-sicp","text":"En este tema hemos explicado conceptos de los siguientes cap\u00edtulos del libro Structure and Intepretation of Computer Programs : 1.1.1 - Expressions 1.1.2 - Naming and environment 1.1.3 - Evaluating combinations 1.1.4 - Compound procedures 1.1.5 - The Substitution Model for Procedure Application 1.1.6 - Conditional Expressions and Predicates 1.3 - Formulating Abstractions with Higher-Order Procedures 2.2 - Hierarchical Data and the Closure Property (Introducci\u00f3n de la secci\u00f3n) 2.2.1 - Representing Sequences 2.3.1 - Quotation Lenguajes y Paradigmas de Programaci\u00f3n, curso 2019-20 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Domingo Gallardo, Cristina Pomares, Antonio Bot\u00eda, Francisco Mart\u00ednez","title":"Bibliograf\u00eda - SICP"},{"location":"teoria/tema03-procedimientos-recursivos/tema03-procedimientos-recursivos.html","text":"Tema 3: Procedimientos recursivos \u00b6 Ya hemos visto muchos ejemplos de funciones recursivas. Una funci\u00f3n es recursiva cuando se llama a si misma. Una vez que uno se acostumbra a su uso, se comprueba que la recursi\u00f3n es una forma mucho m\u00e1s natural que la iteraci\u00f3n de expresar un gran n\u00famero de funciones y procedimientos. La formulaci\u00f3n matem\u00e1tica de la recursi\u00f3n es sencilla de entender, pero su implementaci\u00f3n en un lenguaje de programaci\u00f3n no lo es tanto. El primer lenguaje de programaci\u00f3n que permiti\u00f3 el uso de expresiones recursivas fue el Lisp. En el momento de su creaci\u00f3n exist\u00eda ya el Fortran, que no permit\u00eda que una funci\u00f3n se llamase a si misma. Ya hemos visto la utilidad de la recursi\u00f3n en muchos ejemplos para recorrer listas, para filtrarlas, etc. En este tema veremos algunos aspectos negativos de la recursi\u00f3n: su coste espacial y temporal. Veremos que hay soluciones a estos problemas, cambiando el estilo de la recursi\u00f3n y generando procesos iterativos o usando un enfoque autom\u00e1tico llamado memoization en el que se guardan los resultados de cada llamada recursiva. Por \u00faltimo, veremos un \u00faltimo ejemplo curioso e interesante de la recursi\u00f3n para realizar figuras fractales con gr\u00e1ficos de tortuga. El coste de la recursi\u00f3n \u00b6 Hasta ahora hemos estudiado el dise\u00f1o de funciones recursivas. Vamos a tratar por primera vez su coste. Veremos que hay casos en los que es prohibitivo utilizar la recursi\u00f3n tal y como la hemos visto. Y veremos tambi\u00e9n que existen soluciones para esos casos. La pila de la recursi\u00f3n \u00b6 Vamos a estudiar el comportamiento de la evaluaci\u00f3n de una llamada a una funci\u00f3n recursiva. Supongamos la funci\u00f3n mi-length : 1 2 3 4 ( define ( mi-length items ) ( if ( null? items ) 0 ( + 1 ( mi-length ( cdr items ))))) Examinamos c\u00f3mo se eval\u00faan las llamadas recursivas: 1 2 3 4 5 6 7 8 9 10 (mi-length '(a b c d)) (+ 1 (mi-length '(b c d))) (+ 1 (+ 1 (mi-length '(c d)))) (+ 1 (+ 1 (+ 1 (mi-length '(d))))) (+ 1 (+ 1 (+ 1 (+ 1 (mi-length '()))))) (+ 1 (+ 1 (+ 1 (+ 1 0)))) (+ 1 (+ 1 (+ 1 1))) (+ 1 (+ 1 2)) (+ 1 3) 4 Cada llamada a la recursi\u00f3n deja una funci\u00f3n en espera de ser evaluada cuando la recursi\u00f3n devuelva un valor (en el caso anterior las funciones suma). Estas llamadas en espera, junto con sus argumentos, se almacenan en la pila de la recursi\u00f3n . Cuando la recursi\u00f3n devuelve un valor, los valores se recuperan de la pila, se realiza la llamada y se devuelve el valor a la anterior llamada en espera. Si la recursi\u00f3n est\u00e1 mal hecha y nunca termina se genera un stack overflow porque la memoria que se almacena en la pila sobrepasa la memoria reservada para el int\u00e9rprete DrRacket. Coste espacial de la recursi\u00f3n \u00b6 El coste espacial de un programa es una funci\u00f3n que relaciona la memoria consumida por una llamada para resolver un problema con alguna variable que determina el tama\u00f1o del problema a resolver. En el caso de la funci\u00f3n mi-length el tama\u00f1o del problema viene dado por la longitud de la lista. El coste espacial de mi-lenght es O(n) , siendo n la longitud de la lista. El coste depende del n\u00famero de llamadas a la recursi\u00f3n \u00b6 Veamos con un ejemplo que el coste de las llamadas recursivas puede dispararse. Supongamos la famosa secuencia de Fibonacci : 0,1,1,2,3,5,8,13,... Formulaci\u00f3n matem\u00e1tica de la secuencia de Fibonacci: 1 2 3 Fibonacci(n) = Fibonacci(n-1) + Fibonacci(n-2) Fibonacci(0) = 0 Fibonacci(1) = 1 Formulaci\u00f3n recursiva en Scheme: 1 2 3 4 5 ( define ( fib n ) ( cond (( = n 0 ) 0 ) (( = n 1 ) 1 ) ( else ( + ( fib ( - n 1 )) ( fib ( - n 2 )))))) Evaluaci\u00f3n de una llamada a Fibonacci: Cada llamada a la recursi\u00f3n produce otras dos llamadas, por lo que el n\u00famero de llamadas finales es 2^n siendo n el n\u00famero que se pasa a la funci\u00f3n. El coste espacial y temporal es exponencial, O(2^n). Esto hace inviable utilizar esta implementaci\u00f3n para realizar el c\u00e1lculo de la funci\u00f3n. Puedes comprobarlo intentando evaluar en el int\u00e9rprete (fib 35) . Soluciones al coste de la recursi\u00f3n: procesos iterativos \u00b6 Diferenciamos entre procedimientos y procesos: un procedimiento es un algoritmo y un proceso es la ejecuci\u00f3n de ese algoritmo. Es posible definir procedimientos recursivos que generen procesos iterativos (como los bucles en programaci\u00f3n imperativa) en los que no se dejen llamadas recursivas en espera ni se incremente la pila de la recursi\u00f3n . Para ello construimos la recursi\u00f3n de forma que en cada llamada se haga un c\u00e1lculo parcial y en el caso base se pueda devolver directamente el resultado obtenido. Este estilo de recursi\u00f3n se denomina recursi\u00f3n por la cola ( tail recursion , en ingl\u00e9s). Se puede realizar una implementaci\u00f3n eficiente de la ejecuci\u00f3n del proceso, eliminando la pila de la recursi\u00f3n. Factorial iterativo \u00b6 Empezamos a explicar la recursi\u00f3n por la cola con un ejemplo muy sencillo: la versi\u00f3n iterativa de la t\u00edpica funci\u00f3n factorial . Le pondremos de nombre a la funci\u00f3n factorial-iter : 1 2 3 4 5 6 7 ( define ( factorial n ) ( fact-iter n n )) ( define ( fact-iter n result ) ( if ( = n 1 ) result ( fact-iter ( - n 1 ) ( * result ( - n 1 )) ))) La funci\u00f3n (fact-iter n result) es la que define el proceso iterativo. Su argumento n es el valor del que hay que calcular el factorial y el argumento result es un par\u00e1metro adicional en el que se van guardando los resultados intermedios. En cada llamada recursiva, n se va haciendo cada vez m\u00e1s peque\u00f1o y en result se va acumulando el c\u00e1lculo del factorial. Al final de la recursi\u00f3n el factorial debe estar calculado en result y se devuelve. Veamos la secuencia de llamadas: 1 2 3 4 5 6 (factorial 4) (factorial-iter 4 4) (factorial-iter 3 4*3=12) (factorial-iter 2 12*2=24) (factorial-iter 1 24*1=24) 24 Antes de realizar cada llamada recursiva se realiza el c\u00e1lculo del resultado parcial, que se guarda en el par\u00e1metro result . Despu\u00e9s se realiza la llamada con el nuevo valor calculado de n y de result . Al final, cuando n vale 1 se devuelve el valor calculado de result . Este valor es el resultado completo de la recursi\u00f3n, ya que no hay que hacer ninguna operaci\u00f3n m\u00e1s con \u00e9l. A diferencia de los procesos recursivos, en los que se quedan llamadas en espera en la pila de la recursi\u00f3n, en los procesos iterativos no hay ninguna llamada en espera. El resultado devuelto por el caso base es directamente la soluci\u00f3n de la recursi\u00f3n, no queda nada por hacer con este resultado. Es importante el valor inicial de resultado . La funci\u00f3n factorial se encarga de inicializar este par\u00e1metro. En este caso es el mismo valor del n\u00famero n a calcular el factorial. La secuencia de llamadas recursivas acumula en la variable result el valor del factorial: 1 4 * 3 * 2 * 1 = 24 Versi\u00f3n iterativa de mi-length \u00b6 Veamos un segundo ejemplo. \u00bfC\u00f3mo ser\u00eda la versi\u00f3n iterativa de mi-length , la funci\u00f3n que calcula la logitud de una lista?. Tenemos que a\u00f1adir un par\u00e1metro adicional en el que iremos acumulando el resultado parcial. En este caso, cada vez que llamemos a la recursi\u00f3n eliminado un elemento de la lista, incrementaremos en 1 el valor del resultado. Para que funcione bien este enfoque, debemos inicializar este resultado a 0. La soluci\u00f3n es la siguiente: 1 2 3 4 5 6 7 ( define ( mi-length lista ) ( mi-length-iter lista 0 )) ( define ( mi-length-iter lista result ) ( if ( null? lista ) result ( mi-length-iter ( cdr lista ) ( + result 1 )))) Fijaros que, al igual que en la versi\u00f3n iterativa de factorial, no hay ninguna llamada a ning\u00fana funci\u00f3n que recoja el resultado de la llamada recursiva y haga algo con \u00e9l. Directamente el resultado de la llamada recursiva es el resultado final de la recursi\u00f3n. Funci\u00f3n suma-lista usando recursi\u00f3n por la cola \u00b6 Veamos otro ejemplo. Supongamos que queremos calcular usando recursi\u00f3n por la cola la suma de los n\u00fameros de una lista. Deber\u00edamos a\u00f1adir un par\u00e1metro adicional en el que vamos acumulando esa suma. Inicializaremos a 0 ese par\u00e1metro e iremos en cada llamada recursiva acumulando el primer elemento de la lista: 1 2 3 4 5 6 7 ( define ( suma-lista lista ) ( suma-lista-iter lista 0 )) ( define ( suma-lista-iter lista result ) ( if ( null? lista ) result ( suma-lista-iter ( cdr lista ) ( + result ( car lista ))))) Procesos iterativos \u00b6 Un resumen de las caracter\u00edsticas de los procesos iterativos resultantes de hacer una recursi\u00f3n por la cola: La recursi\u00f3n resultante es menos elegante. Se necesita una par\u00e1metro adicional en el que se van acumulando los resultados parciales. La \u00faltima llamada a la recursi\u00f3n devuelve el valor acumulado. El proceso resultante de la recursi\u00f3n es iterativo en el sentido de que no deja llamadas en espera ni incurre en coste espacial. Fibonacci iterativo \u00b6 Cualquier programa recursivo se puede transformar en otro que genera un proceso iterativo. En general, las versiones iterativas son menos intuitivas y m\u00e1s dif\u00edciles de entender y depurar. Veamos, por ejemplo, la formulaci\u00f3n iterativa de Fibonacci: 1 2 3 4 5 6 7 ( define ( fib n ) ( fib-iter 1 0 n )) ( define ( fib-iter a b count ) ( if ( = count 0 ) b ( fib-iter ( + a b ) a ( - count 1 )))) La secuencia de llamadas recursivas ser\u00eda la siguiente: 1 2 3 4 5 6 7 8 9 (fib 6) (fib-iter 1 0 6) (fib-iter 1+0=1 1 5) (fib-iter 1+1=2 1 4) (fib-iter 2+1=3 2 3) (fib-iter 3+2=5 3 2) (fib-iter 5+3=8 5 1) (fib-iter 8+5=13 8 0) 8 En la llamada recursiva n , el par\u00e1metro a guarda el valor de fibonacci n+1 y el par\u00e1metro b guarda el valor de fibonacci n , que es el que se devuelve. Conseguimos n llamadas inicializando count a n y decrementando el par\u00e1metro en 1 cada vez. Tri\u00e1ngulo de Pascal \u00b6 El tri\u00e1ngulo de Pascal es el siguiente tri\u00e1ngulo de n\u00fameros. 1 2 3 4 5 6 7 8 9 1 1 1 1 2 1 1 3 3 1 1 4 6 4 1 1 5 10 10 5 1 1 6 15 20 15 6 1 1 7 21 35 35 21 7 1 ... Si numeramos las filas y columnas empezando a contar por 0, la expresi\u00f3n general del valor en una fila y columna determinada se puede obtener con la siguiente definici\u00f3n recursiva: 1 2 3 4 Pascal (n, 0) = 1 Pascal (n, n) = 1 Pascal (fila, columna) = Pascal (fila-1,columna-1) + Pascal (fila-1, columna) La funci\u00f3n s\u00f3lo est\u00e1 definida para valores de columna menores o iguales que fila . En Scheme es f\u00e1cil escribir una funci\u00f3n recursiva que implemente la definici\u00f3n anterior: 1 2 3 4 5 6 7 8 9 10 11 ( define ( pascal fila col ) ( cond (( = col 0 ) 1 ) (( = col fila ) 1 ) ( else ( + ( pascal ( - fila 1 ) ( - col 1 )) ( pascal ( - fila 1 ) col ) )))) ( pascal 4 2 ) ; \u21d2 6 ( pascal 8 4 ) ; \u21d2 70 ( pascal 27 13 ) ; \u21d2 20058300 Hay que llamar a la funci\u00f3n con un valor de col menor o igual que fila . En el caso en que se pase un valor col mayor que fila la recursi\u00f3n no termina y se entra en un bucle infinito. La funci\u00f3n tiene una formulaci\u00f3n sencilla y funciona correctamente. Sin embargo, el coste de esta recursi\u00f3n es tambi\u00e9n exponencial, igual que pasaba en el caso de la secuencia de fibonacci. Por ejemplo, la \u00faltima expresi\u00f3n (pascal 27 13) tarda un buen rato en devolver el resultado. Ser\u00eda imposible calcular el valor de n\u00fameros de Pascal un poco m\u00e1s grandes, como (pascal 40 20) . Veamos c\u00f3mo se puede conseguir una versi\u00f3n iterativa. La idea es definir una funci\u00f3n iterativa pascal-fila a la que le pasamos el n\u00famero de fila n y nos devuelve la lista de n+1 n\u00fameros que constituyen la fila n del tri\u00e1ngulo de Pascal: 1 2 3 4 5 6 fila 0 = (1) fila 1 = (1 1) fila 2 = (1 2 1) fila 3 = (1 3 3 1) fila 4 = (1 4 6 4 1) ... Esta funci\u00f3n necesitar\u00e1 un par\u00e1metro adicional ( lista-fila ) que se inicializa con la lista (1) y en el que se va guardando cada fila sucesiva. Esta fila va creciendo hasta que llegamos a la fila que tenemos que devolver. Hay que hacer la iteraci\u00f3n n veces, por lo que vamos decrementando el par\u00e1metro n hasta que se llega a 0. Para implementar esta funci\u00f3n usamos otra llamada (pascal-sig-fila lista-fila) que recibe una fila del tri\u00e1ngulo y devuelve la siguiente. Por ejemplo: 1 2 ( pascal-sig-fila ' ( 1 3 3 1 )) ; \u21d2 (1 4 6 4 1) Esta funci\u00f3n la implementamos con una funci\u00f3n recursiva auxiliar (esta es recursiva pura) llamada (pascal-suma-dos-a-dos lista-fila) que es la que se encarga de realizar el c\u00e1lculo de la nueva fila. El c\u00f3digo completo es el siguiente: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ( define ( pascal fila col ) ( list-ref ( pascal-fila ' ( 1 ) fila ) col )) ( define ( pascal-fila lista-fila n ) ( if ( = 0 n ) lista-fila ( pascal-fila ( pascal-sig-fila lista-fila ) ( - n 1 )))) ( define ( pascal-sig-fila lista-fila ) ( append ' ( 1 ) ( pascal-suma-dos-a-dos lista-fila ) ' ( 1 ))) ( define ( pascal-suma-dos-a-dos lista-fila ) ( if ( null? ( cdr lista-fila )) ' () ( cons ( + ( car lista-fila ) ( car ( cdr lista-fila ))) ( pascal-suma-dos-a-dos ( cdr lista-fila ))))) Con esta implementaci\u00f3n ya no se tiene un coste exponencial y se puede calcular el valor de n\u00fameros como Pascal(40, 20): 1 2 ( pascal 40 20 ) ; \u21d2 137846528820 Soluciones al coste de la recursi\u00f3n: memoization \u00b6 Una alternativa que mantiene la elegancia de los procesos recursivos y la eficiencia de los iterativos es la memoization . Si miramos la traza de (fibonacci 4) podemos ver que el coste est\u00e1 producido por la repetici\u00f3n de llamadas; por ejemplo (fibonacci 3) se eval\u00faa 2 veces. En programaci\u00f3n funcional la llamada a (fibonacci 3) siempre va a devolver el mismo valor. La idea de la memoization es guardar el valor devuelto por la cada llamada en alguna estructura (una lista de asociaci\u00f3n, por ejemplo) y no volver a realizar la llamada a la recursi\u00f3n las siguientes veces. Fibonacci con memoization \u00b6 Para implementar la memoization necesitamos odos m\u00e9todos imperativos put y get que implementan un diccionario clave-valor . La funci\u00f3n (put key value dic) asocia un valor a una clave, la guarda en el diccionario (con mutaci\u00f3n) y devuelve el valor. La funci\u00f3n (get key dic) devuelve el valor del diccionario asociado a una clave. En el caso en que no exista ning\u00fan valor se devuelve #f . Ejemplos: 1 2 3 4 ( define mi-dic ( crea-diccionario )) ( put 1 10 mi-dic ) ; \u21d2 10 ( get 1 mi-dic ) ; \u21d2 10 ( get 2 mi-dic ) ; \u21d2 #f Estos m\u00e9todos son imperativos porque modifican (mutan) la estructura de datos que pasamos como par\u00e1metro. Para implementarlos tenemos que salirnos del paradigma funcional, usando las funciones de Racket que permiten mutar las parejas. No es importante la implementaci\u00f3n, la dejamos aqu\u00ed como referencia y para poder probar la memoization . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 ( define ( crea-diccionario ) ( mcons ' *diccionario* ' ())) ( define ( busca key dic ) ( cond (( null? dic ) #f ) (( equal? key ( mcar ( mcar dic ))) ( mcar dic )) ( else ( busca key ( mcdr dic ))))) ( define ( get key dic ) ( define record ( busca key ( mcdr dic ))) ( if ( not record ) #f ( mcdr record ))) ( define ( put key value dic ) ( define record ( busca key ( mcdr dic ))) ( if ( not record ) ( set-mcdr! dic ( mcons ( mcons key value ) ( mcdr dic ))) ( set-mcdr! record value )) value ) La funci\u00f3n fib-memo realiza el c\u00e1lculo de la serie de Fibonacci utilizando exactamente la misma definici\u00f3n recursiva original, pero a\u00f1adiendo la t\u00e9cnica de memoization : lo primero que hacemos para calcular el n\u00famero de fibonacci n , antes de llamar a la recursi\u00f3n, es comprobar si est\u00e1 ya guardado en la lista de asociaci\u00f3n. En el caso en que est\u00e9, lo devolvemos. S\u00f3lo cuando el n\u00famero no est\u00e1 calculado llamamos a la recursi\u00f3n para calcularlo. La implementaci\u00f3n se muestra a continuaci\u00f3n. Vemos que para devolver el n\u00famero de fibonacci n se comprueba si ya est\u00e1 guardado en la lista. S\u00f3lo en el caso en que no est\u00e9 guardado se llama a la recursi\u00f3n para calcularlo y guardarlo. La funci\u00f3n put que guarda el nuevo valor calculado tambi\u00e9n lo devuelve. 1 2 3 4 5 6 7 ( define ( fib-memo n dic ) ( cond (( = n 0 ) 0 ) (( = n 1 ) 1 ) (( not ( equal? ( get n dic ) #f )) ( get n dic )) ( else ( put n ( + ( fib-memo ( - n 1 ) dic ) ( fib-memo ( - n 2 ) dic )) dic )))) Podemos comprobar la diferencia de tiempos de ejecuci\u00f3n entre esta versi\u00f3n y la anterior. El coste de la funci\u00f3n memoizada es O(n). Frente al coste O(2^n) de la versi\u00f3n inicial que la hac\u00eda imposible de utilizar. 1 2 ( fib-memo 200 lista ) \u21d2 280571172992510140037611932413038677189525 Recursi\u00f3n y gr\u00e1ficos de tortuga \u00b6 Vamos a terminar el apartado sobre procedimientos recursivos con un \u00faltimo ejemplo algo distinto de los vistos hasta ahora. Usaremos la recursi\u00f3n para dibujar figuras fractales usando los denominados gr\u00e1ficos de tortuga . Para dibujar las figuras tendremos que utilizar un estilo de programaci\u00f3n no funcional, dibujando los distintos trazos de las figuras con pasos de ejecuci\u00f3n secuenciales. Para ello usaremos una primitiva imperativa de Scheme: la forma especial begin que permite realizar un grupo de pasos de ejecuci\u00f3n de forma secuencial. Aviso Ten cuidado con la forma especial begin , es una forma especial imperativa. No debes usarla en la implementaci\u00f3n de ninguna funci\u00f3n cuando estemos usando el paradigma funcional. Gr\u00e1ficos de tortuga en Racket \u00b6 Se pueden utilizar los gr\u00e1ficos de tortuga en Racket cargando la librer\u00eda (graphics turtles) : 1 2 #lang racket ( require graphics/turtles ) Los comandos m\u00e1s importantes de esta librer\u00eda son: (turtles #t) : abre una ventana y coloca la tortuga en el centro, mirando hacia el eje X (derecha) (clear) : borra la ventana y coloca la tortuga en el centro (draw d) : avanza la tortuga dibujando d p\u00edxeles (move d) : mueve la tortuga d p\u00edxeles hacia adelante (sin dibujar) (turn g) : gira la tortuga g grados (positivos: en el sentido contrario a las agujas del reloj) Prueba a realizar algunas figuras con los comandos de tortuga, antes de escribir el algoritmo en Scheme del tri\u00e1ngulo de Sierpinski. Por ejemplo, podemos definir una funci\u00f3n que dibuja un tri\u00e1ngulo rect\u00e1ngulo con catetos de longitud x : 1 2 3 4 5 6 7 8 9 10 11 12 13 ( define ( hipot x ) ( * x ( sqrt 2 ))) ( define ( triangulo-rectangulo x ) ( begin ( draw x ) ( turn 90 ) ( draw x ) ( turn 135 ) ( draw ( hipot x )) ( turn 135 ))) ( triangulo-rectangulo 100 ) La funci\u00f3n (hipot x) devuelve la longitud de la hipotenusa de un tri\u00e1ngulo rect\u00e1ngulo con dos lados de longitud x . O sea, la expresi\u00f3n: hipot(x) = \\sqrt{x^2+x^2} = x \\sqrt{2} hipot(x) = \\sqrt{x^2+x^2} = x \\sqrt{2} Como puedes comprobar, el c\u00f3digo es imperativo. La forma especial begin permite realizar una serie de pasos de ejecuci\u00f3n que modifican el estado (posici\u00f3n y orientaci\u00f3n) de la tortuga y dibujan los trazos de la figura. El siguiente c\u00f3digo es una variante del anterior que dibuja un tri\u00e1ngulo rect\u00e1ngulo de base w y lados w/2 . Va a ser la figura base del tri\u00e1ngulo de Sierpinski. 1 2 3 4 5 6 7 8 ( define ( triangle w ) ( begin ( draw w ) ( turn 135 ) ( draw ( hipot ( / w 2 ))) ( turn 90 ) ( draw ( hipot ( / w 2 ))) ( turn 135 ))) Tri\u00e1ngulo de Sierpinski \u00b6 Tri\u00e1ngulo de Sierpinski \u00bfVes alguna recursi\u00f3n en la figura? \u00bfCu\u00e1l podr\u00eda ser el par\u00e1metro de la funci\u00f3n que la dibujara? \u00bfSe te ocurre un algoritmo recursivo que la dibuje? La figura es autosimilar (una caracter\u00edstica de las figuras fractales). Una parte de la figura es id\u00e9ntica a la figura total, pero reducida de escala. Esto nos da una pista de que es posible dibujar la figura con un algoritmo recursivo. Para intentar encontrar una forma de enfocar el problema, vamos a pensarlo de la siguiente forma: supongamos que tenemos un tri\u00e1ngulo de Sierpinski de anchura h y altura h/2 con su esquina inferior izquierda en la posici\u00f3n 0,0. \u00bfC\u00f3mo podr\u00edamos construir el siguiente tri\u00e1ngulo de Sierpinski?. Podr\u00edamos construir un tri\u00e1ngulo de Sierpinski m\u00e1s grande dibujando 3 veces el mismo tri\u00e1ngulo, pero en distintas posiciones: Tri\u00e1ngulo 1 en la posici\u00f3n (0,0) Tri\u00e1ngulo 2 en la posici\u00f3n (h/2,h/2) Tri\u00e1ngulo 3 en la posici\u00f3n (h,0) El algoritmo recursivo se basa en la misma idea, pero hacia atr\u00e1s . Debemos intentar dibujar un tri\u00e1ngulo de altura h situado en la posici\u00f3n x , y bas\u00e1ndonos en 3 llamadas recursivas a tri\u00e1ngulos m\u00e1s peque\u00f1os. En el caso base, cuando h sea menor que un umbral, dibujaremos un tri\u00e1ngulo de lado h y altura h/2 : O sea, que para dibujar un tri\u00e1ngulo de Sierpinski de base h y altura h/2 debemos: Dibujar tres tri\u00e1ngulos de Sierpinsky de la mitad del tama\u00f1o del original ( h/2 ) situadas en las posiciones (x,y) , (x+h/4, y+h/4) y (x+h/2,y) En el caso base de la recursi\u00f3n, en el que h es menor que una constante, se dibuja un tri\u00e1ngulo de base h y altura h/2 . Una versi\u00f3n del algoritmo en pseudoc\u00f3digo : 1 2 3 4 5 6 Sierpinsky (x, y, h): if (h > MIN) { Sierpinsky (x, y, h/2) Sierpinsky (x+h/4, y+h/4, h/2) Sierpinsky (x+h/2, y, h/2) } else dibujaTriangulo (x, y, h) Sierpinski en Racket \u00b6 La siguiente es una versi\u00f3n imperativa del algoritmo que dibuja el tri\u00e1ngulo de Sierpinski. No es funcional porque se realizan pasos de ejecuci\u00f3n , usando la forma especial begin o m\u00faltiples instrucciones en una misma funci\u00f3n (por ejemplo la funci\u00f3n triangle ). 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #lang racket ( require graphics/turtles ) ( turtles #t ) ( define ( hipot x ) ( * x ( sqrt 2 ))) ( define ( triangle w ) ( begin ( draw w ) ( turn 135 ) ( draw ( hipot ( / w 2 ))) ( turn 90 ) ( draw ( hipot ( / w 2 ))) ( turn 135 ))) ( define ( sierpinski w ) ( if ( > w 20 ) ( begin ( sierpinski ( / w 2 )) ( move ( / w 4 )) ( turn 90 ) ( move ( / w 4 )) ( turn -90 ) ( sierpinski ( / w 2 )) ( turn -90 ) ( move ( / w 4 )) ( turn 90 ) ( move ( / w 4 )) ( sierpinski ( / w 2 )) ( turn 180 ) ( move ( / w 2 )) ( turn -180 )) ;; volvemos a la posici\u00f3n original ( triangle w ))) La llamada a 1 ( sierpinski 40 ) produce la siguiente figura: La llamada a 1 ( sierpinski 700 ) Produce la figura que vimos al principio del apartado: Para ocupar la venta completa debemos desplazar la tortuga hacia atr\u00e1s antes de invocar a sierpinski : 1 2 3 ( clear ) ( move -350 ) ( sierpinski 700 ) Recursi\u00f3n mutua \u00b6 En la recursi\u00f3n mutua definimos una funci\u00f3n en base a una segunda, que a su vez se define en base a la primera. Tambi\u00e9n debe haber un caso base que termine la recursi\u00f3n Por ejemplo: x es par si x-1 es impar x es impar si x-1 es par 0 es par Programas en Scheme: 1 2 3 4 5 6 7 8 9 ( define ( par? x ) ( if ( = 0 x ) #t ( impar? ( - x 1 )))) ( define ( impar? x ) ( if ( = 0 x ) #f ( par? ( - x 1 )))) Ejemplo avanzado: curvas de Hilbert \u00b6 La curva de Hilbert es una curva fractal que tiene la propiedad de rellenar completamente el espacio Su dibujo tiene una formulaci\u00f3n recursiva: La curva H3 se puede construir a partir de la curva H2. El algoritmo recursivo se formula dibujando la curva i-\u00e9sima a partir de la curva i-1. Para dibujar una curva de Hilbert de orden i a la derecha de la tortuga: 1 2 3 4 5 6 7 8 9 10 11 1. Gira la tortuga -90 2. Dibuja una curva de orden i-1 a la izquierda 3. Avanza long dibujando 4. Gira 90 5. Dibuja una curva de orden i-1 a la derecha 6. Avanza long dibujando 7. Dibuja una curva de orden i-1 a la derecha 8. Gira 90 9. Avanza long dibujando 10. Dibuja una curva de orden i-1 a la izquierda 11. Gira -90 El algoritmo para dibujar a la izquierda es sim\u00e9trico. Como en la curva de Sierpinsky, utilizamos la librer\u00eda graphics/turtles , que permite usar la tortuga de Logo con los comandos de Logo draw y turn . Definimos dos funciones sim\u00e9tricas, la funci\u00f3n (h-der i long) que dibuja una curva de Hilbert de orden i con una longitud de trazo long a la derecha de la tortuga y la funci\u00f3n (h-izq i w) que dibuja una curva de Hilbert de orden i con una longitud de trazo long a la izquierda de la tortuga. El algoritmo en Scheme: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #lang racket ( require graphics/turtles ) ( define ( h-izq i long ) ( if ( > i 0 ) ( begin ( turn 90 ) ( h-der ( - i 1 ) long ) ( draw long ) ( turn -90 ) ( h-izq ( - i 1 ) long ) ( draw long ) ( h-izq ( - i 1 ) long ) ( turn -90 ) ( draw long ) ( h-der ( - i 1 ) long ) ( turn 90 )) ( move 0 ))) ( define ( h-der i long ) ( if ( > i 0 ) ( begin ( turn -90 ) ( h-izq ( - i 1 ) long ) ( draw long ) ( turn 90 ) ( h-der ( - i 1 ) long ) ( draw long ) ( h-der ( - i 1 ) long ) ( turn 90 ) ( draw long ) ( h-izq ( - i 1 ) long ) ( turn -90 )) ( move 0 ))) Podemos probarlo con distintos par\u00e1metros de grado de curva y longitud de trazo. Curva de Hilbert de nivel 3 con trazo de longitud 20: 1 2 ( clear ) ( h-izq 3 30 ) Para entender mejor el algoritmo podemos dibujar paso a paso esta figura usando los siguientes comandos: 1 2 3 4 5 6 7 8 9 10 11 12 ( clear ) ( turn 90 ) ( h-der 2 30 ) ( draw 30 ) ( turn -90 ) ( h-izq 2 30 ) ( draw 30 ) ( h-izq 2 30 ) ( turn -90 ) ( draw 30 ) ( h-der 2 30 ) ( turn 90 ) Curva de Hilbert de nivel 6 con trazo de longitud 10: 1 2 3 4 5 6 ( clear ) ( move -350 ) ( turn -90 ) ( move 350 ) ( turn 90 ) ( h-izq 6 10 ) Curva de Hilbert de nivel 7 con trazo de longitud 5: 1 2 3 4 5 6 ( clear ) ( move -350 ) ( turn -90 ) ( move 350 ) ( turn 90 ) ( h-izq 7 5 ) Bibliograf\u00eda - SICP \u00b6 En este tema explicamos conceptos de los siguientes cap\u00edtulos del libro Structure and Intepretation of Computer Programs : 1.2 - Procedures and the Processes They Generate 1.2.1 - Linear Recursion and Iteration 1.2.2 - Tree Recursion Lenguajes y Paradigmas de Programaci\u00f3n, curso 2019-20 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Domingo Gallardo, Cristina Pomares, Antonio Bot\u00eda, Francisco Mart\u00ednez","title":"Tema 3: Procedimientos recursivos"},{"location":"teoria/tema03-procedimientos-recursivos/tema03-procedimientos-recursivos.html#tema-3-procedimientos-recursivos","text":"Ya hemos visto muchos ejemplos de funciones recursivas. Una funci\u00f3n es recursiva cuando se llama a si misma. Una vez que uno se acostumbra a su uso, se comprueba que la recursi\u00f3n es una forma mucho m\u00e1s natural que la iteraci\u00f3n de expresar un gran n\u00famero de funciones y procedimientos. La formulaci\u00f3n matem\u00e1tica de la recursi\u00f3n es sencilla de entender, pero su implementaci\u00f3n en un lenguaje de programaci\u00f3n no lo es tanto. El primer lenguaje de programaci\u00f3n que permiti\u00f3 el uso de expresiones recursivas fue el Lisp. En el momento de su creaci\u00f3n exist\u00eda ya el Fortran, que no permit\u00eda que una funci\u00f3n se llamase a si misma. Ya hemos visto la utilidad de la recursi\u00f3n en muchos ejemplos para recorrer listas, para filtrarlas, etc. En este tema veremos algunos aspectos negativos de la recursi\u00f3n: su coste espacial y temporal. Veremos que hay soluciones a estos problemas, cambiando el estilo de la recursi\u00f3n y generando procesos iterativos o usando un enfoque autom\u00e1tico llamado memoization en el que se guardan los resultados de cada llamada recursiva. Por \u00faltimo, veremos un \u00faltimo ejemplo curioso e interesante de la recursi\u00f3n para realizar figuras fractales con gr\u00e1ficos de tortuga.","title":"Tema 3: Procedimientos recursivos"},{"location":"teoria/tema03-procedimientos-recursivos/tema03-procedimientos-recursivos.html#el-coste-de-la-recursion","text":"Hasta ahora hemos estudiado el dise\u00f1o de funciones recursivas. Vamos a tratar por primera vez su coste. Veremos que hay casos en los que es prohibitivo utilizar la recursi\u00f3n tal y como la hemos visto. Y veremos tambi\u00e9n que existen soluciones para esos casos.","title":"El coste de la recursi\u00f3n"},{"location":"teoria/tema03-procedimientos-recursivos/tema03-procedimientos-recursivos.html#la-pila-de-la-recursion","text":"Vamos a estudiar el comportamiento de la evaluaci\u00f3n de una llamada a una funci\u00f3n recursiva. Supongamos la funci\u00f3n mi-length : 1 2 3 4 ( define ( mi-length items ) ( if ( null? items ) 0 ( + 1 ( mi-length ( cdr items ))))) Examinamos c\u00f3mo se eval\u00faan las llamadas recursivas: 1 2 3 4 5 6 7 8 9 10 (mi-length '(a b c d)) (+ 1 (mi-length '(b c d))) (+ 1 (+ 1 (mi-length '(c d)))) (+ 1 (+ 1 (+ 1 (mi-length '(d))))) (+ 1 (+ 1 (+ 1 (+ 1 (mi-length '()))))) (+ 1 (+ 1 (+ 1 (+ 1 0)))) (+ 1 (+ 1 (+ 1 1))) (+ 1 (+ 1 2)) (+ 1 3) 4 Cada llamada a la recursi\u00f3n deja una funci\u00f3n en espera de ser evaluada cuando la recursi\u00f3n devuelva un valor (en el caso anterior las funciones suma). Estas llamadas en espera, junto con sus argumentos, se almacenan en la pila de la recursi\u00f3n . Cuando la recursi\u00f3n devuelve un valor, los valores se recuperan de la pila, se realiza la llamada y se devuelve el valor a la anterior llamada en espera. Si la recursi\u00f3n est\u00e1 mal hecha y nunca termina se genera un stack overflow porque la memoria que se almacena en la pila sobrepasa la memoria reservada para el int\u00e9rprete DrRacket.","title":"La pila de la recursi\u00f3n"},{"location":"teoria/tema03-procedimientos-recursivos/tema03-procedimientos-recursivos.html#coste-espacial-de-la-recursion","text":"El coste espacial de un programa es una funci\u00f3n que relaciona la memoria consumida por una llamada para resolver un problema con alguna variable que determina el tama\u00f1o del problema a resolver. En el caso de la funci\u00f3n mi-length el tama\u00f1o del problema viene dado por la longitud de la lista. El coste espacial de mi-lenght es O(n) , siendo n la longitud de la lista.","title":"Coste espacial de la recursi\u00f3n"},{"location":"teoria/tema03-procedimientos-recursivos/tema03-procedimientos-recursivos.html#el-coste-depende-del-numero-de-llamadas-a-la-recursion","text":"Veamos con un ejemplo que el coste de las llamadas recursivas puede dispararse. Supongamos la famosa secuencia de Fibonacci : 0,1,1,2,3,5,8,13,... Formulaci\u00f3n matem\u00e1tica de la secuencia de Fibonacci: 1 2 3 Fibonacci(n) = Fibonacci(n-1) + Fibonacci(n-2) Fibonacci(0) = 0 Fibonacci(1) = 1 Formulaci\u00f3n recursiva en Scheme: 1 2 3 4 5 ( define ( fib n ) ( cond (( = n 0 ) 0 ) (( = n 1 ) 1 ) ( else ( + ( fib ( - n 1 )) ( fib ( - n 2 )))))) Evaluaci\u00f3n de una llamada a Fibonacci: Cada llamada a la recursi\u00f3n produce otras dos llamadas, por lo que el n\u00famero de llamadas finales es 2^n siendo n el n\u00famero que se pasa a la funci\u00f3n. El coste espacial y temporal es exponencial, O(2^n). Esto hace inviable utilizar esta implementaci\u00f3n para realizar el c\u00e1lculo de la funci\u00f3n. Puedes comprobarlo intentando evaluar en el int\u00e9rprete (fib 35) .","title":"El coste depende del n\u00famero de llamadas a la recursi\u00f3n"},{"location":"teoria/tema03-procedimientos-recursivos/tema03-procedimientos-recursivos.html#soluciones-al-coste-de-la-recursion-procesos-iterativos","text":"Diferenciamos entre procedimientos y procesos: un procedimiento es un algoritmo y un proceso es la ejecuci\u00f3n de ese algoritmo. Es posible definir procedimientos recursivos que generen procesos iterativos (como los bucles en programaci\u00f3n imperativa) en los que no se dejen llamadas recursivas en espera ni se incremente la pila de la recursi\u00f3n . Para ello construimos la recursi\u00f3n de forma que en cada llamada se haga un c\u00e1lculo parcial y en el caso base se pueda devolver directamente el resultado obtenido. Este estilo de recursi\u00f3n se denomina recursi\u00f3n por la cola ( tail recursion , en ingl\u00e9s). Se puede realizar una implementaci\u00f3n eficiente de la ejecuci\u00f3n del proceso, eliminando la pila de la recursi\u00f3n.","title":"Soluciones al coste de la recursi\u00f3n: procesos iterativos"},{"location":"teoria/tema03-procedimientos-recursivos/tema03-procedimientos-recursivos.html#factorial-iterativo","text":"Empezamos a explicar la recursi\u00f3n por la cola con un ejemplo muy sencillo: la versi\u00f3n iterativa de la t\u00edpica funci\u00f3n factorial . Le pondremos de nombre a la funci\u00f3n factorial-iter : 1 2 3 4 5 6 7 ( define ( factorial n ) ( fact-iter n n )) ( define ( fact-iter n result ) ( if ( = n 1 ) result ( fact-iter ( - n 1 ) ( * result ( - n 1 )) ))) La funci\u00f3n (fact-iter n result) es la que define el proceso iterativo. Su argumento n es el valor del que hay que calcular el factorial y el argumento result es un par\u00e1metro adicional en el que se van guardando los resultados intermedios. En cada llamada recursiva, n se va haciendo cada vez m\u00e1s peque\u00f1o y en result se va acumulando el c\u00e1lculo del factorial. Al final de la recursi\u00f3n el factorial debe estar calculado en result y se devuelve. Veamos la secuencia de llamadas: 1 2 3 4 5 6 (factorial 4) (factorial-iter 4 4) (factorial-iter 3 4*3=12) (factorial-iter 2 12*2=24) (factorial-iter 1 24*1=24) 24 Antes de realizar cada llamada recursiva se realiza el c\u00e1lculo del resultado parcial, que se guarda en el par\u00e1metro result . Despu\u00e9s se realiza la llamada con el nuevo valor calculado de n y de result . Al final, cuando n vale 1 se devuelve el valor calculado de result . Este valor es el resultado completo de la recursi\u00f3n, ya que no hay que hacer ninguna operaci\u00f3n m\u00e1s con \u00e9l. A diferencia de los procesos recursivos, en los que se quedan llamadas en espera en la pila de la recursi\u00f3n, en los procesos iterativos no hay ninguna llamada en espera. El resultado devuelto por el caso base es directamente la soluci\u00f3n de la recursi\u00f3n, no queda nada por hacer con este resultado. Es importante el valor inicial de resultado . La funci\u00f3n factorial se encarga de inicializar este par\u00e1metro. En este caso es el mismo valor del n\u00famero n a calcular el factorial. La secuencia de llamadas recursivas acumula en la variable result el valor del factorial: 1 4 * 3 * 2 * 1 = 24","title":"Factorial iterativo"},{"location":"teoria/tema03-procedimientos-recursivos/tema03-procedimientos-recursivos.html#version-iterativa-de-mi-length","text":"Veamos un segundo ejemplo. \u00bfC\u00f3mo ser\u00eda la versi\u00f3n iterativa de mi-length , la funci\u00f3n que calcula la logitud de una lista?. Tenemos que a\u00f1adir un par\u00e1metro adicional en el que iremos acumulando el resultado parcial. En este caso, cada vez que llamemos a la recursi\u00f3n eliminado un elemento de la lista, incrementaremos en 1 el valor del resultado. Para que funcione bien este enfoque, debemos inicializar este resultado a 0. La soluci\u00f3n es la siguiente: 1 2 3 4 5 6 7 ( define ( mi-length lista ) ( mi-length-iter lista 0 )) ( define ( mi-length-iter lista result ) ( if ( null? lista ) result ( mi-length-iter ( cdr lista ) ( + result 1 )))) Fijaros que, al igual que en la versi\u00f3n iterativa de factorial, no hay ninguna llamada a ning\u00fana funci\u00f3n que recoja el resultado de la llamada recursiva y haga algo con \u00e9l. Directamente el resultado de la llamada recursiva es el resultado final de la recursi\u00f3n.","title":"Versi\u00f3n iterativa de mi-length"},{"location":"teoria/tema03-procedimientos-recursivos/tema03-procedimientos-recursivos.html#funcion-suma-lista-usando-recursion-por-la-cola","text":"Veamos otro ejemplo. Supongamos que queremos calcular usando recursi\u00f3n por la cola la suma de los n\u00fameros de una lista. Deber\u00edamos a\u00f1adir un par\u00e1metro adicional en el que vamos acumulando esa suma. Inicializaremos a 0 ese par\u00e1metro e iremos en cada llamada recursiva acumulando el primer elemento de la lista: 1 2 3 4 5 6 7 ( define ( suma-lista lista ) ( suma-lista-iter lista 0 )) ( define ( suma-lista-iter lista result ) ( if ( null? lista ) result ( suma-lista-iter ( cdr lista ) ( + result ( car lista )))))","title":"Funci\u00f3n suma-lista usando recursi\u00f3n por la cola"},{"location":"teoria/tema03-procedimientos-recursivos/tema03-procedimientos-recursivos.html#procesos-iterativos","text":"Un resumen de las caracter\u00edsticas de los procesos iterativos resultantes de hacer una recursi\u00f3n por la cola: La recursi\u00f3n resultante es menos elegante. Se necesita una par\u00e1metro adicional en el que se van acumulando los resultados parciales. La \u00faltima llamada a la recursi\u00f3n devuelve el valor acumulado. El proceso resultante de la recursi\u00f3n es iterativo en el sentido de que no deja llamadas en espera ni incurre en coste espacial.","title":"Procesos iterativos"},{"location":"teoria/tema03-procedimientos-recursivos/tema03-procedimientos-recursivos.html#fibonacci-iterativo","text":"Cualquier programa recursivo se puede transformar en otro que genera un proceso iterativo. En general, las versiones iterativas son menos intuitivas y m\u00e1s dif\u00edciles de entender y depurar. Veamos, por ejemplo, la formulaci\u00f3n iterativa de Fibonacci: 1 2 3 4 5 6 7 ( define ( fib n ) ( fib-iter 1 0 n )) ( define ( fib-iter a b count ) ( if ( = count 0 ) b ( fib-iter ( + a b ) a ( - count 1 )))) La secuencia de llamadas recursivas ser\u00eda la siguiente: 1 2 3 4 5 6 7 8 9 (fib 6) (fib-iter 1 0 6) (fib-iter 1+0=1 1 5) (fib-iter 1+1=2 1 4) (fib-iter 2+1=3 2 3) (fib-iter 3+2=5 3 2) (fib-iter 5+3=8 5 1) (fib-iter 8+5=13 8 0) 8 En la llamada recursiva n , el par\u00e1metro a guarda el valor de fibonacci n+1 y el par\u00e1metro b guarda el valor de fibonacci n , que es el que se devuelve. Conseguimos n llamadas inicializando count a n y decrementando el par\u00e1metro en 1 cada vez.","title":"Fibonacci iterativo"},{"location":"teoria/tema03-procedimientos-recursivos/tema03-procedimientos-recursivos.html#triangulo-de-pascal","text":"El tri\u00e1ngulo de Pascal es el siguiente tri\u00e1ngulo de n\u00fameros. 1 2 3 4 5 6 7 8 9 1 1 1 1 2 1 1 3 3 1 1 4 6 4 1 1 5 10 10 5 1 1 6 15 20 15 6 1 1 7 21 35 35 21 7 1 ... Si numeramos las filas y columnas empezando a contar por 0, la expresi\u00f3n general del valor en una fila y columna determinada se puede obtener con la siguiente definici\u00f3n recursiva: 1 2 3 4 Pascal (n, 0) = 1 Pascal (n, n) = 1 Pascal (fila, columna) = Pascal (fila-1,columna-1) + Pascal (fila-1, columna) La funci\u00f3n s\u00f3lo est\u00e1 definida para valores de columna menores o iguales que fila . En Scheme es f\u00e1cil escribir una funci\u00f3n recursiva que implemente la definici\u00f3n anterior: 1 2 3 4 5 6 7 8 9 10 11 ( define ( pascal fila col ) ( cond (( = col 0 ) 1 ) (( = col fila ) 1 ) ( else ( + ( pascal ( - fila 1 ) ( - col 1 )) ( pascal ( - fila 1 ) col ) )))) ( pascal 4 2 ) ; \u21d2 6 ( pascal 8 4 ) ; \u21d2 70 ( pascal 27 13 ) ; \u21d2 20058300 Hay que llamar a la funci\u00f3n con un valor de col menor o igual que fila . En el caso en que se pase un valor col mayor que fila la recursi\u00f3n no termina y se entra en un bucle infinito. La funci\u00f3n tiene una formulaci\u00f3n sencilla y funciona correctamente. Sin embargo, el coste de esta recursi\u00f3n es tambi\u00e9n exponencial, igual que pasaba en el caso de la secuencia de fibonacci. Por ejemplo, la \u00faltima expresi\u00f3n (pascal 27 13) tarda un buen rato en devolver el resultado. Ser\u00eda imposible calcular el valor de n\u00fameros de Pascal un poco m\u00e1s grandes, como (pascal 40 20) . Veamos c\u00f3mo se puede conseguir una versi\u00f3n iterativa. La idea es definir una funci\u00f3n iterativa pascal-fila a la que le pasamos el n\u00famero de fila n y nos devuelve la lista de n+1 n\u00fameros que constituyen la fila n del tri\u00e1ngulo de Pascal: 1 2 3 4 5 6 fila 0 = (1) fila 1 = (1 1) fila 2 = (1 2 1) fila 3 = (1 3 3 1) fila 4 = (1 4 6 4 1) ... Esta funci\u00f3n necesitar\u00e1 un par\u00e1metro adicional ( lista-fila ) que se inicializa con la lista (1) y en el que se va guardando cada fila sucesiva. Esta fila va creciendo hasta que llegamos a la fila que tenemos que devolver. Hay que hacer la iteraci\u00f3n n veces, por lo que vamos decrementando el par\u00e1metro n hasta que se llega a 0. Para implementar esta funci\u00f3n usamos otra llamada (pascal-sig-fila lista-fila) que recibe una fila del tri\u00e1ngulo y devuelve la siguiente. Por ejemplo: 1 2 ( pascal-sig-fila ' ( 1 3 3 1 )) ; \u21d2 (1 4 6 4 1) Esta funci\u00f3n la implementamos con una funci\u00f3n recursiva auxiliar (esta es recursiva pura) llamada (pascal-suma-dos-a-dos lista-fila) que es la que se encarga de realizar el c\u00e1lculo de la nueva fila. El c\u00f3digo completo es el siguiente: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ( define ( pascal fila col ) ( list-ref ( pascal-fila ' ( 1 ) fila ) col )) ( define ( pascal-fila lista-fila n ) ( if ( = 0 n ) lista-fila ( pascal-fila ( pascal-sig-fila lista-fila ) ( - n 1 )))) ( define ( pascal-sig-fila lista-fila ) ( append ' ( 1 ) ( pascal-suma-dos-a-dos lista-fila ) ' ( 1 ))) ( define ( pascal-suma-dos-a-dos lista-fila ) ( if ( null? ( cdr lista-fila )) ' () ( cons ( + ( car lista-fila ) ( car ( cdr lista-fila ))) ( pascal-suma-dos-a-dos ( cdr lista-fila ))))) Con esta implementaci\u00f3n ya no se tiene un coste exponencial y se puede calcular el valor de n\u00fameros como Pascal(40, 20): 1 2 ( pascal 40 20 ) ; \u21d2 137846528820","title":"Tri\u00e1ngulo de Pascal"},{"location":"teoria/tema03-procedimientos-recursivos/tema03-procedimientos-recursivos.html#soluciones-al-coste-de-la-recursion-memoization","text":"Una alternativa que mantiene la elegancia de los procesos recursivos y la eficiencia de los iterativos es la memoization . Si miramos la traza de (fibonacci 4) podemos ver que el coste est\u00e1 producido por la repetici\u00f3n de llamadas; por ejemplo (fibonacci 3) se eval\u00faa 2 veces. En programaci\u00f3n funcional la llamada a (fibonacci 3) siempre va a devolver el mismo valor. La idea de la memoization es guardar el valor devuelto por la cada llamada en alguna estructura (una lista de asociaci\u00f3n, por ejemplo) y no volver a realizar la llamada a la recursi\u00f3n las siguientes veces.","title":"Soluciones al coste de la recursi\u00f3n: memoization"},{"location":"teoria/tema03-procedimientos-recursivos/tema03-procedimientos-recursivos.html#fibonacci-con-memoization","text":"Para implementar la memoization necesitamos odos m\u00e9todos imperativos put y get que implementan un diccionario clave-valor . La funci\u00f3n (put key value dic) asocia un valor a una clave, la guarda en el diccionario (con mutaci\u00f3n) y devuelve el valor. La funci\u00f3n (get key dic) devuelve el valor del diccionario asociado a una clave. En el caso en que no exista ning\u00fan valor se devuelve #f . Ejemplos: 1 2 3 4 ( define mi-dic ( crea-diccionario )) ( put 1 10 mi-dic ) ; \u21d2 10 ( get 1 mi-dic ) ; \u21d2 10 ( get 2 mi-dic ) ; \u21d2 #f Estos m\u00e9todos son imperativos porque modifican (mutan) la estructura de datos que pasamos como par\u00e1metro. Para implementarlos tenemos que salirnos del paradigma funcional, usando las funciones de Racket que permiten mutar las parejas. No es importante la implementaci\u00f3n, la dejamos aqu\u00ed como referencia y para poder probar la memoization . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 ( define ( crea-diccionario ) ( mcons ' *diccionario* ' ())) ( define ( busca key dic ) ( cond (( null? dic ) #f ) (( equal? key ( mcar ( mcar dic ))) ( mcar dic )) ( else ( busca key ( mcdr dic ))))) ( define ( get key dic ) ( define record ( busca key ( mcdr dic ))) ( if ( not record ) #f ( mcdr record ))) ( define ( put key value dic ) ( define record ( busca key ( mcdr dic ))) ( if ( not record ) ( set-mcdr! dic ( mcons ( mcons key value ) ( mcdr dic ))) ( set-mcdr! record value )) value ) La funci\u00f3n fib-memo realiza el c\u00e1lculo de la serie de Fibonacci utilizando exactamente la misma definici\u00f3n recursiva original, pero a\u00f1adiendo la t\u00e9cnica de memoization : lo primero que hacemos para calcular el n\u00famero de fibonacci n , antes de llamar a la recursi\u00f3n, es comprobar si est\u00e1 ya guardado en la lista de asociaci\u00f3n. En el caso en que est\u00e9, lo devolvemos. S\u00f3lo cuando el n\u00famero no est\u00e1 calculado llamamos a la recursi\u00f3n para calcularlo. La implementaci\u00f3n se muestra a continuaci\u00f3n. Vemos que para devolver el n\u00famero de fibonacci n se comprueba si ya est\u00e1 guardado en la lista. S\u00f3lo en el caso en que no est\u00e9 guardado se llama a la recursi\u00f3n para calcularlo y guardarlo. La funci\u00f3n put que guarda el nuevo valor calculado tambi\u00e9n lo devuelve. 1 2 3 4 5 6 7 ( define ( fib-memo n dic ) ( cond (( = n 0 ) 0 ) (( = n 1 ) 1 ) (( not ( equal? ( get n dic ) #f )) ( get n dic )) ( else ( put n ( + ( fib-memo ( - n 1 ) dic ) ( fib-memo ( - n 2 ) dic )) dic )))) Podemos comprobar la diferencia de tiempos de ejecuci\u00f3n entre esta versi\u00f3n y la anterior. El coste de la funci\u00f3n memoizada es O(n). Frente al coste O(2^n) de la versi\u00f3n inicial que la hac\u00eda imposible de utilizar. 1 2 ( fib-memo 200 lista ) \u21d2 280571172992510140037611932413038677189525","title":"Fibonacci con memoization"},{"location":"teoria/tema03-procedimientos-recursivos/tema03-procedimientos-recursivos.html#recursion-y-graficos-de-tortuga","text":"Vamos a terminar el apartado sobre procedimientos recursivos con un \u00faltimo ejemplo algo distinto de los vistos hasta ahora. Usaremos la recursi\u00f3n para dibujar figuras fractales usando los denominados gr\u00e1ficos de tortuga . Para dibujar las figuras tendremos que utilizar un estilo de programaci\u00f3n no funcional, dibujando los distintos trazos de las figuras con pasos de ejecuci\u00f3n secuenciales. Para ello usaremos una primitiva imperativa de Scheme: la forma especial begin que permite realizar un grupo de pasos de ejecuci\u00f3n de forma secuencial. Aviso Ten cuidado con la forma especial begin , es una forma especial imperativa. No debes usarla en la implementaci\u00f3n de ninguna funci\u00f3n cuando estemos usando el paradigma funcional.","title":"Recursi\u00f3n y gr\u00e1ficos de tortuga"},{"location":"teoria/tema03-procedimientos-recursivos/tema03-procedimientos-recursivos.html#graficos-de-tortuga-en-racket","text":"Se pueden utilizar los gr\u00e1ficos de tortuga en Racket cargando la librer\u00eda (graphics turtles) : 1 2 #lang racket ( require graphics/turtles ) Los comandos m\u00e1s importantes de esta librer\u00eda son: (turtles #t) : abre una ventana y coloca la tortuga en el centro, mirando hacia el eje X (derecha) (clear) : borra la ventana y coloca la tortuga en el centro (draw d) : avanza la tortuga dibujando d p\u00edxeles (move d) : mueve la tortuga d p\u00edxeles hacia adelante (sin dibujar) (turn g) : gira la tortuga g grados (positivos: en el sentido contrario a las agujas del reloj) Prueba a realizar algunas figuras con los comandos de tortuga, antes de escribir el algoritmo en Scheme del tri\u00e1ngulo de Sierpinski. Por ejemplo, podemos definir una funci\u00f3n que dibuja un tri\u00e1ngulo rect\u00e1ngulo con catetos de longitud x : 1 2 3 4 5 6 7 8 9 10 11 12 13 ( define ( hipot x ) ( * x ( sqrt 2 ))) ( define ( triangulo-rectangulo x ) ( begin ( draw x ) ( turn 90 ) ( draw x ) ( turn 135 ) ( draw ( hipot x )) ( turn 135 ))) ( triangulo-rectangulo 100 ) La funci\u00f3n (hipot x) devuelve la longitud de la hipotenusa de un tri\u00e1ngulo rect\u00e1ngulo con dos lados de longitud x . O sea, la expresi\u00f3n: hipot(x) = \\sqrt{x^2+x^2} = x \\sqrt{2} hipot(x) = \\sqrt{x^2+x^2} = x \\sqrt{2} Como puedes comprobar, el c\u00f3digo es imperativo. La forma especial begin permite realizar una serie de pasos de ejecuci\u00f3n que modifican el estado (posici\u00f3n y orientaci\u00f3n) de la tortuga y dibujan los trazos de la figura. El siguiente c\u00f3digo es una variante del anterior que dibuja un tri\u00e1ngulo rect\u00e1ngulo de base w y lados w/2 . Va a ser la figura base del tri\u00e1ngulo de Sierpinski. 1 2 3 4 5 6 7 8 ( define ( triangle w ) ( begin ( draw w ) ( turn 135 ) ( draw ( hipot ( / w 2 ))) ( turn 90 ) ( draw ( hipot ( / w 2 ))) ( turn 135 )))","title":"Gr\u00e1ficos de tortuga en Racket"},{"location":"teoria/tema03-procedimientos-recursivos/tema03-procedimientos-recursivos.html#triangulo-de-sierpinski","text":"Tri\u00e1ngulo de Sierpinski \u00bfVes alguna recursi\u00f3n en la figura? \u00bfCu\u00e1l podr\u00eda ser el par\u00e1metro de la funci\u00f3n que la dibujara? \u00bfSe te ocurre un algoritmo recursivo que la dibuje? La figura es autosimilar (una caracter\u00edstica de las figuras fractales). Una parte de la figura es id\u00e9ntica a la figura total, pero reducida de escala. Esto nos da una pista de que es posible dibujar la figura con un algoritmo recursivo. Para intentar encontrar una forma de enfocar el problema, vamos a pensarlo de la siguiente forma: supongamos que tenemos un tri\u00e1ngulo de Sierpinski de anchura h y altura h/2 con su esquina inferior izquierda en la posici\u00f3n 0,0. \u00bfC\u00f3mo podr\u00edamos construir el siguiente tri\u00e1ngulo de Sierpinski?. Podr\u00edamos construir un tri\u00e1ngulo de Sierpinski m\u00e1s grande dibujando 3 veces el mismo tri\u00e1ngulo, pero en distintas posiciones: Tri\u00e1ngulo 1 en la posici\u00f3n (0,0) Tri\u00e1ngulo 2 en la posici\u00f3n (h/2,h/2) Tri\u00e1ngulo 3 en la posici\u00f3n (h,0) El algoritmo recursivo se basa en la misma idea, pero hacia atr\u00e1s . Debemos intentar dibujar un tri\u00e1ngulo de altura h situado en la posici\u00f3n x , y bas\u00e1ndonos en 3 llamadas recursivas a tri\u00e1ngulos m\u00e1s peque\u00f1os. En el caso base, cuando h sea menor que un umbral, dibujaremos un tri\u00e1ngulo de lado h y altura h/2 : O sea, que para dibujar un tri\u00e1ngulo de Sierpinski de base h y altura h/2 debemos: Dibujar tres tri\u00e1ngulos de Sierpinsky de la mitad del tama\u00f1o del original ( h/2 ) situadas en las posiciones (x,y) , (x+h/4, y+h/4) y (x+h/2,y) En el caso base de la recursi\u00f3n, en el que h es menor que una constante, se dibuja un tri\u00e1ngulo de base h y altura h/2 . Una versi\u00f3n del algoritmo en pseudoc\u00f3digo : 1 2 3 4 5 6 Sierpinsky (x, y, h): if (h > MIN) { Sierpinsky (x, y, h/2) Sierpinsky (x+h/4, y+h/4, h/2) Sierpinsky (x+h/2, y, h/2) } else dibujaTriangulo (x, y, h)","title":"Tri\u00e1ngulo de Sierpinski"},{"location":"teoria/tema03-procedimientos-recursivos/tema03-procedimientos-recursivos.html#sierpinski-en-racket","text":"La siguiente es una versi\u00f3n imperativa del algoritmo que dibuja el tri\u00e1ngulo de Sierpinski. No es funcional porque se realizan pasos de ejecuci\u00f3n , usando la forma especial begin o m\u00faltiples instrucciones en una misma funci\u00f3n (por ejemplo la funci\u00f3n triangle ). 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #lang racket ( require graphics/turtles ) ( turtles #t ) ( define ( hipot x ) ( * x ( sqrt 2 ))) ( define ( triangle w ) ( begin ( draw w ) ( turn 135 ) ( draw ( hipot ( / w 2 ))) ( turn 90 ) ( draw ( hipot ( / w 2 ))) ( turn 135 ))) ( define ( sierpinski w ) ( if ( > w 20 ) ( begin ( sierpinski ( / w 2 )) ( move ( / w 4 )) ( turn 90 ) ( move ( / w 4 )) ( turn -90 ) ( sierpinski ( / w 2 )) ( turn -90 ) ( move ( / w 4 )) ( turn 90 ) ( move ( / w 4 )) ( sierpinski ( / w 2 )) ( turn 180 ) ( move ( / w 2 )) ( turn -180 )) ;; volvemos a la posici\u00f3n original ( triangle w ))) La llamada a 1 ( sierpinski 40 ) produce la siguiente figura: La llamada a 1 ( sierpinski 700 ) Produce la figura que vimos al principio del apartado: Para ocupar la venta completa debemos desplazar la tortuga hacia atr\u00e1s antes de invocar a sierpinski : 1 2 3 ( clear ) ( move -350 ) ( sierpinski 700 )","title":"Sierpinski en Racket"},{"location":"teoria/tema03-procedimientos-recursivos/tema03-procedimientos-recursivos.html#recursion-mutua","text":"En la recursi\u00f3n mutua definimos una funci\u00f3n en base a una segunda, que a su vez se define en base a la primera. Tambi\u00e9n debe haber un caso base que termine la recursi\u00f3n Por ejemplo: x es par si x-1 es impar x es impar si x-1 es par 0 es par Programas en Scheme: 1 2 3 4 5 6 7 8 9 ( define ( par? x ) ( if ( = 0 x ) #t ( impar? ( - x 1 )))) ( define ( impar? x ) ( if ( = 0 x ) #f ( par? ( - x 1 ))))","title":"Recursi\u00f3n mutua"},{"location":"teoria/tema03-procedimientos-recursivos/tema03-procedimientos-recursivos.html#ejemplo-avanzado-curvas-de-hilbert","text":"La curva de Hilbert es una curva fractal que tiene la propiedad de rellenar completamente el espacio Su dibujo tiene una formulaci\u00f3n recursiva: La curva H3 se puede construir a partir de la curva H2. El algoritmo recursivo se formula dibujando la curva i-\u00e9sima a partir de la curva i-1. Para dibujar una curva de Hilbert de orden i a la derecha de la tortuga: 1 2 3 4 5 6 7 8 9 10 11 1. Gira la tortuga -90 2. Dibuja una curva de orden i-1 a la izquierda 3. Avanza long dibujando 4. Gira 90 5. Dibuja una curva de orden i-1 a la derecha 6. Avanza long dibujando 7. Dibuja una curva de orden i-1 a la derecha 8. Gira 90 9. Avanza long dibujando 10. Dibuja una curva de orden i-1 a la izquierda 11. Gira -90 El algoritmo para dibujar a la izquierda es sim\u00e9trico. Como en la curva de Sierpinsky, utilizamos la librer\u00eda graphics/turtles , que permite usar la tortuga de Logo con los comandos de Logo draw y turn . Definimos dos funciones sim\u00e9tricas, la funci\u00f3n (h-der i long) que dibuja una curva de Hilbert de orden i con una longitud de trazo long a la derecha de la tortuga y la funci\u00f3n (h-izq i w) que dibuja una curva de Hilbert de orden i con una longitud de trazo long a la izquierda de la tortuga. El algoritmo en Scheme: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #lang racket ( require graphics/turtles ) ( define ( h-izq i long ) ( if ( > i 0 ) ( begin ( turn 90 ) ( h-der ( - i 1 ) long ) ( draw long ) ( turn -90 ) ( h-izq ( - i 1 ) long ) ( draw long ) ( h-izq ( - i 1 ) long ) ( turn -90 ) ( draw long ) ( h-der ( - i 1 ) long ) ( turn 90 )) ( move 0 ))) ( define ( h-der i long ) ( if ( > i 0 ) ( begin ( turn -90 ) ( h-izq ( - i 1 ) long ) ( draw long ) ( turn 90 ) ( h-der ( - i 1 ) long ) ( draw long ) ( h-der ( - i 1 ) long ) ( turn 90 ) ( draw long ) ( h-izq ( - i 1 ) long ) ( turn -90 )) ( move 0 ))) Podemos probarlo con distintos par\u00e1metros de grado de curva y longitud de trazo. Curva de Hilbert de nivel 3 con trazo de longitud 20: 1 2 ( clear ) ( h-izq 3 30 ) Para entender mejor el algoritmo podemos dibujar paso a paso esta figura usando los siguientes comandos: 1 2 3 4 5 6 7 8 9 10 11 12 ( clear ) ( turn 90 ) ( h-der 2 30 ) ( draw 30 ) ( turn -90 ) ( h-izq 2 30 ) ( draw 30 ) ( h-izq 2 30 ) ( turn -90 ) ( draw 30 ) ( h-der 2 30 ) ( turn 90 ) Curva de Hilbert de nivel 6 con trazo de longitud 10: 1 2 3 4 5 6 ( clear ) ( move -350 ) ( turn -90 ) ( move 350 ) ( turn 90 ) ( h-izq 6 10 ) Curva de Hilbert de nivel 7 con trazo de longitud 5: 1 2 3 4 5 6 ( clear ) ( move -350 ) ( turn -90 ) ( move 350 ) ( turn 90 ) ( h-izq 7 5 )","title":"Ejemplo avanzado: curvas de Hilbert"},{"location":"teoria/tema03-procedimientos-recursivos/tema03-procedimientos-recursivos.html#bibliografia-sicp","text":"En este tema explicamos conceptos de los siguientes cap\u00edtulos del libro Structure and Intepretation of Computer Programs : 1.2 - Procedures and the Processes They Generate 1.2.1 - Linear Recursion and Iteration 1.2.2 - Tree Recursion Lenguajes y Paradigmas de Programaci\u00f3n, curso 2019-20 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Domingo Gallardo, Cristina Pomares, Antonio Bot\u00eda, Francisco Mart\u00ednez","title":"Bibliograf\u00eda - SICP"},{"location":"teoria/tema04-estructuras-recursivas/tema04-estructuras-recursivas.html","text":"Tema 4: Estructuras de datos recursivas \u00b6 Listas estructuradas \u00b6 Hemos visto que las listas en Scheme se implementan como un estructura de datos recursiva, formada por una pareja que enlaza en su parte derecha el resto de la lista y que termina con una parte derecha en la que hay una lista vac\u00eda. En este apartado vamos a volver a estudiar las listas desde un nivel de abstracci\u00f3n alto, usando las funciones: (car lista) para obtener el primer elemento de una lista (cdr lista) para obtener el resto de la lista (cons dato lista) para construir una nueva lista con el dato como primer elemento En la mayor\u00eda de funciones y ejemplos que hemos visto hasta ahora las listas est\u00e1n formadas por datos y el recorrido por la lista es un recorrido lineal, iterando por sus elementos. En este apartado vamos a ampliar este concepto y estudiar c\u00f3mo trabajar con listas que contienen otras listas . Veremos que esto cambia fundamentalmente la estructura de las listas y de las funciones que van a operar con ellas. El cambio fundamental es que la funci\u00f3n car lista puede devolver dos tipos de elementos: Un elemento de la lista (del tipo de elementos que hay en la lista) Otra lista (formada por el tipo de elementos de la lista) Definici\u00f3n y ejemplos \u00b6 Las listas en Scheme pueden tener cualquier tipo de elementos, incluido otras listas. Llamaremos lista estructurada a una lista que contiene otras sublistas. Lo contrario de lista estructurada es una lista plana , una lista formada por elementos que no son listas. Llamaremos hojas a los elementos de una lista que no son sublistas. A las listas estructuradas cuyas hojas son s\u00edmbolos se les denomina en el contexto de la programaci\u00f3n funcional expresiones-S ( S-expression ). Por ejemplo, la lista estructurada: 1 (a b (c d e) (f (g h))) es una lista estructurada con 4 elementos: El elemento 'a , una hoja El elemento 'b , otra hoja La lista plana (c d e) La lista estructurada (f (g h)) Se puede construir con cualquiera de las siguientes expresiones: 1 2 ( define lista ( list ' a ' b ( list ' c ' d ' e ) ( list ' f ( list ' g ' h )))) ( define lista ' ( a b ( c d e ) ( f ( g h )))) Una lista formada por parejas la consideraremos una lista plana, ya que no contiene ninguna sublista. Por ejemplo, la lista 1 (( a . 3 ) ( b . 5 ) ( c . 12 )) es una lista plana de tres elementos (hojas) que son parejas. Definiciones en Scheme Vamos a escribir las definiciones anteriores de hoja , plana y estructurada usando c\u00f3digo de Scheme. Funci\u00f3n (hoja? dato) Definimos una hoja como aquellos elementos de una lista estructurada que no son listas: 1 2 ( define ( hoja? elem ) ( not ( list? elem ))) Utilizaremos esta funci\u00f3n para comprobar si un determinado elemento de una lista es o no una hoja. Por ejemplo, supongamos la siguiente lista: 1 (( 1 2 ) 3 4 ( 5 6 )) Es una lista de 4 elementos, siendo el primero y el \u00faltimo otras sublistas y el segundo y el tercero hojas. Podemos comprobar si son o no hojas sus elementos: 1 2 3 4 5 ( define lista ' (( 1 2 ) 3 4 ( 5 6 ))) ( hoja? ( car lista )) ; \u21d2 #f ( hoja? ( cadr lista )) ; \u21d2 #t ( hoja? ( caddr lista )) ; \u21d2 #t ( hoja? ( cadddr lista )) ; \u21d2 #f La lista vac\u00eda no es una hoja 1 ( hoja? ' ()) ; \u21d2 #f Funci\u00f3n (plana? lista) Como hemos dicho antes, una lista es plana cuando todos sus elementos son hojas. Queremos implementar la funci\u00f3n (plana? lista) que lo compruebe. Por ejemplo: 1 2 3 4 ( plana? ' ( a b c d e f )) ; \u21d2 #t ( plana? ( list ( cons ' a 1 ) \"Hola\" #f )) ; \u21d2 #t ( plana? ' ( a ( b c ) d )) ; \u21d2 #f ( plana? ' ( a () b )) ; \u21d2 #f Una definici\u00f3n recursiva de lista plana: Una lista es plana si y solo si el primer elemento es una hoja y el resto es plana. Y el caso base: Una lista vac\u00eda es plana. Usando esta definici\u00f3n recursiva, podemos implementar en Scheme la funci\u00f3n (plana? lista) que comprueba si una lista es plana: 1 2 3 4 ( define ( plana? lista ) ( or ( null? lista ) ( and ( hoja? ( car lista )) ( plana? ( cdr lista ))))) Se podr\u00eda tambi\u00e9n implementar la funci\u00f3n plana? usando la funci\u00f3n de orden superior for-all? que comprueba que todos los elementos de una lista cumplen una propiedad. En esta caso, ser hoja. 1 2 ( define ( plana-fos? lista ) ( for-all? hoja? lista )) Funci\u00f3n for-all? Recordemos que la funci\u00f3n (for-all? predicado lista) se implementa de la siguiente forma: 1 2 3 4 ( define ( for-all? predicado lista ) ( or ( null? lista ) ( and ( predicado ( car lista )) ( for-all? predicado ( cdr lista ))))) Funci\u00f3n (estructurada? lista) Una lista es estructurada cuando alguno de sus elementos es otra lista. Como caso base, una lista vac\u00eda no es estructurada. Queremos implementar la funci\u00f3n (estructurada? lista) que compruebe si una lista es estructurada. 1 2 3 4 ( estructurada? ' ( 1 2 3 4 )) ; \u21d2 #f ( estructurada? ( list ( cons ' a 1 ) ( cons ' b 2 ) ( cons ' c 3 ))) ; \u21d2 #f ( estructurada? ' ( a () b )) ; \u21d2 #t ( estructurada? ' ( a ( b c ) d )) ; \u21d2 #t 1 2 3 4 ( define ( estructurada? lista ) ( and ( not ( null? lista )) ( or ( list? ( car lista )) ( estructurada? ( cdr lista ))))) Se podr\u00eda implementar tambi\u00e9n usando la funci\u00f3n de orden superior exists? para consultar si alg\u00fan elemento de la lista es tambi\u00e9n otra lista. 1 2 ( define ( estructurada-fos? lista ) ( exists? list? lista )) Funci\u00f3n exists? Recordemos que la funci\u00f3n (exists? predicado lista) se implementa de la siguiente forma: 1 2 3 4 5 ( define ( exists? predicado lista ) ( if ( null? lista ) #f ( or ( predicado ( car lista )) ( exists? predicado ( cdr lista ))))) Realmente bastar\u00eda con haber hecho una de las dos definiciones y escribir la otra como la negaci\u00f3n de la primera: 1 2 ( define ( estructurada? lista ) ( not ( plana? lista ))) Ejemplos de listas estructuradas Las listas estructuradas son muy \u00fatiles para representar informaci\u00f3n jer\u00e1rquica en donde queremos representar elementos que contienen otros elementos. Por ejemplo, las expresiones de Scheme son listas estructuradas: 1 2 3 ( = 4 ( + 2 2 )) ( if ( = x y ) ( * x y ) ( + ( / x y ) 45 )) ( define ( factorial x ) ( if ( = x 0 ) 1 ( * x ( factorial ( - x 1 ))))) El an\u00e1lisis sint\u00e1ctico de una oraci\u00f3n puede generar una lista estructurada de s\u00edmbolos, en donde se agrupan los distintos elementos de la oraci\u00f3n: 1 (( Juan ) ( compr\u00f3 ) ( la entrada ( de la pel\u00edcula )) ( el viernes por la tarde )) Una p\u00e1gina HTML, con sus distintos elementos, unos dentro de otros, tambi\u00e9n se puede representar con una lista estructurada: 1 2 3 4 (( <h1> Mi lista de la compra </h1> ) ( <ul> ( <li> naranjas </li> ) ( <li> tomates </li> ) ( <li> huevos </li> ) </ul> )) Pseudo \u00e1rboles con niveles Las listas estructuradas definen una estructura de niveles, donde la lista inicial representa el primer nivel, y cada sublista representa un nivel inferior. Los datos de las listas representan las hojas. Por ejemplo, la representaci\u00f3n en forma de niveles de la lista ((a b c) d e) es la siguiente: Cada asterisco * representa una lista. Las ramas que salen del asterisco representan los elementos de la lista. En el ejemplo tenemos en un primer nivel una lista con 3 elementos: la lista (a b c) , d y e . Y en el segundo nivel se encuentra la lista (a b c) cuyos 3 elementos son hojas. Las hojas d y e est\u00e1n en el nivel 1 y en las posiciones 2 y 3 de la lista y las hojas a , b y c en el nivel 2. Una lista estructurada no es un \u00e1rbol Una lista estructurada no es un \u00e1rbol propiamente dicho, porque un \u00e1rbol tiene datos en todos los nodos, mientras que en la lista estructurada los datos est\u00e1n s\u00f3lo en las hojas. Las listas estructuradas sirven para agrupar de forma jer\u00e1rquica un conjunto de datos en distintos niveles. A pesar de ser distintas de los \u00e1rboles, ambas son estructuras de datos jer\u00e1rquicas (con niveles) que se pueden definir de forma recursiva y sobre las que se pueden definir algoritmos recursivos. Veremos m\u00e1s adelante c\u00f3mo definir y trabajar con \u00e1rboles en Scheme. Otro ejemplo. \u00bfCu\u00e1l ser\u00eda la representaci\u00f3n en niveles de la siguiente lista estructurada?: 1 ( map ( lambda ( x ) ( + x 10 )) ( quote ( 1 2 3 4 ))) Funciones recursivas sobre listas estructuradas \u00b6 N\u00famero de hojas Veamos como primer ejemplo la funci\u00f3n (num-hojas lista) que cuenta el n\u00famero de hojas de una lista estructurada. Por ejemplo: 1 ( num-hojas ' (( 1 2 ) ( 3 4 ( 5 ) 6 ) ( 7 ))) ; \u21d2 7 Como hemos comentado antes, una cuesti\u00f3n clave en las funciones que vamos a construir sobre listas estructuradas es que el car de una lista estructurada puede ser a su vez otra lista. Para calcular el n\u00famero de hojas de una lista podemos obtener el primer elemento y el resto de la lista, y contar recursivamente el n\u00famero de hojas del primer elemento y del resto. Al ser una lista estructurada, el primer elemento puede ser a su vez otra lista, por lo que llamamos a la recursi\u00f3n para contar sus hojas. La definici\u00f3n de este caso general usando pseudoc\u00f3digo es: El n\u00famero de hojas de una lista estructurada es la suma del n\u00famero de hojas de su primer elemento (que puede ser otra lista) y del n\u00famero de hojas del resto. La recursi\u00f3n tiene dos llamadas recursivas. Una que recibe el elemento de la cabeza de la lista y otra que recibe el resto de la lista. 1 2 3 4 5 ;Caso general num-hojas ( define ( num-hojas lista ) ; Falta caso base ( + ( num-hojas ( car lista )) ( num-hojas ( cdr lista )))) No hay coste exponencial A pesar de haber dos llamadas recursivas, no pasa lo mismo que en Fibonacci o Pascal ya que no se van a repetir llamadas a la recursi\u00f3n con los mismos datos. La recursi\u00f3n recorre la lista estructurada y su coste ser\u00e1 el n\u00famero de elementos de la lista. Para considerar el caso base , veamos c\u00f3mo las llamadas recursivas reciben cada vez un problema m\u00e1s peque\u00f1o. La llamada recursiva sobre el resto de la lista recibe cada vez una lista con 1 elemento menos. Al final se llamar\u00e1 a la funci\u00f3n con una lista vac\u00eda. Ese ser\u00e1 un caso base. El n\u00famero de elementos de una lista vac\u00eda es 0. La llamada recursiva sobre la cabeza de la lista es algo distinta. Recibe una lista en la que se ha descendido un nivel y tiene, por tanto, un nivel menos. Al final se llamar\u00e1 a la funci\u00f3n con una hoja (un dato). Ese ser\u00e1 el otro caso base y habr\u00e1 que devolver 1. La definici\u00f3n completa de la funci\u00f3n queda de la siguiente forma: 1 2 3 4 5 6 ( define ( num-hojas elem ) ( cond (( null? elem ) 0 ) (( hoja? elem ) 1 ) ( else ( + ( num-hojas ( car elem )) ( num-hojas ( cdr elem )))))) Hay que hacer notar que el par\u00e1metro elem puede ser tanto una lista como un dato at\u00f3mico (una hoja). Estamos aprovech\u00e1ndonos de la caracter\u00edstica de Scheme de ser d\u00e9bilmente tipado para hacer un c\u00f3digo bastante conciso. Versi\u00f3n con funciones de orden superior Podemos usar tambi\u00e9n las funciones de orden superior map y foldr para obtener una versi\u00f3n m\u00e1s concisa. Una lista estructurada tiene como elementos en un primer nivel hojas o otras sublistas. Podemos entonces mapear una expresi\u00f3n lambda que se aplica a cada uno de esos elementos. En la expresi\u00f3n lambda comprobamos si el elemento (el par\u00e1metro sublista de la expresi\u00f3n lambda) es una hoja o una lista. En el primero caso devolvemos 1. En el segundo aplicaremos la propia funci\u00f3n que estamos definiendo sobre la sublista, con lo que se devolver\u00e1 el n\u00famero de hojas de esa sublista. El resultado del map ser\u00e1 una lista de n\u00fameros (el n\u00famero de hojas de cada componente), que podemos sumar haciendo un fold-right con la funci\u00f3n + : 1 2 3 4 5 ( define ( num-hojas-fos lista ) ( fold-right + 0 ( map ( lambda ( elem ) ( if ( hoja? elem ) 1 ( num-hojas-fos elem ))) lista ))) Una explicaci\u00f3n gr\u00e1fica de c\u00f3mo funciona la funci\u00f3n sobre la lista (1 (2 3) (4) (5 (6 7) 8)) : Altura de una lista estructurada La altura de una lista estructurada viene dada por su n\u00famero de niveles: una lista plana tiene una altura de 1, la lista ((1 2 3) 4 5) tiene una altura de 2. Para calcular la altura de una lista estructurada tenemos que obtener (de forma recursiva) la altura de su primer elemento, y la altura del resto de la lista, sumarle 1 a la altura del primer elemento y devolver el m\u00e1ximo de los dos n\u00fameros. Como casos base, la altura de una lista vac\u00eda o de una hoja (dato) es 0. En Scheme: 1 2 3 4 5 6 ( define ( altura elem ) ( cond (( null? elem ) 0 ) (( hoja? elem ) 0 ) ( else ( max ( + 1 ( altura ( car elem ))) ( altura ( cdr elem )))))) Por ejemplo: 1 2 ( altura ' ( 1 ( 2 3 ) 4 )) ; \u21d2 2 ( altura ' ( 1 ( 2 ( 3 )) 3 )) ; \u21d2 3 Versi\u00f3n con funciones de orden superior Y la segunda versi\u00f3n, usando las funciones de orden superior map para obtener la altura de sus elementos del primer nivel (puedes ser hojas o sublistas) y fold-right para quedarse con el m\u00e1ximo de la lista de valores que devuelve el map. 1 2 3 4 5 ( define ( altura-fos lista ) ( + 1 ( fold-right max 0 ( map ( lambda ( elem ) ( if ( hoja? elem ) 0 ( altura-fos elem ))) lista )))) Otras funciones recursivas Vamos a dise\u00f1ar otras funciones recursivas que trabajan con la estructura jer\u00e1rquica de las listas estructuradas. (aplana lista) : devuelve una lista plana con todas las hojas de la lista (pertenece-lista? dato lista) : busca una hoja en una lista estructurada (nivel-hoja dato lista) : devuelve el nivel en el que se encuentra un dato en una lista (cuadrado-estruct lista) : eleva todas las hojas al cuadrado (suponemos que la lista estructurada contiene n\u00fameros) (map-estruct f lista) : similar a map, aplica una funci\u00f3n a todas las hojas de la lista estructurada y devuelve el resultado (otra lista estructurada) (aplana lista) Devuelve una lista plana con todas las hojas de la lista. Por ejemplo: 1 2 ( aplana ' ( 1 2 ( 3 ( 4 ( 5 ))) ((( 6 ))))) ; \u21d2 (1 2 3 4 5 6) La soluci\u00f3n recursiva es: 1 2 3 4 5 6 7 ( define ( aplana elem ) ( cond (( null? elem ) ' ()) (( hoja? elem ) ( list elem )) ( else ( append ( aplana ( car elem )) ( aplana ( cdr elem )))))) Con funciones de orden superior: 1 2 3 4 5 6 7 ( define ( aplana-fos lista ) ( fold-right append ' () ( map ( lambda ( elem ) ( if ( hoja? elem ) ( list elem ) ( aplana-fos elem ))) lista ))) (pertenece-lista? dato lista) Comprueba si el dato aparece en la lista estructurada. 1 2 ( pertenece? ' a ' ( b c ( d ( a )))) ; \u21d2 #t ( pertenece? ' a ' ( b c ( d e ( f )) g )) ; \u21d2 #f Soluci\u00f3n recursiva: 1 2 3 4 5 6 ( define ( pertenece? dato elem ) ( cond (( null? elem ) #f ) (( hoja? elem ) ( equal? dato elem )) ( else ( or ( pertenece? dato ( car elem )) ( pertenece? dato ( cdr elem )))))) Con funciones de orden superior: 1 2 3 4 5 ( define ( pertenece-fos? dato lista ) ( exists ( lambda ( elem ) ( if ( hoja? elem ) ( equal? dato elem ) ( pertenece-fos? dato elem ))) lista )) (nivel-hoja dato lista) Veamos una \u00faltima funci\u00f3n (nivel-hoja dato lista) que recorre una lista estructurada buscando el dato y devuelve el nivel en que se encuentra. Si el dato no se encuentra en la lista, se devolver\u00e1 -1. Si el dato se encuentra en m\u00e1s de un lugar de la lista se devolver\u00e1 el nivel mayor. Ejemplos: 1 2 3 4 ( nivel-hoja ' b ' ( a b ( c ))) ; \u21d2 1 ( nivel-hoja ' b ' ( a ( b ) c )) ; \u21d2 2 ( nivel-hoja ' b ' ( a ( b ) d (( b )))) ; \u21d2 3 ( nivel-hoja ' b ' ( a c d (( e )))) ; \u21d2 -1 Soluci\u00f3n recursiva: 1 2 3 4 5 6 7 ( define ( nivel-hoja dato elem ) ( cond (( null? elem ) -1 ) (( hoja? elem ) ( if ( equal? elem dato ) 0 -1 )) ( else ( max ( suma-1-si-mayor-igual-que-0 ( nivel-hoja dato ( car elem ))) ( nivel-hoja dato ( cdr elem )))))) La funci\u00f3n auxiliar se define de la siguiente forma: 1 2 3 4 ( define ( suma-1-si-mayor-igual-que-0 x ) ( if ( >= x 0 ) ( + x 1 ) x )) Con funciones de orden superior: 1 2 3 4 5 6 7 8 ( define ( nivel-hoja-fos dato lista ) ( suma-1-si-mayor-igual-que-0 ( fold-right max -1 ( map ( lambda ( elem ) ( if ( hoja? elem ) ( if ( equal? elem dato ) 0 -1 ) ( nivel-hoja-fos dato elem ))) lista )))) Se puede hacer otra versi\u00f3n de la funci\u00f3n anterior, que aproveche que Scheme es un lenguaje d\u00e9bilmente tipado y que devuelva #f si el dato no se encuentra: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ( define ( incrementa-nivel-si-encontrado x ) ( if ( not x ) x ( + x 1 ))) ( define ( mayor-nivel-si-encontrado x y ) ( cond (( not x ) y ) (( not y ) x ) ( else ( max x y )))) ( define ( nivel-hoja2 dato elem ) ( cond (( null? elem ) #f ) (( hoja? elem ) ( if ( equal? x dato ) 0 #f )) ( else ( mayor-nivel-si-encontrado ( incrementa-nivel-si-encontrado ( nivel-hoja dato ( car elem ))) ( nivel-hoja2 dato ( cdr elem )))))) Las funciones auxiliares incrementa-nivel-si-encontrado y mayor-nivel-si-encontrado realizan la suma de 1 y calculan el m\u00e1ximo tratando con los casos en los que alguno de los argumentos es #f porque no se ha encontrado el dato. Ejemplos: 1 2 3 4 ( nivel-hoja2 ' b ' ( a b ( c ))) ; \u21d2 1 ( nivel-hoja2 ' b ' ( a ( b ) c )) ; \u21d2 2 ( nivel-hoja2 ' b ' ( a ( b ) d (( b )))) ; \u21d2 3 ( nivel-hoja2 ' b ' ( a c d (( e )))) ; \u21d2 #f (cuadrado-estruct lista) Vamos ahora a ver un tipo de funci\u00f3n distinta. Una que construye una lista estructurada y la devuelve. Queremos implementar la funci\u00f3n (cuadrado-estruct lista) que recibe una lista estructurada y devuelve otra lista estructurada con la misma estructura y sus n\u00fameros elevados al cuadrado. Por ejemplo: 1 ( cuadrado-estruct ' ( 2 3 ( 4 ( 5 )))) ; \u21d2 (4 9 (16 (25)) La soluci\u00f3n recursiva es: 1 2 3 4 5 ( define ( cuadrado-estruct elem ) ( cond (( null? elem ) ' ()) (( hoja? elem ) ( * elem elem )) ( else ( cons ( cuadrado-estruct ( car elem )) ( cuadrado-estruct ( cdr elem )))))) Se llama a la recursi\u00f3n con el car y con el cdr de la lista original. El resultado de ambas llamadas ser\u00e1n las correspondientes listas estructuradas con sus elementos elevados al cuadrado. Y se devuelve la lista resultante de insertar la lista devuelta en la llamada recursiva con el car en la primera posici\u00f3n de la lista devuelta en la llamada recursiva con el cdr . Es muy interesante la versi\u00f3n de esta funci\u00f3n con funciones de orden superior: 1 2 3 4 5 ( define ( cuadrado-estruct-fos lista ) ( map ( lambda ( elem ) ( if ( hoja? elem ) ( * elem elem ) ( cuadrado-estruct-fos elem ))) lista )) Como una lista estructurada est\u00e1 compuesta de datos o de otras sublistas podemos aplicar map para que devuelva la lista resultante de transformar la original con la funci\u00f3n que le pasamos como par\u00e1metro. (map-estruct f lista) Podemos generalizar la funci\u00f3n anterior y definir la funci\u00f3n de orden superior sobre listas estructuradas (map-estructurada f lista) que devuelve una lista estructurada igual que la original con el resultado de aplicar a cada uno de sus hojas la funci\u00f3n f Por ejemplo: 1 ( map-estruct ( lambda ( x ) ( * x x )) ' ( 2 3 ( 4 ( 5 )))) ; \u21d2 (4 9 (16 (25)) La soluci\u00f3n recursiva es una generalizaci\u00f3n de la funci\u00f3n anterior, usando el par\u00e1metro f : 1 2 3 4 5 ( define ( map-estruct f elem ) ( cond (( null? elem ) ' ()) (( hoja? elem ) ( f elem )) ( else ( cons ( map-estruct f ( car elem )) ( map-estruct f ( cdr elem )))))) Soluci\u00f3n con map : 1 2 3 4 5 ( define ( map-estruct-fos f lista ) ( map ( lambda ( elem ) ( if ( hoja? elem ) ( f elem ) ( map-estruct-fos f elem ))) lista )) Bibliograf\u00eda - SICP \u00b6 En este tema explicamos conceptos de los siguientes cap\u00edtulos del libro Structure and Intepretation of Computer Programs : 2.2.2 - Hierarchical Structures Lenguajes y Paradigmas de Programaci\u00f3n, curso 2019-20 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Domingo Gallardo, Cristina Pomares, Antonio Bot\u00eda, Francisco Mart\u00ednez","title":"Tema 4: Estructuras recursivas"},{"location":"teoria/tema04-estructuras-recursivas/tema04-estructuras-recursivas.html#tema-4-estructuras-de-datos-recursivas","text":"","title":"Tema 4: Estructuras de datos recursivas"},{"location":"teoria/tema04-estructuras-recursivas/tema04-estructuras-recursivas.html#listas-estructuradas","text":"Hemos visto que las listas en Scheme se implementan como un estructura de datos recursiva, formada por una pareja que enlaza en su parte derecha el resto de la lista y que termina con una parte derecha en la que hay una lista vac\u00eda. En este apartado vamos a volver a estudiar las listas desde un nivel de abstracci\u00f3n alto, usando las funciones: (car lista) para obtener el primer elemento de una lista (cdr lista) para obtener el resto de la lista (cons dato lista) para construir una nueva lista con el dato como primer elemento En la mayor\u00eda de funciones y ejemplos que hemos visto hasta ahora las listas est\u00e1n formadas por datos y el recorrido por la lista es un recorrido lineal, iterando por sus elementos. En este apartado vamos a ampliar este concepto y estudiar c\u00f3mo trabajar con listas que contienen otras listas . Veremos que esto cambia fundamentalmente la estructura de las listas y de las funciones que van a operar con ellas. El cambio fundamental es que la funci\u00f3n car lista puede devolver dos tipos de elementos: Un elemento de la lista (del tipo de elementos que hay en la lista) Otra lista (formada por el tipo de elementos de la lista)","title":"Listas estructuradas"},{"location":"teoria/tema04-estructuras-recursivas/tema04-estructuras-recursivas.html#definicion-y-ejemplos","text":"Las listas en Scheme pueden tener cualquier tipo de elementos, incluido otras listas. Llamaremos lista estructurada a una lista que contiene otras sublistas. Lo contrario de lista estructurada es una lista plana , una lista formada por elementos que no son listas. Llamaremos hojas a los elementos de una lista que no son sublistas. A las listas estructuradas cuyas hojas son s\u00edmbolos se les denomina en el contexto de la programaci\u00f3n funcional expresiones-S ( S-expression ). Por ejemplo, la lista estructurada: 1 (a b (c d e) (f (g h))) es una lista estructurada con 4 elementos: El elemento 'a , una hoja El elemento 'b , otra hoja La lista plana (c d e) La lista estructurada (f (g h)) Se puede construir con cualquiera de las siguientes expresiones: 1 2 ( define lista ( list ' a ' b ( list ' c ' d ' e ) ( list ' f ( list ' g ' h )))) ( define lista ' ( a b ( c d e ) ( f ( g h )))) Una lista formada por parejas la consideraremos una lista plana, ya que no contiene ninguna sublista. Por ejemplo, la lista 1 (( a . 3 ) ( b . 5 ) ( c . 12 )) es una lista plana de tres elementos (hojas) que son parejas.","title":"Definici\u00f3n y ejemplos"},{"location":"teoria/tema04-estructuras-recursivas/tema04-estructuras-recursivas.html#funciones-recursivas-sobre-listas-estructuradas","text":"","title":"Funciones recursivas sobre listas estructuradas"},{"location":"teoria/tema04-estructuras-recursivas/tema04-estructuras-recursivas.html#bibliografia-sicp","text":"En este tema explicamos conceptos de los siguientes cap\u00edtulos del libro Structure and Intepretation of Computer Programs : 2.2.2 - Hierarchical Structures Lenguajes y Paradigmas de Programaci\u00f3n, curso 2019-20 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Domingo Gallardo, Cristina Pomares, Antonio Bot\u00eda, Francisco Mart\u00ednez","title":"Bibliograf\u00eda - SICP"},{"location":"teoria/tema05-bis-programacion-imperativa/ambitos-let-clousures.html","text":"6. \u00c1mbitos de variables, let y closures \u00b6 Ahora que hemos introducido la forma especial lambda y la idea de que una funci\u00f3n es un objeto de primera clase, podemos revisar el concepto de \u00e1mbito de variables en Scheme e introducir un importante concepto: clausura ( closure en ingl\u00e9s). 6.1. \u00c1mbitos de variables \u00b6 El concepto del \u00e1mbito de vida de las variables es un concepto fundamental en los lenguajes de programaci\u00f3n. En ingl\u00e9s se utiliza el t\u00e9rmino scope . Cuando se define una variable, asoci\u00e1ndole un valor, esta asociaci\u00f3n tiene una extensi\u00f3n determinada, ya sea en t\u00e9rminos de tiempo de compilaci\u00f3n ( \u00e1mbito l\u00e9xico ) como en t\u00e9rminos de tiempo de ejecuci\u00f3n ( \u00e1mbito din\u00e1mico ). El \u00e1mbito de una variable determina cu\u00e1ndo podemos referirnos a ella para recuperar el valor asociado. Al conjunto de variables disponibles en una parte del programa o en una parte de su ejecuci\u00f3n se denomina contexto o entorno ( context o environment ). Variables de \u00e1mbito global Una variable definida en el programa con la instrucci\u00f3n define tiene un \u00e1mbito global. 1 2 3 (define a \"hola\") (define b (string-append \"adios\" a)) (define cuadrado (lambda (x) (* x x))) Todas las variables definidas fuera de funciones forman parte del entorno global del programa. Variables de \u00e1mbito local Como en la mayor\u00eda de lenguajes de programaci\u00f3n, en Scheme se crea un entorno local cada vez que se invoca a una funci\u00f3n. En este entorno local los argumentos de la funci\u00f3n toman los valores de los par\u00e1metros usados en la llamada a la funci\u00f3n. Consideramos, por tanto, estos par\u00e1metros como variables de \u00e1mbito local de la funci\u00f3n. Podemos usar en un entorno local una variable con el mismo nombre que en el entorno global. Cuando se ejecute el c\u00f3digo de la funci\u00f3n se evaluar\u00e1 la variable de \u00e1mbito local. Por ejemplo, supongamos las expresiones: 1 2 3 4 5 6 ( define x 5 ) ( define ( suma-3 x ) ( + x 3 )) ( suma-3 12 ) \u21d2 15 Cuando se ejecuta la expresi\u00f3n (+ x 3) en la invocaci\u00f3n a (suma-3 12) el valor de x es 12, no es 5, devolvi\u00e9ndose 15. Una vez realizada la invocaci\u00f3n, desparece el entorno local y las variables locales definidas en \u00e9l, recuper\u00e1ndose el contexto global. Por ejemplo, en la siguiente expresi\u00f3n, una vez realizada la invocaci\u00f3n a (suma-3 12) se devuelve el n\u00famero 15 y se eval\u00faa en el entorno global la expresi\u00f3n (+ 15 x) . En este contexto la variable x vale 5 por lo que la expresi\u00f3n devuelve 20. 1 2 3 4 5 6 ( define x 5 ) ( define ( suma-3 x ) ( + x 3 )) ( + ( suma-3 12 ) x ) \u21d2 20 En el entorno local tambi\u00e9n se pueden utilizar variables definidas en el entorno global. Por ejemplo: 1 2 3 4 5 6 ( define y 12 ) ( define ( suma - 3 - bis x ) ( + x y 3 )) ( suma - 3 - bis 5 ) \u21d2 20 La expresi\u00f3n (+ x 3 y) se eval\u00faa en el entorno local en el que x vale 5. Al no estar definida la variable y en este entorno local, se usa su definici\u00f3n de \u00e1mbito global. 6.2 Forma especial let \u00b6 Forma especial let En Scheme se define la forma especial let que permite crear un entorno local en el que se da valor a variables y se eval\u00faa una expresi\u00f3n. Sintaxis: 1 2 3 4 ( let (( <var1> <exp-1> ) ... ( <varn> <exp-n> )) <cuerpo> ) Las variables var1 , \u2026 varn toman los valores devueltos por las expresiones exp1 , \u2026 expn y el cuerpo se eval\u00faa con esos valores. Por ejemplo: 1 2 3 4 5 6 7 ( define x 10 ) ( define y 20 ) ( let (( x 1 ) ( y 2 ) ( z 3 )) ( + x y z )) \u21d2 6 El \u00e1mbito de las variables definidas en el let es local Las variables definidas en el let s\u00f3lo tienen valores en el entorno creado por la forma especial. 1 2 3 4 5 6 7 ( define x 10 ) ( define y 20 ) ( let (( x 1 ) ( y 2 ) ( z 3 )) ( + x y z )) \u21d2 6 Cuando ha terminado la evaluaci\u00f3n del let el \u00e1mbito local desaparece y quedan los valores definidos en el \u00e1mbito global. 1 2 x \u21d2 5 y \u21d2 error, no definida Let permite usar variables definidas en un \u00e1mbito en el que se ejecuta el let Al igual que en la invocaci\u00f3n a funciones, desde el \u00e1mbito definido por el let se puede usar las variables del entorno en el que se est\u00e1 ejecutando el let . Por ejemplo, en el siguiente c\u00f3digo se usa la variable z definida en el \u00e1mbito global. 1 2 3 4 5 ( define z 8 ) ( let (( x 1 ) ( y 2 )) ( + x y z )) \u21d2 11 Variables en las definiciones del let Las expresiones que dan valor a las variables del let se eval\u00faan todas en el entorno en el que se ejecuta el let , antes de crear las variables locales. No se realiza una asignaci\u00f3n secuencial: 1 2 3 4 ( define x 1 ) ( let (( w ( + x 3 )) ( z ( + w 2 ))) ;; Error: w no est\u00e1 definida ( + w z )) Sem\u00e1ntica del let Para evaluar una expresi\u00f3n let debemos seguir las siguientes reglas: Evaluar todas las expresiones de la derecha de las variables y guardar sus valores en variables auxiliares locales. Definir un \u00e1mbito local en el que se ligan las variables del let con los valores de las variables auxiliares. Evaluar el cuerpo del let en el \u00e1mbito local Let se define utilizando lambda La sem\u00e1ntica anterior queda clara cuando comprobamos que let se puede definir en funci\u00f3n de lambda. En general, la expresi\u00f3n: 1 ( let (( <var1> <exp1> ) ... ( <varn> <expn> )) <cuerpo> ) se puede implementar con la siguiente llamada a lambda: 1 (( lambda ( <var1> ... <varn> ) <cuerpo> ) <exp1> ... <expn> ) Para ejecutar un let con un lambda se debe crear un procedimiento en tiempo de ejecuci\u00f3n con tantas variables como las variables del let , con el cuerpo del let , y se debe invocar a dicho procedimiento con las expresiones de las variables del let . Esas expresiones se eval\u00faan antes de invocar al procedimiento y la invocaci\u00f3n se realiza con los resultados. La invocaci\u00f3n crea un entorno local con los par\u00e1metros del procedimiento (las variables del let ) asociados a los valores, y en este \u00e1mbito local se ejecuta el cuerpo del procedimiento (el cuerpo del let ). Por ejemplo: 1 2 3 (let ((x (+ 2 3)) (y (+ x 3))) (+ x y)) Equivale a: 1 (( lambda ( x y ) ( + x y )) ( + 2 3 ) ( + x 3 )) Let dentro de funciones Podemos usar let en el cuerpo de funciones para crear nuevas variables locales, adem\u00e1s de los par\u00e1metros de la funci\u00f3n 1 2 3 4 5 6 ( define ( suma-cuadrados x y ) ( let (( cuadrado-x ( cuadrado x )) ( cuadrado-y ( cuadrado y ))) ( + cuadrado-x cuadrado-y ))) ( suma-cuadrados 4 10 ) \u21d2 116 Cuando se invoca (suma-cuadrados 4 10) se crea un entorno local en el que las variables x e y toman el valor 4 y 10 y en el que se ejecuta la forma especial let . Esta forma especial crea a su vez un entorno local en el que se definen las variables cuadrado-x y cuadrado-y que toman los valores devueltos por las expresiones (cuadrado x) y (cuadrado y) : 16 y 100 . En este entorno local se eval\u00faa la expresi\u00f3n (+ cuadrado-x cuadrado-y) . El uso de let permite aumentar la legibilidad de los programas, dando nombre a expresiones: Por ejemplo: 1 2 3 4 5 ( define ( distancia x1 y1 x2 y2 ) ( let (( distancia-x ( - x2 x1 )) ( distancia-y ( - y2 y1 ))) ( sqrt ( + ( cuadrado distancia-x ) ( cuadrado distancia-y ))))) Otro ejemplo: 1 2 3 4 5 6 ( define ( intersecta-intervalo a1 a2 b1 b2 ) ( let (( dentro-b1 ( and ( >= b1 a1 ) ( <= b1 a2 ))) ( dentro-b2 ( and ( >= b2 a1 ) ( <= b2 a2 )))) ( or dentro-b1 dentro-b2 ))) 6.3. Clausuras \u00b6 Vamos a terminar explicando el concepto de clausura . Hemos visto que las funciones son objetos de primera clase de Scheme y que es posible crear funciones en tiempo de ejecuci\u00f3n con la forma especial lambda . Una clausura es una funci\u00f3n devuelta por otra funci\u00f3n. La clausura captura las variables locales de la funci\u00f3n principal y puede usarlas en su propio c\u00f3digo cuando este se invoque posteriormente. Veamos un ejemplo. Supongamos que definimos la siguiente funci\u00f3n (make-sumador k) que devuelve otra funci\u00f3n. 1 2 3 4 5 6 ( define ( make - sumador k ) ( lambda ( x ) ( + x k ))) ( define f ( make - sumador 10 )) ( f 2 ) \u21d2 12 En la funci\u00f3n (make-sumador k) se llama a la forma especial lambda para crear un procedimiento. El procedimiento devuelto es lo que se denomina clausura . En este caso la clausura captura la variable local k (el par\u00e1metro de make-sumador ) y usa su valor cuando posteriormente se invoca. Cuando se invoca a (f 2) se ejecuta la clausura y se crea un nuevo entorno local en el que x (el par\u00e1metro de la clausura) vale 2 y en el que se usa la variable k capturada. En la invocaci\u00f3n anterior (f 2) , cuando se ejecuta la expresi\u00f3n (+ x k) las variables tienen los siguientes valores: 1 2 x : 2 ( variable local de la clausura ) k : 10 ( valor capturado del entorno local en el que se cre\u00f3 la clausura Las variables locales creadas en un let tambi\u00e9n se capturan en las clausuras Veamos el siguiente ejemplo, en el que creamos una funci\u00f3n en un entorno local creado por un let : 1 2 3 4 5 6 7 8 9 ( define x 10 ) ( define y 12 ) ( define ( prueba x ) ( let (( y 3 )) ( lambda ( z ) ( + x y z )))) ( define h ( prueba 5 )) ( h 2 ) \u21d2 8 Sucede lo siguiente: Se invoca la expresi\u00f3n (prueba 5) . Esto crea un entorno local en el que se le da a la variable x (el par\u00e1metro de prueba ) el valor 5 . En este contexto se ejecuta el let , que crea otro entorno local en el que y vale 3. En el contexto del let se crea una clausura con la invocaci\u00f3n de la expresi\u00f3n lambda (lambda (z) (+ x y z)) . La clausura captura las variables locales x e y con sus valores 5 y 3 y la funci\u00f3n prueba la devuelve como resultado de la invocaci\u00f3n. La clausura se guarda en la variable h . Con la invocaci\u00f3n (h 2) se invoca a la clausura, lo que crea un entorno local en el que se encuentran las siguientes variables: 1 2 3 z : 2 ( par\u00e1metro de la clausura ) x : 5 ( variable local de la funci\u00f3n prueba capturada en el momento de creaci\u00f3n de la clausura )) y : 3 ( variable local del let capturada en el momento de creaci\u00f3n de la clausura ) En este contexto se ejecuta la expresi\u00f3n (+ x y z) , que devuelve 10. Lenguajes y Paradigmas de Programaci\u00f3n, curso 2015-16 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Domingo Gallardo, Cristina Pomares","title":"Ambitos let clousures"},{"location":"teoria/tema05-bis-programacion-imperativa/ambitos-let-clousures.html#6-ambitos-de-variables-let-y-closures","text":"Ahora que hemos introducido la forma especial lambda y la idea de que una funci\u00f3n es un objeto de primera clase, podemos revisar el concepto de \u00e1mbito de variables en Scheme e introducir un importante concepto: clausura ( closure en ingl\u00e9s).","title":"6. \u00c1mbitos de variables, let y closures"},{"location":"teoria/tema05-bis-programacion-imperativa/ambitos-let-clousures.html#61-ambitos-de-variables","text":"El concepto del \u00e1mbito de vida de las variables es un concepto fundamental en los lenguajes de programaci\u00f3n. En ingl\u00e9s se utiliza el t\u00e9rmino scope . Cuando se define una variable, asoci\u00e1ndole un valor, esta asociaci\u00f3n tiene una extensi\u00f3n determinada, ya sea en t\u00e9rminos de tiempo de compilaci\u00f3n ( \u00e1mbito l\u00e9xico ) como en t\u00e9rminos de tiempo de ejecuci\u00f3n ( \u00e1mbito din\u00e1mico ). El \u00e1mbito de una variable determina cu\u00e1ndo podemos referirnos a ella para recuperar el valor asociado. Al conjunto de variables disponibles en una parte del programa o en una parte de su ejecuci\u00f3n se denomina contexto o entorno ( context o environment ).","title":" 6.1. \u00c1mbitos de variables"},{"location":"teoria/tema05-bis-programacion-imperativa/ambitos-let-clousures.html#62-forma-especial-let","text":"","title":" 6.2 Forma especial let"},{"location":"teoria/tema05-bis-programacion-imperativa/ambitos-let-clousures.html#63-clausuras","text":"Vamos a terminar explicando el concepto de clausura . Hemos visto que las funciones son objetos de primera clase de Scheme y que es posible crear funciones en tiempo de ejecuci\u00f3n con la forma especial lambda . Una clausura es una funci\u00f3n devuelta por otra funci\u00f3n. La clausura captura las variables locales de la funci\u00f3n principal y puede usarlas en su propio c\u00f3digo cuando este se invoque posteriormente. Veamos un ejemplo. Supongamos que definimos la siguiente funci\u00f3n (make-sumador k) que devuelve otra funci\u00f3n. 1 2 3 4 5 6 ( define ( make - sumador k ) ( lambda ( x ) ( + x k ))) ( define f ( make - sumador 10 )) ( f 2 ) \u21d2 12 En la funci\u00f3n (make-sumador k) se llama a la forma especial lambda para crear un procedimiento. El procedimiento devuelto es lo que se denomina clausura . En este caso la clausura captura la variable local k (el par\u00e1metro de make-sumador ) y usa su valor cuando posteriormente se invoca. Cuando se invoca a (f 2) se ejecuta la clausura y se crea un nuevo entorno local en el que x (el par\u00e1metro de la clausura) vale 2 y en el que se usa la variable k capturada. En la invocaci\u00f3n anterior (f 2) , cuando se ejecuta la expresi\u00f3n (+ x k) las variables tienen los siguientes valores: 1 2 x : 2 ( variable local de la clausura ) k : 10 ( valor capturado del entorno local en el que se cre\u00f3 la clausura","title":" 6.3. Clausuras"},{"location":"teoria/tema05-bis-programacion-imperativa/tema05-programacion-imperativa.html","text":"Tema 5: Programaci\u00f3n imperativa \u00b6 Contenidos \u00b6 1. Historia y caracter\u00edsticas de la programaci\u00f3n imperativa 1.1. Historia de la programaci\u00f3n imperativa 1.2. Caracter\u00edsticas principales de la programaci\u00f3n imperativa 2. Programaci\u00f3n imperativa en Scheme 2.1. Pasos de ejecuci\u00f3n 2.2. Mutaci\u00f3n con formas especiales set! 2.3. Igualdad de referencia y de valor 3. Estructuras de datos mutables 3.1. Mutaci\u00f3n de elementos 3.2. Funciones mutadoras: make-ciclo! , append! y intercambia! 3.3. Lista ordenada mutable 3.4. Diccionario mutable 3.5. Ejemplo de mutaci\u00f3n con listas de asociaci\u00f3n 4. \u00c1mbitos de variables y clausuras 4.1. Variables de \u00e1mbito global 4.2. Variables de \u00e1mbito local 4.3. Clausuras y estado local 5. Clausuras con mutaci\u00f3n = estado local mutable 5.1. Estado local mutable 5.2. Paso de mensajes Bibliograf\u00eda \u00b6 En este tema explicamos conceptos de los siguientes cap\u00edtulos del libro Structure and Intepretation of Computer Programs : 3.3.1 Mutable List Structure 3.3.2 Representing Queues 3.3.3 Representing tables 3.1.1 Local State Variables 3.1.3 The Cost of Introducing Assignment 1. Historia y caracter\u00edsticas de la programaci\u00f3n imperativa \u00b6 1.1. Historia de la programaci\u00f3n imperativa \u00b6 1.1.1. Or\u00edgenes de la programaci\u00f3n imperativa La programaci\u00f3n imperativa es la forma natural de programar un computador, es el estilo de programaci\u00f3n que se utiliza en el ensamblador, el estilo m\u00e1s cercano a la arquitectura del computador Caracter\u00edsticas de la arquitectura arquitectura cl\u00e1sica de Von Newmann : memoria donde se almacenan los datos (referenciables por su direcci\u00f3n de memoria) y el programa unidad de control que ejecuta las instrucciones del programa (contador del programa) Los primeros lenguajes de programaci\u00f3n (como el Fortran) son abstracciones del ensamblador y de esta arquitectura. Lenguajes m\u00e1s modernos como el BASIC o el C han continuado con esta idea. 1.1.2. Programaci\u00f3n procedural Uso de procedimientos y subrutinas Los cambios de estado se localizan en estos procedimientos Los procedimientos especifican par\u00e1metros y valores devueltos (un primer paso hacia la abstracci\u00f3n y los modelos funcionales y declarativos) Primer lenguaje con estas ideas: ALGOL 1.1.3. Programaci\u00f3n estructurada Art\u00edculo a finales de los 60 de Edsger W. Dijkstra: GOTO statement considered harmful en el que se arremete contra la sentencia GOTO de muchos lenguajes de programaci\u00f3n de la \u00e9poca La programaci\u00f3n estructurada mantiene la programaci\u00f3n imperativa, pero haciendo \u00e9nfasis en la necesidad de que los programas sean correctos (debe ser posible de comprobar formalmente los programas), modulares y mantenibles. Lenguajes: Pascal, ALGOL 68, Ada 1.1.4. Programaci\u00f3n Orientada a Objetos La POO tambi\u00e9n utiliza la programaci\u00f3n imperativa, aunque extiende los conceptos de modularidad, mantenibilidad y estado local Se populariza a finales de los 70 y principios de los 80 1.2. Caracter\u00edsticas principales de la programaci\u00f3n imperativa \u00b6 Idea principal de la programaci\u00f3n imperativa: la computaci\u00f3n se realiza cambiando el estado del programa por medio de sentencias que definen pasos de ejecuci\u00f3n del computador Estado del programa modificable Sentencias de control que definen pasos de ejecuci\u00f3n Vamos a ver unos ejemplos de estas caracter\u00edsticas usando el lenguaje de programaci\u00f3n Java. 1.2.1. Modificaci\u00f3n de datos Uno de los elementos de la arquitectura de Von Newmann es la existencia de celdas de memoria referenciables y modificables 1 2 int x = 0 ; x = x + 1 ; Otro ejemplo t\u00edpico de este concepto en los lenguajes de programaci\u00f3n es el array: una estructura de datos que se almacena directamente en memoria y que puede ser accedido y modificado. En Java los arrays son tipeados, mutables y de tama\u00f1o fijo 1 2 String [] unoDosTres = { \"uno\" , \"dos\" , \"tres\" }; unoDosTres [ 0 ] = unoDosTres [ 2 ] ; Un ejemplo de un m\u00e9todo que recibe un par\u00e1metro de tipo array en Java. El par\u00e1metro se pasa por referencia: 1 2 3 4 5 public void llenaCadenas ( String [] cadenas , String cadena ) { for ( int i = 0 ; i < cadenas . length ; i ++ ) { cadenas [ i ] = cadena ; } } Todos los ejemplos anteriores en un programa main Java: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 public class Main { public static void main ( String [] args ) { int x = 0 ; x = x + 1 ; System . out . println ( \"x: \" + x ); String [] unoDosTres = { \"uno\" , \"dos\" , \"tres\" }; unoDosTres [ 0 ] = unoDosTres [ 2 ] ; for ( String valor : unoDosTres ) { System . out . println ( valor ); } llenaCadenas ( unoDosTres , \"uno\" ); for ( String valor : unoDosTres ) { System . out . println ( valor ); } } public static void llenaCadenas ( String [] cadenas , String cadena ) { for ( int i = 0 ; i < cadenas . length ; i ++ ) { cadenas [ i ] = cadena ; } } } 1.2.2. Almacenamiento de datos en variables Todos los lenguajes de programaci\u00f3n definen variables que contienen datos Las variables pueden mantener valores (tipos de valor o value types) o referencias (tipos de referencia o reference types) En C, C++ o Java, los datos primitivos como int o char son de tipo valor y los objetos y datos compuestos son de tipo referencia La asignaci\u00f3n de un valor a una variable tiene implicaciones distintas si el tipo es de valor (se copia el valor) o de referencia (se copia la referencia) Copia de valor (datos primitivos en Java): 1 2 3 4 int x = 10 ; int y = x ; x = 20 ; System . out . println ( y ); // Sigue siendo 10 Copia de referencia (objetos en Java): 1 2 3 4 5 6 // import java.awt.geom.Point2D; Point2D p1 = new Point2D . Double ( 2.0 , 3.0 ); Point2D p2 = p1 ; p1 . setLocation ( 12.0 , 13.0 ); System . out . println ( \"p2.x = \" + p2 . getX ()); // 12.0 System . out . println ( \"p2.y = \" + p2 . getY ()); // 13.0 El uso de las referencias para los objetos de clases y para los tipos compuestos est\u00e1 generalizado en la mayor\u00eda de lenguajes de programaci\u00f3n Tiene efectos laterales pero permite obtener estructuras de datos eficientes 1.2.3. Igualdad de valor y de referencia Todos los lenguajes de programaci\u00f3n imperativos que permite la distinci\u00f3n entre valores y referencias implementan dos tipos de igualdad entre variables Igualdad de valor (el contenido de los datos de las variables es el mismo) Igualdad de referencia (las variables tienen la misma referencia) Igualdad de referencia => Igualdad de valor (pero al rev\u00e9s no) En Java la igualdad de referencia se define con == y la de valor con el m\u00e9todo equals : 1 2 3 4 5 6 Point2D p1 = new Point2D . Double ( 2.0 , 3.0 ); Point2D p2 = p1 ; Point2D p3 = new Point2D . Double ( 2.0 , 3.0 ); System . out . println ( p1 == p2 ); // true System . out . println ( p1 == p3 ); // false System . out . println ( p1 . equals ( p3 )); // true 1.2.4. Sentencias de control Tambi\u00e9n tiene su origen en la arquitectura de Von Newmann Sentencia que modifica el contador de programa y determina cu\u00e1l ser\u00e1 la siguiente instrucci\u00f3n a ejecutar Tipos de sentencias de control en programaci\u00f3n estructurada: Las sentencias de secuencia definen instrucciones que son ejecutados una detr\u00e1s de otra de forma s\u00edncrona. Una instrucci\u00f3n no comienza hasta que la anterior ha terminado. Las sentencias de selecci\u00f3n definen una o m\u00e1s condiciones que determinan las instrucciones que se deber\u00e1n ejecutar. Las sentencias de iteraci\u00f3n definen instrucciones que se ejecutan de forma repetitiva hasta que se cumple una determinada condici\u00f3n. Bucles y variables Ejemplo imperativo que imprime en Java una tabla con los productos de los n\u00fameros del 1 al 9: 1 2 3 4 5 6 7 8 for ( int i = 1 ; i <= 9 ; i ++ ) { System . out . println ( \"Tabla del \" + i ); System . out . println ( \"-----------\" ); for ( int j = 1 ; j <= 9 ; j ++ ) { System . out . println ( i + \" * \" + j + \" = \" + i * j ); } System . out . println (); } 2. Programaci\u00f3n imperativa en Scheme \u00b6 Al igual que LISP, Scheme tiene caracter\u00edsticas imperativas Vamos a ver algunas de ellas Pasos de ejecuci\u00f3n Asignaci\u00f3n con la forma especial set! Datos mutables con las formas especiales set-car! y set-cdr! Una nota importante: todos los ejemplos que hay a continuaci\u00f3n necesitan importar la librer\u00eda mutable-pairs : 1 2 3 # lang r6rs ( import ( rnrs ) ( rnrs mutable-pairs )) 2.1. Pasos de ejecuci\u00f3n \u00b6 Es posible definir pasos de ejecuci\u00f3n con la forma especial begin Todas las sentencias de la forma especial se ejecutan de forma secuencial, una tras otra Tanto en la definici\u00f3n de funciones como en lambda es posible definir cuerpos de funci\u00f3n con m\u00faltiples sentencias que se ejecutan tambi\u00e9n de forma secuencial. Hasta ahora no hemos usado esta caracter\u00edstica porque hemos utilizado Scheme de forma funcional. Ejemplo begin : 1 2 3 4 5 6 7 8 9 10 11 12 ( begin ( display \"Escribe un n\u00famero: \" ) ( define x ( read )) ( display \"Escribe otro: \" ) ( define y ( read )) ( define maximo ( max x y )) ( display ( string-append \"El m\u00e1ximo de \" ( number->string x ) \" y \" ( number->string y ) \" es \" ( number->string maximo )))) Ejemplo de pasos de ejecuci\u00f3n en la definici\u00f3n de una funci\u00f3n: 1 2 3 4 5 6 7 ( define ( display-tres-valores a b c ) ( display a ) ( newline ) ( display b ) ( newline ) ( display c ) ( newline )) 2.2. Mutaci\u00f3n con formas especiales set! \u00b6 2.2.1. Forma especial set! La forma especial set! permite asignar un nuevo valor a una variable La variable debe haber sido previamente creada con define La forma especial no devuelve ning\u00fan valor, modifica el valor de la variable usada Sintaxis: 1 (set! <variable> <nuevo-valor>) Por ejemplo, la t\u00edpica asignaci\u00f3n de los lenguajes imperativos se puede realizar de esta forma en Scheme: 1 2 3 ( define a 10 ) ( set! a ( + a 1 )) a ; \u21d2 11 La forma especial set! funciona con cualquier tipo de datos. Por ejemplo, utilizando la caracter\u00edstica de que Scheme es d\u00e9bilmente tipeado, puede incluso asignar un nuevo tipo de valor a una variable: 1 2 3 4 ( define a \"Hola\" ) a ; \u21d2 \"Hola\" ( set! a ( cons 1 2 )) a ; \u21d2 {1 . 2} 2.2.2. Datos mutables En Scheme se definen las formas especiales set-car! y set-cdr! que permite modificar (mutar) la parte izquierda o derecha de una pareja una vez creada Al igual que set! , no devuelven ning\u00fan valor Sintaxis: 1 2 (set-car! <pareja> <nuevo-valor>) (set-cdr! <pareja> <nuevo-valor>) Ejemplo 1 2 3 4 ( define p ( cons 1 2 )) ( set-car! p 10 ) ( set-cdr! p 20 ) p ; \u21d2 (10 . 20) 2.2.3. Efectos laterales La introducci\u00f3n de la asignaci\u00f3n y los datos mutables hace posible que Scheme se comporte como un lenguaje imperativo en el que m\u00e1s de una variable apunta a un mismo valor y se producen efectos laterales Un efecto lateral se produce cuando el valor de una variable cambia debido a una sentencia en la que no aparece la variable Podemos comprobar ahora que las parejas son datos que se copian por referencia Ejemplo: 1 2 3 4 5 6 7 ( define p1 ( cons 1 2 )) ( define p2 p1 ) p1 ; \u21d2 (1 . 2) p2 ; \u21d2 (1 . 2) ( set-car! p1 20 ) p1 ; \u21d2 (20 . 2) p2 ; \u21d2 (20 . 2) 2.3. Igualdad de referencia y de valor \u00b6 La utilizaci\u00f3n de referencias, la mutaci\u00f3n y los efectos laterales hace tambi\u00e9n necesario definir dos tipos de igualdades: igualdad de referencia e igualdad de valor. Igualdad de referencia: dos variables son iguales cuando apuntan al mismo valor Igualdad de valor: dos variables son iguales cuando contienen el mismo valor En Scheme la funci\u00f3n eq? comprueba la igualdad de referencia y equal? la igualdad de valor Igualdad de referencia implica igualdad de valor, pero no al rev\u00e9s Ejemplo: 1 2 3 4 5 6 7 8 ( define p1 ( cons 10 20 )) ( define p2 p1 ) ( define p3 ( cons 10 20 )) ( equal? p3 p1 ) ; \u21d2 #t ( eq? p3 p1 ) ; \u21d2 #f ( eq? p2 p1 ) ; \u21d2 #t ( set! p3 p1 ) ;; La asignaci\u00f3n copia referencias ( eq? p3 p1 ) ; \u21d2 #t 3. Estructuras de datos mutables \u00b6 La utilizaci\u00f3n de las formas especiales set-car! y set-cdr! permite un estilo nuevo de manejo de las estructuras de datos ya vistas (listas o \u00e1rboles) Es posible implementar funciones m\u00e1s eficientes que actualizan la estructura modificando directamente las referencias de unas celdas a otras Las operaciones no construyen estructuras nuevas, sino que modifican la ya existente 3.1. Mutaci\u00f3n de elementos \u00b6 Ejemplo 1 Vamos a empezar con un ejemplo sencillo en el que vamos a mutar un elemento de una estructura de datos formada por parejas. Supongamos la siguiente estructura: 1 2 3 4 ( define datos ( cons 2 ( cons ( cons 5 ( cons 8 9 )) ( cons 3 4 )))) El diagrama box-and-pointer es el siguiente. F\u00edjate que hay elementos de las parejas que son datos at\u00f3micos y otros que son referencias a otras parejas. Vamos ahora a mutar la estructura utilizando las sentencias set-car! y set-cdr! . Para mutar una pareja acceder a la pareja y modificar su parte derecha o su parte izquierda con las sentencias anteriores. Por ejemplo, \u00bfc\u00f3mo cambiar\u00edamos el 8 por un 18 ? Deber\u00edamos obtener la pareja (8 . 9) que est\u00e1 al final de la estructura y modificar su parte izquierda: 1 ( set-car! ( cdr ( car ( cdr datos ))) 18 ) La expresi\u00f3n (cdr (car (cdr datos))) devuelve la pareja que queremos modificar y la sentencia set-car! modifica su parte izquierda. Si ahora vemos qu\u00e9 hay en datos veremos que se ha modificado la estructura: 1 2 ( print-pareja datos ) ; \u21d2 (2 . ((5 . (18 . 9)) . (3 . 4))) Recuerda que print-pareja es una funci\u00f3n que vimos anteriormente. Hemos mutado un dato por otro. Tambi\u00e9n podemos mutar las referencias a las parejas. Por ejemplo, podr\u00edamos modificar la parte derecha de la pareja que contiene el 5 para que apunte a la pareja (3 . 4) : Para ello habr\u00eda que obtener la pareja que contiene el 5 con la expresi\u00f3n (car (cdr datos)) y mutar su parte derecha ( set-cdr! ) con la referencia a la pareja (3 . 4) que se obtiene con la expresi\u00f3n (cdr (cdr datos)) : 1 ( set-cdr! ( car ( cdr datos )) ( cdr ( cdr datos ))) Ejemplo 2 Veamos un segundo ejemplo. Supongamos las siguientes sentencias. \u00bfCu\u00e1l ser\u00eda el box-and-pointer resultante? 1 2 3 4 5 6 ( define x ' (( a b ) c d )) ( define y ' ( e f )) ( set-car! x y ) ( define z ( cons y ( cdr x ))) ( set-cdr! x y ) ( set-car! z ( caar x )) Debemos ir paso a paso ejecutando cada instrucci\u00f3n y dibujando c\u00f3mo cambia el diagrama. El diagrama representa el estado del programa , y es un conjunto de parejas que contienen valores y referencias entre ellas. Es muy importante considerar cu\u00e1ndo la sentencia copia un valor y cuando copia una referencia. Las parejas siempre tienen sem\u00e1ntica de referencia. El diagrama resultante despu\u00e9s de las dos primeras sentencias es: Y el diagrama despu\u00e9s de todas las sentencias es: Los valores de las variables despu\u00e9s de todas las sentencias son los siguientes: 1 2 3 x ; \u21d2 {{e f} e f} y ; \u21d2 {e f} z ; \u21d2 {e c d} Ejemplo 3 En este ejemplo vamos a usar una nueva forma especial de Scheme que permite crear variables locales y ejecutar expresiones en las que se utilicen esas variables. Se trata de la forma especial let . Veremos algo m\u00e1s de esta forma especial m\u00e1s adelante, cuando hablemos de \u00e1mbitos de variables. Por ahora es suficiente saber que permite crear variables locales y ejecutar un cuerpo (que puede tener m\u00e1s de una sentencia) con esas variables. 1 2 3 4 ( let (( x ( + 2 3 )) ( y ( * 2 10 )) ( + x y )) ; \u21d2 25 En este caso let permite crear dos variables locales x e y y asignarles los valores 5 y 20 respectivamente. Las sentencias del cuerpo del let (en este caso la sentencia (+ x y) ) se eval\u00faan con estos valores reci\u00e9n creados. Vamos a usar esta forma especial en ocasiones para guardar valores o referencias que despu\u00e9s necesitamos asignar. Por ejemplo, \u00bfc\u00f3mo podr\u00edamos definir una funci\u00f3n que mute las referencias de una lista para intercambiar sus posiciones segunda y tercera (sin crear nuevas parejas)? Si llamamos a la funci\u00f3n intercambia! deber\u00eda hacer lo siguiente: 1 2 3 ( define lista ' ( 1 2 3 4 5 6 )) ( intercambia! lista ) lista ; \u21d2 {1 3 2 4 5 6} Dibujando el diagrama box-and-pointer podemos ver las mutaciones que tenemos que hacer: La funci\u00f3n es la siguiente: 1 2 3 4 5 6 ( define ( intercambia! lista ) ( let (( segundo ( cdr lista )) ( tercero ( cddr lista ))) ( set-cdr! lista tercero ) ( set-cdr! segundo ( cdr tercero )) ( set-cdr! tercero segundo ))) 3.2. Funciones mutadoras: make-ciclo! , append! e intercambia-lista! \u00b6 Veamos ahora varios ejemplos de funciones recursivas que recorren listas y realizan mutaciones en ellas. Normalmente las funciones mutadoras no devuelven una estructura, sino que modifican la que se pasa como par\u00e1metro. Por convenio, indicaremos que una funci\u00f3n es mutadora terminando su nombre con un signo de admiraci\u00f3n. make-ciclo! Empecemos con una funci\u00f3n muta una lista, haciendo que la parte derecha de la \u00faltima pareja apunte a la pareja inicial de la misma. Para conseguirlo, necesitamos guardar la referencia a la pareja inicial de la lista en el primer par\u00e1metro de la funci\u00f3n. Y el segundo par\u00e1metro ir\u00e1 avanzando hasta encontrar el final de la lista: 1 2 3 4 ( define ( make-ciclo! lista ref ) ( if ( null? ( cdr ref )) ( set-cdr! ref lista ) ( make-ciclo! lista ( cdr ref )))) Si probamos la funci\u00f3n con una lista, podemos comprobar que DrRacket detecta el ciclo que se produce al final de la misma: 1 2 3 ( define lista ' ( 1 2 3 4 5 6 )) ( make-ciclo! lista lista ) lista ; \u21d2 #0={1 2 3 4 5 6 . #0#} Una forma alternativa de implementar esta funci\u00f3n es mediante una funci\u00f3n que devuelva la referencia de la \u00faltima pareja de la lista: 1 2 3 4 5 6 7 8 ( define ( ultima-pareja lista ) ( if ( null? ( cdr lista )) lista ( ultima-pareja ( cdr lista )))) ( define ( make-ciclo2! lista ) ( let (( ultima-pareja ( ultima-pareja lista ))) ( set-cdr! ultima-pareja lista ))) append! Y vemos a continuaci\u00f3n una versi\u00f3n mutadora de append que llamamos append! y que mejora la eficiencia de la original, copiando al final de la primera lista una referencia a la segunda: La implementaci\u00f3n es la siguiente: 1 2 3 4 ( define ( append! l1 l2 ) ( if ( null? ( cdr l1 )) ( set-cdr! l1 l2 ) ( append! ( cdr l1 ) l2 ))) Ejemplo: 1 2 3 4 ( define a ' ( 1 2 3 4 )) ( define b ' ( 5 6 7 )) ( append! a b ) a ; \u21d2 {1 2 3 4 5 6 7} Algunas puntualizaciones: Al igual que set! , set-car! o set-cdr! , la funci\u00f3n append! no devuelve ning\u00fan valor, sino que modifica directamente la lista que se pasa como primer par\u00e1metro. Al modificarse la lista, todas las referencias que apuntan a ellas quedan tambi\u00e9n modificadas. La funci\u00f3n dar\u00eda un error en el caso en que la llam\u00e1ramos con una lista vac\u00eda como primer argumento. intercambia-lista! Un \u00faltimo ejemplo de funci\u00f3n recursiva que muta una lista. Queremos definir una funci\u00f3n que intercambie todas las parejas excepto la primera de una lista con un n\u00famero de datos impar, pero sin usar set-car! . Llamamos a la funci\u00f3n (intercambia-lista! lista) y deber\u00eda hacer lo siguiente: 1 2 3 ( define lista ' ( 1 2 3 4 5 6 7 )) ( intercambia-lista! lista ) lista ; \u21d2 {1 3 2 5 4 7 6} La forma de implementar esta funci\u00f3n va a ser llamando a la funci\u00f3n intercambia! (la que hemos definido anteriormente que intercambia el segundo y el tercer elemento) hasta que lleguemos al final de la lista. Lo hacemos con una recursi\u00f3n: 1 2 3 4 5 ( define ( intercambia-lista! lista ) ( if ( not ( null? ( cdr lista ))) ( begin ( intercambia! lista ) ( intercambia-lista! ( cddr lista ))))) La funci\u00f3n termina cuando llegamos a la pareja final de la lista, la que tiene la lista vac\u00eda en su parte derecha. Si no estamos en el final de la lista llamamos a la funci\u00f3n intercambia! para intercambiar la siguiente pareja con su siguiente y llamamos a la recursi\u00f3n con la variable lista apuntando a la tercera pareja de la lista. 3.3. Lista ordenada mutable \u00b6 Veamos ahora una lista ordenada mutable de n\u00fameros, en la que insertaremos elementos de forma ordenada. Definiremos las siguientes funciones: (make-olist) : construye una lista ordenada vac\u00eda (borra-primero-olist! olist) : funci\u00f3n mutadora que elimina (con mutaci\u00f3n) el primer elemento de la lista (inserta-olist! olist n) : funci\u00f3n mutadora que inserta (con mutaci\u00f3n) de forma ordenada un n\u00famero en la lista Implementamos el tipo de datos con una lista normal con una pareja adicional en cabeza. Esta pareja adicional funcionar\u00e1 de cabecera de la lista y ser\u00e1 la referencia inmutable a la que apuntar\u00e1 cualquier variable que apunte a la lista. De esta forma podremos insertar elementos en primera posici\u00f3n de la lista. En la cabecera usaremos por convenio el s\u00edmbolo '*olist*' . 1 ( define lista ' ( *olist* 10 20 30 )) Constructor El constructor (make-olist) devuelve una lista s\u00f3lo con la cabecera. 1 2 ( define ( make-olist ) ( list '*olist* )) Mutadores Las funciones mutadoras modifican la estructura de datos. Comenzamos con la funci\u00f3n (borra-primero-olist! olist) que elimina con mutaci\u00f3n el primer elemento de la lista ordenada: 1 2 ( define ( borra-primero-olist! olist ) ( set-cdr! olist ( cddr olist ))) Definimos la funci\u00f3n mutadora inserta-olist! que modifica la lista ordenada a\u00f1adiendo una nueva pareja, insert\u00e1ndola en la posici\u00f3n correcta modificando las referencias. La funci\u00f3n (add-item! item ref) es la funci\u00f3n clave que crea una nueva pareja con el item y la a\u00f1ade en el cdr de la pareja a la que apunta ref . 1 2 3 4 5 6 7 8 9 ( define ( add-item! ref item ) ( set-cdr! ref ( cons item ( cdr ref )))) ( define ( inserta-olist! olist n ) ( cond (( null? ( cdr olist )) ( add-item! olist n )) (( < n ( cadr olist )) ( add-item! olist n )) (( = n ( cadr olist )) #f ) ; el valor devuelto no importa ( else ( inserta-olist! ( cdr olist ) n )))) Ejemplo de uso: 1 2 3 4 5 ( define c ( make-olist )) ( inserta-olist! c 5 ) ( inserta-olist! c 10 ) ( inserta-olist! c -10 ) c ; \u21d2 {*olist* -10 5 10} 3.4. Diccionario mutable \u00b6 Veamos ahora un ejemplo m\u00e1s: un diccionario mutable definido mediante una lista de asociaci\u00f3n formada por parejas de clave y valor 1 ( define l-assoc ( list ( cons 'a 1 ) ( cons 'b 2 ) ( cons 'c 3 ))) La funci\u00f3n de Scheme assq recorre la lista de asociaci\u00f3n y devuelve la tupla que contiene el dato que se pasa como par\u00e1metro como clave 1 2 3 4 5 ( assq 'a l-assoc ) ; \u21d2 (a.1) ( assq 'b l-assoc ) ; \u21d2 (b.2) ( assq 'c l-assoc ) ; \u21d2 (c.3) ( assq 'd l-assoc ) ; \u21d2 #f ( cdr ( assq 'c l-assoc )) ; \u21d2 3 La funci\u00f3n assq busca en la lista de asociaci\u00f3n usando la igualdad de referencia eq? 1 2 3 4 ( define p ( cons 1 2 )) ( define l-assoc ( list ( cons 'a 1 ) ( cons p 2 ) ( cons 'c 3 ))) ( assq ( cons 1 2 ) l-assoc ) ; \u21d2 #f ( assq p l-assoc ) ; \u21d2 {{1 . 2} . 2} Las funciones que vamos a implementar del diccionario son las siguientes: (make-dic) : construye un diccionario vac\u00edo (put-dic! dic clave valor) : inserta en el diccionario un nuevo valor asociado a una clave (get-dic dic clave) : devuelve el valor asociado a una clave en un diccionario Al igual que la lista ordenada mutable, el diccionario necesita una cabecera: 1 2 ( define ( make-dic ) ( list '*dic* )) La funci\u00f3n (get-dic dic clave) usa la funci\u00f3n assq para buscar la pareja que contiene una clave determinada en la lista de asociaci\u00f3n (el cdr de dic). Y despu\u00e9s devuelve el cdr de esa pareja (el valor guardado junto con la clave: 1 2 3 4 5 ( define ( get-dic dic clave ) ( let ( pareja ( assq clave ( cdr dic ))) ( if ( not pareja ) #f ( cdr pareja )))) La funci\u00f3n (put-dic! dic clave valor) usa igual que antes la funci\u00f3n assq para comprobar si la clave ya est\u00e1 en la lista de asociaci\u00f3n. Si existe, sustituye el valor por el nuevo. Si no existe, crea una pareja con la clave y el valor y la inserta al comienzo del diccionario (despu\u00e9s de la cabecera): 1 2 3 4 5 6 7 8 ( define ( put-dic! dic clave valor ) ( let ( pareja ( assq clave ( cdr dic ))) ( if ( not pareja ) ( set-cdr! dic ( cons ( cons clave valor ) ( cdr dic ))) ( set-cdr! pareja valor ))) 'ok ) En las funciones anteriores volvemos a usar la forma especial let . Ejemplos de uso: 1 2 3 4 5 6 7 ( define dic ( make-dic )) ( put-dic! dic 'a 10 ) ; \u21d2 ok ( get-dic dic 'a ) ; \u21d2 10 ( put-dic! dic 'b ' ( a b c )) ; \u21d2 ok ( get-dic dic 'b ) ; \u21d2 {a b c} ( put-dic! dic 'a 'ardilla ) ; \u21d2 ok ( get-dic dic 'a ) ; \u21d2 ardilla 3.5. Ejemplo de mutaci\u00f3n con listas de asociaci\u00f3n \u00b6 Una vez introducidos distintas estructuras de datos mutables, incluyendo listas de asociaci\u00f3n, vamos a terminar estos ejemplos con un ejemplo pr\u00e1ctico en el que intervienen las listas y las listas de asociaci\u00f3n. Se trata de escribir un procedimiento regular->assoc! que transforme una lista regular en una lista de asociaci\u00f3n sin crear nuevas parejas. La lista regular (k1 v1 k2 v2 k3 v3 ...) deber\u00e1 convertirse en la lista de asociaci\u00f3n ((k1 . v1) (k2 . v2) (k3 . v3) ...) . Ejemplo: 1 2 3 4 ( define my-list ( list 'a 1 'b 2 'c 3 )) lista ; \u21d2 (a 1 b 2 c 3) ( regular->assoc! my-list ) lista ; \u21d2 ((a . 1) (b . 2) (c . 3)) Una posible soluci\u00f3n a este problema ser\u00eda la siguiente (no es la \u00fanica soluci\u00f3n): Cuando trabajamos con este tipo de problemas, es muy \u00fatil ayudarse con los diagramas caja y puntero. Vamos a crear los diagramas caja y puntero para el ejemplo anterior: Antes de llamar a regular->assoc!: Despu\u00e9s de llamar a regular->assoc!: Queremos hacer la transformaci\u00f3n sin crear nuevas parejas, por lo que cada pareja en el primer diagrama corresponde a una pareja particular en el segundo diagrama. No podemos modificar la primera pareja de la lista (porque perder\u00edamos la ligadura de la variable lista ), por lo que es primera pareja tiene que permanecer en el primer lugar. Por otra parte, a y 1 van a formar parte del mismo par en la lista de asociaci\u00f3n, por lo que vamos a considerar el siguiente cambio de las dos primeras parejas. Diagrama inicial: Despu\u00e9s del cambio de las dos primeras parejas: La siguiente funci\u00f3n manejar-dos-parejas! es la encargada de hacer esta mutaci\u00f3n: 1 2 3 4 5 6 ( define ( manejar-dos-parejas! p ) ( let (( key ( car p ))) ;; 1 ( set-car! p ( cdr p )) ;; 2 ( set-cdr! p ( cdar p )) ;; 3 ( set-cdr! ( car p ) ( caar p )) ;; 4 ( set-car! ( car p ) key ))) ;; 5 Se han numerado las l\u00edneas para una mejor explicaci\u00f3n. En la l\u00ednea 1, (define key (car p)) , creamos una variable local key que guarda el valor actual del (car p) , ese valor ser\u00e1 la clave de la primera pareja de la lista de asociaci\u00f3n; necesitamos almacenarlo para no perderlo. En la l\u00ednea 2, (set-car! p (cdr p)) , cambiamos el car de p para que apunte a la siguiente pareja (la azul): En la l\u00ednea 3, (set-cdr! p (cdar p)) , copiamos en el cdr de p el cdr de la pareja en azul para que ambos apunten a la siguiente pareja: En la l\u00ednea 4, (set-cdr! (car p) (caar p)) , cambiamos el cdr de la pareja en azul al car de la misma pareja. Hacemos \u00e9sto porque en una lista de asociaci\u00f3n, los valores se guardan en los cdrs y las claves en los cars : Por \u00faltimo, en la l\u00ednea 5 (set-car! (car p) key) , completamos el problema poniendo la clave que hab\u00edamos guardado, en el car de la pareja azul: Reordenamos el diagrama para verlo m\u00e1s claro: Hemos definido un procedimiento que maneja un subproblema (dos parejas) del problema. Ahora s\u00f3lo nos queda definir la funci\u00f3n que maneja toda la lista: 1 2 3 4 5 ( define ( regular->assoc! lista ) ( if ( null? lista ) 'ok ( begin ( manejar-dos-parejas! lista ) ( regular->assoc! ( cdr lista ))))) 4. \u00c1mbitos de variables y clausuras \u00b6 El concepto del \u00e1mbito de vida de las variables es un concepto fundamental en los lenguajes de programaci\u00f3n. Utilizaremos las palabras \u00e1mbito y entorno como sin\u00f3nimos. En ingl\u00e9s se utiliza el t\u00e9rmino scope . Cuando se define una variable, asoci\u00e1ndole un valor, esta asociaci\u00f3n tiene una extensi\u00f3n determinada, ya sea en t\u00e9rminos de tiempo de compilaci\u00f3n ( \u00e1mbito l\u00e9xico ) como en t\u00e9rminos de tiempo de ejecuci\u00f3n ( \u00e1mbito din\u00e1mico ). El \u00e1mbito de una variable determina cu\u00e1ndo podemos referirnos a ella para recuperar el valor asociado. Al conjunto de variables disponibles en una parte del programa o en una parte de su ejecuci\u00f3n se denomina contexto o entorno ( context o environment ). 4.1. Variables de \u00e1mbito global \u00b6 Una variable definida en el programa con la instrucci\u00f3n define tiene un \u00e1mbito global. 1 2 3 ( define a \"hola\" ) ( define b ( string-append \"adios\" a )) ( define cuadrado ( lambda ( x ) ( * x x ))) Todas las variables definidas fuera de funciones forman parte del entorno global del programa. 4.2. Variables de \u00e1mbito local \u00b6 En Scheme existen dos formas de definir variables de \u00e1mbito local: la forma especial define dentro de una funci\u00f3n y la forma especial let . 4.2.1 Variables locales con define Como en la mayor\u00eda de lenguajes de programaci\u00f3n, en Scheme se crea un entorno o \u00e1mbito local (memoria local de la invocaci\u00f3n de la funci\u00f3n) cada vez que se invoca a una funci\u00f3n. En este entorno local toman valor los par\u00e1metros y las variables locales de la funci\u00f3n. Es posible definir variables locales en una funci\u00f3n utilizando la forma especial define dentro de la propia funci\u00f3n. Esto no lo hac\u00edamos dentro del paradigma funcional, para evitar realizar pasos de ejecuci\u00f3n. Pero ahora que estamos en el paradigma imperativo podemos utilizarlo. 1 2 3 4 5 ( define ( distancia x1 y1 x2 y2 ) ( define distancia-x ( - x2 x1 )) ( define distancia-y ( - y2 y1 )) ( sqrt ( + ( cuadrado distancia-x ) ( cuadrado distancia-y )))) Podemos usar en un entorno local una variable con el mismo nombre que en el entorno global. Cuando se ejecute el c\u00f3digo de la funci\u00f3n se utilizar\u00e1 el valor local. Por ejemplo, supongamos las siguientes expresiones: 1 2 3 4 5 6 ( define x 5 ) ( define ( suma-10 y ) ( define x 10 ) ( + x y )) ( suma-10 3 ) ; \u21d2 13 La primera sentencia de la funci\u00f3n (suma y) define una variable local x a la que se asigna un valor inicial de 10. Cuando se ejecuta la expresi\u00f3n (+ x y) , en la invocaci\u00f3n a (suma 3) el valor de x es entonces 10 (el valor local que hemos definido en la sentencia anterior), no es 5, devolvi\u00e9ndose 15. Sucede igual si un par\u00e1metro tiene el mismo nombre que una variable global: 1 2 3 4 5 ( define x 5 ) ( define ( suma-3 x ) ( + x 3 )) ( suma-3 12 ) ; \u21d2 15 Cuando se ejecuta la expresi\u00f3n (+ x 3) en la invocaci\u00f3n a (suma-3 12) el valor de x es 12, no es 5, devolvi\u00e9ndose 15. En el entorno local tambi\u00e9n se pueden utilizar variables definidas en el entorno global. Por ejemplo: 1 2 3 4 5 6 ( define z 12 ) ( define ( foo y ) ( define x 10 ) ( + x y z )) ( foo 5 ) ; \u21d2 27 La expresi\u00f3n (+ x y z) se eval\u00faa en el entorno local en el que x vale 10 e y vale 5. Al no estar definida la variable z en este entorno local, se usa su definici\u00f3n de \u00e1mbito global. Una vez realizada la invocaci\u00f3n, desparece el entorno local junto con las variables locales definidas en \u00e9l, y se recupera el contexto global. Por ejemplo, en la siguiente expresi\u00f3n, una vez realizada la invocaci\u00f3n a (suma-10 2) se devuelve el n\u00famero 12 y se eval\u00faa en el entorno global la expresi\u00f3n (+ 12 x) . En este contexto la variable x vale 5 por lo que la expresi\u00f3n devuelve 17. 1 2 3 4 5 6 ( define x 5 ) ( define ( suma-10 y ) ( define x 10 ) ( + x y )) ( + ( suma-10 2 ) x ) ; \u21d2 17 Otro ejemplo: 1 2 3 4 5 6 7 8 9 ( define x 10 ) ( define ( foo2 y ) ( define z 5 ) ( + x y z )) ( foo2 2 ) ; \u21d2 17 x ; \u21d2 10 z ; \u21d2 error, no definida y ; \u21d2 error, no definida Define en el cuerpo de una funci\u00f3n La forma especial define para crear variables locales s\u00f3lo puede utilizarse al comienzo de la definici\u00f3n de una funci\u00f3n. Si intentamos utilizarla a mitad del c\u00f3digo de la funci\u00f3n tendremos un error: 1 2 3 4 5 6 7 8 9 ( define ( suma-10-si-mayor-que-0 x ) ( if ( > x 0 ) ( begin ;; ERROR: ;; no es posible usar define a mitad del c\u00f3digo ;; de una funci\u00f3n ( define y 10 ) ( + x y )) x )) 4.2.1 Variables locales con let La otra forma de definir variables locales en Scheme es con la forma especial let . La forma especial let permite crear un \u00e1mbito local en el que se da valor a variables y se eval\u00faan expresiones. Sintaxis: 1 2 3 4 ( let (( <var1> <exp-1> ) ... ( <varn> <exp-n> )) <cuerpo> ) Las variables var1 , \u2026 varn toman los valores devueltos por las expresiones exp1 , \u2026 expn y el cuerpo se eval\u00faa con esos valores. Esas variables s\u00f3lo tienen valor en el \u00e1mbito de la forma especial. Por ejemplo: 1 2 3 4 5 6 ( define x 10 ) ( let (( x ( + 1 2 )) ( y ( * 10 2 )) ( + x y )) ; \u21d2 23 x ; \u21d2 10 y ; \u21d2 error, no definida Cuando ha terminado la evaluaci\u00f3n del let el \u00e1mbito local desaparece y quedan los valores definidos en el \u00e1mbito anterior. Las expresiones que dan valor a las variables del let se eval\u00faan antes de crear el \u00e1mbito local. Por ejemplo, en el siguiente c\u00f3digo, las expresiones (+ x 3) y (+ y 2) devuelven 4 y 7 respectivamente: 1 2 3 4 5 ( define x 1 ) ( define y 5 ) ( let (( w ( + x 3 )) ( z ( + y 2 ))) ( + w z )) ; \u21d2 11 En el cuerpo del let puede haber m\u00e1s de una expresi\u00f3n: 1 2 3 4 5 6 ( let (( x 10 ) ( y 20 )) ( display \"x: \" ) ( display x ) ( display \"\\ny: \" ) ( display y )) Let en el cuerpo de una funci\u00f3n A diferencia de define s\u00ed que es posible usar let en cualquier expresi\u00f3n de Scheme, por ejemplo, en un if : 1 2 3 4 5 ( define ( suma-10-si-mayor-que-0 x ) ( if ( > x 0 ) ( let (( y 10 )) ( + x y )) x )) 4.3. Clausuras y estado local \u00b6 Recordemos que la forma especial lambda permite crear funciones an\u00f3nimas en tiempo de ejecuci\u00f3n. Si ejecutamos una forma especial lambda como \u00faltimo paso de una funci\u00f3n, se devolver\u00e1 la funci\u00f3n reci\u00e9n creada. \u00bfQu\u00e9 sucede si utilizamos en el cuerpo de esta funci\u00f3n an\u00f3nima una variable local definida en la funci\u00f3n principal? Vamos a verlo: 1 2 3 ( define ( make-sumador ) ( define z 10 ) ( lambda ( x ) ( + x z ))) La funci\u00f3n make-sumador define una variable local z con el valor de 10. Y despu\u00e9s construye una funci\u00f3n con la expresi\u00f3n lambda . Al ser la \u00faltima expresi\u00f3n de la funci\u00f3n make-sumador , esta funci\u00f3n construida en tiempo de ejecuci\u00f3n es lo que se devuelve. Si invocamos a make-sumador vemos que devuelve un procedimiento: 1 ( make-sumador ) ; \u21d2 #<procedure> Si guardamos el procedimiento en una variable y despu\u00e9s lo invocamos, tendremos que pasarle un par\u00e1metro (correspondiente al argumento x de la expresi\u00f3n lambda ). \u00bfQu\u00e9 devolver\u00e1 esa invocaci\u00f3n? 1 2 ( define f ( make-sumador )) ( f 5 ) ; \u21d2 ??? Al invocar a f se ejecutar\u00e1 el cuerpo del procedimiento, esto es, la expresi\u00f3n (+ x z) . La variable x valdr\u00e1 5 (el valor del par\u00e1metro). Pero, \u00bfcu\u00e1l es el valor de la variable z?. Podemos comprobar que es 10, porque la invocaci\u00f3n devuelve devuelve 15: 1 ( f 5 ) ; \u21d2 15 \u00bfPor qu\u00e9? Lo que est\u00e1 pasando es que la funci\u00f3n an\u00f3nima que crea la expresi\u00f3n lambda captura las variables locales definidas en el \u00e1mbito en el que se crea. Por eso recibe el nombre de clausura , porque encierra los valores que tienen esas variables en el momento de su creaci\u00f3n y esos valores son los que usa en las variables libres cuando posteriormente la invoquemos. En el ejemplo anterior se est\u00e1 capturando la variable z con su valor 10. Cuando despu\u00e9s invocamos a (f 5) se eval\u00faa el cuerpo (+ x z) con x valiendo 5 y z valiendo el valor capturado (10). Tambi\u00e9n podemos utilizar como estado local el valor de un par\u00e1metro. Por ejemplo: 1 2 3 4 5 6 ( define ( make-sumador k ) ( lambda ( x ) ( + x k ))) ( define f ( make-sumador 10 )) ( f 2 ) ; \u21d2 12 En la funci\u00f3n (make-sumador k) se llama a la forma especial lambda para crear una clausura. La clausura captura la variable local k (el par\u00e1metro de make-sumador ) y usar\u00e1 su valor cuando posteriormente se eval\u00fae. En este caso, la clausura se ha creado con k valiendo 10, y captura este valor. Cuando despu\u00e9s se invoca a (f 2) se ejecuta la clausura en un nuevo \u00e1mbito local con las siguientes variables y valores: 1 2 x : 2 ( variable local de la clausura ) k : 10 ( valor capturado del entorno local en el que se cre\u00f3 la clausura En este \u00e1mbito se ejecuta la expresi\u00f3n (+ x k) , devolvi\u00e9ndose el valor 12. Por \u00faltimo, tambi\u00e9n es posible crear la clausura dentro de un estado local definido con un let y usar en el cuerpo del lambda variables locales definidas en el let : 1 2 3 4 5 6 7 ( define ( make-sumador-cuadrado k ) ( if ( > k 0 ) ( let (( y ( cuadrado k ))) ( lambda ( x ) ( + x y ))) ( lambda ( x ) x ))) La funci\u00f3n anterior tiene un condicional en el que se comprueba si k es mayor que 0. Si lo es, se devuelve una clausura creada en el \u00e1mbito del let con la variable y capturada con el valor del cuadrado de k . Esta clausura suma a su entrada el valor de y . Por ejemplo: 1 2 ( define f ( make-sumador-cuadrado 4 )) ( f 3 ) ; \u21d2 19 En el caso en que k menor o igual que 0, se devuelve una clausura que devuelve siempre el valor que recibe: 1 2 ( define f ( make-sumador-cuadrado -8 )) ( f 3 ) ; \u21d2 3 La definici\u00f3n de clausuras con un estado local inicializado a un valor creado en tiempo de ejecuci\u00f3n es una caracter\u00edstica muy potente. Permite no s\u00f3lo crear funciones en tiempo de ejecuci\u00f3n para utilizarlas posteriormente, sino configurarlas con el estado local que nos interese. Veremos en el apartado siguiente que la combinaci\u00f3n de clausuras y mutaci\u00f3n permite crear funciones con estado local mutable, algo equivalente a objetos que encapsulan c\u00f3digo y estado. 5. Clausuras con mutaci\u00f3n = estado local mutable \u00b6 5.1. Estado local mutable \u00b6 Si combinamos una clausura con la posibilidad de mutar las variables capturadas por la clausura obtenemos un estado local mutable asociado a funciones creadas en tiempo de ejecuci\u00f3n. Veamos, por ejemplo, la siguiente funci\u00f3n (make-contador i) : 1 2 3 4 5 ( define ( make-contador i ) ( define x i ) ( lambda () ( set! x ( + x 1 )) x ))) La funci\u00f3n make-contador define una clausura que captura la variable local x inicializada a i . En cada invocaci\u00f3n a la clausura se ejecuta una sentencia set que modifica el valor de la variable capturada. Y despu\u00e9s se devuelve el nuevo valor de la variable. Estamos implementando un contador asociado a la clausura. 1 2 3 ( define f ( make-contador 10 )) ( f ) \u21d2 11 ( f ) \u21d2 12 El estado (el valor del contador) se mantiene y se modifica entre distintas invocaciones a f . A diferencia del paradigma funcional podemos comprobar que distintas invocaciones a la misma funci\u00f3n devuelven valores distintos (dependiente del estado de la clausura). Podemos crear distintas clausuras, cada una con su variable capturada, en distintas invocaciones a make-contador : 1 2 3 4 5 6 ( define h ( make-contador 10 )) ( define g ( make-contador 100 )) ( h ) \u21d2 11 ( h ) \u21d2 12 ( g ) \u21d2 101 ( g ) \u21d2 102 Una forma alternativa de crear la clausura, sin usar la forma especial lambda es defini\u00e9ndola con un define en el cuerpo de make-contador . Despu\u00e9s de los dos define la \u00faltima sentencia devuelve la funci\u00f3n incrementa (la clausura). 1 2 3 4 5 6 ( define ( make-contador i ) ( define x i ) ( define ( incrementa ) ( set! x ( + x 1 )) x ) incrementa ) 5.2. Paso de mensajes \u00b6 En el ejemplo anterior creamos una clausura que siempre incrementa el valor del contador. \u00bfC\u00f3mo podr\u00edamos crear una clausura que permitiera hacer distintas cosas con el valor capturado? Una forma de hacerlo es definir en la clausura un par\u00e1metro adicional (un s\u00edmbolo que llamamos mensaje ) y devolver distintas clausuras en funci\u00f3n del valor de ese par\u00e1metro adicional: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ( define ( make-contador i ) ( define x i ) ( define ( get ) x ) ( define ( inc-1 ) ( set! x ( + x 1 )) x ) ( define ( inc y ) ( set! x ( + x y )) x ) ( define ( dispatcher mensaje ) ( cond (( equal? mensaje 'get ) get ) (( equal? mensaje 'inc-1 ) inc-1 ) (( equal? mensaje 'inc ) inc ) ( else \"Error: mensaje desconocido\" ))) dispatcher ) La funci\u00f3n make-contador devuelve la clausura dispatcher que se encarga de procesar el mensaje y devolver la clausura asociada a ese mensaje. Cuando invoquemos al dispatcher con un s\u00edmbolo, devuelve otro procedimiento que hay que volver a invocar con los par\u00e1metros adecuados (sin par\u00e1metros en los dos primeros casos y con el valor a incrementar en el \u00faltimo caso): Si recibe el s\u00edmbolo 'get devuelve la clausura que devuelve el valor del contador Si recibe el s\u00edmbolo 'inc-1 devuelve la clausura que incrementa el valor del contador en 1 Si recibe el s\u00edmbolo 'inc devuelve la clausura que incrementa el valor del contador una cantidad determinada Por ejemplo: 1 2 3 4 ( define c ( make-contador 100 )) (( c 'get )) \u21d2 100 (( c 'inc-1 )) \u21d2 101 (( c 'inc ) 10 ) \u21d2 111 Lenguajes y Paradigmas de Programaci\u00f3n, curso 2016-17 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Domingo Gallardo, Cristina Pomares","title":"Tema 5: Programaci\u00f3n imperativa"},{"location":"teoria/tema05-bis-programacion-imperativa/tema05-programacion-imperativa.html#tema-5-programacion-imperativa","text":"","title":"Tema 5: Programaci\u00f3n imperativa"},{"location":"teoria/tema05-bis-programacion-imperativa/tema05-programacion-imperativa.html#contenidos","text":"1. Historia y caracter\u00edsticas de la programaci\u00f3n imperativa 1.1. Historia de la programaci\u00f3n imperativa 1.2. Caracter\u00edsticas principales de la programaci\u00f3n imperativa 2. Programaci\u00f3n imperativa en Scheme 2.1. Pasos de ejecuci\u00f3n 2.2. Mutaci\u00f3n con formas especiales set! 2.3. Igualdad de referencia y de valor 3. Estructuras de datos mutables 3.1. Mutaci\u00f3n de elementos 3.2. Funciones mutadoras: make-ciclo! , append! y intercambia! 3.3. Lista ordenada mutable 3.4. Diccionario mutable 3.5. Ejemplo de mutaci\u00f3n con listas de asociaci\u00f3n 4. \u00c1mbitos de variables y clausuras 4.1. Variables de \u00e1mbito global 4.2. Variables de \u00e1mbito local 4.3. Clausuras y estado local 5. Clausuras con mutaci\u00f3n = estado local mutable 5.1. Estado local mutable 5.2. Paso de mensajes","title":"Contenidos"},{"location":"teoria/tema05-bis-programacion-imperativa/tema05-programacion-imperativa.html#bibliografia","text":"En este tema explicamos conceptos de los siguientes cap\u00edtulos del libro Structure and Intepretation of Computer Programs : 3.3.1 Mutable List Structure 3.3.2 Representing Queues 3.3.3 Representing tables 3.1.1 Local State Variables 3.1.3 The Cost of Introducing Assignment","title":"Bibliograf\u00eda"},{"location":"teoria/tema05-bis-programacion-imperativa/tema05-programacion-imperativa.html#1-historia-y-caracteristicas-de-la-programacion-imperativa","text":"","title":" 1. Historia y caracter\u00edsticas de la programaci\u00f3n imperativa"},{"location":"teoria/tema05-bis-programacion-imperativa/tema05-programacion-imperativa.html#11-historia-de-la-programacion-imperativa","text":"","title":"1.1. Historia de la programaci\u00f3n imperativa"},{"location":"teoria/tema05-bis-programacion-imperativa/tema05-programacion-imperativa.html#12-caracteristicas-principales-de-la-programacion-imperativa","text":"Idea principal de la programaci\u00f3n imperativa: la computaci\u00f3n se realiza cambiando el estado del programa por medio de sentencias que definen pasos de ejecuci\u00f3n del computador Estado del programa modificable Sentencias de control que definen pasos de ejecuci\u00f3n Vamos a ver unos ejemplos de estas caracter\u00edsticas usando el lenguaje de programaci\u00f3n Java.","title":" 1.2. Caracter\u00edsticas principales de la programaci\u00f3n imperativa"},{"location":"teoria/tema05-bis-programacion-imperativa/tema05-programacion-imperativa.html#2-programacion-imperativa-en-scheme","text":"Al igual que LISP, Scheme tiene caracter\u00edsticas imperativas Vamos a ver algunas de ellas Pasos de ejecuci\u00f3n Asignaci\u00f3n con la forma especial set! Datos mutables con las formas especiales set-car! y set-cdr! Una nota importante: todos los ejemplos que hay a continuaci\u00f3n necesitan importar la librer\u00eda mutable-pairs : 1 2 3 # lang r6rs ( import ( rnrs ) ( rnrs mutable-pairs ))","title":" 2. Programaci\u00f3n imperativa en Scheme"},{"location":"teoria/tema05-bis-programacion-imperativa/tema05-programacion-imperativa.html#21-pasos-de-ejecucion","text":"Es posible definir pasos de ejecuci\u00f3n con la forma especial begin Todas las sentencias de la forma especial se ejecutan de forma secuencial, una tras otra Tanto en la definici\u00f3n de funciones como en lambda es posible definir cuerpos de funci\u00f3n con m\u00faltiples sentencias que se ejecutan tambi\u00e9n de forma secuencial. Hasta ahora no hemos usado esta caracter\u00edstica porque hemos utilizado Scheme de forma funcional. Ejemplo begin : 1 2 3 4 5 6 7 8 9 10 11 12 ( begin ( display \"Escribe un n\u00famero: \" ) ( define x ( read )) ( display \"Escribe otro: \" ) ( define y ( read )) ( define maximo ( max x y )) ( display ( string-append \"El m\u00e1ximo de \" ( number->string x ) \" y \" ( number->string y ) \" es \" ( number->string maximo )))) Ejemplo de pasos de ejecuci\u00f3n en la definici\u00f3n de una funci\u00f3n: 1 2 3 4 5 6 7 ( define ( display-tres-valores a b c ) ( display a ) ( newline ) ( display b ) ( newline ) ( display c ) ( newline ))","title":" 2.1. Pasos de ejecuci\u00f3n"},{"location":"teoria/tema05-bis-programacion-imperativa/tema05-programacion-imperativa.html#22-mutacion-con-formas-especiales-set","text":"","title":" 2.2. Mutaci\u00f3n con formas especiales set!"},{"location":"teoria/tema05-bis-programacion-imperativa/tema05-programacion-imperativa.html#23-igualdad-de-referencia-y-de-valor","text":"La utilizaci\u00f3n de referencias, la mutaci\u00f3n y los efectos laterales hace tambi\u00e9n necesario definir dos tipos de igualdades: igualdad de referencia e igualdad de valor. Igualdad de referencia: dos variables son iguales cuando apuntan al mismo valor Igualdad de valor: dos variables son iguales cuando contienen el mismo valor En Scheme la funci\u00f3n eq? comprueba la igualdad de referencia y equal? la igualdad de valor Igualdad de referencia implica igualdad de valor, pero no al rev\u00e9s Ejemplo: 1 2 3 4 5 6 7 8 ( define p1 ( cons 10 20 )) ( define p2 p1 ) ( define p3 ( cons 10 20 )) ( equal? p3 p1 ) ; \u21d2 #t ( eq? p3 p1 ) ; \u21d2 #f ( eq? p2 p1 ) ; \u21d2 #t ( set! p3 p1 ) ;; La asignaci\u00f3n copia referencias ( eq? p3 p1 ) ; \u21d2 #t","title":" 2.3. Igualdad de referencia y de valor"},{"location":"teoria/tema05-bis-programacion-imperativa/tema05-programacion-imperativa.html#3-estructuras-de-datos-mutables","text":"La utilizaci\u00f3n de las formas especiales set-car! y set-cdr! permite un estilo nuevo de manejo de las estructuras de datos ya vistas (listas o \u00e1rboles) Es posible implementar funciones m\u00e1s eficientes que actualizan la estructura modificando directamente las referencias de unas celdas a otras Las operaciones no construyen estructuras nuevas, sino que modifican la ya existente","title":" 3. Estructuras de datos mutables"},{"location":"teoria/tema05-bis-programacion-imperativa/tema05-programacion-imperativa.html#31-mutacion-de-elementos","text":"Ejemplo 1 Vamos a empezar con un ejemplo sencillo en el que vamos a mutar un elemento de una estructura de datos formada por parejas. Supongamos la siguiente estructura: 1 2 3 4 ( define datos ( cons 2 ( cons ( cons 5 ( cons 8 9 )) ( cons 3 4 )))) El diagrama box-and-pointer es el siguiente. F\u00edjate que hay elementos de las parejas que son datos at\u00f3micos y otros que son referencias a otras parejas. Vamos ahora a mutar la estructura utilizando las sentencias set-car! y set-cdr! . Para mutar una pareja acceder a la pareja y modificar su parte derecha o su parte izquierda con las sentencias anteriores. Por ejemplo, \u00bfc\u00f3mo cambiar\u00edamos el 8 por un 18 ? Deber\u00edamos obtener la pareja (8 . 9) que est\u00e1 al final de la estructura y modificar su parte izquierda: 1 ( set-car! ( cdr ( car ( cdr datos ))) 18 ) La expresi\u00f3n (cdr (car (cdr datos))) devuelve la pareja que queremos modificar y la sentencia set-car! modifica su parte izquierda. Si ahora vemos qu\u00e9 hay en datos veremos que se ha modificado la estructura: 1 2 ( print-pareja datos ) ; \u21d2 (2 . ((5 . (18 . 9)) . (3 . 4))) Recuerda que print-pareja es una funci\u00f3n que vimos anteriormente. Hemos mutado un dato por otro. Tambi\u00e9n podemos mutar las referencias a las parejas. Por ejemplo, podr\u00edamos modificar la parte derecha de la pareja que contiene el 5 para que apunte a la pareja (3 . 4) : Para ello habr\u00eda que obtener la pareja que contiene el 5 con la expresi\u00f3n (car (cdr datos)) y mutar su parte derecha ( set-cdr! ) con la referencia a la pareja (3 . 4) que se obtiene con la expresi\u00f3n (cdr (cdr datos)) : 1 ( set-cdr! ( car ( cdr datos )) ( cdr ( cdr datos ))) Ejemplo 2 Veamos un segundo ejemplo. Supongamos las siguientes sentencias. \u00bfCu\u00e1l ser\u00eda el box-and-pointer resultante? 1 2 3 4 5 6 ( define x ' (( a b ) c d )) ( define y ' ( e f )) ( set-car! x y ) ( define z ( cons y ( cdr x ))) ( set-cdr! x y ) ( set-car! z ( caar x )) Debemos ir paso a paso ejecutando cada instrucci\u00f3n y dibujando c\u00f3mo cambia el diagrama. El diagrama representa el estado del programa , y es un conjunto de parejas que contienen valores y referencias entre ellas. Es muy importante considerar cu\u00e1ndo la sentencia copia un valor y cuando copia una referencia. Las parejas siempre tienen sem\u00e1ntica de referencia. El diagrama resultante despu\u00e9s de las dos primeras sentencias es: Y el diagrama despu\u00e9s de todas las sentencias es: Los valores de las variables despu\u00e9s de todas las sentencias son los siguientes: 1 2 3 x ; \u21d2 {{e f} e f} y ; \u21d2 {e f} z ; \u21d2 {e c d} Ejemplo 3 En este ejemplo vamos a usar una nueva forma especial de Scheme que permite crear variables locales y ejecutar expresiones en las que se utilicen esas variables. Se trata de la forma especial let . Veremos algo m\u00e1s de esta forma especial m\u00e1s adelante, cuando hablemos de \u00e1mbitos de variables. Por ahora es suficiente saber que permite crear variables locales y ejecutar un cuerpo (que puede tener m\u00e1s de una sentencia) con esas variables. 1 2 3 4 ( let (( x ( + 2 3 )) ( y ( * 2 10 )) ( + x y )) ; \u21d2 25 En este caso let permite crear dos variables locales x e y y asignarles los valores 5 y 20 respectivamente. Las sentencias del cuerpo del let (en este caso la sentencia (+ x y) ) se eval\u00faan con estos valores reci\u00e9n creados. Vamos a usar esta forma especial en ocasiones para guardar valores o referencias que despu\u00e9s necesitamos asignar. Por ejemplo, \u00bfc\u00f3mo podr\u00edamos definir una funci\u00f3n que mute las referencias de una lista para intercambiar sus posiciones segunda y tercera (sin crear nuevas parejas)? Si llamamos a la funci\u00f3n intercambia! deber\u00eda hacer lo siguiente: 1 2 3 ( define lista ' ( 1 2 3 4 5 6 )) ( intercambia! lista ) lista ; \u21d2 {1 3 2 4 5 6} Dibujando el diagrama box-and-pointer podemos ver las mutaciones que tenemos que hacer: La funci\u00f3n es la siguiente: 1 2 3 4 5 6 ( define ( intercambia! lista ) ( let (( segundo ( cdr lista )) ( tercero ( cddr lista ))) ( set-cdr! lista tercero ) ( set-cdr! segundo ( cdr tercero )) ( set-cdr! tercero segundo )))","title":" 3.1. Mutaci\u00f3n de elementos"},{"location":"teoria/tema05-bis-programacion-imperativa/tema05-programacion-imperativa.html#32-funciones-mutadoras-make-ciclo-append-e-intercambia-lista","text":"Veamos ahora varios ejemplos de funciones recursivas que recorren listas y realizan mutaciones en ellas. Normalmente las funciones mutadoras no devuelven una estructura, sino que modifican la que se pasa como par\u00e1metro. Por convenio, indicaremos que una funci\u00f3n es mutadora terminando su nombre con un signo de admiraci\u00f3n. make-ciclo! Empecemos con una funci\u00f3n muta una lista, haciendo que la parte derecha de la \u00faltima pareja apunte a la pareja inicial de la misma. Para conseguirlo, necesitamos guardar la referencia a la pareja inicial de la lista en el primer par\u00e1metro de la funci\u00f3n. Y el segundo par\u00e1metro ir\u00e1 avanzando hasta encontrar el final de la lista: 1 2 3 4 ( define ( make-ciclo! lista ref ) ( if ( null? ( cdr ref )) ( set-cdr! ref lista ) ( make-ciclo! lista ( cdr ref )))) Si probamos la funci\u00f3n con una lista, podemos comprobar que DrRacket detecta el ciclo que se produce al final de la misma: 1 2 3 ( define lista ' ( 1 2 3 4 5 6 )) ( make-ciclo! lista lista ) lista ; \u21d2 #0={1 2 3 4 5 6 . #0#} Una forma alternativa de implementar esta funci\u00f3n es mediante una funci\u00f3n que devuelva la referencia de la \u00faltima pareja de la lista: 1 2 3 4 5 6 7 8 ( define ( ultima-pareja lista ) ( if ( null? ( cdr lista )) lista ( ultima-pareja ( cdr lista )))) ( define ( make-ciclo2! lista ) ( let (( ultima-pareja ( ultima-pareja lista ))) ( set-cdr! ultima-pareja lista ))) append! Y vemos a continuaci\u00f3n una versi\u00f3n mutadora de append que llamamos append! y que mejora la eficiencia de la original, copiando al final de la primera lista una referencia a la segunda: La implementaci\u00f3n es la siguiente: 1 2 3 4 ( define ( append! l1 l2 ) ( if ( null? ( cdr l1 )) ( set-cdr! l1 l2 ) ( append! ( cdr l1 ) l2 ))) Ejemplo: 1 2 3 4 ( define a ' ( 1 2 3 4 )) ( define b ' ( 5 6 7 )) ( append! a b ) a ; \u21d2 {1 2 3 4 5 6 7} Algunas puntualizaciones: Al igual que set! , set-car! o set-cdr! , la funci\u00f3n append! no devuelve ning\u00fan valor, sino que modifica directamente la lista que se pasa como primer par\u00e1metro. Al modificarse la lista, todas las referencias que apuntan a ellas quedan tambi\u00e9n modificadas. La funci\u00f3n dar\u00eda un error en el caso en que la llam\u00e1ramos con una lista vac\u00eda como primer argumento. intercambia-lista! Un \u00faltimo ejemplo de funci\u00f3n recursiva que muta una lista. Queremos definir una funci\u00f3n que intercambie todas las parejas excepto la primera de una lista con un n\u00famero de datos impar, pero sin usar set-car! . Llamamos a la funci\u00f3n (intercambia-lista! lista) y deber\u00eda hacer lo siguiente: 1 2 3 ( define lista ' ( 1 2 3 4 5 6 7 )) ( intercambia-lista! lista ) lista ; \u21d2 {1 3 2 5 4 7 6} La forma de implementar esta funci\u00f3n va a ser llamando a la funci\u00f3n intercambia! (la que hemos definido anteriormente que intercambia el segundo y el tercer elemento) hasta que lleguemos al final de la lista. Lo hacemos con una recursi\u00f3n: 1 2 3 4 5 ( define ( intercambia-lista! lista ) ( if ( not ( null? ( cdr lista ))) ( begin ( intercambia! lista ) ( intercambia-lista! ( cddr lista ))))) La funci\u00f3n termina cuando llegamos a la pareja final de la lista, la que tiene la lista vac\u00eda en su parte derecha. Si no estamos en el final de la lista llamamos a la funci\u00f3n intercambia! para intercambiar la siguiente pareja con su siguiente y llamamos a la recursi\u00f3n con la variable lista apuntando a la tercera pareja de la lista.","title":" 3.2. Funciones mutadoras: make-ciclo!, append! e intercambia-lista!"},{"location":"teoria/tema05-bis-programacion-imperativa/tema05-programacion-imperativa.html#33-lista-ordenada-mutable","text":"Veamos ahora una lista ordenada mutable de n\u00fameros, en la que insertaremos elementos de forma ordenada. Definiremos las siguientes funciones: (make-olist) : construye una lista ordenada vac\u00eda (borra-primero-olist! olist) : funci\u00f3n mutadora que elimina (con mutaci\u00f3n) el primer elemento de la lista (inserta-olist! olist n) : funci\u00f3n mutadora que inserta (con mutaci\u00f3n) de forma ordenada un n\u00famero en la lista Implementamos el tipo de datos con una lista normal con una pareja adicional en cabeza. Esta pareja adicional funcionar\u00e1 de cabecera de la lista y ser\u00e1 la referencia inmutable a la que apuntar\u00e1 cualquier variable que apunte a la lista. De esta forma podremos insertar elementos en primera posici\u00f3n de la lista. En la cabecera usaremos por convenio el s\u00edmbolo '*olist*' . 1 ( define lista ' ( *olist* 10 20 30 )) Constructor El constructor (make-olist) devuelve una lista s\u00f3lo con la cabecera. 1 2 ( define ( make-olist ) ( list '*olist* )) Mutadores Las funciones mutadoras modifican la estructura de datos. Comenzamos con la funci\u00f3n (borra-primero-olist! olist) que elimina con mutaci\u00f3n el primer elemento de la lista ordenada: 1 2 ( define ( borra-primero-olist! olist ) ( set-cdr! olist ( cddr olist ))) Definimos la funci\u00f3n mutadora inserta-olist! que modifica la lista ordenada a\u00f1adiendo una nueva pareja, insert\u00e1ndola en la posici\u00f3n correcta modificando las referencias. La funci\u00f3n (add-item! item ref) es la funci\u00f3n clave que crea una nueva pareja con el item y la a\u00f1ade en el cdr de la pareja a la que apunta ref . 1 2 3 4 5 6 7 8 9 ( define ( add-item! ref item ) ( set-cdr! ref ( cons item ( cdr ref )))) ( define ( inserta-olist! olist n ) ( cond (( null? ( cdr olist )) ( add-item! olist n )) (( < n ( cadr olist )) ( add-item! olist n )) (( = n ( cadr olist )) #f ) ; el valor devuelto no importa ( else ( inserta-olist! ( cdr olist ) n )))) Ejemplo de uso: 1 2 3 4 5 ( define c ( make-olist )) ( inserta-olist! c 5 ) ( inserta-olist! c 10 ) ( inserta-olist! c -10 ) c ; \u21d2 {*olist* -10 5 10}","title":" 3.3. Lista ordenada mutable"},{"location":"teoria/tema05-bis-programacion-imperativa/tema05-programacion-imperativa.html#34-diccionario-mutable","text":"Veamos ahora un ejemplo m\u00e1s: un diccionario mutable definido mediante una lista de asociaci\u00f3n formada por parejas de clave y valor 1 ( define l-assoc ( list ( cons 'a 1 ) ( cons 'b 2 ) ( cons 'c 3 ))) La funci\u00f3n de Scheme assq recorre la lista de asociaci\u00f3n y devuelve la tupla que contiene el dato que se pasa como par\u00e1metro como clave 1 2 3 4 5 ( assq 'a l-assoc ) ; \u21d2 (a.1) ( assq 'b l-assoc ) ; \u21d2 (b.2) ( assq 'c l-assoc ) ; \u21d2 (c.3) ( assq 'd l-assoc ) ; \u21d2 #f ( cdr ( assq 'c l-assoc )) ; \u21d2 3 La funci\u00f3n assq busca en la lista de asociaci\u00f3n usando la igualdad de referencia eq? 1 2 3 4 ( define p ( cons 1 2 )) ( define l-assoc ( list ( cons 'a 1 ) ( cons p 2 ) ( cons 'c 3 ))) ( assq ( cons 1 2 ) l-assoc ) ; \u21d2 #f ( assq p l-assoc ) ; \u21d2 {{1 . 2} . 2} Las funciones que vamos a implementar del diccionario son las siguientes: (make-dic) : construye un diccionario vac\u00edo (put-dic! dic clave valor) : inserta en el diccionario un nuevo valor asociado a una clave (get-dic dic clave) : devuelve el valor asociado a una clave en un diccionario Al igual que la lista ordenada mutable, el diccionario necesita una cabecera: 1 2 ( define ( make-dic ) ( list '*dic* )) La funci\u00f3n (get-dic dic clave) usa la funci\u00f3n assq para buscar la pareja que contiene una clave determinada en la lista de asociaci\u00f3n (el cdr de dic). Y despu\u00e9s devuelve el cdr de esa pareja (el valor guardado junto con la clave: 1 2 3 4 5 ( define ( get-dic dic clave ) ( let ( pareja ( assq clave ( cdr dic ))) ( if ( not pareja ) #f ( cdr pareja )))) La funci\u00f3n (put-dic! dic clave valor) usa igual que antes la funci\u00f3n assq para comprobar si la clave ya est\u00e1 en la lista de asociaci\u00f3n. Si existe, sustituye el valor por el nuevo. Si no existe, crea una pareja con la clave y el valor y la inserta al comienzo del diccionario (despu\u00e9s de la cabecera): 1 2 3 4 5 6 7 8 ( define ( put-dic! dic clave valor ) ( let ( pareja ( assq clave ( cdr dic ))) ( if ( not pareja ) ( set-cdr! dic ( cons ( cons clave valor ) ( cdr dic ))) ( set-cdr! pareja valor ))) 'ok ) En las funciones anteriores volvemos a usar la forma especial let . Ejemplos de uso: 1 2 3 4 5 6 7 ( define dic ( make-dic )) ( put-dic! dic 'a 10 ) ; \u21d2 ok ( get-dic dic 'a ) ; \u21d2 10 ( put-dic! dic 'b ' ( a b c )) ; \u21d2 ok ( get-dic dic 'b ) ; \u21d2 {a b c} ( put-dic! dic 'a 'ardilla ) ; \u21d2 ok ( get-dic dic 'a ) ; \u21d2 ardilla","title":" 3.4. Diccionario mutable"},{"location":"teoria/tema05-bis-programacion-imperativa/tema05-programacion-imperativa.html#35-ejemplo-de-mutacion-con-listas-de-asociacion","text":"Una vez introducidos distintas estructuras de datos mutables, incluyendo listas de asociaci\u00f3n, vamos a terminar estos ejemplos con un ejemplo pr\u00e1ctico en el que intervienen las listas y las listas de asociaci\u00f3n. Se trata de escribir un procedimiento regular->assoc! que transforme una lista regular en una lista de asociaci\u00f3n sin crear nuevas parejas. La lista regular (k1 v1 k2 v2 k3 v3 ...) deber\u00e1 convertirse en la lista de asociaci\u00f3n ((k1 . v1) (k2 . v2) (k3 . v3) ...) . Ejemplo: 1 2 3 4 ( define my-list ( list 'a 1 'b 2 'c 3 )) lista ; \u21d2 (a 1 b 2 c 3) ( regular->assoc! my-list ) lista ; \u21d2 ((a . 1) (b . 2) (c . 3)) Una posible soluci\u00f3n a este problema ser\u00eda la siguiente (no es la \u00fanica soluci\u00f3n): Cuando trabajamos con este tipo de problemas, es muy \u00fatil ayudarse con los diagramas caja y puntero. Vamos a crear los diagramas caja y puntero para el ejemplo anterior: Antes de llamar a regular->assoc!: Despu\u00e9s de llamar a regular->assoc!: Queremos hacer la transformaci\u00f3n sin crear nuevas parejas, por lo que cada pareja en el primer diagrama corresponde a una pareja particular en el segundo diagrama. No podemos modificar la primera pareja de la lista (porque perder\u00edamos la ligadura de la variable lista ), por lo que es primera pareja tiene que permanecer en el primer lugar. Por otra parte, a y 1 van a formar parte del mismo par en la lista de asociaci\u00f3n, por lo que vamos a considerar el siguiente cambio de las dos primeras parejas. Diagrama inicial: Despu\u00e9s del cambio de las dos primeras parejas: La siguiente funci\u00f3n manejar-dos-parejas! es la encargada de hacer esta mutaci\u00f3n: 1 2 3 4 5 6 ( define ( manejar-dos-parejas! p ) ( let (( key ( car p ))) ;; 1 ( set-car! p ( cdr p )) ;; 2 ( set-cdr! p ( cdar p )) ;; 3 ( set-cdr! ( car p ) ( caar p )) ;; 4 ( set-car! ( car p ) key ))) ;; 5 Se han numerado las l\u00edneas para una mejor explicaci\u00f3n. En la l\u00ednea 1, (define key (car p)) , creamos una variable local key que guarda el valor actual del (car p) , ese valor ser\u00e1 la clave de la primera pareja de la lista de asociaci\u00f3n; necesitamos almacenarlo para no perderlo. En la l\u00ednea 2, (set-car! p (cdr p)) , cambiamos el car de p para que apunte a la siguiente pareja (la azul): En la l\u00ednea 3, (set-cdr! p (cdar p)) , copiamos en el cdr de p el cdr de la pareja en azul para que ambos apunten a la siguiente pareja: En la l\u00ednea 4, (set-cdr! (car p) (caar p)) , cambiamos el cdr de la pareja en azul al car de la misma pareja. Hacemos \u00e9sto porque en una lista de asociaci\u00f3n, los valores se guardan en los cdrs y las claves en los cars : Por \u00faltimo, en la l\u00ednea 5 (set-car! (car p) key) , completamos el problema poniendo la clave que hab\u00edamos guardado, en el car de la pareja azul: Reordenamos el diagrama para verlo m\u00e1s claro: Hemos definido un procedimiento que maneja un subproblema (dos parejas) del problema. Ahora s\u00f3lo nos queda definir la funci\u00f3n que maneja toda la lista: 1 2 3 4 5 ( define ( regular->assoc! lista ) ( if ( null? lista ) 'ok ( begin ( manejar-dos-parejas! lista ) ( regular->assoc! ( cdr lista )))))","title":" 3.5. Ejemplo de mutaci\u00f3n con listas de asociaci\u00f3n"},{"location":"teoria/tema05-bis-programacion-imperativa/tema05-programacion-imperativa.html#4-ambitos-de-variables-y-clausuras","text":"El concepto del \u00e1mbito de vida de las variables es un concepto fundamental en los lenguajes de programaci\u00f3n. Utilizaremos las palabras \u00e1mbito y entorno como sin\u00f3nimos. En ingl\u00e9s se utiliza el t\u00e9rmino scope . Cuando se define una variable, asoci\u00e1ndole un valor, esta asociaci\u00f3n tiene una extensi\u00f3n determinada, ya sea en t\u00e9rminos de tiempo de compilaci\u00f3n ( \u00e1mbito l\u00e9xico ) como en t\u00e9rminos de tiempo de ejecuci\u00f3n ( \u00e1mbito din\u00e1mico ). El \u00e1mbito de una variable determina cu\u00e1ndo podemos referirnos a ella para recuperar el valor asociado. Al conjunto de variables disponibles en una parte del programa o en una parte de su ejecuci\u00f3n se denomina contexto o entorno ( context o environment ).","title":" 4. \u00c1mbitos de variables y clausuras"},{"location":"teoria/tema05-bis-programacion-imperativa/tema05-programacion-imperativa.html#41-variables-de-ambito-global","text":"Una variable definida en el programa con la instrucci\u00f3n define tiene un \u00e1mbito global. 1 2 3 ( define a \"hola\" ) ( define b ( string-append \"adios\" a )) ( define cuadrado ( lambda ( x ) ( * x x ))) Todas las variables definidas fuera de funciones forman parte del entorno global del programa.","title":" 4.1. Variables de \u00e1mbito global"},{"location":"teoria/tema05-bis-programacion-imperativa/tema05-programacion-imperativa.html#42-variables-de-ambito-local","text":"En Scheme existen dos formas de definir variables de \u00e1mbito local: la forma especial define dentro de una funci\u00f3n y la forma especial let .","title":" 4.2. Variables de \u00e1mbito local"},{"location":"teoria/tema05-bis-programacion-imperativa/tema05-programacion-imperativa.html#43-clausuras-y-estado-local","text":"Recordemos que la forma especial lambda permite crear funciones an\u00f3nimas en tiempo de ejecuci\u00f3n. Si ejecutamos una forma especial lambda como \u00faltimo paso de una funci\u00f3n, se devolver\u00e1 la funci\u00f3n reci\u00e9n creada. \u00bfQu\u00e9 sucede si utilizamos en el cuerpo de esta funci\u00f3n an\u00f3nima una variable local definida en la funci\u00f3n principal? Vamos a verlo: 1 2 3 ( define ( make-sumador ) ( define z 10 ) ( lambda ( x ) ( + x z ))) La funci\u00f3n make-sumador define una variable local z con el valor de 10. Y despu\u00e9s construye una funci\u00f3n con la expresi\u00f3n lambda . Al ser la \u00faltima expresi\u00f3n de la funci\u00f3n make-sumador , esta funci\u00f3n construida en tiempo de ejecuci\u00f3n es lo que se devuelve. Si invocamos a make-sumador vemos que devuelve un procedimiento: 1 ( make-sumador ) ; \u21d2 #<procedure> Si guardamos el procedimiento en una variable y despu\u00e9s lo invocamos, tendremos que pasarle un par\u00e1metro (correspondiente al argumento x de la expresi\u00f3n lambda ). \u00bfQu\u00e9 devolver\u00e1 esa invocaci\u00f3n? 1 2 ( define f ( make-sumador )) ( f 5 ) ; \u21d2 ??? Al invocar a f se ejecutar\u00e1 el cuerpo del procedimiento, esto es, la expresi\u00f3n (+ x z) . La variable x valdr\u00e1 5 (el valor del par\u00e1metro). Pero, \u00bfcu\u00e1l es el valor de la variable z?. Podemos comprobar que es 10, porque la invocaci\u00f3n devuelve devuelve 15: 1 ( f 5 ) ; \u21d2 15 \u00bfPor qu\u00e9? Lo que est\u00e1 pasando es que la funci\u00f3n an\u00f3nima que crea la expresi\u00f3n lambda captura las variables locales definidas en el \u00e1mbito en el que se crea. Por eso recibe el nombre de clausura , porque encierra los valores que tienen esas variables en el momento de su creaci\u00f3n y esos valores son los que usa en las variables libres cuando posteriormente la invoquemos. En el ejemplo anterior se est\u00e1 capturando la variable z con su valor 10. Cuando despu\u00e9s invocamos a (f 5) se eval\u00faa el cuerpo (+ x z) con x valiendo 5 y z valiendo el valor capturado (10). Tambi\u00e9n podemos utilizar como estado local el valor de un par\u00e1metro. Por ejemplo: 1 2 3 4 5 6 ( define ( make-sumador k ) ( lambda ( x ) ( + x k ))) ( define f ( make-sumador 10 )) ( f 2 ) ; \u21d2 12 En la funci\u00f3n (make-sumador k) se llama a la forma especial lambda para crear una clausura. La clausura captura la variable local k (el par\u00e1metro de make-sumador ) y usar\u00e1 su valor cuando posteriormente se eval\u00fae. En este caso, la clausura se ha creado con k valiendo 10, y captura este valor. Cuando despu\u00e9s se invoca a (f 2) se ejecuta la clausura en un nuevo \u00e1mbito local con las siguientes variables y valores: 1 2 x : 2 ( variable local de la clausura ) k : 10 ( valor capturado del entorno local en el que se cre\u00f3 la clausura En este \u00e1mbito se ejecuta la expresi\u00f3n (+ x k) , devolvi\u00e9ndose el valor 12. Por \u00faltimo, tambi\u00e9n es posible crear la clausura dentro de un estado local definido con un let y usar en el cuerpo del lambda variables locales definidas en el let : 1 2 3 4 5 6 7 ( define ( make-sumador-cuadrado k ) ( if ( > k 0 ) ( let (( y ( cuadrado k ))) ( lambda ( x ) ( + x y ))) ( lambda ( x ) x ))) La funci\u00f3n anterior tiene un condicional en el que se comprueba si k es mayor que 0. Si lo es, se devuelve una clausura creada en el \u00e1mbito del let con la variable y capturada con el valor del cuadrado de k . Esta clausura suma a su entrada el valor de y . Por ejemplo: 1 2 ( define f ( make-sumador-cuadrado 4 )) ( f 3 ) ; \u21d2 19 En el caso en que k menor o igual que 0, se devuelve una clausura que devuelve siempre el valor que recibe: 1 2 ( define f ( make-sumador-cuadrado -8 )) ( f 3 ) ; \u21d2 3 La definici\u00f3n de clausuras con un estado local inicializado a un valor creado en tiempo de ejecuci\u00f3n es una caracter\u00edstica muy potente. Permite no s\u00f3lo crear funciones en tiempo de ejecuci\u00f3n para utilizarlas posteriormente, sino configurarlas con el estado local que nos interese. Veremos en el apartado siguiente que la combinaci\u00f3n de clausuras y mutaci\u00f3n permite crear funciones con estado local mutable, algo equivalente a objetos que encapsulan c\u00f3digo y estado.","title":" 4.3. Clausuras y estado local"},{"location":"teoria/tema05-bis-programacion-imperativa/tema05-programacion-imperativa.html#5-clausuras-con-mutacion-estado-local-mutable","text":"","title":" 5. Clausuras con mutaci\u00f3n = estado local mutable"},{"location":"teoria/tema05-bis-programacion-imperativa/tema05-programacion-imperativa.html#51-estado-local-mutable","text":"Si combinamos una clausura con la posibilidad de mutar las variables capturadas por la clausura obtenemos un estado local mutable asociado a funciones creadas en tiempo de ejecuci\u00f3n. Veamos, por ejemplo, la siguiente funci\u00f3n (make-contador i) : 1 2 3 4 5 ( define ( make-contador i ) ( define x i ) ( lambda () ( set! x ( + x 1 )) x ))) La funci\u00f3n make-contador define una clausura que captura la variable local x inicializada a i . En cada invocaci\u00f3n a la clausura se ejecuta una sentencia set que modifica el valor de la variable capturada. Y despu\u00e9s se devuelve el nuevo valor de la variable. Estamos implementando un contador asociado a la clausura. 1 2 3 ( define f ( make-contador 10 )) ( f ) \u21d2 11 ( f ) \u21d2 12 El estado (el valor del contador) se mantiene y se modifica entre distintas invocaciones a f . A diferencia del paradigma funcional podemos comprobar que distintas invocaciones a la misma funci\u00f3n devuelven valores distintos (dependiente del estado de la clausura). Podemos crear distintas clausuras, cada una con su variable capturada, en distintas invocaciones a make-contador : 1 2 3 4 5 6 ( define h ( make-contador 10 )) ( define g ( make-contador 100 )) ( h ) \u21d2 11 ( h ) \u21d2 12 ( g ) \u21d2 101 ( g ) \u21d2 102 Una forma alternativa de crear la clausura, sin usar la forma especial lambda es defini\u00e9ndola con un define en el cuerpo de make-contador . Despu\u00e9s de los dos define la \u00faltima sentencia devuelve la funci\u00f3n incrementa (la clausura). 1 2 3 4 5 6 ( define ( make-contador i ) ( define x i ) ( define ( incrementa ) ( set! x ( + x 1 )) x ) incrementa )","title":" 5.1. Estado local mutable"},{"location":"teoria/tema05-bis-programacion-imperativa/tema05-programacion-imperativa.html#52-paso-de-mensajes","text":"En el ejemplo anterior creamos una clausura que siempre incrementa el valor del contador. \u00bfC\u00f3mo podr\u00edamos crear una clausura que permitiera hacer distintas cosas con el valor capturado? Una forma de hacerlo es definir en la clausura un par\u00e1metro adicional (un s\u00edmbolo que llamamos mensaje ) y devolver distintas clausuras en funci\u00f3n del valor de ese par\u00e1metro adicional: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ( define ( make-contador i ) ( define x i ) ( define ( get ) x ) ( define ( inc-1 ) ( set! x ( + x 1 )) x ) ( define ( inc y ) ( set! x ( + x y )) x ) ( define ( dispatcher mensaje ) ( cond (( equal? mensaje 'get ) get ) (( equal? mensaje 'inc-1 ) inc-1 ) (( equal? mensaje 'inc ) inc ) ( else \"Error: mensaje desconocido\" ))) dispatcher ) La funci\u00f3n make-contador devuelve la clausura dispatcher que se encarga de procesar el mensaje y devolver la clausura asociada a ese mensaje. Cuando invoquemos al dispatcher con un s\u00edmbolo, devuelve otro procedimiento que hay que volver a invocar con los par\u00e1metros adecuados (sin par\u00e1metros en los dos primeros casos y con el valor a incrementar en el \u00faltimo caso): Si recibe el s\u00edmbolo 'get devuelve la clausura que devuelve el valor del contador Si recibe el s\u00edmbolo 'inc-1 devuelve la clausura que incrementa el valor del contador en 1 Si recibe el s\u00edmbolo 'inc devuelve la clausura que incrementa el valor del contador una cantidad determinada Por ejemplo: 1 2 3 4 ( define c ( make-contador 100 )) (( c 'get )) \u21d2 100 (( c 'inc-1 )) \u21d2 101 (( c 'inc ) 10 ) \u21d2 111 Lenguajes y Paradigmas de Programaci\u00f3n, curso 2016-17 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Domingo Gallardo, Cristina Pomares","title":" 5.2. Paso de mensajes"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html","text":"Tema 5: Programaci\u00f3n Funcional con Swift \u00b6 Introducci\u00f3n \u00b6 Te recomendamos que leas el seminario de Swift en el que se introduce el lenguaje y se explica c\u00f3mo ejecutar programas en este lenguaje: Seminario de Swift Conceptos fundamentales de Programaci\u00f3n Funcional \u00b6 Vamos a repasar en este tema c\u00f3mo se implementan en Swift conceptos principalmente funcionales como: Valores inmutables Funciones como objetos de primera clase y clasuras Funciones de orden superior Repasamos r\u00e1pidamente algunos conceptos b\u00e1sicos de programaci\u00f3n funcional, vistos en los primeros temas de la asignatura. Programaci\u00f3n Funcional: La Programaci\u00f3n Funcional es un paradigma de programaci\u00f3n que trata la computaci\u00f3n como la evaluaci\u00f3n de funciones matem\u00e1ticas y que evita cambios de estado y datos mutables. Funciones matem\u00e1ticas o puras: Las funciones matem\u00e1ticas tienen la caracter\u00edstica de que cuando las invocas con el mismo argumento siempre te devolver\u00e1n el mismo resultado. Funciones como objetos de primera clase: En programaci\u00f3n funcional, las funciones son objetos de primera clase del lenguaje, similares a enteros o strings . Podemos pasar funciones como argumentos en las denominadas funciones de orden superior o devolver funciones creadas en tiempo de ejecuci\u00f3n (clausuras). Caracter\u00edsticas b\u00e1sicas de Swift \u00b6 Swift es un lenguaje principalmente imperativo, pero en su dise\u00f1o se han introducido conceptos modernos de programaci\u00f3n funcional, extra\u00eddos de lenguajes como Rust o Haskell. Por ello se puede considerar un lenguaje multi-paradigma , en el que se puede definir c\u00f3digo funcional que se puede ejecutar junto con c\u00f3digo imperativo. Como dice su creador Chris Lattner : El lenguaje Swift es el resultado de un esfuerzo incansable de un equipo de expertos en lenguajes, gur\u00fas de documentaci\u00f3n, ninjas de optimizaci\u00f3n de compiladores [..]. Por supuesto, tambi\u00e9n se benefici\u00f3 enormemente de las experiencias ganadas en muchos otros lenguajes, tomando ideas de Objective-C, Rust, Haskell, Ruby, Python, C#, CLU, y demasiados otros para ser enumerados. Lenguaje fuertemente tipado A diferencia de Scheme, Swift es un lenguaje fuertemente tipado en el que hay que definir los tipos de variables, par\u00e1metros y funciones. Por ejemplo, en las siguientes declaraciones definimos variables de distintos tipos: 1 2 3 let n : Int = 10 let str : String = \"Hola\" let array : [ Int ] = [ 1 , 2 , 3 , 4 , 5 ] El compilador de Swift permite identificar los tipos de las variables cuando se realiza una asignaci\u00f3n. La t\u00e9cnica se denomina inferencia de tipos y permite declarar variables sin escribir su tipo. Por ejemplo, las variables anteriores se pueden declarar tambi\u00e9n asi: 1 2 3 let n = 10 let str = \"Hola\" let array = [ 1 , 2 , 3 , 4 , 5 ] Aunque no hayamos declarado expl\u00edcitamente el tipo de las variables, el compilador les ha asignado el tipo correspondiente. Por ejemplo, no podemos asignarles un valor de distinto tipo: 1 2 3 4 5 6 7 var x = 5 x = 4 // correcto x = 6.0 // error // error: cannot assign value of type 'Double' to type 'Int' // x = 5.0 // ^~~ // Int( ) El compilador indica el error e incluso sugiere una posible soluci\u00f3n del mismo. En este caso llamar al constructor Int() pas\u00e1ndole un Double como par\u00e1metro. Lenguaje multi-paradigma Swift permite combinar caracter\u00edsticas funcionales con caracter\u00edsticas imperativas y de programaci\u00f3n orientada a objetos. Veremos en este tema muchas caracter\u00edsticas funcionales que podremos utilizar en cualquier programa Swift que desarrollemos. Por ejemplo, cuando declaramos una variable podemos declararla como mutable, usando la declaraci\u00f3n var , o como inmutable, usando la declaraci\u00f3n let . Si queremos utilizar un enfoque funcional preferiremos siempre declarar las variables con let . 1 2 3 4 var x = 10 x = 20 // x es mutable let y = 10 y = 20 // error: y es inmutable Una ventaja de la inmutabilidad es que permite que el compilador de Swift optimice el c\u00f3digo de forma muy eficiente. De hecho, el propio compilador nos indica que es preferible definir una variable como let si no la vamos a modificar: 1 2 3 4 5 6 7 8 func saluda ( nombre : String ) -> String { var saludo = \"Hola \" + nombre + \"!\" return saludo } //warning: variable 'saludo' was never mutated; consider changing to 'let' constant // var saludo = \"Hola \" + nombre // ~~~ ^ // let Inmutabilidad \u00b6 Una de las caracter\u00edsticas funcionales importantes de Swift es el \u00e9nfasis en la inmutabilidad para reforzar la seguridad del lenguaje. Hemos visto que la palabra clave let permite definir constantes y que Swift recomienda su uso si el valor que definimos es un valor que no va a ser modificado. El valor asignado a una constante let puede no conocerse en tiempo de compilaci\u00f3n, sino que puede ser obtenido en tiempo de ejecuci\u00f3n como un valor devuelto por una funci\u00f3n: 1 let respuesta : String = respuestaUsuario . respuesta () Al declarar una variable como let se bloquea su contenido y no se permite su modificaci\u00f3n. Una de las ventajas del paradigma funcional y de la inmutabilidad es que garantiza que el c\u00f3digo que escribimos no tiene efectos laterales y puede ser ejecutado sin problemas en entornos multi-procesador o multi-hilo. Creaci\u00f3n de nuevas estructuras y mutaci\u00f3n \u00b6 En la biblioteca est\u00e1ndar de Swift existen una gran cantidad de estructuras (como Int , Double , Bool , String , Array , Dictionary , etc.) que tienen dos tipos de m\u00e9todos: m\u00e9todos que mutan la estructura y m\u00e9todos que devuelven una nueva estructura. Cuando estemos escribiendo c\u00f3digo con estilo funcional deberemos utilizar siempre estos \u00faltimos m\u00e9todos, los que construyen estructuras nuevas. Por ejemplo, en el struct Array se define el m\u00e9todo sort y el m\u00e9todo sorted . El primero ordena el array con mutaci\u00f3n y el segundo devuelve una copia ordenada, sin modificar el array original. En el siguiente c\u00f3digo no se modifica el array original, sino que se construye un array nuevo ordenado: 1 2 3 4 5 6 7 8 9 10 // C\u00f3digo recomendable en programaci\u00f3n funcional // porque utiliza el m\u00e9todo sorted que devuelve una // copia del array original let miArray = [ 10 , - 1 , 3 , 80 ] let arrayOrdenado = miArray . sorted () print ( miArray ) print ( arrayOrdenado ) // Imprime: // [10, -1, 3, 80] // [-1, 3, 10, 80] Este c\u00f3digo es el recomendable cuando estemos escribiendo c\u00f3digo con un estilo de programaci\u00f3n funcional. Sin embargo, el siguiente c\u00f3digo es imperativo y utiliza la mutaci\u00f3n del array original: 1 2 3 4 5 6 7 // C\u00f3digo no recomendable en programaci\u00f3n funcional // porque utiliza el m\u00e9todo sort que muta el array original var miArray = [ 10 , - 1 , 3 , 80 ] miArray . sort () print ( miArray ) // Imprime: // [-1, 3, 10, 80] Otro ejemplo es en la forma de a\u00f1adir elementos a un array. Podemos hacerlo con un enfoque funcional, usando el operador + que construye un array nuevo: 1 2 3 4 5 6 // C\u00f3digo recomendable en programaci\u00f3n funcional let miArray = [ 10 , - 1 , 3 , 80 ] let array2 = miArray + [ 100 ] print ( array2 ) // Imprime: // [10, -1, 3, 80, 100] Y podemos hacerlo usando un enfoque imperativo, con el m\u00e9todo append : 1 2 3 4 5 6 // C\u00f3digo no recomendable en programaci\u00f3n funcional var miArray = [ 10 , - 1 , 3 , 80 ] miArray . append ( 100 ) print ( miArray ) // Imprime: // [10, -1, 3, 80, 100] Importante En programaci\u00f3n funcional debemos usar siempre los m\u00e9todos que no modifican las estructuras . As\u00ed evitaremos los efectos laterales y nuestro c\u00f3digo funcionar\u00e1 correctamente en entornos multi-hilo. Cuando definimos una variable de tipo let el valor que se asigne a esa variable se convierte en inmutable. Si se trata de una estructura o una clase con m\u00e9todos mutables el compilador dar\u00e1 un error. Por ejemplo: 1 2 3 let miArray = [ 10 , - 1 , 3 , 80 ] miArray . append ( 100 ) // error: cannot use mutating member on immutable value: 'miArray' is a 'let' constant Otro ejemplo. El m\u00e9todo append(_:) de un String es un m\u00e9todo mutable. Si definimos una cadena con let no podremos modificarla y dar\u00eda error el siguiente c\u00f3digo: 1 2 3 4 5 var cadenaMutable = \"Hola\" let cadenaInmutable = \"Adios\" cadenaMutable . append ( cadenaInmutable ) // cadenaMutable es \"HolaAdios\" cadenaInmutable . append ( \"Adios\" ) // error: cannot use mutating member on immutable value: 'cadenaInmutable' is a 'let' constant Funciones \u00b6 Definici\u00f3n de una funci\u00f3n en Swift \u00b6 Para definir una funci\u00f3n en Swift se debe usar la palabra func , definir el nombre de la funci\u00f3n, sus par\u00e1metros y el tipo de vuelto. El valor devuelto por la funci\u00f3n se debe devolver usando la palabra return . C\u00f3digo de la funci\u00f3n saluda(nombre:) : 1 2 3 4 func saluda ( nombre : String ) -> String { let saludo = \"Hola, \" + nombre + \"!\" return saludo } Para invocar a la funci\u00f3n saluda(nombre:) : 1 2 3 4 print ( saluda ( nombre : \"Ana\" )) print ( saluda ( nombre : \"Pedro\" )) // Imprime \"Hola, Ana!\" // Imprime \"Hola, Pedro!\" Etiquetas de argumentos y nombres de par\u00e1metros \u00b6 Cada par\u00e1metro de una funci\u00f3n tiene una etiqueta del argumento y un nombre de par\u00e1metro. La etiqueta del argumento se usa cuando se llama a la funci\u00f3n y el nombre del par\u00e1metro se usa internamente en su implementaci\u00f3n. Por defecto, los par\u00e1metros usan su nombre de par\u00e1metro como etiqueta del argumento: 1 2 3 4 5 6 func unaFuncion ( primerNombreParametro : Int , segundoNombreParametro : Int ) { // En el cuerpo de la funci\u00f3n, primerNombreParametro y // segundoNombreParametro se refieren a los valores de los // argumentos del primer y el segundo par\u00e1metro } unaFuncion ( primerNombreParametro : 1 , segundoNombreParametro : 2 ) Es posible hacer distintos la etiqueta del argumento del nombre del par\u00e1metro: 1 2 3 4 5 func saluda ( nombre : String , de ciudad : String ) -> String { return \"Hola \\( nombre ) ! Me alegro de que hayas podido visitarnos desde \\( ciudad ) .\" } print ( saluda ( nombre : \"Bill\" , de : \"Cupertino\" )) // Imprime \"Hola Bill! Me alegro de que hayas podido visitarnos desde Cupertino.\" Otro ejemplo, la siguiente funci\u00f3n concatena(palabra:con:) : 1 2 3 4 5 func concatena ( palabra str1 : String , con str2 : String ) -> String { return str1 + str2 } print ( concatena ( palabra : \"Hola\" , con : \"adios\" )) Si no se quiere una etiqueta del argumento para un par\u00e1metro, se puede escribir un subrayado ( _ ) en lugar de una etiqueta del argumento expl\u00edcita para ese par\u00e1metro: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 func max ( _ x : Int , _ y : Int ) -> Int { if x > y { return x } else { return y } } print ( max ( 10 , 3 )) func divide ( _ x : Double , entre y : Double ) -> Double { return x / y } print ( divide ( 30 , entre : 4 )) El perfil de la funci\u00f3n est\u00e1 formado por el nombre de la funci\u00f3n, las etiquetas de los argumentos y el tipo devuelto por la funci\u00f3n. En la documentaci\u00f3n de las funciones usaremos las etiquetas separadas por dos puntos. Por ejemplo, las funciones anteriores son max(_:_:) y divide(_:entre:) . Las etiquetas de los argumentos son parte del nombre de la funci\u00f3n. Es posible definir funciones distintas con s\u00f3lo distintos nombres de argumentos, como las siguientes funciones mitad(par:) y mitad(impar:) : 1 2 3 4 5 6 7 8 9 10 11 12 func mitad ( par : Int ) -> Int { return par / 2 } func mitad ( impar : Int ) -> Int { return ( impar + 1 ) / 2 } print ( mitad ( par : 8 )) // Imprime 4 print ( mitad ( impar : 9 )) // Imprime 5 Par\u00e1metros y valores devueltos \u00b6 Es posible definir funciones sin par\u00e1metros: 1 2 3 4 5 func diHolaMundo () -> String { return \"hola, mundo\" } print ( diHolaMundo ()) // Imprime \"hola, mundo\" Podemos definir funciones sin valor devuelto. Por ejemplo, la siguiente funci\u00f3n diAdios(nombre:) . No hay que escribir flecha con el tipo devuelto. Cuidado, no ser\u00eda propiamente programaci\u00f3n funcional. 1 2 3 4 5 func diAdios ( nombre : String ) { print ( \"Adi\u00f3s, \\( nombre ) !\" ) } diAdios ( nombre : \"Dave\" ) // Imprime \"Adi\u00f3s, Dave!\" Es posible devolver m\u00faltiples valores, construyendo una tupla. Por ejemplo, la siguiente funci\u00f3n ecuacion(a:b:c:) calcula las dos soluciones de una ecuaci\u00f3n de segundo grado: 1 2 3 4 5 6 func ecuacion ( a : Double , b : Double , c : Double ) -> ( pos : Double , neg : Double ) { let discriminante = b * b - 4 * a * c let raizPositiva = ( - b + discriminante . squareRoot ()) / 2 * a let raizNegativa = ( - b - discriminante . squareRoot ()) / 2 * a return ( raizPositiva , raizNegativa ) } Recordemos (consultar el seminario de Swift) que podemos acceder a los valores de la tupla por posici\u00f3n: 1 2 3 let resultado = ecuacion ( a : 1 , b : - 5 , c : 6 ) print ( \"Las ra\u00edces de la ecuaci\u00f3n son \\( resultado . 0 ) y \\( resultado . 1 ) \" ) //Imprime \"Las ra\u00edces de la ecuaci\u00f3n son 3.0 y 2.0\" En este caso en la definici\u00f3n del tipo devuelto por la funci\u00f3n estamos etiquetando esos valores con las etiquetas pos y neg . De esta forma podemos acceder a los componentes de la tupla usando esas etiquetas definidas: 1 2 3 let resultado = ecuacion ( a : 1 , b : - 5 , c : 6 ) print ( \"Las ra\u00edces de la ecuaci\u00f3n son \\( resultado . pos ) y \\( resultado . neg ) \" ) //Imprime \"Las ra\u00edces de la ecuaci\u00f3n son 3.0 y 2.0\" Recursi\u00f3n \u00b6 Veamos algunos ejemplos de funciones recursivas en Swift. Primero una funci\u00f3n suma(hasta:) que devuelve la suma desde 0 hasta el n\u00famero que le pasamos como par\u00e1metro. 1 2 3 4 5 6 7 8 9 10 func suma ( hasta x : Int ) -> Int { if x == 0 { return 0 } else { return x + suma ( hasta : x - 1 ) } } print ( suma ( hasta : 5 )) // Imprime \"15\" Tambi\u00e9n es posible definir recursiones que recorran arrays de una forma similar a c\u00f3mo trabaj\u00e1bamos en Scheme. Los arrays en Swift no funcionan exactamente como las listas de Scheme (no son listas de parejas), pero podemos obtener el primer elemento y el resto de la siguiente forma. 1 2 3 let a = [ 10 , 20 , 30 , 40 , 50 , 60 ] let primero = a [ 0 ] let resto = Array ( a . dropFirst ()) En primero se guarda el n\u00famero 10. En resto se guarda el Array del 20 al 60. El m\u00e9todo dropFirst devuelve una ArraySlice , que es una vista de un rango de elementos del array, en este caso el que va desde la posici\u00f3n 1 hasta la 5 (la posici\u00f3n inicial de un array es la 0). Es necesario el constructor Array para convertir ese ArraySlice en un Array . Usando las instrucciones anteriores podemos definir la funci\u00f3n recursiva que suma los valores de un Array de la siguiente forma similar a c\u00f3mo lo hac\u00edamos en Scheme: 1 2 3 4 5 6 7 8 9 10 11 12 func sumaValores ( _ valores : [ Int ]) -> Int { if ( valores . isEmpty ) { return 0 } else { let primero = valores [ 0 ] let resto = Array ( valores . dropFirst ()) return primero + sumaValores ( resto ) } } print ( sumaValores ([ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 ])) // Imprime \"36\" Un \u00faltimo ejemplo es la siguiente funci\u00f3n minMax(array:) que devuelve el n\u00famero m\u00e1s peque\u00f1o y m\u00e1s grande de un array de enteros: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 func minMax ( array : [ Int ]) -> ( min : Int , max : Int ) { if ( array . count == 1 ) { return ( array [ 0 ], array [ 0 ]) } else { let primero = array [ 0 ] let resto = Array ( array . dropFirst ()) // Llamada recursiva que devuelve el m\u00ednimo y el m\u00e1ximo del // resto del array let minMaxResto = minMax ( array : resto ) let minimo = min ( primero , minMaxResto . min ) let maximo = max ( primero , minMaxResto . max ) return ( minimo , maximo ) } } let limites = minMax ( array : [ 8 , - 6 , 2 , 100 , 3 , 71 ]) print ( \"El m\u00ednimo es \\( limites . min ) y el m\u00e1ximo es \\( limites . max ) \" ) // Imprime \"El m\u00edmimo es -6 y el m\u00e1ximo es 100\" En este ejemplo nos apartamos un poco de la soluci\u00f3n vista en Scheme porque permitimos pasos de ejecuci\u00f3n que inicializan variables. Pero no nos salimos del paradigma funcional, porque todas son variables inmutables definidas con let . Tipos funci\u00f3n \u00b6 En Swift las funciones son objetos de primera clase y podemos asignarlas a variables, pasarlas como par\u00e1metro o devolverlas como resultado de otra funci\u00f3n. Al ser un lenguaje fuertemente tipado, las variables, par\u00e1metros o resultados deben ser objetos de tipo funci\u00f3n. Cada funci\u00f3n tiene un tipo espec\u00edfico, definido por el tipo de sus par\u00e1metros y el tipo del valor devuelto. 1 2 3 4 5 6 func sumaDosInts ( a : Int , b : Int ) -> Int { return a + b } func multiplicaDosInts ( a : Int , b : Int ) -> Int { return a * b } El tipo de estas funciones es (Int, Int) -> Int , que se puede leer como: \"Un tipo funci\u00f3n que tiene dos par\u00e1metros, ambos de tipo Int y que devuelve un valor de tipo Int \". En Swift se puede usar un tipo funci\u00f3n de la misma forma que cualquier otro tipo, por ejemplo asignando la funci\u00f3n a una variable: 1 2 3 4 5 6 var f = sumaDosInts print ( f ( 2 , 3 )) // Imprime \"5\" f = multiplicaDosInts print ( f ( 2 , 3 )) // Imprime \"6\" La variable f es una variable de tipo (Int, Int) -> Int , o sea, una variable que contiene funciones de dos argumentos Int que devuelven un Int . Nota Habr\u00e1s notado que al invocar a f no se ponen etiquetas en los argumentos. De hecho, si las pusi\u00e9ramos el compilador de Swift se quejar\u00eda: 1 2 print ( f ( a : 2 , b : 3 )) //error: extraneous argument labels 'a:b:' in call Esto es debido a que al ser f una variable se le puede asignar cualquier funci\u00f3n que tenga el perfil (Int, Int) -> Int sin tener en cuenta las etiquetas de los argumentos. Funciones que reciben otras funciones \u00b6 Podemos usar un tipo funci\u00f3n en par\u00e1metros de otras funciones: 1 2 3 4 5 func printResultado ( funcion : ( Int , Int ) -> Int , _ a : Int , _ b : Int ) { print ( \"Resultado: \\( funcionMatematica ( a , b )) \" ) } printResultado ( funcion : sumaDosInts , 3 , 5 ) // Prints \"Resultado: 8\" La funci\u00f3n printResultado(funcion:_:_:) toma como primer par\u00e1metro otra funci\u00f3n que recibe dos Int y devuelve un Int , y como segundo y tercer par\u00e1metro dos Int . Veamos otro ejemplo, que ya vimos en Scheme. Supongamos que queremos calcular el sumatorio desde a hasta b en el que aplicamos una funci\u00f3n f a cada n\u00famero que sumamos: 1 sumatorio(a, b, f) = f(a) + f(a+1) + f(a+2) + ... + f(b) Recordamos que se resuelve con la siguiente recursi\u00f3n: 1 2 sumatorio(a, b, f) = f(a) + sumatorio(a+1, b, f) sumatorio(a, b, f) = 0 si a > b Veamos c\u00f3mo se implementa en Swift: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 func sumatorio ( desde a : Int , hasta b : Int , func f : ( Int ) -> Int ) -> Int { if a > b { return 0 } else { return f ( a ) + sumatorio ( desde : a + 1 , hasta : b , func : f ) } } func identidad ( _ x : Int ) -> Int { return x } func doble ( _ x : Int ) -> Int { return x + x } func cuadrado ( _ x : Int ) -> Int { return x * x } print ( sumatorio ( desde : 0 , hasta : 10 , func : identidad )) // Imprime 55 print ( sumatorio ( desde : 0 , hasta : 10 , func : doble )) // Imprime 110 print ( sumatorio ( desde : 0 , hasta : 10 , func : cuadrado )) // Imprime 385 Funciones en estructuras \u00b6 Como cualquier otro tipo Las funciones pueden tambi\u00e9n incluirse en estructuras de datos compuestas, como arrays: 1 2 3 4 var funciones = [ identidad , doble , cuadrado ] print ( funciones [ 0 ]( 10 )) // 10 print ( funciones [ 1 ]( 10 )) // 20 print ( funciones [ 2 ]( 10 )) // 100 El tipo de la variable funciones ser\u00eda [(Int) -> Int] . Al ser Swift fuertemente tipeado, no podr\u00edamos hacer un array con distintos tipos de funciones. Por ejemplo el siguiente c\u00f3digo dar\u00eda un error: 1 2 3 4 5 6 7 func suma ( _ x : Int , _ y : Int ) -> Int { return x + y } // La siguiente l\u00ednea genera un error var misFunciones = [ doble , cuadrado , suma ] // error: heterogenous collection literal could only be inferred to // '[Any]'; add explicit type annotation if this is intentional Funciones que devuelven otras funciones \u00b6 Por \u00faltimo, veamos un ejemplo de funciones que devuelven otras funciones. Es un ejemplo sencillo, una funci\u00f3n que devuelve otra que suma 10: 1 2 3 4 5 6 7 8 func construyeSumador10 () -> ( Int ) -> Int { func suma10 ( x : Int ) -> Int { return x + 10 } return suma10 } var f = construyeSumador10 () print ( f ( 20 )) // Imprime 30 La funci\u00f3n devuelta por construyeSumador10() es una funci\u00f3n con el tipo (Int) -> Int (recibe un par\u00e1metro entero y devuelve un entero). En la llamada a construyeSumador10() se crea esa funci\u00f3n y se asigna a la variable f . Estas funciones devueltas se denominan clausuras . M\u00e1s adelante hablaremos algo m\u00e1s de ellas. Veremos tambi\u00e9n m\u00e1s adelante que es posible usar expresiones de clausura que construyen clausuras an\u00f3nimas. Podemos modificar el ejemplo anterior, haciendo que la funci\u00f3n construyeSumador reciba el n\u00famero a sumar como par\u00e1metro: 1 2 3 4 5 6 7 8 9 10 11 func construyeSumador ( inc : Int ) -> ( Int ) -> Int { func suma ( x : Int ) -> Int { return x + inc } return suma } var f = construyeSumador ( inc : 10 ) var g = construyeSumador ( inc : 100 ) print ( f ( 20 )) // Imprime \"30\" print ( g ( 20 )) // Imprime \"120\" Invocamos dos veces a construyeSumador(inc:) y guardamos las clausuras construidas en las variables f y g . En f se guarda una funci\u00f3n que suma 10 a su argumento y en g otra que suma 100 . Tipos \u00b6 Entre las ventajas del uso de tipos est\u00e1 la detecci\u00f3n de errores en los programas en tiempo de compilaci\u00f3n o las ayudas del entorno de desarrollo para autocompletar c\u00f3digo. Entre los inconvenientes se encuentra la necesidad de ser m\u00e1s estrictos a la hora de definir los par\u00e1metros y los valores devueltos por las funciones, lo que impide la flexibilidad de Scheme. Se utilizan tipos para definir los posibles valores de: variables par\u00e1metros de funciones valores devueltos por funciones Tal y como hemos visto cuando hemos comentado que Swift es fuertemente tipado las definiciones de tipos van precedidas de dos puntos en las variables y par\u00e1metros, o de una flecha ( -> ) en la definici\u00f3n de los tipos de los valores devueltos por una funci\u00f3n: 1 2 3 4 5 6 let valorDouble : Double = 3.0 let unaCadena : String = \"Hola\" func calculaEstadisticas ( valores : Array < Int >) -> ( min : Int , max : Int , media : Int ) { ... } En Swift existen dos clases de tipos: tipos con nombre y tipos compuestos. Tipos con nombre \u00b6 Un tipo con nombre es un tipo al que podemos dar un nombre determinado cuando se define. Por ejemplo, al definir un nombre de una clase o de un enumerado estamos tambi\u00e9n definiendo un nombre de un tipo. En Swift es posible definir los siguientes tipos con nombre: nombres de clases nombres de estructuras nombres de enumeraciones nombres de protocolos Por ejemplo, instancias de una clase definida por el usuario llamada MiClase tienen el tipo MiClase . Adem\u00e1s de los tipos definidos por el usuario, la biblioteca est\u00e1ndar de Swift tiene un gran n\u00famero de tipos predefinidos. A diferencia de otros lenguajes, estos tipos no son parte del propio lenguaje sino que se definen en su mayor\u00eda como estructuras implementadas en esta biblioteca est\u00e1ndar. Por ejemplo, arrays, diccionarios o incluso los tipos m\u00e1s b\u00e1sicos como String o Int est\u00e1n construidos en esa biblioteca. La implementaci\u00f3n de estos elementos est\u00e1 disponible en abierto en el sitio GitHub de Swift . Tipos compuestos \u00b6 Los tipos compuestos son tipos sin nombre. En Swift se definen dos: tuplas y tipos funci\u00f3n. Un tipo compuesto puede tener tipos con nombre y otros tipos compuestos. Por ejemplo la tupla (Int, (Int, Int)) contiene dos elementos: el primero es el tipo con nombre Int y el segundo el tipo compuesto que define la tupla (Int, Int) . Los tipos funci\u00f3n los hemos visto previamente. 1 2 3 4 5 6 7 8 9 10 11 let tupla : ( Int , Int , String ) = ( 2 , 3 , \"Hola\" ) let otraTupla : ( Int , Int , String ) = ( 5 , 8 , \"Adios\" ) func sumaTupla ( tupla t1 : ( Int , Int ), con t2 : ( Int , Int )) -> ( Int , Int ) { return ( t1 . 0 + t2 . 0 , t1 . 1 + t2 . 1 ) } print ( sumaTupla ( tupla : ( tupla . 0 , tupla . 1 ), con : ( otraTupla . 0 , otraTupla . 1 ))) // Imprime (7, 11) Typealias En Swift se define la palabra clave typealias para darle un nombre asignado a cualquier otro tipo. Ambos tipos son iguales a todos los efectos (es \u00fanicamente az\u00facar sint\u00e1ctico). Por ejemplo, en el siguiente c\u00f3digo definimos un typealias llamado Resultado que corresponde a una tupla con dos Int correspondientes al resultado de un partido de futbol. Una vez definido, podemos usarlo como un tipo. La funci\u00f3n quiniela(partido:) devuelve un String correspondiente al resultado de la quiniela de un partido: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 typealias Resultado = ( Int , Int ) func quiniela ( partido : Resultado ) -> String { switch partido { case let ( goles1 , goles2 ) where goles1 < goles2 : return \"Dos\" case let ( goles1 , goles2 ) where goles1 > goles2 : return \"Uno\" default : return \"Equis\" } } print ( quiniela ( partido : ( 1 , 3 ))) // Imprime \"Dos\" print ( quiniela ( partido : ( 2 , 2 ))) // Imprime \"Equis\" Tipos valor y tipos referencia \u00b6 En Swift existen dos tipos de construcciones que forman la base de la programaci\u00f3n orientada a objetos: las estructuras ( structs ) y las clases. En el tema siguiente hablaremos sobre ello. En la biblioteca est\u00e1ndar de Swift la mayor parte de los tipos definidos (como Int , Double , Bool , String , Array , Dictionary , etc.) son estructuras, no clases. Una de las diferencias m\u00e1s importantes entre estructuras y clases es su comportamiento en una asignaci\u00f3n: las estructuras tienen una sem\u00e1ntica de copia (son tipos valor) y las clases tienen una sem\u00e1ntica de referencia (son tipos referencia). Un tipo valor es un tipo que tiene sem\u00e1ntica de copia en las asignaciones y cuando se pasan como par\u00e1metro en llamadas a funciones. Los tipos valor son muy \u00fatiles porque evitan los efectos laterales en los programas y simplifican el comportamiento del compilador en la gesti\u00f3n de memoria. Al no existir referencias, se simplifica enormemente la gesti\u00f3n de memoria de estas estructuras. No es necesario llevar la cuenta de qu\u00e9 referencias apuntan a un determinado valor, sino que se puede liberar la memoria en cuanto se elimina el \u00e1mbito actual. Frente a un tipo valor, un tipo de referencia es aquel en los que los valores se asignan a variables con una sem\u00e1ntica de referencia. Cuando se realizan varias asignaciones de una misma instancia a distintas variables todas ellas guardan una referencia a la misma instancia. Si la instancia se modifica, todas las variables reflejar\u00e1n el nuevo valor. Cuando veamos las clases en el pr\u00f3ximo tema veremos algunos ejemplos. Veamos ahora algunos ejemplos de copia por valor en estructuras. Por ejemplo, si asignamos una cadena a otra, se realiza una copia: 1 2 3 4 5 var str1 = \"Hola\" var str2 = str1 str1 . append ( \"Adios\" ) print ( str1 ) // Imprime \"HolaAdios\" print ( str2 ) // Imprime \"Hola\" Los arrays tambi\u00e9n son estructuras y, por tanto, tambi\u00e9n tienen sem\u00e1ntica de copia: 1 2 3 4 5 var array1 = [ 1 , 2 , 3 , 4 ] var array2 = array1 array1 [ 0 ] = 10 print ( array1 ) // [10, 2, 3, 4] print ( array2 ) // [1, 2, 3, 4] A diferencia de otros lenguajes como Java, los par\u00e1metros de una funci\u00f3n siempre son inmutables y se pasan por copia, para reforzar el car\u00e1cter funcional de las funciones. Por ejemplo, es incorrecto escribir lo siguiente: 1 2 3 4 func ponCero ( array : [ Int ] , pos : Int ) { array [ pos ] = 0 // error : cannot assign through subscript : 'array' is a 'let' constant } Se podr\u00eda pensar que es muy costoso copiar un array entero. Por ejemplo, si asignamos o pasamos como par\u00e1metro un array de 1000 elementos. Pero no es as\u00ed. El compilador de Swift optimiza estas sentencias y s\u00f3lo realiza la copia en el momento en que hay una modificaci\u00f3n de una de las variables que comparten el array. Es lo que se llama copy on write . Enumeraciones \u00b6 Las enumeraciones definen un tipo con un valor restringido de posibles valores: 1 2 3 4 5 6 enum Direccion { case norte case sur case este case oeste } Cualquier variable del tipo Direccion solo puede tener uno de los cuatro valores definidos. Se obtiene el valor escribiendo el nombre de la enumeraci\u00f3n, un punto y el valor definido. Si el tipo de enumeraci\u00f3n se puede inferir no es necesario escribirlo. 1 2 3 4 5 let hemosGirado = true var direccionActual = Direccion . norte if hemosGirado { direccionActual = . sur } En sentencias switch: 1 2 3 4 5 6 7 8 9 10 11 12 let direccionAIr = Direccion . sur switch direccionAIr { case . norte : print ( \"Nos vamos al norte\" ) case . sur : print ( \"Cuidado con los pinguinos\" ) case . este : print ( \"Donde nace el sol\" ) case . oeste : print ( \"Donde el cielo es azul\" ) } // Imprime \"Cuidado con los pinguinos\" Otro ejemplo: 1 2 3 enum Planeta { case mercurio , venus , tierra , marte , jupiter , saturno , urano , neptuno } Y, por \u00faltimo, es m\u00e1s correcto definir el resultado de una quiniela con un enumerado en lugar de con un String : 1 2 3 enum Quiniela { case uno , equis , dos } Valores brutos de enumeraciones Es posible asignar a las constantes del enumerado un valor concreto de un tipo subyacente, por ejemplo enteros: 1 2 3 enum Quiniela : Int { case uno = 1 , equis = 0 , dos = 2 } Se puede obtener el valor bruto a partir del propio tipo o de una variable del tipo, usando rawValue : 1 2 3 4 5 6 // Obtenemos el valor bruto a partir del tipo let valorEquis : Int = Quiniela . equis . rawValue // Obtenemos el valor bruto a partir de una variable let res = Quiniela . equis let valorEquis = res . rawValue Tambi\u00e9n se puede asignar los valores de forma impl\u00edcita, dando un valor a la primera constante. Las siguientes tienen el valor consecutivo: 1 2 3 4 5 enum Planeta : Int { case mercurio = 1 , venus , tierra , marte , jupiter , saturno , urano , neptuno } let posicionTierra = Planeta . tierra . rawValue // posicionTierra es 3 Podemos escoger cualquier tipo subyacente. Por ejemplo el tipo Character : 1 2 3 4 5 enum CaracterControlASCII : Character { case tab = \" \\t \" case lineFeed = \" \\n \" case carriageReturn = \" \\r \" } El car\u00e1cter nueva l\u00ednea ( lineFeed ) se puede obtener de la siguiente forma: 1 let nuevaLinea = CaracterControlASCII.LineFeed.rawValue Y por \u00faltimo, se puede definir como tipo subyacente String y los valores brutos de las constantes ser\u00e1n sus nombres convertidos a cadenas: 1 2 3 4 5 enum Direccion : String { case norte , sur , este , oeste } let direccionAtardecer = Direccion . oeste . rawValue // direccionAtardecer es \"oeste\" Cuando se definen valores brutos es posible inicializar el enumerado de una forma similar a una estructura o una clase pasando el valor bruto. Devuelve el valor enumerado correspondiente o nil (un opcional): 1 2 let posiblePlaneta = Planeta ( rawValue : 7 ) // posiblePlaneta es de tipo Planeta? y es igual a Planeta.urano Valores asociados a instancias de enumeraciones Una caracter\u00edstica singular de las enumeraciones en Swift es que permiten definir valores variables asociados a cada caso. Veamos un ejemplo inicial muy sencillo, con una enumeraci\u00f3n con un \u00fanico caso, en el que se define una variable de tipo Int : 1 2 3 enum Prueba { case x ( Int ) } Esta notaci\u00f3n obliga a definir un valor concreto del Int asociado a x en el momento de creaci\u00f3n del enumerado: 1 2 let valor1 = Prueba . x ( 10 ) let valor2 = Prueba . x ( 40 ) Las variables valor1 y valor2 son de tipo Prueba y tiene como valor la constante x , y el entero asociado 10 y 40 en cada caso. Son parecidas a instancias de una clase. Para obtener el valor asociado debemos usar un case let en una sentencia switch con una variable a la que se asigna el valor. Por ejemplo, en el siguiente c\u00f3digo el valor del enumerado se asigna a la variable a : 1 2 3 4 5 switch valor1 { case let . x ( a ): print ( \"Valor asociado a x: \\( a ) \" ) } // Imprime \"Valor asociado a x: 10 Los valores asociados y los valores brutos son distintos: el valor bruto de un caso de enumeraci\u00f3n es el mismo para todas las instancias, mientras que el valor asociado es distinto y se proporciona cuando se define el valor concreto de la enumeraci\u00f3n. Cuando unimos a la caracter\u00edstica del valor asociado la posibilidad de los enumerados de tener m\u00e1s de una opci\u00f3n tenemos lo que en otros lenguajes de programaci\u00f3n se llaman uniones etiquetadas o variantes . Veamos un ejemplo, m\u00e1s real, en el que usamos un enum para definir posibles valores de un c\u00f3digo de barras, en el que incluimos dos posibles tipos de c\u00f3digo de barras: el c\u00f3digo de barras lineal (denominado UPC) y el c\u00f3digo QR: 1 2 3 4 enum CodigoBarras { case upc ( Int , Int , Int , Int ) case qrCode ( String ) } Se lee de la siguiente forma: \u201cDefinimos un tipo enumerado llamado CodigoBarras , que puede tomar como valor un upc (c\u00f3digo de barras lineal) con un valor asociado de tipo (Int, Int, Int, Int) (una tupla de 4 enteros que representan los 4 n\u00fameros que hay en los c\u00f3digos de barras lineales) o un valor qrCode con valor asociado de tipo String \". Veamos un ejemplo de uso, en el que creamos un c\u00f3digo de barras de producto de tipo UPC, despu\u00e9s lo modificamos a otro de tipo c\u00f3digo QR y por \u00faltimo lo imprimimos: 1 2 3 4 5 6 7 8 9 10 var codigoBarrasProducto = CodigoBarras . upc ( 8 , 85909 , 51226 , 3 ) codigoBarrasProducto = . qrCode ( \"ABCDEFGHIJKLMNOP\" ) switch codigoBarrasProducto { case let . upc ( sistemaNumeracion , fabricante , producto , control ): print ( \"UPC: \\( sistemaNumeracion ) , \\( fabricante ) , \\( producto ) , \\( control ) .\" ) case let . qrCode ( codigoProducto ): print ( \"C\u00f3digo QR: \\( codigoProducto ) .\" ) } // Imprime \"C\u00f3digo QR : ABCDEFGHIJKLMNOP.\" Enumeraciones recursivas Es posible combinar las caracter\u00edsticas de las enumeraciones con valor con la recursi\u00f3n para crear enumeraciones recursivas. Hay que preceder la palabra clave enum con indirect : 1 2 3 4 5 6 7 8 9 10 indirect enum ExpresionAritmetica { case numero ( Int ) case suma ( ExpresionAritmetica , ExpresionAritmetica ) case multiplicacion ( ExpresionAritmetica , ExpresionAritmetica ) } let cinco = ExpresionAritmetica . numero ( 5 ) let cuatro = ExpresionAritmetica . numero ( 4 ) let suma = ExpresionAritmetica . suma ( cinco , cuatro ) let producto = ExpresionAritmetica . multiplicacion ( suma , ExpresionAritmetica . numero ( 2 )) Es muy c\u00f3modo manejar enumeraciones recursivas de forma recursiva: 1 2 3 4 5 6 7 8 9 10 11 12 13 func evalua ( expresion : ExpresionAritmetica ) -> Int { switch expresion { case let . numero ( valor ): return valor case let . suma ( izquierda , derecha ): return evalua ( expresion : izquierda ) + evalua ( expresion : derecha ) case let . multiplicacion ( izquierda , derecha ): return evalua ( expresion : izquierda ) * evalua ( expresion : derecha ) } } print ( evalua ( expresion : producto )) // Imprime 18 Otro ejemplo de enums recursivos, para definir un tipo de datos Lista similar al que vimos en Scheme. La lista puede ser una lista vac\u00eda o puede contener dos elementos: un valor Int y otra lista: 1 2 3 4 indirect enum Lista { case vacia case nodo ( Int , Lista ) } Para crear una lista de tipo nodo deberemos dar un valor entero (el valor de la cabeza de la lista) y otra lista (el resto de la lista). Tambi\u00e9n podemos crear una lista vac\u00eda. Por ejemplo, podemos crear la lista (10, 20, 30) de la siguiente manera: 1 2 3 let lista1 = Lista . nodo ( 30 , Lista . vacia ) let lista2 = Lista . nodo ( 20 , lista1 ) let lista3 = Lista . nodo ( 10 , lista2 ) Podr\u00edamos crear esta misma lista de una forma m\u00e1s abreviada: 1 let lista : Lista = . nodo ( 10 , . nodo ( 20 , . nodo ( 30 , . vacia ))) Una vez definido el tipo enumerado, podemos definir funciones que trabajen con \u00e9l. La siguiente funci\u00f3n, por ejemplo, es una funci\u00f3n recursiva que recibe una lista y devuelve la suma de sus elementos. Funciona de una forma muy similar a la definici\u00f3n que hicimos en Scheme: 1 2 3 4 5 6 7 8 9 10 11 12 13 func suma ( lista : Lista ) -> Int { switch lista { case . vacia : return 0 case let . nodo ( car , cdr ): return car + suma ( lista : cdr ) } } let z : Lista = . nodo ( 20 , . nodo ( 10 , . vacia )) print ( suma ( lista : z )) // Imprime 30 Podemos tambi\u00e9n definir una funci\u00f3n recursiva construye(lista:[Int]) que devuelve una lista a partir de una array de enteros: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 func construye ( lista : [ Int ]) -> Lista { if ( lista . isEmpty ) { return Lista . vacia } else { let primero = lista [ 0 ] let resto = Array ( lista . dropFirst ()) return Lista . nodo ( primero , construye ( lista : resto )) } } let lista = construye ( lista : [ 1 , 2 , 3 , 4 , 5 ]) print ( suma ( lista : lista )) // Imprime 15 Opcionales \u00b6 Una de las caracter\u00edsticas principales que Swift intenta promover es la seguridad y la robustez. Debe ser dif\u00edcil que el desarrollador escriba c\u00f3digo con errores y que rompa la aplicaci\u00f3n. Por ejemplo, la comprobaci\u00f3n est\u00e1tica de los tipos de datos o el manejo autom\u00e1tico de la gesti\u00f3n de memoria son dos caracter\u00edsticas del lenguaje que van en esta direcci\u00f3n. Otro de los elementos m\u00e1s importantes del lenguaje para promover la seguridad son los opcionales. Vamos a estudiar su uso y utilidad. En muchos lenguajes existe el concepto de valor vac\u00edo . Por ejemplo, en Java se usa null o en Python None . Nota Tony Hoare introdujo el concepto de Null en ALGOL, en 1965. En una conferencia en 2009 habla sobre esta idea y la considera un costoso error: Null References: The Billion Dollar Mistake . El concepto de null es un concepto peligroso, como lo saben bien los desarrolladores Java. En Java, si intentamos usar una variable que contiene null se produce la t\u00edpica excepci\u00f3n null pointer exception y la aplicaci\u00f3n se rompe. Todos hemos ca\u00eddo en este error, y con m\u00e1s frecuencia de la que ser\u00eda deseable. En Swift tambi\u00e9n existe el valor nulo. La forma de representarlo es el identificador nil . La caracter\u00edstica de seguridad que introduce Swift con respecto a Java y a otros lenguajes es que no es posible asignar nil a una variable de un tipo normal. Por ejemplo, la siguiente l\u00ednea dar\u00eda un error de compilaci\u00f3n: 1 2 let cadena : String = nil // error: 'nil' cannot initialize specified type 'String' Si queremos utilizar nil debemos declarar la variable usando lo que se denomina tipo opcional : 1 2 var cadena : String ? = \"Hola\" cadena = nil El tipo String? indica que podemos tener un valor nil o un valor del tipo original. Primero estamos definiendo la variable cadena del tipo String? ( String opcional) y le estamos asignando un valor determinado (de tipo String ). Y despu\u00e9s le asignamos nil . El uso de opcionales es necesario en situaciones en las que podemos obtener un valor desconocido. Por ejemplo, en alguna funci\u00f3n en la que pedimos un valor al usuario y el usuario puede no introducir ninguno. O en estructuras de datos en las que hacemos b\u00fasquedas que pueden no devolver ning\u00fan valor, como en un diccionario: 1 2 3 4 5 6 var edades = [ \"Raquel\" : 30 , \"Pedro\" : 22 , ] let edad1 = edades [ \"Raquel\" ] let edad2 = edades [ \"Ana\" ] En el c\u00f3digo anterior definimos un diccionario edades con claves de tipo String y valores Int . La variable edad1 se inicializa con un opcional con el valor 30 y la variable edad2 con un opcional que vale nil . Un valor opcional no puede ser usado directamente. Primero debemos comprobar si el valor es distinto de nil y s\u00f3lo despu\u00e9s podremos usarlo. Para reforzar esto, Swift esconde o envuelve ( wrap ) el valor real del opcional y obliga a llamar al operador ! para desenvolverlo ( unwrap ) y usarlo. Este operador se denomina de desenvoltura forzosa ( forced unwrapping ). Por ejemplo, el siguiente c\u00f3digo produce un error de compilaci\u00f3n porque intentamos usar un opcional sin desenvolverlo: 1 2 3 var x : Int ? = 10 let y = x + 10 // error: value of optional type 'Int?' must be unwrapped to a value of type 'Int' Para usar el valor asignado a x debemos desenvolverlo con el operador ! : 1 2 3 4 var x : Int ? = 10 let y = x ! + 10 print ( y ) // Imprime \"20\" Podemos definir como opcional variables, par\u00e1metros o valores devueltos por funciones de cualquier tipo, a\u00f1adi\u00e9ndoles la interrogaci\u00f3n al final. Por ejemplo, la siguiente funci\u00f3n max es una funci\u00f3n que devuelve un Int? , un entero opcional en el caso de que se le pase un array vac\u00edo. Al devolver un opcional, debemos desenvolver el valor devuelto cuando queramos usarlo como Int (por ejemplo, en la llamada recursiva). 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 func max ( array :[ Int ]) -> Int ? { if ( array . isEmpty ) { return nil } else if ( array . count == 1 ) { return array [ 0 ] } else { let primero = array [ 0 ] let resto = Array ( array . dropFirst ()) return max ( primero , max ( array : resto ) ! ) } } let maximo = max ( array :[ 10 , 200 , - 100 , 2 ]) print ( maximo !) // Imprime \"200\" Una variable opcional sin asignar ning\u00fan valor se inicializa autom\u00e1ticamente a nil : 1 2 var respuestaEncuesta : String ? // respuestaEncuesta es inicializado autom\u00e1ticamente a nil Si se aplica el operador ! a un valor nil se produce un error en tiempo de ejecuci\u00f3n y la aplicaci\u00f3n se rompe: 1 2 3 var respuestaEncuesta : String ? print ( respuestaEncuesta !) // Fatal error: Unexpectedly found nil while unwrapping an Optional value Ligado opcional \u00b6 Para comprobar si un valor opcional es nil podemos usar un if . Es obligado hacerlo si desconocemos el valor que nos llega. Por ejemplo, supongamos que la funci\u00f3n leerRespuesta() lee una respuesta del usuario y devuelve un String? . Para usar esta funci\u00f3n deber\u00edamos comprobar si el valor devuelto es distinto de nil : 1 2 3 4 5 let respuestaEncuesta = leerRespuesta () if respuestaEncuesta != nil { let respuesta = respuestaEncuesta ! print ( \"Respuesta: \" + respuesta ) } Como es muy habitual hacer lo anterior, en Swift es posible comprobar si un opcional tiene valor y asignar su valor a otra variable al mismo tiempo con una construcci\u00f3n llamada ligado opcional ( optional binding ): 1 2 3 4 let respuestaEncuesta = leerRespuesta () if let respuesta = respuestaEncuesta { print ( \"Respuesta: \" + respuesta ) } Podemos leer el c\u00f3digo anterior de la siguiente forma: \"Si el opcional respuestaEncuesta contiene un valor, define la constante respuesta con el valor contenido en el opcional\". Otro ejemplo, el m\u00e9todo first de un array devuelve un opcional que contiene nil si el array est\u00e1 vac\u00edo o el primer elemento del array en el caso en que exista. El siguiente c\u00f3digo utiliza un ligado opcional para implementar otra versi\u00f3n de la funci\u00f3n sumaValores : 1 2 3 4 5 6 7 8 9 10 11 func sumaValores ( _ valores : [ Int ]) -> Int { if let primero = valores . first { let resto = Array ( valores . dropFirst ()) return primero + sumaValores ( resto ) } else { return 0 } } print ( sumaValores ([ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 ])) // Imprime \"36\" Si tenemos varios opcionales es posible comprobar que todos ellos son distintos de nil usando varios let en el mismo if : 1 2 3 4 5 6 7 8 9 var x1 : Int ? = pedirNumUsuario () var x2 : Int ? = pedirNumUsuario () var x3 : Int ? = pedirNumUsuario () if let dato1 = x1 , let dato2 = x2 , let dato3 = x3 { let suma = dato1 + dato2 + dato3 print ( \"Ning\u00fan nil y la suma de todos los datos es: \\( suma ) \" ) } else { print ( \"Alg\u00fan dato del usuario es nil\" ) } Operador nil-coalescing \u00b6 El operador nil-coalescing ( ?? ) permite definir un valor por defecto en una asignaci\u00f3n si un opcional es nil. 1 2 3 4 5 6 let a : Int ? = nil let b : Int ? = 10 let x = a ?? - 1 let y = b ?? - 1 print ( \"Resultado: \\( x ) , \\( y ) \" ) // Imprime Resultado: -1, 10 En el ejemplo anterior, en la variable x se guardar\u00e1 el valor -1 y en la variable y el valor 10 . Encadenamiento de opcionales \u00b6 El encadenamiento de opcionales ( optional chaining ) permite llamar a un m\u00e9todo de una variable que contiene un opcional. Si la variable no es nil , se ejecuta el m\u00e9todo y se devuelve su valor como un opcional. Si la variable es nil se devuelve nil . 1 2 3 4 5 6 7 8 9 10 11 let nombre1 : String ? = \"Pedro\" let nombre2 : String ? = nil // Error: let str1 = nombre1.lowercased() // No podemos llamar al m\u00e9todo lowercased() del String // porque nombre es opcional y puede tener nil let str1 = nombre1 ?. lowercased () let str2 = nombre2 ?. lowercased () // str1: String? = \"pedro\" // str2: String? = nil Definici\u00f3n de Lista con opcionales \u00b6 Veamos como \u00faltimo ejemplo una segunda versi\u00f3n del enum Lista , en el que utilizamos un \u00fanico case , pero dando la posibilidad de que el resto de la lista sea nil haci\u00e9ndolo opcional. Definimos el enumerado y tambi\u00e9n la funci\u00f3n suma(lista:) : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 indirect enum Lista { case nodo ( Int , Lista ?) } func suma ( lista : Lista ) -> Int { switch lista { case let . nodo ( car , cdr ): if ( cdr == nil ) { return car } else { return car + suma ( lista : cdr !) } } } let z : Lista = . nodo ( 20 , . nodo ( 10 , nil )) print ( suma ( lista : z )) /// Devuelve 30 Clausuras \u00b6 Ya hemos visto previamente que en Swift las funciones son objetos de primera clase del lenguaje y que es posible definir funciones y pasarlas como par\u00e1metro de otras funciones. Tambi\u00e9n es posible construir clausuras, funciones definidas en el \u00e1mbito de otras funcionas y devueltas como resultados. Veremos primero c\u00f3mo definir de forma compacta funciones que se pasan como par\u00e1metro de otras, utilizando expresiones de clausuras . Y despu\u00e9s veremos c\u00f3mo las clausuras definidas en el interior de otras funciones capturan las variables definidas en el \u00e1mbito de la funci\u00f3n principal. Expresiones de clausuras \u00b6 Swift permite definir expresiones compactas con las que construir estas funciones que se pasan como par\u00e1metro de otras funciones. Se denominan expresiones de clausuras ( closure expressions ). Estas expresiones proporcionan optimizaciones de sintaxis para escribir clausuras de forma concisa y clara. Vamos a ver las distintas optimizaciones utilizando como ejemplo el m\u00e9todo sorted(by:) . El m\u00e9todo sorted(by:) \u00b6 Tal y como hemos visto anteriormente la biblioteca st\u00e1ndar de Swift define un m\u00e9todo sorted() que devuelve los elementos ordenados de un Array . El array original no se modifica. La comparaci\u00f3n entre los elementos se realiza usando el comparador < . Veamos un ejemplo con un array de cadenas: 1 2 3 4 let estudiantes = [ \"Kofi\" , \"Abena\" , \"Peter\" , \"Kweku\" , \"Akosua\" ] let ordenados = estudiantes . sorted () print ( ordenados ) // Imprime \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\" Esta funci\u00f3n es similar a las que hay en muchos lenguajes. El \u00fanico aspecto funcional es que el array original no se modifica, sino que la ordenaci\u00f3n construye un nuevo array (existe una funci\u00f3n alternativa mutable que se denomina sort() ). Lo interesante relacionado con las clausuras est\u00e1 en la funci\u00f3n sorted(by:) . En esta funci\u00f3n se utiliza una clausura como par\u00e1metro para modificar la comparaci\u00f3n entre elementos y resultar en una ordenaci\u00f3n distinta. Es una de las distintas funciones de orden superior que se definen en las colecciones (m\u00e1s adelante veremos otras). El perfil de la funci\u00f3n sorted(by:) es: 1 func sorted(by areInIncreasingOrder: (Element, Element) -> Bool) El par\u00e1metro es una funci\u00f3n de dos par\u00e1metros (del tipo de los elementos del array) que devuelve un booleano indicando si el primer par\u00e1metro va antes que el segundo en el array ordenado. La clausura de ordenaci\u00f3n devuelve true si el primer valor deber\u00eda aparecer antes del segundo valor y false en otro caso. Por ejemplo, podr\u00edamos ordenar un array de cadenas en orden alfab\u00e9tico inverso. 1 2 3 4 5 6 7 func primeroMayor ( s1 : String , s2 : String ) -> Bool { return s1 > s2 } let estudiantes = [ \"Kofi\" , \"Abena\" , \"Peter\" , \"Kweku\" , \"Akosua\" ] let alreves = estudiantes . sorted ( by : primeroMayor ) print ( alreves ) // Imprime [\"Peter\", \"Kweku\", \"Kofi\", \"Akosua\", \"Abena\"] Si la primera cadena ( s1 ) es mayor que la segunda cadena ( s2 ), la funci\u00f3n primeroMayor(s1:s2:) devolver\u00e1 true , indicando que s1 deber\u00eda aparecer antes que s2 en el array ordenado. La ordenaci\u00f3n mayor o menor se refiere a la ordenaci\u00f3n alfab\u00e9tica, al estar tratando con caracteres. La versi\u00f3n anterior esta es una forma bastante complicada de escribir lo que b\u00e1sicamente es una funci\u00f3n de una \u00fanica expresi\u00f3n ( a > b ). En este ejemplo, ser\u00eda preferible escribir la clausura de ordenaci\u00f3n inline , utilizando la sintaxis de expresiones de clausuras. Sintaxis de las expresiones de clausura \u00b6 La sintaxis de las expresiones de clausura tiene la siguiente forma general: 1 2 3 { ( <parametros>) -> <tipo devuelto> in <sentencias> } Si aplicamos esta sintaxis al ejemplo anterior: 1 2 3 let alreves = estudiantes . sorted ( by : { ( s1 : String , s2 : String ) -> Bool in return s1 > s2 }) Hay que hacer notar que la declaraci\u00f3n de los par\u00e1metros y el tipo devuelto por esta clausura inline es id\u00e9ntica a la declaraci\u00f3n de la funci\u00f3n primeroMayor(s1:s2:) . En ambos casos, se escribe como (s1: String, s2: String) -> Bool . Sin embargo, en la expresi\u00f3n de clausura los par\u00e1metros y el tipo devuelto se escribe dentro de las llaves, no fuera. El comienzo del cuerpo de la clausura se introduce por la palabra clave in . Esta palabra clave indica que la definici\u00f3n de los par\u00e1metros y del tipo devuelto por la clausura ha terminado, y que el cuerpo de la clausura va a comenzar. Como el cuerpo de la clausura es corto, podemos incluso escribirlo en una \u00fanica l\u00ednea: 1 let alreves = estudiantes . sorted ( by : { ( s1 : String , s2 : String ) -> Bool in return s1 > s2 } ) Inferencia del tipo por el contexto \u00b6 Como la clausura de ordenaci\u00f3n se pasa como argumento de un m\u00e9todo, Swift puede inferir los tipos de sus par\u00e1metros y el tipo del valor que devuelve. El m\u00e9todo sorted(by:) se llama sobre un array de cadenas, por lo que su argumento debe ser una funci\u00f3n del tipo (String, String) -> Bool . Esto significa que los tipos (String, String) y Bool no necesitan escribirse como parte de la definici\u00f3n de la expresi\u00f3n de la clausura. Debido a que todos los tipos pueden ser inferidos, la flecha del tipo devuelto y los par\u00e9ntesis alrededor de los nombres de los par\u00e1metros tambi\u00e9n pueden omitirse: 1 let alreves = estudiantes . sorted ( by : { s1 , s2 in return s1 > s2 } ) Devoluciones impl\u00edcitas en clausuras con una \u00fanica expresi\u00f3n \u00b6 En clausuras con una \u00fanica expresi\u00f3n podemos omitir tambi\u00e9n la palabra clave return : 1 let alreves = estudiantes . sorted ( by : { s1 , s2 in s1 > s2 } ) Abreviaturas en los nombres de los argumentos \u00b6 Swift proporciona autom\u00e1ticamente abreviaturas para los nombres de argumentos de las clausuras inline que pueden usarse para referirse a los valores de los argumentos de la clausura usando los nombres $0 , $1 , $2 , etc. Si se usa estos argumentos abreviados, se puede omitir la definici\u00f3n de la lista de los argumentos: 1 let alreves = estudiantes . sorted ( by : { $0 > $1 } ) Funciones operadoras \u00b6 Incluso hay una forma aun m\u00e1s corta de escribir la expresi\u00f3n de clausura anterior. Swift define una implementaci\u00f3n espec\u00edfica de cadenas del operador mayor-que ( > ) como una funci\u00f3n que tiene dos par\u00e1metros de tipo String y devuelve un Bool . Esto es exactamente lo que necesita el m\u00e9todo sorted(by:) . Podemos, por tanto, pasar simplemente este operador mayor-que, y Swift inferir\u00e1 que queremos usar el espec\u00edfico de cadenas: 1 let alreves = estudiantes . sorted ( by : > ) Clausuras al final \u00b6 Si necesitamos pasar una expresi\u00f3n de clausura a una funci\u00f3n como el argumento final de la clausura y la expresi\u00f3n es larga, puede ser \u00fatil escribirla en su lugar como una clausura al final ( trailing closure ). Una clausura al final es una expresi\u00f3n de clausura que se escribe fuera de (y despu\u00e9s de) los par\u00e9ntesis de la funci\u00f3n a la que se le pasa como par\u00e1metro: 1 let alreves = estudiantes . sorted () { $0 > $1 } Cuando se proporciona una expresi\u00f3n de clausura como \u00fanico argumento de una funci\u00f3n o m\u00e9todo y se pasa como una clausura al final, no es necesario escribir los par\u00e9ntesis tras el nombre de la funci\u00f3n: 1 let alreves = estudiantes . sorted { $0 > $1 } Valores capturados \u00b6 Una clausura puede capturar constantes y variables del contexto en el que se define. La clausura puede referirse y modificar esos valores dentro de su cuerpo, incluso si ya no existe el \u00e1mbito ( scope ) original en el que se definieron estas constantes y variables. En Swift, la forma m\u00e1s sencilla de una clausura que captura valores es una funci\u00f3n anidada ( nested function ) escrita en el cuerpo de otra funci\u00f3n. Una funci\u00f3n anidada puede capturar cualquiera de los argumentos de su funci\u00f3n exterior y tambi\u00e9n puede capturar cualquier constante y variable definida dentro de la funci\u00f3n exterior. Veamos un ejemplo similar al que vimos en Scheme. La funci\u00f3n construyeIncrementador contiene una funci\u00f3n anidada llamada incrementador . Esta funci\u00f3n captura dos valores de su contexto: totalAcumulado y cantidad . Despu\u00e9s de capturar estos valores, incrementador es devuelto por construyeIncrementador como una clausura que incrementa totalAcumulado en cantidad cada vez que se llama. 1 2 3 4 5 6 7 8 func construyeIncrementador ( incremento cantidad : Int ) -> () -> Int { var totalAcumulado = 0 func incrementador () -> Int { totalAcumulado += cantidad return totalAcumulado } return incrementador } El tipo devuelto de construyeIncrementador es () -> Int . Esto significa que devuelve una funci\u00f3n que no tiene par\u00e1metros y que devuelve un Int cada vez que es llamada. La funci\u00f3n construyeIncrementador(incremento:) tiene un \u00fanico par\u00e1metro Int con nombre externo incremento y nombre local cantidad . El argumento pasado a este par\u00e1metro especifica cu\u00e1nto ser\u00e1 incrementado totalAcumulado cada vez que se llama a la funci\u00f3n incrementador devuelta. La funci\u00f3n construyeIncrementador define una funci\u00f3n anidada llamada incrementador , que realiza el incremento real. Esta funci\u00f3n simplemente a\u00f1ade cantidad a totalAcumulado , y devuelve el resultado. Si la consideramos aislada, la funci\u00f3n anidada incrementador() podr\u00eda parecer extra\u00f1a: 1 2 3 4 func incrementador () -> Int { totalAcumulado += cantidad return totalAcumulado } La funci\u00f3n no tiene ning\u00fan par\u00e1metro, y sin embargo se refiere a totalAcumulado y a cantidad en su cuerpo. Lo puede hacer porque ha capturado una referencia a estas variables de la funci\u00f3n de alrededor y las usa en su propio cuerpo. Al capturar estas referencias las variables totalAcumulado y cantidad no desaparecen cuando termina la llamada a construyeIncrementador . Estas variables tambi\u00e9n estar\u00e1n disponibles la pr\u00f3xima vez que se llame la funci\u00f3n incrementador . Aqu\u00ed hay un ejemplo de construyeIncrementador en acci\u00f3n: 1 let incrementaDiez = construyeIncrementador ( incremento : 10 ) Este ejemplo define una constante llamada incrementaDiez para referenciar la funci\u00f3n incrementador que devuelve construyeIncrementador . Esta funci\u00f3n a\u00f1ade 10 a la variable totalAcumulado cada vez que se es llamada. Si llamamos a la funci\u00f3n m\u00e1s de una vez podemos comprobar su conducta en acci\u00f3n: 1 2 3 4 5 6 incrementaDiez () // devuelve 10 incrementaDiez () // devuelve 20 incrementaDiez () // devuelve 30 Si creamos un segundo incrementador, tendr\u00e1 sus propias referencias a un variable totalAcumulado nueva, distinta de la anterior: 1 2 3 let incrementaSiete = construyeIncrementador ( incremento : 7 ) incrementaSiete () // devuelve 7 Si llamamos a la funci\u00f3n incrementador original ( incrementaDiez ) vemos que sigue incrementando su propia variable totalAcumulado y que no se ve afectada por la variable capturada por incrementaSiete : 1 2 incrementaDiez () // devuelve 40 Clausuras con expresiones de clausura \u00b6 En el ejemplo anterior hemos usado una definici\u00f3n interna de una funci\u00f3n para definir la clausura que se devuelve. Lo hemos hecho por claridad, pero no es necesario. Es posible escribir un c\u00f3digo m\u00e1s compacto usando expresiones de clausura. Por ejemplo, la funci\u00f3n construyeSumador() vista en el apartado \"Funciones que devuelven otras funciones\": 1 2 3 4 func construyeSumador10 () -> ( Int ) -> Int { func suma10 ( x : Int ) -> Int { return x + 10 } return suma10 } Una versi\u00f3n de esta misma funci\u00f3n usando una expresi\u00f3n de clausura es la siguiente: 1 2 3 4 5 6 7 func construyeSumador10 () -> ( Int ) -> Int { return { $0 + 10 } } var f = construyeSumador10 () print ( f ( 20 )) // Imprime \"30\" Y lo mismo con la funci\u00f3n constryeIncrementador(incremento:) vista en el apartado anterior: 1 2 3 4 5 6 7 8 func construyeIncrementador ( incremento cantidad : Int ) -> () -> Int { var totalAcumulado = 0 func incrementador () -> Int { totalAcumulado += cantidad return totalAcumulado } return incrementador } La versi\u00f3n con una expresi\u00f3n de clausura: 1 2 3 4 5 6 7 8 9 10 11 func construyeIncrementador ( incremento cantidad : Int ) -> () -> Int { var totalAcumulado = 0 return { totalAcumulado += cantidad return totalAcumulado } } let incrementaDiez = construyeIncrementador ( incremento : 10 ) print ( incrementaDiez ()) // Imprime \"10\" print ( incrementaDiez ()) // Imprime \"20\" Las clausuras son tipos de referencia \u00b6 En el ejemplo anterior, incrementaSiete e incrementaDiez son constantes, pero las clausuras a las que estas constantes se refieren pueden incrementar la variable totalAcumulado que han capturado. Esto es porque funciones y clausuras son tipos referencia. Siempre que asignamos una funci\u00f3n o una clausura a una constante o una variable, estamos realmente estableciendo que la constante o variable es una referencia a la funci\u00f3n o la clausura. En el ejemplo anterior, es la elecci\u00f3n de la clausura a la que referencia incrementaDiez la que es constante, no los contenidos propios de la clausura. Esto tambi\u00e9n significa que si asignamos una clausura a dos constantes o variables distintas, ambas constantes o variables se referir\u00e1n a la misma clausura: 1 2 3 let tambienIncrementaDiez = incrementaDiez tambienIncrementaDiez () // devuelve 50 Funciones de orden superior \u00b6 Una de las caracter\u00edsticas funcionales que m\u00e1s hemos usado para trabajar con listas en Scheme son las funciones de orden superior como map , filter o fold-right . Swift tiene definidas funciones equivalentes para trabajar con colecciones. Se denominan map , filter y reduce . Todas ellas aceptan expresiones de clausura como argumento. Map \u00b6 El m\u00e9todo map se define en el protocolo CollectionType y es adoptado por m\u00faltiples estructuras como Array , Dictionary , Set o String.CharacterView . El perfil del m\u00e9todo map es el siguiente: 1 func map < T >( _ transform : ( Element ) -> T ) -> [ T ] Se trata de un m\u00e9todo gen\u00e9rico (lo veremos m\u00e1s adelante) que recibe como par\u00e1metro una funci\u00f3n unaria (funci\u00f3n de transformaci\u00f3n) del tipo de los elementos de la colecci\u00f3n y que devuelve otro elemento (puede ser del mismo o de distinto tipo que los elementos de la colecci\u00f3n). Devuelve un array que contiene el resultado de aplicar la funci\u00f3n de transformaci\u00f3n a cada elemento del array original. Por ejemplo: 1 2 3 let numeros = [ Int ]( 0. .. 5 ) numeros . map { $0 * $0 } // devuelve [0, 1, 4, 9, 16, 25] Otro ejemplo, en el que usamos map para implementar la funci\u00f3n sumaParejas(parejas: [(Int, Int)]) -> [Int] que devuelve recibe el array parejas de tuplas de dos enteros y devuelve un array con el resultado de sumar los dos elementos de cada pareja: 1 2 3 4 5 6 func suma ( parejas : [( Int , Int )]) -> [ Int ] { return parejas . map ({( pareja : ( Int , Int )) -> Int in return pareja . 0 + pareja . 1 }) } suma ( parejas :[( 1 , 1 ), ( 2 , 2 ), ( 3 , 3 ), ( 4 , 4 )]) // devuelve [2, 4, 6, 8] Podemos usar en el cuerpo de la expresi\u00f3n de clausura de map una variable capturada. Por ejemplo en la siguiente funci\u00f3n incrementaValores(_:con:) que suma con a todos los n\u00fameros de un array que se le pasa por par\u00e1metro: 1 2 3 4 5 6 func incrementa ( valores : [ Int ], con : Int ) -> [ Int ] { return valores . map ({( x : Int ) -> Int in return x + con }) } incrementa ( valores :[ 10 , 20 , 30 ], con : 5 ) // devuelve [15, 25, 35] La versi\u00f3n abreviada de la expresi\u00f3n de clausura es: 1 2 3 4 5 func incrementa ( valores : [ Int ], con inc : Int ) -> [ Int ] { return valores . map { $0 + inc } } incrementa ( valores : [ 10 , 20 , 30 ], con : 5 ) // devuelve [15, 25, 35] Filter \u00b6 La funci\u00f3n filter es tambi\u00e9n igual que la definida en Scheme. Su perfil es: 1 func filter ( _ isIncluded : ( Element ) -> Bool ) -> [ Element ] Recibe una clausura de un argumento que devuelve un booleano. La funci\u00f3n devuelve un array con los elementos de la colecci\u00f3n para los que la clausura devuelve true . Ejemplo: 1 2 3 let numeros = [ Int ]( 0. .. 10 ) numeros . filter { $0 % 2 == 0 } // devuelve [0, 2, 4, 6, 8, 10] Reduce \u00b6 Similar al fold de Scheme. Su perfil es el siguiente: 1 func reduce < Result >( _ initialResult : Result , _ nextPartialResult : ( Result , Element ) -> Result ) -> Result Es una funci\u00f3n gen\u00e9rica que devuelve un valor de un tipo gen\u00e9rico (el tipo del resultado que se construye en la funci\u00f3n). Recibe como par\u00e1metro un valor inicial y una funci\u00f3n de plegado que se aplica al resultado anterior y al elemento de la colecci\u00f3n, devolviendo un resultado. El resultado final es el resultado de aplicar la funci\u00f3n de plegado a todos los elementos de la colecci\u00f3n, empezando por el valor inicial. Por ejemplo, podemos usar reduce para sumar todos los n\u00fameros de un array: 1 2 let numeros = [ Int ]( 0. .. 10 ) numeros . reduce ( 0 , + ) La funci\u00f3n combina los elementos de la colecci\u00f3n usando la funci\u00f3n de combinaci\u00f3n que se pasa como par\u00e1metro. La funci\u00f3n que se pasa como par\u00e1metro recibe dos par\u00e1metros: el primero es el resultado de la combinaci\u00f3n y el segundo se coge de la colecci\u00f3n. Por ejemplo, el siguiente c\u00f3digo usa reduce para sumar la longitud de todas las cadenas de un array: 1 2 3 4 let cadenas = [ \"Patatas\" , \"Arroz\" , \"Huevos\" ] cadenas . reduce ( 0 , {( i : Int , c : String ) -> Int in c . count + i }) // devuelve 18 Es posible simplificar la notaci\u00f3n anterior: 1 cadenas . reduce ( 0 , { $1 . count + $0 }) Tambi\u00e9n se puede utilizar la notaci\u00f3n de clausura al final: 1 cadenas . reduce ( 0 ) { $1 . count + $0 } La combinaci\u00f3n se hace de izquierda a derecha: 1 2 3 4 let cadenas = [ \"Patatas\" , \"Arroz\" , \"Huevos\" ] let cadenas = [ \"Patatas\" , \"Arroz\" , \"Huevos\" ] print ( cadenas . reduce ( \"*\" , { $0 + \"-\" + $1 })) // Imprime \"*-Patatas-Arroz-Huevos\" El primer argumento de la funci\u00f3n de plegado ( $0 ) es el resultado anterior (empieza por \"*\" ) y el segundo argumento ( $1 ) se coge del array de cadenas. Combinaci\u00f3n de funciones de orden superior \u00b6 Cuando el resultado de aplicar una funci\u00f3n de orden superior a una colecci\u00f3n es otra colecci\u00f3n es posible aplicar otra funci\u00f3n de orden superior a este resultado. Por ejemplo, la siguiente sentencia devuelve todos los n\u00fameros pares del array inicial elevados al cuadrado: 1 2 3 let numeros = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] numeros . filter { $0 % 2 == 0 }. map { $0 * $0 } // Devuelve el array [4,16,36,64,100] Y la siguiente devuelve la suma n\u00fameros mayores de 100: 1 2 3 let numeros = [ 103 , 2 , 330 , 42 , 532 , 6 , 125 ] numeros . filter { $0 >= 100 }. reduce ( 0 , + ) // Devuelve 1090 Gen\u00e9ricos \u00b6 Empecemos con un ejemplo sencillo. Supongamos la siguiente funci\u00f3n intercambia(_:) que recibe una tupla (Int, String) y devuelve una tupla (String, Int) con los valores intercambiados. 1 2 3 4 5 6 7 8 func intercambia ( _ tupla : ( Int , String )) -> ( String , Int ) { let tuplaNueva = ( tupla . 1 , tupla . 0 ) return tuplaNueva } let tupla = ( 10 , \"Hola\" ) intercambia ( tupla ) // devuelve (\"Hola\", 10) La funci\u00f3n es interesante, pero s\u00f3lo recibe tuplas cuya primera componente es un Int y su segunda componente es un String . Supongamos que queremos hacer la misma funci\u00f3n para intercambiar elementos de una tupla (Int, Int) . Tendr\u00edamos que usar el mismo c\u00f3digo, pero cambiando los tipos: 1 2 3 4 5 6 7 8 func intercambia ( _ tupla : ( Int , Int )) -> ( Int , Int ) { let tuplaNueva = ( tupla . 1 , tupla . 0 ) return tuplaNueva } let tupla = ( 10 , 20 ) intercambia ( tupla ) // devuelve (20, 10) El c\u00f3digo es el mismo, lo \u00fanico distinto son los tipos. \u00bfPodr\u00edamos generalizar las funciones anteriores para hacer que el c\u00f3digo pueda trabajar con cualquier tipo? La respuesta es s\u00ed, usando funci\u00f3n gen\u00e9rica : 1 2 3 4 func intercambia < A , B >( _ tupla : ( A , B )) -> ( B , A ) { let tuplaNueva = ( tupla . 1 , tupla . 0 ) return tuplaNueva } El cuerpo de la funci\u00f3n es id\u00e9ntico a la funci\u00f3n anterior. La diferencia es que en la versi\u00f3n gen\u00e9rica se usan placeholders (los s\u00edmbolos A y B ) en lugar de tipos concretos. Son tipos gen\u00e9ricos, que se definen usando un identificador entre s\u00edmbolos de < y > . Los tipos reales que se van a usar en la funci\u00f3n se determinan en cada invocaci\u00f3n a la funci\u00f3n, dependiendo del tipo del par\u00e1metro que se utiliza en la llamada: 1 2 3 4 5 6 7 8 9 let tupla = ( 10 , \"Hola\" ) intercambia ( tupla ) // devuelve (\"Hola\", 10) let tupla2 = ( 10 , 20 ) intercambia ( tupla2 ) // devuelve (10, 20) let tupla3 = ( true , 10.5 ) intercambia ( tupla3 ) // devuelve (10.5, true) En el primer ejemplo, los tipos A y B se infieren como Int y String . En el segundo ejemplo como Int e Int . Y en el tercero como Bool y Double . Los tipos gen\u00e9ricos se pueden usar en la definici\u00f3n de todos los elementos de Swift: funciones, enums, estructuras, clases, protocolos o extensiones. Terminamos con un ejemplo en el que incluimos muchos conceptos vistos en este tema. Se trata de la implementaci\u00f3n en Swift de listas al estilo Scheme, con las funciones car , cdr y vacia usando un enum recursivo con un tipo gen\u00e9rico que permite generalizar el tipo de elementos de la lista. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 indirect enum Lista < T > { case vacia case nodo ( T , Lista < T >) } func car < T >( _ lista : Lista < T >) -> T ? { switch lista { case let . nodo ( primero , _ ): return primero case . vacia : return nil } } func cdr < T >( _ lista : Lista < T >) -> Lista < T >? { switch lista { case let . nodo ( _ , resto ): return resto case . vacia : return nil } } func vacia < T >( _ lista : Lista < T >) -> Bool { switch lista { case . vacia : return true default : return false } } let lista : Lista = . nodo ( 20 , . nodo ( 30 , . nodo ( 40 , . vacia ))) print ( car ( lista ) ! ) // Imprime 20 print ( car ( cdr ( lista ) ! ) ! ) // Imprime 30 print ( car ( cdr ( cdr ( lista ) ! ) ! ) ! ) // Imprime 40 print ( vacia ( cdr ( cdr ( cdr ( lista ) ! ) ! ) ! )) // Imprime true Bibliograf\u00eda \u00b6 Swift Language Guide The Basics Collection Types Functions Closures Enumerations Generics Biblioteca est\u00e1ndar de Swift Lenguajes y Paradigmas de Programaci\u00f3n, curso 2018\u201319 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Domingo Gallardo, Cristina Pomares, Antonio Bot\u00eda, Francisco Mart\u00ednez","title":"Tema 5: Programaci\u00f3n Funcional con Swift"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#tema-5-programacion-funcional-con-swift","text":"","title":"Tema 5: Programaci\u00f3n Funcional con Swift"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#introduccion","text":"Te recomendamos que leas el seminario de Swift en el que se introduce el lenguaje y se explica c\u00f3mo ejecutar programas en este lenguaje: Seminario de Swift","title":"Introducci\u00f3n"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#conceptos-fundamentales-de-programacion-funcional","text":"Vamos a repasar en este tema c\u00f3mo se implementan en Swift conceptos principalmente funcionales como: Valores inmutables Funciones como objetos de primera clase y clasuras Funciones de orden superior Repasamos r\u00e1pidamente algunos conceptos b\u00e1sicos de programaci\u00f3n funcional, vistos en los primeros temas de la asignatura. Programaci\u00f3n Funcional: La Programaci\u00f3n Funcional es un paradigma de programaci\u00f3n que trata la computaci\u00f3n como la evaluaci\u00f3n de funciones matem\u00e1ticas y que evita cambios de estado y datos mutables. Funciones matem\u00e1ticas o puras: Las funciones matem\u00e1ticas tienen la caracter\u00edstica de que cuando las invocas con el mismo argumento siempre te devolver\u00e1n el mismo resultado. Funciones como objetos de primera clase: En programaci\u00f3n funcional, las funciones son objetos de primera clase del lenguaje, similares a enteros o strings . Podemos pasar funciones como argumentos en las denominadas funciones de orden superior o devolver funciones creadas en tiempo de ejecuci\u00f3n (clausuras).","title":"Conceptos fundamentales de Programaci\u00f3n Funcional"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#caracteristicas-basicas-de-swift","text":"Swift es un lenguaje principalmente imperativo, pero en su dise\u00f1o se han introducido conceptos modernos de programaci\u00f3n funcional, extra\u00eddos de lenguajes como Rust o Haskell. Por ello se puede considerar un lenguaje multi-paradigma , en el que se puede definir c\u00f3digo funcional que se puede ejecutar junto con c\u00f3digo imperativo. Como dice su creador Chris Lattner : El lenguaje Swift es el resultado de un esfuerzo incansable de un equipo de expertos en lenguajes, gur\u00fas de documentaci\u00f3n, ninjas de optimizaci\u00f3n de compiladores [..]. Por supuesto, tambi\u00e9n se benefici\u00f3 enormemente de las experiencias ganadas en muchos otros lenguajes, tomando ideas de Objective-C, Rust, Haskell, Ruby, Python, C#, CLU, y demasiados otros para ser enumerados.","title":"Caracter\u00edsticas b\u00e1sicas de Swift"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#inmutabilidad","text":"Una de las caracter\u00edsticas funcionales importantes de Swift es el \u00e9nfasis en la inmutabilidad para reforzar la seguridad del lenguaje. Hemos visto que la palabra clave let permite definir constantes y que Swift recomienda su uso si el valor que definimos es un valor que no va a ser modificado. El valor asignado a una constante let puede no conocerse en tiempo de compilaci\u00f3n, sino que puede ser obtenido en tiempo de ejecuci\u00f3n como un valor devuelto por una funci\u00f3n: 1 let respuesta : String = respuestaUsuario . respuesta () Al declarar una variable como let se bloquea su contenido y no se permite su modificaci\u00f3n. Una de las ventajas del paradigma funcional y de la inmutabilidad es que garantiza que el c\u00f3digo que escribimos no tiene efectos laterales y puede ser ejecutado sin problemas en entornos multi-procesador o multi-hilo.","title":"Inmutabilidad"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#creacion-de-nuevas-estructuras-y-mutacion","text":"En la biblioteca est\u00e1ndar de Swift existen una gran cantidad de estructuras (como Int , Double , Bool , String , Array , Dictionary , etc.) que tienen dos tipos de m\u00e9todos: m\u00e9todos que mutan la estructura y m\u00e9todos que devuelven una nueva estructura. Cuando estemos escribiendo c\u00f3digo con estilo funcional deberemos utilizar siempre estos \u00faltimos m\u00e9todos, los que construyen estructuras nuevas. Por ejemplo, en el struct Array se define el m\u00e9todo sort y el m\u00e9todo sorted . El primero ordena el array con mutaci\u00f3n y el segundo devuelve una copia ordenada, sin modificar el array original. En el siguiente c\u00f3digo no se modifica el array original, sino que se construye un array nuevo ordenado: 1 2 3 4 5 6 7 8 9 10 // C\u00f3digo recomendable en programaci\u00f3n funcional // porque utiliza el m\u00e9todo sorted que devuelve una // copia del array original let miArray = [ 10 , - 1 , 3 , 80 ] let arrayOrdenado = miArray . sorted () print ( miArray ) print ( arrayOrdenado ) // Imprime: // [10, -1, 3, 80] // [-1, 3, 10, 80] Este c\u00f3digo es el recomendable cuando estemos escribiendo c\u00f3digo con un estilo de programaci\u00f3n funcional. Sin embargo, el siguiente c\u00f3digo es imperativo y utiliza la mutaci\u00f3n del array original: 1 2 3 4 5 6 7 // C\u00f3digo no recomendable en programaci\u00f3n funcional // porque utiliza el m\u00e9todo sort que muta el array original var miArray = [ 10 , - 1 , 3 , 80 ] miArray . sort () print ( miArray ) // Imprime: // [-1, 3, 10, 80] Otro ejemplo es en la forma de a\u00f1adir elementos a un array. Podemos hacerlo con un enfoque funcional, usando el operador + que construye un array nuevo: 1 2 3 4 5 6 // C\u00f3digo recomendable en programaci\u00f3n funcional let miArray = [ 10 , - 1 , 3 , 80 ] let array2 = miArray + [ 100 ] print ( array2 ) // Imprime: // [10, -1, 3, 80, 100] Y podemos hacerlo usando un enfoque imperativo, con el m\u00e9todo append : 1 2 3 4 5 6 // C\u00f3digo no recomendable en programaci\u00f3n funcional var miArray = [ 10 , - 1 , 3 , 80 ] miArray . append ( 100 ) print ( miArray ) // Imprime: // [10, -1, 3, 80, 100] Importante En programaci\u00f3n funcional debemos usar siempre los m\u00e9todos que no modifican las estructuras . As\u00ed evitaremos los efectos laterales y nuestro c\u00f3digo funcionar\u00e1 correctamente en entornos multi-hilo. Cuando definimos una variable de tipo let el valor que se asigne a esa variable se convierte en inmutable. Si se trata de una estructura o una clase con m\u00e9todos mutables el compilador dar\u00e1 un error. Por ejemplo: 1 2 3 let miArray = [ 10 , - 1 , 3 , 80 ] miArray . append ( 100 ) // error: cannot use mutating member on immutable value: 'miArray' is a 'let' constant Otro ejemplo. El m\u00e9todo append(_:) de un String es un m\u00e9todo mutable. Si definimos una cadena con let no podremos modificarla y dar\u00eda error el siguiente c\u00f3digo: 1 2 3 4 5 var cadenaMutable = \"Hola\" let cadenaInmutable = \"Adios\" cadenaMutable . append ( cadenaInmutable ) // cadenaMutable es \"HolaAdios\" cadenaInmutable . append ( \"Adios\" ) // error: cannot use mutating member on immutable value: 'cadenaInmutable' is a 'let' constant","title":"Creaci\u00f3n de nuevas estructuras y mutaci\u00f3n"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#funciones","text":"","title":"Funciones"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#definicion-de-una-funcion-en-swift","text":"Para definir una funci\u00f3n en Swift se debe usar la palabra func , definir el nombre de la funci\u00f3n, sus par\u00e1metros y el tipo de vuelto. El valor devuelto por la funci\u00f3n se debe devolver usando la palabra return . C\u00f3digo de la funci\u00f3n saluda(nombre:) : 1 2 3 4 func saluda ( nombre : String ) -> String { let saludo = \"Hola, \" + nombre + \"!\" return saludo } Para invocar a la funci\u00f3n saluda(nombre:) : 1 2 3 4 print ( saluda ( nombre : \"Ana\" )) print ( saluda ( nombre : \"Pedro\" )) // Imprime \"Hola, Ana!\" // Imprime \"Hola, Pedro!\"","title":"Definici\u00f3n de una funci\u00f3n en Swift"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#etiquetas-de-argumentos-y-nombres-de-parametros","text":"Cada par\u00e1metro de una funci\u00f3n tiene una etiqueta del argumento y un nombre de par\u00e1metro. La etiqueta del argumento se usa cuando se llama a la funci\u00f3n y el nombre del par\u00e1metro se usa internamente en su implementaci\u00f3n. Por defecto, los par\u00e1metros usan su nombre de par\u00e1metro como etiqueta del argumento: 1 2 3 4 5 6 func unaFuncion ( primerNombreParametro : Int , segundoNombreParametro : Int ) { // En el cuerpo de la funci\u00f3n, primerNombreParametro y // segundoNombreParametro se refieren a los valores de los // argumentos del primer y el segundo par\u00e1metro } unaFuncion ( primerNombreParametro : 1 , segundoNombreParametro : 2 ) Es posible hacer distintos la etiqueta del argumento del nombre del par\u00e1metro: 1 2 3 4 5 func saluda ( nombre : String , de ciudad : String ) -> String { return \"Hola \\( nombre ) ! Me alegro de que hayas podido visitarnos desde \\( ciudad ) .\" } print ( saluda ( nombre : \"Bill\" , de : \"Cupertino\" )) // Imprime \"Hola Bill! Me alegro de que hayas podido visitarnos desde Cupertino.\" Otro ejemplo, la siguiente funci\u00f3n concatena(palabra:con:) : 1 2 3 4 5 func concatena ( palabra str1 : String , con str2 : String ) -> String { return str1 + str2 } print ( concatena ( palabra : \"Hola\" , con : \"adios\" )) Si no se quiere una etiqueta del argumento para un par\u00e1metro, se puede escribir un subrayado ( _ ) en lugar de una etiqueta del argumento expl\u00edcita para ese par\u00e1metro: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 func max ( _ x : Int , _ y : Int ) -> Int { if x > y { return x } else { return y } } print ( max ( 10 , 3 )) func divide ( _ x : Double , entre y : Double ) -> Double { return x / y } print ( divide ( 30 , entre : 4 )) El perfil de la funci\u00f3n est\u00e1 formado por el nombre de la funci\u00f3n, las etiquetas de los argumentos y el tipo devuelto por la funci\u00f3n. En la documentaci\u00f3n de las funciones usaremos las etiquetas separadas por dos puntos. Por ejemplo, las funciones anteriores son max(_:_:) y divide(_:entre:) . Las etiquetas de los argumentos son parte del nombre de la funci\u00f3n. Es posible definir funciones distintas con s\u00f3lo distintos nombres de argumentos, como las siguientes funciones mitad(par:) y mitad(impar:) : 1 2 3 4 5 6 7 8 9 10 11 12 func mitad ( par : Int ) -> Int { return par / 2 } func mitad ( impar : Int ) -> Int { return ( impar + 1 ) / 2 } print ( mitad ( par : 8 )) // Imprime 4 print ( mitad ( impar : 9 )) // Imprime 5","title":"Etiquetas de argumentos y nombres de par\u00e1metros"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#parametros-y-valores-devueltos","text":"Es posible definir funciones sin par\u00e1metros: 1 2 3 4 5 func diHolaMundo () -> String { return \"hola, mundo\" } print ( diHolaMundo ()) // Imprime \"hola, mundo\" Podemos definir funciones sin valor devuelto. Por ejemplo, la siguiente funci\u00f3n diAdios(nombre:) . No hay que escribir flecha con el tipo devuelto. Cuidado, no ser\u00eda propiamente programaci\u00f3n funcional. 1 2 3 4 5 func diAdios ( nombre : String ) { print ( \"Adi\u00f3s, \\( nombre ) !\" ) } diAdios ( nombre : \"Dave\" ) // Imprime \"Adi\u00f3s, Dave!\" Es posible devolver m\u00faltiples valores, construyendo una tupla. Por ejemplo, la siguiente funci\u00f3n ecuacion(a:b:c:) calcula las dos soluciones de una ecuaci\u00f3n de segundo grado: 1 2 3 4 5 6 func ecuacion ( a : Double , b : Double , c : Double ) -> ( pos : Double , neg : Double ) { let discriminante = b * b - 4 * a * c let raizPositiva = ( - b + discriminante . squareRoot ()) / 2 * a let raizNegativa = ( - b - discriminante . squareRoot ()) / 2 * a return ( raizPositiva , raizNegativa ) } Recordemos (consultar el seminario de Swift) que podemos acceder a los valores de la tupla por posici\u00f3n: 1 2 3 let resultado = ecuacion ( a : 1 , b : - 5 , c : 6 ) print ( \"Las ra\u00edces de la ecuaci\u00f3n son \\( resultado . 0 ) y \\( resultado . 1 ) \" ) //Imprime \"Las ra\u00edces de la ecuaci\u00f3n son 3.0 y 2.0\" En este caso en la definici\u00f3n del tipo devuelto por la funci\u00f3n estamos etiquetando esos valores con las etiquetas pos y neg . De esta forma podemos acceder a los componentes de la tupla usando esas etiquetas definidas: 1 2 3 let resultado = ecuacion ( a : 1 , b : - 5 , c : 6 ) print ( \"Las ra\u00edces de la ecuaci\u00f3n son \\( resultado . pos ) y \\( resultado . neg ) \" ) //Imprime \"Las ra\u00edces de la ecuaci\u00f3n son 3.0 y 2.0\"","title":"Par\u00e1metros y valores devueltos"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#recursion","text":"Veamos algunos ejemplos de funciones recursivas en Swift. Primero una funci\u00f3n suma(hasta:) que devuelve la suma desde 0 hasta el n\u00famero que le pasamos como par\u00e1metro. 1 2 3 4 5 6 7 8 9 10 func suma ( hasta x : Int ) -> Int { if x == 0 { return 0 } else { return x + suma ( hasta : x - 1 ) } } print ( suma ( hasta : 5 )) // Imprime \"15\" Tambi\u00e9n es posible definir recursiones que recorran arrays de una forma similar a c\u00f3mo trabaj\u00e1bamos en Scheme. Los arrays en Swift no funcionan exactamente como las listas de Scheme (no son listas de parejas), pero podemos obtener el primer elemento y el resto de la siguiente forma. 1 2 3 let a = [ 10 , 20 , 30 , 40 , 50 , 60 ] let primero = a [ 0 ] let resto = Array ( a . dropFirst ()) En primero se guarda el n\u00famero 10. En resto se guarda el Array del 20 al 60. El m\u00e9todo dropFirst devuelve una ArraySlice , que es una vista de un rango de elementos del array, en este caso el que va desde la posici\u00f3n 1 hasta la 5 (la posici\u00f3n inicial de un array es la 0). Es necesario el constructor Array para convertir ese ArraySlice en un Array . Usando las instrucciones anteriores podemos definir la funci\u00f3n recursiva que suma los valores de un Array de la siguiente forma similar a c\u00f3mo lo hac\u00edamos en Scheme: 1 2 3 4 5 6 7 8 9 10 11 12 func sumaValores ( _ valores : [ Int ]) -> Int { if ( valores . isEmpty ) { return 0 } else { let primero = valores [ 0 ] let resto = Array ( valores . dropFirst ()) return primero + sumaValores ( resto ) } } print ( sumaValores ([ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 ])) // Imprime \"36\" Un \u00faltimo ejemplo es la siguiente funci\u00f3n minMax(array:) que devuelve el n\u00famero m\u00e1s peque\u00f1o y m\u00e1s grande de un array de enteros: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 func minMax ( array : [ Int ]) -> ( min : Int , max : Int ) { if ( array . count == 1 ) { return ( array [ 0 ], array [ 0 ]) } else { let primero = array [ 0 ] let resto = Array ( array . dropFirst ()) // Llamada recursiva que devuelve el m\u00ednimo y el m\u00e1ximo del // resto del array let minMaxResto = minMax ( array : resto ) let minimo = min ( primero , minMaxResto . min ) let maximo = max ( primero , minMaxResto . max ) return ( minimo , maximo ) } } let limites = minMax ( array : [ 8 , - 6 , 2 , 100 , 3 , 71 ]) print ( \"El m\u00ednimo es \\( limites . min ) y el m\u00e1ximo es \\( limites . max ) \" ) // Imprime \"El m\u00edmimo es -6 y el m\u00e1ximo es 100\" En este ejemplo nos apartamos un poco de la soluci\u00f3n vista en Scheme porque permitimos pasos de ejecuci\u00f3n que inicializan variables. Pero no nos salimos del paradigma funcional, porque todas son variables inmutables definidas con let .","title":"Recursi\u00f3n"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#tipos-funcion","text":"En Swift las funciones son objetos de primera clase y podemos asignarlas a variables, pasarlas como par\u00e1metro o devolverlas como resultado de otra funci\u00f3n. Al ser un lenguaje fuertemente tipado, las variables, par\u00e1metros o resultados deben ser objetos de tipo funci\u00f3n. Cada funci\u00f3n tiene un tipo espec\u00edfico, definido por el tipo de sus par\u00e1metros y el tipo del valor devuelto. 1 2 3 4 5 6 func sumaDosInts ( a : Int , b : Int ) -> Int { return a + b } func multiplicaDosInts ( a : Int , b : Int ) -> Int { return a * b } El tipo de estas funciones es (Int, Int) -> Int , que se puede leer como: \"Un tipo funci\u00f3n que tiene dos par\u00e1metros, ambos de tipo Int y que devuelve un valor de tipo Int \". En Swift se puede usar un tipo funci\u00f3n de la misma forma que cualquier otro tipo, por ejemplo asignando la funci\u00f3n a una variable: 1 2 3 4 5 6 var f = sumaDosInts print ( f ( 2 , 3 )) // Imprime \"5\" f = multiplicaDosInts print ( f ( 2 , 3 )) // Imprime \"6\" La variable f es una variable de tipo (Int, Int) -> Int , o sea, una variable que contiene funciones de dos argumentos Int que devuelven un Int . Nota Habr\u00e1s notado que al invocar a f no se ponen etiquetas en los argumentos. De hecho, si las pusi\u00e9ramos el compilador de Swift se quejar\u00eda: 1 2 print ( f ( a : 2 , b : 3 )) //error: extraneous argument labels 'a:b:' in call Esto es debido a que al ser f una variable se le puede asignar cualquier funci\u00f3n que tenga el perfil (Int, Int) -> Int sin tener en cuenta las etiquetas de los argumentos.","title":"Tipos funci\u00f3n"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#funciones-que-reciben-otras-funciones","text":"Podemos usar un tipo funci\u00f3n en par\u00e1metros de otras funciones: 1 2 3 4 5 func printResultado ( funcion : ( Int , Int ) -> Int , _ a : Int , _ b : Int ) { print ( \"Resultado: \\( funcionMatematica ( a , b )) \" ) } printResultado ( funcion : sumaDosInts , 3 , 5 ) // Prints \"Resultado: 8\" La funci\u00f3n printResultado(funcion:_:_:) toma como primer par\u00e1metro otra funci\u00f3n que recibe dos Int y devuelve un Int , y como segundo y tercer par\u00e1metro dos Int . Veamos otro ejemplo, que ya vimos en Scheme. Supongamos que queremos calcular el sumatorio desde a hasta b en el que aplicamos una funci\u00f3n f a cada n\u00famero que sumamos: 1 sumatorio(a, b, f) = f(a) + f(a+1) + f(a+2) + ... + f(b) Recordamos que se resuelve con la siguiente recursi\u00f3n: 1 2 sumatorio(a, b, f) = f(a) + sumatorio(a+1, b, f) sumatorio(a, b, f) = 0 si a > b Veamos c\u00f3mo se implementa en Swift: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 func sumatorio ( desde a : Int , hasta b : Int , func f : ( Int ) -> Int ) -> Int { if a > b { return 0 } else { return f ( a ) + sumatorio ( desde : a + 1 , hasta : b , func : f ) } } func identidad ( _ x : Int ) -> Int { return x } func doble ( _ x : Int ) -> Int { return x + x } func cuadrado ( _ x : Int ) -> Int { return x * x } print ( sumatorio ( desde : 0 , hasta : 10 , func : identidad )) // Imprime 55 print ( sumatorio ( desde : 0 , hasta : 10 , func : doble )) // Imprime 110 print ( sumatorio ( desde : 0 , hasta : 10 , func : cuadrado )) // Imprime 385","title":"Funciones que reciben otras funciones"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#funciones-en-estructuras","text":"Como cualquier otro tipo Las funciones pueden tambi\u00e9n incluirse en estructuras de datos compuestas, como arrays: 1 2 3 4 var funciones = [ identidad , doble , cuadrado ] print ( funciones [ 0 ]( 10 )) // 10 print ( funciones [ 1 ]( 10 )) // 20 print ( funciones [ 2 ]( 10 )) // 100 El tipo de la variable funciones ser\u00eda [(Int) -> Int] . Al ser Swift fuertemente tipeado, no podr\u00edamos hacer un array con distintos tipos de funciones. Por ejemplo el siguiente c\u00f3digo dar\u00eda un error: 1 2 3 4 5 6 7 func suma ( _ x : Int , _ y : Int ) -> Int { return x + y } // La siguiente l\u00ednea genera un error var misFunciones = [ doble , cuadrado , suma ] // error: heterogenous collection literal could only be inferred to // '[Any]'; add explicit type annotation if this is intentional","title":"Funciones en estructuras"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#funciones-que-devuelven-otras-funciones","text":"Por \u00faltimo, veamos un ejemplo de funciones que devuelven otras funciones. Es un ejemplo sencillo, una funci\u00f3n que devuelve otra que suma 10: 1 2 3 4 5 6 7 8 func construyeSumador10 () -> ( Int ) -> Int { func suma10 ( x : Int ) -> Int { return x + 10 } return suma10 } var f = construyeSumador10 () print ( f ( 20 )) // Imprime 30 La funci\u00f3n devuelta por construyeSumador10() es una funci\u00f3n con el tipo (Int) -> Int (recibe un par\u00e1metro entero y devuelve un entero). En la llamada a construyeSumador10() se crea esa funci\u00f3n y se asigna a la variable f . Estas funciones devueltas se denominan clausuras . M\u00e1s adelante hablaremos algo m\u00e1s de ellas. Veremos tambi\u00e9n m\u00e1s adelante que es posible usar expresiones de clausura que construyen clausuras an\u00f3nimas. Podemos modificar el ejemplo anterior, haciendo que la funci\u00f3n construyeSumador reciba el n\u00famero a sumar como par\u00e1metro: 1 2 3 4 5 6 7 8 9 10 11 func construyeSumador ( inc : Int ) -> ( Int ) -> Int { func suma ( x : Int ) -> Int { return x + inc } return suma } var f = construyeSumador ( inc : 10 ) var g = construyeSumador ( inc : 100 ) print ( f ( 20 )) // Imprime \"30\" print ( g ( 20 )) // Imprime \"120\" Invocamos dos veces a construyeSumador(inc:) y guardamos las clausuras construidas en las variables f y g . En f se guarda una funci\u00f3n que suma 10 a su argumento y en g otra que suma 100 .","title":"Funciones que devuelven otras funciones"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#tipos","text":"Entre las ventajas del uso de tipos est\u00e1 la detecci\u00f3n de errores en los programas en tiempo de compilaci\u00f3n o las ayudas del entorno de desarrollo para autocompletar c\u00f3digo. Entre los inconvenientes se encuentra la necesidad de ser m\u00e1s estrictos a la hora de definir los par\u00e1metros y los valores devueltos por las funciones, lo que impide la flexibilidad de Scheme. Se utilizan tipos para definir los posibles valores de: variables par\u00e1metros de funciones valores devueltos por funciones Tal y como hemos visto cuando hemos comentado que Swift es fuertemente tipado las definiciones de tipos van precedidas de dos puntos en las variables y par\u00e1metros, o de una flecha ( -> ) en la definici\u00f3n de los tipos de los valores devueltos por una funci\u00f3n: 1 2 3 4 5 6 let valorDouble : Double = 3.0 let unaCadena : String = \"Hola\" func calculaEstadisticas ( valores : Array < Int >) -> ( min : Int , max : Int , media : Int ) { ... } En Swift existen dos clases de tipos: tipos con nombre y tipos compuestos.","title":"Tipos"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#tipos-con-nombre","text":"Un tipo con nombre es un tipo al que podemos dar un nombre determinado cuando se define. Por ejemplo, al definir un nombre de una clase o de un enumerado estamos tambi\u00e9n definiendo un nombre de un tipo. En Swift es posible definir los siguientes tipos con nombre: nombres de clases nombres de estructuras nombres de enumeraciones nombres de protocolos Por ejemplo, instancias de una clase definida por el usuario llamada MiClase tienen el tipo MiClase . Adem\u00e1s de los tipos definidos por el usuario, la biblioteca est\u00e1ndar de Swift tiene un gran n\u00famero de tipos predefinidos. A diferencia de otros lenguajes, estos tipos no son parte del propio lenguaje sino que se definen en su mayor\u00eda como estructuras implementadas en esta biblioteca est\u00e1ndar. Por ejemplo, arrays, diccionarios o incluso los tipos m\u00e1s b\u00e1sicos como String o Int est\u00e1n construidos en esa biblioteca. La implementaci\u00f3n de estos elementos est\u00e1 disponible en abierto en el sitio GitHub de Swift .","title":"Tipos con nombre"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#tipos-compuestos","text":"Los tipos compuestos son tipos sin nombre. En Swift se definen dos: tuplas y tipos funci\u00f3n. Un tipo compuesto puede tener tipos con nombre y otros tipos compuestos. Por ejemplo la tupla (Int, (Int, Int)) contiene dos elementos: el primero es el tipo con nombre Int y el segundo el tipo compuesto que define la tupla (Int, Int) . Los tipos funci\u00f3n los hemos visto previamente. 1 2 3 4 5 6 7 8 9 10 11 let tupla : ( Int , Int , String ) = ( 2 , 3 , \"Hola\" ) let otraTupla : ( Int , Int , String ) = ( 5 , 8 , \"Adios\" ) func sumaTupla ( tupla t1 : ( Int , Int ), con t2 : ( Int , Int )) -> ( Int , Int ) { return ( t1 . 0 + t2 . 0 , t1 . 1 + t2 . 1 ) } print ( sumaTupla ( tupla : ( tupla . 0 , tupla . 1 ), con : ( otraTupla . 0 , otraTupla . 1 ))) // Imprime (7, 11)","title":"Tipos compuestos"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#tipos-valor-y-tipos-referencia","text":"En Swift existen dos tipos de construcciones que forman la base de la programaci\u00f3n orientada a objetos: las estructuras ( structs ) y las clases. En el tema siguiente hablaremos sobre ello. En la biblioteca est\u00e1ndar de Swift la mayor parte de los tipos definidos (como Int , Double , Bool , String , Array , Dictionary , etc.) son estructuras, no clases. Una de las diferencias m\u00e1s importantes entre estructuras y clases es su comportamiento en una asignaci\u00f3n: las estructuras tienen una sem\u00e1ntica de copia (son tipos valor) y las clases tienen una sem\u00e1ntica de referencia (son tipos referencia). Un tipo valor es un tipo que tiene sem\u00e1ntica de copia en las asignaciones y cuando se pasan como par\u00e1metro en llamadas a funciones. Los tipos valor son muy \u00fatiles porque evitan los efectos laterales en los programas y simplifican el comportamiento del compilador en la gesti\u00f3n de memoria. Al no existir referencias, se simplifica enormemente la gesti\u00f3n de memoria de estas estructuras. No es necesario llevar la cuenta de qu\u00e9 referencias apuntan a un determinado valor, sino que se puede liberar la memoria en cuanto se elimina el \u00e1mbito actual. Frente a un tipo valor, un tipo de referencia es aquel en los que los valores se asignan a variables con una sem\u00e1ntica de referencia. Cuando se realizan varias asignaciones de una misma instancia a distintas variables todas ellas guardan una referencia a la misma instancia. Si la instancia se modifica, todas las variables reflejar\u00e1n el nuevo valor. Cuando veamos las clases en el pr\u00f3ximo tema veremos algunos ejemplos. Veamos ahora algunos ejemplos de copia por valor en estructuras. Por ejemplo, si asignamos una cadena a otra, se realiza una copia: 1 2 3 4 5 var str1 = \"Hola\" var str2 = str1 str1 . append ( \"Adios\" ) print ( str1 ) // Imprime \"HolaAdios\" print ( str2 ) // Imprime \"Hola\" Los arrays tambi\u00e9n son estructuras y, por tanto, tambi\u00e9n tienen sem\u00e1ntica de copia: 1 2 3 4 5 var array1 = [ 1 , 2 , 3 , 4 ] var array2 = array1 array1 [ 0 ] = 10 print ( array1 ) // [10, 2, 3, 4] print ( array2 ) // [1, 2, 3, 4] A diferencia de otros lenguajes como Java, los par\u00e1metros de una funci\u00f3n siempre son inmutables y se pasan por copia, para reforzar el car\u00e1cter funcional de las funciones. Por ejemplo, es incorrecto escribir lo siguiente: 1 2 3 4 func ponCero ( array : [ Int ] , pos : Int ) { array [ pos ] = 0 // error : cannot assign through subscript : 'array' is a 'let' constant } Se podr\u00eda pensar que es muy costoso copiar un array entero. Por ejemplo, si asignamos o pasamos como par\u00e1metro un array de 1000 elementos. Pero no es as\u00ed. El compilador de Swift optimiza estas sentencias y s\u00f3lo realiza la copia en el momento en que hay una modificaci\u00f3n de una de las variables que comparten el array. Es lo que se llama copy on write .","title":"Tipos valor y tipos referencia"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#enumeraciones","text":"Las enumeraciones definen un tipo con un valor restringido de posibles valores: 1 2 3 4 5 6 enum Direccion { case norte case sur case este case oeste } Cualquier variable del tipo Direccion solo puede tener uno de los cuatro valores definidos. Se obtiene el valor escribiendo el nombre de la enumeraci\u00f3n, un punto y el valor definido. Si el tipo de enumeraci\u00f3n se puede inferir no es necesario escribirlo. 1 2 3 4 5 let hemosGirado = true var direccionActual = Direccion . norte if hemosGirado { direccionActual = . sur } En sentencias switch: 1 2 3 4 5 6 7 8 9 10 11 12 let direccionAIr = Direccion . sur switch direccionAIr { case . norte : print ( \"Nos vamos al norte\" ) case . sur : print ( \"Cuidado con los pinguinos\" ) case . este : print ( \"Donde nace el sol\" ) case . oeste : print ( \"Donde el cielo es azul\" ) } // Imprime \"Cuidado con los pinguinos\" Otro ejemplo: 1 2 3 enum Planeta { case mercurio , venus , tierra , marte , jupiter , saturno , urano , neptuno } Y, por \u00faltimo, es m\u00e1s correcto definir el resultado de una quiniela con un enumerado en lugar de con un String : 1 2 3 enum Quiniela { case uno , equis , dos }","title":"Enumeraciones"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#opcionales","text":"Una de las caracter\u00edsticas principales que Swift intenta promover es la seguridad y la robustez. Debe ser dif\u00edcil que el desarrollador escriba c\u00f3digo con errores y que rompa la aplicaci\u00f3n. Por ejemplo, la comprobaci\u00f3n est\u00e1tica de los tipos de datos o el manejo autom\u00e1tico de la gesti\u00f3n de memoria son dos caracter\u00edsticas del lenguaje que van en esta direcci\u00f3n. Otro de los elementos m\u00e1s importantes del lenguaje para promover la seguridad son los opcionales. Vamos a estudiar su uso y utilidad. En muchos lenguajes existe el concepto de valor vac\u00edo . Por ejemplo, en Java se usa null o en Python None . Nota Tony Hoare introdujo el concepto de Null en ALGOL, en 1965. En una conferencia en 2009 habla sobre esta idea y la considera un costoso error: Null References: The Billion Dollar Mistake . El concepto de null es un concepto peligroso, como lo saben bien los desarrolladores Java. En Java, si intentamos usar una variable que contiene null se produce la t\u00edpica excepci\u00f3n null pointer exception y la aplicaci\u00f3n se rompe. Todos hemos ca\u00eddo en este error, y con m\u00e1s frecuencia de la que ser\u00eda deseable. En Swift tambi\u00e9n existe el valor nulo. La forma de representarlo es el identificador nil . La caracter\u00edstica de seguridad que introduce Swift con respecto a Java y a otros lenguajes es que no es posible asignar nil a una variable de un tipo normal. Por ejemplo, la siguiente l\u00ednea dar\u00eda un error de compilaci\u00f3n: 1 2 let cadena : String = nil // error: 'nil' cannot initialize specified type 'String' Si queremos utilizar nil debemos declarar la variable usando lo que se denomina tipo opcional : 1 2 var cadena : String ? = \"Hola\" cadena = nil El tipo String? indica que podemos tener un valor nil o un valor del tipo original. Primero estamos definiendo la variable cadena del tipo String? ( String opcional) y le estamos asignando un valor determinado (de tipo String ). Y despu\u00e9s le asignamos nil . El uso de opcionales es necesario en situaciones en las que podemos obtener un valor desconocido. Por ejemplo, en alguna funci\u00f3n en la que pedimos un valor al usuario y el usuario puede no introducir ninguno. O en estructuras de datos en las que hacemos b\u00fasquedas que pueden no devolver ning\u00fan valor, como en un diccionario: 1 2 3 4 5 6 var edades = [ \"Raquel\" : 30 , \"Pedro\" : 22 , ] let edad1 = edades [ \"Raquel\" ] let edad2 = edades [ \"Ana\" ] En el c\u00f3digo anterior definimos un diccionario edades con claves de tipo String y valores Int . La variable edad1 se inicializa con un opcional con el valor 30 y la variable edad2 con un opcional que vale nil . Un valor opcional no puede ser usado directamente. Primero debemos comprobar si el valor es distinto de nil y s\u00f3lo despu\u00e9s podremos usarlo. Para reforzar esto, Swift esconde o envuelve ( wrap ) el valor real del opcional y obliga a llamar al operador ! para desenvolverlo ( unwrap ) y usarlo. Este operador se denomina de desenvoltura forzosa ( forced unwrapping ). Por ejemplo, el siguiente c\u00f3digo produce un error de compilaci\u00f3n porque intentamos usar un opcional sin desenvolverlo: 1 2 3 var x : Int ? = 10 let y = x + 10 // error: value of optional type 'Int?' must be unwrapped to a value of type 'Int' Para usar el valor asignado a x debemos desenvolverlo con el operador ! : 1 2 3 4 var x : Int ? = 10 let y = x ! + 10 print ( y ) // Imprime \"20\" Podemos definir como opcional variables, par\u00e1metros o valores devueltos por funciones de cualquier tipo, a\u00f1adi\u00e9ndoles la interrogaci\u00f3n al final. Por ejemplo, la siguiente funci\u00f3n max es una funci\u00f3n que devuelve un Int? , un entero opcional en el caso de que se le pase un array vac\u00edo. Al devolver un opcional, debemos desenvolver el valor devuelto cuando queramos usarlo como Int (por ejemplo, en la llamada recursiva). 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 func max ( array :[ Int ]) -> Int ? { if ( array . isEmpty ) { return nil } else if ( array . count == 1 ) { return array [ 0 ] } else { let primero = array [ 0 ] let resto = Array ( array . dropFirst ()) return max ( primero , max ( array : resto ) ! ) } } let maximo = max ( array :[ 10 , 200 , - 100 , 2 ]) print ( maximo !) // Imprime \"200\" Una variable opcional sin asignar ning\u00fan valor se inicializa autom\u00e1ticamente a nil : 1 2 var respuestaEncuesta : String ? // respuestaEncuesta es inicializado autom\u00e1ticamente a nil Si se aplica el operador ! a un valor nil se produce un error en tiempo de ejecuci\u00f3n y la aplicaci\u00f3n se rompe: 1 2 3 var respuestaEncuesta : String ? print ( respuestaEncuesta !) // Fatal error: Unexpectedly found nil while unwrapping an Optional value","title":"Opcionales"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#ligado-opcional","text":"Para comprobar si un valor opcional es nil podemos usar un if . Es obligado hacerlo si desconocemos el valor que nos llega. Por ejemplo, supongamos que la funci\u00f3n leerRespuesta() lee una respuesta del usuario y devuelve un String? . Para usar esta funci\u00f3n deber\u00edamos comprobar si el valor devuelto es distinto de nil : 1 2 3 4 5 let respuestaEncuesta = leerRespuesta () if respuestaEncuesta != nil { let respuesta = respuestaEncuesta ! print ( \"Respuesta: \" + respuesta ) } Como es muy habitual hacer lo anterior, en Swift es posible comprobar si un opcional tiene valor y asignar su valor a otra variable al mismo tiempo con una construcci\u00f3n llamada ligado opcional ( optional binding ): 1 2 3 4 let respuestaEncuesta = leerRespuesta () if let respuesta = respuestaEncuesta { print ( \"Respuesta: \" + respuesta ) } Podemos leer el c\u00f3digo anterior de la siguiente forma: \"Si el opcional respuestaEncuesta contiene un valor, define la constante respuesta con el valor contenido en el opcional\". Otro ejemplo, el m\u00e9todo first de un array devuelve un opcional que contiene nil si el array est\u00e1 vac\u00edo o el primer elemento del array en el caso en que exista. El siguiente c\u00f3digo utiliza un ligado opcional para implementar otra versi\u00f3n de la funci\u00f3n sumaValores : 1 2 3 4 5 6 7 8 9 10 11 func sumaValores ( _ valores : [ Int ]) -> Int { if let primero = valores . first { let resto = Array ( valores . dropFirst ()) return primero + sumaValores ( resto ) } else { return 0 } } print ( sumaValores ([ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 ])) // Imprime \"36\" Si tenemos varios opcionales es posible comprobar que todos ellos son distintos de nil usando varios let en el mismo if : 1 2 3 4 5 6 7 8 9 var x1 : Int ? = pedirNumUsuario () var x2 : Int ? = pedirNumUsuario () var x3 : Int ? = pedirNumUsuario () if let dato1 = x1 , let dato2 = x2 , let dato3 = x3 { let suma = dato1 + dato2 + dato3 print ( \"Ning\u00fan nil y la suma de todos los datos es: \\( suma ) \" ) } else { print ( \"Alg\u00fan dato del usuario es nil\" ) }","title":"Ligado opcional"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#operador-nil-coalescing","text":"El operador nil-coalescing ( ?? ) permite definir un valor por defecto en una asignaci\u00f3n si un opcional es nil. 1 2 3 4 5 6 let a : Int ? = nil let b : Int ? = 10 let x = a ?? - 1 let y = b ?? - 1 print ( \"Resultado: \\( x ) , \\( y ) \" ) // Imprime Resultado: -1, 10 En el ejemplo anterior, en la variable x se guardar\u00e1 el valor -1 y en la variable y el valor 10 .","title":"Operador nil-coalescing"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#encadenamiento-de-opcionales","text":"El encadenamiento de opcionales ( optional chaining ) permite llamar a un m\u00e9todo de una variable que contiene un opcional. Si la variable no es nil , se ejecuta el m\u00e9todo y se devuelve su valor como un opcional. Si la variable es nil se devuelve nil . 1 2 3 4 5 6 7 8 9 10 11 let nombre1 : String ? = \"Pedro\" let nombre2 : String ? = nil // Error: let str1 = nombre1.lowercased() // No podemos llamar al m\u00e9todo lowercased() del String // porque nombre es opcional y puede tener nil let str1 = nombre1 ?. lowercased () let str2 = nombre2 ?. lowercased () // str1: String? = \"pedro\" // str2: String? = nil","title":"Encadenamiento de opcionales"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#definicion-de-lista-con-opcionales","text":"Veamos como \u00faltimo ejemplo una segunda versi\u00f3n del enum Lista , en el que utilizamos un \u00fanico case , pero dando la posibilidad de que el resto de la lista sea nil haci\u00e9ndolo opcional. Definimos el enumerado y tambi\u00e9n la funci\u00f3n suma(lista:) : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 indirect enum Lista { case nodo ( Int , Lista ?) } func suma ( lista : Lista ) -> Int { switch lista { case let . nodo ( car , cdr ): if ( cdr == nil ) { return car } else { return car + suma ( lista : cdr !) } } } let z : Lista = . nodo ( 20 , . nodo ( 10 , nil )) print ( suma ( lista : z )) /// Devuelve 30","title":"Definici\u00f3n de Lista con opcionales"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#clausuras","text":"Ya hemos visto previamente que en Swift las funciones son objetos de primera clase del lenguaje y que es posible definir funciones y pasarlas como par\u00e1metro de otras funciones. Tambi\u00e9n es posible construir clausuras, funciones definidas en el \u00e1mbito de otras funcionas y devueltas como resultados. Veremos primero c\u00f3mo definir de forma compacta funciones que se pasan como par\u00e1metro de otras, utilizando expresiones de clausuras . Y despu\u00e9s veremos c\u00f3mo las clausuras definidas en el interior de otras funciones capturan las variables definidas en el \u00e1mbito de la funci\u00f3n principal.","title":"Clausuras"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#expresiones-de-clausuras","text":"Swift permite definir expresiones compactas con las que construir estas funciones que se pasan como par\u00e1metro de otras funciones. Se denominan expresiones de clausuras ( closure expressions ). Estas expresiones proporcionan optimizaciones de sintaxis para escribir clausuras de forma concisa y clara. Vamos a ver las distintas optimizaciones utilizando como ejemplo el m\u00e9todo sorted(by:) .","title":"Expresiones de clausuras"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#el-metodo-sortedby","text":"Tal y como hemos visto anteriormente la biblioteca st\u00e1ndar de Swift define un m\u00e9todo sorted() que devuelve los elementos ordenados de un Array . El array original no se modifica. La comparaci\u00f3n entre los elementos se realiza usando el comparador < . Veamos un ejemplo con un array de cadenas: 1 2 3 4 let estudiantes = [ \"Kofi\" , \"Abena\" , \"Peter\" , \"Kweku\" , \"Akosua\" ] let ordenados = estudiantes . sorted () print ( ordenados ) // Imprime \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\" Esta funci\u00f3n es similar a las que hay en muchos lenguajes. El \u00fanico aspecto funcional es que el array original no se modifica, sino que la ordenaci\u00f3n construye un nuevo array (existe una funci\u00f3n alternativa mutable que se denomina sort() ). Lo interesante relacionado con las clausuras est\u00e1 en la funci\u00f3n sorted(by:) . En esta funci\u00f3n se utiliza una clausura como par\u00e1metro para modificar la comparaci\u00f3n entre elementos y resultar en una ordenaci\u00f3n distinta. Es una de las distintas funciones de orden superior que se definen en las colecciones (m\u00e1s adelante veremos otras). El perfil de la funci\u00f3n sorted(by:) es: 1 func sorted(by areInIncreasingOrder: (Element, Element) -> Bool) El par\u00e1metro es una funci\u00f3n de dos par\u00e1metros (del tipo de los elementos del array) que devuelve un booleano indicando si el primer par\u00e1metro va antes que el segundo en el array ordenado. La clausura de ordenaci\u00f3n devuelve true si el primer valor deber\u00eda aparecer antes del segundo valor y false en otro caso. Por ejemplo, podr\u00edamos ordenar un array de cadenas en orden alfab\u00e9tico inverso. 1 2 3 4 5 6 7 func primeroMayor ( s1 : String , s2 : String ) -> Bool { return s1 > s2 } let estudiantes = [ \"Kofi\" , \"Abena\" , \"Peter\" , \"Kweku\" , \"Akosua\" ] let alreves = estudiantes . sorted ( by : primeroMayor ) print ( alreves ) // Imprime [\"Peter\", \"Kweku\", \"Kofi\", \"Akosua\", \"Abena\"] Si la primera cadena ( s1 ) es mayor que la segunda cadena ( s2 ), la funci\u00f3n primeroMayor(s1:s2:) devolver\u00e1 true , indicando que s1 deber\u00eda aparecer antes que s2 en el array ordenado. La ordenaci\u00f3n mayor o menor se refiere a la ordenaci\u00f3n alfab\u00e9tica, al estar tratando con caracteres. La versi\u00f3n anterior esta es una forma bastante complicada de escribir lo que b\u00e1sicamente es una funci\u00f3n de una \u00fanica expresi\u00f3n ( a > b ). En este ejemplo, ser\u00eda preferible escribir la clausura de ordenaci\u00f3n inline , utilizando la sintaxis de expresiones de clausuras.","title":"El m\u00e9todo sorted(by:)"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#sintaxis-de-las-expresiones-de-clausura","text":"La sintaxis de las expresiones de clausura tiene la siguiente forma general: 1 2 3 { ( <parametros>) -> <tipo devuelto> in <sentencias> } Si aplicamos esta sintaxis al ejemplo anterior: 1 2 3 let alreves = estudiantes . sorted ( by : { ( s1 : String , s2 : String ) -> Bool in return s1 > s2 }) Hay que hacer notar que la declaraci\u00f3n de los par\u00e1metros y el tipo devuelto por esta clausura inline es id\u00e9ntica a la declaraci\u00f3n de la funci\u00f3n primeroMayor(s1:s2:) . En ambos casos, se escribe como (s1: String, s2: String) -> Bool . Sin embargo, en la expresi\u00f3n de clausura los par\u00e1metros y el tipo devuelto se escribe dentro de las llaves, no fuera. El comienzo del cuerpo de la clausura se introduce por la palabra clave in . Esta palabra clave indica que la definici\u00f3n de los par\u00e1metros y del tipo devuelto por la clausura ha terminado, y que el cuerpo de la clausura va a comenzar. Como el cuerpo de la clausura es corto, podemos incluso escribirlo en una \u00fanica l\u00ednea: 1 let alreves = estudiantes . sorted ( by : { ( s1 : String , s2 : String ) -> Bool in return s1 > s2 } )","title":"Sintaxis de las expresiones de clausura"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#inferencia-del-tipo-por-el-contexto","text":"Como la clausura de ordenaci\u00f3n se pasa como argumento de un m\u00e9todo, Swift puede inferir los tipos de sus par\u00e1metros y el tipo del valor que devuelve. El m\u00e9todo sorted(by:) se llama sobre un array de cadenas, por lo que su argumento debe ser una funci\u00f3n del tipo (String, String) -> Bool . Esto significa que los tipos (String, String) y Bool no necesitan escribirse como parte de la definici\u00f3n de la expresi\u00f3n de la clausura. Debido a que todos los tipos pueden ser inferidos, la flecha del tipo devuelto y los par\u00e9ntesis alrededor de los nombres de los par\u00e1metros tambi\u00e9n pueden omitirse: 1 let alreves = estudiantes . sorted ( by : { s1 , s2 in return s1 > s2 } )","title":"Inferencia del tipo por el contexto"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#devoluciones-implicitas-en-clausuras-con-una-unica-expresion","text":"En clausuras con una \u00fanica expresi\u00f3n podemos omitir tambi\u00e9n la palabra clave return : 1 let alreves = estudiantes . sorted ( by : { s1 , s2 in s1 > s2 } )","title":"Devoluciones impl\u00edcitas en clausuras con una \u00fanica expresi\u00f3n"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#abreviaturas-en-los-nombres-de-los-argumentos","text":"Swift proporciona autom\u00e1ticamente abreviaturas para los nombres de argumentos de las clausuras inline que pueden usarse para referirse a los valores de los argumentos de la clausura usando los nombres $0 , $1 , $2 , etc. Si se usa estos argumentos abreviados, se puede omitir la definici\u00f3n de la lista de los argumentos: 1 let alreves = estudiantes . sorted ( by : { $0 > $1 } )","title":"Abreviaturas en los nombres de los argumentos"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#funciones-operadoras","text":"Incluso hay una forma aun m\u00e1s corta de escribir la expresi\u00f3n de clausura anterior. Swift define una implementaci\u00f3n espec\u00edfica de cadenas del operador mayor-que ( > ) como una funci\u00f3n que tiene dos par\u00e1metros de tipo String y devuelve un Bool . Esto es exactamente lo que necesita el m\u00e9todo sorted(by:) . Podemos, por tanto, pasar simplemente este operador mayor-que, y Swift inferir\u00e1 que queremos usar el espec\u00edfico de cadenas: 1 let alreves = estudiantes . sorted ( by : > )","title":"Funciones operadoras"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#clausuras-al-final","text":"Si necesitamos pasar una expresi\u00f3n de clausura a una funci\u00f3n como el argumento final de la clausura y la expresi\u00f3n es larga, puede ser \u00fatil escribirla en su lugar como una clausura al final ( trailing closure ). Una clausura al final es una expresi\u00f3n de clausura que se escribe fuera de (y despu\u00e9s de) los par\u00e9ntesis de la funci\u00f3n a la que se le pasa como par\u00e1metro: 1 let alreves = estudiantes . sorted () { $0 > $1 } Cuando se proporciona una expresi\u00f3n de clausura como \u00fanico argumento de una funci\u00f3n o m\u00e9todo y se pasa como una clausura al final, no es necesario escribir los par\u00e9ntesis tras el nombre de la funci\u00f3n: 1 let alreves = estudiantes . sorted { $0 > $1 }","title":"Clausuras al final"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#valores-capturados","text":"Una clausura puede capturar constantes y variables del contexto en el que se define. La clausura puede referirse y modificar esos valores dentro de su cuerpo, incluso si ya no existe el \u00e1mbito ( scope ) original en el que se definieron estas constantes y variables. En Swift, la forma m\u00e1s sencilla de una clausura que captura valores es una funci\u00f3n anidada ( nested function ) escrita en el cuerpo de otra funci\u00f3n. Una funci\u00f3n anidada puede capturar cualquiera de los argumentos de su funci\u00f3n exterior y tambi\u00e9n puede capturar cualquier constante y variable definida dentro de la funci\u00f3n exterior. Veamos un ejemplo similar al que vimos en Scheme. La funci\u00f3n construyeIncrementador contiene una funci\u00f3n anidada llamada incrementador . Esta funci\u00f3n captura dos valores de su contexto: totalAcumulado y cantidad . Despu\u00e9s de capturar estos valores, incrementador es devuelto por construyeIncrementador como una clausura que incrementa totalAcumulado en cantidad cada vez que se llama. 1 2 3 4 5 6 7 8 func construyeIncrementador ( incremento cantidad : Int ) -> () -> Int { var totalAcumulado = 0 func incrementador () -> Int { totalAcumulado += cantidad return totalAcumulado } return incrementador } El tipo devuelto de construyeIncrementador es () -> Int . Esto significa que devuelve una funci\u00f3n que no tiene par\u00e1metros y que devuelve un Int cada vez que es llamada. La funci\u00f3n construyeIncrementador(incremento:) tiene un \u00fanico par\u00e1metro Int con nombre externo incremento y nombre local cantidad . El argumento pasado a este par\u00e1metro especifica cu\u00e1nto ser\u00e1 incrementado totalAcumulado cada vez que se llama a la funci\u00f3n incrementador devuelta. La funci\u00f3n construyeIncrementador define una funci\u00f3n anidada llamada incrementador , que realiza el incremento real. Esta funci\u00f3n simplemente a\u00f1ade cantidad a totalAcumulado , y devuelve el resultado. Si la consideramos aislada, la funci\u00f3n anidada incrementador() podr\u00eda parecer extra\u00f1a: 1 2 3 4 func incrementador () -> Int { totalAcumulado += cantidad return totalAcumulado } La funci\u00f3n no tiene ning\u00fan par\u00e1metro, y sin embargo se refiere a totalAcumulado y a cantidad en su cuerpo. Lo puede hacer porque ha capturado una referencia a estas variables de la funci\u00f3n de alrededor y las usa en su propio cuerpo. Al capturar estas referencias las variables totalAcumulado y cantidad no desaparecen cuando termina la llamada a construyeIncrementador . Estas variables tambi\u00e9n estar\u00e1n disponibles la pr\u00f3xima vez que se llame la funci\u00f3n incrementador . Aqu\u00ed hay un ejemplo de construyeIncrementador en acci\u00f3n: 1 let incrementaDiez = construyeIncrementador ( incremento : 10 ) Este ejemplo define una constante llamada incrementaDiez para referenciar la funci\u00f3n incrementador que devuelve construyeIncrementador . Esta funci\u00f3n a\u00f1ade 10 a la variable totalAcumulado cada vez que se es llamada. Si llamamos a la funci\u00f3n m\u00e1s de una vez podemos comprobar su conducta en acci\u00f3n: 1 2 3 4 5 6 incrementaDiez () // devuelve 10 incrementaDiez () // devuelve 20 incrementaDiez () // devuelve 30 Si creamos un segundo incrementador, tendr\u00e1 sus propias referencias a un variable totalAcumulado nueva, distinta de la anterior: 1 2 3 let incrementaSiete = construyeIncrementador ( incremento : 7 ) incrementaSiete () // devuelve 7 Si llamamos a la funci\u00f3n incrementador original ( incrementaDiez ) vemos que sigue incrementando su propia variable totalAcumulado y que no se ve afectada por la variable capturada por incrementaSiete : 1 2 incrementaDiez () // devuelve 40","title":"Valores capturados"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#clausuras-con-expresiones-de-clausura","text":"En el ejemplo anterior hemos usado una definici\u00f3n interna de una funci\u00f3n para definir la clausura que se devuelve. Lo hemos hecho por claridad, pero no es necesario. Es posible escribir un c\u00f3digo m\u00e1s compacto usando expresiones de clausura. Por ejemplo, la funci\u00f3n construyeSumador() vista en el apartado \"Funciones que devuelven otras funciones\": 1 2 3 4 func construyeSumador10 () -> ( Int ) -> Int { func suma10 ( x : Int ) -> Int { return x + 10 } return suma10 } Una versi\u00f3n de esta misma funci\u00f3n usando una expresi\u00f3n de clausura es la siguiente: 1 2 3 4 5 6 7 func construyeSumador10 () -> ( Int ) -> Int { return { $0 + 10 } } var f = construyeSumador10 () print ( f ( 20 )) // Imprime \"30\" Y lo mismo con la funci\u00f3n constryeIncrementador(incremento:) vista en el apartado anterior: 1 2 3 4 5 6 7 8 func construyeIncrementador ( incremento cantidad : Int ) -> () -> Int { var totalAcumulado = 0 func incrementador () -> Int { totalAcumulado += cantidad return totalAcumulado } return incrementador } La versi\u00f3n con una expresi\u00f3n de clausura: 1 2 3 4 5 6 7 8 9 10 11 func construyeIncrementador ( incremento cantidad : Int ) -> () -> Int { var totalAcumulado = 0 return { totalAcumulado += cantidad return totalAcumulado } } let incrementaDiez = construyeIncrementador ( incremento : 10 ) print ( incrementaDiez ()) // Imprime \"10\" print ( incrementaDiez ()) // Imprime \"20\"","title":"Clausuras con expresiones de clausura"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#las-clausuras-son-tipos-de-referencia","text":"En el ejemplo anterior, incrementaSiete e incrementaDiez son constantes, pero las clausuras a las que estas constantes se refieren pueden incrementar la variable totalAcumulado que han capturado. Esto es porque funciones y clausuras son tipos referencia. Siempre que asignamos una funci\u00f3n o una clausura a una constante o una variable, estamos realmente estableciendo que la constante o variable es una referencia a la funci\u00f3n o la clausura. En el ejemplo anterior, es la elecci\u00f3n de la clausura a la que referencia incrementaDiez la que es constante, no los contenidos propios de la clausura. Esto tambi\u00e9n significa que si asignamos una clausura a dos constantes o variables distintas, ambas constantes o variables se referir\u00e1n a la misma clausura: 1 2 3 let tambienIncrementaDiez = incrementaDiez tambienIncrementaDiez () // devuelve 50","title":"Las clausuras son tipos de referencia"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#funciones-de-orden-superior","text":"Una de las caracter\u00edsticas funcionales que m\u00e1s hemos usado para trabajar con listas en Scheme son las funciones de orden superior como map , filter o fold-right . Swift tiene definidas funciones equivalentes para trabajar con colecciones. Se denominan map , filter y reduce . Todas ellas aceptan expresiones de clausura como argumento.","title":"Funciones de orden superior"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#map","text":"El m\u00e9todo map se define en el protocolo CollectionType y es adoptado por m\u00faltiples estructuras como Array , Dictionary , Set o String.CharacterView . El perfil del m\u00e9todo map es el siguiente: 1 func map < T >( _ transform : ( Element ) -> T ) -> [ T ] Se trata de un m\u00e9todo gen\u00e9rico (lo veremos m\u00e1s adelante) que recibe como par\u00e1metro una funci\u00f3n unaria (funci\u00f3n de transformaci\u00f3n) del tipo de los elementos de la colecci\u00f3n y que devuelve otro elemento (puede ser del mismo o de distinto tipo que los elementos de la colecci\u00f3n). Devuelve un array que contiene el resultado de aplicar la funci\u00f3n de transformaci\u00f3n a cada elemento del array original. Por ejemplo: 1 2 3 let numeros = [ Int ]( 0. .. 5 ) numeros . map { $0 * $0 } // devuelve [0, 1, 4, 9, 16, 25] Otro ejemplo, en el que usamos map para implementar la funci\u00f3n sumaParejas(parejas: [(Int, Int)]) -> [Int] que devuelve recibe el array parejas de tuplas de dos enteros y devuelve un array con el resultado de sumar los dos elementos de cada pareja: 1 2 3 4 5 6 func suma ( parejas : [( Int , Int )]) -> [ Int ] { return parejas . map ({( pareja : ( Int , Int )) -> Int in return pareja . 0 + pareja . 1 }) } suma ( parejas :[( 1 , 1 ), ( 2 , 2 ), ( 3 , 3 ), ( 4 , 4 )]) // devuelve [2, 4, 6, 8] Podemos usar en el cuerpo de la expresi\u00f3n de clausura de map una variable capturada. Por ejemplo en la siguiente funci\u00f3n incrementaValores(_:con:) que suma con a todos los n\u00fameros de un array que se le pasa por par\u00e1metro: 1 2 3 4 5 6 func incrementa ( valores : [ Int ], con : Int ) -> [ Int ] { return valores . map ({( x : Int ) -> Int in return x + con }) } incrementa ( valores :[ 10 , 20 , 30 ], con : 5 ) // devuelve [15, 25, 35] La versi\u00f3n abreviada de la expresi\u00f3n de clausura es: 1 2 3 4 5 func incrementa ( valores : [ Int ], con inc : Int ) -> [ Int ] { return valores . map { $0 + inc } } incrementa ( valores : [ 10 , 20 , 30 ], con : 5 ) // devuelve [15, 25, 35]","title":"Map"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#filter","text":"La funci\u00f3n filter es tambi\u00e9n igual que la definida en Scheme. Su perfil es: 1 func filter ( _ isIncluded : ( Element ) -> Bool ) -> [ Element ] Recibe una clausura de un argumento que devuelve un booleano. La funci\u00f3n devuelve un array con los elementos de la colecci\u00f3n para los que la clausura devuelve true . Ejemplo: 1 2 3 let numeros = [ Int ]( 0. .. 10 ) numeros . filter { $0 % 2 == 0 } // devuelve [0, 2, 4, 6, 8, 10]","title":"Filter"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#reduce","text":"Similar al fold de Scheme. Su perfil es el siguiente: 1 func reduce < Result >( _ initialResult : Result , _ nextPartialResult : ( Result , Element ) -> Result ) -> Result Es una funci\u00f3n gen\u00e9rica que devuelve un valor de un tipo gen\u00e9rico (el tipo del resultado que se construye en la funci\u00f3n). Recibe como par\u00e1metro un valor inicial y una funci\u00f3n de plegado que se aplica al resultado anterior y al elemento de la colecci\u00f3n, devolviendo un resultado. El resultado final es el resultado de aplicar la funci\u00f3n de plegado a todos los elementos de la colecci\u00f3n, empezando por el valor inicial. Por ejemplo, podemos usar reduce para sumar todos los n\u00fameros de un array: 1 2 let numeros = [ Int ]( 0. .. 10 ) numeros . reduce ( 0 , + ) La funci\u00f3n combina los elementos de la colecci\u00f3n usando la funci\u00f3n de combinaci\u00f3n que se pasa como par\u00e1metro. La funci\u00f3n que se pasa como par\u00e1metro recibe dos par\u00e1metros: el primero es el resultado de la combinaci\u00f3n y el segundo se coge de la colecci\u00f3n. Por ejemplo, el siguiente c\u00f3digo usa reduce para sumar la longitud de todas las cadenas de un array: 1 2 3 4 let cadenas = [ \"Patatas\" , \"Arroz\" , \"Huevos\" ] cadenas . reduce ( 0 , {( i : Int , c : String ) -> Int in c . count + i }) // devuelve 18 Es posible simplificar la notaci\u00f3n anterior: 1 cadenas . reduce ( 0 , { $1 . count + $0 }) Tambi\u00e9n se puede utilizar la notaci\u00f3n de clausura al final: 1 cadenas . reduce ( 0 ) { $1 . count + $0 } La combinaci\u00f3n se hace de izquierda a derecha: 1 2 3 4 let cadenas = [ \"Patatas\" , \"Arroz\" , \"Huevos\" ] let cadenas = [ \"Patatas\" , \"Arroz\" , \"Huevos\" ] print ( cadenas . reduce ( \"*\" , { $0 + \"-\" + $1 })) // Imprime \"*-Patatas-Arroz-Huevos\" El primer argumento de la funci\u00f3n de plegado ( $0 ) es el resultado anterior (empieza por \"*\" ) y el segundo argumento ( $1 ) se coge del array de cadenas.","title":"Reduce"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#combinacion-de-funciones-de-orden-superior","text":"Cuando el resultado de aplicar una funci\u00f3n de orden superior a una colecci\u00f3n es otra colecci\u00f3n es posible aplicar otra funci\u00f3n de orden superior a este resultado. Por ejemplo, la siguiente sentencia devuelve todos los n\u00fameros pares del array inicial elevados al cuadrado: 1 2 3 let numeros = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] numeros . filter { $0 % 2 == 0 }. map { $0 * $0 } // Devuelve el array [4,16,36,64,100] Y la siguiente devuelve la suma n\u00fameros mayores de 100: 1 2 3 let numeros = [ 103 , 2 , 330 , 42 , 532 , 6 , 125 ] numeros . filter { $0 >= 100 }. reduce ( 0 , + ) // Devuelve 1090","title":"Combinaci\u00f3n de funciones de orden superior"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#genericos","text":"Empecemos con un ejemplo sencillo. Supongamos la siguiente funci\u00f3n intercambia(_:) que recibe una tupla (Int, String) y devuelve una tupla (String, Int) con los valores intercambiados. 1 2 3 4 5 6 7 8 func intercambia ( _ tupla : ( Int , String )) -> ( String , Int ) { let tuplaNueva = ( tupla . 1 , tupla . 0 ) return tuplaNueva } let tupla = ( 10 , \"Hola\" ) intercambia ( tupla ) // devuelve (\"Hola\", 10) La funci\u00f3n es interesante, pero s\u00f3lo recibe tuplas cuya primera componente es un Int y su segunda componente es un String . Supongamos que queremos hacer la misma funci\u00f3n para intercambiar elementos de una tupla (Int, Int) . Tendr\u00edamos que usar el mismo c\u00f3digo, pero cambiando los tipos: 1 2 3 4 5 6 7 8 func intercambia ( _ tupla : ( Int , Int )) -> ( Int , Int ) { let tuplaNueva = ( tupla . 1 , tupla . 0 ) return tuplaNueva } let tupla = ( 10 , 20 ) intercambia ( tupla ) // devuelve (20, 10) El c\u00f3digo es el mismo, lo \u00fanico distinto son los tipos. \u00bfPodr\u00edamos generalizar las funciones anteriores para hacer que el c\u00f3digo pueda trabajar con cualquier tipo? La respuesta es s\u00ed, usando funci\u00f3n gen\u00e9rica : 1 2 3 4 func intercambia < A , B >( _ tupla : ( A , B )) -> ( B , A ) { let tuplaNueva = ( tupla . 1 , tupla . 0 ) return tuplaNueva } El cuerpo de la funci\u00f3n es id\u00e9ntico a la funci\u00f3n anterior. La diferencia es que en la versi\u00f3n gen\u00e9rica se usan placeholders (los s\u00edmbolos A y B ) en lugar de tipos concretos. Son tipos gen\u00e9ricos, que se definen usando un identificador entre s\u00edmbolos de < y > . Los tipos reales que se van a usar en la funci\u00f3n se determinan en cada invocaci\u00f3n a la funci\u00f3n, dependiendo del tipo del par\u00e1metro que se utiliza en la llamada: 1 2 3 4 5 6 7 8 9 let tupla = ( 10 , \"Hola\" ) intercambia ( tupla ) // devuelve (\"Hola\", 10) let tupla2 = ( 10 , 20 ) intercambia ( tupla2 ) // devuelve (10, 20) let tupla3 = ( true , 10.5 ) intercambia ( tupla3 ) // devuelve (10.5, true) En el primer ejemplo, los tipos A y B se infieren como Int y String . En el segundo ejemplo como Int e Int . Y en el tercero como Bool y Double . Los tipos gen\u00e9ricos se pueden usar en la definici\u00f3n de todos los elementos de Swift: funciones, enums, estructuras, clases, protocolos o extensiones. Terminamos con un ejemplo en el que incluimos muchos conceptos vistos en este tema. Se trata de la implementaci\u00f3n en Swift de listas al estilo Scheme, con las funciones car , cdr y vacia usando un enum recursivo con un tipo gen\u00e9rico que permite generalizar el tipo de elementos de la lista. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 indirect enum Lista < T > { case vacia case nodo ( T , Lista < T >) } func car < T >( _ lista : Lista < T >) -> T ? { switch lista { case let . nodo ( primero , _ ): return primero case . vacia : return nil } } func cdr < T >( _ lista : Lista < T >) -> Lista < T >? { switch lista { case let . nodo ( _ , resto ): return resto case . vacia : return nil } } func vacia < T >( _ lista : Lista < T >) -> Bool { switch lista { case . vacia : return true default : return false } } let lista : Lista = . nodo ( 20 , . nodo ( 30 , . nodo ( 40 , . vacia ))) print ( car ( lista ) ! ) // Imprime 20 print ( car ( cdr ( lista ) ! ) ! ) // Imprime 30 print ( car ( cdr ( cdr ( lista ) ! ) ! ) ! ) // Imprime 40 print ( vacia ( cdr ( cdr ( cdr ( lista ) ! ) ! ) ! )) // Imprime true","title":"Gen\u00e9ricos"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#bibliografia","text":"Swift Language Guide The Basics Collection Types Functions Closures Enumerations Generics Biblioteca est\u00e1ndar de Swift Lenguajes y Paradigmas de Programaci\u00f3n, curso 2018\u201319 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Domingo Gallardo, Cristina Pomares, Antonio Bot\u00eda, Francisco Mart\u00ednez","title":"Bibliograf\u00eda"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html","text":"Tema 6: Programaci\u00f3n Orientada a Objetos con Swift \u00b6 M\u00e1s conceptos sobre clausuras \u00b6 Repaso de clausuras \u00b6 Ya vimos en el tema anterior que las clausuras en Swift son bloques de c\u00f3digo con funcionalidades que se pueden pasar de un sitio a otro en nuestro programa. Son muy similares a las expresiones lambda de Scheme o de Java 8 o a los bloques de Objective-C. Una clausura puede capturar o almacenar referencias a cualquier constante o variable del contexto o \u00e1mbito dentro de la cual han sido definidas. Se pueden definir clausuras en Swift de las siguientes formas: Funciones anidadas que pueden capturar valores de la funci\u00f3n englobante: 1 2 3 4 5 6 7 8 9 10 11 12 func construyeFunc () -> () -> Int { var x = 0 func funcion () -> Int { x = x + 1 return x } return funcion } let f = construyeFunc () f () // -> 1 f () // -> 2 La funci\u00f3n devuelta por construyeFunc() tambi\u00e9n se puede formular como una expresi\u00f3n de clausura: 1 2 3 4 5 6 7 func construyeFunc () -> () -> Int { var x = 0 return { x = x + 1 return x } } En el siguiente ejemplo vemos claramente que la funci\u00f3n captura las variables definidas en el \u00e1mbito en el que se cre\u00f3. En el caso anterior la clausura devuelta captura la variable x con el valor 0. 1 2 3 4 5 6 7 func usaFunc ( _ f : () -> Int ) -> Int { var x = 4 return f () } let f = construyeFunc () usaFunc ( f ) // -> 1 El valor devuelto por usaFunc en el resultado de la invocaci\u00f3n a f() en su segunda l\u00ednea de c\u00f3digo. Y el valor de x usado por la clausura f es el capturado en el momento de su creaci\u00f3n (el valor x=0 definido en la primera l\u00ednea de construyeFunc ). Funciones an\u00f3nimas que pueden capturar valores del contexto que las rodean: 1 2 var x = 100 usaFunc { return x + 10 } // -> 110 En el ejemplo anterior la expresi\u00f3n de clausura se define en el \u00e1mbito global donde la x toma el valor 100. Ese valor queda capturado y es el que se usa en la evaluaci\u00f3n de la funci\u00f3n. Por tanto, en el contexto donde se eval\u00faa esa clausura (dentro del cuerpo de la funcio\u00f3n usaFunc ), la x que toma es la capturada y no la definida en el cuerpo de usaFunc . Clausuras escapadas \u00b6 Se dice que una clausura escapa de una funci\u00f3n cuando la funci\u00f3n recibe una funci\u00f3n o clausura como par\u00e1metro que se llama despu\u00e9s de que la funci\u00f3n finalice su ejecuci\u00f3n. Por ejemplo, definimos un array global de tipo funci\u00f3n: 1 var array : [() -> Int ] = [] Definimos una funci\u00f3n que recibe una clausura como par\u00e1metro, pero no se llama dentro de la funci\u00f3n que la recibe, s\u00f3lo la almacena en el array. Al no ser llamada dentro de la funci\u00f3n, hay que ponerle el atributo @escaping delante del tipo del par\u00e1metro para que Swift permita que sea llamada posteriormente fuera de la funci\u00f3n que la recibe. Si no lo ponemos, el compilador da un error: 1 2 3 4 5 func usaClausura ( _ f : @ escaping () -> Int ) -> Void { array . append ( f ) } usaClausura { return 4 } Se llama posteriormente, fuera de la funci\u00f3n: 1 array [ 0 ]() //-> 4 Autoclausuras \u00b6 Una autoclausura permite crear autom\u00e1ticamente una funci\u00f3n en tiempo de ejecuci\u00f3n sin necesidad de utilizar la sintaxis de las expresiones de clausura. Se puede ver la autoclausura como una forma de retardar la evaluaci\u00f3n, porque esa expresi\u00f3n no se evaluar\u00e1 hasta que se llame a la clausura. Retardar la evaluaci\u00f3n es \u00fatil con trozos de c\u00f3digo que provocan efectos laterales o son costosos computacionalmente, ya que nos permiten controlar el momento de su evaluaci\u00f3n. Por ejemplo, podemos modificar la funci\u00f3n anterior usaFunc a\u00f1adiendo la anotaci\u00f3n @autoclosure antes del tipo del par\u00e1metro clausura: 1 2 3 4 func usaFunc ( _ f : @autoclosure () -> Int ) -> Int { var x = 4 return f () } Al declararlo de esta forma, se puede llamar a usaFunc escribiendo como par\u00e1metro una sentencia que el compilador convierte a clausura: 1 2 var x = 100 usaFunc ( x + 10 ) La expresi\u00f3n x + 10 se considera retardada : se construye una clausura con ella y su evaluaci\u00f3n se realiza dentro de usaFunc . Otro ejemplo en el que podemos comprobar el orden de evaluaci\u00f3n: 1 2 3 4 5 6 7 8 9 10 11 12 func printTest2 ( _ result : @autoclosure () -> Void ) { print ( \"Antes\" ) result () print ( \"Despu\u00e9s\" ) } printTest2 ( print ( \"Hola\" )) // Imprime: // Antes // Hola // Despu\u00e9s La sentencia print(\"Hola\") se pasa como una autoclausura, por lo que el compilador crea autom\u00e1ticamente una clausura con ella sin tener nosotros que escribir la expresi\u00f3n de clausura. Introducci\u00f3n, historia y caracter\u00edsticas de la Programaci\u00f3n Orientada a Objetos \u00b6 Nacimiento \u00b6 La Programaci\u00f3n Orientada a Objetos es un paradigma de programaci\u00f3n que explota en los 80 pero nace a partir de ideas a finales de los 60 y 70 Primer lenguaje con las ideas fundamentales de POO: Simula Smalltalk (1980) como lenguaje paradigm\u00e1tica de POO Alan Kay es el creador del t\u00e9rmino \u201cObject-Oriented\u201d y una de las figuras fundamentales de la historia de la inform\u00e1tica moderna. Trabaj\u00f3 en Xerox Park y desarroll\u00f3 all\u00ed ideas que han sido clave para la inform\u00e1tica personal (como el Dynabook, precursor de tablets y dispositivos m\u00f3viles y el lenguajes de programaci\u00f3n Smalltalk) Art\u00edculo de Alan Kay: \u201cThe Early History of Smalltalk\u201d , ACM SIGPLAN, March 1993 Alan Kay \u00b6 \u201cI invented the term Object-Oriented and I can tell you I did not have C++ in mind.\u201d \u201cSmalltalk is not only NOT its syntax or the class library, it is not even about classes. I'm sorry that I long ago coined the term objects for this topic because it gets many people to focus on the lesser idea. The big idea is messaging.\u201d \u201cSmalltalk's design\u2013and existence\u2013is due to the insight that everything we can describe can be represented by the recursive composition of a single kind of behavioral building block that hides its combination of state and process inside itself and can be dealt with only through the exchange of messages.\u201d \u00bfInteresados en Smalltalk? \u00b6 Visitar: http://www.squeak.org/ http://swiki.agro.uba.ar/small_land http://www.squeakland.org Lenguajes OO \u00b6 Smalltalk, Java, Scala, Ruby, Python, C#, C++, Swift, ... Del paradigma imperativo al OO \u00b6 Programaci\u00f3n procedural: estado abstracto (tipos de datos y barrera de abstracci\u00f3n) + funciones Siguiente paso: agrupar estado y funciones en una \u00fanica entidad Los objetos son estas entidades Caracter\u00edsticas de la POO \u00b6 Objetos (creados/instanciados en tiempo de ejecuci\u00f3n) y clases (plantillas est\u00e1ticas/tiempo de compilaci\u00f3n) Los objetos agrupan estado y conducta (m\u00e9todos) Los m\u00e9todos se invocan mediante mensajes Dispatch din\u00e1mico : cuando una operaci\u00f3n es invocada sobre un objeto, el propio objeto determina qu\u00e9 c\u00f3digo se ejecuta. Dos objetos con la misma interfaz pueden tener implementaciones distintas. Herencia: las clases se pueden definir utilizando otras clases como plantillas y modificando sus m\u00e9todos y/o variables de instancia. Clases y objetos \u00b6 Objeto: Un objeto contiene un estado (propiedades, atributos o variables de instancia) y un conjunto de funciones (m\u00e9todos) que se ejecutan en el \u00e1mbito del objeto e implementan las funcionalidades soportadas Al ejecutar un m\u00e9todo, el objeto modifica su estado Pedimos a un objeto que ejecute un m\u00e9todo Clase: Una clase es la plantilla que sirve para definir los objetos En una clase se define los elementos que componen el objeto (sus atributos o campos) y sus m\u00e9todos En algunos lenguajes se pueden definir tambi\u00e9n en las clases variables (variables de clase) compartidas por todos los objetos de esa clase Lenguajes POO din\u00e1micos vs. est\u00e1ticos \u00b6 Dos tendencias: Lenguajes din\u00e1micos : muchas caracter\u00edsticas del programa se obtienen en tiempo de ejecuci\u00f3n Mayor flexibilidad y generalidad del c\u00f3digo Dispatch din\u00e1mico Reflexi\u00f3n (posibilidad de consultar caracter\u00edsticas de la instancia (nombres de m\u00e9todos, propiedades, etc.) en tiempo de ejecuci\u00f3n) Ejemplos: Smalltalk, Ruby, Python, JavaScript, Java (en menor medida) Lenguajes est\u00e1ticos : la mayor\u00eda de caracter\u00edsticas del programa se obtienen en tiempo de compilaci\u00f3n Mayor eficiencia Se conoce a priori el tipo de la mayor parte de instancias del programa Fuertemente tipeado Ejemplos: C++, Swift Vamos a detallar a continuaci\u00f3n las caracter\u00edsticas de Programaci\u00f3n Orientada a Objetos de Swift . Para tener una introducci\u00f3n r\u00e1pida puedes empezar leyendo los \u00faltimos apartados del seminario de Swift (los apartados Objetos, clases y estructuras , Protocolos y extensiones y Gen\u00e9ricos ). Clases y estructuras \u00b6 En el caso de Swift, las clases y las estructuras son muchas m\u00e1s cercanas en funcionalidad que en otros lenguajes, como C o C++, y tienen muchas caracter\u00edsticas comunes. Muchas caracter\u00edsticas de las instancias de una clase se pueden aplicar tambi\u00e9n a las instancias de una estructura. Por eso en Swift se suele hablar de instancias (un t\u00e9rmino m\u00e1s general) en lugar de objetos . Las clases y las estructuras en Swift tienen muchas cosas en com\u00fan. Ambos pueden: Definir propiedades y almacenar valores Definir m\u00e9todos para proporcionar funcionalidad Definir sub\u00edndices para proporcionar acceso a sus valores usando una sintaxis de sub\u00edndice Definir inicializadores para configurar el estado inicial Ser extendidas para expandir su funcionalidad m\u00e1s all\u00e1 de una implementaci\u00f3n por defecto Ajustarse a un protocolo Las clases tienen caracter\u00edsticas adicionales que no tienen las estructuras: Mediante la herencia una clase puede heredar las caracter\u00edsticas de otra El casting de tipos permite comprobar e interpretar el tipo de una instancia de una clase en tiempo de ejecuci\u00f3n Los deinicializadores permiten a una instancia de una clase liberar los recursos que ha asignado Mediante el conteo de referencias se permite que exista m\u00e1s de una referencia a una instancia de una clase Definici\u00f3n \u00b6 1 2 3 4 5 6 class UnaClase { // definici\u00f3n de clase } struct UnaEstructura { // definici\u00f3n de una estructura } 1 2 3 4 5 6 7 8 9 10 11 12 struct CoordsPantalla { var posX = 0 var posY = 0 } class Ventana { var esquina = CoordsPantalla () var altura = 0 var anchura = 0 var visible = true var etiqueta : String ? } El ejemplo define una nueva estructura llamada CoordsPantalla , que describe una coordenada de pantalla con posiciones basadas en p\u00edxeles. La estructura tiene dos propiedades almacenadas llamadas posX y posY . Las propiedades son constantes o variables que se almacenan en la instancia de la clase o de la estructura. El compilador infiere que estas dos propiedades son Int al inicializarlas a los valores iniciales de 0. El ejemplo tambi\u00e9n define una nueva clase llamada Ventana que describe una ventana en una pantalla. Esta clase tiene cinco propiedades variables. La primera, esquina , se inicializa con una instancia nueva de una estructura CoorsPantalla y se infiere que es de tipo CoordsPantalla . Representa la posici\u00f3n superior izquierda de la pantalla. Las propiedades altura y anchura representan el n\u00famero de p\u00edxeles de las dimensiones de la pantalla. Se inicializan a 0. La propiedad visible es un Bool que indica si la ventana es visible en pantalla. Por ejemplo, una ventana que est\u00e9 minimizada no ser\u00e1 visible. Por \u00faltimo, etiqueta representa el nombre que aparece en la parte superior de la ventana. Es un String opcional que se inicializa a nil porque no se le asigna un valor inicial. Instancias de clases y estructuras \u00b6 La definici\u00f3n de las estructuras y las clases \u00fanicamente definen sus aspectos generales. Para describir una configuraci\u00f3n espec\u00edfica (una resoluci\u00f3n o un modo de v\u00eddeo concreto) es necesario crear una instancia de una estructura o una clase. La sintaxis para crear ambas es similar: 1 2 var unasCoordsPantalla = CoordsPantalla () var unaVentana = Ventana () La forma m\u00e1s sencilla de inicializaci\u00f3n es la anterior. Se utiliza el nombre del tipo de la clase o estructura seguidos de par\u00e9ntesis vac\u00edos. Esto crea una nueva instancia de una clase o estructura, con sus propiedades inicializadas a los valores por defecto definidos en la declaraci\u00f3n de las propiedades. Swift proporciona este inicializador por defecto para clases y estructuras, siempre que no se defina alg\u00fan inicializador expl\u00edcito. M\u00e1s adelante comentaremos c\u00f3mo definir estos inicializadores expl\u00edcitos. En el caso de la instancia unasCoordsPantalla los valores a los que se han inicializado sus propiedades son: 1 2 unasCoordsPantalla . posX // 0 unasCoordsPantalla . posY // 0 Las propiedades de la instancia unaVentana son: 1 2 3 4 5 unaVentana . esquina // CoordsPantalla con posX = 0 y posY = 0 unaVentana . altura // 0 unaVentana . anchura // 0 unaVentana . visible // true unaVentana . etiqueta // nil Todas las propiedades de una instancia deben estar definidas despu\u00e9s de haberse inicializado, a no ser que la propiedad se un opcional. Acceso a propiedades \u00b6 Se puede acceder y modificar las propiedades usando la sintaxis de punto : 1 2 3 4 5 // Accedemos a la propiedad coords . posX // Devuelve 0 // Actualizamos la propiedad coords . posX = 100 ventana . esquina . posY = 100 Inicializaci\u00f3n de las estructuras por sus propiedades \u00b6 Si en las estructuras no se se definen inicializadores expl\u00edcitos (veremos m\u00e1s adelante c\u00f3mo hacerlo) podemos utilizar un inicializador memberwise (de todas las propiedades) en el que hay que proporcionar los valores de todas sus propiedades. En las clases no existen los inicializadores memberwise , s\u00f3lo en las estructuras. 1 var coords = CoordsPantalla ( posX : 200 , posY : 400 ) Es necesario inicializar todas las propiedades. Si no, el compilador da un error: 1 2 var coords2 = CoordsPantalla ( posX : 200 ) // error Estructuras y enumeraciones son tipos valor \u00b6 Un tipo valor es un tipo cuyo valor se copia cuando se asigna a una variable o constante, o cuando se pasa a una funci\u00f3n. Todos los tipos b\u00e1sicos de Swift -enteros, n\u00fameros en punto flotante, cadenas, arrays y diccionarios- son tipos valor y se implementan como estructuras. Las estructuras y las enumeraciones son tipos valor en Swift. 1 2 3 4 var coords1 = CoordsPantalla ( posX : 600 , posY : 600 ) var coords2 = coords1 coords2 . posX = 1000 coords1 . poxX // devuelve 600 En el ejemplo se declara una constante llamada coords1 y se asigna a una instancia de CoordsPantalla inicializada con la posici\u00f3n x de 600 y la posici\u00f3n y de 600. Despu\u00e9s se declara una variable llamada coords2 y se asigna al valor actual de coors1 . Debido a que CoordsPantalla es una estructura, se crea una copia de la instancia existente y esta nueva copia se asigna a coords2 . Aunque ahora coords2 y coords1 tienen las mismas posX y posY , son dos instancias completamente distintas. Despu\u00e9s, la propiedad posX de coords2 se actualiza a 1000. Podemos comprobar que la propiedad se modifica, pero que el valor de posX en coords1 sigue siendo el mismo. Las clases son tipos referencia \u00b6 A diferencia de los tipos valor, los tipos de referencias no se copian cuando se asignan o se pasan a funciones. En su lugar se usa una referencia a la misma instancia existente. En Swift las clases son tipos referencias. Veamos, por ejemplo, una instancia de la clase Ventana : 1 2 3 4 5 6 7 8 var ventana1 = Ventana () ventana1 . esquina = coords1 ventana1 . altura = 800 ventana1 . anchura = 800 ventana1 . etiqueta = \"Finder\" var ventana2 = ventana1 ventana2 . anchura = 1000 ventana1 . anchura // devuelve 1000 Declaramos una variable llamada ventana1 inicializada con una instancia nueva de la clase Ventana . Le asignamos a la propiedad esquina una copia de la resoluci\u00f3n anterior coords1 . Despu\u00e9s declaramos la altura, anchura y etiqueta de la ventana. Y, por \u00faltimo, ventana1 se asigna a una nueva constante llamada ventan2 , y la anchura se modifica. Debido a que son tipos de referencia, ventana1 y ventana2 se refieren a la misma instancia de Ventana . Son s\u00f3lo dos nombres distintos para la misma \u00fanica instancia. Lo podemos comprobar modificando una propiedad mediante una variable y viendo que esa misma propiedad en la otra variable se ha modificado tambi\u00e9n (l\u00edneas 7 y 8). Si tienes experiencia con C, C++, o Objective-C, puedes saber que estos lenguajes usan punteros para referirse a una direcci\u00f3n de memoria. Una constante o variable en Swift que se refiere a una instancia de un tipo referencia es similar a un puntero en C, pero no es un puntero que apunta a una direcci\u00f3n de memoria y no requiere que se escriba un asterisco (*) para indicar que estas creando una referencia. En su lugar, estas referencias se definen como cualquier otra constante o variable en Swift. Declaraci\u00f3n de instancias con let \u00b6 Las estructuras y clases tambi\u00e9n tienen comportamientos distintos cuando se declaran las variables con let . Si definimos con let una instancia de una estructura estamos declarando constante la variable y todas las propiedades de la instancia. No podremos modificar ninguna: 1 2 3 let coords3 = CoordsPantalla ( posX : 400 , posY : 400 ) coords3 . posX = 800 // error: cannot assign to property: 'coords3' is a 'let' constant Si definimos con un let una instancia de una clase s\u00f3lo estamos declarando constante la variable. No podremos reasignarla, pero s\u00ed que podremos modificar las propiedades de la instancia referenciada por la variable: 1 2 3 4 5 6 let ventana3 = Ventana () // S\u00ed que podemos modificar una propiedad de la instancia: ventana3 . etiqueta = \"Listado\" // Pero no podemos reasignar la variable: ventana3 = ventana1 // error: cannot assign to value: 'ventana3' is a 'let' constant Operadores de identidad \u00b6 A veces puede ser \u00fatil descubrir si dos constantes o variables se refieren exactamente a la misma instancia de una clase. Para permitir esto, Swift proporciona dos operadores de identidad: Id\u00e9ntico a ( === ) No id\u00e9ntico a ( !== ) 1 2 ventana1 === ventana2 // devuelve true ventana1 === ventana3 // devuelve false Estos operadores \"id\u00e9ntico a\" no son los mismos que los de \"igual a\" (representado por dos signos iguales == ): \"Id\u00e9ntico a\" significa que dos constantes o variables de una clase se refieren exactamente a la misma instancia de la clase. \"Igual a\" significa que dos instancias se consideran \"iguales\" o \"equivalentes\" en su valor. Es responsabilidad del dise\u00f1ador de la clase definir la implementaci\u00f3n de estos operadores. Criterios para usar estructuras y clases \u00b6 Podemos usar tanto clases como estructuras para definir nuestros tipos de datos y utilizarlos como bloques de construcci\u00f3n del c\u00f3digo de nuestros programas. Sin embargo, se utilizan para distintos tipos de tareas. Como regla general, utilizaremos una estructura cuando se cumplen una o m\u00e1s de las siguientes condiciones: El principal objetivo de la estructura es encapsular unos pocos datos relativamente sencillos. Es razonable esperar que los valores encapsulados ser\u00e1n copiados, m\u00e1s que referenciados, cuando asignamos o pasamos una instancia de esa estructura. Todas las propiedades almacenadas en la estructura son a su vez tipos valor, que tambi\u00e9n se espera que sean copiados m\u00e1s que referenciados. La estructura no necesita heredar propiedades o conducta de otro tipo existente. Ejemplos de buenos candidatos de estructuras incluyen: El tama\u00f1o de una forma geom\u00e9trica, encapsulando por ejemplo las propiedades ancho y alto de tipo Double . Una forma de referirse a rangos dentro de una serie, encapsulando por ejemplo, una propiedad comienzo y otra longitud , ambos del tipo Int . Un punto en un sistema de coordenadas 3D, encapsulando quiz\u00e1s las propiedades x , y y z , todos ellos de tipo Double . En el resto de casos, definiremos una clase y crearemos instancias de esa clase que tendr\u00e1n que ser gestionadas y pasadas por referencia. En la pr\u00e1ctica, esto representa que la mayor\u00eda de datos que construiremos en nuestros programas deber\u00edan clases, no estructuras. Aunque usaremos muchas de las estructuras est\u00e1ndar de Swift. Propiedades \u00b6 Las propiedades asocian valores con una clase, estructura o enumeraci\u00f3n particular. Las propiedades almacenadas ( stored properties ) almacenan valores constantes y variables como parte de una instancia, mientras que las propiedades calculadas ( computed properties ) calculan (en lugar de almacenar) un valor. Las propiedades calculadas se definen en clases, estructuras y enumeraciones. Las propiedades almacenadas se definen s\u00f3lo en clases y estructuras. Enumeraciones: pueden contener s\u00f3lo propiedades calculadas. Clases y estructuras: pueden contener propiedades almacenadas y calculadas. Las propiedades calculadas y almacenadas se asocian habitualmente con instancias de un tipo particular. Sin embargo, las propiedades tambi\u00e9n pueden asociarse con el propio tipo. Estas propiedades se conocen como propiedades del tipo ( type properties ). Adem\u00e1s, en Swift es posible definir observadores de propiedades que monitoricen cambios en los valores de una propiedad, a los que podemos responder con acciones programadas. Los observadores de propiedades pueden a\u00f1adirse tanto a propiedades almacenadas definidas por nosotros como a propiedades heredadas de la superclase. Propiedades almacenadas \u00b6 En su forma m\u00e1s simple, una propiedad almacenada es una constante o variable que est\u00e1 almacenada como parte de una instancia de una clase o estructura particular. Las propiedades almacenadas pueden ser o bien variables (usando la palabra clave var ) o bien constantes (usando la palabra clave let ). Podemos proporcionar un valor por defecto para la inicializaci\u00f3n de las propiedades almacenadas, tanto variables como constantes. El siguiente ejemplo define una estructura llamada RangoLongitudFija que describe un rango de valores enteros cuya longitud no puede ser modificada una vez que se crea: 1 2 3 4 5 6 7 8 struct RangoLongitudFija { var primerValor : Int let longitud : Int } var rangoDeTresItemss = RangoLongitudFija ( primerValor : 0 , longitud : 3 ) // el rango representa ahora valores enteros the range represents integer values 0, 1, and 2 rangoDeTresItemss . primerValor = 6 // el rango representa ahora valores enteros 6, 7 y 8 Las instancias de RangoLongitudFija tienen una propiedad almacenada variable llamada primerValor y una propiedad almacenada constante llamada longitud . En el ejemplo, longitud se inicializa cuando se crea el nuevo rango y no puede ser cambiada en el futuro, por ser una propiedad constante. Propiedades calculadas \u00b6 Adem\u00e1s de las propiedades almacenadas, las clases, estructuras y enumeraciones pueden definir propiedades calculadas , que no almacenan realmente un valor. En su lugar, proporcionan un getter y un opcional setter que devuelven y modifican otras propiedades y valores de forma indirecta. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 struct Punto { var x = 0.0 , y = 0.0 } struct Tama\u00f1o { var ancho = 0.0 , alto = 0.0 } struct Rectangulo { var origen = Punto () var tama\u00f1o = Tama\u00f1o () var centro : Punto { get { let centroX = origen . x + ( tama\u00f1o . ancho / 2 ) let centroY = origen . y + ( tama\u00f1o . alto / 2 ) return Punto ( x : centroX , y : centroY ) } set ( centroNuevo ) { origen . x = centroNuevo . x - ( tama\u00f1o . ancho / 2 ) origen . y = centroNuevo . y - ( tama\u00f1o . alto / 2 ) } } } var cuadrado = Rectangulo ( origen : Punto ( x : 0.0 , y : 0.0 ), tama\u00f1o : Tama\u00f1o ( ancho : 10.0 , alto : 10.0 )) let centroCuadradoInicial = cuadrado . centro cuadrado . centro = Punto ( x : 15.0 , y : 15.0 ) print ( \"cuadrado.origen est\u00e1 ahora en ( \\( cuadrado . origen . x ) , \\( cuadrado . origen . y ) )\" ) // Prints \"cuadrado.origen est\u00e1 ahora en (10.0, 10.0)\" Este ejemplo define tres estructuras para trabajar con formas geom\u00e9tricas: Punto encapsula una coordenada (x, y) Tama\u00f1o encapsula un ancho y un alto Rectangulo define una rect\u00e1ngulo por un punto de origen y un tama\u00f1o La estructura Rectangulo proporciona una propiedad calculada llamada centro . La posici\u00f3n actual del centro de un Rectangulo puede ser siempre determinada a partir de su origen y su tama\u00f1o, por lo que no necesitamos almacenarlo como un Punto expl\u00edcito. En su lugar, Rectangulo define un getter y un setter programado para una variable calculada llamada centro , para permitirnos trabajar con el centro del rect\u00e1ngulo como si fuera una propiedad almacenada. En el ejemplo se crea una variable Rectangulo llamada cuadrado . La variable cuadrado se inicializa un punto origen de (0, 0) y un ancho y tama\u00f1o de 10 . Este cuadrado est\u00e1 representado por el cuadrado azul en el diagrama de abajo. Accedemos entonces a la propiedad centro de la variable cuadrado usando la sintaxis del punto ( cuadrado.centro ), lo que causa que se llame al getter de centro para devolver el valor actual de la propiedad. En lugar de devolver los valores existentes, el getter calcula realmente y devuelve un nuevo Punto para representar el centro del cuadrado. Como puede verse arriba, el getter devuelve correctamente un punto con los valores (5, 5) . Despu\u00e9s la propiedad centro se actualiza al nuevo valor de (15, 15) lo que mueve el cuadrado arriba a la derecha, a la nueva posici\u00f3n mostrada por el cuadrado naranja en el diagrama de abajo. Al asignar el nuevo valor a la propiedad se llama al setter del centro, lo que modifica los valores x e y de las propiedades almacenadas originales, y mueve el cuadrado a su nueva posici\u00f3n. Se puede definir una versi\u00f3n acortada del setter usando la variable por defecto newValue que contiene el nuevo valor asignado en el setter : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 struct Rectangulo { var origen = Punto () var tama\u00f1o = Tama\u00f1o () var centro : Punto { get { let centroX = origen . x + ( tama\u00f1o . ancho / 2 ) let centroY = origen . y + ( tama\u00f1o . alto / 2 ) return Punto ( x : centroX , y : centroY ) } set { origen . x = newValue . x - ( tama\u00f1o . ancho / 2 ) origen . y = newValue . y - ( tama\u00f1o . alto / 2 ) } } } Propiedades solo-lectura \u00b6 Una propiedad calculada con un getter y sin setter se conoce como una propiedad calculada de solo-lectura. Una propiedad calculada de solo-lectura siempre devuelve un valor, y puede accederse a ella usando la sintaxis de punto, pero no puede modificarse a un valor distinto. Es posible simplificar la declaraci\u00f3n de una propiedad calculada de solo-lectura eliminando la palabra clave get y sus llaves: 1 2 3 4 5 6 7 8 9 struct Cuboide { var ancho = 0.0 , alto = 0.0 , profundo = 0.0 var volumen : Double { return ancho * alto * profundo } } let cuatroPorCincoPorDos = Cuboide ( ancho : 4.0 , alto : 5.0 , profundo : 2.0 ) print ( \"el volumen de cuatroPorCincoPorDos es \\( cuatroPorCincoPorDos . volumen ) \" ) // Imprime \"el volumen de cuatroPorCincoPorDos es 40.0\" Este ejemplo define una nueva estructura llamada Cubiode , que representa una caja rectangular 3D con propiedades ancho , alto y profundo . Esta estructura tiene una propiedad calculada llamada volumen , que calcula y devuelve el volumen actual del cuboide. No tendr\u00eda sentido que el volumen fuera modificable, porque no ser\u00eda ambiguo determinar qu\u00e9 valores concretos de ancho, alto y profundo deber\u00edan usarse para un valor particular del volumen. Observadores de propiedades \u00b6 Los observadores de propiedades ( property observers ) observan y responden a cambios en el valor de una propiedad. Los observadores de propiedades se llaman cada vez que el valor de una propiedad es actualizado, incluso si el nuevo valor es el mismo que el valor actual de la propiedad. Se pueden a\u00f1adir observadores a cualquier propiedad almacenada que se definan. Se pueden tambi\u00e9n a\u00f1adir observadores a cualquier propiedad heredada (ya sea almacenada o calculada) sobreescribiendo la propiedad en la subclase. No es necesario definir observadores de propiedades calculadas no sobreescritas porque siempre es posible observar y responder a cambios en su valor en el setter de la propiedad. Es posible definir alguno o ambos de estos observadores sobre una propiedad: willSet es llamado justo antes de que el nuevo valor se almacena en la propiedad. didSet es llamado inmediatamente despu\u00e9s de que el nuevo valor es almacenado en la propiedad. Si implementamos un observador willSet , se le pasa el nuevo valor de la propiedad como un par\u00e1metro constante. Podemos especificar un nombre para este par\u00e1metro como parte de la implementaci\u00f3n de willSet . Si no escribimos el nombre del par\u00e1metro y los par\u00e9ntesis dentro de la implementaci\u00f3n, el par\u00e1metro estar\u00e1 disponible con el nombre por defecto de newValue . De forma similar, si implementamos un observador didSet , se pasa como un par\u00e1metro constante que contiene el valor antiguo de la propiedad. Podemos darle nombre al par\u00e1metro o usar el nombre por defecto de oldValue . Si asignamos un valor a la propiedad dentro de su propio observador didSet , el nuevo valor que asignamos reemplaza el que acaba de a\u00f1adirse a la propiedad. A continuaci\u00f3n podemos ver un ejemplo de willSet y didSet en acci\u00f3n. En \u00e9l definimos una clase nueva llamada CuentaPasos , que hace un seguimiento del n\u00famero total de pasos que una persona hace al caminar. Esta clase puede usarse con datos de entrada de un pod\u00f3metro o cualquier otro sistema de seguir el ejercicio de la persona durante su rutina diaria. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class ContadorPasos { var totalPasos : Int = 0 { willSet ( nuevoTotalPasos ) { print ( \"A punto de actualizar totoalPasos a \\( nuevoTotalPasos ) \" ) } didSet { if totalPasos > oldValue { print ( \"A\u00f1adidos \\( totalPasos - oldValue ) pasos\" ) } } } } let contadorPasos = ContadorPasos () contadorPasos . totalPasos = 200 // Imprime: \"A punto de actualizar totalPasos a 200\" // Imprime: \"A\u00f1adidos 200 pasos\" contadorPasos . totalPasos = 360 // Imprime: \"A punto de actualizar totalPasos a 360\" // Imprime: \"A\u00f1adidos 160 pasos\" contadorPasos . totalPasos = 896 // Imprime: \"A punto de actualizar totalPasos a 896\" // Imprime: \"A\u00f1adidos 536 pasos\" La clase CuentaPasos declara la propiedad totalPasos de tipo Int . Esta es una propiedad almacenada con observadores willSet y didSet . Los observadores willSet y didSet de totalPasos se llaman siempre que se le asigna un nuevo valor a la propiedad. Esto es as\u00ed incluso si el nuevo valor es el mismo que el valor actual. El observador willSet usa un par\u00e1metro definido por nosotros con el nombre de nuevoTotalPasos para el valor que llega. En el ejemplo, sencillamente imprime el valor que est\u00e1 a punto de establecer. El observador didSet se llama despu\u00e9s de que el valor de totalPasos se ha actualizado. Compara el nuevo valor de totalPasos con el valor antiguo. Si el n\u00famero total de pasos se ha incrementado, se imprime un mensaje indicando cu\u00e1ntos pasos se han tomado. El observador didSet no proporciona un par\u00e1metro definido por nosotros para el valor antiguo, sino que usa el nombre por defecto oldValue . Variables locales y globales \u00b6 Las capacidades anteriores de propiedades calculadas y de observadores tambi\u00e9n est\u00e1n disponibles para variables globales y locales. El siguiente ejemplo muestra un ejemplo con una variable calculada a partir de otras dos: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 var x = 10 { didSet { print ( \"El nuevo valor: \\( x ) y el valor antiguo: \\( oldValue ) \" ) } } var y = 2 * x var z : Int { get { return x + y } set { x = newValue / 2 y = newValue / 2 } } print ( z ) z = 100 print ( x ) Propiedades del tipo \u00b6 Las propiedades de las instancias son propiedades que pertenecen a una instancia de un tipo particular. Cada vez que creamos una nueva instancia de ese tipo, tiene su propio conjunto de valores de propiedades, separados de los de cualquier otra instancia. Podemos definir tambi\u00e9n propiedades que pertenecen al tipo propiamente dicho, no a ninguna de las instancias de ese tipo. S\u00f3lo habr\u00e1 una copia de estas propiedades, sea cual sea el n\u00famero de instancias de ese tipo que creemos. Estos tipos de propiedades se llaman propiedades del tipo ( type propierties ). Se pueden definir en tanto en estructuras, clases como en enumeraciones. Las propiedades del tipo son \u00fatiles para definir valores que son universales a todas las instancias de un tipo particular, como una propiedad constante que todas las instancias pueden usar (como una constante est\u00e1tica en C), o una propiedad variable que almacena un valor que es global a todas las instancias de ese tipo (como una variable est\u00e1tica en C). Las propiedades del tipo almacenadas pueden ser variables o constantes. Las propiedades del tipo calculadas se declaran siempre como propiedades variables, de la misma forma que las propiedades calculadas de instancias. A diferencia de las propiedades almacenadas de instancias, debemos siempre proporcionar un valor por defecto para las propiedades almacenadas de tipo. Esto es debido a que el tipo por si mismo no tiene un inicializador que pueda asignar un valor en tiempo de inicializaci\u00f3n. En Swift, las propiedades del tipo se definen como parte de la definici\u00f3n del tipo, dentro de las llaves del tipo. Las propiedades del tipo toman valor en el \u00e1mbito del tipo. Para definir una propiedad del tipo hay que usar la palabra clave static . Para propiedades de tipo calculadas de clases, podemos usar en su lugar la palabra clave class para permitir a las subclases que sobreescriban la implementaci\u00f3n de la superclase. Las propiedades del tipo pueden ser tambi\u00e9n constantes ( let ) o variables ( var ). Ejemplo: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 struct UnaEstructura { static var almacenada = \"A\" static var calculada : Int { return 1 } } enum UnaEnumeracion { static var almacenada = \"A\" static var calculada : Int { return 1 } } class UnaClase { static var almacenada = \"A\" static var calculada : Int { return 1 } } Las propiedades del tipo se consultan y actualizan usando tambi\u00e9n la sintaxis de punto, pero sobre el tipo : 1 2 3 UnaEstructura . almacenada // devuelve \"A\" UnaEstructura . almacenada = \"B\" UnaClase . calculada // devuelve 1 No es posible acceder a la variable del tipo a trav\u00e9s de una instancia: 1 2 let a = UnaEstructura () a . almacenada // error El siguiente ejemplo muestra c\u00f3mo es posible usar una variable del tipo para almacenar informaci\u00f3n global a todas las instancias de ese tipo: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 struct Valor { var valor : Int = 0 { didSet { Valor . sumaValores += valor } } static var sumaValores = 0 } var c1 = Valor () var c2 = Valor () var c3 = Valor () c1 . valor = 10 c2 . valor = 20 c3 . valor = 30 print ( \"Suma de los cambios de valores: \\( Valor . sumaValores ) \" ) // Imprime 60 M\u00e9todos \u00b6 Los m\u00e9todos son funciones que est\u00e1n asociadas a un tipo particular. Las clases, estructuras y enumeraciones pueden definir todas ellas m\u00e9todos de instancia, que encapsulan tareas y funcionalidades espec\u00edficas que trabajan con una instancia de un tipo dado. Las clases, estructuras y enumeraciones tambi\u00e9n pueden definir m\u00e9todos del tipo, que est\u00e1n asociados con el propio tipo. Los m\u00e9todos del tipo son similares a los m\u00e9todos de clase en Java. El hecho de que las estructuras y las enumeraciones puedan definir m\u00e9todos en Swift es una diferencia importante con C y Objective-C. M\u00e9todos de instancia \u00b6 Los m\u00e9todos de instancia son funciones que pertenecen a instancias de una clase, estructura o enumeraci\u00f3n. Proporcionan la funcionalidad de esas instancias, bien proporcionando formas de acceder y modificar propiedades de las instancias, o bien proporcionando funcionalidades relacionadas con el prop\u00f3sito de la instancia. Los m\u00e9todos de instancia tienen exactamente la misma sintaxis que las funciones. Los m\u00e9todos de instancia se escriben dentro de las llaves del tipo al que pertenecen. Un m\u00e9todo de instancia tiene acceso impl\u00edcito a todos los otros m\u00e9todos de instancia y propiedades del tipo. Un m\u00e9todo de instancia puede ser invocado s\u00f3lo sobre una instancia espec\u00edfica del tipo al que pertenece. No puede ser invocado de forma aislada sin una instancia existente. A continuaci\u00f3n podemos ver un ejemplo que define una sencilla clase Contador , que puede usarse para contar el n\u00famero de veces que sucede una acci\u00f3n: 1 2 3 4 5 6 7 8 9 10 11 12 class Contador { var veces = 0 func incrementa () { veces += 1 } func incrementa ( en cantidad : Int ) { veces += cantidad } func reset () { veces = 0 } } Y un ejemplo de uso: 1 2 3 4 5 6 7 8 let contador = Contador () // el valor inicial del contador es 0 contador . incrementa () // el valor del contador es ahora 1 contador . incrementa ( en : 5 ) // el valor del contador es ahora 6 contador . reset () // el valor del contador es ahora 0 En el ejemplo anterior, los m\u00e9todos no devuelven ning\u00fan valor. Podemos modificar el ejemplo para que los m\u00e9todos devuelvan el valor actualizado del contador: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Contador { var veces = 0 func incrementa () -> Int { veces += 1 return veces } func incrementa ( en cantidad : Int ) -> Int { veces += cantidad return veces } func reset () -> Int { veces = 0 return veces } } Nombres locales y externos de par\u00e1metros \u00b6 Ya vimos que los par\u00e1metros de las funciones pueden tener un nombre interno y un nombre externo. Lo mismo sucede con los m\u00e9todos, porque los m\u00e9todos no son m\u00e1s que funciones asociadas con un tipo. Los nombres de los m\u00e9todos en Swift se refieren normalmente al primer par\u00e1metro usando una preposici\u00f3n como con , en , a o por , como hemos visto en el ejemplo anterior incrementa(en:) . El uso de la preposici\u00f3n permite que el m\u00e9todo se lea como una frase. El nombre de una par\u00e1metro se utiliza tambi\u00e9n como etiqueta del argumento (nombre externo). Al igual que en las funciones, es posible definir dos nombres del par\u00e1metro, uno externo y otro interno. Y el nombre externo puede ser un _ para indicar que no es necesario usar la etiqueta del argumento. Esta forma de invocar a los m\u00e9todos hace que el lenguaje sea m\u00e1s expresivo, sin necesidad de nombres largos de m\u00e9todos o funciones. Consideremos por ejemplo esta versi\u00f3n alternativa de la clase Contador , que define una forma m\u00e1s compleja del m\u00e9todo incrementa(en:) : 1 2 3 4 5 6 class Contador { var valor : Int = 0 func incrementa ( en cantidad : Int , numeroDeVeces : Int ) { valor += cantidad * numeroDeVeces } } El m\u00e9todo incrementa(en:numeroDeVeces:) tiene dos par\u00e1metros: cantidad y numeroDeVeces . El primer par\u00e1metro tiene un nombre externo y otro interno. En el cuerpo del m\u00e9todo se utiliza el nombre interno ( cantidad ). El segundo par\u00e1metro numeroDeVeces es tanto nombre externo como interno. Podemos llamar al m\u00e9todo de la siguiente forma: 1 2 3 let contador = Contador () contador . incrementa ( en : 5 , numeroDeVeces : 3 ) // el valor del contador es ahora 15 Al igual que en las funciones, podemos definir expl\u00edcitamente los nombres externos de los par\u00e1metros y usar el subrayado ( _ ) para indicar que ese par\u00e1metro no tendr\u00e1 nombre externo. La propiedad self \u00b6 Toda instancia de un tipo tiene una propiedad impl\u00edcita llamada self , que es exactamente equivalente a la instancia misma. Podemos usar la propiedad self para referirnos a la instancia actual dentro de sus propios m\u00e9todos de instancia. El m\u00e9todo incrementa() en el ejemplo anterior podr\u00eda haberse escrito de esta forma: 1 2 3 func incrementa () { self . veces += 1 } En la pr\u00e1ctica no es necesario usar self casi nunca. Swift asume que cualquier referencia a una propiedad dentro de un m\u00e9todo se refiere a la propiedad de la instancia. Es obligado usarlo es cuando el nombre de la propiedad coincide con el nombre de un par\u00e1metro. En esta situaci\u00f3n el nombre del par\u00e1metro toma precedencia y es necesario usar self para poder referirse a la propiedad de la instancia. Un ejemplo: 1 2 3 4 5 6 7 8 9 10 11 struct Punto { var x = 0.0 , y = 0.0 func estaAlaDerecha ( de x : Double ) -> Bool { return self . x > x } } let unPunto = Punto ( x : 4.0 , y : 5.0 ) if unPunto . estaAlaDerecha ( de : 1.0 ) { print ( \"Este punto est\u00e1 a la derecha de la l\u00ednea donde x == 1.0\" ) } // Imprime \"Este punto est\u00e1 a la derecha de la l\u00ednea donde x == 1.0\" Operaciones con instancias de tipo valor \u00b6 Las estructuras y las enumeraciones son tipos valor . Por defecto, las propiedades de un tipo valor no pueden ser modificadas desde dentro de los m\u00e9todos de instancia. Si queremos modificar una propiedad de un tipo valor la forma m\u00e1s natural de hacerlo es creando una instancia nueva, usando el estilo de programaci\u00f3n funcional: 1 2 3 4 5 6 7 8 9 10 struct Punto { var x = 0.0 , y = 0.0 func incrementa ( incX : Double , incY : Double ) -> Punto { return Punto ( x : x + incX , y : y + incY ) } } let unPunto = Punto ( x : 1.0 , y : 1.0 ) var puntoMovido = unPunto . incrementa ( incX : 2.0 , incY : 3.0 ) print ( \"Hemos movido el punto a ( \\( puntoMovido . x ) , \\( puntoMovido . y ) )\" ) // Imprime \"Hemos movido el punto a (3.0, 4.0)\" Modificaci\u00f3n de tipos valor desde dentro de la instancia \u00b6 Sin embargo, hay ocasiones en las que necesitamos modificar las propiedades de nuestra estructura o enumeraci\u00f3n dentro de un m\u00e9todo particular. Necesitamos conseguir una conducta mutadora para ese m\u00e9todo. El m\u00e9todo puede mutar (esto es, cambiar) sus propiedades desde dentro del m\u00e9todo, as\u00ed como asignar una instancia completamente nueva a su propiedad impl\u00edcita self , con lo que esta nueva instancia reemplazar\u00e1 la existente cuando el m\u00e9todo termine. Podemos conseguir esta conducta colocando la palabra clave mutating antes de la palabra func del m\u00e9todo: 1 2 3 4 5 6 7 8 9 10 11 struct Punto { var x = 0.0 , y = 0.0 mutating func incrementado ( incX : Double , incY : Double ) { x += incX y += incY } } var unPunto = Punto ( x : 1.0 , y : 1.0 ) unPunto . incrementado ( incX : 2.0 , incY : 3.0 ) print ( \"El punto est\u00e1 ahora en ( \\( unPunto . x ) , \\( unPunto . y ) )\" ) // Imprime \"El punto est\u00e1 ahora en (3.0, 4.0)\" La estructura Punto anterior define un m\u00e9todo mutador incrementado(incX:incY:) que mueve una instancia de Punto una cierta cantidad. En lugar de devolver un nuevo punto, el m\u00e9todo modifica realmente el punto en el que es llamado. La palabra clave mutating se a\u00f1ade a su definici\u00f3n para permitirle modificar sus propiedades. Hay que hacer notar que no es posible llamar a un m\u00e9todo mutador sobre una constante de un tipo estructura, porque sus propiedades no se pueden cambiar, incluso aunque sean propiedades variables: 1 2 3 let puntoFijo = Punto ( x : 3.0 , y : 3.0 ) puntoFijo . incrementado ( incX : 2.0 , incY : 3.0 ) // esto provocar\u00e1 un error Asignaci\u00f3n a self en un m\u00e9todo mutador \u00b6 Los m\u00e9todos mutadores pueden asignar una nueva instancia completamente nueva a la propiedad self . El anterior ejemplo Punto podr\u00eda habers escrito de la siguiente forma: 1 2 3 4 5 6 struct Punto { var x = 0.0 , y = 0.0 mutating func incrementa ( incX : Double , incY : Double ) { self = Punto ( x : x + incX , y : y + incY ) } } Esta versi\u00f3n del m\u00e9todo mutador incrementa(incX:incY:) crea una estructura nueva cuyos valores x e y se inicializan a los valores desados. El resutado final de llamar a esta versi\u00f3n alternativa ser\u00e1 exactamente el mismo que llamar a la versi\u00f3n anterior (aunque con una peque\u00f1a penalizaci\u00f3n de eficiencia: este m\u00e9todo es 1,3 veces m\u00e1s lento que el anterior en la versi\u00f3n 2.2 del compilador de Swift). Los m\u00e9todos mutadores de enumeraciones pueden establecer el par\u00e1metro self impl\u00edcito para que tenga un subtipo distinto de la misma enumeraci\u00f3n: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 enum InterruptorTriEstado { case apagado , medio , alto mutating func siguiente () { switch self { case . apagado : self = . medio case . medio : self = . alto case . alto : self = . apagado } } } var luzHorno = InterruptorTriEstado . medio luzHorno . siguiente () // luzHorno es ahora .alto luzHorno . siguiente () // luzHorno es ahora .apagado M\u00e9todos del tipo \u00b6 Los m\u00e9todos de instancia, como los descritos antes, se llaman en instancias de un tipo particular. Es posible tambi\u00e9n definir m\u00e9todos que se llaman en el propio tipo. Esta clase de m\u00e9todos se denominan m\u00e9todos del tipo . Se define un m\u00e9todo del tipo escribiendo la palabra clave static antes de la palabra clave func del m\u00e9todo. Las clases tambi\u00e9n pueden usar la palabra clave class para permitir a las subclases sobreescribir la implementaci\u00f3n del m\u00e9todo. Los m\u00e9todos del tipo se invocan tambi\u00e9n con la sintaxis de punto, escribiendo el nombre del tipo. Por ejemplo: 1 2 3 4 5 6 class NuevaClase { static func unMetodoDelTipo () { print ( \"Hola desde el tipo\" ) } } NuevaClase . unMetodoDelTipo () Dentro del cuerpo del m\u00e9todo, la propiedad impl\u00edcita self se refiere al propio tipo, m\u00e1s que a una instancia de ese tipo. Para estructuras y enumeraciones, esto significa que puedes usar self para desambiguar entre propiedades del tipo y los par\u00e1metros del m\u00e9todo, de la misma forma que se hace en los m\u00e9todos de instancias. Cualquier nombre de m\u00e9todo o propiedad que se utilice en el cuerpo de un m\u00e9todo del tipo se referir\u00e1 a otras propiedades o m\u00e9todos de nivel del tipo. Se puede utilizar estos nombres sin necesidad de a\u00f1adir el prefijo del nombre del tipo. Por ejemplo, podemos a\u00f1adir a la clase Ventana una propiedad y m\u00e9todo de clase con la que almacenar instancias de ventanas. Inicialmente guardamos un array vac\u00edo. 1 2 3 4 5 6 7 8 9 10 class Ventana { // Propiedades static var ventanas : [ Ventana ] = [] static func registrar ( ventana : Ventana ) { ventanas . append ( ventana ) } } Cada vez que creamos una ventana podemos llamar al m\u00e9todo registrar de la clase para a\u00f1adirlo a la colecci\u00f3n de ventanas de la clase: 1 2 3 4 let v1 = Ventana () Ventana . registrar ( ventana : v1 ) print ( \"Se han registrado \\( Ventana . ventanas . count ) ventanas\" ) // Imprime \"Se han registrado 1 ventanas\" Inicializaci\u00f3n \u00b6 Inicializaci\u00f3n es el proceso de preparar para su uso una instancia de una clase, estructura o enumeraci\u00f3n. Este proceso incluye la asignaci\u00f3n de un valor inicial para cada propiedad almacenada y la ejecuci\u00f3n de cualquier otra operaci\u00f3n de inicializaci\u00f3n que se necesite para que la nueva instancia est\u00e9 lista para usarse. Para implementar este proceso de inicializaci\u00f3n hay que definir inicializadores , que son como m\u00e9todos especiales que pueden llamarse para crear una nueva instancia de un tipo particular. A diferencia de otros lenguajes, los inicializadores en Swift no devuelven un valor. Su papel principal es que las nuevas instancias del tipo est\u00e9n correctamente inicializadas antes de poder ser usadas por primera vez. Tambi\u00e9n es posible implementar deinicializadores , m\u00e9todos que se ejecutan cuando las instancias son eliminadas de la memoria (no vamos a explicarlos por falta de tiempo). El proceso de inicializaci\u00f3n de una instancia puede resultar un proceso complicado, sobre todo cuando se tienen relaciones de herencia y hay que especificar tambi\u00e9n c\u00f3mo realizar la inicializaci\u00f3n de la subclase utilizando la superclase. Por falta de tiempo no vamos a explicar todo el proceso completo. Recomendamos consultar la documentaci\u00f3n original de Swift . Inicializadores por defecto y memberwise \u00b6 Ya hemos visto que es posible inicializar clases y estructuras definiendo valores por defecto a todas sus propiedades (con la posible excepci\u00f3n de las que tienen un tipo opcional). En ese caso, podemos no definir ning\u00fan inicializador y usar el inicializador por defecto que proporciona Swift. 1 2 3 4 5 6 7 8 9 10 struct Punto2D { var x = 0.0 var y = 0.0 } class Segmento { var p1 = Punto2D () var p2 = Punto2D () } var s = Segmento () Tambi\u00e9n es posible en las estructuras utilizar el inicializador memberwise , en el que especificamos todos los valores de las propiedades: 1 var p = Punto2D ( x : 10.0 , y : 10.0 ) Los inicializadores por defecto y memberwise desaparecen en el momento en que definimos alg\u00fan inicializador con la palabra init . Veamos c\u00f3mo definir inicializadores. Inicializaci\u00f3n de propiedades almacenadas \u00b6 Como hemos dicho, las clases y estructuras deben definir todas sus propiedades almacenadas a un valor inicial en el tiempo en la instancia se crea, a no ser que \u00e9stas sean opcionales, en cuyo caso quedar\u00edan inicializadas a nil . Podemos definir el valor inicial para una propiedad en un inicializador o asign\u00e1ndole un valor por defecto como parte de la definici\u00f3n de la propiedad. Un inicializador , en su forma m\u00e1s simple se escribe con la palabra clave init : 1 2 3 init () { // realizar alguna inicializaci\u00f3n aqu\u00ed } Por ejemplo, podemos definir la estructura Farenheit que almacena una temperatura en grados Farenheit. Tiene una propiedad almacenada de tipo Double . Definimos un inicializador que inicializa las instancias a 32.0 (equivalente a 0.0 grados Celsius). 1 2 3 4 5 6 7 8 9 struct Fahrenheit { var temperatura : Double init () { temperatura = 32.0 } } var f = Fahrenheit () print ( \"La temperatura por defecto es \\( f . temperatura ) Fahrenheit\" ) // Imprime \"La temperatura por defecto es 32.0\u00b0 Fahrenheit\" La implementaci\u00f3n anterior es equivalente a la que ya hemos visto con el inicializador por defecto: 1 2 3 struct Fahrenheit { var temperatura = 32.0 } Inicializadores personalizados \u00b6 Podemos proporcionar par\u00e1metros de inicializaci\u00f3n como parte de la definici\u00f3n de un inicializador, para definir los tipos y los nombres de los valores que personalizan el proceso de inicializaci\u00f3n. Los par\u00e1metros de inicializaci\u00f3n tienen las mismas capacidades y sintaxis que los par\u00e1metros de funciones y m\u00e9todos. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 struct Celsius { var temperaturaEnCelsius : Double init ( desdeFahrenheit fahrenheit : Double ) { temperaturaEnCelsius = ( fahrenheit - 32.0 ) / 1.8 } init ( desdeKelvin kelvin : Double ) { temperaturaEnCelsius = kelvin - 273.15 } } let puntoDeEbullicionDelAgua = Celsius ( desdeFahrenheit : 212.0 ) // puntoDeEbullicionDelAgua.temperaturaEnCelsius es 100.0 let puntoDeCongelacionDelAgua = Celsius ( desdeKelvin : 273.15 ) // puntoDeCongelacionDelAgua.temperaturaEnCelsius is 0.0 Vemos que dependiendo del nombre de par\u00e1metro proporcionado se escoge un inicializador u otro. En los inicializadores es obligatorio proporcionar los nombres de todos los par\u00e1metros: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 struct Color { let rojo , verde , azul : Double init ( rojo : Double , verde : Double , azul : Double ) { self . rojo = rojo self . verde = verde self . azul = azul } init ( blanco : Double ) { rojo = blanco verde = blanco azul = blanco } } let magenta = Color ( rojo : 1.0 , verde : 0.0 , azul : 1.0 ) let medioGris = Color ( blanco : 0.5 ) Podemos evitar proporcionar nombres externos usando un subrayado. Por ejemplo, podemos a\u00f1adir al struct anterior Celsius un inicializador sin nombre externo para el caso en que pasemos la temperatura inicial precisamente en Celsius: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 struct Celsius { var temperaturaEnCelsius : Double init ( desdeFahrenheit fahrenheit : Double ) { temperaturaEnCelsius = ( fahrenheit - 32.0 ) / 1.8 } init ( desdeKelvin kelvin : Double ) { temperaturaEnCelsius = kelvin - 273.15 } init ( _ celsius : Double ) { temperaturaEnCelsius = celsius } } let temperaturaCuerpo = Celsius ( 37.0 ) // temperaturaCuerpo.temperaturaEnCelsius es 37.0 Por \u00faltimo, es posible inicializar propiedades constantes definidas con let . S\u00f3lo toman valor en el momento de la inicializaci\u00f3n y despu\u00e9s no pueden modificarse. 1 2 3 4 5 6 7 8 9 10 11 12 13 class PreguntaEncuesta { let texto : String var respuesta : String ? init ( texto : String ) { self . texto = texto } func pregunta () { print ( texto ) } } let preguntaQueso = PreguntaEncuesta ( texto : \"\u00bfTe gusta el queso?\" ) preguntaQueso . pregunta () // -> \"\u00bfTe gusta el queso? preguntaQueso . respuesta // -> nil La propiedad respuesta se inicializa a nil al ser un opcional y no inicializarla en el inicializador. Por \u00faltimo, es posible definir m\u00e1s de un inicializador, as\u00ed como invocar a inicializadores m\u00e1s b\u00e1sicos desde otros. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 struct Rectangulo { var origen = Punto () var tama\u00f1o = Tama\u00f1o () init (){} init ( origen : Punto , tama\u00f1o : Tama\u00f1o ) { self . origen = origen self . tama\u00f1o = tama\u00f1o } init ( centro : Punto , tama\u00f1o : Tama\u00f1o ) { let origenX = centro . x - ( tama\u00f1o . ancho / 2 ) let origenY = centro . y - ( tama\u00f1o . ancho / 2 ) self . init ( origen : Punto ( x : origenX , y : origenY ), tama\u00f1o : tama\u00f1o ) } } let basicRectangulo = Rectangulo () // el origen de basicRectangulo es (0.0, 0.0) y su tama\u00f1o (0.0, 0.0) let origenRectangulo = Rectangulo ( origen : Punto ( x : 2.0 , y : 2.0 ), tama\u00f1o : Tama\u00f1o ( ancho : 5.0 , alto : 5.0 )) // el origne de origenRectangulo es (2.0, 2.0) y su tama\u00f1o (5.0, 5.0) let centroRectangulo = Rectangulo ( centro : Punto ( x : 4.0 , y : 4.0 ), tama\u00f1o : Tama\u00f1o ( ancho : 3.0 , alto : 3.0 )) // el origen de centroRectangulo es (2.5, 2.5) y su tama\u00f1o (3.0, 3.0) El inicializador init(){} permite inicializar el Rectangulo a los valores por defecto definidos en las propiedades. Proporciona la misma funcionalidad que el inicializador por defecto, que tal y como hemos comentado, no se crea en una estructura o clase en la que definimos sus propios inicializadores. Herencia \u00b6 Una clase puede heredar m\u00e9todos, propiedades y otras caracter\u00edsticas de otra clase. Cuando una clase hereda de otra, la clase que hereda se denomina subclase , y la clase de la que se hereda se denomina su superclase . La herencia es una conducta fundamental que diferencia las clases de otros tipos en Swift. Las clases en Swift pueden llamar y acceder a m\u00e9todos y propiedades que pertenecen a su superclase y pueden proporcionar sus propias versiones que sobreescriben esos m\u00e9todos y propiedades. Para sobreescribir un m\u00e9todo o una propiedad es necesario cumplir con la definici\u00f3n proporcionada por la superclase. Las clases tambi\u00e9n pueden a\u00f1adir observadores a las propiedades heredadas para ser notificadas cuando cambia el valor de una propiedad. A cualquier propiedad se le puede a\u00f1adir un observador de propiedad, independientemente de si es originalmente una propiedad almacenada o calculada. Definici\u00f3n de una clase base \u00b6 Una clase que no hereda de ninguna otra se denomina una clase base ( base class ). A diferencia de otros lenguajes orientados a objetos, las clases en Swift no heredan de una clase base universal. Tambi\u00e9n a diferencia de otros lenguajes orientados a objetos Swift no permite definir clases abstractas que no permiten crear instancias. Cualquier clase en Swift puede ser instanciada. El siguiente ejemplo define una clase base llamada Vehiculo . Esta clase base define una propiedad almacenada llamada velocidadActual con un valor por defecto de 0.0. Esta propiedad se utiliza por una propiedad String calculada llamada descripcion que crea una descripci\u00f3n del veh\u00edculo. La clase base Vehiculo tambi\u00e9n define un m\u00e9todo llamdo hazRuido . Este m\u00e9todo no hace nada realmente para una instancia de un veh\u00edculo base, pero ser\u00e1 modificado m\u00e1s adelante por las subclases de Vehiculo . 1 2 3 4 5 6 7 8 9 class Vehiculo { var velocidadActual = 0.0 var descripcion : String { return \"viajando a \\( velocidadActual ) kil\u00f3metros por hora\" } func hazRuido () { // no hace nada - un veh\u00edculo arbitrario no hace ruido necesariamente } } Creamos una instancia nueva de Vehiculo con la sintaxis de inicializaci\u00f3n que hemos visto, en la que se escribe el nombre del tipo de la clase seguido por par\u00e9ntesis vac\u00edos: 1 let unVehiculo = Vehiculo () Habiendo creado una instancia nueva de Vehiculo , podemos acceder a su descripci\u00f3n: 1 2 print ( \"Veh\u00edculo: \\( unVehiculo . descripcion ) \" ) // Veh\u00edculo: viajando a 0.0 kil\u00f3metros por hora La clase Vehiculo define caracter\u00edsticas comunes para un veh\u00edculo arbitrario, pero no es de mucha utilidad por si misma. Para hacerla m\u00e1s \u00fatil, tenemos que refinarla para describir tipos de veh\u00edculos m\u00e1s espec\u00edficos. Construcci\u00f3n de subclases \u00b6 La construcci\u00f3n de una subclase ( subclassing ) es la acci\u00f3n de basar una nueva clase en una clase existente. La subclase hereda caracter\u00edsticas de la clase existente, que despu\u00e9s podemos refinar. Tambi\u00e9n podemos a\u00f1adir nuevas caracter\u00edsticas a la subclase. Para indicar que una subclase tiene una superclase hay que escribir el nombre de la subclase antes de el de la superclase, separadas por dos puntos ( : ): 1 2 3 class UnaSubclase : UnaSuperClase { // definici\u00f3n de la subclase } En el ejemplo anterior del Vehiculo podemos definir una subclase Bicicleta : 1 2 3 class Bicicleta : Vehiculo { var tieneCesta = false } La nueva clase Bicicleta obtiene autom\u00e1ticamente todas las caracter\u00edsticas del Vehiculo , como sus propiedades velocidadActual y descripcion y su m\u00e9todo haceRuido() . Adem\u00e1s de las caracter\u00edsticas que hereda, la clase Bicicleta define una nueva propiedad almacenada, tieneCesta , con un valor por defecto de false . Por defecto, cualquier instancia nueva de Bicicleta no tendr\u00e1 una cesta. Puedes establecer la propiedad tieneCesta a true para una instancia particular de Bicicleta despu\u00e9s de crearla: 1 2 let bicicleta = Bicicleta () bicicleta . tieneCesta = true Podemos tambi\u00e9n modificar la propiedad heredada velocidadActual y preguntar por la propiedad descripcion : 1 2 3 bicicleta . velocidadActual = 10.0 print ( \"Bicicleta: \\( bicicleta . descripcion ) \" ) // Bicicleta: viajando a 10.0 kil\u00f3metros por hora Podemos construir subclases a partir de otras subclases. El siguiente ejemplo crea una subclase de Bicicleta que representa una bicicleta de dos sillines (un \"tandem\"): 1 2 3 class Tandem : Bicicleta { var numeroActualDePasajeros = 0 } Tandem hereda todas las propiedades y m\u00e9todos de Bicicleta , que a su vez hereda todas sus propiedades y m\u00e9todos de Vehiculo . La subclase Tandem tambi\u00e9n a\u00f1ade una nueva propiedad almacenada llamada numeroActualDePasajeros , con un valor por defecto de 0. Si creamos una instancia de Tandem podremos trabajar con cualquiera de sus propiedades nuevas y heredadas, y preguntar a la descripci\u00f3n de solo lectura que hereda de Vehiculo : 1 2 3 4 5 6 let tandem = Tandem () tandem . tieneCesta = true tandem . numeroActualDePasajeros = 2 tandem . velocidadActual = 18.0 print ( \"Tandem: \\( tandem . descripcion ) \" ) // Tandem: viajando a 18.0 kil\u00f3metros por hora Sobreescritura \u00b6 Una subclase puede proporcionar su propia implementaci\u00f3n de un m\u00e9todo de la instancia, m\u00e9todo del tipo, propiedad de la instancia o propiedad del tipo que hereda de su superclase. Esto se conoce como sobreescritura ( overriding ). Para sobreescribir una caracter\u00edstica que ser\u00eda de otra forma heredada debemos usar el prefijo override . De esta forma se clarifica que intentamos proporcionar una sobreescritura y que no lo hacemos por error. Esta palabra clave tambi\u00e9n hace que el compilador comprueba que la superclase (o una de sus clases padre) tiene una declaraci\u00f3n que empareja con la que proporcionamos en la sobreescritura. Cuando proporcionamos una sobreescritura puede ser \u00fatil acceder a los valores proporcionados por la clase padre. Para acceder a ellos podemos usar el prefijo super . El siguiente ejemplo define una nueva subclase de Vehiculo llamada Tren , que sobreescribe el m\u00e9todo hazRuido() : 1 2 3 4 5 class Tren : Vehiculo { override func hazRuido () { print ( \"Chuu Chuu\" ) } } Si creamos una nueva instancia de Tren y llamamos al m\u00e9todo hazRuido podemos comprobar que se llama a la versi\u00f3n del m\u00e9todo de la subclase: 1 2 3 let tren = Tren () tren . hazRuido () // Imprime \"Chuu Chuu\" Podemos sobreescribir cualquier propiedad heredada del tipo o de la instancia y proporcionar nuestros propios getters y setters para esa propiedad, o a\u00f1adir observadores de propiedades para observar cuando cambian los valores subyacentes de la propiedad. Podemos proporcionar un getter (o setter , si es apropiado) para sobreescribir cualquier propiedad heredada, independientemente de si la propiedad heredada se implementa como una propiedad almacenada o calculada. La naturaleza almacenada o calculada no se conoce por la subclase, que solo conoce su nombre y su tipo. Es posible convertir una propiedad heredada de solo-lectura en una de lectura-escritura. No es posible presentar una propiedad heredada de lectura-escritura como de solo-lectura. El siguiente ejemplo define una nueva clase llamada Coche , que es una subclase de Vehiculo . La clase Coche introduce una nueva propiedad almacenada llamada marcha , con un valor por defecto de 1. Tambi\u00e9n sobreescribe la propiedad heredada descripcion , incluyendo la marcha actual en la descripci\u00f3n: 1 2 3 4 5 6 class Coche : Vehiculo { var marcha = 1 override var descripcion : String { return super . descripcion + \" con la marcha \\( marcha ) \" } } Podemos ver el funcionamiento en el siguiente ejemplo: 1 2 3 4 5 let coche = Coche () coche . velocidadActual = 50.0 coche . marcha = 3 print ( \"Coche: \\( coche . descripcion ) \" ) // Coche: viajando a 50.0 kil\u00f3metros por hora con la marcha 3 Por \u00faltimo, podemos a\u00f1adir observadores a propiedades heredadas. Esto nos permite ser notificados cuando el valor de una propiedad heredada cambia, independientemente de si esa propiedad se ha implementado en la subclase o en la superclase. El siguiente ejemplo define una nueva clase llamada CocheAutomatico que es una subclase de Coche . La clase CocheAutomatico representa un coche con una caja de cambios autom\u00e1tica, que selecciona autom\u00e1ticamente la marcha bas\u00e1ndose en la velocidad actual: 1 2 3 4 5 6 7 class CocheAutomatico : Coche { override var velocidadActual : Double { didSet { marcha = min ( Int ( velocidadActual / 25.0 ) + 1 , 5 ) } } } En cualquier momento que se modifica la propiedad velocidadActual de una instancia de CocheAutomatico , el observador didSet establece la propiedad marcha a un valor apropiado para la nueva velocidad. Un ejemplo de ejecuci\u00f3n: 1 2 3 4 let automatico = CocheAutomatico () automatico . velocidadActual = 100.0 print ( \"CocheAutomatico: \\( automatico . descripcion ) \" ) // CocheAutomatico: viajando a 100.0 kil\u00f3metros por hora con la marcha 5 Por \u00faltimo, es posible prevenir un m\u00e9todo o propiedad de ser sobreescrito declar\u00e1ndolo como final . Para ello, hay que escribir el modificador final antes del nombre de la palabra clave que introduce el m\u00e9todo o la propiedad (como final var , final func ). Tambi\u00e9n es posible marcar la clase completa como final, escribiendo el modificador antes de class ( final class ). Protocolos \u00b6 Un protocolo ( protocol ) define un esquema de m\u00e9todos, propiedades y otros requisitos que encajan en una tarea particular o un trozo de funcionalidad. El protocolo puede luego ser adoptado ( adopted ) por una clase, estructura o enumarci\u00f3n para proporcionar una implementaci\u00f3n real de esos requisitos. Cualquier tipo que satisface los requerimientos de un protocolo se dice que se ajusta o cumple ( conform ) ese protocolo. Adem\u00e1s de especificar los requisitos de los tipos que cumplen el protocolo, tambi\u00e9n se puede extender un protocolo (lo veremos m\u00e1s adelante, cuando hablemos de extensiones ) para proporcionar una implementaci\u00f3n de algunos de los m\u00e9todos requeridos por el protocolo. Sintaxis \u00b6 Los protocolos se definen de forma similar a las clases, estructuras y enumeraciones: 1 2 3 protocol UnProtocolo { // definici\u00f3n del protocolo } Para definir un tipo que se ajusta a un protocolo particular se debe poner el nombre del protocolo tras el nombre del tipo, separado por dos puntos. Podemos listar m\u00e1s de un protocolo, y se separan por comas: 1 2 3 struct UnStruct : PrimerProtocolo , OtroProtocolo { // definici\u00f3n del struct } Si una clase tiene una superclase, se escribe el nombre de la superclase antes de los protocolos, seguido por una coma: 1 2 3 class UnaClase : UnaSuperClase , PrimerProtocolo , OtroProto { // definici\u00f3n de la clase } Requisitos de propiedades \u00b6 Un protocolo puede requerir a cualquier tipo que se ajuste a \u00e9l que proporcione una propiedad de instancia o de tipo con un nombre y tipo particular. El protocolo no especifica si la propiedad es una propiedad calculada o almacenada, s\u00f3lo especifica el nombre y el tipo de la propiedad requerida. El protocolo tambi\u00e9n especifica si la propiedad debe ser de lectura y escritura o s\u00f3lo de lectura. Si un protocolo requiere que una propiedad sea de lectura y escritura, el requisito no puede ser satisfecho por una propiedad constante almacenada o por una propiedad calculada de s\u00f3lo lectura. Si el protocolo s\u00f3lo requiere que la propiedad sea de lectura, el requisito puede ser satisfecho por cualquier tipo de propiedad, y es v\u00e1lido que la propiedad sea tambi\u00e9n de escritura si es \u00fatil para nuestro propio c\u00f3digo. Los requisitos de la propiedad se declaran siempre como propiedades variables, precedido por la palabra clave var . Las propiedades de lectura y escritura se indican escribiendo { get set } despu\u00e9s de la declaraci\u00f3n de su tipo, y las propiedades de s\u00f3lo lectura se indican escribiendo { get } . 1 2 3 4 protocol UnProtocolo { var debeSerEscribible : Int { get set } var noTienePorQueSerEscribible : Int { get } } Para definir una propiedad de tipo hay que precederla en el protocolo con la palabra clave static : 1 2 3 protocol OtroProtocolo { static var unaPropiedadDeTipo : Int { get set } } Veamos un ejemplo. Definimos el protocolo TieneNombre en el que se requiere que cualquier clase que se ajuste a \u00e9l debe tener una propiedad de instancia de lectura de tipo String que se llame nombreCompleto : 1 2 3 protocol TieneNombre { var nombreCompleto : String { get } } Un ejemplo de una sencilla estructura que adopta el protocolo: 1 2 3 4 5 6 7 struct Persona : TieneNombre { var edad : Int var nombreCompleto : String } let john = Persona ( edad : 35 , nombreCompleto : \"John Appleseed\" ) // john.nombreCompleto es \"John Appleseed\" Este ejemplo define una estructure llamada Persona , que representa una persona con una edad y un nombre espec\u00edfico. En la primera l\u00ednea se declara que se adopta el protocolo TieneNombre . Cada instancia de Persona tiene la propiedad almacenada llamada nombreCompleto , que es de tipo String . Esto cumple el \u00fanico requisito del protocolo TieneNombre , y signifca que Persona se ajusta correctamente al protocolo (Swift informa de un error en tiempo de compilaci\u00f3n si un requisito de un protocolo no se cumple). Otro ejemplo de una clase m\u00e1s compleja, que tambi\u00e9n adopta el protocolo: 1 2 3 4 5 6 7 8 9 10 11 12 13 class NaveEstelar : TieneNombre { var prefijo : String ? var nombre : String init ( nombre : String , prefijo : String ? = nil ) { self . nombre = nombre self . prefijo = prefijo } var nombreCompleto : String { return ( prefijo != nil ? prefijo ! + \" \" : \"\" ) + nombre } } var ncc1701 = NaveEstelar ( nombre : \"Enterprise\" , prefijo : \"USS\" ) // ncc1701.nombreCompleto es \"USS Enterprise\" Esta clase implementa el requisito de la propiedad nombreCompleto como una propiedad calculada de solo lectura para una nave estelar. Cada instancia de NavaEstelar almacena un nombre obligatorio y un prefijo opcional. La propiedad nombreCompleto usa el valor del prefijo si existe, y la a\u00f1ade al comienzo del nombre para crear un nombre completo de la nave estelar. Requisitos de m\u00e9todos \u00b6 Los protocolos pueden requerir que los tipos que se ajusten a ellos implementen m\u00e9todos de instancia y de tipos espec\u00edficos. Estos m\u00e9todos se escriben como parte de la definici\u00f3n del protocolo de la misma forma que los m\u00e9todos normales, pero sin sus cuerpos: 1 2 3 protocol UnProtocolo { func unMetodo () -> Int } Los m\u00e9todos del tipo en el protocolo deben indicarse con la palabra clave static : 1 2 3 protocol UnProtocolo { static func unMetodoDelTipo () } Un ejemplo: 1 2 3 protocol GeneradorNumerosAleatorios { func random () -> Double } Este protocolo, GeneradorNumerosAleatorios , requiere que cualquier tipo que se ajuste a \u00e9l tenga un m\u00e9todo de instancia llamado random , que devuelve un valor Double cada vez que se llama. Aunque no est\u00e1 especificado en el protocolo, se asume que este valor ser\u00e1 un n\u00famero entre 0.0 y 1.0 (sin incluirlo). El protocolo GeneradorNumerosAleatorios no hace ninguna suposici\u00f3n sobre c\u00f3mo ser\u00e1 generado cada n\u00famero aleatorio, simplemente requiere al generador que proporcione una forma est\u00e1ndar de generarlo. Una implementaci\u00f3n de una clase que adopta el protocolo: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class GeneradorLinealCongruente : GeneradorNumerosAleatorios { var ultimoRandom = 42.0 let m = 139968.0 let a = 3877.0 let c = 29573.0 func random () -> Double { let number = ultimoRandom * a + c ultimoRandom = number . truncatingRemainder ( dividingBy : m ) return ultimoRandom / m } } let generador = GeneradorLinealCongruente () print ( \"Un n\u00famero aleatorio: \\( generador . random ()) \" ) // Imprime \"Un n\u00famero aleatorio: 0.37464991998171\" print ( \"Y otro: \\( generador . random ()) \" ) // Imprime \"Y otro: 0.729023776863283\" Requisito de m\u00e9todo mutating \u00b6 Si definimos un protocolo con un requisito de m\u00e9todo de instancia que pretenda mutar las instancias del tipo que adopte el protocolo, se debe marcar el m\u00e9todo con la palabra mutating . Esto permite a las estructuras y enumeraciones que adopten el protocolo definir ese m\u00e9todo como mutating . No es necesario hacerlo con las clases, porque la palabra mutating solo es necesaria en estructuras y enumeraciones. Un ejemplo: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 protocol Conmutable { mutating func conmutar () } enum Interruptor : Conmutable { case apagado , encendido mutating func conmutar () { switch self { case . apagado : self = . encendido case . encendido : self = . apagado } } } var interruptorLampara = Interruptor . apagado interruptorLampara . conmutar () // interruptorLampara es ahora igual a .encendido Protocolos como tipos \u00b6 Los protocolos no implementan realmente ninguna funcionalidad por ellos mismos. Sin embargo, cualquier protocolo que definamos se convierte autom\u00e1ticamente en un tipo con todas sus propiedades que podemos usar en nuestro c\u00f3digo. Podemos entonces usar el protocolo en cualquier sitio donde permitamos otros tipos, incluyendo: El tipo de un par\u00e1metro de una funci\u00f3n, m\u00e9todo o inicializador o de sus valores devueltos. El tipo de una constante, variable o propiedad El tipo de los \u00edtems de un array, diccionario u otro contenedor 1 2 3 4 5 6 7 8 9 10 11 class Dado { let caras : Int let generador : GeneradorNumerosAleatorios init ( caras : Int , generador : GeneradorNumerosAleatorios ) { self . caras = caras self . generador = generador } func tirar () -> Int { return Int ( generador . random () * Double ( caras )) + 1 } } Este ejemplo define una nueva clase llamada Dado , que representa un dado de n caras que se puede usar en un juego de tablero. Las instancias de dados tienen una propiedad llamada caras , que representa cu\u00e1ntas caras tienen, y una propiedad llamada generador , que proporciona un generador a partir del cual crear valores de tiradas. La propiedad generador es del tipo GeneradorNumerosAleatorios . Podemos asignarle una instancia de cualquier tipo que adopte el protocolo GeneradorNumerosAleatorios . Dado tiene tambi\u00e9n un inicializador, para configurar sus estado inicial. El inicializador tiene un par\u00e1metro llamado generador , que tambi\u00e9n es del tipo GeneradorNumerosAleatorios . Podemos pasarle un valor de cualquier instancia que se ajuste a este tipo. Y tambi\u00e9n proporciona un m\u00e9todo de instancia llamado tirar , que devuelve un valor entero entre 1 y el n\u00famero de caras del dado. Este m\u00e9todo llama al m\u00e9todo random() del generador para crear un nuevo n\u00famero aleatorio entre 0.0 y 1.0 y usa este n\u00famero aleatorio para crear un valor de tirada que est\u00e9 dentro del rango correcto. Debido a que sabemos que el generador se ajusta al protocolo GeneradorNumerosAleatorios tenemos la garant\u00eda de que va a existir un m\u00e9todo random() al que llamar. Un ejemplo de uso del c\u00f3digo: 1 2 3 4 5 6 7 8 9 var d6 = Dado ( caras : 6 , generador : GeneradorLinealCongruente ()) for _ in 1. .. 5 { print ( \"La tirada del dado es \\( d6 . tirar ()) \" ) } // La tirada del dado es 3 // La tirada del dado es 5 // La tirada del dado es 4 // La tirada del dado es 5 // La tirada del dado es 4 Colecciones de tipos protocolo \u00b6 Como hemos comentado anteriormente, un protocolo puede usarse como el tipo que se almacena un una colecci\u00f3n (array, diccionario, etc.). Veamos un ejemplo: 1 2 3 4 5 6 7 8 9 10 var peterParker = Persona ( edad : 24 , nombreCompleto : \"Peter Parker\" ) var ncc1701 = NaveEstelar ( nombre : \"Enterprise\" , prefijo : \"USS\" ) let cosasConNombre : [ TieneNombre ] = [ peterParker , ncc1701 ] for cosa in cosasConNombre { print ( cosa . nombreCompleto ) } // Peter Parker // USS Enterprise Hay que hacer notar que la constante cosa que itera sobre los elementos del array es de tipo TieneNombre ], no es de tipo Persona ni de tipo NaveEstelar , incluso aunque las instancias que hay tras de escena son do esos tipos. Por ser del tipo TieneNombre sabemos que tiene una propiedad nombreCompleto que podemos usar sobre la variable iteradora. Protocolo Equatable \u00b6 En la biblioteca est\u00e1ndar de Swift se definen distintos protocolos como Collection y Equatable que describen abstracciones comunes. Muchos de estos protocolos incorporan implementaciones por defecto de algunos de sus m\u00e9todos mediante extensiones definidas en la propia biblioteca est\u00e1ndar. Veamos por ejemplo el protocolo Equatable . Se trata de un protocolo importante que define las operaciones de igualdad ( == ) y diferencia ( != ). Debemos implementar la operaci\u00f3n de igualdad en cualquier clase que se ajuste al protocolo, pero la operaci\u00f3n de diferencia ya tiene una implementaci\u00f3n por defecto. Un ejemplo: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Punto3D : Equatable { let x , y , z : Double init ( x : Double , y : Double , z : Double ) { self . x = x self . y = y self . z = z } static func == ( izquierda : Punto3D , derecha : Punto3D ) -> Bool { return izquierda . x == derecha . x && izquierda . y == derecha . y && izquierda . z == derecha . z } } let p1 = Punto3D ( x : 0.0 , y : 0.0 , z : 0.0 ) let p2 = Punto3D ( x : 0.0 , y : 0.0 , z : 0.0 ) print ( p1 == p2 ) // Imprime true print ( p1 != p2 ) // Imprime false El operador == se define en la propia estructura. Se utiliza la palabra static para indicar que se trata de un operador que estamos sobrecargando (hablaremos m\u00e1s adelante de los operadores). El operador != que se usa en la \u00faltima instrucci\u00f3n se define en una implementaci\u00f3n por defecto. En Swift 5 el compilador define una implementaci\u00f3n autom\u00e1tica del operador == en las estructuras y enumeraciones al a\u00f1adir el protocolo Equatable , siempre que las propiedades almacenadas y los valores asociados cumplan ese protocolo. Por ejemplo, si en lugar de una clase definimos un struct Punto3D el c\u00f3digo quedar\u00eda como sigue (no es necesario definir ni el inicializador por defecto ni el operador == ): 1 2 3 4 5 6 7 8 9 10 11 struct Punto3D : Equatable { let x , y , z : Double } let p1 = Punto3D ( x : 0.0 , y : 0.0 , z : 0.0 ) let p2 = Punto3D ( x : 0.0 , y : 0.0 , z : 0.0 ) print ( p1 == p2 ) // Imprime true print ( p1 != p2 ) // Imprime false Casting de tipos \u00b6 El casting de tipos es una forma de comprobar el tipo de una instancia o de tratar esa instancia como de una superclase distinta o conseguir una subclase de alg\u00fan otro sitio en la propia jerarqu\u00eda de clase. La forma de implementarlo es utilizando los operadores is y as . Estos operadores proporcionan una forma simple y expresiva de comprobar el tipo de un valor o transformar un valor en uno de otro tipo. Tambi\u00e9n se puede usar el casting de tipos para comprobar si un tipo se ajusta a un protocolo. Una jerarqu\u00eda de clases para el casting de tipos \u00b6 Vamos a comenzar construyendo una jerarqu\u00eda de clases y subclases con las que trabajar. Utilizaremos el casting de tipos para comprobar el tipo de una instancia particular de una clase y para convertir esa instancia en otra clase dentro de la misma jerarqu\u00eda. En el primer fragmento de c\u00f3digo definimos una clase nueva llamada MediaItem . Esta clase proporciona la funcionalidad b\u00e1sica de cualquier tipo de \u00edtem que aparece en una biblioteca de medios digitales. Espec\u00edficamente, declara una propiedad nombre de tipo String y un inicializador init nombre (suponemos que todos los \u00edtems, incluyendo pel\u00edculas y canciones, tendr\u00e1n un nombre). 1 2 3 4 5 6 class MediaItem { var nombre : String init ( nombre : String ) { self . nombre = nombre } } El siguiente fragmento define dos subclases de MediaItem . La primera subclase, Pelicula , encapsula informaci\u00f3n adicional sobre una pel\u00edcula. A\u00f1ade una propiedad director a la clase base MediaItem , con su correspondiente inicializador. La segunda subclase, Cancion , a\u00f1ade una propiedad artista y un inicializador a la clase base: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Pelicula : MediaItem { var director : String init ( nombre : String , director : String ) { self . director = director super . init ( nombre : nombre ) } } class Cancion : MediaItem { var artista : String init ( nombre : String , artista : String ) { self . artista = artista super . init ( nombre : nombre ) } } Por \u00faltimo, creamos un array constante llamado biblioteca , que contienen dos instancias de Pelicula y tres instancias de Cancion . 1 2 3 4 5 6 7 let biblioteca : [ MediaItem ] = [ Pelicula ( nombre : \"El Se\u00f1or de los Anillos\" , director : \"Peter Jackson\" ), Cancion ( nombre : \"Child in Time\" , artista : \"Deep Purple\" ), Pelicula ( nombre : \"El Puente de los Esp\u00edas\" , director : \"Steven Spielberg\" ), Cancion ( nombre : \"I Wish You Were Here\" , artista : \"Pink Floyd\" ), Cancion ( nombre : \"Yellow\" , artista : \"Coldplay\" ) ] Podr\u00edamos tambi\u00e9n dejar que el compilador infiera el tipo del array. Es capaz de deducir que Pelicula y Cancion tienen una superclase com\u00fan MediaItem , por lo que infiere que el tipo del array es [MediaItem] : 1 2 3 4 5 6 7 8 // Declaraci\u00f3n equivalente a la anterior let biblioteca = [ Pelicula ( nombre : \"El Se\u00f1or de los Anillos\" , director : \"Peter Jackson\" ), Cancion ( nombre : \"Child in Time\" , artista : \"Deep Purple\" ), Pelicula ( nombre : \"El Puente de los Esp\u00edas\" , director : \"Steven Spielberg\" ), Cancion ( nombre : \"I Wish You Were Here\" , artista : \"Pink Floyd\" ), Cancion ( nombre : \"Yellow\" , artista : \"Coldplay\" ) ] Los \u00edtems almacenados en la biblioteca son todav\u00eda instancias de Pelicula y Cancion . Sin embargo, si iteramos sobre los contenidos de este array, los \u00edtems que recibiremos tendr\u00e1n el tipo MediaItem y no Pelicula o Cancion . Para trabajar con ellos como su tipo nativo, debemos chequear su tipo, y hacer un downcast a su tipo concreto. Comprobaci\u00f3n del tipo \u00b6 Podemos usar el operador de comprobaci\u00f3n ( check operator ) is para comprobar si una instancia es de un cierto tipo subclase. El operador de comprobaci\u00f3n devuelve true si la instancia es del tipo de la subclase y false si no. Lo podemos comprobar en el siguiente ejemplo, en el que contamos las instancias de pel\u00edculas y canciones en el array biblioteca : 1 2 3 4 5 6 7 8 9 10 11 12 13 var contadorPeliculas = 0 var contadorCanciones = 0 for item in biblioteca { if item is Pelicula { contadorPeliculas += 1 } else if item is Cancion { contadorCanciones += 1 } } print ( \"La biblioteca contiene \\( contadorCanciones ) pel\u00edculas y \\( contadorPeliculas ) canciones\" ) // Imprime \"La biblioteca contiene 3 pel\u00edculas y 2 canciones\" El ejemplo itera por todos los \u00edtems del array biblioteca . En cada paso, el bucle for-in guarda en la constante item el siguiente MediaItem del array. La instrucci\u00f3n item is Pelicula devuelve true si el MediaItem actual es una instancia de Pelicula y false en otro caso. De forma similar, item is Cancion comprueba si el \u00edtem es una instancia de Cancion . Al final del bucle for-in , los valores de contadorPeliculas y contadorCanciones contendr\u00e1n una cuenta de cuantas instancias MediaItem de cada tipo se han encontrado. Downcasting \u00b6 Una constante o variable de un cierto tipo de clase puede referirse (contener) a una instancia de una subclase. Cuando creemos que sucede esto, podemos intentar hacer un downcast al tipo de la subclase con un operador de cast ( as? o as! ). Como el downcast puede fallar, la versi\u00f3n condicional, as? , devuelve un valor opcional del tipo al que estamos intentando hacer el downcasting . La versi\u00f3n forzosa, as! , intenta el downcast y fuerza la desenvoltura del resultado en un \u00fanica acci\u00f3n compuesta. Debemos usar la versi\u00f3n condicional ( as? ) cuando no estamos seguros si el downcast tendr\u00e1 \u00e9xito. Se devolver\u00e1 un valor opcional y el valor ser\u00e1 nil si no es posible hacer el downcast . Esto permitir\u00e1 comprobar si ha habido un downcast con \u00e9xito. La otra versi\u00f3n ( as! ) se usa s\u00f3lo cuando estamos seguros de que el downcast tendr\u00e1 \u00e9xito. Esta versi\u00f3n del operador lanzar\u00e1 un error en tiempo de ejecuci\u00f3n si intentamos hacer un downcast a un tipo incorrecto. El siguiente ejemplo itera sobre cada MediaItem en biblioteca , e imprime una descripci\u00f3n apropiada para cada \u00edtem. Para hacerlo, necesita acceder a cada \u00edtem como una Pelicula o Cancion y no s\u00f3lo como una MediaItem . Esto es necesario para poder acceder a la propiedad director o artista de una instancia de Pelicula o Cancion . En este ejemplo, cada \u00edtem en el array podr\u00eda ser un Pelicula o podr\u00eda ser una Cancion . No sabemos por anticipado la clase verdadera de cada \u00edtem, por lo que es apropiado usar la versi\u00f3n condicional ( as? ) para comprobar el downcast cada vez a lo largo del bucle: 1 2 3 4 5 6 7 8 9 10 11 12 13 for item in biblioteca { if let pelicula = item as ? Pelicula { print ( \"Pel\u00edcula: \\( pelicula . nombre ) , dir. \\( pelicula . director ) \" ) } else if let cancion = item as ? Cancion { print ( \"Cancion: \\( cancion . nombre ) , de \\( cancion . artista ) \" ) } } // Pel\u00edcula: El Se\u00f1or de los Anillos, dir. Peter Jackson // Cancion: Child in Time, de Deep Purple // Pel\u00edcula: El Puente de los Esp\u00edas, dir. Steven Spielberg // Cancion: I Wish You Were Here, de Pink Floyd // Cancion: Yellow, de Coldplay El ejemplo comienza intentando hacer downcast del \u00edtem a una Pelicula . Debido a que es una instancia de MediaItme , es posible que sea un Pelicula o una Cancion , o incluso el tipo base MediaItem . Debido a esta incertidumbre, debemos usar la versi\u00f3n as? para devolver un valor opcional. El resultado ser\u00e1 una \"Pelicula opcional\". Podemos desenvolver el valor Pelicula usando un if let como vimos en el apartado de opcionales. Si tiene \u00e9xito el downcasting , las propiedades de la pel\u00edcula se pueden usar para imprimir una descripci\u00f3n de la pel\u00edcula llamando a los correspondientes m\u00e9todos de la clase Pelicula . Igual con Cancion . El tipo Any \u00b6 El tipo Any puede representar una instancia de cualquier tipo, incluyendo tipos funci\u00f3n: 1 2 3 4 5 6 7 8 9 10 var array = [ Any ]() array . append ( 0 ) array . append ( 0.0 ) array . append ( 42 ) array . append ( 3.14159 ) array . append ( \"hola\" ) array . append (( 3.0 , 5.0 )) array . append ( Pelicula ( nombre : \"Ghostbusters\" , director : \"Ivan Reitman\" )) array . append ({ ( name : String ) -> String in \"Hola, \\( name ) \" }) El array contiene dos valores Int , dos valores Double , un valor String , una tupla del tipo (Double, Double) , la pel\u00edcula \"Ghostbusters\", y una clausura que toma un String y devuelve otro String . Puedes usar los operadores is y as en una sentencia switch para descubrir en tiempo de ejecuci\u00f3n el tipo espec\u00edfico de una constante o variable de la que s\u00f3lo se sabe que es de tipo Any : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 for item in array { switch item { case 0 as Int : print ( \"cero como un Int\" ) case 0 as Double : print ( \"cero como un Double\" ) case let someInt as Int : print ( \"un valor entero de \\( someInt ) \" ) case let unDouble as Double where unDouble > 0 : print ( \"a valor positivo de \\( unDouble ) \" ) case is Double : print ( \"alg\u00fan otro valor double que no quiero imprimir\" ) case let someString as String : print ( \"una cadena con valor de \\\" \\( someString ) \\\" \" ) case let ( x , y ) as ( Double , Double ): print ( \"un punto (x, y) en \\( x ) , \\( y ) \" ) case let pelicula as Pelicula : print ( \"una pel\u00edcula: \\( pelicula . nombre ) , dir. \\( pelicula . director ) \" ) case let stringConverter as ( String ) -> String : print ( stringConverter ( \"Michael\" )) default : print ( \"alguna otra cosa\" ) } } // cero como un Int // cero como un Double // un valor entero de 42 // a valor positivo de 3.14159 // una cadena con valor de \"hola\" // un punto (x, y) en 3.0, 5.0 // una pel\u00edcula: Ghostbusters, dir. Ivan Reitman // Hola, Michael Comprobaci\u00f3n de ajustarse a un protocolo \u00b6 Podemos usar tambi\u00e9n los operadores anteriores is y as (y as? y as! ) para comprobar si una instancia se ajusta a un protocolo y para hacer un cast a un protocolo espec\u00edfico. Veamos un ejemplo. Definimos el protocolo TieneArea con el \u00fanico requisito de una propiedad de lectura llamada area de tipo Double : 1 2 3 protocol TieneArea { var area : Double { get } } Definimos dos clases Circulo y Pais que se ajustan ambos al protocolo: 1 2 3 4 5 6 7 8 9 10 11 class Circulo : TieneArea { let pi = 3.1415927 var radio : Double var area : Double { return pi * radio * radio } init ( radio : Double ) { self . radio = radio } } class Pais : TieneArea { var area : Double init ( area : Double ) { self . area = area } } La clase Circulo implementa el requisito como una propiedad calculada, basada en la propiedad almacenada radio . La clase Pais implementa el requisito directamente como una propiedad almacenada. Ambas clases se ajustan correctamente al protocolo TieneArea . Definimos una clase Animal que no se ajusta al protocolo: 1 2 3 4 class Animal { var patas : Int init ( patas : Int ) { self . patas = patas } } Las clases Circulo , Pais y Animal no tienen ninguna clase base compartida. Sin embargo, todas son clases, por lo que las instancias de los tres tipos pueden usarse para inicializar un array que almacena valores de tipo Any : 1 2 3 4 5 let objetos : [ Any ] = [ Circulo ( radio : 2.0 ), Pais ( area : 243_610 ), Animal ( patas : 4 ) ] Y ahora podemos iterar sobre el array de objetos, comprobando para cada \u00edtem si la instancia se ajusta al protocolo TieneArea : 1 2 3 4 5 6 7 8 9 10 11 for objecto in objetos { if let objetoConArea = objecto as ? TieneArea { print ( \"El \u00e1rea es \\( objetoConArea . area ) \" ) } else { print ( \"Algo que no tiene un \u00e1rea\" ) } } // El \u00e1rea es 12.5663708 // El \u00e1rea es 243610.0 // Algo que no tiene un \u00e1rea Cuando un objeto en el array se ajusta al protocolo TieneArea , el valor opcional devuelto por el operador as? se desenvuelve con un ligado opcional en una constante llamada objetoConArea . Esta constante tiene el tipo TieneArea , por lo que su propiedad area podr\u00e1 ser accedida e impresa. Hay que notar que los objetos subyacentes no cambian en el proceso de casting . Siguen siendo un Circulo , un Pais y un Animal . Sin embargo, en el momento en se almacenan en la constante objetoConArea , s\u00f3lo se sabe que son del tipo TieneArea , por lo que s\u00f3lo podremos acceder a su propiedad area . Extensiones \u00b6 Las extensiones a\u00f1aden nueva funcionalidad a una clase, estructura, enumeraci\u00f3n o protocolo. Esto incluye la posibilidad de extender tipos para los que no tenemos acceso al c\u00f3digo fuente original (esto se conoce como modelado retroactivo ). Entre otras cosas, las extensiones pueden: A\u00f1adir propiedades calculadas de instancia y de tipo Definir m\u00e9todos de instancia y de tipo Proporcionar nuevos inicializadores Hacer que un tipo existente se ajuste a un protocolo Sintaxis \u00b6 Para declarar una extensi\u00f3n hay que usar la palabra clave extension , indicando despu\u00e9s el tipo que se quiere extender (enumeraci\u00f3n, clase, estructura o protocolo) 1 2 3 extension UnTipoExistente { // nueva funcionalidad para a\u00f1adir a UnTipo } Propiedades calculadas \u00b6 Las extensiones pueden a\u00f1adir propiedades calculadas de instancias y de tipos. Como primer ejemplo, recordemos el tipo Persona : 1 2 3 4 5 6 7 8 protocol TieneNombre { var nombreCompleto : String { get } } struct Persona : TieneNombre { var edad : Int var nombreCompleto : String } Vamos a a\u00f1adir a la estructura la propiedad calculada mayorEdad , un Bool que indica si la edad de la persona es mayor o igual de 18: 1 2 3 4 5 extension Persona { var mayorEdad : Bool { return edad >= 18 } } Una vez definida esta extensi\u00f3n, hemos ampliado la clase con esta nueva propiedad, sin modificar el c\u00f3digo inicial con la definici\u00f3n de la clase. Podemos preguntar si una persona es mayor de edad: 1 2 var p = Persona ( edad : 15 , nombreCompleto : \"Luc\u00eda\" ) p . mayorEdad // false Es posible incluso extender clases de las librer\u00edas est\u00e1ndar de Swift, como Int , Double , Array , etc. Por ejemplo, podemos a\u00f1adir propiedades calculadas a la clase Double para trabajar con unidades de distancia. Las siguientes propiedades convierten una cantidad en las unidades correspondientes a su equivalente en metros: 1 2 3 4 5 6 7 extension Double { var km : Double { return self * 1_000.0 } var m : Double { return self } var cm : Double { return self / 100.0 } var mm : Double { return self / 1_000.0 } var ft : Double { return self / 3.28084 } } Una vez definida la extensi\u00f3n, podemos usarla en cualquier variable Double . Incluso la podemos usar en literales: 1 2 3 4 5 6 7 8 let distancia = 11. km // En distancia tendremos 11000 metros let unaPulgada = 25.4 . mm print ( \"Una pulgada es \\( unaPulgada ) metros\" ) // Una pulgada es 0.0254 metros let tresPies = 3. ft print ( \"Tres pies son \\( tresPies ) metros\" ) // Tres pies son 0.914399970739201 metros Por ejemplo, cuando se escribe 11.km se pide el valor de la propiedad calculada km de la instancia 11 . La propiedad calculada devuelve el resultado de multiplicar 11 por 1000 , esto es, los metros correspondientes a 11 kil\u00f3metros. De forma similar, hay 3.28084 pies en un metro, por lo que la propiedad calculada ft divide el valor Double subyacente por 3.28084, para conventirlo de pies a metros. Estas propiedades son propiedades calculadas de solo lectura, por lo que se expresan sin la palabra clave get , por brevedad. Sus valores devueltos son de tipo Double , y pueden usarse en c\u00e1lculos matem\u00e1ticos en cualquier sitio que se acepte un Double : 1 2 3 let unMaraton = 42. km + 195. m print ( \"Un marat\u00f3n tiene una longitud de \\( unMaraton ) metros\" ) // Un marat\u00f3n tiene una longitud de 42195.0 metros Inicializadores \u00b6 Las extensiones pueden a\u00f1adir nuevos inicializadores a tipos existentes. Esto nos permite extender otros tipos para aceptar nuestros propios tipos como par\u00e1metros de la inicializaci\u00f3n, o para proporcionar opciones adicionales que no estaban incluidos en la implementaci\u00f3n original del tipo. Recordemos la estructura Rectangulo , definida por un Punto y un Tama\u00f1o . Supongamos que la definimos sin inicializadores: 1 2 3 4 5 6 7 8 9 10 struct Tama\u00f1o { var ancho = 0.0 , alto = 0.0 } struct Punto { var x = 0.0 , y = 0.0 } struct Rectangulo { var origen = Punto () var tama\u00f1o = Tama\u00f1o () } Recordemos que debido a que la estructura Rectangulo proporciona valores por defecto para todas sus propiedades, tiene un inicializador por defecto que puede utilizarse para crear nuevas instancias. Tambi\u00e9n podemos inicializarlo asignando todas sus propieades: 1 2 3 let rectanguloPorDefecto = Rectangulo () let rectanguloInicializado = Rectangulo ( origen : Punto ( x : 2.0 , y : 2.0 ), tama\u00f1o : Tama\u00f1o ( ancho : 5.0 , alto : 5.0 )) Podemos ahora extender la estructura Rectangulo para proporcionar un inicializador adicional que toma un punto espec\u00edfico del centro y un tama\u00f1o: 1 2 3 4 5 6 7 extension Rectangulo { init ( centro : Punto , tama\u00f1o : Tama\u00f1o ) { let origenX = centro . x - ( tama\u00f1o . ancho / 2 ) let origenY = centro . y - ( tama\u00f1o . alto / 2 ) self . init ( origen : Punto ( x : origenX , y : origenY ), tama\u00f1o : tama\u00f1o ) } } Este nuevo inicializador empieza por calcular un punto de origen basado en el centro propuesto y en el tama\u00f1o. El inicializador llama despu\u00e9s al inicializador autom\u00e1tico de la estructura init(origen:tama\u00f1o:) , que almacena los nuevos valores de las propiedades: 1 2 3 let rectanguloCentro = Rectangulo ( centro : Punto ( x : 4.0 , y : 4.0 ), tama\u00f1o : Tama\u00f1o ( ancho : 3.0 , alto : 3.0 )) // el origen del rectanguloCentro es is (2.5, 2.5) y su tama\u00f1o es (3.0, 3.0) M\u00e9todos \u00b6 Las extensiones pueden a\u00f1adir nuevos m\u00e9todos de instancia y nuevos m\u00e9todos del tipo. Por ejemplo, podemos a\u00f1adir el m\u00e9todo descripcion() a la estructura Persona : 1 2 3 4 5 6 7 8 extension Persona { func descripcion () -> String { return \"Me llamo \\( nombreCompleto ) y tengo \\( edad ) a\u00f1os\" } } let reedRichards = Persona ( edad : 40 , nombreCompleto : \"Reed Richards\" ) print ( reedRichards . descripcion ()) Tambi\u00e9n podemos a\u00f1adir m\u00e9todos a clases y estructuras importadas. Por ejemplo podemos a\u00f1adir un nuevo m\u00e9todo de instancia llamado repeticiones al tipo Int : 1 2 3 4 5 6 7 extension Int { func repeticiones ( _ tarea : () -> Void ) { for _ in 0. .< self { tarea () } } } El m\u00e9todo repeticiones(_:) toma un \u00fanico argumento de tipo () -> Void , que indica una funci\u00f3n que no tiene par\u00e1metros y no devuelve ning\u00fan valor. Despu\u00e9s de definir esta extensi\u00f3n, podemos llamar al m\u00e9todo repeticiones(_:) en cualquier n\u00famero entero para ejecutar una tarea un cierto n\u00famero de veces: 1 2 3 4 5 6 3. repeticiones ({ print ( \"Hola!\" ) }) // Hola! // Hola! // Hola! Usando clausuras por la cola podemos hacer la llamada m\u00e1s concisa: 1 2 3 4 5 6 3. repeticiones { print ( \"Adios!\" ) } // Adios! // Adios! // Adios! M\u00e9todos de instancia mutadores \u00b6 Los m\u00e9todos de instancia a\u00f1adidos con una extensi\u00f3n tambi\u00e9n pueden modificar (o mutar) la propia instancia. Los m\u00e9todos de las estructuras y los enumerados que modifican self o sus propiedades deben marcarse como mutating . Por ejemplo: 1 2 3 4 5 6 7 8 extension Int { mutating func cuadrado () { self = self * self } } var unInt = 3 unInt . cuadrado () // unInt es ahora 9 Ajustar un tipo a un protocolo mediante una extensi\u00f3n \u00b6 Una extensi\u00f3n puede extender un tipo existente para hacer que se ajuste a uno o m\u00e1s protocolos. En este caso, los nombres de los protocolos se escriben exactamente de la misma forma que en una clase o estructura: 1 2 3 extension UnTipo : UnProtocolo , OtroProtocolo { // implementaci\u00f3n de los requisitos del protocolo } Las instancias del tipo adoptar\u00e1n autom\u00e1ticamente el protocolo y se ajustar\u00e1n al protocolo con las propiedades y m\u00e9todos a\u00f1adidos por la extensi\u00f3n. Por ejemplo, este protocolo, llamado RepresentableComoTexto puede ser implementado por cualquier tipo que tenga una forma de representarse como texto. Esto puede ser una descripci\u00f3n de si mismo o una versi\u00f3n de texto de su estado actual: 1 2 3 protocol RepresentableComoTexto { var descripcionTextual : String { get } } La clase Dado que vimos anteriormente puede extenderse para ajustarse al protocolo: 1 2 3 4 5 extension Dado : RepresentableComoTexto { var descripcionTextual : String { return \"Un dado de \\( caras ) caras\" } } Esta extensi\u00f3n adopta el nuevo protocolo exactamente como si el Dado lo hubiera proporcionado en su implementaci\u00f3n original. El nombre del protocolo se indica tras el nombre del tipo, separado por dos puntos, y se proporciona una implementaci\u00f3n entre llaves. Cualquier instancia de un dado se puede tratar ahora como RepresentableComoTexto : 1 2 3 let d12 = Dado ( caras : 12 , generador : GeneradorLinealCongruente ()) print ( d12 . descripcionTextual ) // Un dado de 12 caras De forma similar, un Rectangulo tambi\u00e9n puede extenderse para adoptar y ajustarse al protocolo: 1 2 3 4 5 6 7 8 9 10 extension Rectangulo : RepresentableComoTexto { var descripcionTextual : String { return \"Un rect\u00e1ngulo situado en ( \\( origen . x ) , \\( origen . y ) )\" } } let rectanguloInicializado = Rectangulo ( origen : Punto ( x : 2.0 , y : 2.0 ), tama\u00f1o : Tama\u00f1o ( ancho : 5.0 , alto : 5.0 )) print ( rectanguloInicializado . descripcionTextual ) // Un rect\u00e1ngulo situado en (2.0, 2.0) Declaraci\u00f3n de la adopci\u00f3n de un protocolo con una extensi\u00f3n \u00b6 Si un tipo ya se ajusta a todos los requisitos de un protocolo, pero todav\u00eda no se ha declarado que se ajusta al protocolo, podemos hacer que lo adopte con una extensi\u00f3n vac\u00eda: 1 2 3 4 5 6 7 struct Hamster { var nombre : String var descripcionTextual : String { return \"Un hamster llamado \\( nombre ) \" } } extension Hamster : RepresentableComoTexto {} Las instancias de Hamster pueden ahora usarse en cualquier sitio que se requiera un tipo RepresentableComoTexto : 1 2 3 4 let simonElHamster = Hamster ( nombre : \"Simon\" ) let algoRepresentableComoTexto : RepresentableComoTexto = simonElHamster print ( algoRepresentableComoTexto . descripcionTextual ) // Un hamster llamado Simon Implementaci\u00f3n de m\u00e9todos de un protocolo \u00b6 Podemos definir extensiones en los protocolos para proporcionar implementaciones de m\u00e9todos y propiedades a todos los tipos que se ajustan a \u00e9l. Esto permite definir conductas en los propios protocolos, m\u00e1s que en cada tipo individual o en una funci\u00f3n global. Por ejemplo, el protocolo GeneradorNumerosAleatorios puede ser extendido para proporcionar un m\u00e9todo boolAleatorio() , que usa el resultado del random() requerido para devolver un valor Bool aleatorio: 1 2 3 4 5 extension GeneradorNumerosAleatorios { func randomBool () -> Bool { return random () > 0.5 } } Al crear una extensi\u00f3n en el protocolo, todos los tipos que se ajustan a \u00e9l adquieren autom\u00e1ticamente esta implementaci\u00f3n sin ninguna modificaci\u00f3n adicional. 1 2 3 4 5 let generator = GeneradorLinealCongruente() print(\"Un n\u00famero aleatorio: \\(generator.random())\") // Imprime \"Un n\u00famero aleatorio: 0.37464991998171\" print(\"Y un booleano aleatorio: \\(generator.randomBool())\") // Imprime \"Un booleano aleatorio: true\" El tipo que se ajusta al protocolo puede proporcionar su propia implementaci\u00f3n, que se usar\u00e1 en lugar de la proporcionada por la extensi\u00f3n. Funciones operadoras \u00b6 Las clases y las estructuras pueden proporcionar sus propias implementaciones de operadores existentes. Esto se conoce como sobrecarga de los operadores existentes. En el siguiente ejemplo se muestra c\u00f3mo implementar el operador de suma ( + ) para una estructura. El operador suma es un operador binario (tiene dos operandos) e infijo (aparece junto entre los dos operandos). Definimos una estructura Vector2D para un vector de posici\u00f3n de dos dimensiones: 1 2 3 4 5 6 struct Vector2D { var x = 0.0 , y = 0.0 static func + ( izquierdo : Vector2D , derecho : Vector2D ) -> Vector2D { return Vector2D ( x : izquierdo . x + derecho . x , y : izquierdo . y + derecho . y ) } } La funci\u00f3n operador se define como una funci\u00f3n est\u00e1tica con un un nombre de funci\u00f3n que empareja con el operador a sobrecargar ( + ). Debido a que la suma aritm\u00e9tica se define como un operador binario, esta funci\u00f3n operador toma dos par\u00e1metros de entrada de tipo Vector2D y devuelve un \u00fanico valor de salida, tambi\u00e9n de tipo Vector2D . En esta implementaci\u00f3n, llamamos a los par\u00e1metros de entrada izquierdo y derecho para representar las instancias de Vector2D que estar\u00e1n a la izquierda y a la derecha del operador + . Son nombres arbitrarios, lo importante es la posici\u00f3n. El primer par\u00e1metro de la funci\u00f3n es el que hace de primer operador. La funci\u00f3n devuelve una nueva instancia de Vector2D , cuyas propiedades x e y se inicializan con la suma de las propiedades x e y de las instancias de Vector2D que se est\u00e1n sumando. La funci\u00f3n se define globalmente, m\u00e1s que como un m\u00e9todo en la estructura Vector2D , para que pueda usarse como un operador infijo entre instancias existentes de Vector2D : 1 2 3 4 let vector = Vector2D ( x : 3.0 , y : 1.0 ) let otroVector = Vector2D ( x : 2.0 , y : 4.0 ) let vectorSuma = vector + otroVector // vectorSuma es una instancia de Vector2D con valores de (5.0, 5.0) Operadores prefijos y postfijos \u00b6 El ejemplo anterior demuestra una implementaci\u00f3n propia de un operador binario infijo. Las clases y las estructuras pueden tambi\u00e9n proporcionar implementaciones de los operadores unarios est\u00e1ndar. Los operadores unarios operan sobre un \u00fanico objetivo. Son prefijos se preceden el objetivo (como -a ) y postfijos si siguen su objetivo (como en b! ). Para implementar un operador unario prefijo o postfijo se debe escribir el modificador prefix o postfix antes de la palabra clave func en la declaraci\u00f3n de la funci\u00f3n operador: 1 2 3 4 5 6 struct Vector2D { ... static prefix func - ( vector : Vector2D ) -> Vector2D { return Vector2D ( x : - vector . x , y : - vector . y ) } } El ejemplo anterior implementa el operador unario negaci\u00f3n ( -a ) para instancias de Vector2D . Por ejemplo: 1 2 3 4 5 let positivo = Vector2D ( x : 3.0 , y : 4.0 ) let negativo = - positivo // negativo es una instancia de Vector2D con valores de (-3.0, -4.0) let tambienPositivo = - negativo // tambienPositivo es una instancia de Vector2D con valores de (3.0, 4.0) Operadores de equivalencia \u00b6 Como ya hemos visto, las clases no tienen una implementaci\u00f3n por defecto de los operadores \"igual a\" ( == ) y \"no igual a\" ( != ), pero las estructuras s\u00ed (a partir de Swift 5). Para comparar dos instancias de una clase debemos proporcionar una implementaci\u00f3n del operador == . A partir de Swift 5 si declaramos que una estructura cumple el protocolo Equatable el compilador de Swift implementar\u00e1 una comparaci\u00f3n por defecto, siempre que todas las propiedades de la estructura sean a su vez Equatable . En Swift 4 para implementar la igualdad en la estructura Vector2D tenemos que definir una extensi\u00f3n que cumple el protocolo Equatable : 1 2 3 4 5 6 // Swift 4 extension Vector2D : Equatable { static func == ( izquierdo : Vector2D , derecho : Vector2D ) -> Bool { return ( izquierdo . x == derecho . x ) && ( izquierdo . y == derecho . y ) } } En el ejemplo anterior se implementa un operador \"igual a\" ( == ) que comprueba si dos instancias de Vector2D tienen valores equivalentes. En el contexto del Vector2D tiene sentido considerar \"igual\" como \"ambas instancias tienen los mismos valores x e y\", por lo que esta es la l\u00f3gica usada por la implementaci\u00f3n. La implementaci\u00f3n del operador \"no igual a\" ( != ) se realiza por defecto como una negaci\u00f3n del anterior. En Swift 5 basta con declarar con la extensi\u00f3n que el Vector2D cumple el protocolo: 1 2 // Swift 5 extension Vector2D : Equatable {} Una vez definido el operador == podemos comparar dos instancias de Vector2D : 1 2 3 4 5 6 7 8 9 let dosTres = Vector2D ( x : 2.0 , y : 3.0 ) let otroDosTres = Vector2D ( x : 2.0 , y : 3.0 ) let unoDos = Vector2D ( x : 1.0 , y : 2.0 ) if dosTres == otroDosTres { print ( \"Los vectores \\( dosTres ) y \\( otroDosTres ) son equivalentes.\" ) } if ( unoDos != dosTres ) { print ( \"Los vectores \\( unoDos ) y \\( dosTres ) son distintos.\" ) } Gen\u00e9ricos \u00b6 Veamos c\u00f3mo podemos utilizar los gen\u00e9ricos con clases y estructuras. Vamos a utilizar como ejemplo un tipo de dato muy sencillo: una pila ( stack ) en la que se podr\u00e1n a\u00f1adir ( push ) y retirar ( pop ) elementos. La versi\u00f3n no gen\u00e9rica del tipo de dato es la siguiente, en la que se implementa una pila de enteros. 1 2 3 4 5 6 7 8 9 struct IntStack { var items = [ Int ]() mutating func push ( _ item : Int ) { items . append ( item ) } mutating func pop () -> Int { return items . removeLast () } } La estructura usa un array para guardar los \u00edtems y los m\u00e9todos push y pop a\u00f1aden y retiran los elementos. El problema de esta estructura es su falta de genericidad; s\u00f3lo puede almacenar enteros. Aqu\u00ed est\u00e1 una versi\u00f3n gen\u00e9rica del mismo c\u00f3digo: 1 2 3 4 5 6 7 8 9 struct Stack < Element > { var items = [ Element ]() mutating func push ( _ item : Element ) { items . append ( item ) } mutating func pop () -> Element { return items . removeLast () } } El par\u00e1metro del tipo Element define un tipo gen\u00e9rico que se utiliza como placeholder del tipo real del que se declare la estructura. Podemos ver que se utiliza en la definici\u00f3n de los distintos elementos de la estructura. Por ejemplo, el array de \u00edtems es un array de Element s. Y los \u00edtems a\u00f1adidos y retirados de la pila son tambi\u00e9n objetos de tipo Element . Por ejemplo, podemos crear una pila de cadenas: 1 2 3 4 5 6 var stackOfStrings = Stack < String >() stackOfStrings . push ( \"uno\" ) stackOfStrings . push ( \"dos\" ) stackOfStrings . push ( \"tres\" ) stackOfStrings . push ( \"cuatro\" ) // la pila contiene ahora 4 cadenas Y podemos retirar la \u00faltima cadena de la pila: 1 let fromTheTop = stackOfStrings . pop () Extensi\u00f3n de un tipo gen\u00e9rico \u00b6 Cuando se extiende un tipo gen\u00e9rico, no hace falta a\u00f1adir el par\u00e1metro del tipo entre <> . El tipo gen\u00e9rico est\u00e1 disponible a partir de la definici\u00f3n original y se puede usar tal cual en el cuerpo de la extensi\u00f3n. Por ejemplo, podemos extender el tipo gen\u00e9rico Stack para a\u00f1adir una propiedad computable de s\u00f3lo lectura que devuelva el tope de la pila: 1 2 3 4 5 extension Stack { var topItem : Element ? { return items . isEmpty ? nil : items [ items . count - 1 ] } } En la extensi\u00f3n se utiliza el nombre gen\u00e9rico Element sin tener que declararlo despu\u00e9s de Stack , porque est\u00e1 definido en la estructura original. Ahora ya se puede acceder al tope de la pila sin retirar el elemento: 1 2 3 4 if let topItem = stackOfStrings . topItem { print ( \"El \u00edtem en el tope de la pila es \\( topItem ) .\" ) } // Imprime \"El \u00edtem en el tope de la pila es tres.\" Restricci\u00f3n en las extensiones de un protocolo \u00b6 En una extensi\u00f3n de un protocolo es posible definir una restricci\u00f3n indicando una condici\u00f3n que se debe cumplir para que la extensi\u00f3n se pueda aplicar. Los m\u00e9todos y propiedades de la extensi\u00f3n s\u00f3lo estar\u00e1n disponibles en aquellos tipos que se ajusten al protocolo y cumplan el requisito. El requisito se definen usando una cl\u00e1usula gen\u00e9rica where en la que se indica una condici\u00f3n sobre alg\u00fan tipo asociado definido en el protocolo. Nota No hemos visto el concepto de tipo asociado en un protocolo. Es una especie de tipo gen\u00e9rico que se define en el protocolo y que se convierte en un tipo concreto en la clase que se ajusta al protocolo. Por ejemplo, podemos definir una extensi\u00f3n al protocolo Collection que se aplique a cualquier colecci\u00f3n cuyos elementos cumplen el protocolo Equatable . De esta forma nos aseguramos de que los operadores == y != est\u00e1n definidos y podemos usarlos en la extensi\u00f3n: 1 2 3 4 5 6 7 8 9 10 extension Collection where Element : Equatable { func allEqual () -> Bool { for element in self { if element != self . first { return false } } return true } } El nombre Element es un nombre definido en el protocolo Collection que se refiere al tipo de los elementos de la colecci\u00f3n. Es un tipo asociado . El m\u00e9todo allEqual() devuelve true si y s\u00f3lo si todos los elementos en la colecci\u00f3n son iguales. Un ejemplo: 1 2 let numerosIguales = [ 100 , 100 , 100 , 100 , 100 ] let numerosDiferentes = [ 100 , 100 , 200 , 100 , 200 ] Dado que ambos arrays cumplen el protocolo Collection y los enteros cumplen el protocolo Equatable podemos usar el m\u00e9todo allEqual() : 1 2 3 4 print(numerosIguales.allEqual()) // Prints \"true\" print(numerosDiferentes.allEqual()) // Prints \"false\" En una colecci\u00f3n cuyos elementos no cumplen el protocolo Equatable no se puede utilizar el m\u00e9todo de la extensi\u00f3n: 1 2 3 4 let tormenta = Persona ( edad : 32 , nombreCompleto : \"Ororo Munroe\" ) let superHeroes = [ tormenta , peterParker , reedRichards ] print ( superHeroes . allEqual ()) //error: type 'Persona' does not conform to protocol 'Equatable' Bibliograf\u00eda \u00b6 Swift Language Guide Classes and Structures Properties Methods Inheritance Initialization Protocolos Casting de tipos Extensiones Funciones operador Gen\u00e9ricos Lenguajes y Paradigmas de Programaci\u00f3n, curso 2018\u201319 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Domingo Gallardo, Cristina Pomares, Antonio Bot\u00eda, Francisco Mart\u00ednez","title":"Tema06 programacion orientada objetos swift"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#tema-6-programacion-orientada-a-objetos-con-swift","text":"","title":"Tema 6: Programaci\u00f3n Orientada a Objetos con Swift"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#mas-conceptos-sobre-clausuras","text":"","title":"M\u00e1s conceptos sobre clausuras"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#repaso-de-clausuras","text":"Ya vimos en el tema anterior que las clausuras en Swift son bloques de c\u00f3digo con funcionalidades que se pueden pasar de un sitio a otro en nuestro programa. Son muy similares a las expresiones lambda de Scheme o de Java 8 o a los bloques de Objective-C. Una clausura puede capturar o almacenar referencias a cualquier constante o variable del contexto o \u00e1mbito dentro de la cual han sido definidas. Se pueden definir clausuras en Swift de las siguientes formas: Funciones anidadas que pueden capturar valores de la funci\u00f3n englobante: 1 2 3 4 5 6 7 8 9 10 11 12 func construyeFunc () -> () -> Int { var x = 0 func funcion () -> Int { x = x + 1 return x } return funcion } let f = construyeFunc () f () // -> 1 f () // -> 2 La funci\u00f3n devuelta por construyeFunc() tambi\u00e9n se puede formular como una expresi\u00f3n de clausura: 1 2 3 4 5 6 7 func construyeFunc () -> () -> Int { var x = 0 return { x = x + 1 return x } } En el siguiente ejemplo vemos claramente que la funci\u00f3n captura las variables definidas en el \u00e1mbito en el que se cre\u00f3. En el caso anterior la clausura devuelta captura la variable x con el valor 0. 1 2 3 4 5 6 7 func usaFunc ( _ f : () -> Int ) -> Int { var x = 4 return f () } let f = construyeFunc () usaFunc ( f ) // -> 1 El valor devuelto por usaFunc en el resultado de la invocaci\u00f3n a f() en su segunda l\u00ednea de c\u00f3digo. Y el valor de x usado por la clausura f es el capturado en el momento de su creaci\u00f3n (el valor x=0 definido en la primera l\u00ednea de construyeFunc ). Funciones an\u00f3nimas que pueden capturar valores del contexto que las rodean: 1 2 var x = 100 usaFunc { return x + 10 } // -> 110 En el ejemplo anterior la expresi\u00f3n de clausura se define en el \u00e1mbito global donde la x toma el valor 100. Ese valor queda capturado y es el que se usa en la evaluaci\u00f3n de la funci\u00f3n. Por tanto, en el contexto donde se eval\u00faa esa clausura (dentro del cuerpo de la funcio\u00f3n usaFunc ), la x que toma es la capturada y no la definida en el cuerpo de usaFunc .","title":"Repaso de clausuras"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#clausuras-escapadas","text":"Se dice que una clausura escapa de una funci\u00f3n cuando la funci\u00f3n recibe una funci\u00f3n o clausura como par\u00e1metro que se llama despu\u00e9s de que la funci\u00f3n finalice su ejecuci\u00f3n. Por ejemplo, definimos un array global de tipo funci\u00f3n: 1 var array : [() -> Int ] = [] Definimos una funci\u00f3n que recibe una clausura como par\u00e1metro, pero no se llama dentro de la funci\u00f3n que la recibe, s\u00f3lo la almacena en el array. Al no ser llamada dentro de la funci\u00f3n, hay que ponerle el atributo @escaping delante del tipo del par\u00e1metro para que Swift permita que sea llamada posteriormente fuera de la funci\u00f3n que la recibe. Si no lo ponemos, el compilador da un error: 1 2 3 4 5 func usaClausura ( _ f : @ escaping () -> Int ) -> Void { array . append ( f ) } usaClausura { return 4 } Se llama posteriormente, fuera de la funci\u00f3n: 1 array [ 0 ]() //-> 4","title":"Clausuras escapadas"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#autoclausuras","text":"Una autoclausura permite crear autom\u00e1ticamente una funci\u00f3n en tiempo de ejecuci\u00f3n sin necesidad de utilizar la sintaxis de las expresiones de clausura. Se puede ver la autoclausura como una forma de retardar la evaluaci\u00f3n, porque esa expresi\u00f3n no se evaluar\u00e1 hasta que se llame a la clausura. Retardar la evaluaci\u00f3n es \u00fatil con trozos de c\u00f3digo que provocan efectos laterales o son costosos computacionalmente, ya que nos permiten controlar el momento de su evaluaci\u00f3n. Por ejemplo, podemos modificar la funci\u00f3n anterior usaFunc a\u00f1adiendo la anotaci\u00f3n @autoclosure antes del tipo del par\u00e1metro clausura: 1 2 3 4 func usaFunc ( _ f : @autoclosure () -> Int ) -> Int { var x = 4 return f () } Al declararlo de esta forma, se puede llamar a usaFunc escribiendo como par\u00e1metro una sentencia que el compilador convierte a clausura: 1 2 var x = 100 usaFunc ( x + 10 ) La expresi\u00f3n x + 10 se considera retardada : se construye una clausura con ella y su evaluaci\u00f3n se realiza dentro de usaFunc . Otro ejemplo en el que podemos comprobar el orden de evaluaci\u00f3n: 1 2 3 4 5 6 7 8 9 10 11 12 func printTest2 ( _ result : @autoclosure () -> Void ) { print ( \"Antes\" ) result () print ( \"Despu\u00e9s\" ) } printTest2 ( print ( \"Hola\" )) // Imprime: // Antes // Hola // Despu\u00e9s La sentencia print(\"Hola\") se pasa como una autoclausura, por lo que el compilador crea autom\u00e1ticamente una clausura con ella sin tener nosotros que escribir la expresi\u00f3n de clausura.","title":"Autoclausuras"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#introduccion-historia-y-caracteristicas-de-la-programacion-orientada-a-objetos","text":"","title":"Introducci\u00f3n, historia y caracter\u00edsticas de la Programaci\u00f3n Orientada a Objetos"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#nacimiento","text":"La Programaci\u00f3n Orientada a Objetos es un paradigma de programaci\u00f3n que explota en los 80 pero nace a partir de ideas a finales de los 60 y 70 Primer lenguaje con las ideas fundamentales de POO: Simula Smalltalk (1980) como lenguaje paradigm\u00e1tica de POO Alan Kay es el creador del t\u00e9rmino \u201cObject-Oriented\u201d y una de las figuras fundamentales de la historia de la inform\u00e1tica moderna. Trabaj\u00f3 en Xerox Park y desarroll\u00f3 all\u00ed ideas que han sido clave para la inform\u00e1tica personal (como el Dynabook, precursor de tablets y dispositivos m\u00f3viles y el lenguajes de programaci\u00f3n Smalltalk) Art\u00edculo de Alan Kay: \u201cThe Early History of Smalltalk\u201d , ACM SIGPLAN, March 1993","title":"Nacimiento"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#alan-kay","text":"\u201cI invented the term Object-Oriented and I can tell you I did not have C++ in mind.\u201d \u201cSmalltalk is not only NOT its syntax or the class library, it is not even about classes. I'm sorry that I long ago coined the term objects for this topic because it gets many people to focus on the lesser idea. The big idea is messaging.\u201d \u201cSmalltalk's design\u2013and existence\u2013is due to the insight that everything we can describe can be represented by the recursive composition of a single kind of behavioral building block that hides its combination of state and process inside itself and can be dealt with only through the exchange of messages.\u201d","title":"Alan Kay"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#interesados-en-smalltalk","text":"Visitar: http://www.squeak.org/ http://swiki.agro.uba.ar/small_land http://www.squeakland.org","title":"\u00bfInteresados en Smalltalk?"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#lenguajes-oo","text":"Smalltalk, Java, Scala, Ruby, Python, C#, C++, Swift, ...","title":"Lenguajes OO"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#del-paradigma-imperativo-al-oo","text":"Programaci\u00f3n procedural: estado abstracto (tipos de datos y barrera de abstracci\u00f3n) + funciones Siguiente paso: agrupar estado y funciones en una \u00fanica entidad Los objetos son estas entidades","title":"Del paradigma imperativo al OO"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#caracteristicas-de-la-poo","text":"Objetos (creados/instanciados en tiempo de ejecuci\u00f3n) y clases (plantillas est\u00e1ticas/tiempo de compilaci\u00f3n) Los objetos agrupan estado y conducta (m\u00e9todos) Los m\u00e9todos se invocan mediante mensajes Dispatch din\u00e1mico : cuando una operaci\u00f3n es invocada sobre un objeto, el propio objeto determina qu\u00e9 c\u00f3digo se ejecuta. Dos objetos con la misma interfaz pueden tener implementaciones distintas. Herencia: las clases se pueden definir utilizando otras clases como plantillas y modificando sus m\u00e9todos y/o variables de instancia.","title":"Caracter\u00edsticas de la POO"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#clases-y-objetos","text":"Objeto: Un objeto contiene un estado (propiedades, atributos o variables de instancia) y un conjunto de funciones (m\u00e9todos) que se ejecutan en el \u00e1mbito del objeto e implementan las funcionalidades soportadas Al ejecutar un m\u00e9todo, el objeto modifica su estado Pedimos a un objeto que ejecute un m\u00e9todo Clase: Una clase es la plantilla que sirve para definir los objetos En una clase se define los elementos que componen el objeto (sus atributos o campos) y sus m\u00e9todos En algunos lenguajes se pueden definir tambi\u00e9n en las clases variables (variables de clase) compartidas por todos los objetos de esa clase","title":"Clases y objetos"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#lenguajes-poo-dinamicos-vs-estaticos","text":"Dos tendencias: Lenguajes din\u00e1micos : muchas caracter\u00edsticas del programa se obtienen en tiempo de ejecuci\u00f3n Mayor flexibilidad y generalidad del c\u00f3digo Dispatch din\u00e1mico Reflexi\u00f3n (posibilidad de consultar caracter\u00edsticas de la instancia (nombres de m\u00e9todos, propiedades, etc.) en tiempo de ejecuci\u00f3n) Ejemplos: Smalltalk, Ruby, Python, JavaScript, Java (en menor medida) Lenguajes est\u00e1ticos : la mayor\u00eda de caracter\u00edsticas del programa se obtienen en tiempo de compilaci\u00f3n Mayor eficiencia Se conoce a priori el tipo de la mayor parte de instancias del programa Fuertemente tipeado Ejemplos: C++, Swift Vamos a detallar a continuaci\u00f3n las caracter\u00edsticas de Programaci\u00f3n Orientada a Objetos de Swift . Para tener una introducci\u00f3n r\u00e1pida puedes empezar leyendo los \u00faltimos apartados del seminario de Swift (los apartados Objetos, clases y estructuras , Protocolos y extensiones y Gen\u00e9ricos ).","title":"Lenguajes POO din\u00e1micos vs. est\u00e1ticos"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#clases-y-estructuras","text":"En el caso de Swift, las clases y las estructuras son muchas m\u00e1s cercanas en funcionalidad que en otros lenguajes, como C o C++, y tienen muchas caracter\u00edsticas comunes. Muchas caracter\u00edsticas de las instancias de una clase se pueden aplicar tambi\u00e9n a las instancias de una estructura. Por eso en Swift se suele hablar de instancias (un t\u00e9rmino m\u00e1s general) en lugar de objetos . Las clases y las estructuras en Swift tienen muchas cosas en com\u00fan. Ambos pueden: Definir propiedades y almacenar valores Definir m\u00e9todos para proporcionar funcionalidad Definir sub\u00edndices para proporcionar acceso a sus valores usando una sintaxis de sub\u00edndice Definir inicializadores para configurar el estado inicial Ser extendidas para expandir su funcionalidad m\u00e1s all\u00e1 de una implementaci\u00f3n por defecto Ajustarse a un protocolo Las clases tienen caracter\u00edsticas adicionales que no tienen las estructuras: Mediante la herencia una clase puede heredar las caracter\u00edsticas de otra El casting de tipos permite comprobar e interpretar el tipo de una instancia de una clase en tiempo de ejecuci\u00f3n Los deinicializadores permiten a una instancia de una clase liberar los recursos que ha asignado Mediante el conteo de referencias se permite que exista m\u00e1s de una referencia a una instancia de una clase","title":"Clases y estructuras"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#definicion","text":"1 2 3 4 5 6 class UnaClase { // definici\u00f3n de clase } struct UnaEstructura { // definici\u00f3n de una estructura } 1 2 3 4 5 6 7 8 9 10 11 12 struct CoordsPantalla { var posX = 0 var posY = 0 } class Ventana { var esquina = CoordsPantalla () var altura = 0 var anchura = 0 var visible = true var etiqueta : String ? } El ejemplo define una nueva estructura llamada CoordsPantalla , que describe una coordenada de pantalla con posiciones basadas en p\u00edxeles. La estructura tiene dos propiedades almacenadas llamadas posX y posY . Las propiedades son constantes o variables que se almacenan en la instancia de la clase o de la estructura. El compilador infiere que estas dos propiedades son Int al inicializarlas a los valores iniciales de 0. El ejemplo tambi\u00e9n define una nueva clase llamada Ventana que describe una ventana en una pantalla. Esta clase tiene cinco propiedades variables. La primera, esquina , se inicializa con una instancia nueva de una estructura CoorsPantalla y se infiere que es de tipo CoordsPantalla . Representa la posici\u00f3n superior izquierda de la pantalla. Las propiedades altura y anchura representan el n\u00famero de p\u00edxeles de las dimensiones de la pantalla. Se inicializan a 0. La propiedad visible es un Bool que indica si la ventana es visible en pantalla. Por ejemplo, una ventana que est\u00e9 minimizada no ser\u00e1 visible. Por \u00faltimo, etiqueta representa el nombre que aparece en la parte superior de la ventana. Es un String opcional que se inicializa a nil porque no se le asigna un valor inicial.","title":"Definici\u00f3n"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#instancias-de-clases-y-estructuras","text":"La definici\u00f3n de las estructuras y las clases \u00fanicamente definen sus aspectos generales. Para describir una configuraci\u00f3n espec\u00edfica (una resoluci\u00f3n o un modo de v\u00eddeo concreto) es necesario crear una instancia de una estructura o una clase. La sintaxis para crear ambas es similar: 1 2 var unasCoordsPantalla = CoordsPantalla () var unaVentana = Ventana () La forma m\u00e1s sencilla de inicializaci\u00f3n es la anterior. Se utiliza el nombre del tipo de la clase o estructura seguidos de par\u00e9ntesis vac\u00edos. Esto crea una nueva instancia de una clase o estructura, con sus propiedades inicializadas a los valores por defecto definidos en la declaraci\u00f3n de las propiedades. Swift proporciona este inicializador por defecto para clases y estructuras, siempre que no se defina alg\u00fan inicializador expl\u00edcito. M\u00e1s adelante comentaremos c\u00f3mo definir estos inicializadores expl\u00edcitos. En el caso de la instancia unasCoordsPantalla los valores a los que se han inicializado sus propiedades son: 1 2 unasCoordsPantalla . posX // 0 unasCoordsPantalla . posY // 0 Las propiedades de la instancia unaVentana son: 1 2 3 4 5 unaVentana . esquina // CoordsPantalla con posX = 0 y posY = 0 unaVentana . altura // 0 unaVentana . anchura // 0 unaVentana . visible // true unaVentana . etiqueta // nil Todas las propiedades de una instancia deben estar definidas despu\u00e9s de haberse inicializado, a no ser que la propiedad se un opcional.","title":"Instancias de clases y estructuras"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#acceso-a-propiedades","text":"Se puede acceder y modificar las propiedades usando la sintaxis de punto : 1 2 3 4 5 // Accedemos a la propiedad coords . posX // Devuelve 0 // Actualizamos la propiedad coords . posX = 100 ventana . esquina . posY = 100","title":"Acceso a propiedades"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#inicializacion-de-las-estructuras-por-sus-propiedades","text":"Si en las estructuras no se se definen inicializadores expl\u00edcitos (veremos m\u00e1s adelante c\u00f3mo hacerlo) podemos utilizar un inicializador memberwise (de todas las propiedades) en el que hay que proporcionar los valores de todas sus propiedades. En las clases no existen los inicializadores memberwise , s\u00f3lo en las estructuras. 1 var coords = CoordsPantalla ( posX : 200 , posY : 400 ) Es necesario inicializar todas las propiedades. Si no, el compilador da un error: 1 2 var coords2 = CoordsPantalla ( posX : 200 ) // error","title":"Inicializaci\u00f3n de las estructuras por sus propiedades"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#estructuras-y-enumeraciones-son-tipos-valor","text":"Un tipo valor es un tipo cuyo valor se copia cuando se asigna a una variable o constante, o cuando se pasa a una funci\u00f3n. Todos los tipos b\u00e1sicos de Swift -enteros, n\u00fameros en punto flotante, cadenas, arrays y diccionarios- son tipos valor y se implementan como estructuras. Las estructuras y las enumeraciones son tipos valor en Swift. 1 2 3 4 var coords1 = CoordsPantalla ( posX : 600 , posY : 600 ) var coords2 = coords1 coords2 . posX = 1000 coords1 . poxX // devuelve 600 En el ejemplo se declara una constante llamada coords1 y se asigna a una instancia de CoordsPantalla inicializada con la posici\u00f3n x de 600 y la posici\u00f3n y de 600. Despu\u00e9s se declara una variable llamada coords2 y se asigna al valor actual de coors1 . Debido a que CoordsPantalla es una estructura, se crea una copia de la instancia existente y esta nueva copia se asigna a coords2 . Aunque ahora coords2 y coords1 tienen las mismas posX y posY , son dos instancias completamente distintas. Despu\u00e9s, la propiedad posX de coords2 se actualiza a 1000. Podemos comprobar que la propiedad se modifica, pero que el valor de posX en coords1 sigue siendo el mismo.","title":"Estructuras y enumeraciones son tipos valor"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#las-clases-son-tipos-referencia","text":"A diferencia de los tipos valor, los tipos de referencias no se copian cuando se asignan o se pasan a funciones. En su lugar se usa una referencia a la misma instancia existente. En Swift las clases son tipos referencias. Veamos, por ejemplo, una instancia de la clase Ventana : 1 2 3 4 5 6 7 8 var ventana1 = Ventana () ventana1 . esquina = coords1 ventana1 . altura = 800 ventana1 . anchura = 800 ventana1 . etiqueta = \"Finder\" var ventana2 = ventana1 ventana2 . anchura = 1000 ventana1 . anchura // devuelve 1000 Declaramos una variable llamada ventana1 inicializada con una instancia nueva de la clase Ventana . Le asignamos a la propiedad esquina una copia de la resoluci\u00f3n anterior coords1 . Despu\u00e9s declaramos la altura, anchura y etiqueta de la ventana. Y, por \u00faltimo, ventana1 se asigna a una nueva constante llamada ventan2 , y la anchura se modifica. Debido a que son tipos de referencia, ventana1 y ventana2 se refieren a la misma instancia de Ventana . Son s\u00f3lo dos nombres distintos para la misma \u00fanica instancia. Lo podemos comprobar modificando una propiedad mediante una variable y viendo que esa misma propiedad en la otra variable se ha modificado tambi\u00e9n (l\u00edneas 7 y 8). Si tienes experiencia con C, C++, o Objective-C, puedes saber que estos lenguajes usan punteros para referirse a una direcci\u00f3n de memoria. Una constante o variable en Swift que se refiere a una instancia de un tipo referencia es similar a un puntero en C, pero no es un puntero que apunta a una direcci\u00f3n de memoria y no requiere que se escriba un asterisco (*) para indicar que estas creando una referencia. En su lugar, estas referencias se definen como cualquier otra constante o variable en Swift.","title":"Las clases son tipos referencia"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#declaracion-de-instancias-con-let","text":"Las estructuras y clases tambi\u00e9n tienen comportamientos distintos cuando se declaran las variables con let . Si definimos con let una instancia de una estructura estamos declarando constante la variable y todas las propiedades de la instancia. No podremos modificar ninguna: 1 2 3 let coords3 = CoordsPantalla ( posX : 400 , posY : 400 ) coords3 . posX = 800 // error: cannot assign to property: 'coords3' is a 'let' constant Si definimos con un let una instancia de una clase s\u00f3lo estamos declarando constante la variable. No podremos reasignarla, pero s\u00ed que podremos modificar las propiedades de la instancia referenciada por la variable: 1 2 3 4 5 6 let ventana3 = Ventana () // S\u00ed que podemos modificar una propiedad de la instancia: ventana3 . etiqueta = \"Listado\" // Pero no podemos reasignar la variable: ventana3 = ventana1 // error: cannot assign to value: 'ventana3' is a 'let' constant","title":"Declaraci\u00f3n de instancias con let"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#operadores-de-identidad","text":"A veces puede ser \u00fatil descubrir si dos constantes o variables se refieren exactamente a la misma instancia de una clase. Para permitir esto, Swift proporciona dos operadores de identidad: Id\u00e9ntico a ( === ) No id\u00e9ntico a ( !== ) 1 2 ventana1 === ventana2 // devuelve true ventana1 === ventana3 // devuelve false Estos operadores \"id\u00e9ntico a\" no son los mismos que los de \"igual a\" (representado por dos signos iguales == ): \"Id\u00e9ntico a\" significa que dos constantes o variables de una clase se refieren exactamente a la misma instancia de la clase. \"Igual a\" significa que dos instancias se consideran \"iguales\" o \"equivalentes\" en su valor. Es responsabilidad del dise\u00f1ador de la clase definir la implementaci\u00f3n de estos operadores.","title":"Operadores de identidad"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#criterios-para-usar-estructuras-y-clases","text":"Podemos usar tanto clases como estructuras para definir nuestros tipos de datos y utilizarlos como bloques de construcci\u00f3n del c\u00f3digo de nuestros programas. Sin embargo, se utilizan para distintos tipos de tareas. Como regla general, utilizaremos una estructura cuando se cumplen una o m\u00e1s de las siguientes condiciones: El principal objetivo de la estructura es encapsular unos pocos datos relativamente sencillos. Es razonable esperar que los valores encapsulados ser\u00e1n copiados, m\u00e1s que referenciados, cuando asignamos o pasamos una instancia de esa estructura. Todas las propiedades almacenadas en la estructura son a su vez tipos valor, que tambi\u00e9n se espera que sean copiados m\u00e1s que referenciados. La estructura no necesita heredar propiedades o conducta de otro tipo existente. Ejemplos de buenos candidatos de estructuras incluyen: El tama\u00f1o de una forma geom\u00e9trica, encapsulando por ejemplo las propiedades ancho y alto de tipo Double . Una forma de referirse a rangos dentro de una serie, encapsulando por ejemplo, una propiedad comienzo y otra longitud , ambos del tipo Int . Un punto en un sistema de coordenadas 3D, encapsulando quiz\u00e1s las propiedades x , y y z , todos ellos de tipo Double . En el resto de casos, definiremos una clase y crearemos instancias de esa clase que tendr\u00e1n que ser gestionadas y pasadas por referencia. En la pr\u00e1ctica, esto representa que la mayor\u00eda de datos que construiremos en nuestros programas deber\u00edan clases, no estructuras. Aunque usaremos muchas de las estructuras est\u00e1ndar de Swift.","title":"Criterios para usar estructuras y clases"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#propiedades","text":"Las propiedades asocian valores con una clase, estructura o enumeraci\u00f3n particular. Las propiedades almacenadas ( stored properties ) almacenan valores constantes y variables como parte de una instancia, mientras que las propiedades calculadas ( computed properties ) calculan (en lugar de almacenar) un valor. Las propiedades calculadas se definen en clases, estructuras y enumeraciones. Las propiedades almacenadas se definen s\u00f3lo en clases y estructuras. Enumeraciones: pueden contener s\u00f3lo propiedades calculadas. Clases y estructuras: pueden contener propiedades almacenadas y calculadas. Las propiedades calculadas y almacenadas se asocian habitualmente con instancias de un tipo particular. Sin embargo, las propiedades tambi\u00e9n pueden asociarse con el propio tipo. Estas propiedades se conocen como propiedades del tipo ( type properties ). Adem\u00e1s, en Swift es posible definir observadores de propiedades que monitoricen cambios en los valores de una propiedad, a los que podemos responder con acciones programadas. Los observadores de propiedades pueden a\u00f1adirse tanto a propiedades almacenadas definidas por nosotros como a propiedades heredadas de la superclase.","title":"Propiedades"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#propiedades-almacenadas","text":"En su forma m\u00e1s simple, una propiedad almacenada es una constante o variable que est\u00e1 almacenada como parte de una instancia de una clase o estructura particular. Las propiedades almacenadas pueden ser o bien variables (usando la palabra clave var ) o bien constantes (usando la palabra clave let ). Podemos proporcionar un valor por defecto para la inicializaci\u00f3n de las propiedades almacenadas, tanto variables como constantes. El siguiente ejemplo define una estructura llamada RangoLongitudFija que describe un rango de valores enteros cuya longitud no puede ser modificada una vez que se crea: 1 2 3 4 5 6 7 8 struct RangoLongitudFija { var primerValor : Int let longitud : Int } var rangoDeTresItemss = RangoLongitudFija ( primerValor : 0 , longitud : 3 ) // el rango representa ahora valores enteros the range represents integer values 0, 1, and 2 rangoDeTresItemss . primerValor = 6 // el rango representa ahora valores enteros 6, 7 y 8 Las instancias de RangoLongitudFija tienen una propiedad almacenada variable llamada primerValor y una propiedad almacenada constante llamada longitud . En el ejemplo, longitud se inicializa cuando se crea el nuevo rango y no puede ser cambiada en el futuro, por ser una propiedad constante.","title":"Propiedades almacenadas"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#propiedades-calculadas","text":"Adem\u00e1s de las propiedades almacenadas, las clases, estructuras y enumeraciones pueden definir propiedades calculadas , que no almacenan realmente un valor. En su lugar, proporcionan un getter y un opcional setter que devuelven y modifican otras propiedades y valores de forma indirecta. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 struct Punto { var x = 0.0 , y = 0.0 } struct Tama\u00f1o { var ancho = 0.0 , alto = 0.0 } struct Rectangulo { var origen = Punto () var tama\u00f1o = Tama\u00f1o () var centro : Punto { get { let centroX = origen . x + ( tama\u00f1o . ancho / 2 ) let centroY = origen . y + ( tama\u00f1o . alto / 2 ) return Punto ( x : centroX , y : centroY ) } set ( centroNuevo ) { origen . x = centroNuevo . x - ( tama\u00f1o . ancho / 2 ) origen . y = centroNuevo . y - ( tama\u00f1o . alto / 2 ) } } } var cuadrado = Rectangulo ( origen : Punto ( x : 0.0 , y : 0.0 ), tama\u00f1o : Tama\u00f1o ( ancho : 10.0 , alto : 10.0 )) let centroCuadradoInicial = cuadrado . centro cuadrado . centro = Punto ( x : 15.0 , y : 15.0 ) print ( \"cuadrado.origen est\u00e1 ahora en ( \\( cuadrado . origen . x ) , \\( cuadrado . origen . y ) )\" ) // Prints \"cuadrado.origen est\u00e1 ahora en (10.0, 10.0)\" Este ejemplo define tres estructuras para trabajar con formas geom\u00e9tricas: Punto encapsula una coordenada (x, y) Tama\u00f1o encapsula un ancho y un alto Rectangulo define una rect\u00e1ngulo por un punto de origen y un tama\u00f1o La estructura Rectangulo proporciona una propiedad calculada llamada centro . La posici\u00f3n actual del centro de un Rectangulo puede ser siempre determinada a partir de su origen y su tama\u00f1o, por lo que no necesitamos almacenarlo como un Punto expl\u00edcito. En su lugar, Rectangulo define un getter y un setter programado para una variable calculada llamada centro , para permitirnos trabajar con el centro del rect\u00e1ngulo como si fuera una propiedad almacenada. En el ejemplo se crea una variable Rectangulo llamada cuadrado . La variable cuadrado se inicializa un punto origen de (0, 0) y un ancho y tama\u00f1o de 10 . Este cuadrado est\u00e1 representado por el cuadrado azul en el diagrama de abajo. Accedemos entonces a la propiedad centro de la variable cuadrado usando la sintaxis del punto ( cuadrado.centro ), lo que causa que se llame al getter de centro para devolver el valor actual de la propiedad. En lugar de devolver los valores existentes, el getter calcula realmente y devuelve un nuevo Punto para representar el centro del cuadrado. Como puede verse arriba, el getter devuelve correctamente un punto con los valores (5, 5) . Despu\u00e9s la propiedad centro se actualiza al nuevo valor de (15, 15) lo que mueve el cuadrado arriba a la derecha, a la nueva posici\u00f3n mostrada por el cuadrado naranja en el diagrama de abajo. Al asignar el nuevo valor a la propiedad se llama al setter del centro, lo que modifica los valores x e y de las propiedades almacenadas originales, y mueve el cuadrado a su nueva posici\u00f3n. Se puede definir una versi\u00f3n acortada del setter usando la variable por defecto newValue que contiene el nuevo valor asignado en el setter : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 struct Rectangulo { var origen = Punto () var tama\u00f1o = Tama\u00f1o () var centro : Punto { get { let centroX = origen . x + ( tama\u00f1o . ancho / 2 ) let centroY = origen . y + ( tama\u00f1o . alto / 2 ) return Punto ( x : centroX , y : centroY ) } set { origen . x = newValue . x - ( tama\u00f1o . ancho / 2 ) origen . y = newValue . y - ( tama\u00f1o . alto / 2 ) } } }","title":"Propiedades calculadas"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#propiedades-solo-lectura","text":"Una propiedad calculada con un getter y sin setter se conoce como una propiedad calculada de solo-lectura. Una propiedad calculada de solo-lectura siempre devuelve un valor, y puede accederse a ella usando la sintaxis de punto, pero no puede modificarse a un valor distinto. Es posible simplificar la declaraci\u00f3n de una propiedad calculada de solo-lectura eliminando la palabra clave get y sus llaves: 1 2 3 4 5 6 7 8 9 struct Cuboide { var ancho = 0.0 , alto = 0.0 , profundo = 0.0 var volumen : Double { return ancho * alto * profundo } } let cuatroPorCincoPorDos = Cuboide ( ancho : 4.0 , alto : 5.0 , profundo : 2.0 ) print ( \"el volumen de cuatroPorCincoPorDos es \\( cuatroPorCincoPorDos . volumen ) \" ) // Imprime \"el volumen de cuatroPorCincoPorDos es 40.0\" Este ejemplo define una nueva estructura llamada Cubiode , que representa una caja rectangular 3D con propiedades ancho , alto y profundo . Esta estructura tiene una propiedad calculada llamada volumen , que calcula y devuelve el volumen actual del cuboide. No tendr\u00eda sentido que el volumen fuera modificable, porque no ser\u00eda ambiguo determinar qu\u00e9 valores concretos de ancho, alto y profundo deber\u00edan usarse para un valor particular del volumen.","title":"Propiedades solo-lectura"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#observadores-de-propiedades","text":"Los observadores de propiedades ( property observers ) observan y responden a cambios en el valor de una propiedad. Los observadores de propiedades se llaman cada vez que el valor de una propiedad es actualizado, incluso si el nuevo valor es el mismo que el valor actual de la propiedad. Se pueden a\u00f1adir observadores a cualquier propiedad almacenada que se definan. Se pueden tambi\u00e9n a\u00f1adir observadores a cualquier propiedad heredada (ya sea almacenada o calculada) sobreescribiendo la propiedad en la subclase. No es necesario definir observadores de propiedades calculadas no sobreescritas porque siempre es posible observar y responder a cambios en su valor en el setter de la propiedad. Es posible definir alguno o ambos de estos observadores sobre una propiedad: willSet es llamado justo antes de que el nuevo valor se almacena en la propiedad. didSet es llamado inmediatamente despu\u00e9s de que el nuevo valor es almacenado en la propiedad. Si implementamos un observador willSet , se le pasa el nuevo valor de la propiedad como un par\u00e1metro constante. Podemos especificar un nombre para este par\u00e1metro como parte de la implementaci\u00f3n de willSet . Si no escribimos el nombre del par\u00e1metro y los par\u00e9ntesis dentro de la implementaci\u00f3n, el par\u00e1metro estar\u00e1 disponible con el nombre por defecto de newValue . De forma similar, si implementamos un observador didSet , se pasa como un par\u00e1metro constante que contiene el valor antiguo de la propiedad. Podemos darle nombre al par\u00e1metro o usar el nombre por defecto de oldValue . Si asignamos un valor a la propiedad dentro de su propio observador didSet , el nuevo valor que asignamos reemplaza el que acaba de a\u00f1adirse a la propiedad. A continuaci\u00f3n podemos ver un ejemplo de willSet y didSet en acci\u00f3n. En \u00e9l definimos una clase nueva llamada CuentaPasos , que hace un seguimiento del n\u00famero total de pasos que una persona hace al caminar. Esta clase puede usarse con datos de entrada de un pod\u00f3metro o cualquier otro sistema de seguir el ejercicio de la persona durante su rutina diaria. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class ContadorPasos { var totalPasos : Int = 0 { willSet ( nuevoTotalPasos ) { print ( \"A punto de actualizar totoalPasos a \\( nuevoTotalPasos ) \" ) } didSet { if totalPasos > oldValue { print ( \"A\u00f1adidos \\( totalPasos - oldValue ) pasos\" ) } } } } let contadorPasos = ContadorPasos () contadorPasos . totalPasos = 200 // Imprime: \"A punto de actualizar totalPasos a 200\" // Imprime: \"A\u00f1adidos 200 pasos\" contadorPasos . totalPasos = 360 // Imprime: \"A punto de actualizar totalPasos a 360\" // Imprime: \"A\u00f1adidos 160 pasos\" contadorPasos . totalPasos = 896 // Imprime: \"A punto de actualizar totalPasos a 896\" // Imprime: \"A\u00f1adidos 536 pasos\" La clase CuentaPasos declara la propiedad totalPasos de tipo Int . Esta es una propiedad almacenada con observadores willSet y didSet . Los observadores willSet y didSet de totalPasos se llaman siempre que se le asigna un nuevo valor a la propiedad. Esto es as\u00ed incluso si el nuevo valor es el mismo que el valor actual. El observador willSet usa un par\u00e1metro definido por nosotros con el nombre de nuevoTotalPasos para el valor que llega. En el ejemplo, sencillamente imprime el valor que est\u00e1 a punto de establecer. El observador didSet se llama despu\u00e9s de que el valor de totalPasos se ha actualizado. Compara el nuevo valor de totalPasos con el valor antiguo. Si el n\u00famero total de pasos se ha incrementado, se imprime un mensaje indicando cu\u00e1ntos pasos se han tomado. El observador didSet no proporciona un par\u00e1metro definido por nosotros para el valor antiguo, sino que usa el nombre por defecto oldValue .","title":"Observadores de propiedades"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#variables-locales-y-globales","text":"Las capacidades anteriores de propiedades calculadas y de observadores tambi\u00e9n est\u00e1n disponibles para variables globales y locales. El siguiente ejemplo muestra un ejemplo con una variable calculada a partir de otras dos: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 var x = 10 { didSet { print ( \"El nuevo valor: \\( x ) y el valor antiguo: \\( oldValue ) \" ) } } var y = 2 * x var z : Int { get { return x + y } set { x = newValue / 2 y = newValue / 2 } } print ( z ) z = 100 print ( x )","title":"Variables locales y globales"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#propiedades-del-tipo","text":"Las propiedades de las instancias son propiedades que pertenecen a una instancia de un tipo particular. Cada vez que creamos una nueva instancia de ese tipo, tiene su propio conjunto de valores de propiedades, separados de los de cualquier otra instancia. Podemos definir tambi\u00e9n propiedades que pertenecen al tipo propiamente dicho, no a ninguna de las instancias de ese tipo. S\u00f3lo habr\u00e1 una copia de estas propiedades, sea cual sea el n\u00famero de instancias de ese tipo que creemos. Estos tipos de propiedades se llaman propiedades del tipo ( type propierties ). Se pueden definir en tanto en estructuras, clases como en enumeraciones. Las propiedades del tipo son \u00fatiles para definir valores que son universales a todas las instancias de un tipo particular, como una propiedad constante que todas las instancias pueden usar (como una constante est\u00e1tica en C), o una propiedad variable que almacena un valor que es global a todas las instancias de ese tipo (como una variable est\u00e1tica en C). Las propiedades del tipo almacenadas pueden ser variables o constantes. Las propiedades del tipo calculadas se declaran siempre como propiedades variables, de la misma forma que las propiedades calculadas de instancias. A diferencia de las propiedades almacenadas de instancias, debemos siempre proporcionar un valor por defecto para las propiedades almacenadas de tipo. Esto es debido a que el tipo por si mismo no tiene un inicializador que pueda asignar un valor en tiempo de inicializaci\u00f3n. En Swift, las propiedades del tipo se definen como parte de la definici\u00f3n del tipo, dentro de las llaves del tipo. Las propiedades del tipo toman valor en el \u00e1mbito del tipo. Para definir una propiedad del tipo hay que usar la palabra clave static . Para propiedades de tipo calculadas de clases, podemos usar en su lugar la palabra clave class para permitir a las subclases que sobreescriban la implementaci\u00f3n de la superclase. Las propiedades del tipo pueden ser tambi\u00e9n constantes ( let ) o variables ( var ). Ejemplo: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 struct UnaEstructura { static var almacenada = \"A\" static var calculada : Int { return 1 } } enum UnaEnumeracion { static var almacenada = \"A\" static var calculada : Int { return 1 } } class UnaClase { static var almacenada = \"A\" static var calculada : Int { return 1 } } Las propiedades del tipo se consultan y actualizan usando tambi\u00e9n la sintaxis de punto, pero sobre el tipo : 1 2 3 UnaEstructura . almacenada // devuelve \"A\" UnaEstructura . almacenada = \"B\" UnaClase . calculada // devuelve 1 No es posible acceder a la variable del tipo a trav\u00e9s de una instancia: 1 2 let a = UnaEstructura () a . almacenada // error El siguiente ejemplo muestra c\u00f3mo es posible usar una variable del tipo para almacenar informaci\u00f3n global a todas las instancias de ese tipo: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 struct Valor { var valor : Int = 0 { didSet { Valor . sumaValores += valor } } static var sumaValores = 0 } var c1 = Valor () var c2 = Valor () var c3 = Valor () c1 . valor = 10 c2 . valor = 20 c3 . valor = 30 print ( \"Suma de los cambios de valores: \\( Valor . sumaValores ) \" ) // Imprime 60","title":"Propiedades del tipo"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#metodos","text":"Los m\u00e9todos son funciones que est\u00e1n asociadas a un tipo particular. Las clases, estructuras y enumeraciones pueden definir todas ellas m\u00e9todos de instancia, que encapsulan tareas y funcionalidades espec\u00edficas que trabajan con una instancia de un tipo dado. Las clases, estructuras y enumeraciones tambi\u00e9n pueden definir m\u00e9todos del tipo, que est\u00e1n asociados con el propio tipo. Los m\u00e9todos del tipo son similares a los m\u00e9todos de clase en Java. El hecho de que las estructuras y las enumeraciones puedan definir m\u00e9todos en Swift es una diferencia importante con C y Objective-C.","title":"M\u00e9todos"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#metodos-de-instancia","text":"Los m\u00e9todos de instancia son funciones que pertenecen a instancias de una clase, estructura o enumeraci\u00f3n. Proporcionan la funcionalidad de esas instancias, bien proporcionando formas de acceder y modificar propiedades de las instancias, o bien proporcionando funcionalidades relacionadas con el prop\u00f3sito de la instancia. Los m\u00e9todos de instancia tienen exactamente la misma sintaxis que las funciones. Los m\u00e9todos de instancia se escriben dentro de las llaves del tipo al que pertenecen. Un m\u00e9todo de instancia tiene acceso impl\u00edcito a todos los otros m\u00e9todos de instancia y propiedades del tipo. Un m\u00e9todo de instancia puede ser invocado s\u00f3lo sobre una instancia espec\u00edfica del tipo al que pertenece. No puede ser invocado de forma aislada sin una instancia existente. A continuaci\u00f3n podemos ver un ejemplo que define una sencilla clase Contador , que puede usarse para contar el n\u00famero de veces que sucede una acci\u00f3n: 1 2 3 4 5 6 7 8 9 10 11 12 class Contador { var veces = 0 func incrementa () { veces += 1 } func incrementa ( en cantidad : Int ) { veces += cantidad } func reset () { veces = 0 } } Y un ejemplo de uso: 1 2 3 4 5 6 7 8 let contador = Contador () // el valor inicial del contador es 0 contador . incrementa () // el valor del contador es ahora 1 contador . incrementa ( en : 5 ) // el valor del contador es ahora 6 contador . reset () // el valor del contador es ahora 0 En el ejemplo anterior, los m\u00e9todos no devuelven ning\u00fan valor. Podemos modificar el ejemplo para que los m\u00e9todos devuelvan el valor actualizado del contador: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Contador { var veces = 0 func incrementa () -> Int { veces += 1 return veces } func incrementa ( en cantidad : Int ) -> Int { veces += cantidad return veces } func reset () -> Int { veces = 0 return veces } }","title":"M\u00e9todos de instancia"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#nombres-locales-y-externos-de-parametros","text":"Ya vimos que los par\u00e1metros de las funciones pueden tener un nombre interno y un nombre externo. Lo mismo sucede con los m\u00e9todos, porque los m\u00e9todos no son m\u00e1s que funciones asociadas con un tipo. Los nombres de los m\u00e9todos en Swift se refieren normalmente al primer par\u00e1metro usando una preposici\u00f3n como con , en , a o por , como hemos visto en el ejemplo anterior incrementa(en:) . El uso de la preposici\u00f3n permite que el m\u00e9todo se lea como una frase. El nombre de una par\u00e1metro se utiliza tambi\u00e9n como etiqueta del argumento (nombre externo). Al igual que en las funciones, es posible definir dos nombres del par\u00e1metro, uno externo y otro interno. Y el nombre externo puede ser un _ para indicar que no es necesario usar la etiqueta del argumento. Esta forma de invocar a los m\u00e9todos hace que el lenguaje sea m\u00e1s expresivo, sin necesidad de nombres largos de m\u00e9todos o funciones. Consideremos por ejemplo esta versi\u00f3n alternativa de la clase Contador , que define una forma m\u00e1s compleja del m\u00e9todo incrementa(en:) : 1 2 3 4 5 6 class Contador { var valor : Int = 0 func incrementa ( en cantidad : Int , numeroDeVeces : Int ) { valor += cantidad * numeroDeVeces } } El m\u00e9todo incrementa(en:numeroDeVeces:) tiene dos par\u00e1metros: cantidad y numeroDeVeces . El primer par\u00e1metro tiene un nombre externo y otro interno. En el cuerpo del m\u00e9todo se utiliza el nombre interno ( cantidad ). El segundo par\u00e1metro numeroDeVeces es tanto nombre externo como interno. Podemos llamar al m\u00e9todo de la siguiente forma: 1 2 3 let contador = Contador () contador . incrementa ( en : 5 , numeroDeVeces : 3 ) // el valor del contador es ahora 15 Al igual que en las funciones, podemos definir expl\u00edcitamente los nombres externos de los par\u00e1metros y usar el subrayado ( _ ) para indicar que ese par\u00e1metro no tendr\u00e1 nombre externo.","title":"Nombres locales y externos de par\u00e1metros"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#la-propiedad-self","text":"Toda instancia de un tipo tiene una propiedad impl\u00edcita llamada self , que es exactamente equivalente a la instancia misma. Podemos usar la propiedad self para referirnos a la instancia actual dentro de sus propios m\u00e9todos de instancia. El m\u00e9todo incrementa() en el ejemplo anterior podr\u00eda haberse escrito de esta forma: 1 2 3 func incrementa () { self . veces += 1 } En la pr\u00e1ctica no es necesario usar self casi nunca. Swift asume que cualquier referencia a una propiedad dentro de un m\u00e9todo se refiere a la propiedad de la instancia. Es obligado usarlo es cuando el nombre de la propiedad coincide con el nombre de un par\u00e1metro. En esta situaci\u00f3n el nombre del par\u00e1metro toma precedencia y es necesario usar self para poder referirse a la propiedad de la instancia. Un ejemplo: 1 2 3 4 5 6 7 8 9 10 11 struct Punto { var x = 0.0 , y = 0.0 func estaAlaDerecha ( de x : Double ) -> Bool { return self . x > x } } let unPunto = Punto ( x : 4.0 , y : 5.0 ) if unPunto . estaAlaDerecha ( de : 1.0 ) { print ( \"Este punto est\u00e1 a la derecha de la l\u00ednea donde x == 1.0\" ) } // Imprime \"Este punto est\u00e1 a la derecha de la l\u00ednea donde x == 1.0\"","title":"La propiedad self"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#operaciones-con-instancias-de-tipo-valor","text":"Las estructuras y las enumeraciones son tipos valor . Por defecto, las propiedades de un tipo valor no pueden ser modificadas desde dentro de los m\u00e9todos de instancia. Si queremos modificar una propiedad de un tipo valor la forma m\u00e1s natural de hacerlo es creando una instancia nueva, usando el estilo de programaci\u00f3n funcional: 1 2 3 4 5 6 7 8 9 10 struct Punto { var x = 0.0 , y = 0.0 func incrementa ( incX : Double , incY : Double ) -> Punto { return Punto ( x : x + incX , y : y + incY ) } } let unPunto = Punto ( x : 1.0 , y : 1.0 ) var puntoMovido = unPunto . incrementa ( incX : 2.0 , incY : 3.0 ) print ( \"Hemos movido el punto a ( \\( puntoMovido . x ) , \\( puntoMovido . y ) )\" ) // Imprime \"Hemos movido el punto a (3.0, 4.0)\"","title":"Operaciones con instancias de tipo valor"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#modificacion-de-tipos-valor-desde-dentro-de-la-instancia","text":"Sin embargo, hay ocasiones en las que necesitamos modificar las propiedades de nuestra estructura o enumeraci\u00f3n dentro de un m\u00e9todo particular. Necesitamos conseguir una conducta mutadora para ese m\u00e9todo. El m\u00e9todo puede mutar (esto es, cambiar) sus propiedades desde dentro del m\u00e9todo, as\u00ed como asignar una instancia completamente nueva a su propiedad impl\u00edcita self , con lo que esta nueva instancia reemplazar\u00e1 la existente cuando el m\u00e9todo termine. Podemos conseguir esta conducta colocando la palabra clave mutating antes de la palabra func del m\u00e9todo: 1 2 3 4 5 6 7 8 9 10 11 struct Punto { var x = 0.0 , y = 0.0 mutating func incrementado ( incX : Double , incY : Double ) { x += incX y += incY } } var unPunto = Punto ( x : 1.0 , y : 1.0 ) unPunto . incrementado ( incX : 2.0 , incY : 3.0 ) print ( \"El punto est\u00e1 ahora en ( \\( unPunto . x ) , \\( unPunto . y ) )\" ) // Imprime \"El punto est\u00e1 ahora en (3.0, 4.0)\" La estructura Punto anterior define un m\u00e9todo mutador incrementado(incX:incY:) que mueve una instancia de Punto una cierta cantidad. En lugar de devolver un nuevo punto, el m\u00e9todo modifica realmente el punto en el que es llamado. La palabra clave mutating se a\u00f1ade a su definici\u00f3n para permitirle modificar sus propiedades. Hay que hacer notar que no es posible llamar a un m\u00e9todo mutador sobre una constante de un tipo estructura, porque sus propiedades no se pueden cambiar, incluso aunque sean propiedades variables: 1 2 3 let puntoFijo = Punto ( x : 3.0 , y : 3.0 ) puntoFijo . incrementado ( incX : 2.0 , incY : 3.0 ) // esto provocar\u00e1 un error","title":"Modificaci\u00f3n de tipos valor desde dentro de la instancia"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#asignacion-a-self-en-un-metodo-mutador","text":"Los m\u00e9todos mutadores pueden asignar una nueva instancia completamente nueva a la propiedad self . El anterior ejemplo Punto podr\u00eda habers escrito de la siguiente forma: 1 2 3 4 5 6 struct Punto { var x = 0.0 , y = 0.0 mutating func incrementa ( incX : Double , incY : Double ) { self = Punto ( x : x + incX , y : y + incY ) } } Esta versi\u00f3n del m\u00e9todo mutador incrementa(incX:incY:) crea una estructura nueva cuyos valores x e y se inicializan a los valores desados. El resutado final de llamar a esta versi\u00f3n alternativa ser\u00e1 exactamente el mismo que llamar a la versi\u00f3n anterior (aunque con una peque\u00f1a penalizaci\u00f3n de eficiencia: este m\u00e9todo es 1,3 veces m\u00e1s lento que el anterior en la versi\u00f3n 2.2 del compilador de Swift). Los m\u00e9todos mutadores de enumeraciones pueden establecer el par\u00e1metro self impl\u00edcito para que tenga un subtipo distinto de la misma enumeraci\u00f3n: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 enum InterruptorTriEstado { case apagado , medio , alto mutating func siguiente () { switch self { case . apagado : self = . medio case . medio : self = . alto case . alto : self = . apagado } } } var luzHorno = InterruptorTriEstado . medio luzHorno . siguiente () // luzHorno es ahora .alto luzHorno . siguiente () // luzHorno es ahora .apagado","title":"Asignaci\u00f3n a self en un m\u00e9todo mutador"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#metodos-del-tipo","text":"Los m\u00e9todos de instancia, como los descritos antes, se llaman en instancias de un tipo particular. Es posible tambi\u00e9n definir m\u00e9todos que se llaman en el propio tipo. Esta clase de m\u00e9todos se denominan m\u00e9todos del tipo . Se define un m\u00e9todo del tipo escribiendo la palabra clave static antes de la palabra clave func del m\u00e9todo. Las clases tambi\u00e9n pueden usar la palabra clave class para permitir a las subclases sobreescribir la implementaci\u00f3n del m\u00e9todo. Los m\u00e9todos del tipo se invocan tambi\u00e9n con la sintaxis de punto, escribiendo el nombre del tipo. Por ejemplo: 1 2 3 4 5 6 class NuevaClase { static func unMetodoDelTipo () { print ( \"Hola desde el tipo\" ) } } NuevaClase . unMetodoDelTipo () Dentro del cuerpo del m\u00e9todo, la propiedad impl\u00edcita self se refiere al propio tipo, m\u00e1s que a una instancia de ese tipo. Para estructuras y enumeraciones, esto significa que puedes usar self para desambiguar entre propiedades del tipo y los par\u00e1metros del m\u00e9todo, de la misma forma que se hace en los m\u00e9todos de instancias. Cualquier nombre de m\u00e9todo o propiedad que se utilice en el cuerpo de un m\u00e9todo del tipo se referir\u00e1 a otras propiedades o m\u00e9todos de nivel del tipo. Se puede utilizar estos nombres sin necesidad de a\u00f1adir el prefijo del nombre del tipo. Por ejemplo, podemos a\u00f1adir a la clase Ventana una propiedad y m\u00e9todo de clase con la que almacenar instancias de ventanas. Inicialmente guardamos un array vac\u00edo. 1 2 3 4 5 6 7 8 9 10 class Ventana { // Propiedades static var ventanas : [ Ventana ] = [] static func registrar ( ventana : Ventana ) { ventanas . append ( ventana ) } } Cada vez que creamos una ventana podemos llamar al m\u00e9todo registrar de la clase para a\u00f1adirlo a la colecci\u00f3n de ventanas de la clase: 1 2 3 4 let v1 = Ventana () Ventana . registrar ( ventana : v1 ) print ( \"Se han registrado \\( Ventana . ventanas . count ) ventanas\" ) // Imprime \"Se han registrado 1 ventanas\"","title":"M\u00e9todos del tipo"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#inicializacion","text":"Inicializaci\u00f3n es el proceso de preparar para su uso una instancia de una clase, estructura o enumeraci\u00f3n. Este proceso incluye la asignaci\u00f3n de un valor inicial para cada propiedad almacenada y la ejecuci\u00f3n de cualquier otra operaci\u00f3n de inicializaci\u00f3n que se necesite para que la nueva instancia est\u00e9 lista para usarse. Para implementar este proceso de inicializaci\u00f3n hay que definir inicializadores , que son como m\u00e9todos especiales que pueden llamarse para crear una nueva instancia de un tipo particular. A diferencia de otros lenguajes, los inicializadores en Swift no devuelven un valor. Su papel principal es que las nuevas instancias del tipo est\u00e9n correctamente inicializadas antes de poder ser usadas por primera vez. Tambi\u00e9n es posible implementar deinicializadores , m\u00e9todos que se ejecutan cuando las instancias son eliminadas de la memoria (no vamos a explicarlos por falta de tiempo). El proceso de inicializaci\u00f3n de una instancia puede resultar un proceso complicado, sobre todo cuando se tienen relaciones de herencia y hay que especificar tambi\u00e9n c\u00f3mo realizar la inicializaci\u00f3n de la subclase utilizando la superclase. Por falta de tiempo no vamos a explicar todo el proceso completo. Recomendamos consultar la documentaci\u00f3n original de Swift .","title":"Inicializaci\u00f3n"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#inicializadores-por-defecto-y-memberwise","text":"Ya hemos visto que es posible inicializar clases y estructuras definiendo valores por defecto a todas sus propiedades (con la posible excepci\u00f3n de las que tienen un tipo opcional). En ese caso, podemos no definir ning\u00fan inicializador y usar el inicializador por defecto que proporciona Swift. 1 2 3 4 5 6 7 8 9 10 struct Punto2D { var x = 0.0 var y = 0.0 } class Segmento { var p1 = Punto2D () var p2 = Punto2D () } var s = Segmento () Tambi\u00e9n es posible en las estructuras utilizar el inicializador memberwise , en el que especificamos todos los valores de las propiedades: 1 var p = Punto2D ( x : 10.0 , y : 10.0 ) Los inicializadores por defecto y memberwise desaparecen en el momento en que definimos alg\u00fan inicializador con la palabra init . Veamos c\u00f3mo definir inicializadores.","title":"Inicializadores por defecto y memberwise"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#inicializacion-de-propiedades-almacenadas","text":"Como hemos dicho, las clases y estructuras deben definir todas sus propiedades almacenadas a un valor inicial en el tiempo en la instancia se crea, a no ser que \u00e9stas sean opcionales, en cuyo caso quedar\u00edan inicializadas a nil . Podemos definir el valor inicial para una propiedad en un inicializador o asign\u00e1ndole un valor por defecto como parte de la definici\u00f3n de la propiedad. Un inicializador , en su forma m\u00e1s simple se escribe con la palabra clave init : 1 2 3 init () { // realizar alguna inicializaci\u00f3n aqu\u00ed } Por ejemplo, podemos definir la estructura Farenheit que almacena una temperatura en grados Farenheit. Tiene una propiedad almacenada de tipo Double . Definimos un inicializador que inicializa las instancias a 32.0 (equivalente a 0.0 grados Celsius). 1 2 3 4 5 6 7 8 9 struct Fahrenheit { var temperatura : Double init () { temperatura = 32.0 } } var f = Fahrenheit () print ( \"La temperatura por defecto es \\( f . temperatura ) Fahrenheit\" ) // Imprime \"La temperatura por defecto es 32.0\u00b0 Fahrenheit\" La implementaci\u00f3n anterior es equivalente a la que ya hemos visto con el inicializador por defecto: 1 2 3 struct Fahrenheit { var temperatura = 32.0 }","title":"Inicializaci\u00f3n de propiedades almacenadas"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#inicializadores-personalizados","text":"Podemos proporcionar par\u00e1metros de inicializaci\u00f3n como parte de la definici\u00f3n de un inicializador, para definir los tipos y los nombres de los valores que personalizan el proceso de inicializaci\u00f3n. Los par\u00e1metros de inicializaci\u00f3n tienen las mismas capacidades y sintaxis que los par\u00e1metros de funciones y m\u00e9todos. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 struct Celsius { var temperaturaEnCelsius : Double init ( desdeFahrenheit fahrenheit : Double ) { temperaturaEnCelsius = ( fahrenheit - 32.0 ) / 1.8 } init ( desdeKelvin kelvin : Double ) { temperaturaEnCelsius = kelvin - 273.15 } } let puntoDeEbullicionDelAgua = Celsius ( desdeFahrenheit : 212.0 ) // puntoDeEbullicionDelAgua.temperaturaEnCelsius es 100.0 let puntoDeCongelacionDelAgua = Celsius ( desdeKelvin : 273.15 ) // puntoDeCongelacionDelAgua.temperaturaEnCelsius is 0.0 Vemos que dependiendo del nombre de par\u00e1metro proporcionado se escoge un inicializador u otro. En los inicializadores es obligatorio proporcionar los nombres de todos los par\u00e1metros: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 struct Color { let rojo , verde , azul : Double init ( rojo : Double , verde : Double , azul : Double ) { self . rojo = rojo self . verde = verde self . azul = azul } init ( blanco : Double ) { rojo = blanco verde = blanco azul = blanco } } let magenta = Color ( rojo : 1.0 , verde : 0.0 , azul : 1.0 ) let medioGris = Color ( blanco : 0.5 ) Podemos evitar proporcionar nombres externos usando un subrayado. Por ejemplo, podemos a\u00f1adir al struct anterior Celsius un inicializador sin nombre externo para el caso en que pasemos la temperatura inicial precisamente en Celsius: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 struct Celsius { var temperaturaEnCelsius : Double init ( desdeFahrenheit fahrenheit : Double ) { temperaturaEnCelsius = ( fahrenheit - 32.0 ) / 1.8 } init ( desdeKelvin kelvin : Double ) { temperaturaEnCelsius = kelvin - 273.15 } init ( _ celsius : Double ) { temperaturaEnCelsius = celsius } } let temperaturaCuerpo = Celsius ( 37.0 ) // temperaturaCuerpo.temperaturaEnCelsius es 37.0 Por \u00faltimo, es posible inicializar propiedades constantes definidas con let . S\u00f3lo toman valor en el momento de la inicializaci\u00f3n y despu\u00e9s no pueden modificarse. 1 2 3 4 5 6 7 8 9 10 11 12 13 class PreguntaEncuesta { let texto : String var respuesta : String ? init ( texto : String ) { self . texto = texto } func pregunta () { print ( texto ) } } let preguntaQueso = PreguntaEncuesta ( texto : \"\u00bfTe gusta el queso?\" ) preguntaQueso . pregunta () // -> \"\u00bfTe gusta el queso? preguntaQueso . respuesta // -> nil La propiedad respuesta se inicializa a nil al ser un opcional y no inicializarla en el inicializador. Por \u00faltimo, es posible definir m\u00e1s de un inicializador, as\u00ed como invocar a inicializadores m\u00e1s b\u00e1sicos desde otros. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 struct Rectangulo { var origen = Punto () var tama\u00f1o = Tama\u00f1o () init (){} init ( origen : Punto , tama\u00f1o : Tama\u00f1o ) { self . origen = origen self . tama\u00f1o = tama\u00f1o } init ( centro : Punto , tama\u00f1o : Tama\u00f1o ) { let origenX = centro . x - ( tama\u00f1o . ancho / 2 ) let origenY = centro . y - ( tama\u00f1o . ancho / 2 ) self . init ( origen : Punto ( x : origenX , y : origenY ), tama\u00f1o : tama\u00f1o ) } } let basicRectangulo = Rectangulo () // el origen de basicRectangulo es (0.0, 0.0) y su tama\u00f1o (0.0, 0.0) let origenRectangulo = Rectangulo ( origen : Punto ( x : 2.0 , y : 2.0 ), tama\u00f1o : Tama\u00f1o ( ancho : 5.0 , alto : 5.0 )) // el origne de origenRectangulo es (2.0, 2.0) y su tama\u00f1o (5.0, 5.0) let centroRectangulo = Rectangulo ( centro : Punto ( x : 4.0 , y : 4.0 ), tama\u00f1o : Tama\u00f1o ( ancho : 3.0 , alto : 3.0 )) // el origen de centroRectangulo es (2.5, 2.5) y su tama\u00f1o (3.0, 3.0) El inicializador init(){} permite inicializar el Rectangulo a los valores por defecto definidos en las propiedades. Proporciona la misma funcionalidad que el inicializador por defecto, que tal y como hemos comentado, no se crea en una estructura o clase en la que definimos sus propios inicializadores.","title":"Inicializadores personalizados"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#herencia","text":"Una clase puede heredar m\u00e9todos, propiedades y otras caracter\u00edsticas de otra clase. Cuando una clase hereda de otra, la clase que hereda se denomina subclase , y la clase de la que se hereda se denomina su superclase . La herencia es una conducta fundamental que diferencia las clases de otros tipos en Swift. Las clases en Swift pueden llamar y acceder a m\u00e9todos y propiedades que pertenecen a su superclase y pueden proporcionar sus propias versiones que sobreescriben esos m\u00e9todos y propiedades. Para sobreescribir un m\u00e9todo o una propiedad es necesario cumplir con la definici\u00f3n proporcionada por la superclase. Las clases tambi\u00e9n pueden a\u00f1adir observadores a las propiedades heredadas para ser notificadas cuando cambia el valor de una propiedad. A cualquier propiedad se le puede a\u00f1adir un observador de propiedad, independientemente de si es originalmente una propiedad almacenada o calculada.","title":"Herencia"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#definicion-de-una-clase-base","text":"Una clase que no hereda de ninguna otra se denomina una clase base ( base class ). A diferencia de otros lenguajes orientados a objetos, las clases en Swift no heredan de una clase base universal. Tambi\u00e9n a diferencia de otros lenguajes orientados a objetos Swift no permite definir clases abstractas que no permiten crear instancias. Cualquier clase en Swift puede ser instanciada. El siguiente ejemplo define una clase base llamada Vehiculo . Esta clase base define una propiedad almacenada llamada velocidadActual con un valor por defecto de 0.0. Esta propiedad se utiliza por una propiedad String calculada llamada descripcion que crea una descripci\u00f3n del veh\u00edculo. La clase base Vehiculo tambi\u00e9n define un m\u00e9todo llamdo hazRuido . Este m\u00e9todo no hace nada realmente para una instancia de un veh\u00edculo base, pero ser\u00e1 modificado m\u00e1s adelante por las subclases de Vehiculo . 1 2 3 4 5 6 7 8 9 class Vehiculo { var velocidadActual = 0.0 var descripcion : String { return \"viajando a \\( velocidadActual ) kil\u00f3metros por hora\" } func hazRuido () { // no hace nada - un veh\u00edculo arbitrario no hace ruido necesariamente } } Creamos una instancia nueva de Vehiculo con la sintaxis de inicializaci\u00f3n que hemos visto, en la que se escribe el nombre del tipo de la clase seguido por par\u00e9ntesis vac\u00edos: 1 let unVehiculo = Vehiculo () Habiendo creado una instancia nueva de Vehiculo , podemos acceder a su descripci\u00f3n: 1 2 print ( \"Veh\u00edculo: \\( unVehiculo . descripcion ) \" ) // Veh\u00edculo: viajando a 0.0 kil\u00f3metros por hora La clase Vehiculo define caracter\u00edsticas comunes para un veh\u00edculo arbitrario, pero no es de mucha utilidad por si misma. Para hacerla m\u00e1s \u00fatil, tenemos que refinarla para describir tipos de veh\u00edculos m\u00e1s espec\u00edficos.","title":"Definici\u00f3n de una clase base"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#construccion-de-subclases","text":"La construcci\u00f3n de una subclase ( subclassing ) es la acci\u00f3n de basar una nueva clase en una clase existente. La subclase hereda caracter\u00edsticas de la clase existente, que despu\u00e9s podemos refinar. Tambi\u00e9n podemos a\u00f1adir nuevas caracter\u00edsticas a la subclase. Para indicar que una subclase tiene una superclase hay que escribir el nombre de la subclase antes de el de la superclase, separadas por dos puntos ( : ): 1 2 3 class UnaSubclase : UnaSuperClase { // definici\u00f3n de la subclase } En el ejemplo anterior del Vehiculo podemos definir una subclase Bicicleta : 1 2 3 class Bicicleta : Vehiculo { var tieneCesta = false } La nueva clase Bicicleta obtiene autom\u00e1ticamente todas las caracter\u00edsticas del Vehiculo , como sus propiedades velocidadActual y descripcion y su m\u00e9todo haceRuido() . Adem\u00e1s de las caracter\u00edsticas que hereda, la clase Bicicleta define una nueva propiedad almacenada, tieneCesta , con un valor por defecto de false . Por defecto, cualquier instancia nueva de Bicicleta no tendr\u00e1 una cesta. Puedes establecer la propiedad tieneCesta a true para una instancia particular de Bicicleta despu\u00e9s de crearla: 1 2 let bicicleta = Bicicleta () bicicleta . tieneCesta = true Podemos tambi\u00e9n modificar la propiedad heredada velocidadActual y preguntar por la propiedad descripcion : 1 2 3 bicicleta . velocidadActual = 10.0 print ( \"Bicicleta: \\( bicicleta . descripcion ) \" ) // Bicicleta: viajando a 10.0 kil\u00f3metros por hora Podemos construir subclases a partir de otras subclases. El siguiente ejemplo crea una subclase de Bicicleta que representa una bicicleta de dos sillines (un \"tandem\"): 1 2 3 class Tandem : Bicicleta { var numeroActualDePasajeros = 0 } Tandem hereda todas las propiedades y m\u00e9todos de Bicicleta , que a su vez hereda todas sus propiedades y m\u00e9todos de Vehiculo . La subclase Tandem tambi\u00e9n a\u00f1ade una nueva propiedad almacenada llamada numeroActualDePasajeros , con un valor por defecto de 0. Si creamos una instancia de Tandem podremos trabajar con cualquiera de sus propiedades nuevas y heredadas, y preguntar a la descripci\u00f3n de solo lectura que hereda de Vehiculo : 1 2 3 4 5 6 let tandem = Tandem () tandem . tieneCesta = true tandem . numeroActualDePasajeros = 2 tandem . velocidadActual = 18.0 print ( \"Tandem: \\( tandem . descripcion ) \" ) // Tandem: viajando a 18.0 kil\u00f3metros por hora","title":"Construcci\u00f3n de subclases"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#sobreescritura","text":"Una subclase puede proporcionar su propia implementaci\u00f3n de un m\u00e9todo de la instancia, m\u00e9todo del tipo, propiedad de la instancia o propiedad del tipo que hereda de su superclase. Esto se conoce como sobreescritura ( overriding ). Para sobreescribir una caracter\u00edstica que ser\u00eda de otra forma heredada debemos usar el prefijo override . De esta forma se clarifica que intentamos proporcionar una sobreescritura y que no lo hacemos por error. Esta palabra clave tambi\u00e9n hace que el compilador comprueba que la superclase (o una de sus clases padre) tiene una declaraci\u00f3n que empareja con la que proporcionamos en la sobreescritura. Cuando proporcionamos una sobreescritura puede ser \u00fatil acceder a los valores proporcionados por la clase padre. Para acceder a ellos podemos usar el prefijo super . El siguiente ejemplo define una nueva subclase de Vehiculo llamada Tren , que sobreescribe el m\u00e9todo hazRuido() : 1 2 3 4 5 class Tren : Vehiculo { override func hazRuido () { print ( \"Chuu Chuu\" ) } } Si creamos una nueva instancia de Tren y llamamos al m\u00e9todo hazRuido podemos comprobar que se llama a la versi\u00f3n del m\u00e9todo de la subclase: 1 2 3 let tren = Tren () tren . hazRuido () // Imprime \"Chuu Chuu\" Podemos sobreescribir cualquier propiedad heredada del tipo o de la instancia y proporcionar nuestros propios getters y setters para esa propiedad, o a\u00f1adir observadores de propiedades para observar cuando cambian los valores subyacentes de la propiedad. Podemos proporcionar un getter (o setter , si es apropiado) para sobreescribir cualquier propiedad heredada, independientemente de si la propiedad heredada se implementa como una propiedad almacenada o calculada. La naturaleza almacenada o calculada no se conoce por la subclase, que solo conoce su nombre y su tipo. Es posible convertir una propiedad heredada de solo-lectura en una de lectura-escritura. No es posible presentar una propiedad heredada de lectura-escritura como de solo-lectura. El siguiente ejemplo define una nueva clase llamada Coche , que es una subclase de Vehiculo . La clase Coche introduce una nueva propiedad almacenada llamada marcha , con un valor por defecto de 1. Tambi\u00e9n sobreescribe la propiedad heredada descripcion , incluyendo la marcha actual en la descripci\u00f3n: 1 2 3 4 5 6 class Coche : Vehiculo { var marcha = 1 override var descripcion : String { return super . descripcion + \" con la marcha \\( marcha ) \" } } Podemos ver el funcionamiento en el siguiente ejemplo: 1 2 3 4 5 let coche = Coche () coche . velocidadActual = 50.0 coche . marcha = 3 print ( \"Coche: \\( coche . descripcion ) \" ) // Coche: viajando a 50.0 kil\u00f3metros por hora con la marcha 3 Por \u00faltimo, podemos a\u00f1adir observadores a propiedades heredadas. Esto nos permite ser notificados cuando el valor de una propiedad heredada cambia, independientemente de si esa propiedad se ha implementado en la subclase o en la superclase. El siguiente ejemplo define una nueva clase llamada CocheAutomatico que es una subclase de Coche . La clase CocheAutomatico representa un coche con una caja de cambios autom\u00e1tica, que selecciona autom\u00e1ticamente la marcha bas\u00e1ndose en la velocidad actual: 1 2 3 4 5 6 7 class CocheAutomatico : Coche { override var velocidadActual : Double { didSet { marcha = min ( Int ( velocidadActual / 25.0 ) + 1 , 5 ) } } } En cualquier momento que se modifica la propiedad velocidadActual de una instancia de CocheAutomatico , el observador didSet establece la propiedad marcha a un valor apropiado para la nueva velocidad. Un ejemplo de ejecuci\u00f3n: 1 2 3 4 let automatico = CocheAutomatico () automatico . velocidadActual = 100.0 print ( \"CocheAutomatico: \\( automatico . descripcion ) \" ) // CocheAutomatico: viajando a 100.0 kil\u00f3metros por hora con la marcha 5 Por \u00faltimo, es posible prevenir un m\u00e9todo o propiedad de ser sobreescrito declar\u00e1ndolo como final . Para ello, hay que escribir el modificador final antes del nombre de la palabra clave que introduce el m\u00e9todo o la propiedad (como final var , final func ). Tambi\u00e9n es posible marcar la clase completa como final, escribiendo el modificador antes de class ( final class ).","title":"Sobreescritura"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#protocolos","text":"Un protocolo ( protocol ) define un esquema de m\u00e9todos, propiedades y otros requisitos que encajan en una tarea particular o un trozo de funcionalidad. El protocolo puede luego ser adoptado ( adopted ) por una clase, estructura o enumarci\u00f3n para proporcionar una implementaci\u00f3n real de esos requisitos. Cualquier tipo que satisface los requerimientos de un protocolo se dice que se ajusta o cumple ( conform ) ese protocolo. Adem\u00e1s de especificar los requisitos de los tipos que cumplen el protocolo, tambi\u00e9n se puede extender un protocolo (lo veremos m\u00e1s adelante, cuando hablemos de extensiones ) para proporcionar una implementaci\u00f3n de algunos de los m\u00e9todos requeridos por el protocolo.","title":"Protocolos"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#sintaxis","text":"Los protocolos se definen de forma similar a las clases, estructuras y enumeraciones: 1 2 3 protocol UnProtocolo { // definici\u00f3n del protocolo } Para definir un tipo que se ajusta a un protocolo particular se debe poner el nombre del protocolo tras el nombre del tipo, separado por dos puntos. Podemos listar m\u00e1s de un protocolo, y se separan por comas: 1 2 3 struct UnStruct : PrimerProtocolo , OtroProtocolo { // definici\u00f3n del struct } Si una clase tiene una superclase, se escribe el nombre de la superclase antes de los protocolos, seguido por una coma: 1 2 3 class UnaClase : UnaSuperClase , PrimerProtocolo , OtroProto { // definici\u00f3n de la clase }","title":"Sintaxis"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#requisitos-de-propiedades","text":"Un protocolo puede requerir a cualquier tipo que se ajuste a \u00e9l que proporcione una propiedad de instancia o de tipo con un nombre y tipo particular. El protocolo no especifica si la propiedad es una propiedad calculada o almacenada, s\u00f3lo especifica el nombre y el tipo de la propiedad requerida. El protocolo tambi\u00e9n especifica si la propiedad debe ser de lectura y escritura o s\u00f3lo de lectura. Si un protocolo requiere que una propiedad sea de lectura y escritura, el requisito no puede ser satisfecho por una propiedad constante almacenada o por una propiedad calculada de s\u00f3lo lectura. Si el protocolo s\u00f3lo requiere que la propiedad sea de lectura, el requisito puede ser satisfecho por cualquier tipo de propiedad, y es v\u00e1lido que la propiedad sea tambi\u00e9n de escritura si es \u00fatil para nuestro propio c\u00f3digo. Los requisitos de la propiedad se declaran siempre como propiedades variables, precedido por la palabra clave var . Las propiedades de lectura y escritura se indican escribiendo { get set } despu\u00e9s de la declaraci\u00f3n de su tipo, y las propiedades de s\u00f3lo lectura se indican escribiendo { get } . 1 2 3 4 protocol UnProtocolo { var debeSerEscribible : Int { get set } var noTienePorQueSerEscribible : Int { get } } Para definir una propiedad de tipo hay que precederla en el protocolo con la palabra clave static : 1 2 3 protocol OtroProtocolo { static var unaPropiedadDeTipo : Int { get set } } Veamos un ejemplo. Definimos el protocolo TieneNombre en el que se requiere que cualquier clase que se ajuste a \u00e9l debe tener una propiedad de instancia de lectura de tipo String que se llame nombreCompleto : 1 2 3 protocol TieneNombre { var nombreCompleto : String { get } } Un ejemplo de una sencilla estructura que adopta el protocolo: 1 2 3 4 5 6 7 struct Persona : TieneNombre { var edad : Int var nombreCompleto : String } let john = Persona ( edad : 35 , nombreCompleto : \"John Appleseed\" ) // john.nombreCompleto es \"John Appleseed\" Este ejemplo define una estructure llamada Persona , que representa una persona con una edad y un nombre espec\u00edfico. En la primera l\u00ednea se declara que se adopta el protocolo TieneNombre . Cada instancia de Persona tiene la propiedad almacenada llamada nombreCompleto , que es de tipo String . Esto cumple el \u00fanico requisito del protocolo TieneNombre , y signifca que Persona se ajusta correctamente al protocolo (Swift informa de un error en tiempo de compilaci\u00f3n si un requisito de un protocolo no se cumple). Otro ejemplo de una clase m\u00e1s compleja, que tambi\u00e9n adopta el protocolo: 1 2 3 4 5 6 7 8 9 10 11 12 13 class NaveEstelar : TieneNombre { var prefijo : String ? var nombre : String init ( nombre : String , prefijo : String ? = nil ) { self . nombre = nombre self . prefijo = prefijo } var nombreCompleto : String { return ( prefijo != nil ? prefijo ! + \" \" : \"\" ) + nombre } } var ncc1701 = NaveEstelar ( nombre : \"Enterprise\" , prefijo : \"USS\" ) // ncc1701.nombreCompleto es \"USS Enterprise\" Esta clase implementa el requisito de la propiedad nombreCompleto como una propiedad calculada de solo lectura para una nave estelar. Cada instancia de NavaEstelar almacena un nombre obligatorio y un prefijo opcional. La propiedad nombreCompleto usa el valor del prefijo si existe, y la a\u00f1ade al comienzo del nombre para crear un nombre completo de la nave estelar.","title":"Requisitos de propiedades"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#requisitos-de-metodos","text":"Los protocolos pueden requerir que los tipos que se ajusten a ellos implementen m\u00e9todos de instancia y de tipos espec\u00edficos. Estos m\u00e9todos se escriben como parte de la definici\u00f3n del protocolo de la misma forma que los m\u00e9todos normales, pero sin sus cuerpos: 1 2 3 protocol UnProtocolo { func unMetodo () -> Int } Los m\u00e9todos del tipo en el protocolo deben indicarse con la palabra clave static : 1 2 3 protocol UnProtocolo { static func unMetodoDelTipo () } Un ejemplo: 1 2 3 protocol GeneradorNumerosAleatorios { func random () -> Double } Este protocolo, GeneradorNumerosAleatorios , requiere que cualquier tipo que se ajuste a \u00e9l tenga un m\u00e9todo de instancia llamado random , que devuelve un valor Double cada vez que se llama. Aunque no est\u00e1 especificado en el protocolo, se asume que este valor ser\u00e1 un n\u00famero entre 0.0 y 1.0 (sin incluirlo). El protocolo GeneradorNumerosAleatorios no hace ninguna suposici\u00f3n sobre c\u00f3mo ser\u00e1 generado cada n\u00famero aleatorio, simplemente requiere al generador que proporcione una forma est\u00e1ndar de generarlo. Una implementaci\u00f3n de una clase que adopta el protocolo: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class GeneradorLinealCongruente : GeneradorNumerosAleatorios { var ultimoRandom = 42.0 let m = 139968.0 let a = 3877.0 let c = 29573.0 func random () -> Double { let number = ultimoRandom * a + c ultimoRandom = number . truncatingRemainder ( dividingBy : m ) return ultimoRandom / m } } let generador = GeneradorLinealCongruente () print ( \"Un n\u00famero aleatorio: \\( generador . random ()) \" ) // Imprime \"Un n\u00famero aleatorio: 0.37464991998171\" print ( \"Y otro: \\( generador . random ()) \" ) // Imprime \"Y otro: 0.729023776863283\"","title":"Requisitos de m\u00e9todos"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#requisito-de-metodo-mutating","text":"Si definimos un protocolo con un requisito de m\u00e9todo de instancia que pretenda mutar las instancias del tipo que adopte el protocolo, se debe marcar el m\u00e9todo con la palabra mutating . Esto permite a las estructuras y enumeraciones que adopten el protocolo definir ese m\u00e9todo como mutating . No es necesario hacerlo con las clases, porque la palabra mutating solo es necesaria en estructuras y enumeraciones. Un ejemplo: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 protocol Conmutable { mutating func conmutar () } enum Interruptor : Conmutable { case apagado , encendido mutating func conmutar () { switch self { case . apagado : self = . encendido case . encendido : self = . apagado } } } var interruptorLampara = Interruptor . apagado interruptorLampara . conmutar () // interruptorLampara es ahora igual a .encendido","title":"Requisito de m\u00e9todo mutating"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#protocolos-como-tipos","text":"Los protocolos no implementan realmente ninguna funcionalidad por ellos mismos. Sin embargo, cualquier protocolo que definamos se convierte autom\u00e1ticamente en un tipo con todas sus propiedades que podemos usar en nuestro c\u00f3digo. Podemos entonces usar el protocolo en cualquier sitio donde permitamos otros tipos, incluyendo: El tipo de un par\u00e1metro de una funci\u00f3n, m\u00e9todo o inicializador o de sus valores devueltos. El tipo de una constante, variable o propiedad El tipo de los \u00edtems de un array, diccionario u otro contenedor 1 2 3 4 5 6 7 8 9 10 11 class Dado { let caras : Int let generador : GeneradorNumerosAleatorios init ( caras : Int , generador : GeneradorNumerosAleatorios ) { self . caras = caras self . generador = generador } func tirar () -> Int { return Int ( generador . random () * Double ( caras )) + 1 } } Este ejemplo define una nueva clase llamada Dado , que representa un dado de n caras que se puede usar en un juego de tablero. Las instancias de dados tienen una propiedad llamada caras , que representa cu\u00e1ntas caras tienen, y una propiedad llamada generador , que proporciona un generador a partir del cual crear valores de tiradas. La propiedad generador es del tipo GeneradorNumerosAleatorios . Podemos asignarle una instancia de cualquier tipo que adopte el protocolo GeneradorNumerosAleatorios . Dado tiene tambi\u00e9n un inicializador, para configurar sus estado inicial. El inicializador tiene un par\u00e1metro llamado generador , que tambi\u00e9n es del tipo GeneradorNumerosAleatorios . Podemos pasarle un valor de cualquier instancia que se ajuste a este tipo. Y tambi\u00e9n proporciona un m\u00e9todo de instancia llamado tirar , que devuelve un valor entero entre 1 y el n\u00famero de caras del dado. Este m\u00e9todo llama al m\u00e9todo random() del generador para crear un nuevo n\u00famero aleatorio entre 0.0 y 1.0 y usa este n\u00famero aleatorio para crear un valor de tirada que est\u00e9 dentro del rango correcto. Debido a que sabemos que el generador se ajusta al protocolo GeneradorNumerosAleatorios tenemos la garant\u00eda de que va a existir un m\u00e9todo random() al que llamar. Un ejemplo de uso del c\u00f3digo: 1 2 3 4 5 6 7 8 9 var d6 = Dado ( caras : 6 , generador : GeneradorLinealCongruente ()) for _ in 1. .. 5 { print ( \"La tirada del dado es \\( d6 . tirar ()) \" ) } // La tirada del dado es 3 // La tirada del dado es 5 // La tirada del dado es 4 // La tirada del dado es 5 // La tirada del dado es 4","title":"Protocolos como tipos"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#colecciones-de-tipos-protocolo","text":"Como hemos comentado anteriormente, un protocolo puede usarse como el tipo que se almacena un una colecci\u00f3n (array, diccionario, etc.). Veamos un ejemplo: 1 2 3 4 5 6 7 8 9 10 var peterParker = Persona ( edad : 24 , nombreCompleto : \"Peter Parker\" ) var ncc1701 = NaveEstelar ( nombre : \"Enterprise\" , prefijo : \"USS\" ) let cosasConNombre : [ TieneNombre ] = [ peterParker , ncc1701 ] for cosa in cosasConNombre { print ( cosa . nombreCompleto ) } // Peter Parker // USS Enterprise Hay que hacer notar que la constante cosa que itera sobre los elementos del array es de tipo TieneNombre ], no es de tipo Persona ni de tipo NaveEstelar , incluso aunque las instancias que hay tras de escena son do esos tipos. Por ser del tipo TieneNombre sabemos que tiene una propiedad nombreCompleto que podemos usar sobre la variable iteradora.","title":"Colecciones de tipos protocolo"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#protocolo-equatable","text":"En la biblioteca est\u00e1ndar de Swift se definen distintos protocolos como Collection y Equatable que describen abstracciones comunes. Muchos de estos protocolos incorporan implementaciones por defecto de algunos de sus m\u00e9todos mediante extensiones definidas en la propia biblioteca est\u00e1ndar. Veamos por ejemplo el protocolo Equatable . Se trata de un protocolo importante que define las operaciones de igualdad ( == ) y diferencia ( != ). Debemos implementar la operaci\u00f3n de igualdad en cualquier clase que se ajuste al protocolo, pero la operaci\u00f3n de diferencia ya tiene una implementaci\u00f3n por defecto. Un ejemplo: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Punto3D : Equatable { let x , y , z : Double init ( x : Double , y : Double , z : Double ) { self . x = x self . y = y self . z = z } static func == ( izquierda : Punto3D , derecha : Punto3D ) -> Bool { return izquierda . x == derecha . x && izquierda . y == derecha . y && izquierda . z == derecha . z } } let p1 = Punto3D ( x : 0.0 , y : 0.0 , z : 0.0 ) let p2 = Punto3D ( x : 0.0 , y : 0.0 , z : 0.0 ) print ( p1 == p2 ) // Imprime true print ( p1 != p2 ) // Imprime false El operador == se define en la propia estructura. Se utiliza la palabra static para indicar que se trata de un operador que estamos sobrecargando (hablaremos m\u00e1s adelante de los operadores). El operador != que se usa en la \u00faltima instrucci\u00f3n se define en una implementaci\u00f3n por defecto. En Swift 5 el compilador define una implementaci\u00f3n autom\u00e1tica del operador == en las estructuras y enumeraciones al a\u00f1adir el protocolo Equatable , siempre que las propiedades almacenadas y los valores asociados cumplan ese protocolo. Por ejemplo, si en lugar de una clase definimos un struct Punto3D el c\u00f3digo quedar\u00eda como sigue (no es necesario definir ni el inicializador por defecto ni el operador == ): 1 2 3 4 5 6 7 8 9 10 11 struct Punto3D : Equatable { let x , y , z : Double } let p1 = Punto3D ( x : 0.0 , y : 0.0 , z : 0.0 ) let p2 = Punto3D ( x : 0.0 , y : 0.0 , z : 0.0 ) print ( p1 == p2 ) // Imprime true print ( p1 != p2 ) // Imprime false","title":"Protocolo Equatable"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#casting-de-tipos","text":"El casting de tipos es una forma de comprobar el tipo de una instancia o de tratar esa instancia como de una superclase distinta o conseguir una subclase de alg\u00fan otro sitio en la propia jerarqu\u00eda de clase. La forma de implementarlo es utilizando los operadores is y as . Estos operadores proporcionan una forma simple y expresiva de comprobar el tipo de un valor o transformar un valor en uno de otro tipo. Tambi\u00e9n se puede usar el casting de tipos para comprobar si un tipo se ajusta a un protocolo.","title":"Casting de tipos"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#una-jerarquia-de-clases-para-el-casting-de-tipos","text":"Vamos a comenzar construyendo una jerarqu\u00eda de clases y subclases con las que trabajar. Utilizaremos el casting de tipos para comprobar el tipo de una instancia particular de una clase y para convertir esa instancia en otra clase dentro de la misma jerarqu\u00eda. En el primer fragmento de c\u00f3digo definimos una clase nueva llamada MediaItem . Esta clase proporciona la funcionalidad b\u00e1sica de cualquier tipo de \u00edtem que aparece en una biblioteca de medios digitales. Espec\u00edficamente, declara una propiedad nombre de tipo String y un inicializador init nombre (suponemos que todos los \u00edtems, incluyendo pel\u00edculas y canciones, tendr\u00e1n un nombre). 1 2 3 4 5 6 class MediaItem { var nombre : String init ( nombre : String ) { self . nombre = nombre } } El siguiente fragmento define dos subclases de MediaItem . La primera subclase, Pelicula , encapsula informaci\u00f3n adicional sobre una pel\u00edcula. A\u00f1ade una propiedad director a la clase base MediaItem , con su correspondiente inicializador. La segunda subclase, Cancion , a\u00f1ade una propiedad artista y un inicializador a la clase base: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Pelicula : MediaItem { var director : String init ( nombre : String , director : String ) { self . director = director super . init ( nombre : nombre ) } } class Cancion : MediaItem { var artista : String init ( nombre : String , artista : String ) { self . artista = artista super . init ( nombre : nombre ) } } Por \u00faltimo, creamos un array constante llamado biblioteca , que contienen dos instancias de Pelicula y tres instancias de Cancion . 1 2 3 4 5 6 7 let biblioteca : [ MediaItem ] = [ Pelicula ( nombre : \"El Se\u00f1or de los Anillos\" , director : \"Peter Jackson\" ), Cancion ( nombre : \"Child in Time\" , artista : \"Deep Purple\" ), Pelicula ( nombre : \"El Puente de los Esp\u00edas\" , director : \"Steven Spielberg\" ), Cancion ( nombre : \"I Wish You Were Here\" , artista : \"Pink Floyd\" ), Cancion ( nombre : \"Yellow\" , artista : \"Coldplay\" ) ] Podr\u00edamos tambi\u00e9n dejar que el compilador infiera el tipo del array. Es capaz de deducir que Pelicula y Cancion tienen una superclase com\u00fan MediaItem , por lo que infiere que el tipo del array es [MediaItem] : 1 2 3 4 5 6 7 8 // Declaraci\u00f3n equivalente a la anterior let biblioteca = [ Pelicula ( nombre : \"El Se\u00f1or de los Anillos\" , director : \"Peter Jackson\" ), Cancion ( nombre : \"Child in Time\" , artista : \"Deep Purple\" ), Pelicula ( nombre : \"El Puente de los Esp\u00edas\" , director : \"Steven Spielberg\" ), Cancion ( nombre : \"I Wish You Were Here\" , artista : \"Pink Floyd\" ), Cancion ( nombre : \"Yellow\" , artista : \"Coldplay\" ) ] Los \u00edtems almacenados en la biblioteca son todav\u00eda instancias de Pelicula y Cancion . Sin embargo, si iteramos sobre los contenidos de este array, los \u00edtems que recibiremos tendr\u00e1n el tipo MediaItem y no Pelicula o Cancion . Para trabajar con ellos como su tipo nativo, debemos chequear su tipo, y hacer un downcast a su tipo concreto.","title":"Una jerarqu\u00eda de clases para el casting de tipos"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#comprobacion-del-tipo","text":"Podemos usar el operador de comprobaci\u00f3n ( check operator ) is para comprobar si una instancia es de un cierto tipo subclase. El operador de comprobaci\u00f3n devuelve true si la instancia es del tipo de la subclase y false si no. Lo podemos comprobar en el siguiente ejemplo, en el que contamos las instancias de pel\u00edculas y canciones en el array biblioteca : 1 2 3 4 5 6 7 8 9 10 11 12 13 var contadorPeliculas = 0 var contadorCanciones = 0 for item in biblioteca { if item is Pelicula { contadorPeliculas += 1 } else if item is Cancion { contadorCanciones += 1 } } print ( \"La biblioteca contiene \\( contadorCanciones ) pel\u00edculas y \\( contadorPeliculas ) canciones\" ) // Imprime \"La biblioteca contiene 3 pel\u00edculas y 2 canciones\" El ejemplo itera por todos los \u00edtems del array biblioteca . En cada paso, el bucle for-in guarda en la constante item el siguiente MediaItem del array. La instrucci\u00f3n item is Pelicula devuelve true si el MediaItem actual es una instancia de Pelicula y false en otro caso. De forma similar, item is Cancion comprueba si el \u00edtem es una instancia de Cancion . Al final del bucle for-in , los valores de contadorPeliculas y contadorCanciones contendr\u00e1n una cuenta de cuantas instancias MediaItem de cada tipo se han encontrado.","title":"Comprobaci\u00f3n del tipo"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#downcasting","text":"Una constante o variable de un cierto tipo de clase puede referirse (contener) a una instancia de una subclase. Cuando creemos que sucede esto, podemos intentar hacer un downcast al tipo de la subclase con un operador de cast ( as? o as! ). Como el downcast puede fallar, la versi\u00f3n condicional, as? , devuelve un valor opcional del tipo al que estamos intentando hacer el downcasting . La versi\u00f3n forzosa, as! , intenta el downcast y fuerza la desenvoltura del resultado en un \u00fanica acci\u00f3n compuesta. Debemos usar la versi\u00f3n condicional ( as? ) cuando no estamos seguros si el downcast tendr\u00e1 \u00e9xito. Se devolver\u00e1 un valor opcional y el valor ser\u00e1 nil si no es posible hacer el downcast . Esto permitir\u00e1 comprobar si ha habido un downcast con \u00e9xito. La otra versi\u00f3n ( as! ) se usa s\u00f3lo cuando estamos seguros de que el downcast tendr\u00e1 \u00e9xito. Esta versi\u00f3n del operador lanzar\u00e1 un error en tiempo de ejecuci\u00f3n si intentamos hacer un downcast a un tipo incorrecto. El siguiente ejemplo itera sobre cada MediaItem en biblioteca , e imprime una descripci\u00f3n apropiada para cada \u00edtem. Para hacerlo, necesita acceder a cada \u00edtem como una Pelicula o Cancion y no s\u00f3lo como una MediaItem . Esto es necesario para poder acceder a la propiedad director o artista de una instancia de Pelicula o Cancion . En este ejemplo, cada \u00edtem en el array podr\u00eda ser un Pelicula o podr\u00eda ser una Cancion . No sabemos por anticipado la clase verdadera de cada \u00edtem, por lo que es apropiado usar la versi\u00f3n condicional ( as? ) para comprobar el downcast cada vez a lo largo del bucle: 1 2 3 4 5 6 7 8 9 10 11 12 13 for item in biblioteca { if let pelicula = item as ? Pelicula { print ( \"Pel\u00edcula: \\( pelicula . nombre ) , dir. \\( pelicula . director ) \" ) } else if let cancion = item as ? Cancion { print ( \"Cancion: \\( cancion . nombre ) , de \\( cancion . artista ) \" ) } } // Pel\u00edcula: El Se\u00f1or de los Anillos, dir. Peter Jackson // Cancion: Child in Time, de Deep Purple // Pel\u00edcula: El Puente de los Esp\u00edas, dir. Steven Spielberg // Cancion: I Wish You Were Here, de Pink Floyd // Cancion: Yellow, de Coldplay El ejemplo comienza intentando hacer downcast del \u00edtem a una Pelicula . Debido a que es una instancia de MediaItme , es posible que sea un Pelicula o una Cancion , o incluso el tipo base MediaItem . Debido a esta incertidumbre, debemos usar la versi\u00f3n as? para devolver un valor opcional. El resultado ser\u00e1 una \"Pelicula opcional\". Podemos desenvolver el valor Pelicula usando un if let como vimos en el apartado de opcionales. Si tiene \u00e9xito el downcasting , las propiedades de la pel\u00edcula se pueden usar para imprimir una descripci\u00f3n de la pel\u00edcula llamando a los correspondientes m\u00e9todos de la clase Pelicula . Igual con Cancion .","title":"Downcasting"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#el-tipo-any","text":"El tipo Any puede representar una instancia de cualquier tipo, incluyendo tipos funci\u00f3n: 1 2 3 4 5 6 7 8 9 10 var array = [ Any ]() array . append ( 0 ) array . append ( 0.0 ) array . append ( 42 ) array . append ( 3.14159 ) array . append ( \"hola\" ) array . append (( 3.0 , 5.0 )) array . append ( Pelicula ( nombre : \"Ghostbusters\" , director : \"Ivan Reitman\" )) array . append ({ ( name : String ) -> String in \"Hola, \\( name ) \" }) El array contiene dos valores Int , dos valores Double , un valor String , una tupla del tipo (Double, Double) , la pel\u00edcula \"Ghostbusters\", y una clausura que toma un String y devuelve otro String . Puedes usar los operadores is y as en una sentencia switch para descubrir en tiempo de ejecuci\u00f3n el tipo espec\u00edfico de una constante o variable de la que s\u00f3lo se sabe que es de tipo Any : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 for item in array { switch item { case 0 as Int : print ( \"cero como un Int\" ) case 0 as Double : print ( \"cero como un Double\" ) case let someInt as Int : print ( \"un valor entero de \\( someInt ) \" ) case let unDouble as Double where unDouble > 0 : print ( \"a valor positivo de \\( unDouble ) \" ) case is Double : print ( \"alg\u00fan otro valor double que no quiero imprimir\" ) case let someString as String : print ( \"una cadena con valor de \\\" \\( someString ) \\\" \" ) case let ( x , y ) as ( Double , Double ): print ( \"un punto (x, y) en \\( x ) , \\( y ) \" ) case let pelicula as Pelicula : print ( \"una pel\u00edcula: \\( pelicula . nombre ) , dir. \\( pelicula . director ) \" ) case let stringConverter as ( String ) -> String : print ( stringConverter ( \"Michael\" )) default : print ( \"alguna otra cosa\" ) } } // cero como un Int // cero como un Double // un valor entero de 42 // a valor positivo de 3.14159 // una cadena con valor de \"hola\" // un punto (x, y) en 3.0, 5.0 // una pel\u00edcula: Ghostbusters, dir. Ivan Reitman // Hola, Michael","title":"El tipo Any"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#comprobacion-de-ajustarse-a-un-protocolo","text":"Podemos usar tambi\u00e9n los operadores anteriores is y as (y as? y as! ) para comprobar si una instancia se ajusta a un protocolo y para hacer un cast a un protocolo espec\u00edfico. Veamos un ejemplo. Definimos el protocolo TieneArea con el \u00fanico requisito de una propiedad de lectura llamada area de tipo Double : 1 2 3 protocol TieneArea { var area : Double { get } } Definimos dos clases Circulo y Pais que se ajustan ambos al protocolo: 1 2 3 4 5 6 7 8 9 10 11 class Circulo : TieneArea { let pi = 3.1415927 var radio : Double var area : Double { return pi * radio * radio } init ( radio : Double ) { self . radio = radio } } class Pais : TieneArea { var area : Double init ( area : Double ) { self . area = area } } La clase Circulo implementa el requisito como una propiedad calculada, basada en la propiedad almacenada radio . La clase Pais implementa el requisito directamente como una propiedad almacenada. Ambas clases se ajustan correctamente al protocolo TieneArea . Definimos una clase Animal que no se ajusta al protocolo: 1 2 3 4 class Animal { var patas : Int init ( patas : Int ) { self . patas = patas } } Las clases Circulo , Pais y Animal no tienen ninguna clase base compartida. Sin embargo, todas son clases, por lo que las instancias de los tres tipos pueden usarse para inicializar un array que almacena valores de tipo Any : 1 2 3 4 5 let objetos : [ Any ] = [ Circulo ( radio : 2.0 ), Pais ( area : 243_610 ), Animal ( patas : 4 ) ] Y ahora podemos iterar sobre el array de objetos, comprobando para cada \u00edtem si la instancia se ajusta al protocolo TieneArea : 1 2 3 4 5 6 7 8 9 10 11 for objecto in objetos { if let objetoConArea = objecto as ? TieneArea { print ( \"El \u00e1rea es \\( objetoConArea . area ) \" ) } else { print ( \"Algo que no tiene un \u00e1rea\" ) } } // El \u00e1rea es 12.5663708 // El \u00e1rea es 243610.0 // Algo que no tiene un \u00e1rea Cuando un objeto en el array se ajusta al protocolo TieneArea , el valor opcional devuelto por el operador as? se desenvuelve con un ligado opcional en una constante llamada objetoConArea . Esta constante tiene el tipo TieneArea , por lo que su propiedad area podr\u00e1 ser accedida e impresa. Hay que notar que los objetos subyacentes no cambian en el proceso de casting . Siguen siendo un Circulo , un Pais y un Animal . Sin embargo, en el momento en se almacenan en la constante objetoConArea , s\u00f3lo se sabe que son del tipo TieneArea , por lo que s\u00f3lo podremos acceder a su propiedad area .","title":"Comprobaci\u00f3n de ajustarse a un protocolo"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#extensiones","text":"Las extensiones a\u00f1aden nueva funcionalidad a una clase, estructura, enumeraci\u00f3n o protocolo. Esto incluye la posibilidad de extender tipos para los que no tenemos acceso al c\u00f3digo fuente original (esto se conoce como modelado retroactivo ). Entre otras cosas, las extensiones pueden: A\u00f1adir propiedades calculadas de instancia y de tipo Definir m\u00e9todos de instancia y de tipo Proporcionar nuevos inicializadores Hacer que un tipo existente se ajuste a un protocolo","title":"Extensiones"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#sintaxis_1","text":"Para declarar una extensi\u00f3n hay que usar la palabra clave extension , indicando despu\u00e9s el tipo que se quiere extender (enumeraci\u00f3n, clase, estructura o protocolo) 1 2 3 extension UnTipoExistente { // nueva funcionalidad para a\u00f1adir a UnTipo }","title":"Sintaxis"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#propiedades-calculadas_1","text":"Las extensiones pueden a\u00f1adir propiedades calculadas de instancias y de tipos. Como primer ejemplo, recordemos el tipo Persona : 1 2 3 4 5 6 7 8 protocol TieneNombre { var nombreCompleto : String { get } } struct Persona : TieneNombre { var edad : Int var nombreCompleto : String } Vamos a a\u00f1adir a la estructura la propiedad calculada mayorEdad , un Bool que indica si la edad de la persona es mayor o igual de 18: 1 2 3 4 5 extension Persona { var mayorEdad : Bool { return edad >= 18 } } Una vez definida esta extensi\u00f3n, hemos ampliado la clase con esta nueva propiedad, sin modificar el c\u00f3digo inicial con la definici\u00f3n de la clase. Podemos preguntar si una persona es mayor de edad: 1 2 var p = Persona ( edad : 15 , nombreCompleto : \"Luc\u00eda\" ) p . mayorEdad // false Es posible incluso extender clases de las librer\u00edas est\u00e1ndar de Swift, como Int , Double , Array , etc. Por ejemplo, podemos a\u00f1adir propiedades calculadas a la clase Double para trabajar con unidades de distancia. Las siguientes propiedades convierten una cantidad en las unidades correspondientes a su equivalente en metros: 1 2 3 4 5 6 7 extension Double { var km : Double { return self * 1_000.0 } var m : Double { return self } var cm : Double { return self / 100.0 } var mm : Double { return self / 1_000.0 } var ft : Double { return self / 3.28084 } } Una vez definida la extensi\u00f3n, podemos usarla en cualquier variable Double . Incluso la podemos usar en literales: 1 2 3 4 5 6 7 8 let distancia = 11. km // En distancia tendremos 11000 metros let unaPulgada = 25.4 . mm print ( \"Una pulgada es \\( unaPulgada ) metros\" ) // Una pulgada es 0.0254 metros let tresPies = 3. ft print ( \"Tres pies son \\( tresPies ) metros\" ) // Tres pies son 0.914399970739201 metros Por ejemplo, cuando se escribe 11.km se pide el valor de la propiedad calculada km de la instancia 11 . La propiedad calculada devuelve el resultado de multiplicar 11 por 1000 , esto es, los metros correspondientes a 11 kil\u00f3metros. De forma similar, hay 3.28084 pies en un metro, por lo que la propiedad calculada ft divide el valor Double subyacente por 3.28084, para conventirlo de pies a metros. Estas propiedades son propiedades calculadas de solo lectura, por lo que se expresan sin la palabra clave get , por brevedad. Sus valores devueltos son de tipo Double , y pueden usarse en c\u00e1lculos matem\u00e1ticos en cualquier sitio que se acepte un Double : 1 2 3 let unMaraton = 42. km + 195. m print ( \"Un marat\u00f3n tiene una longitud de \\( unMaraton ) metros\" ) // Un marat\u00f3n tiene una longitud de 42195.0 metros","title":"Propiedades calculadas"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#inicializadores","text":"Las extensiones pueden a\u00f1adir nuevos inicializadores a tipos existentes. Esto nos permite extender otros tipos para aceptar nuestros propios tipos como par\u00e1metros de la inicializaci\u00f3n, o para proporcionar opciones adicionales que no estaban incluidos en la implementaci\u00f3n original del tipo. Recordemos la estructura Rectangulo , definida por un Punto y un Tama\u00f1o . Supongamos que la definimos sin inicializadores: 1 2 3 4 5 6 7 8 9 10 struct Tama\u00f1o { var ancho = 0.0 , alto = 0.0 } struct Punto { var x = 0.0 , y = 0.0 } struct Rectangulo { var origen = Punto () var tama\u00f1o = Tama\u00f1o () } Recordemos que debido a que la estructura Rectangulo proporciona valores por defecto para todas sus propiedades, tiene un inicializador por defecto que puede utilizarse para crear nuevas instancias. Tambi\u00e9n podemos inicializarlo asignando todas sus propieades: 1 2 3 let rectanguloPorDefecto = Rectangulo () let rectanguloInicializado = Rectangulo ( origen : Punto ( x : 2.0 , y : 2.0 ), tama\u00f1o : Tama\u00f1o ( ancho : 5.0 , alto : 5.0 )) Podemos ahora extender la estructura Rectangulo para proporcionar un inicializador adicional que toma un punto espec\u00edfico del centro y un tama\u00f1o: 1 2 3 4 5 6 7 extension Rectangulo { init ( centro : Punto , tama\u00f1o : Tama\u00f1o ) { let origenX = centro . x - ( tama\u00f1o . ancho / 2 ) let origenY = centro . y - ( tama\u00f1o . alto / 2 ) self . init ( origen : Punto ( x : origenX , y : origenY ), tama\u00f1o : tama\u00f1o ) } } Este nuevo inicializador empieza por calcular un punto de origen basado en el centro propuesto y en el tama\u00f1o. El inicializador llama despu\u00e9s al inicializador autom\u00e1tico de la estructura init(origen:tama\u00f1o:) , que almacena los nuevos valores de las propiedades: 1 2 3 let rectanguloCentro = Rectangulo ( centro : Punto ( x : 4.0 , y : 4.0 ), tama\u00f1o : Tama\u00f1o ( ancho : 3.0 , alto : 3.0 )) // el origen del rectanguloCentro es is (2.5, 2.5) y su tama\u00f1o es (3.0, 3.0)","title":"Inicializadores"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#metodos_1","text":"Las extensiones pueden a\u00f1adir nuevos m\u00e9todos de instancia y nuevos m\u00e9todos del tipo. Por ejemplo, podemos a\u00f1adir el m\u00e9todo descripcion() a la estructura Persona : 1 2 3 4 5 6 7 8 extension Persona { func descripcion () -> String { return \"Me llamo \\( nombreCompleto ) y tengo \\( edad ) a\u00f1os\" } } let reedRichards = Persona ( edad : 40 , nombreCompleto : \"Reed Richards\" ) print ( reedRichards . descripcion ()) Tambi\u00e9n podemos a\u00f1adir m\u00e9todos a clases y estructuras importadas. Por ejemplo podemos a\u00f1adir un nuevo m\u00e9todo de instancia llamado repeticiones al tipo Int : 1 2 3 4 5 6 7 extension Int { func repeticiones ( _ tarea : () -> Void ) { for _ in 0. .< self { tarea () } } } El m\u00e9todo repeticiones(_:) toma un \u00fanico argumento de tipo () -> Void , que indica una funci\u00f3n que no tiene par\u00e1metros y no devuelve ning\u00fan valor. Despu\u00e9s de definir esta extensi\u00f3n, podemos llamar al m\u00e9todo repeticiones(_:) en cualquier n\u00famero entero para ejecutar una tarea un cierto n\u00famero de veces: 1 2 3 4 5 6 3. repeticiones ({ print ( \"Hola!\" ) }) // Hola! // Hola! // Hola! Usando clausuras por la cola podemos hacer la llamada m\u00e1s concisa: 1 2 3 4 5 6 3. repeticiones { print ( \"Adios!\" ) } // Adios! // Adios! // Adios!","title":"M\u00e9todos"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#metodos-de-instancia-mutadores","text":"Los m\u00e9todos de instancia a\u00f1adidos con una extensi\u00f3n tambi\u00e9n pueden modificar (o mutar) la propia instancia. Los m\u00e9todos de las estructuras y los enumerados que modifican self o sus propiedades deben marcarse como mutating . Por ejemplo: 1 2 3 4 5 6 7 8 extension Int { mutating func cuadrado () { self = self * self } } var unInt = 3 unInt . cuadrado () // unInt es ahora 9","title":"M\u00e9todos de instancia mutadores"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#ajustar-un-tipo-a-un-protocolo-mediante-una-extension","text":"Una extensi\u00f3n puede extender un tipo existente para hacer que se ajuste a uno o m\u00e1s protocolos. En este caso, los nombres de los protocolos se escriben exactamente de la misma forma que en una clase o estructura: 1 2 3 extension UnTipo : UnProtocolo , OtroProtocolo { // implementaci\u00f3n de los requisitos del protocolo } Las instancias del tipo adoptar\u00e1n autom\u00e1ticamente el protocolo y se ajustar\u00e1n al protocolo con las propiedades y m\u00e9todos a\u00f1adidos por la extensi\u00f3n. Por ejemplo, este protocolo, llamado RepresentableComoTexto puede ser implementado por cualquier tipo que tenga una forma de representarse como texto. Esto puede ser una descripci\u00f3n de si mismo o una versi\u00f3n de texto de su estado actual: 1 2 3 protocol RepresentableComoTexto { var descripcionTextual : String { get } } La clase Dado que vimos anteriormente puede extenderse para ajustarse al protocolo: 1 2 3 4 5 extension Dado : RepresentableComoTexto { var descripcionTextual : String { return \"Un dado de \\( caras ) caras\" } } Esta extensi\u00f3n adopta el nuevo protocolo exactamente como si el Dado lo hubiera proporcionado en su implementaci\u00f3n original. El nombre del protocolo se indica tras el nombre del tipo, separado por dos puntos, y se proporciona una implementaci\u00f3n entre llaves. Cualquier instancia de un dado se puede tratar ahora como RepresentableComoTexto : 1 2 3 let d12 = Dado ( caras : 12 , generador : GeneradorLinealCongruente ()) print ( d12 . descripcionTextual ) // Un dado de 12 caras De forma similar, un Rectangulo tambi\u00e9n puede extenderse para adoptar y ajustarse al protocolo: 1 2 3 4 5 6 7 8 9 10 extension Rectangulo : RepresentableComoTexto { var descripcionTextual : String { return \"Un rect\u00e1ngulo situado en ( \\( origen . x ) , \\( origen . y ) )\" } } let rectanguloInicializado = Rectangulo ( origen : Punto ( x : 2.0 , y : 2.0 ), tama\u00f1o : Tama\u00f1o ( ancho : 5.0 , alto : 5.0 )) print ( rectanguloInicializado . descripcionTextual ) // Un rect\u00e1ngulo situado en (2.0, 2.0)","title":"Ajustar un tipo a un protocolo mediante una extensi\u00f3n"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#declaracion-de-la-adopcion-de-un-protocolo-con-una-extension","text":"Si un tipo ya se ajusta a todos los requisitos de un protocolo, pero todav\u00eda no se ha declarado que se ajusta al protocolo, podemos hacer que lo adopte con una extensi\u00f3n vac\u00eda: 1 2 3 4 5 6 7 struct Hamster { var nombre : String var descripcionTextual : String { return \"Un hamster llamado \\( nombre ) \" } } extension Hamster : RepresentableComoTexto {} Las instancias de Hamster pueden ahora usarse en cualquier sitio que se requiera un tipo RepresentableComoTexto : 1 2 3 4 let simonElHamster = Hamster ( nombre : \"Simon\" ) let algoRepresentableComoTexto : RepresentableComoTexto = simonElHamster print ( algoRepresentableComoTexto . descripcionTextual ) // Un hamster llamado Simon","title":"Declaraci\u00f3n de la adopci\u00f3n de un protocolo con una extensi\u00f3n"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#implementacion-de-metodos-de-un-protocolo","text":"Podemos definir extensiones en los protocolos para proporcionar implementaciones de m\u00e9todos y propiedades a todos los tipos que se ajustan a \u00e9l. Esto permite definir conductas en los propios protocolos, m\u00e1s que en cada tipo individual o en una funci\u00f3n global. Por ejemplo, el protocolo GeneradorNumerosAleatorios puede ser extendido para proporcionar un m\u00e9todo boolAleatorio() , que usa el resultado del random() requerido para devolver un valor Bool aleatorio: 1 2 3 4 5 extension GeneradorNumerosAleatorios { func randomBool () -> Bool { return random () > 0.5 } } Al crear una extensi\u00f3n en el protocolo, todos los tipos que se ajustan a \u00e9l adquieren autom\u00e1ticamente esta implementaci\u00f3n sin ninguna modificaci\u00f3n adicional. 1 2 3 4 5 let generator = GeneradorLinealCongruente() print(\"Un n\u00famero aleatorio: \\(generator.random())\") // Imprime \"Un n\u00famero aleatorio: 0.37464991998171\" print(\"Y un booleano aleatorio: \\(generator.randomBool())\") // Imprime \"Un booleano aleatorio: true\" El tipo que se ajusta al protocolo puede proporcionar su propia implementaci\u00f3n, que se usar\u00e1 en lugar de la proporcionada por la extensi\u00f3n.","title":"Implementaci\u00f3n de m\u00e9todos de un protocolo"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#funciones-operadoras","text":"Las clases y las estructuras pueden proporcionar sus propias implementaciones de operadores existentes. Esto se conoce como sobrecarga de los operadores existentes. En el siguiente ejemplo se muestra c\u00f3mo implementar el operador de suma ( + ) para una estructura. El operador suma es un operador binario (tiene dos operandos) e infijo (aparece junto entre los dos operandos). Definimos una estructura Vector2D para un vector de posici\u00f3n de dos dimensiones: 1 2 3 4 5 6 struct Vector2D { var x = 0.0 , y = 0.0 static func + ( izquierdo : Vector2D , derecho : Vector2D ) -> Vector2D { return Vector2D ( x : izquierdo . x + derecho . x , y : izquierdo . y + derecho . y ) } } La funci\u00f3n operador se define como una funci\u00f3n est\u00e1tica con un un nombre de funci\u00f3n que empareja con el operador a sobrecargar ( + ). Debido a que la suma aritm\u00e9tica se define como un operador binario, esta funci\u00f3n operador toma dos par\u00e1metros de entrada de tipo Vector2D y devuelve un \u00fanico valor de salida, tambi\u00e9n de tipo Vector2D . En esta implementaci\u00f3n, llamamos a los par\u00e1metros de entrada izquierdo y derecho para representar las instancias de Vector2D que estar\u00e1n a la izquierda y a la derecha del operador + . Son nombres arbitrarios, lo importante es la posici\u00f3n. El primer par\u00e1metro de la funci\u00f3n es el que hace de primer operador. La funci\u00f3n devuelve una nueva instancia de Vector2D , cuyas propiedades x e y se inicializan con la suma de las propiedades x e y de las instancias de Vector2D que se est\u00e1n sumando. La funci\u00f3n se define globalmente, m\u00e1s que como un m\u00e9todo en la estructura Vector2D , para que pueda usarse como un operador infijo entre instancias existentes de Vector2D : 1 2 3 4 let vector = Vector2D ( x : 3.0 , y : 1.0 ) let otroVector = Vector2D ( x : 2.0 , y : 4.0 ) let vectorSuma = vector + otroVector // vectorSuma es una instancia de Vector2D con valores de (5.0, 5.0)","title":"Funciones operadoras"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#operadores-prefijos-y-postfijos","text":"El ejemplo anterior demuestra una implementaci\u00f3n propia de un operador binario infijo. Las clases y las estructuras pueden tambi\u00e9n proporcionar implementaciones de los operadores unarios est\u00e1ndar. Los operadores unarios operan sobre un \u00fanico objetivo. Son prefijos se preceden el objetivo (como -a ) y postfijos si siguen su objetivo (como en b! ). Para implementar un operador unario prefijo o postfijo se debe escribir el modificador prefix o postfix antes de la palabra clave func en la declaraci\u00f3n de la funci\u00f3n operador: 1 2 3 4 5 6 struct Vector2D { ... static prefix func - ( vector : Vector2D ) -> Vector2D { return Vector2D ( x : - vector . x , y : - vector . y ) } } El ejemplo anterior implementa el operador unario negaci\u00f3n ( -a ) para instancias de Vector2D . Por ejemplo: 1 2 3 4 5 let positivo = Vector2D ( x : 3.0 , y : 4.0 ) let negativo = - positivo // negativo es una instancia de Vector2D con valores de (-3.0, -4.0) let tambienPositivo = - negativo // tambienPositivo es una instancia de Vector2D con valores de (3.0, 4.0)","title":"Operadores prefijos y postfijos"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#operadores-de-equivalencia","text":"Como ya hemos visto, las clases no tienen una implementaci\u00f3n por defecto de los operadores \"igual a\" ( == ) y \"no igual a\" ( != ), pero las estructuras s\u00ed (a partir de Swift 5). Para comparar dos instancias de una clase debemos proporcionar una implementaci\u00f3n del operador == . A partir de Swift 5 si declaramos que una estructura cumple el protocolo Equatable el compilador de Swift implementar\u00e1 una comparaci\u00f3n por defecto, siempre que todas las propiedades de la estructura sean a su vez Equatable . En Swift 4 para implementar la igualdad en la estructura Vector2D tenemos que definir una extensi\u00f3n que cumple el protocolo Equatable : 1 2 3 4 5 6 // Swift 4 extension Vector2D : Equatable { static func == ( izquierdo : Vector2D , derecho : Vector2D ) -> Bool { return ( izquierdo . x == derecho . x ) && ( izquierdo . y == derecho . y ) } } En el ejemplo anterior se implementa un operador \"igual a\" ( == ) que comprueba si dos instancias de Vector2D tienen valores equivalentes. En el contexto del Vector2D tiene sentido considerar \"igual\" como \"ambas instancias tienen los mismos valores x e y\", por lo que esta es la l\u00f3gica usada por la implementaci\u00f3n. La implementaci\u00f3n del operador \"no igual a\" ( != ) se realiza por defecto como una negaci\u00f3n del anterior. En Swift 5 basta con declarar con la extensi\u00f3n que el Vector2D cumple el protocolo: 1 2 // Swift 5 extension Vector2D : Equatable {} Una vez definido el operador == podemos comparar dos instancias de Vector2D : 1 2 3 4 5 6 7 8 9 let dosTres = Vector2D ( x : 2.0 , y : 3.0 ) let otroDosTres = Vector2D ( x : 2.0 , y : 3.0 ) let unoDos = Vector2D ( x : 1.0 , y : 2.0 ) if dosTres == otroDosTres { print ( \"Los vectores \\( dosTres ) y \\( otroDosTres ) son equivalentes.\" ) } if ( unoDos != dosTres ) { print ( \"Los vectores \\( unoDos ) y \\( dosTres ) son distintos.\" ) }","title":"Operadores de equivalencia"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#genericos","text":"Veamos c\u00f3mo podemos utilizar los gen\u00e9ricos con clases y estructuras. Vamos a utilizar como ejemplo un tipo de dato muy sencillo: una pila ( stack ) en la que se podr\u00e1n a\u00f1adir ( push ) y retirar ( pop ) elementos. La versi\u00f3n no gen\u00e9rica del tipo de dato es la siguiente, en la que se implementa una pila de enteros. 1 2 3 4 5 6 7 8 9 struct IntStack { var items = [ Int ]() mutating func push ( _ item : Int ) { items . append ( item ) } mutating func pop () -> Int { return items . removeLast () } } La estructura usa un array para guardar los \u00edtems y los m\u00e9todos push y pop a\u00f1aden y retiran los elementos. El problema de esta estructura es su falta de genericidad; s\u00f3lo puede almacenar enteros. Aqu\u00ed est\u00e1 una versi\u00f3n gen\u00e9rica del mismo c\u00f3digo: 1 2 3 4 5 6 7 8 9 struct Stack < Element > { var items = [ Element ]() mutating func push ( _ item : Element ) { items . append ( item ) } mutating func pop () -> Element { return items . removeLast () } } El par\u00e1metro del tipo Element define un tipo gen\u00e9rico que se utiliza como placeholder del tipo real del que se declare la estructura. Podemos ver que se utiliza en la definici\u00f3n de los distintos elementos de la estructura. Por ejemplo, el array de \u00edtems es un array de Element s. Y los \u00edtems a\u00f1adidos y retirados de la pila son tambi\u00e9n objetos de tipo Element . Por ejemplo, podemos crear una pila de cadenas: 1 2 3 4 5 6 var stackOfStrings = Stack < String >() stackOfStrings . push ( \"uno\" ) stackOfStrings . push ( \"dos\" ) stackOfStrings . push ( \"tres\" ) stackOfStrings . push ( \"cuatro\" ) // la pila contiene ahora 4 cadenas Y podemos retirar la \u00faltima cadena de la pila: 1 let fromTheTop = stackOfStrings . pop ()","title":"Gen\u00e9ricos"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#extension-de-un-tipo-generico","text":"Cuando se extiende un tipo gen\u00e9rico, no hace falta a\u00f1adir el par\u00e1metro del tipo entre <> . El tipo gen\u00e9rico est\u00e1 disponible a partir de la definici\u00f3n original y se puede usar tal cual en el cuerpo de la extensi\u00f3n. Por ejemplo, podemos extender el tipo gen\u00e9rico Stack para a\u00f1adir una propiedad computable de s\u00f3lo lectura que devuelva el tope de la pila: 1 2 3 4 5 extension Stack { var topItem : Element ? { return items . isEmpty ? nil : items [ items . count - 1 ] } } En la extensi\u00f3n se utiliza el nombre gen\u00e9rico Element sin tener que declararlo despu\u00e9s de Stack , porque est\u00e1 definido en la estructura original. Ahora ya se puede acceder al tope de la pila sin retirar el elemento: 1 2 3 4 if let topItem = stackOfStrings . topItem { print ( \"El \u00edtem en el tope de la pila es \\( topItem ) .\" ) } // Imprime \"El \u00edtem en el tope de la pila es tres.\"","title":"Extensi\u00f3n de un tipo gen\u00e9rico"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#restriccion-en-las-extensiones-de-un-protocolo","text":"En una extensi\u00f3n de un protocolo es posible definir una restricci\u00f3n indicando una condici\u00f3n que se debe cumplir para que la extensi\u00f3n se pueda aplicar. Los m\u00e9todos y propiedades de la extensi\u00f3n s\u00f3lo estar\u00e1n disponibles en aquellos tipos que se ajusten al protocolo y cumplan el requisito. El requisito se definen usando una cl\u00e1usula gen\u00e9rica where en la que se indica una condici\u00f3n sobre alg\u00fan tipo asociado definido en el protocolo. Nota No hemos visto el concepto de tipo asociado en un protocolo. Es una especie de tipo gen\u00e9rico que se define en el protocolo y que se convierte en un tipo concreto en la clase que se ajusta al protocolo. Por ejemplo, podemos definir una extensi\u00f3n al protocolo Collection que se aplique a cualquier colecci\u00f3n cuyos elementos cumplen el protocolo Equatable . De esta forma nos aseguramos de que los operadores == y != est\u00e1n definidos y podemos usarlos en la extensi\u00f3n: 1 2 3 4 5 6 7 8 9 10 extension Collection where Element : Equatable { func allEqual () -> Bool { for element in self { if element != self . first { return false } } return true } } El nombre Element es un nombre definido en el protocolo Collection que se refiere al tipo de los elementos de la colecci\u00f3n. Es un tipo asociado . El m\u00e9todo allEqual() devuelve true si y s\u00f3lo si todos los elementos en la colecci\u00f3n son iguales. Un ejemplo: 1 2 let numerosIguales = [ 100 , 100 , 100 , 100 , 100 ] let numerosDiferentes = [ 100 , 100 , 200 , 100 , 200 ] Dado que ambos arrays cumplen el protocolo Collection y los enteros cumplen el protocolo Equatable podemos usar el m\u00e9todo allEqual() : 1 2 3 4 print(numerosIguales.allEqual()) // Prints \"true\" print(numerosDiferentes.allEqual()) // Prints \"false\" En una colecci\u00f3n cuyos elementos no cumplen el protocolo Equatable no se puede utilizar el m\u00e9todo de la extensi\u00f3n: 1 2 3 4 let tormenta = Persona ( edad : 32 , nombreCompleto : \"Ororo Munroe\" ) let superHeroes = [ tormenta , peterParker , reedRichards ] print ( superHeroes . allEqual ()) //error: type 'Persona' does not conform to protocol 'Equatable'","title":"Restricci\u00f3n en las extensiones de un protocolo"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#bibliografia","text":"Swift Language Guide Classes and Structures Properties Methods Inheritance Initialization Protocolos Casting de tipos Extensiones Funciones operador Gen\u00e9ricos Lenguajes y Paradigmas de Programaci\u00f3n, curso 2018\u201319 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Domingo Gallardo, Cristina Pomares, Antonio Bot\u00eda, Francisco Mart\u00ednez","title":"Bibliograf\u00eda"}]}