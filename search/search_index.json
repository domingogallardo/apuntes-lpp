{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Sitio web con los apuntes de teor\u00eda, seminarios y pr\u00e1cticas de la asignatura \"Lenguajes y paradigmas de programaci\u00f3n\". Despliega el men\u00fa de la izquierda para consultar los apuntes. Otros enlaces: Ficha de la asignatura Plataforma docente Moodle","title":"Index"},{"location":"practicas/practica01/practica01.html","text":"Pr\u00e1ctica 1: Seminario de Scheme \u00b6 Realizaci\u00f3n de la pr\u00e1ctica \u00b6 Instala en tu ordenador el DrRacket, tal y como se comenta al comienzo del seminario de Scheme y crea un fichero practica1.rkt . Escribe en comentarios (comenzando por punto y coma ; ) tu nombre y apellidos. Incluye en el fichero todo el c\u00f3digo que escribas esta semana. Usa tambi\u00e9n comentarios para separar secciones y realizar anotaciones. Lee el seminario de Scheme hasta el apartado 2.4. ( Tipos de datos simples ) incluido. Puedes ver el v\u00eddeo 1 que hemos subido a Moodle . A la vez que lees el texto o ves el v\u00eddeo debes probar en el int\u00e9rprete de Racket todos los ejemplos que aparecen. Pru\u00e9balos de forma interactiva en el panel de interpretaci\u00f3n del DrRacket y guarda las definiciones en el panel de edici\u00f3n del fichero practica1.rkt . Haz el siguiente ejercicio. Ejercicio 1 . Lanza DrRacket y escribe cada una de las siguientes instrucciones en el int\u00e9rprete, intentado adivinar el resultado que va devolver. Est\u00e1n ordenadas por dificultad de arriba abajo y de izquierda a derecha. \u00a1\u00a1Piensa en los resultados!!. Intenta entender c\u00f3mo interpreta Scheme lo que escribes. Instrucci\u00f3n Instrucci\u00f3n 3 (+ (- 4 (* 3 (/ 4 2) 4)) 3) (+ 1 2 ) (* (+ (+ 2 3) 4) (* (* 3 3) 2)) (+ 1 2 3 4) (* (+ 2 3 4 5) 3 (- 5 2 1)) (+) (+ (- (+ (- (+ 2 3) 5) 1) 2) 3) (sqrt 25) (- (sqrt (* 5 ( + 3 2))) (+ 1 1 1 1)) (* (+ 2 3) 5) (> (* 3 (+ 2 (+ 3 1)) (+ 1 1)) (+ (* 2 2) 3)) + (= (* 3 2) (+ 1 (+ 2 2) 1)) #\\+ (not (> (+ 3 2) 5)) \"+\" (and (even? 2) (odd? (+ 3 2))) \"hola\" (remainder (+ 6 2) (+ 1 1)) Lee el apartado 2.5. ( Tipos de datos compuestos ) del seminario de Scheme, en el que se explica c\u00f3mo se trabaja con cadenas, parejas y listas en Racket. Puedes ver el v\u00eddeo 2 que hemos subido a Moodle . Prueba en el int\u00e9rprete de Racket todos los ejemplos que aparecen en el seminario. Haz los siguientes ejercicios. Ejercicio 2 sobre parejas. Predice lo que hace Scheme cuando escribas las siguientes expresiones. Est\u00e1n ordenadas por dificultad de arriba abajo y de izquierda a derecha. Despu\u00e9s, pru\u00e9balas y comprueba si tu predicci\u00f3n era correcta. Si no lo era, intenta comprender por qu\u00e9. Instrucci\u00f3n Instrucci\u00f3n (cons 1 2) (car (car (cons (cons 1 2) 3))) (car (cons 1 2)) (car (cons (cons 3 4) 2)) (cdr (cons 1 2)) (cdr (cons (cons 3 4) 2)) (cons (* 2 3) (/ 4 2)) (cdr (cons 1 (cons 2 3))) (cons (+ 2 1) (if (> 2 3) \"2\" \"3\")) (cdr (car (cons (cons 1 2) 3))) Ejercicio 3 sobre listas. Predice lo que hace Scheme cuando escribas las siguientes expresiones. Despu\u00e9s, pru\u00e9balas y comprueba si tu predicci\u00f3n era correcta. Si no lo era, intenta comprender por qu\u00e9. Instrucci\u00f3n Instrucci\u00f3n (list 1 2 3 4) (cons 3 '(1 2 3)) (rest (list 1 2 3 4)) (rest (cons #t (cons \"Hola\" (list 1)))) (first '(1 2 3 4)) (first (list (list 1 2) 1 2 3 4)) (first (list #t 1 \"Hola\")) (first (rest '((1 2) 1 2))) (first (rest (list 1 2 3 4))) (cons '(1 2 3) '(4 5 6)) (rest (rest '(1 2 3 4))) (first (rest (list 1 2 3 4))) (first (rest (rest (list 1 2 3 4)))) (rest (rest (list 1 2 3 4))) (list (* 2 2) (+ 1 2) (/ 4 2)) (first (rest (rest (rest '(1 2 3 4))))) (list (+ 2 3) (- 3 4) (string-ref \"hola\" 3)) Ejercicio 4 sobre listas. Intenta hacer los siguientes apartados sin utilizar el int\u00e9rprete de Scheme. Despu\u00e9s comprueba si has acertado. a) Dada la siguiente lista, indica la expresi\u00f3n correcta para que Scheme devuelva 3: ( list 1 2 3 4 5 ) b) Dada la siguiente lista, indica la expresi\u00f3n correcta para que Scheme devuelva (5). ( list 1 2 3 4 5 ) c) Dada la siguiente lista, indica la expresi\u00f3n correcta para que Scheme devuelva 5. ( list 1 2 3 4 5 ) d) Dada la siguiente expresi\u00f3n, \u00bfqu\u00e9 devuelve Scheme? ( first ( rest ( rest ( list 1 ( list 2 3 ) ( list 4 5 ) 6 )))) e) Dada la siguiente expresi\u00f3n, \u00bfqu\u00e9 devuelve Scheme? ( rest ( rest ' ( 1 ( 2 3 ) 4 5 ))) Lee el apartado 3 ( Estructuras de control ) del seminario de Scheme. Puedes ver el v\u00eddeo 3 en la p\u00e1gina de Moodle hasta el minuto 7:00. Haz el siguiente ejercicio. Ejercicio 5 . Predice lo que devolver\u00e1 Scheme cuando escribas las siguientes expresiones. Est\u00e1n ordenadas por dificultad de arriba abajo y de izquierda a derecha. Despu\u00e9s, pru\u00e9balas y comprueba si tu predicci\u00f3n era correcta. Si no lo era, intenta comprender por qu\u00e9. Instrucci\u00f3n Instrucci\u00f3n (equal? \"hola\" \"hola\") (+ (char->integer(integer->char 1200)) (char->integer #\\A)) (string-ref \"pepe\" 1) (string-length (make-string 7 #\\E)) (substring \"buenos dias\" 1 4) (define a 3) (define b (+ a 1)) (= \"hola\" \"hola\") (+ a b (* a b)) (string-ref (substring \"buenos dias\" 2 5) 1) (= a b) (define pi 3.14159) (if (and (> a b) (< b (* a b))) b a) pi (cond ((= a 4) 6) ((= b 4) (+ 6 7 a)) (else 25)) \"pi\" (+ 2 (if (> b a) b a)) (+ pi (+ pi pi)) (* (cond ((> a b) a) ((< a b) b) (else -1)) (+ a 1)) (+ (* pi pi) (- 2 pi pi pi pi)) ((if (< a b) + -) a b) Lee el resto del seminario, desde el apartado 4 hasta el final. Puedes ver el v\u00eddeo 3 en la p\u00e1gina de Moodle desde el minuto 7:00 hasta el final. Prueba las funciones ecuacion y convertir-temperatura y reflexiona sobre c\u00f3mo se implementan. Prueba las pruebas unitarias de la funci\u00f3n ecuacion . Cambia la definici\u00f3n de la funci\u00f3n para introducir un error y provocar un fallo en las pruebas unitarias. Arregla la definici\u00f3n de la funci\u00f3n para que vuelva a funcionar. Haz el siguiente ejercicio. Ejercicio 6 . Define una funci\u00f3n que calcule la distancia entre dos puntos, definidos por parejas de n\u00fameros enteros. A\u00f1ade los siguientes tests para comprobar que funciona correctamente: Entrada Salida p1:(0 0) p2:(0 10) 10 p1:(0 0) p2:(10 0) 10 p1:(0 0) p2:(10 10) 14.142135623730951 Entrega de la pr\u00e1ctica \u00b6 Sube la soluci\u00f3n de los ejercicios a Moodle en el cuestionario Entrega pr\u00e1ctica 1 hasta el domingo 6 a las 21:00 h. Una vez finalizado el plazo de entrega podr\u00e1s revisar el cuestionario y visualizar la soluci\u00f3n del ejercicio 6. Una vez est\u00e9 disponible la soluci\u00f3n debes compararla con la tuya. Puedes consultar cualquier duda con tu profesor de pr\u00e1cticas en la clase de pr\u00e1cticas de la semana que viene. Lenguajes y Paradigmas de Programaci\u00f3n, curso 2021-22 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Domingo Gallardo, Cristina Pomares, Antonio Bot\u00eda, Francisco Mart\u00ednez","title":"Pr\u00e1ctica 1"},{"location":"practicas/practica01/practica01.html#practica-1-seminario-de-scheme","text":"","title":"Pr\u00e1ctica 1: Seminario de Scheme"},{"location":"practicas/practica01/practica01.html#realizacion-de-la-practica","text":"Instala en tu ordenador el DrRacket, tal y como se comenta al comienzo del seminario de Scheme y crea un fichero practica1.rkt . Escribe en comentarios (comenzando por punto y coma ; ) tu nombre y apellidos. Incluye en el fichero todo el c\u00f3digo que escribas esta semana. Usa tambi\u00e9n comentarios para separar secciones y realizar anotaciones. Lee el seminario de Scheme hasta el apartado 2.4. ( Tipos de datos simples ) incluido. Puedes ver el v\u00eddeo 1 que hemos subido a Moodle . A la vez que lees el texto o ves el v\u00eddeo debes probar en el int\u00e9rprete de Racket todos los ejemplos que aparecen. Pru\u00e9balos de forma interactiva en el panel de interpretaci\u00f3n del DrRacket y guarda las definiciones en el panel de edici\u00f3n del fichero practica1.rkt . Haz el siguiente ejercicio. Ejercicio 1 . Lanza DrRacket y escribe cada una de las siguientes instrucciones en el int\u00e9rprete, intentado adivinar el resultado que va devolver. Est\u00e1n ordenadas por dificultad de arriba abajo y de izquierda a derecha. \u00a1\u00a1Piensa en los resultados!!. Intenta entender c\u00f3mo interpreta Scheme lo que escribes. Instrucci\u00f3n Instrucci\u00f3n 3 (+ (- 4 (* 3 (/ 4 2) 4)) 3) (+ 1 2 ) (* (+ (+ 2 3) 4) (* (* 3 3) 2)) (+ 1 2 3 4) (* (+ 2 3 4 5) 3 (- 5 2 1)) (+) (+ (- (+ (- (+ 2 3) 5) 1) 2) 3) (sqrt 25) (- (sqrt (* 5 ( + 3 2))) (+ 1 1 1 1)) (* (+ 2 3) 5) (> (* 3 (+ 2 (+ 3 1)) (+ 1 1)) (+ (* 2 2) 3)) + (= (* 3 2) (+ 1 (+ 2 2) 1)) #\\+ (not (> (+ 3 2) 5)) \"+\" (and (even? 2) (odd? (+ 3 2))) \"hola\" (remainder (+ 6 2) (+ 1 1)) Lee el apartado 2.5. ( Tipos de datos compuestos ) del seminario de Scheme, en el que se explica c\u00f3mo se trabaja con cadenas, parejas y listas en Racket. Puedes ver el v\u00eddeo 2 que hemos subido a Moodle . Prueba en el int\u00e9rprete de Racket todos los ejemplos que aparecen en el seminario. Haz los siguientes ejercicios. Ejercicio 2 sobre parejas. Predice lo que hace Scheme cuando escribas las siguientes expresiones. Est\u00e1n ordenadas por dificultad de arriba abajo y de izquierda a derecha. Despu\u00e9s, pru\u00e9balas y comprueba si tu predicci\u00f3n era correcta. Si no lo era, intenta comprender por qu\u00e9. Instrucci\u00f3n Instrucci\u00f3n (cons 1 2) (car (car (cons (cons 1 2) 3))) (car (cons 1 2)) (car (cons (cons 3 4) 2)) (cdr (cons 1 2)) (cdr (cons (cons 3 4) 2)) (cons (* 2 3) (/ 4 2)) (cdr (cons 1 (cons 2 3))) (cons (+ 2 1) (if (> 2 3) \"2\" \"3\")) (cdr (car (cons (cons 1 2) 3))) Ejercicio 3 sobre listas. Predice lo que hace Scheme cuando escribas las siguientes expresiones. Despu\u00e9s, pru\u00e9balas y comprueba si tu predicci\u00f3n era correcta. Si no lo era, intenta comprender por qu\u00e9. Instrucci\u00f3n Instrucci\u00f3n (list 1 2 3 4) (cons 3 '(1 2 3)) (rest (list 1 2 3 4)) (rest (cons #t (cons \"Hola\" (list 1)))) (first '(1 2 3 4)) (first (list (list 1 2) 1 2 3 4)) (first (list #t 1 \"Hola\")) (first (rest '((1 2) 1 2))) (first (rest (list 1 2 3 4))) (cons '(1 2 3) '(4 5 6)) (rest (rest '(1 2 3 4))) (first (rest (list 1 2 3 4))) (first (rest (rest (list 1 2 3 4)))) (rest (rest (list 1 2 3 4))) (list (* 2 2) (+ 1 2) (/ 4 2)) (first (rest (rest (rest '(1 2 3 4))))) (list (+ 2 3) (- 3 4) (string-ref \"hola\" 3)) Ejercicio 4 sobre listas. Intenta hacer los siguientes apartados sin utilizar el int\u00e9rprete de Scheme. Despu\u00e9s comprueba si has acertado. a) Dada la siguiente lista, indica la expresi\u00f3n correcta para que Scheme devuelva 3: ( list 1 2 3 4 5 ) b) Dada la siguiente lista, indica la expresi\u00f3n correcta para que Scheme devuelva (5). ( list 1 2 3 4 5 ) c) Dada la siguiente lista, indica la expresi\u00f3n correcta para que Scheme devuelva 5. ( list 1 2 3 4 5 ) d) Dada la siguiente expresi\u00f3n, \u00bfqu\u00e9 devuelve Scheme? ( first ( rest ( rest ( list 1 ( list 2 3 ) ( list 4 5 ) 6 )))) e) Dada la siguiente expresi\u00f3n, \u00bfqu\u00e9 devuelve Scheme? ( rest ( rest ' ( 1 ( 2 3 ) 4 5 ))) Lee el apartado 3 ( Estructuras de control ) del seminario de Scheme. Puedes ver el v\u00eddeo 3 en la p\u00e1gina de Moodle hasta el minuto 7:00. Haz el siguiente ejercicio. Ejercicio 5 . Predice lo que devolver\u00e1 Scheme cuando escribas las siguientes expresiones. Est\u00e1n ordenadas por dificultad de arriba abajo y de izquierda a derecha. Despu\u00e9s, pru\u00e9balas y comprueba si tu predicci\u00f3n era correcta. Si no lo era, intenta comprender por qu\u00e9. Instrucci\u00f3n Instrucci\u00f3n (equal? \"hola\" \"hola\") (+ (char->integer(integer->char 1200)) (char->integer #\\A)) (string-ref \"pepe\" 1) (string-length (make-string 7 #\\E)) (substring \"buenos dias\" 1 4) (define a 3) (define b (+ a 1)) (= \"hola\" \"hola\") (+ a b (* a b)) (string-ref (substring \"buenos dias\" 2 5) 1) (= a b) (define pi 3.14159) (if (and (> a b) (< b (* a b))) b a) pi (cond ((= a 4) 6) ((= b 4) (+ 6 7 a)) (else 25)) \"pi\" (+ 2 (if (> b a) b a)) (+ pi (+ pi pi)) (* (cond ((> a b) a) ((< a b) b) (else -1)) (+ a 1)) (+ (* pi pi) (- 2 pi pi pi pi)) ((if (< a b) + -) a b) Lee el resto del seminario, desde el apartado 4 hasta el final. Puedes ver el v\u00eddeo 3 en la p\u00e1gina de Moodle desde el minuto 7:00 hasta el final. Prueba las funciones ecuacion y convertir-temperatura y reflexiona sobre c\u00f3mo se implementan. Prueba las pruebas unitarias de la funci\u00f3n ecuacion . Cambia la definici\u00f3n de la funci\u00f3n para introducir un error y provocar un fallo en las pruebas unitarias. Arregla la definici\u00f3n de la funci\u00f3n para que vuelva a funcionar. Haz el siguiente ejercicio. Ejercicio 6 . Define una funci\u00f3n que calcule la distancia entre dos puntos, definidos por parejas de n\u00fameros enteros. A\u00f1ade los siguientes tests para comprobar que funciona correctamente: Entrada Salida p1:(0 0) p2:(0 10) 10 p1:(0 0) p2:(10 0) 10 p1:(0 0) p2:(10 10) 14.142135623730951","title":"Realizaci\u00f3n de la pr\u00e1ctica"},{"location":"practicas/practica01/practica01.html#entrega-de-la-practica","text":"Sube la soluci\u00f3n de los ejercicios a Moodle en el cuestionario Entrega pr\u00e1ctica 1 hasta el domingo 6 a las 21:00 h. Una vez finalizado el plazo de entrega podr\u00e1s revisar el cuestionario y visualizar la soluci\u00f3n del ejercicio 6. Una vez est\u00e9 disponible la soluci\u00f3n debes compararla con la tuya. Puedes consultar cualquier duda con tu profesor de pr\u00e1cticas en la clase de pr\u00e1cticas de la semana que viene. Lenguajes y Paradigmas de Programaci\u00f3n, curso 2021-22 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Domingo Gallardo, Cristina Pomares, Antonio Bot\u00eda, Francisco Mart\u00ednez","title":"Entrega de la pr\u00e1ctica"},{"location":"practicas/practica02/practica02.html","text":"Pr\u00e1ctica 2: Programaci\u00f3n funcional en Scheme \u00b6 Antes de la clase de pr\u00e1cticas \u00b6 Antes de empezar esta pr\u00e1ctica es importante que revises la soluci\u00f3n de la pr\u00e1ctica 1. Puedes preguntar las dudas al profesor de pr\u00e1cticas. Los siguientes ejercicios est\u00e1n basados en los conceptos de teor\u00eda vistos la semana pasada. Antes de la clase de pr\u00e1cticas debes repasar todos los conceptos y probar en el DrRacket todos los ejemplos del tema 2 Programaci\u00f3n Funcional hasta el apartado 2.6 Listas incluido. Ejercicios \u00b6 Abre el DrRacket y crea el fichero practica2.rkt en el que deber\u00e1s escribir todos los ejemplos y soluciones de los ejercicios que hagas. Escribe en comentarios tu nombre y apellidos. Usa tambi\u00e9n comentarios para separar secciones y realizar anotaciones. Incluye en el fichero todo el c\u00f3digo, ejemplos y resoluci\u00f3n de ejercicios, que hagas esta semana. Tambi\u00e9n debes a\u00f1adir casos de prueba al c\u00f3digo de todas las funciones que implementes, tal y como vimos al final del seminario de Scheme. Puedes usar algunos de los ejemplos de los enunciados, pero debes tambi\u00e9n construir algunos casos nuevos, con ejemplos creados por ti. Siempre debes incluir casos de prueba Los casos de prueba son un componente importante del c\u00f3digo, ya que permiten guardar en el propio c\u00f3digo una demostraci\u00f3n de que \u00e9ste funciona correctamente, as\u00ed como unos ejemplos de c\u00f3mo llamar a las funciones definidas. Ejercicio 1 \u00b6 a) Implementa la funci\u00f3n (binario-a-decimal b3 b2 b1 b0) que reciba 4 bits que representan un n\u00famero en binario y devuelva el n\u00famero decimal equivalente. ( binario-a-decimal 1 1 1 1 ) ; \u21d2 15 ( binario-a-decimal 0 1 1 0 ) ; \u21d2 6 ( binario-a-decimal 0 0 1 0 ) ; \u21d2 2 Nota : recuerda que para realizar esta conversi\u00f3n, se utiliza la siguiente f\u00f3rmula: n = b3 * 2\u02c63 + b2 * 2\u02c62 + b1 * 2\u02c61 + b0 * 2\u02c60 Para la implementaci\u00f3n de la expresi\u00f3n debes utilizar la funci\u00f3n expt . b) Implementa la funci\u00f3n (binario-a-hexadecimal b3 b2 b1 b0) que reciba 4 bits de un n\u00famero representado en binario y devuelva el car\u00e1cter correspondiente a su representaci\u00f3n en hexadecimal. ( binario-a-hexadecimal 1 1 1 1 ) ; \u21d2 #\\F ( binario-a-hexadecimal 0 1 1 0 ) ; \u21d2 #\\6 ( binario-a-hexadecimal 1 0 1 0 ) ; \u21d2 #\\A Nota : para realizar esta conversi\u00f3n, como paso intermedio debes pasar primero el n\u00famero binario a su representaci\u00f3n decimal (utilizando la funci\u00f3n definida en el apartado anterior) y despu\u00e9s a su correspondiente hexadecimal. Recuerda que la representaci\u00f3n hexadecimal de los n\u00fameros decimales del 0 al 9 es el car\u00e1cter correspondiente a ese n\u00famero, y que el n\u00famero decimal 10 se representa con el car\u00e1cter A, el 11 con el B, y as\u00ed sucesivamente hasta el 15 que es el F en hexadecimal. Para la implementaci\u00f3n de esta funci\u00f3n auxiliar que pasa de decimal a hexadecimal debes usar las funciones integer->char y char->integer . En la funci\u00f3n char->integer los caracteres consecutivos est\u00e1n asociados con n\u00fameros consecutivos. Por ejemplo, el entero correspondiente al car\u00e1cter #\\A es uno menos que el correspondiente al car\u00e1cter #\\B . Los caracteres de n\u00fameros y los de letras no son consecutivos. Ejercicio 2 \u00b6 Implementa la funci\u00f3n (menor-de-tres n1 n2 n3) que reciba tres n\u00fameros como argumento y devuelva el menor de los tres, intentando que el n\u00famero de condiciones sea m\u00ednima. No debes utilizar la funci\u00f3n min . Implementa dos versiones de la funci\u00f3n: versi\u00f3n 1: usando la forma especial if versi\u00f3n 2 (ll\u00e1mala menor-de-tres-v2 ): sin usar la forma especial if , sino definiendo una funci\u00f3n auxiliar (menor x y) que devuelva el menor de dos n\u00fameros (en esta s\u00ed que deber\u00edas usar if ) y construyendo la funci\u00f3n menor-de-tres-v2 como una composici\u00f3n de llamadas a esta funci\u00f3n auxiliar. ( menor-de-tres 2 8 1 ) ;; \u21d2 1 ( menor-de-tres-v2 3 0 3 ) ;; \u21d2 0 Ejercicio 3 \u00b6 a) Supongamos las definiciones ( define ( f x y ) ( cons x y )) ( define ( g x ) ( cons 2 x )) Realiza la evaluaci\u00f3n paso a paso de la siguiente expresi\u00f3n ( f ( g ( + 2 1 )) ( + 1 1 )) mediante el modelo de sustituci\u00f3n , utilizando tanto el orden aplicativo y como el orden normal . Escribe la soluci\u00f3n entre comentarios en el propio fichero .rkt de la pr\u00e1ctica. b) Supongamos las definiciones ( define ( f x ) ( / x 0 )) ( define ( g x y ) ( if ( = x 0 ) 0 y )) Igual que en el apartado anterior, realiza la evaluaci\u00f3n paso a paso de la siguiente expresi\u00f3n ( g 0 ( f 10 )) mediante el modelo de sustituci\u00f3n , utilizando tanto el orden aplicativo y como el orden normal . Y escribe la soluci\u00f3n entre comentarios en el propio fichero .rkt de la pr\u00e1ctica. Ejercicio 4 \u00b6 Implementa la funci\u00f3n (cadenas-mayores lista1 lista2) que recibe 2 listas con 3 cadenas y devuelve otra lista con las 3 cadenas de mayor longitud, comparando las cadenas de cada posici\u00f3n de la lista. En el caso en que las cadenas tengan la misma longitud, se devuelve la cadena de la primera lista. ( cadenas-mayores ' ( \"hola\" \"que\" \"tal\" ) ' ( \"meme\" \"y\" \"adios\" )) ; \u21d2 (\"hola\" \"que\" \"adios\") ( cadenas-mayores ' ( \"esto\" \"es\" \"lpp\" ) ' ( \"hoy\" \"hay\" \"clase\" )) ; \u21d2 (\"esto\" \"hay\" \"clase\") Ejercicio 5 \u00b6 Supongamos que queremos programar un juego de cartas. Lo primero que debemos hacer es definir una forma de representar las cartas y funciones que trabajen con esa representaci\u00f3n. En este ejercicio vamos a implementar esas funciones. Representaremos una carta por un s\u00edmbolo con dos letras: la primera indicar\u00e1 su n\u00famero o figura y la segunda el palo de la carta. Por ejemplo: ( define tres-de-oros ' 3O ) ( define as-de-copas ' AC ) ( define caballo-de-espadas ' CE ) Debemos definir la funci\u00f3n carta que devuelve una pareja con el valor correspondiente a su orden en la baraja espa\u00f1ola (un n\u00famero) y el palo de la carta (un s\u00edmbolo). ( carta tres-de-oros ) ; \u21d2 (3 . Oros) ( carta as-de-copas ) ; \u21d2 (1 . Copas) ( carta ' RB ) ; \u21d2 (12 . Bastos) Los valores de las cartas de la baraja espa\u00f1ola son: A (As) \u21d2 1 S (Sota) \u21d2 10 C (Caballo) \u21d2 11 R (Rey) \u21d2 12 Para realizar el ejercicio debes definir en primer lugar las funciones (obten-palo char) y (obten-valor char) que devuelven el palo y el valor, dado un car\u00e1cter. Y debes implementar la funci\u00f3n carta usando estas dos funciones. ( obten-palo #\\O ) ; \u21d2 Oros ( obten-palo #\\E ) ; \u21d2 Espadas ( obten-valor #\\3 ) ; \u21d2 3 ( obten-valor #\\S ) ; \u21d2 10 Pista Puedes utilizar las funciones (symbol->string simbolo) que convierte un s\u00edmbolo en una cadena y (string-ref cadena pos) que devuelve el car\u00e1cter de una cadena situado en una determinada posici\u00f3n. Ejercicio 6 \u00b6 Implementa la funci\u00f3n (palos-mano-cartas carta1 carta2 carta3) que recibe 3 cartas de la baraja espa\u00f1ola y devuelve una cadena indicando la cantidad de palos repetidos: \"todas del mismo palo\", \"palos distintos\" o \"dos cartas con el mismo palo\". Para obtener los palos de las cartas debes usar las funciones definidas en el ejercicio anterior. Ejemplos: ( palos-mano-cartas ' 3O ' 7O ' 2O ) ; \u21d2 \"todas del mismo palo\" ( palos-mano-cartas ' 3O ' 7C ' 2E ) ; \u21d2 \"palos distintos\" ( palos-mano-cartas ' 3O ' 7O ' 2E ) ; \u21d2 \"dos cartas con el mismo palo\" Entrega de la pr\u00e1ctica \u00b6 Sube la soluci\u00f3n de los ejercicios al cuestionario de Moodle Entrega pr\u00e1ctica 2 hasta el domingo 13 de febrero a las 21:00 h. Tal y como hemos comentado al comienzo de la pr\u00e1ctica, debes incluir casos de prueba en todo el c\u00f3digo que escribas. Una vez finalizado el plazo de entrega podr\u00e1s revisar el cuestionario y visualizar la soluci\u00f3n. Corrige la entrega, comparando la soluci\u00f3n con la tuya. Puedes consultar cualquier duda con tu profesor en la clase de pr\u00e1cticas de la semana que viene. Lenguajes y Paradigmas de Programaci\u00f3n, curso 2021-22 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Domingo Gallardo, Cristina Pomares, Antonio Bot\u00eda, Francisco Mart\u00ednez","title":"Pr\u00e1ctica 2"},{"location":"practicas/practica02/practica02.html#practica-2-programacion-funcional-en-scheme","text":"","title":"Pr\u00e1ctica 2: Programaci\u00f3n funcional en Scheme"},{"location":"practicas/practica02/practica02.html#antes-de-la-clase-de-practicas","text":"Antes de empezar esta pr\u00e1ctica es importante que revises la soluci\u00f3n de la pr\u00e1ctica 1. Puedes preguntar las dudas al profesor de pr\u00e1cticas. Los siguientes ejercicios est\u00e1n basados en los conceptos de teor\u00eda vistos la semana pasada. Antes de la clase de pr\u00e1cticas debes repasar todos los conceptos y probar en el DrRacket todos los ejemplos del tema 2 Programaci\u00f3n Funcional hasta el apartado 2.6 Listas incluido.","title":"Antes de la clase de pr\u00e1cticas"},{"location":"practicas/practica02/practica02.html#ejercicios","text":"Abre el DrRacket y crea el fichero practica2.rkt en el que deber\u00e1s escribir todos los ejemplos y soluciones de los ejercicios que hagas. Escribe en comentarios tu nombre y apellidos. Usa tambi\u00e9n comentarios para separar secciones y realizar anotaciones. Incluye en el fichero todo el c\u00f3digo, ejemplos y resoluci\u00f3n de ejercicios, que hagas esta semana. Tambi\u00e9n debes a\u00f1adir casos de prueba al c\u00f3digo de todas las funciones que implementes, tal y como vimos al final del seminario de Scheme. Puedes usar algunos de los ejemplos de los enunciados, pero debes tambi\u00e9n construir algunos casos nuevos, con ejemplos creados por ti. Siempre debes incluir casos de prueba Los casos de prueba son un componente importante del c\u00f3digo, ya que permiten guardar en el propio c\u00f3digo una demostraci\u00f3n de que \u00e9ste funciona correctamente, as\u00ed como unos ejemplos de c\u00f3mo llamar a las funciones definidas.","title":"Ejercicios"},{"location":"practicas/practica02/practica02.html#ejercicio-1","text":"a) Implementa la funci\u00f3n (binario-a-decimal b3 b2 b1 b0) que reciba 4 bits que representan un n\u00famero en binario y devuelva el n\u00famero decimal equivalente. ( binario-a-decimal 1 1 1 1 ) ; \u21d2 15 ( binario-a-decimal 0 1 1 0 ) ; \u21d2 6 ( binario-a-decimal 0 0 1 0 ) ; \u21d2 2 Nota : recuerda que para realizar esta conversi\u00f3n, se utiliza la siguiente f\u00f3rmula: n = b3 * 2\u02c63 + b2 * 2\u02c62 + b1 * 2\u02c61 + b0 * 2\u02c60 Para la implementaci\u00f3n de la expresi\u00f3n debes utilizar la funci\u00f3n expt . b) Implementa la funci\u00f3n (binario-a-hexadecimal b3 b2 b1 b0) que reciba 4 bits de un n\u00famero representado en binario y devuelva el car\u00e1cter correspondiente a su representaci\u00f3n en hexadecimal. ( binario-a-hexadecimal 1 1 1 1 ) ; \u21d2 #\\F ( binario-a-hexadecimal 0 1 1 0 ) ; \u21d2 #\\6 ( binario-a-hexadecimal 1 0 1 0 ) ; \u21d2 #\\A Nota : para realizar esta conversi\u00f3n, como paso intermedio debes pasar primero el n\u00famero binario a su representaci\u00f3n decimal (utilizando la funci\u00f3n definida en el apartado anterior) y despu\u00e9s a su correspondiente hexadecimal. Recuerda que la representaci\u00f3n hexadecimal de los n\u00fameros decimales del 0 al 9 es el car\u00e1cter correspondiente a ese n\u00famero, y que el n\u00famero decimal 10 se representa con el car\u00e1cter A, el 11 con el B, y as\u00ed sucesivamente hasta el 15 que es el F en hexadecimal. Para la implementaci\u00f3n de esta funci\u00f3n auxiliar que pasa de decimal a hexadecimal debes usar las funciones integer->char y char->integer . En la funci\u00f3n char->integer los caracteres consecutivos est\u00e1n asociados con n\u00fameros consecutivos. Por ejemplo, el entero correspondiente al car\u00e1cter #\\A es uno menos que el correspondiente al car\u00e1cter #\\B . Los caracteres de n\u00fameros y los de letras no son consecutivos.","title":"Ejercicio 1"},{"location":"practicas/practica02/practica02.html#ejercicio-2","text":"Implementa la funci\u00f3n (menor-de-tres n1 n2 n3) que reciba tres n\u00fameros como argumento y devuelva el menor de los tres, intentando que el n\u00famero de condiciones sea m\u00ednima. No debes utilizar la funci\u00f3n min . Implementa dos versiones de la funci\u00f3n: versi\u00f3n 1: usando la forma especial if versi\u00f3n 2 (ll\u00e1mala menor-de-tres-v2 ): sin usar la forma especial if , sino definiendo una funci\u00f3n auxiliar (menor x y) que devuelva el menor de dos n\u00fameros (en esta s\u00ed que deber\u00edas usar if ) y construyendo la funci\u00f3n menor-de-tres-v2 como una composici\u00f3n de llamadas a esta funci\u00f3n auxiliar. ( menor-de-tres 2 8 1 ) ;; \u21d2 1 ( menor-de-tres-v2 3 0 3 ) ;; \u21d2 0","title":"Ejercicio 2"},{"location":"practicas/practica02/practica02.html#ejercicio-3","text":"a) Supongamos las definiciones ( define ( f x y ) ( cons x y )) ( define ( g x ) ( cons 2 x )) Realiza la evaluaci\u00f3n paso a paso de la siguiente expresi\u00f3n ( f ( g ( + 2 1 )) ( + 1 1 )) mediante el modelo de sustituci\u00f3n , utilizando tanto el orden aplicativo y como el orden normal . Escribe la soluci\u00f3n entre comentarios en el propio fichero .rkt de la pr\u00e1ctica. b) Supongamos las definiciones ( define ( f x ) ( / x 0 )) ( define ( g x y ) ( if ( = x 0 ) 0 y )) Igual que en el apartado anterior, realiza la evaluaci\u00f3n paso a paso de la siguiente expresi\u00f3n ( g 0 ( f 10 )) mediante el modelo de sustituci\u00f3n , utilizando tanto el orden aplicativo y como el orden normal . Y escribe la soluci\u00f3n entre comentarios en el propio fichero .rkt de la pr\u00e1ctica.","title":"Ejercicio 3"},{"location":"practicas/practica02/practica02.html#ejercicio-4","text":"Implementa la funci\u00f3n (cadenas-mayores lista1 lista2) que recibe 2 listas con 3 cadenas y devuelve otra lista con las 3 cadenas de mayor longitud, comparando las cadenas de cada posici\u00f3n de la lista. En el caso en que las cadenas tengan la misma longitud, se devuelve la cadena de la primera lista. ( cadenas-mayores ' ( \"hola\" \"que\" \"tal\" ) ' ( \"meme\" \"y\" \"adios\" )) ; \u21d2 (\"hola\" \"que\" \"adios\") ( cadenas-mayores ' ( \"esto\" \"es\" \"lpp\" ) ' ( \"hoy\" \"hay\" \"clase\" )) ; \u21d2 (\"esto\" \"hay\" \"clase\")","title":"Ejercicio 4"},{"location":"practicas/practica02/practica02.html#ejercicio-5","text":"Supongamos que queremos programar un juego de cartas. Lo primero que debemos hacer es definir una forma de representar las cartas y funciones que trabajen con esa representaci\u00f3n. En este ejercicio vamos a implementar esas funciones. Representaremos una carta por un s\u00edmbolo con dos letras: la primera indicar\u00e1 su n\u00famero o figura y la segunda el palo de la carta. Por ejemplo: ( define tres-de-oros ' 3O ) ( define as-de-copas ' AC ) ( define caballo-de-espadas ' CE ) Debemos definir la funci\u00f3n carta que devuelve una pareja con el valor correspondiente a su orden en la baraja espa\u00f1ola (un n\u00famero) y el palo de la carta (un s\u00edmbolo). ( carta tres-de-oros ) ; \u21d2 (3 . Oros) ( carta as-de-copas ) ; \u21d2 (1 . Copas) ( carta ' RB ) ; \u21d2 (12 . Bastos) Los valores de las cartas de la baraja espa\u00f1ola son: A (As) \u21d2 1 S (Sota) \u21d2 10 C (Caballo) \u21d2 11 R (Rey) \u21d2 12 Para realizar el ejercicio debes definir en primer lugar las funciones (obten-palo char) y (obten-valor char) que devuelven el palo y el valor, dado un car\u00e1cter. Y debes implementar la funci\u00f3n carta usando estas dos funciones. ( obten-palo #\\O ) ; \u21d2 Oros ( obten-palo #\\E ) ; \u21d2 Espadas ( obten-valor #\\3 ) ; \u21d2 3 ( obten-valor #\\S ) ; \u21d2 10 Pista Puedes utilizar las funciones (symbol->string simbolo) que convierte un s\u00edmbolo en una cadena y (string-ref cadena pos) que devuelve el car\u00e1cter de una cadena situado en una determinada posici\u00f3n.","title":"Ejercicio 5"},{"location":"practicas/practica02/practica02.html#ejercicio-6","text":"Implementa la funci\u00f3n (palos-mano-cartas carta1 carta2 carta3) que recibe 3 cartas de la baraja espa\u00f1ola y devuelve una cadena indicando la cantidad de palos repetidos: \"todas del mismo palo\", \"palos distintos\" o \"dos cartas con el mismo palo\". Para obtener los palos de las cartas debes usar las funciones definidas en el ejercicio anterior. Ejemplos: ( palos-mano-cartas ' 3O ' 7O ' 2O ) ; \u21d2 \"todas del mismo palo\" ( palos-mano-cartas ' 3O ' 7C ' 2E ) ; \u21d2 \"palos distintos\" ( palos-mano-cartas ' 3O ' 7O ' 2E ) ; \u21d2 \"dos cartas con el mismo palo\"","title":"Ejercicio 6"},{"location":"practicas/practica02/practica02.html#entrega-de-la-practica","text":"Sube la soluci\u00f3n de los ejercicios al cuestionario de Moodle Entrega pr\u00e1ctica 2 hasta el domingo 13 de febrero a las 21:00 h. Tal y como hemos comentado al comienzo de la pr\u00e1ctica, debes incluir casos de prueba en todo el c\u00f3digo que escribas. Una vez finalizado el plazo de entrega podr\u00e1s revisar el cuestionario y visualizar la soluci\u00f3n. Corrige la entrega, comparando la soluci\u00f3n con la tuya. Puedes consultar cualquier duda con tu profesor en la clase de pr\u00e1cticas de la semana que viene. Lenguajes y Paradigmas de Programaci\u00f3n, curso 2021-22 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Domingo Gallardo, Cristina Pomares, Antonio Bot\u00eda, Francisco Mart\u00ednez","title":"Entrega de la pr\u00e1ctica"},{"location":"practicas/practica03/practica03.html","text":"Pr\u00e1ctica 3: Recursi\u00f3n, parejas y diagramas box-and-pointer \u00b6 Antes de la clase de pr\u00e1cticas \u00b6 Antes de empezar esta pr\u00e1ctica es importante que revises la soluci\u00f3n de la pr\u00e1ctica 2. Puedes preguntar las dudas al profesor de pr\u00e1cticas. Los siguientes ejercicios est\u00e1n basados en los conceptos de teor\u00eda vistos la semana pasada. Antes de la clase de pr\u00e1cticas debes repasar todos los conceptos y probar en el DrRacket todos los ejemplos de los siguientes apartados del tema 2 Programaci\u00f3n Funcional : 2.7 Recursi\u00f3n 2.8 Recursi\u00f3n y listas 3 Tipos de datos compuestos en Scheme 4 Listas en Scheme Ejercicios \u00b6 Abre el DrRacket y crea el fichero practica3.rkt en el que deber\u00e1s escribir todos los ejemplos y soluciones de los ejercicios que hagas. Funci\u00f3n auxiliar para dibujar diagramas caja y puntero \u00b6 Descarga el fichero lpp.rkt , pulsando el bot\u00f3n derecho del rat\u00f3n y seleccionando la opci\u00f3n Guardar como lpp.rkt . Gu\u00e1rdalo en la misma carpeta en la que tengas el fichero practica3.rkt . Contiene la definici\u00f3n de una funci\u00f3n auxiliar (caja-puntero dato) que te permite crear diagramas caja y puntero de estructuras de parejas. El siguiente programa muestra un ejemplo del uso de esta funci\u00f3n: #lang racket ( require rackunit ) ( require \"lpp.rkt\" ) ( caja-puntero ' ( 1 . 2 )) ( caja-puntero ( cons 1 ( cons 2 ( cons 3 4 )))) ( caja-puntero ( list 1 2 3 )) ( caja-puntero ' (( 1 2 ) . 2 )) ( caja-puntero ' ( 1 ( 2 3 ) 4 )) La siguiente imagen muestra la ejecuci\u00f3n del programa en el DrRacket. Puedes mirar el c\u00f3digo fuente del fichero lpp.rkt para curiosear c\u00f3mo est\u00e1 implementada la funci\u00f3n caja-puntero . Se utiliza la librer\u00eda de im\u00e1genes de Racket 2htdp/image . Para usar la librer\u00eda hay que incluir la siguiente l\u00ednea en nuestro programa: #lang racket ( require 2htdp/image ) Una cosa muy interesante de esta librer\u00eda es que define las im\u00e1genes como objetos de primera clase del lenguaje, que pueden asignarse a variables o pasarse como par\u00e1metro para construir otras im\u00e1genes. Lo podemos ver en el siguiente ejemplo: Incluso podemos incluir im\u00e1genes en listas: Ejercicio 1 \u00b6 a.1) Implementa la funci\u00f3n recursiva (minimo lista) que recibe una lista con n\u00fameros como argumento y devuelve el menor n\u00famero de la lista. Suponemos listas de 1 o m\u00e1s elementos. Para la implementaci\u00f3n debes usar la funci\u00f3n menor definida en la pr\u00e1ctica anterior. Pista Podemos expresar el caso general de la recursi\u00f3n de la siguiente forma: El m\u00ednimo de los elementos de una lista es el menor entre el primer elemento de la lista y el m\u00ednimo del resto de la lista. Y el caso base: El m\u00ednimo de una lista con un \u00fanico n\u00famero es ese n\u00famero. Ejemplos: ( minimo ' ( 1 8 6 4 3 )) ; \u21d2 1 ( minimo ' ( 1 -1 3 -6 4 )) ; \u21d2 -6 a.2) Vamos a investigar el funcionamiento de la recursi\u00f3n en la funci\u00f3n minimo . Supongamos la siguiente llamada: ( minimo ' ( 1 8 6 4 3 )) ; \u21d2 1 \u00bfQu\u00e9 lista se pasa como par\u00e1metro a la primera llamada recursiva a la funci\u00f3n? \u00bfQu\u00e9 devuelve esa llamada recursiva? \u00bfCon qu\u00e9 argumentos se llama a la funci\u00f3n menor que devuelve el resultado final? b) Implementa la funci\u00f3n recursiva (concatena lista-chars) que recibe una lista de caracteres y devuelve la cadena resultante de concatenarlos. Ejemplos: ( concatena ' ( #\\H #\\o #\\l #\\a )) ; \u21d2 \"Hola\" ( concatena ' ( #\\S #\\c #\\h #\\e #\\m #\\e #\\space #\\m #\\o #\\l #\\a )) ; \u21d2 \"Scheme mola\" c) Implementa la funci\u00f3n (contiene? cadena char) que comprueba si una cadena contiene un car\u00e1cter determinado. Debes usar la funci\u00f3n string->list e implementar la funci\u00f3n auxiliar recursiva (contiene-lista? lista dato) . Ejemplos: ( contiene? \"Hola\" #\\o ) ; \u21d2 #t ( contiene? \"Esto es una frase\" #\\space ) ; \u21d2 #t ( contiene? \"Hola\" #\\h ) ; \u21d2 #f Ejercicio 2 \u00b6 a) Implementa la funci\u00f3n recursiva (binario-a-decimal lista-bits) que reciba una lista de bits que representan un n\u00famero en binario (el primer elemento ser\u00e1 el bit m\u00e1s significativo) y devuelva el n\u00famero decimal equivalente. Pista Puedes utilizar la funci\u00f3n length . ( binario-a-decimal ' ( 1 1 1 1 )) ; \u21d2 15 ( binario-a-decimal ' ( 1 1 0 )) ; \u21d2 6 ( binario-a-decimal ' ( 1 0 )) ; \u21d2 2 b) Implementa la funci\u00f3n recursiva (ordenada-creciente? lista-nums) que recibe como argumento una lista de n\u00fameros y devuelve #t si los n\u00fameros de la lista est\u00e1n ordenados de forma creciente o #f en caso contrario. Suponemos listas de 1 o m\u00e1s elementos. ( ordenada-creciente? ' ( -1 23 45 59 99 )) ; \u21d2 #t ( ordenada-creciente? ' ( 12 50 -1 293 1000 )) ; \u21d2 #f ( ordenada-creciente? ' ( 3 )) ; \u21d2 #t Ejercicio 3 \u00b6 a.1) Dado el siguiente box & pointer , escribe la expresi\u00f3n en Scheme que define p1 usando el m\u00ednimo n\u00famero de llamadas a list y cons . No debes utilizar expresiones con quote . Puedes usar la funci\u00f3n gr\u00e1fica caja-puntero para comprobar si tu soluci\u00f3n es correcta. a.2) Escribe las expresiones que devuelven 2 y 4 a partir de p1 . Debes usar las funciones first y rest si el argumento es una lista y car y cdr si es una pareja que no forma parte de una lista. b.1) Dado el siguiente diagrama caja y puntero, escribe la expresi\u00f3n en Scheme que define p2 usando el m\u00ednimo n\u00famero de llamadas a list y cons . b.2) Escribe las expresiones que devuelven 9 y 2 a partir de p2 . Debes usar las funciones first y rest si el argumento es una lista y car y cdr si es una pareja que no forma parte de una lista. Ejercicio 4 \u00b6 Implementa la funci\u00f3n recursiva (contar-datos-iguales lista-parejas) que recibe una lista de parejas y devuelve el n\u00famero de parejas que tienen sus dos datos iguales. ( contar-datos-iguales ' (( 2 . 3 ) ( \"hola\" . \"hola\" ) ( \\#a . \\#a ) ( true . false ))) ; \u21d2 2 ( contar-datos-iguales ' (( 2 . \"hola\" ) ( \"hola\" . 3 ) ( \\#a . true ) ( \\#b . false ))) ; \u21d2 0 Ejercicio 5 \u00b6 Vamos a jugar al domin\u00f3. En el juego del domin\u00f3 las fichas tienen una pareja de valores. Podemos colocar una ficha en la partida cuando uno de los valores de la ficha coincide con el primer valor de la lista de fichas ya colocadas o con el \u00faltimo. Por ejemplo, supongamos que la partida ha formado la siguiente lista de fichas: (( 1 . 3 ) ( 3 . 0 ) ( 0 . 0 ) ( 0 . 4 ) ( 4 . 2 )) Esta es una lista correcta, porque coinciden los valores de las fichas que la forman (el valor derecho de una ficha con el izquierdo de la siguiente). Si tuvi\u00e9ramos en nuestra mano de fichas las fichas: (( 5 . 5 ) ( 3 . 2 ) ( 4 . 6 ) ( 6 . 6 )) podr\u00edamos colocar la ficha (3 . 2) al final de la lista de la partida (gir\u00e1ndola). a) Implementa la funci\u00f3n recursiva (domino-correcto? fichas) que recibe una lista de fichas resultantes de una partida de domin\u00f3 y comprueba si las fichas est\u00e1n colocadas de forma correcta. ( define partida ' (( 1 . 3 ) ( 3 . 0 ) ( 0 . 0 ) ( 0 . 4 ) ( 4 . 2 ))) ( domino-correcto? partida ) ; \u21d2 #t ( domino-correcto? ' (( 1 . 3 ))) ; \u21d2 #t ( domino-correcto? ' (( 1 . 4 ) ( 2 . 1 ))) ; \u21d2 #f b) Implementa la funci\u00f3n recursiva (juega? mano partida) que recibe una mano (una lista de fichas) y otra lista de fichas colocadas en la partida y devuelve #t si existe alguna ficha de la mano que se puede colocar en la partida. Para obtener la \u00faltima ficha de la partida debes usar e implementar la funci\u00f3n (ultimo lista) que devuelva el \u00faltimo elemento de una lista. Hazla tambi\u00e9n recursiva. (define mano '((5 . 5) (3 . 2) (4 . 6) (6 . 6))) (juega? mano partida) ; \u21d2 #t - podr\u00eda poner la ficha (3 . 2) (juega? mano '((0 . 0))) ; \u21d2 #f (juega? mano '((0 . 0) (0 . 1))) ; \u21d2 #f Ejercicio 6 \u00b6 a) Implementa las funciones (suma-izq pareja n) y (suma-der pareja n) definidas de la siguiente forma: (suma-izq pareja n) : devuelve una nueva pareja con la parte izquierda incrementada en n . (suma-der pareja n) : devuelve una nueva pareja con la parte derecha incrementada en n . Ejemplos: ( suma-izq ( cons 10 20 ) 3 ) ; \u21d2 (13 . 20) ( suma-der ( cons 10 20 ) 5 ) ; \u21d2 (10 . 25) b) Implementa la funci\u00f3n recursiva (suma-impares-pares lista-num) que devuelva una pareja cuya parte izquierda sea la suma de los n\u00fameros impares de la lista y la parte derecha la suma de los n\u00fameros pares. Debes utilizar las funciones auxiliares definidas en el apartado anterior. Tambi\u00e9n puedes utilizar las funciones predefinidas even? y odd? . Ejemplos: ( suma-impares-pares ' ( 3 2 1 4 8 7 6 5 )) ; \u21d2 (16 . 20) ( suma-impares-pares ' ( 3 1 5 )) ; \u21d2 (9 . 0) c) Recuerda la funci\u00f3n recursiva (veces lista id) que vimos en teor\u00eda: ( define ( veces lista id ) ( cond (( null? lista ) 0 ) (( equal? ( first lista ) id ) ( + 1 ( veces ( rest lista ) id ))) ( else ( veces ( rest lista ) id )))) ( veces ' ( a b a a b b ) ' a ) ; \u21d2 3 Reescribe la funci\u00f3n (veces lista id) para que solo aparezca una llamada recursiva en su c\u00f3digo. Ejercicio 7 \u00b6 Implementa la funci\u00f3n recursiva (cadena-mayor lista) que recibe un lista de cadenas y devuelve una pareja con la cadena de mayor longitud y dicha longitud. En el caso de que haya m\u00e1s de una cadena con la m\u00e1xima longitud, se devolver\u00e1 la \u00faltima de ellas que aparezca en la lista. En el caso en que la lista sea vac\u00eda se devolver\u00e1 la pareja con la cadena vac\u00eda y un 0 (la longitud de la cadena vac\u00eda). Pista : puedes utilizar la funci\u00f3n string-length ( cadena-mayor ' ( \"vamos\" \"a\" \"obtener\" \"la\" \"cadena\" \"mayor\" )) ; \u21d2 (\"obtener\" . 7) ( cadena-mayor ' ( \"prueba\" \"con\" \"maximo\" \"igual\" )) ; \u21d2 (\"maximo\" . 6) ( cadena-mayor ' ()) ; \u21d2 (\"\" . 0) Entrega de la pr\u00e1ctica \u00b6 Sube la soluci\u00f3n de los ejercicios al cuestionario de Moodle Entrega pr\u00e1ctica 3 hasta el domingo 20 de febrero a las 21:00 h. Tal y como hemos comentado al comienzo de la pr\u00e1ctica, debes incluir casos de prueba en todo el c\u00f3digo que escribas. Una vez finalizado el plazo de entrega podr\u00e1s revisar el cuestionario y visualizar la soluci\u00f3n. Corrige la entrega, comparando la soluci\u00f3n con la tuya. Puedes consultar cualquier duda con tu profesor en la clase de pr\u00e1cticas de la semana que viene. Lenguajes y Paradigmas de Programaci\u00f3n, curso 2021-22 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Domingo Gallardo, Cristina Pomares, Antonio Bot\u00eda, Francisco Mart\u00ednez","title":"Pr\u00e1ctica 3"},{"location":"practicas/practica03/practica03.html#practica-3-recursion-parejas-y-diagramas-box-and-pointer","text":"","title":"Pr\u00e1ctica 3: Recursi\u00f3n, parejas y diagramas box-and-pointer"},{"location":"practicas/practica03/practica03.html#antes-de-la-clase-de-practicas","text":"Antes de empezar esta pr\u00e1ctica es importante que revises la soluci\u00f3n de la pr\u00e1ctica 2. Puedes preguntar las dudas al profesor de pr\u00e1cticas. Los siguientes ejercicios est\u00e1n basados en los conceptos de teor\u00eda vistos la semana pasada. Antes de la clase de pr\u00e1cticas debes repasar todos los conceptos y probar en el DrRacket todos los ejemplos de los siguientes apartados del tema 2 Programaci\u00f3n Funcional : 2.7 Recursi\u00f3n 2.8 Recursi\u00f3n y listas 3 Tipos de datos compuestos en Scheme 4 Listas en Scheme","title":"Antes de la clase de pr\u00e1cticas"},{"location":"practicas/practica03/practica03.html#ejercicios","text":"Abre el DrRacket y crea el fichero practica3.rkt en el que deber\u00e1s escribir todos los ejemplos y soluciones de los ejercicios que hagas.","title":"Ejercicios"},{"location":"practicas/practica03/practica03.html#funcion-auxiliar-para-dibujar-diagramas-caja-y-puntero","text":"Descarga el fichero lpp.rkt , pulsando el bot\u00f3n derecho del rat\u00f3n y seleccionando la opci\u00f3n Guardar como lpp.rkt . Gu\u00e1rdalo en la misma carpeta en la que tengas el fichero practica3.rkt . Contiene la definici\u00f3n de una funci\u00f3n auxiliar (caja-puntero dato) que te permite crear diagramas caja y puntero de estructuras de parejas. El siguiente programa muestra un ejemplo del uso de esta funci\u00f3n: #lang racket ( require rackunit ) ( require \"lpp.rkt\" ) ( caja-puntero ' ( 1 . 2 )) ( caja-puntero ( cons 1 ( cons 2 ( cons 3 4 )))) ( caja-puntero ( list 1 2 3 )) ( caja-puntero ' (( 1 2 ) . 2 )) ( caja-puntero ' ( 1 ( 2 3 ) 4 )) La siguiente imagen muestra la ejecuci\u00f3n del programa en el DrRacket. Puedes mirar el c\u00f3digo fuente del fichero lpp.rkt para curiosear c\u00f3mo est\u00e1 implementada la funci\u00f3n caja-puntero . Se utiliza la librer\u00eda de im\u00e1genes de Racket 2htdp/image . Para usar la librer\u00eda hay que incluir la siguiente l\u00ednea en nuestro programa: #lang racket ( require 2htdp/image ) Una cosa muy interesante de esta librer\u00eda es que define las im\u00e1genes como objetos de primera clase del lenguaje, que pueden asignarse a variables o pasarse como par\u00e1metro para construir otras im\u00e1genes. Lo podemos ver en el siguiente ejemplo: Incluso podemos incluir im\u00e1genes en listas:","title":"Funci\u00f3n auxiliar para dibujar diagramas caja y puntero"},{"location":"practicas/practica03/practica03.html#ejercicio-1","text":"a.1) Implementa la funci\u00f3n recursiva (minimo lista) que recibe una lista con n\u00fameros como argumento y devuelve el menor n\u00famero de la lista. Suponemos listas de 1 o m\u00e1s elementos. Para la implementaci\u00f3n debes usar la funci\u00f3n menor definida en la pr\u00e1ctica anterior. Pista Podemos expresar el caso general de la recursi\u00f3n de la siguiente forma: El m\u00ednimo de los elementos de una lista es el menor entre el primer elemento de la lista y el m\u00ednimo del resto de la lista. Y el caso base: El m\u00ednimo de una lista con un \u00fanico n\u00famero es ese n\u00famero. Ejemplos: ( minimo ' ( 1 8 6 4 3 )) ; \u21d2 1 ( minimo ' ( 1 -1 3 -6 4 )) ; \u21d2 -6 a.2) Vamos a investigar el funcionamiento de la recursi\u00f3n en la funci\u00f3n minimo . Supongamos la siguiente llamada: ( minimo ' ( 1 8 6 4 3 )) ; \u21d2 1 \u00bfQu\u00e9 lista se pasa como par\u00e1metro a la primera llamada recursiva a la funci\u00f3n? \u00bfQu\u00e9 devuelve esa llamada recursiva? \u00bfCon qu\u00e9 argumentos se llama a la funci\u00f3n menor que devuelve el resultado final? b) Implementa la funci\u00f3n recursiva (concatena lista-chars) que recibe una lista de caracteres y devuelve la cadena resultante de concatenarlos. Ejemplos: ( concatena ' ( #\\H #\\o #\\l #\\a )) ; \u21d2 \"Hola\" ( concatena ' ( #\\S #\\c #\\h #\\e #\\m #\\e #\\space #\\m #\\o #\\l #\\a )) ; \u21d2 \"Scheme mola\" c) Implementa la funci\u00f3n (contiene? cadena char) que comprueba si una cadena contiene un car\u00e1cter determinado. Debes usar la funci\u00f3n string->list e implementar la funci\u00f3n auxiliar recursiva (contiene-lista? lista dato) . Ejemplos: ( contiene? \"Hola\" #\\o ) ; \u21d2 #t ( contiene? \"Esto es una frase\" #\\space ) ; \u21d2 #t ( contiene? \"Hola\" #\\h ) ; \u21d2 #f","title":"Ejercicio 1"},{"location":"practicas/practica03/practica03.html#ejercicio-2","text":"a) Implementa la funci\u00f3n recursiva (binario-a-decimal lista-bits) que reciba una lista de bits que representan un n\u00famero en binario (el primer elemento ser\u00e1 el bit m\u00e1s significativo) y devuelva el n\u00famero decimal equivalente. Pista Puedes utilizar la funci\u00f3n length . ( binario-a-decimal ' ( 1 1 1 1 )) ; \u21d2 15 ( binario-a-decimal ' ( 1 1 0 )) ; \u21d2 6 ( binario-a-decimal ' ( 1 0 )) ; \u21d2 2 b) Implementa la funci\u00f3n recursiva (ordenada-creciente? lista-nums) que recibe como argumento una lista de n\u00fameros y devuelve #t si los n\u00fameros de la lista est\u00e1n ordenados de forma creciente o #f en caso contrario. Suponemos listas de 1 o m\u00e1s elementos. ( ordenada-creciente? ' ( -1 23 45 59 99 )) ; \u21d2 #t ( ordenada-creciente? ' ( 12 50 -1 293 1000 )) ; \u21d2 #f ( ordenada-creciente? ' ( 3 )) ; \u21d2 #t","title":"Ejercicio 2"},{"location":"practicas/practica03/practica03.html#ejercicio-3","text":"a.1) Dado el siguiente box & pointer , escribe la expresi\u00f3n en Scheme que define p1 usando el m\u00ednimo n\u00famero de llamadas a list y cons . No debes utilizar expresiones con quote . Puedes usar la funci\u00f3n gr\u00e1fica caja-puntero para comprobar si tu soluci\u00f3n es correcta. a.2) Escribe las expresiones que devuelven 2 y 4 a partir de p1 . Debes usar las funciones first y rest si el argumento es una lista y car y cdr si es una pareja que no forma parte de una lista. b.1) Dado el siguiente diagrama caja y puntero, escribe la expresi\u00f3n en Scheme que define p2 usando el m\u00ednimo n\u00famero de llamadas a list y cons . b.2) Escribe las expresiones que devuelven 9 y 2 a partir de p2 . Debes usar las funciones first y rest si el argumento es una lista y car y cdr si es una pareja que no forma parte de una lista.","title":"Ejercicio 3"},{"location":"practicas/practica03/practica03.html#ejercicio-4","text":"Implementa la funci\u00f3n recursiva (contar-datos-iguales lista-parejas) que recibe una lista de parejas y devuelve el n\u00famero de parejas que tienen sus dos datos iguales. ( contar-datos-iguales ' (( 2 . 3 ) ( \"hola\" . \"hola\" ) ( \\#a . \\#a ) ( true . false ))) ; \u21d2 2 ( contar-datos-iguales ' (( 2 . \"hola\" ) ( \"hola\" . 3 ) ( \\#a . true ) ( \\#b . false ))) ; \u21d2 0","title":"Ejercicio 4"},{"location":"practicas/practica03/practica03.html#ejercicio-5","text":"Vamos a jugar al domin\u00f3. En el juego del domin\u00f3 las fichas tienen una pareja de valores. Podemos colocar una ficha en la partida cuando uno de los valores de la ficha coincide con el primer valor de la lista de fichas ya colocadas o con el \u00faltimo. Por ejemplo, supongamos que la partida ha formado la siguiente lista de fichas: (( 1 . 3 ) ( 3 . 0 ) ( 0 . 0 ) ( 0 . 4 ) ( 4 . 2 )) Esta es una lista correcta, porque coinciden los valores de las fichas que la forman (el valor derecho de una ficha con el izquierdo de la siguiente). Si tuvi\u00e9ramos en nuestra mano de fichas las fichas: (( 5 . 5 ) ( 3 . 2 ) ( 4 . 6 ) ( 6 . 6 )) podr\u00edamos colocar la ficha (3 . 2) al final de la lista de la partida (gir\u00e1ndola). a) Implementa la funci\u00f3n recursiva (domino-correcto? fichas) que recibe una lista de fichas resultantes de una partida de domin\u00f3 y comprueba si las fichas est\u00e1n colocadas de forma correcta. ( define partida ' (( 1 . 3 ) ( 3 . 0 ) ( 0 . 0 ) ( 0 . 4 ) ( 4 . 2 ))) ( domino-correcto? partida ) ; \u21d2 #t ( domino-correcto? ' (( 1 . 3 ))) ; \u21d2 #t ( domino-correcto? ' (( 1 . 4 ) ( 2 . 1 ))) ; \u21d2 #f b) Implementa la funci\u00f3n recursiva (juega? mano partida) que recibe una mano (una lista de fichas) y otra lista de fichas colocadas en la partida y devuelve #t si existe alguna ficha de la mano que se puede colocar en la partida. Para obtener la \u00faltima ficha de la partida debes usar e implementar la funci\u00f3n (ultimo lista) que devuelva el \u00faltimo elemento de una lista. Hazla tambi\u00e9n recursiva. (define mano '((5 . 5) (3 . 2) (4 . 6) (6 . 6))) (juega? mano partida) ; \u21d2 #t - podr\u00eda poner la ficha (3 . 2) (juega? mano '((0 . 0))) ; \u21d2 #f (juega? mano '((0 . 0) (0 . 1))) ; \u21d2 #f","title":"Ejercicio 5"},{"location":"practicas/practica03/practica03.html#ejercicio-6","text":"a) Implementa las funciones (suma-izq pareja n) y (suma-der pareja n) definidas de la siguiente forma: (suma-izq pareja n) : devuelve una nueva pareja con la parte izquierda incrementada en n . (suma-der pareja n) : devuelve una nueva pareja con la parte derecha incrementada en n . Ejemplos: ( suma-izq ( cons 10 20 ) 3 ) ; \u21d2 (13 . 20) ( suma-der ( cons 10 20 ) 5 ) ; \u21d2 (10 . 25) b) Implementa la funci\u00f3n recursiva (suma-impares-pares lista-num) que devuelva una pareja cuya parte izquierda sea la suma de los n\u00fameros impares de la lista y la parte derecha la suma de los n\u00fameros pares. Debes utilizar las funciones auxiliares definidas en el apartado anterior. Tambi\u00e9n puedes utilizar las funciones predefinidas even? y odd? . Ejemplos: ( suma-impares-pares ' ( 3 2 1 4 8 7 6 5 )) ; \u21d2 (16 . 20) ( suma-impares-pares ' ( 3 1 5 )) ; \u21d2 (9 . 0) c) Recuerda la funci\u00f3n recursiva (veces lista id) que vimos en teor\u00eda: ( define ( veces lista id ) ( cond (( null? lista ) 0 ) (( equal? ( first lista ) id ) ( + 1 ( veces ( rest lista ) id ))) ( else ( veces ( rest lista ) id )))) ( veces ' ( a b a a b b ) ' a ) ; \u21d2 3 Reescribe la funci\u00f3n (veces lista id) para que solo aparezca una llamada recursiva en su c\u00f3digo.","title":"Ejercicio 6"},{"location":"practicas/practica03/practica03.html#ejercicio-7","text":"Implementa la funci\u00f3n recursiva (cadena-mayor lista) que recibe un lista de cadenas y devuelve una pareja con la cadena de mayor longitud y dicha longitud. En el caso de que haya m\u00e1s de una cadena con la m\u00e1xima longitud, se devolver\u00e1 la \u00faltima de ellas que aparezca en la lista. En el caso en que la lista sea vac\u00eda se devolver\u00e1 la pareja con la cadena vac\u00eda y un 0 (la longitud de la cadena vac\u00eda). Pista : puedes utilizar la funci\u00f3n string-length ( cadena-mayor ' ( \"vamos\" \"a\" \"obtener\" \"la\" \"cadena\" \"mayor\" )) ; \u21d2 (\"obtener\" . 7) ( cadena-mayor ' ( \"prueba\" \"con\" \"maximo\" \"igual\" )) ; \u21d2 (\"maximo\" . 6) ( cadena-mayor ' ()) ; \u21d2 (\"\" . 0)","title":"Ejercicio 7"},{"location":"practicas/practica03/practica03.html#entrega-de-la-practica","text":"Sube la soluci\u00f3n de los ejercicios al cuestionario de Moodle Entrega pr\u00e1ctica 3 hasta el domingo 20 de febrero a las 21:00 h. Tal y como hemos comentado al comienzo de la pr\u00e1ctica, debes incluir casos de prueba en todo el c\u00f3digo que escribas. Una vez finalizado el plazo de entrega podr\u00e1s revisar el cuestionario y visualizar la soluci\u00f3n. Corrige la entrega, comparando la soluci\u00f3n con la tuya. Puedes consultar cualquier duda con tu profesor en la clase de pr\u00e1cticas de la semana que viene. Lenguajes y Paradigmas de Programaci\u00f3n, curso 2021-22 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Domingo Gallardo, Cristina Pomares, Antonio Bot\u00eda, Francisco Mart\u00ednez","title":"Entrega de la pr\u00e1ctica"},{"location":"practicas/practica04/practica04.html","text":"Pr\u00e1ctica 4: Funciones recursivas con listas \u00b6 Antes de la clase de pr\u00e1cticas \u00b6 Antes de empezar esta pr\u00e1ctica es importante que revises la soluci\u00f3n de la pr\u00e1ctica 3. Puedes preguntar las dudas al profesor de pr\u00e1cticas. Los siguientes ejercicios est\u00e1n basados en los conceptos de teor\u00eda vistos la semana pasada. Antes de la clase de pr\u00e1cticas debes repasar todos los conceptos y probar en el DrRacket todos los ejemplos de los siguientes apartados del tema 2 Programaci\u00f3n Funcional : 4.3. Funciones recursivas que construyen listas 4.4. Funciones con n\u00famero variable de argumentos 5 Funciones como tipos de datos de primera clase (incluido hasta el apartado 5.3. Funci\u00f3n apply ) Ejercicios \u00b6 Ejercicio 1 \u00b6 a) Implementa la funci\u00f3n recursiva (contiene-prefijo prefijo lista-pal) que recibe una cadena y una lista de palabras. Devuelve una lista con los booleanos resultantes de comprobar si la cadena es prefijo de cada una de las palabras de la lista. Debes definir una funci\u00f3n auxiliar (es-prefijo? pal1 pal2) que compruebe si la palabra 1 es prefijo de la palabra 2. Pista Puedes usar la funci\u00f3n (substring palabra inicio final) que devuelve la subcadena de la palabra que va desde la posici\u00f3n inicio hasta la posici\u00f3n final (sin incluir). Ejemplos: ( es-prefijo? \"ante\" \"anterior\" ) ; \u21d2 #t ( contiene-prefijo \"ante\" ' ( \"anterior\" \"ant\u00edgona\" \"antena\" \"anatema\" )) ; \u21d2 (#t #f #t #f) b) Vamos a generalizar la soluci\u00f3n del ejercicio 4 de la pr\u00e1ctica 2 e implementar la funci\u00f3n recursiva (cadenas-mayores lista1 lista2) teniendo en cuenta que las listas que recibe tienen un n\u00famero indeterminado de cadenas. En el caso en que una de las listas sea mayor que la otra, se deber\u00e1n a\u00f1adir todas sus cadenas a la lista resultante. Ejemplos: ( cadenas-mayores ' ( \"hola\" \"que\" \"tal\" ) ' ( \"adios\" )) ; \u21d2 (\"adios\" \"que\" \"tal\") ( cadenas-mayores ' ( \"hola\" \"que\" \"tal\" ) ' ( \"meme\" \"y\" \"adios\" )) ; \u21d2 (\"hola\" \"que\" \"adios\") ( cadenas-mayores ' ( \"la\" \"primera\" \"pr\u00e1ctica\" \"de\" \"recursi\u00f3n\" ) ' ( \"confiar\" \"en\" \"la\" \"recursi\u00f3n\" \"facilita\" \"su\" \"resoluci\u00f3n\" )) ; \u21d2 (\"confiar\" \"primera\" \"pr\u00e1ctica\" \"recursi\u00f3n\" \"recursi\u00f3n\" \"su\" \"resoluci\u00f3n\") c) Implementa la funci\u00f3n recursiva (inserta-pos dato pos lista) que recibe un dato, una posici\u00f3n y una lista e inserta el dato en la posici\u00f3n indicada de la lista. Si la posici\u00f3n es 0, el dato se inserta en cabeza. Suponemos que la posici\u00f3n siempre ser\u00e1 positiva y menor o igual que la longitud de la lista. Ejemplos: ( inserta-pos ' b 2 ' ( a a a a )) ; \u21d2 '(a a b a a) ( inserta-pos ' b 0 ' ( a a a a )) ; \u21d2 '(b a a a a) d) Implementa la funci\u00f3n recursiva (inserta-ordenada n lista-ordenada) que recibe un n\u00famero y una lista de n\u00fameros ordenados de menor a mayor y devuelve la lista resultante de insertar el n\u00famero n en la posici\u00f3n correcta para que la lista siga estando ordenada. Ejemplo: ( inserta-ordenada 10 ' ( -8 2 3 11 20 )) ; \u21d2 (-8 2 3 10 11 20) Usando la funci\u00f3n anterior inserta-ordenada implementa la funci\u00f3n recursiva (ordena lista) que recibe una lista de n\u00fameros y devuelve una lista ordenada. Ejemplo: ( ordena ' ( 2 -1 100 4 -6 )) ; \u21d2 (-6 -1 2 4 100) Ejercicio 2 \u00b6 Vamos a implementar distintas versiones de funciones que expanden una lista original. En el primer apartado definiremos una funci\u00f3n auxiliar que se deber\u00e1 usar en todos los dem\u00e1s apartados. a) Escribe la funci\u00f3n recursiva (expande-pareja pareja) que recibe una pareja formada por un dato y un n\u00famero n y devuelve la lista formada por n repeticiones del dato. Ejemplo: ( expande-pareja ' ( hola . 3 )) ; \u21d2 (hola hola hola) ( expande-pareja ' ( #t . 5 )) ; \u21d2 (#t #t #t #t #t) b) Vamos a implementar dos versiones de la funci\u00f3n (expande-parejas pareja1 ... pareja_n) que recibe un n\u00famero variable de argumentos y devuelve una lista donde se han \"expandido\" las parejas, creando una lista con tantos elementos como el n\u00famero que indique cada pareja. Todos los argumentos son opcionales; si no hay argumentos se devolver\u00e1 la lista vac\u00eda. Ejemplo: ( expande-parejas ' ( #t . 3 ) ' ( \"LPP\" . 2 ) ' ( b . 4 )) ; \u21d2 (#t #t #t \"LPP\" \"LPP\" b b b b) b.1) Escribe una soluci\u00f3n en la que la funci\u00f3n expande-parejas llame a una funci\u00f3n recursiva (expande-lista lista-parejas) que trabaje sobre una lista de parejas. b.2) Escribe una soluci\u00f3n en la que la propia funci\u00f3n expande-parejas sea recursiva. Pista Repasa el apartado 5.3.1 de teor\u00eda. c) Implementa la funci\u00f3n recursiva (expande2 lista) . Recibe una lista en la que hay intercalados algunos n\u00fameros enteros positivos. Devuelve la lista original en la que se han expandido los elementos siguientes a los n\u00fameros, tantas veces como indica el n\u00famero. La lista nunca va a contener dos n\u00fameros consecutivos y siempre va a haber un elemento despu\u00e9s de un n\u00famero. Debes usar tambi\u00e9n para su implementaci\u00f3n la funci\u00f3n (expande-pareja pareja) definida en el apartado a). Ejemplo: ( expande2 ' ( 4 clase ua 3 lpp aulario )) ; \u21d2 (clase clase clase clase ua lpp lpp lpp aulario)) En el ejemplo, el 4 indica que el siguiente elemento ( clase ) se debe repetir 4 veces en la lista expandida y el 3 indica que el siguiente elemento ( lpp ) se va a repetir 3 veces. Como en los anteriores ejercicios, te recomendamos implementar alguna funci\u00f3n auxiliar. Ejercicio 3 \u00b6 a) Implementa la funci\u00f3n recursiva (mueve-al-principio lista dato) que recibe una lista y un dato que est\u00e1 contenido en la lista. La funci\u00f3n debe devolver la lista resultante de mover la primera aparici\u00f3n del dato al comienzo de la lista, dejando el resto de la lista sin modificar. Suponemos que el dato que se pasa como par\u00e1metro est\u00e1 contenido en la lista. Ejemplo: ( mueve-al-principio ' ( a b e c d e f ) ' e ) ; \u21d2 (e a b c d e f) ( mueve-al-principio ' ( a b c d e f g ) ' a ) ; \u21d2 (a b c d e f g)) b) Implementa la funci\u00f3n recursiva (producto-cartesiano lista1 lista2) que devuelva una lista con todas las parejas resultantes de combinar todos los elementos de la lista 1 con todos los elementos de la lista 2. Ejemplo: ( producto-cartesiano ' ( 1 2 ) ' ( 1 2 3 )) ; \u21d2 ((1 . 1) (1 . 2) (1 . 3) (2 . 1) (2 . 2) (2 . 3)) Ejercicio 4 \u00b6 a) Indica qu\u00e9 devuelven las siguientes expresiones en Scheme. Puede ser que alguna expresi\u00f3n contenga alg\u00fan error. Ind\u00edcalo tambi\u00e9n en ese caso y explica qu\u00e9 tipo de error. Hazlo sin el int\u00e9rprete, y despu\u00e9s comprueba con el int\u00e9rprete si tu respuesta era correcta. (( lambda ( x ) ( * x x )) 3 ) ; \u21d2 ? (( lambda () ( + 6 4 ))) ; \u21d2 ? (( lambda ( x y ) ( * x ( + 2 y ))) ( + 2 3 ) 4 ) ; \u21d2 ? (( lambda ( x y ) ( * x ( + 2 x ))) 5 ) ; \u21d2 ? ( define f ( lambda ( a b ) ( string-append \"***\" a b \"***\" ))) ( define g f ) ( procedure? g ) ; \u21d2 ? ( g \"Hola\" \"Adios\" ) ; \u21d2 ? b) Hemos visto en teor\u00eda que la forma especial define para construir funciones es azucar sint\u00e1ctico y que el int\u00e9rprete de Scheme la convierte en una expresi\u00f3n equivalente usando la forma especial lambda . Escribe cu\u00e1l ser\u00eda las expresiones equivalentes, usando la forma especial lambda a las siguientes definiciones de funciones: ( define ( suma-3 x ) ( + x 3 )) ( define ( factorial x ) ( if ( = x 0 ) 1 ( * x ( factorial ( - x 1 ))))) c) Suponiendo las siguientes definiciones de funciones indica qu\u00e9 devolver\u00edan las invocaciones. Puede ser que alguna expresi\u00f3n contenga alg\u00fan error. Ind\u00edcalo tambi\u00e9n en ese caso y explica qu\u00e9 tipo de error. Hazlo sin el int\u00e9rprete, y despu\u00e9s comprueba con el int\u00e9rprete si tu respuesta era correcta. ( define ( doble x ) ( * 2 x )) ( define ( foo f g x y ) ( f ( g x ) y )) ( define ( bar f p x y ) ( if ( and ( p x ) ( p y )) ( f x y ) ' error )) ( foo + 10 doble 15 ) ; \u21d2 ? ( foo doble + 10 15 ) ; \u21d2 ? ( foo + doble 10 15 ) ; \u21d2 ? ( foo string-append ( lambda ( x ) ( string-append \"***\" x )) \"Hola\" \"Adios\" ) ; \u21d2 ? ( bar doble number? 10 15 ) ; \u21d2 ? ( bar string-append string? \"Hola\" \"Adios\" ) ; \u21d2 ? ( bar + number? \"Hola\" 5 ) ; \u21d2 ? Ejercicio 5 \u00b6 Seguimos con el juego del domin\u00f3. Implementa la funci\u00f3n recursiva (quitar-ficha mano puntos) que recibe una lista de fichas de domin\u00f3 (parejas, como ya vimos en la pr\u00e1ctica anterior) y unos puntos (los puntos del inicio o final de la partida de fichas sobre la mesa). La funci\u00f3n debe buscar en la mano alguna ficha que contenga esos puntos, esto es, la ficha que vamos a poner sobre la mesa. Y debe quitarla de la mano. O sea, la funci\u00f3n devolver\u00e1 una lista de la que se ha quitado la primera ficha que contiene esos puntos, ya sea en su parte izquierda o en su parte derecha. ( quitar-ficha ' (( 2 . 3 ) ( 4 . 4 ) ( 1 . 6 ) ( 4 . 5 )) 4 ) ; \u21d2 ((2 . 3) (1 . 6) (4 . 5)) ( quitar-ficha ' (( 2 . 3 ) ( 4 . 4 ) ( 1 . 6 ) ( 4 . 5 )) 5 ) ; \u21d2 ((2 . 3) (4 . 4) (1 . 6))) ( quitar-ficha ' (( 2 . 3 ) ( 4 . 4 ) ( 1 . 6 ) ( 4 . 5 )) 0 ) ; \u21d2 ((2 . 3) (4 . 4) (1 . 6) (4 . 5)) Ejercicio 6 \u00b6 a) Implementa una funci\u00f3n recursiva (comprueba-simbolos lista-simbolos lista-num) que recibe una lista de s\u00edmbolos y una lista de n\u00fameros enteros (ambas de la misma longitud) y devuelve una lista de parejas. Cada pareja est\u00e1 formada por el s\u00edmbolo de la i-\u00e9sima posici\u00f3n de lista-simbolos y el n\u00famero entero situado esa posici\u00f3n de lista-num , siempre y cuando dicho n\u00famero se corresponda con la longitud de la cadena correspondiente al s\u00edmbolo. Puedes utilizar las funciones predefinidas string-length y symbol->string . Ejemplo: ( comprueba-simbolos ' ( este es un ejercicio de examen ) ' ( 2 1 2 9 1 6 )) ; \u21d2 ((un . 2) (ejercicio . 9) (examen . 6)) b) Generalizamos la funci\u00f3n anterior (comprueba-simbolos) y la llamamos (comprueba pred lista lista-num) pas\u00e1ndole como par\u00e1metro un predicado de comparaci\u00f3n. La funci\u00f3n ahora podr\u00e1 procesar cualquier tipo de listas (de s\u00edmbolos, de cadenas, de listas, etc.). La funci\u00f3n pasada como par\u00e1metro se encarga de hacer la comparaci\u00f3n apropiada al tipo de dato de la lista. Ejemplo: ( comprueba ( lambda ( x y ) ( = ( string-length ( symbol->string x )) y )) ' ( este es un ejercicio de examen ) ' ( 2 1 2 9 1 6 )) ; \u21d2 ((un . 2) (ejercicio . 9) (examen . 6)) ( comprueba ( lambda ( x y ) ( = ( length x ) y )) ' (( 1 2 3 ) ( a ) ( a b ) ( a a ) ( c ) ( a b c d )) ' ( 2 1 2 9 1 4 )) ; \u21d2 (((a) . 1) ((a b) . 2) ((c) . 1) ((a b c d) . 4)) ( comprueba ( lambda ( x y ) ( = ( string-length x ) y )) ' ( \"aui\" \"a\" \"ae\" \"aa\" \"c\" \"aeiou\" ) ' ( 2 1 2 9 1 5 )) ; \u21d2 ((\"a\" . 1) (\"ae\" . 2) (\"c\" . 1) (\"aeiou\" . 5)) Entrega de la pr\u00e1ctica \u00b6 Sube la soluci\u00f3n de los ejercicios al cuestionario de Moodle Entrega pr\u00e1ctica 4 hasta el domingo 27 de febrero a las 21:00 h. Tal y como hemos comentado al comienzo de la pr\u00e1ctica, debes incluir casos de prueba en todo el c\u00f3digo que escribas. Una vez finalizado el plazo de entrega podr\u00e1s revisar el cuestionario y visualizar la soluci\u00f3n. Corrige la entrega, comparando la soluci\u00f3n con la tuya. Puedes consultar cualquier duda con tu profesor en la clase de pr\u00e1cticas de la semana que viene. Lenguajes y Paradigmas de Programaci\u00f3n, curso 2021-22 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Domingo Gallardo, Cristina Pomares, Antonio Bot\u00eda, Francisco Mart\u00ednez","title":"Pr\u00e1ctica 4"},{"location":"practicas/practica04/practica04.html#practica-4-funciones-recursivas-con-listas","text":"","title":"Pr\u00e1ctica 4: Funciones recursivas con listas"},{"location":"practicas/practica04/practica04.html#antes-de-la-clase-de-practicas","text":"Antes de empezar esta pr\u00e1ctica es importante que revises la soluci\u00f3n de la pr\u00e1ctica 3. Puedes preguntar las dudas al profesor de pr\u00e1cticas. Los siguientes ejercicios est\u00e1n basados en los conceptos de teor\u00eda vistos la semana pasada. Antes de la clase de pr\u00e1cticas debes repasar todos los conceptos y probar en el DrRacket todos los ejemplos de los siguientes apartados del tema 2 Programaci\u00f3n Funcional : 4.3. Funciones recursivas que construyen listas 4.4. Funciones con n\u00famero variable de argumentos 5 Funciones como tipos de datos de primera clase (incluido hasta el apartado 5.3. Funci\u00f3n apply )","title":"Antes de la clase de pr\u00e1cticas"},{"location":"practicas/practica04/practica04.html#ejercicios","text":"","title":"Ejercicios"},{"location":"practicas/practica04/practica04.html#ejercicio-1","text":"a) Implementa la funci\u00f3n recursiva (contiene-prefijo prefijo lista-pal) que recibe una cadena y una lista de palabras. Devuelve una lista con los booleanos resultantes de comprobar si la cadena es prefijo de cada una de las palabras de la lista. Debes definir una funci\u00f3n auxiliar (es-prefijo? pal1 pal2) que compruebe si la palabra 1 es prefijo de la palabra 2. Pista Puedes usar la funci\u00f3n (substring palabra inicio final) que devuelve la subcadena de la palabra que va desde la posici\u00f3n inicio hasta la posici\u00f3n final (sin incluir). Ejemplos: ( es-prefijo? \"ante\" \"anterior\" ) ; \u21d2 #t ( contiene-prefijo \"ante\" ' ( \"anterior\" \"ant\u00edgona\" \"antena\" \"anatema\" )) ; \u21d2 (#t #f #t #f) b) Vamos a generalizar la soluci\u00f3n del ejercicio 4 de la pr\u00e1ctica 2 e implementar la funci\u00f3n recursiva (cadenas-mayores lista1 lista2) teniendo en cuenta que las listas que recibe tienen un n\u00famero indeterminado de cadenas. En el caso en que una de las listas sea mayor que la otra, se deber\u00e1n a\u00f1adir todas sus cadenas a la lista resultante. Ejemplos: ( cadenas-mayores ' ( \"hola\" \"que\" \"tal\" ) ' ( \"adios\" )) ; \u21d2 (\"adios\" \"que\" \"tal\") ( cadenas-mayores ' ( \"hola\" \"que\" \"tal\" ) ' ( \"meme\" \"y\" \"adios\" )) ; \u21d2 (\"hola\" \"que\" \"adios\") ( cadenas-mayores ' ( \"la\" \"primera\" \"pr\u00e1ctica\" \"de\" \"recursi\u00f3n\" ) ' ( \"confiar\" \"en\" \"la\" \"recursi\u00f3n\" \"facilita\" \"su\" \"resoluci\u00f3n\" )) ; \u21d2 (\"confiar\" \"primera\" \"pr\u00e1ctica\" \"recursi\u00f3n\" \"recursi\u00f3n\" \"su\" \"resoluci\u00f3n\") c) Implementa la funci\u00f3n recursiva (inserta-pos dato pos lista) que recibe un dato, una posici\u00f3n y una lista e inserta el dato en la posici\u00f3n indicada de la lista. Si la posici\u00f3n es 0, el dato se inserta en cabeza. Suponemos que la posici\u00f3n siempre ser\u00e1 positiva y menor o igual que la longitud de la lista. Ejemplos: ( inserta-pos ' b 2 ' ( a a a a )) ; \u21d2 '(a a b a a) ( inserta-pos ' b 0 ' ( a a a a )) ; \u21d2 '(b a a a a) d) Implementa la funci\u00f3n recursiva (inserta-ordenada n lista-ordenada) que recibe un n\u00famero y una lista de n\u00fameros ordenados de menor a mayor y devuelve la lista resultante de insertar el n\u00famero n en la posici\u00f3n correcta para que la lista siga estando ordenada. Ejemplo: ( inserta-ordenada 10 ' ( -8 2 3 11 20 )) ; \u21d2 (-8 2 3 10 11 20) Usando la funci\u00f3n anterior inserta-ordenada implementa la funci\u00f3n recursiva (ordena lista) que recibe una lista de n\u00fameros y devuelve una lista ordenada. Ejemplo: ( ordena ' ( 2 -1 100 4 -6 )) ; \u21d2 (-6 -1 2 4 100)","title":"Ejercicio 1"},{"location":"practicas/practica04/practica04.html#ejercicio-2","text":"Vamos a implementar distintas versiones de funciones que expanden una lista original. En el primer apartado definiremos una funci\u00f3n auxiliar que se deber\u00e1 usar en todos los dem\u00e1s apartados. a) Escribe la funci\u00f3n recursiva (expande-pareja pareja) que recibe una pareja formada por un dato y un n\u00famero n y devuelve la lista formada por n repeticiones del dato. Ejemplo: ( expande-pareja ' ( hola . 3 )) ; \u21d2 (hola hola hola) ( expande-pareja ' ( #t . 5 )) ; \u21d2 (#t #t #t #t #t) b) Vamos a implementar dos versiones de la funci\u00f3n (expande-parejas pareja1 ... pareja_n) que recibe un n\u00famero variable de argumentos y devuelve una lista donde se han \"expandido\" las parejas, creando una lista con tantos elementos como el n\u00famero que indique cada pareja. Todos los argumentos son opcionales; si no hay argumentos se devolver\u00e1 la lista vac\u00eda. Ejemplo: ( expande-parejas ' ( #t . 3 ) ' ( \"LPP\" . 2 ) ' ( b . 4 )) ; \u21d2 (#t #t #t \"LPP\" \"LPP\" b b b b) b.1) Escribe una soluci\u00f3n en la que la funci\u00f3n expande-parejas llame a una funci\u00f3n recursiva (expande-lista lista-parejas) que trabaje sobre una lista de parejas. b.2) Escribe una soluci\u00f3n en la que la propia funci\u00f3n expande-parejas sea recursiva. Pista Repasa el apartado 5.3.1 de teor\u00eda. c) Implementa la funci\u00f3n recursiva (expande2 lista) . Recibe una lista en la que hay intercalados algunos n\u00fameros enteros positivos. Devuelve la lista original en la que se han expandido los elementos siguientes a los n\u00fameros, tantas veces como indica el n\u00famero. La lista nunca va a contener dos n\u00fameros consecutivos y siempre va a haber un elemento despu\u00e9s de un n\u00famero. Debes usar tambi\u00e9n para su implementaci\u00f3n la funci\u00f3n (expande-pareja pareja) definida en el apartado a). Ejemplo: ( expande2 ' ( 4 clase ua 3 lpp aulario )) ; \u21d2 (clase clase clase clase ua lpp lpp lpp aulario)) En el ejemplo, el 4 indica que el siguiente elemento ( clase ) se debe repetir 4 veces en la lista expandida y el 3 indica que el siguiente elemento ( lpp ) se va a repetir 3 veces. Como en los anteriores ejercicios, te recomendamos implementar alguna funci\u00f3n auxiliar.","title":"Ejercicio 2"},{"location":"practicas/practica04/practica04.html#ejercicio-3","text":"a) Implementa la funci\u00f3n recursiva (mueve-al-principio lista dato) que recibe una lista y un dato que est\u00e1 contenido en la lista. La funci\u00f3n debe devolver la lista resultante de mover la primera aparici\u00f3n del dato al comienzo de la lista, dejando el resto de la lista sin modificar. Suponemos que el dato que se pasa como par\u00e1metro est\u00e1 contenido en la lista. Ejemplo: ( mueve-al-principio ' ( a b e c d e f ) ' e ) ; \u21d2 (e a b c d e f) ( mueve-al-principio ' ( a b c d e f g ) ' a ) ; \u21d2 (a b c d e f g)) b) Implementa la funci\u00f3n recursiva (producto-cartesiano lista1 lista2) que devuelva una lista con todas las parejas resultantes de combinar todos los elementos de la lista 1 con todos los elementos de la lista 2. Ejemplo: ( producto-cartesiano ' ( 1 2 ) ' ( 1 2 3 )) ; \u21d2 ((1 . 1) (1 . 2) (1 . 3) (2 . 1) (2 . 2) (2 . 3))","title":"Ejercicio 3"},{"location":"practicas/practica04/practica04.html#ejercicio-4","text":"a) Indica qu\u00e9 devuelven las siguientes expresiones en Scheme. Puede ser que alguna expresi\u00f3n contenga alg\u00fan error. Ind\u00edcalo tambi\u00e9n en ese caso y explica qu\u00e9 tipo de error. Hazlo sin el int\u00e9rprete, y despu\u00e9s comprueba con el int\u00e9rprete si tu respuesta era correcta. (( lambda ( x ) ( * x x )) 3 ) ; \u21d2 ? (( lambda () ( + 6 4 ))) ; \u21d2 ? (( lambda ( x y ) ( * x ( + 2 y ))) ( + 2 3 ) 4 ) ; \u21d2 ? (( lambda ( x y ) ( * x ( + 2 x ))) 5 ) ; \u21d2 ? ( define f ( lambda ( a b ) ( string-append \"***\" a b \"***\" ))) ( define g f ) ( procedure? g ) ; \u21d2 ? ( g \"Hola\" \"Adios\" ) ; \u21d2 ? b) Hemos visto en teor\u00eda que la forma especial define para construir funciones es azucar sint\u00e1ctico y que el int\u00e9rprete de Scheme la convierte en una expresi\u00f3n equivalente usando la forma especial lambda . Escribe cu\u00e1l ser\u00eda las expresiones equivalentes, usando la forma especial lambda a las siguientes definiciones de funciones: ( define ( suma-3 x ) ( + x 3 )) ( define ( factorial x ) ( if ( = x 0 ) 1 ( * x ( factorial ( - x 1 ))))) c) Suponiendo las siguientes definiciones de funciones indica qu\u00e9 devolver\u00edan las invocaciones. Puede ser que alguna expresi\u00f3n contenga alg\u00fan error. Ind\u00edcalo tambi\u00e9n en ese caso y explica qu\u00e9 tipo de error. Hazlo sin el int\u00e9rprete, y despu\u00e9s comprueba con el int\u00e9rprete si tu respuesta era correcta. ( define ( doble x ) ( * 2 x )) ( define ( foo f g x y ) ( f ( g x ) y )) ( define ( bar f p x y ) ( if ( and ( p x ) ( p y )) ( f x y ) ' error )) ( foo + 10 doble 15 ) ; \u21d2 ? ( foo doble + 10 15 ) ; \u21d2 ? ( foo + doble 10 15 ) ; \u21d2 ? ( foo string-append ( lambda ( x ) ( string-append \"***\" x )) \"Hola\" \"Adios\" ) ; \u21d2 ? ( bar doble number? 10 15 ) ; \u21d2 ? ( bar string-append string? \"Hola\" \"Adios\" ) ; \u21d2 ? ( bar + number? \"Hola\" 5 ) ; \u21d2 ?","title":"Ejercicio 4"},{"location":"practicas/practica04/practica04.html#ejercicio-5","text":"Seguimos con el juego del domin\u00f3. Implementa la funci\u00f3n recursiva (quitar-ficha mano puntos) que recibe una lista de fichas de domin\u00f3 (parejas, como ya vimos en la pr\u00e1ctica anterior) y unos puntos (los puntos del inicio o final de la partida de fichas sobre la mesa). La funci\u00f3n debe buscar en la mano alguna ficha que contenga esos puntos, esto es, la ficha que vamos a poner sobre la mesa. Y debe quitarla de la mano. O sea, la funci\u00f3n devolver\u00e1 una lista de la que se ha quitado la primera ficha que contiene esos puntos, ya sea en su parte izquierda o en su parte derecha. ( quitar-ficha ' (( 2 . 3 ) ( 4 . 4 ) ( 1 . 6 ) ( 4 . 5 )) 4 ) ; \u21d2 ((2 . 3) (1 . 6) (4 . 5)) ( quitar-ficha ' (( 2 . 3 ) ( 4 . 4 ) ( 1 . 6 ) ( 4 . 5 )) 5 ) ; \u21d2 ((2 . 3) (4 . 4) (1 . 6))) ( quitar-ficha ' (( 2 . 3 ) ( 4 . 4 ) ( 1 . 6 ) ( 4 . 5 )) 0 ) ; \u21d2 ((2 . 3) (4 . 4) (1 . 6) (4 . 5))","title":"Ejercicio 5"},{"location":"practicas/practica04/practica04.html#ejercicio-6","text":"a) Implementa una funci\u00f3n recursiva (comprueba-simbolos lista-simbolos lista-num) que recibe una lista de s\u00edmbolos y una lista de n\u00fameros enteros (ambas de la misma longitud) y devuelve una lista de parejas. Cada pareja est\u00e1 formada por el s\u00edmbolo de la i-\u00e9sima posici\u00f3n de lista-simbolos y el n\u00famero entero situado esa posici\u00f3n de lista-num , siempre y cuando dicho n\u00famero se corresponda con la longitud de la cadena correspondiente al s\u00edmbolo. Puedes utilizar las funciones predefinidas string-length y symbol->string . Ejemplo: ( comprueba-simbolos ' ( este es un ejercicio de examen ) ' ( 2 1 2 9 1 6 )) ; \u21d2 ((un . 2) (ejercicio . 9) (examen . 6)) b) Generalizamos la funci\u00f3n anterior (comprueba-simbolos) y la llamamos (comprueba pred lista lista-num) pas\u00e1ndole como par\u00e1metro un predicado de comparaci\u00f3n. La funci\u00f3n ahora podr\u00e1 procesar cualquier tipo de listas (de s\u00edmbolos, de cadenas, de listas, etc.). La funci\u00f3n pasada como par\u00e1metro se encarga de hacer la comparaci\u00f3n apropiada al tipo de dato de la lista. Ejemplo: ( comprueba ( lambda ( x y ) ( = ( string-length ( symbol->string x )) y )) ' ( este es un ejercicio de examen ) ' ( 2 1 2 9 1 6 )) ; \u21d2 ((un . 2) (ejercicio . 9) (examen . 6)) ( comprueba ( lambda ( x y ) ( = ( length x ) y )) ' (( 1 2 3 ) ( a ) ( a b ) ( a a ) ( c ) ( a b c d )) ' ( 2 1 2 9 1 4 )) ; \u21d2 (((a) . 1) ((a b) . 2) ((c) . 1) ((a b c d) . 4)) ( comprueba ( lambda ( x y ) ( = ( string-length x ) y )) ' ( \"aui\" \"a\" \"ae\" \"aa\" \"c\" \"aeiou\" ) ' ( 2 1 2 9 1 5 )) ; \u21d2 ((\"a\" . 1) (\"ae\" . 2) (\"c\" . 1) (\"aeiou\" . 5))","title":"Ejercicio 6"},{"location":"practicas/practica04/practica04.html#entrega-de-la-practica","text":"Sube la soluci\u00f3n de los ejercicios al cuestionario de Moodle Entrega pr\u00e1ctica 4 hasta el domingo 27 de febrero a las 21:00 h. Tal y como hemos comentado al comienzo de la pr\u00e1ctica, debes incluir casos de prueba en todo el c\u00f3digo que escribas. Una vez finalizado el plazo de entrega podr\u00e1s revisar el cuestionario y visualizar la soluci\u00f3n. Corrige la entrega, comparando la soluci\u00f3n con la tuya. Puedes consultar cualquier duda con tu profesor en la clase de pr\u00e1cticas de la semana que viene. Lenguajes y Paradigmas de Programaci\u00f3n, curso 2021-22 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Domingo Gallardo, Cristina Pomares, Antonio Bot\u00eda, Francisco Mart\u00ednez","title":"Entrega de la pr\u00e1ctica"},{"location":"practicas/practica05/practica05.html","text":"Pr\u00e1ctica 5: Funciones como datos de primera clase y funciones de orden superior \u00b6 Antes de la clase de pr\u00e1cticas \u00b6 Antes de empezar esta pr\u00e1ctica es importante que revises la soluci\u00f3n de la pr\u00e1ctica 4. Puedes preguntar las dudas al profesor de pr\u00e1cticas. Los siguientes ejercicios est\u00e1n basados en los conceptos de teor\u00eda vistos la semana pasada. Antes de la clase de pr\u00e1cticas debes repasar todos los conceptos y probar en el DrRacket todos los ejemplos de los siguientes apartados del tema 2 Programaci\u00f3n Funcional : 5.4. Generalizaci\u00f3n. 5.5. Funciones que devuelven otras funciones. 5.6. Funciones en estructuras de datos. 5.7. Funciones de orden superior. Ejercicios \u00b6 Descarga el fichero lpp.rkt , pulsando el bot\u00f3n derecho del rat\u00f3n y seleccionando la opci\u00f3n Guardar como lpp.rkt . Gu\u00e1rdalo en la misma carpeta en la que tengas el fichero practica4.rkt . El fichero contiene la definici\u00f3n de las funciones de orden superior exists? y for-all? . Ejercicio 1 \u00b6 a) Define la funci\u00f3n (aplica-veces f1 f2 n x) que aplica n veces las funciones f2 y f1 al n\u00famero x . Por ejemplo, (aplica-veces doble suma-2 3 5) deber\u00e1 devolver el resultado de sumarle 2 a 5 (7), despu\u00e9s calcular el doble (14), despu\u00e9s sumarle otra vez 2 al resultado (16), volver a calcular su doble (32) y, por \u00faltimo, sumarle 2 al resultado (34) y calcular su doble. Esto es, aplica 3 veces las funciones suma-2 y doble tomando como n\u00famero inicial el 5. El resultado ser\u00e1 68. Ejemplos: ( aplica-veces ( lambda ( x ) ( + x 1 )) ( lambda ( x ) ( + x 2 )) 2 10 ) ; \u21d2 16 ( aplica-veces ( lambda ( x ) ( * x x )) ( lambda ( x ) ( + x 1 )) 4 3 ) ; \u21d2 7072978201 b) Implementa la funci\u00f3n recursiva (mueve-al-principio-condicion pred lista) que recibe un predicado y una lista. La funci\u00f3n es una generalizaci\u00f3n de la funci\u00f3n de la pr\u00e1ctica anterior y debe devolver la lista resultante de mover la primera aparici\u00f3n del dato que cumpla el predicado al comienzo de la lista, dejando el resto de la lista sin modificar. A diferencia de la pr\u00e1ctica anterior, en la lista puede no haber ning\u00fan elemento que cumpla el predicado. En ese caso se devolver\u00e1 la lista original. Ejemplos: ( mueve-al-principio-condicion number? ' ( a b c 1 d 1 e ) ; \u21d2 (1 a b c d 1 e) ( mueve-al-principio-condicion number? ' ( 1 a b 1 c )) ; \u21d2 (1 a b 1 c) ( mueve-al-principio-condicion number? ' ( a b c d )) ; \u21d2 '(a b c d) Ejercicio 2 \u00b6 a) Indica qu\u00e9 devuelven las siguientes expresiones, sin utilizar el int\u00e9rprete. Comprueba despu\u00e9s si has acertado. ( map ( lambda ( x ) ( cond (( symbol? x ) ( symbol->string x )) (( number? x ) ( number->string x )) (( boolean? x ) ( if x \"#t\" \"#f\" )) ( else \"desconocido\" ))) ' ( 1 #t hola #f ( 1 . 2 ))) ; \u21d2 ? ( filter ( lambda ( x ) ( equal? ( string-ref ( symbol->string x ) 1 ) #\\a )) ' ( alicante barcelona madrid almer\u00eda )) ; \u21d2 ? ( foldr ( lambda ( dato resultado ) ( string-append dato \"*\" resultado )) \"\" ' ( \"Hola\" \"que\" \"tal\" )) ; \u21d2 ? ( foldr append ' () ' (( 1 2 ) ( 3 4 5 ) ( 6 7 ) ( 8 ))) ; \u21d2 ? ( foldl ( lambda ( dato resultado ) ( string-append ( symbol->string ( car dato )) ( symbol->string ( cdr dato )) resultado )) \"\" ' (( a . b ) ( hola . adios ) ( una . pareja ))) ; \u21d2 ? ( foldr ( lambda ( dato resultado ) ( cons ( + ( car resultado ) dato ) ( + ( cdr resultado ) 1 ))) ' ( 0 . 0 ) ' ( 1 1 2 2 3 3 )) ; \u21d2 ? ( apply + ( map cdr ' (( 1 . 3 ) ( 2 . 8 ) ( 2 . 4 )))) ; \u21d2 ? ( apply min ( map car ( filter ( lambda ( p ) ( > ( car p ) ( cdr p ))) ' (( 3 . 1 ) ( 1 . 20 ) ( 5 . 2 ))))) ; \u21d2 ? b) Sin utilizar el int\u00e9rprete DrRacket, rellena los siguientes huecos para obtener el resultado esperado. Despu\u00e9s usa el int\u00e9rprete para comprobar si has acertado. ; Los siguientes ejercicios utilizan esta definici\u00f3n de lista ( define lista ' (( 2 . 7 ) ( 3 . 5 ) ( 10 . 4 ) ( 5 . 5 ))) ; Queremos obtener una lista donde cada n\u00famero es la suma de las ; parejas que son pares ( filter ________ ( ________ ( lambda ( x ) ( + ( car x ) ( cdr x ))) lista )) ; \u21d2 (8 14 10) ; Queremos obtener una lista de parejas invertidas donde la \"nueva\" ; parte izquierda es mayor que la derecha. ( filter ___________ ( map ____________ lista )) ; \u21d2 ((7 . 2) (5 . 3)) ; Queremos obtener una lista cuyos elementos son las partes izquierda ; de aquellas parejas cuya suma sea par. ( foldr __________ ' () ( _________ ( lambda ( x ) ( even? ( + ( car x ) ( cdr x )))) lista )) ; \u21d2 (3 10 5) c) Rellena los siguientes huecos con una \u00fanica expresi\u00f3n en la que se utilice alguna funci\u00f3n previamente definida ( f o g ). Comprueba con el int\u00e9rprete si lo has hecho correctamente. ( define ( f x ) ( lambda ( y z ) ( string-append y z x ))) ( define g ( f \"a\" )) ( check-equal? ____________________ \"claselppa\" ) ( define ( f x ) ( lambda ( y z ) ( list y x z ))) _____________ ( check-equal? ( g \"hola\" \"clase\" ) ( list \"hola\" \"lpp\" \"clase\" )) ( define ( f g ) ( lambda ( z x ) ( g z x ))) ( check-equal? _____________________ ' ( 3 . 4 )) Ejercicio 3 \u00b6 a) Implementa utilizando funciones de orden superior la funci\u00f3n (contar-datos-iguales-fos lista-parejas) que recibe una lista de parejas y devuelve el n\u00famero de parejas que tienen sus dos datos iguales. ( contar-datos-iguales-fos ' (( 2 . 3 ) ( \"hola\" . \"hola\" ) ( \\#a . \\#a ) ( true . false ))) ; \u21d2 2 ( contar-datos-iguales-fos ' (( 2 . \"hola\" ) ( \"hola\" . 3 ) ( \\#a . true ) ( \\#b . false ))) ; \u21d2 0 b) Implementa, utilizando funciones de orden superior, la funci\u00f3n (expande-lista-fos lista-parejas) , que hace lo mismo que la funci\u00f3n (expande-lista lista-parejas) de la pr\u00e1ctica anterior. Igual que en la pr\u00e1ctica anterior debes usar la funci\u00f3n expande-pareja . (expande-lista-fos '((#t . 3) (\"LPP\" . 2) (b . 4))) ; \u21d2 '(#t #t #t \"LPP\" \"LPP\" b b b b)) c) Implementa, utilizando funciones de orden superior, la funci\u00f3n (comprueba-simbolos-fos lista-simbolos lista-num) que hace lo mismo que la funci\u00f3n comprueba-simbolos del ejercicio 6a) de la pr\u00e1ctica pasada. Ejemplo: (comprueba-simbolos-fos '(este es un ejercicio de examen) '(2 1 2 9 1 6)) ; \u21d2 ((un . 2) (ejercicio . 9) (examen . 6)) Ejercicio 4 \u00b6 a) Implementa usando funciones de orden superior la funci\u00f3n (suma-n-izq n lista-parejas) que recibe una lista de parejas y devuelve otra lista a la que hemos sumado n a todas las partes izquierdas. Ejemplo ( suma-n-izq 10 ' (( 1 . 3 ) ( 0 . 9 ) ( 5 . 8 ) ( 4 . 1 ))) ; \u21d2 ((11 . 3) (10 . 9) (15 . 8) (14 . 1)) b) Implementa usando funciones de orden superior la funci\u00f3n (aplica-2 func lista-parejas) que recibe una funci\u00f3n de dos argumentos y una lista de parejas y devuelve una lista con el resultado de aplicar esa funci\u00f3n a los elementos izquierdo y derecho de cada pareja. Ejemplo: ( aplica-2 + ' (( 2 . 3 ) ( 1 . -1 ) ( 5 . 4 ))) ; \u21d2 (5 0 9) ( aplica-2 ( lambda ( x y ) ( if ( even? x ) y ( * y -1 ))) ' (( 2 . 3 ) ( 1 . 3 ) ( 5 . 4 ) ( 8 . 10 ))) ; \u21d2 (3 -3 -4 10) Ejercicio 5 \u00b6 a) Completa la definici\u00f3n de la siguiente funci\u00f3n de orden superior (busca-mayor mayor? lista) que busca el mayor elemento de una lista. Recibe un predicado mayor? que compara dos elementos de la lista y devuelve #t o #f dependiendo de si el primero es mayor que el segundo. Al usar un predicado como argumento, estamos definiendo una funci\u00f3n gen\u00e9rica que podemos usar para obtener el mayor elemento de listas de n\u00fameros, de cadenas, de parejas, etc. En cada caso deberemos pasar como par\u00e1metro mayor? la funci\u00f3n de comparaci\u00f3n apropiada. ( define ( busca-mayor mayor? lista ) ( foldl __________ ( first lista ) ( rest lista ))) Pista F\u00edjate que como elemento base de foldl estamos usando el primer elemento de la lista y que el plegado lo hacemos sobre el resto de la lista. Escribe algunos check-equal? en los que compruebes el funcionamiento de busca-mayor , utilizando funciones mayor? distintas. b) Implementa, usando el predicado de orden superior for-all? dos versiones de la funci\u00f3n (todos-menores? lista n) que recibe una lista con sublistas de n\u00fameros y un n\u00famero n y comprueba si todos los n\u00fameros en las sublistas son menores que n . La primera versi\u00f3n la debes implementar usando for-all? y la funci\u00f3n busca-mayor definida en el apartado anterior y la segunda usando for-all? y la funci\u00f3n de orden superior exists? . Ejemplo: ( todos-menores? ' (( 10 30 20 ) ( 1 50 30 ) ( 30 40 90 )) 100 ) ; \u21d2 #t ( todos-menores? ' (( 10 30 20 ) ( 1 50 30 ) ( 30 40 90 )) 90 ) ; \u21d2 #f ( todos-menores? ' (( 10 30 20 ) ( 1 50 30 ) ( 30 40 90 )) 55 ) ; \u21d2 #f Lenguajes y Paradigmas de Programaci\u00f3n, curso 2021-22 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Domingo Gallardo, Cristina Pomares, Antonio Bot\u00eda, Francisco Mart\u00ednez","title":"Pr\u00e1ctica 5"},{"location":"practicas/practica05/practica05.html#practica-5-funciones-como-datos-de-primera-clase-y-funciones-de-orden-superior","text":"","title":"Pr\u00e1ctica 5: Funciones como datos de primera clase y funciones de orden superior"},{"location":"practicas/practica05/practica05.html#antes-de-la-clase-de-practicas","text":"Antes de empezar esta pr\u00e1ctica es importante que revises la soluci\u00f3n de la pr\u00e1ctica 4. Puedes preguntar las dudas al profesor de pr\u00e1cticas. Los siguientes ejercicios est\u00e1n basados en los conceptos de teor\u00eda vistos la semana pasada. Antes de la clase de pr\u00e1cticas debes repasar todos los conceptos y probar en el DrRacket todos los ejemplos de los siguientes apartados del tema 2 Programaci\u00f3n Funcional : 5.4. Generalizaci\u00f3n. 5.5. Funciones que devuelven otras funciones. 5.6. Funciones en estructuras de datos. 5.7. Funciones de orden superior.","title":"Antes de la clase de pr\u00e1cticas"},{"location":"practicas/practica05/practica05.html#ejercicios","text":"Descarga el fichero lpp.rkt , pulsando el bot\u00f3n derecho del rat\u00f3n y seleccionando la opci\u00f3n Guardar como lpp.rkt . Gu\u00e1rdalo en la misma carpeta en la que tengas el fichero practica4.rkt . El fichero contiene la definici\u00f3n de las funciones de orden superior exists? y for-all? .","title":"Ejercicios"},{"location":"practicas/practica05/practica05.html#ejercicio-1","text":"a) Define la funci\u00f3n (aplica-veces f1 f2 n x) que aplica n veces las funciones f2 y f1 al n\u00famero x . Por ejemplo, (aplica-veces doble suma-2 3 5) deber\u00e1 devolver el resultado de sumarle 2 a 5 (7), despu\u00e9s calcular el doble (14), despu\u00e9s sumarle otra vez 2 al resultado (16), volver a calcular su doble (32) y, por \u00faltimo, sumarle 2 al resultado (34) y calcular su doble. Esto es, aplica 3 veces las funciones suma-2 y doble tomando como n\u00famero inicial el 5. El resultado ser\u00e1 68. Ejemplos: ( aplica-veces ( lambda ( x ) ( + x 1 )) ( lambda ( x ) ( + x 2 )) 2 10 ) ; \u21d2 16 ( aplica-veces ( lambda ( x ) ( * x x )) ( lambda ( x ) ( + x 1 )) 4 3 ) ; \u21d2 7072978201 b) Implementa la funci\u00f3n recursiva (mueve-al-principio-condicion pred lista) que recibe un predicado y una lista. La funci\u00f3n es una generalizaci\u00f3n de la funci\u00f3n de la pr\u00e1ctica anterior y debe devolver la lista resultante de mover la primera aparici\u00f3n del dato que cumpla el predicado al comienzo de la lista, dejando el resto de la lista sin modificar. A diferencia de la pr\u00e1ctica anterior, en la lista puede no haber ning\u00fan elemento que cumpla el predicado. En ese caso se devolver\u00e1 la lista original. Ejemplos: ( mueve-al-principio-condicion number? ' ( a b c 1 d 1 e ) ; \u21d2 (1 a b c d 1 e) ( mueve-al-principio-condicion number? ' ( 1 a b 1 c )) ; \u21d2 (1 a b 1 c) ( mueve-al-principio-condicion number? ' ( a b c d )) ; \u21d2 '(a b c d)","title":"Ejercicio 1"},{"location":"practicas/practica05/practica05.html#ejercicio-2","text":"a) Indica qu\u00e9 devuelven las siguientes expresiones, sin utilizar el int\u00e9rprete. Comprueba despu\u00e9s si has acertado. ( map ( lambda ( x ) ( cond (( symbol? x ) ( symbol->string x )) (( number? x ) ( number->string x )) (( boolean? x ) ( if x \"#t\" \"#f\" )) ( else \"desconocido\" ))) ' ( 1 #t hola #f ( 1 . 2 ))) ; \u21d2 ? ( filter ( lambda ( x ) ( equal? ( string-ref ( symbol->string x ) 1 ) #\\a )) ' ( alicante barcelona madrid almer\u00eda )) ; \u21d2 ? ( foldr ( lambda ( dato resultado ) ( string-append dato \"*\" resultado )) \"\" ' ( \"Hola\" \"que\" \"tal\" )) ; \u21d2 ? ( foldr append ' () ' (( 1 2 ) ( 3 4 5 ) ( 6 7 ) ( 8 ))) ; \u21d2 ? ( foldl ( lambda ( dato resultado ) ( string-append ( symbol->string ( car dato )) ( symbol->string ( cdr dato )) resultado )) \"\" ' (( a . b ) ( hola . adios ) ( una . pareja ))) ; \u21d2 ? ( foldr ( lambda ( dato resultado ) ( cons ( + ( car resultado ) dato ) ( + ( cdr resultado ) 1 ))) ' ( 0 . 0 ) ' ( 1 1 2 2 3 3 )) ; \u21d2 ? ( apply + ( map cdr ' (( 1 . 3 ) ( 2 . 8 ) ( 2 . 4 )))) ; \u21d2 ? ( apply min ( map car ( filter ( lambda ( p ) ( > ( car p ) ( cdr p ))) ' (( 3 . 1 ) ( 1 . 20 ) ( 5 . 2 ))))) ; \u21d2 ? b) Sin utilizar el int\u00e9rprete DrRacket, rellena los siguientes huecos para obtener el resultado esperado. Despu\u00e9s usa el int\u00e9rprete para comprobar si has acertado. ; Los siguientes ejercicios utilizan esta definici\u00f3n de lista ( define lista ' (( 2 . 7 ) ( 3 . 5 ) ( 10 . 4 ) ( 5 . 5 ))) ; Queremos obtener una lista donde cada n\u00famero es la suma de las ; parejas que son pares ( filter ________ ( ________ ( lambda ( x ) ( + ( car x ) ( cdr x ))) lista )) ; \u21d2 (8 14 10) ; Queremos obtener una lista de parejas invertidas donde la \"nueva\" ; parte izquierda es mayor que la derecha. ( filter ___________ ( map ____________ lista )) ; \u21d2 ((7 . 2) (5 . 3)) ; Queremos obtener una lista cuyos elementos son las partes izquierda ; de aquellas parejas cuya suma sea par. ( foldr __________ ' () ( _________ ( lambda ( x ) ( even? ( + ( car x ) ( cdr x )))) lista )) ; \u21d2 (3 10 5) c) Rellena los siguientes huecos con una \u00fanica expresi\u00f3n en la que se utilice alguna funci\u00f3n previamente definida ( f o g ). Comprueba con el int\u00e9rprete si lo has hecho correctamente. ( define ( f x ) ( lambda ( y z ) ( string-append y z x ))) ( define g ( f \"a\" )) ( check-equal? ____________________ \"claselppa\" ) ( define ( f x ) ( lambda ( y z ) ( list y x z ))) _____________ ( check-equal? ( g \"hola\" \"clase\" ) ( list \"hola\" \"lpp\" \"clase\" )) ( define ( f g ) ( lambda ( z x ) ( g z x ))) ( check-equal? _____________________ ' ( 3 . 4 ))","title":"Ejercicio 2"},{"location":"practicas/practica05/practica05.html#ejercicio-3","text":"a) Implementa utilizando funciones de orden superior la funci\u00f3n (contar-datos-iguales-fos lista-parejas) que recibe una lista de parejas y devuelve el n\u00famero de parejas que tienen sus dos datos iguales. ( contar-datos-iguales-fos ' (( 2 . 3 ) ( \"hola\" . \"hola\" ) ( \\#a . \\#a ) ( true . false ))) ; \u21d2 2 ( contar-datos-iguales-fos ' (( 2 . \"hola\" ) ( \"hola\" . 3 ) ( \\#a . true ) ( \\#b . false ))) ; \u21d2 0 b) Implementa, utilizando funciones de orden superior, la funci\u00f3n (expande-lista-fos lista-parejas) , que hace lo mismo que la funci\u00f3n (expande-lista lista-parejas) de la pr\u00e1ctica anterior. Igual que en la pr\u00e1ctica anterior debes usar la funci\u00f3n expande-pareja . (expande-lista-fos '((#t . 3) (\"LPP\" . 2) (b . 4))) ; \u21d2 '(#t #t #t \"LPP\" \"LPP\" b b b b)) c) Implementa, utilizando funciones de orden superior, la funci\u00f3n (comprueba-simbolos-fos lista-simbolos lista-num) que hace lo mismo que la funci\u00f3n comprueba-simbolos del ejercicio 6a) de la pr\u00e1ctica pasada. Ejemplo: (comprueba-simbolos-fos '(este es un ejercicio de examen) '(2 1 2 9 1 6)) ; \u21d2 ((un . 2) (ejercicio . 9) (examen . 6))","title":"Ejercicio 3"},{"location":"practicas/practica05/practica05.html#ejercicio-4","text":"a) Implementa usando funciones de orden superior la funci\u00f3n (suma-n-izq n lista-parejas) que recibe una lista de parejas y devuelve otra lista a la que hemos sumado n a todas las partes izquierdas. Ejemplo ( suma-n-izq 10 ' (( 1 . 3 ) ( 0 . 9 ) ( 5 . 8 ) ( 4 . 1 ))) ; \u21d2 ((11 . 3) (10 . 9) (15 . 8) (14 . 1)) b) Implementa usando funciones de orden superior la funci\u00f3n (aplica-2 func lista-parejas) que recibe una funci\u00f3n de dos argumentos y una lista de parejas y devuelve una lista con el resultado de aplicar esa funci\u00f3n a los elementos izquierdo y derecho de cada pareja. Ejemplo: ( aplica-2 + ' (( 2 . 3 ) ( 1 . -1 ) ( 5 . 4 ))) ; \u21d2 (5 0 9) ( aplica-2 ( lambda ( x y ) ( if ( even? x ) y ( * y -1 ))) ' (( 2 . 3 ) ( 1 . 3 ) ( 5 . 4 ) ( 8 . 10 ))) ; \u21d2 (3 -3 -4 10)","title":"Ejercicio 4"},{"location":"practicas/practica05/practica05.html#ejercicio-5","text":"a) Completa la definici\u00f3n de la siguiente funci\u00f3n de orden superior (busca-mayor mayor? lista) que busca el mayor elemento de una lista. Recibe un predicado mayor? que compara dos elementos de la lista y devuelve #t o #f dependiendo de si el primero es mayor que el segundo. Al usar un predicado como argumento, estamos definiendo una funci\u00f3n gen\u00e9rica que podemos usar para obtener el mayor elemento de listas de n\u00fameros, de cadenas, de parejas, etc. En cada caso deberemos pasar como par\u00e1metro mayor? la funci\u00f3n de comparaci\u00f3n apropiada. ( define ( busca-mayor mayor? lista ) ( foldl __________ ( first lista ) ( rest lista ))) Pista F\u00edjate que como elemento base de foldl estamos usando el primer elemento de la lista y que el plegado lo hacemos sobre el resto de la lista. Escribe algunos check-equal? en los que compruebes el funcionamiento de busca-mayor , utilizando funciones mayor? distintas. b) Implementa, usando el predicado de orden superior for-all? dos versiones de la funci\u00f3n (todos-menores? lista n) que recibe una lista con sublistas de n\u00fameros y un n\u00famero n y comprueba si todos los n\u00fameros en las sublistas son menores que n . La primera versi\u00f3n la debes implementar usando for-all? y la funci\u00f3n busca-mayor definida en el apartado anterior y la segunda usando for-all? y la funci\u00f3n de orden superior exists? . Ejemplo: ( todos-menores? ' (( 10 30 20 ) ( 1 50 30 ) ( 30 40 90 )) 100 ) ; \u21d2 #t ( todos-menores? ' (( 10 30 20 ) ( 1 50 30 ) ( 30 40 90 )) 90 ) ; \u21d2 #f ( todos-menores? ' (( 10 30 20 ) ( 1 50 30 ) ( 30 40 90 )) 55 ) ; \u21d2 #f Lenguajes y Paradigmas de Programaci\u00f3n, curso 2021-22 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Domingo Gallardo, Cristina Pomares, Antonio Bot\u00eda, Francisco Mart\u00ednez","title":"Ejercicio 5"},{"location":"practicas/practica06/practica06.html","text":"Pr\u00e1ctica 6: Procedimientos recursivos e iterativos \u00b6 Antes de la clase de pr\u00e1cticas \u00b6 Los siguientes ejercicios est\u00e1n basados en los conceptos de teor\u00eda vistos la semana pasada. Antes de la clase de pr\u00e1cticas debes repasar todos los conceptos y probar en el DrRacket todos los ejemplos de los siguientes apartados del tema 3 Procedimientos recursivos : 1 El coste de la recursi\u00f3n 2 Procesos iterativos 3 Memoization 4 Figuras recursivas Ejercicios \u00b6 Descarga el fichero lpp.rkt , pulsando el bot\u00f3n derecho del rat\u00f3n y seleccionando la opci\u00f3n Guardar como lpp.rkt . Gu\u00e1rdalo en la misma carpeta en la que tengas el fichero practica6.rkt . El fichero contiene la definici\u00f3n de las funciones (crea-diccionario) , (put key value dic) y (get key dic) , necesarias para realizar una implementaci\u00f3n de un algoritmo recursivo con memoization y que necesitar\u00e1s en el ejercicio 4. Ejercicio 1 \u00b6 a) Implementa una versi\u00f3n recursiva iterativa de la funci\u00f3n (concat lista) que toma como argumento una lista de cadenas y devuelve una cadena resultante de concatenar todas las palabras de la lista. La funci\u00f3n concat deber\u00e1 llamar a la funci\u00f3n concat-iter que es la que implementa propiamente la versi\u00f3n iterativa usando recursi\u00f3n por la cola. Ejemplo: ( concat ' ( \"hola\" \"y\" \"adi\u00f3s\" )) ; \u21d2 \"holayadi\u00f3s\" ( concat-iter ' ( \"hola\" \"y\" \"adi\u00f3s\" ) \"\" ) ; \u21d2 \"holayadi\u00f3s\" b) Define utilizando recursi\u00f3n por la cola la funci\u00f3n (min-max lista) que recibe una lista num\u00e9rica y devuelve una pareja con el m\u00ednimo y el m\u00e1ximo de sus elementos. La lista recibida como par\u00e1metro tendr\u00e1 como m\u00ednimo un elemento. Ejemplo: ( min-max ' ( 2 5 9 12 5 0 4 )) ; \u21d2 (0 . 12) ( min-max ' ( 3 2 -8 4 10 0 )) ; \u21d2 (-8 . 10) ( min-max-iter ' ( 5 9 12 -2 5 0 4 ) ( cons 2 2 )) ; \u21d2 (-2 . 12) Ejercicio 2 \u00b6 a) Implementa utilizando recursi\u00f3n por la cola las funciones expande-pareja y expande-parejas de la pr\u00e1ctica 4. Ejemplo: ( expande-pareja ( cons ' a 4 )) ; \u21d2 (a a a a) ( expande-parejas ' ( #t . 3 ) ' ( \"LPP\" . 2 ) ' ( b . 4 )) ; \u21d2 (#t #t #t \"LPP\" \"LPP\" b b b b) b) Implementa utilizando recursi\u00f3n por la cola la funci\u00f3n (rotar k lista) que mueve k elementos de la cabeza de la lista al final. No es necesario utilizar una funci\u00f3n iterativa auxiliar , puedes hacer que la propia funci\u00f3n rotar sea iterativa usando el par\u00e1metro lista como el par\u00e1metro donde acumular el resultado. Ejemplo: ( rotar 4 ' ( a b c d e f g )) ; \u21d2 (e f g a b c d) Ejercicio 3 \u00b6 a) Implementa utilizando recursi\u00f3n por la cola la funci\u00f3n mi-foldl que haga lo mismo que la funci\u00f3n de orden superior foldl . ( mi-foldl string-append \"****\" ' ( \"hola\" \"que\" \"tal\" )) \u21d2 \"talquehola****\" ( mi-foldl cons ' () ' ( 1 2 3 4 )) ; \u21d2 (4 3 2 1) b) Existe un algoritmo eficiente para calcular el valor decimal de un n\u00famero binario basado en usar de forma iterativa una multiplicaci\u00f3n por 2. La idea es que si a un n\u00famero binario le a\u00f1adimos un d\u00edgito a su derecha, el valor del n\u00famero resultante es el valor del n\u00famero original multiplicado por 2 m\u00e1s el d\u00edgito que hemos a\u00f1adido. Por ejemplo, si tenemos el n\u00famero 101 , que es el n\u00famero decimal 5, y le a\u00f1adimos un 1 a su derecha (obteniendo el 1011 ) el n\u00famero decimal resultante se obtendr\u00eda multiplicando por 2 el n\u00famero original ( 5*2 = 10 ) y sum\u00e1ndole el 1 que hemos a\u00f1adido ( 11 ). De esta forma, podemos calcular de forma iterativa el valor decimal de un n\u00famero binario haciendo esta operaci\u00f3n con sus d\u00edgitos de izquierda a derecha. Deber\u00edamos ir acumulando en un resultado el valor del n\u00famero procesado y, en cada nuevo paso, multiplicar por 2 ese valor y sumar el valor del nuevo d\u00edgito que estamos procesando. resultado nuevo = resultado anterior * 2 + nuevo bit Supongamos el n\u00famero binario anterior, el 1011 . Veamos una traza de c\u00f3mo se obtendr\u00eda el 11. n\u00famero nuevo resultado resultado procesado bit anterior nuevo ======================================================= 1 0 0*2 + 1 = 1 1 0 1 1*2 + 0 = 2 10 1 2 2*2 + 1 = 5 101 1 5 5*2 + 1 = 11 1011 11 Implementa, usando el algoritmo anterior iterativo, la funci\u00f3n (binario-a-decimal lista-bits) que reciba una lista de bits que representan un n\u00famero en binario (el primer elemento ser\u00e1 el bit m\u00e1s significativo) y devuelva el n\u00famero decimal equivalente. ( binario-a-decimal ' ( 1 1 1 1 )) ; \u21d2 15 ( binario-a-decimal ' ( 1 1 0 )) ; \u21d2 6 ( binario-a-decimal ' ( 1 0 )) ; \u21d2 2 Ejercicio 4 \u00b6 Realiza una implementaci\u00f3n que utilice la t\u00e9cnica de la memoization del algoritmo que devuelve la serie de Pascal . ( define diccionario ( crea-diccionario )) ( pascal-memo 8 4 diccionario ) ; \u21d2 70 ( pascal-memo 40 20 diccionario ) ; \u21d2 137846528820 Ejercicio 5 \u00b6 a) Usando la librer\u00eda de im\u00e1genes de Racket 2htdp/image implementa la figura recursiva conocida como curva de Koch . Debes definir una funci\u00f3n recursiva (koch nivel trazo) que dibuje una curva de Koch de nivel nivel y de longitud trazo . Como pista, f\u00edjate en el dibujo. Para construir una imagen de una curva de Koch de nivel n y longitud l, se deber\u00e1n juntar 4 curvas de Koch de nivel n-1 y longitud l/3. La primera y la \u00faltima imagen son la curva original y la segunda y tercera est\u00e1n rotadas 60 grados. F\u00edjate tambi\u00e9n en la alineaci\u00f3n de las im\u00e1genes. Puedes ver ejemplos de las curvas de nivel 1, 2 y 3 en las siguientes figuras: b) Usando la funci\u00f3n anterior, implementa la funci\u00f3n (copo-nieve nivel trazo) que dibuje el copo de nieve de Koch que puedes ver en los siguientes ejemplos. Esta funci\u00f3n no es recursiva, se construye combinando tres veces la curva de Koch anterior. Ejercicio 6 \u00b6 Define la funci\u00f3n (alfombra-sierpinski tam) que construya la alfombra de Sierpinski (una variante del tri\u00e1ngulo de Sierpinski que hemos visto en teor\u00eda) de lado tam p\u00edxeles. En el caso base, cuando el tama\u00f1o sea menor que un umbral determinado, se debe dibujar un c\u00edrculo sin relleno de ancho tam . F\u00edjate que el par\u00e1metro que se le pasa a la primitiva circle es el del radio (lo puedes consultar aqu\u00ed ), por lo que para dibujar un c\u00edrculo de ancho (di\u00e1metro) tam habr\u00e1 que llamar a la primitiva con el par\u00e1metro tam/2 . Por ejemplo, la llamada a (alfombra-sierpinski 360) , poniendo como umbral 20 p\u00edxeles, debe dibujar la siguiente figura: Lenguajes y Paradigmas de Programaci\u00f3n, curso 2021-22 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Domingo Gallardo, Cristina Pomares, Antonio Bot\u00eda, Francisco Mart\u00ednez","title":"Pr\u00e1ctica 6"},{"location":"practicas/practica06/practica06.html#practica-6-procedimientos-recursivos-e-iterativos","text":"","title":"Pr\u00e1ctica 6: Procedimientos recursivos e iterativos"},{"location":"practicas/practica06/practica06.html#antes-de-la-clase-de-practicas","text":"Los siguientes ejercicios est\u00e1n basados en los conceptos de teor\u00eda vistos la semana pasada. Antes de la clase de pr\u00e1cticas debes repasar todos los conceptos y probar en el DrRacket todos los ejemplos de los siguientes apartados del tema 3 Procedimientos recursivos : 1 El coste de la recursi\u00f3n 2 Procesos iterativos 3 Memoization 4 Figuras recursivas","title":"Antes de la clase de pr\u00e1cticas"},{"location":"practicas/practica06/practica06.html#ejercicios","text":"Descarga el fichero lpp.rkt , pulsando el bot\u00f3n derecho del rat\u00f3n y seleccionando la opci\u00f3n Guardar como lpp.rkt . Gu\u00e1rdalo en la misma carpeta en la que tengas el fichero practica6.rkt . El fichero contiene la definici\u00f3n de las funciones (crea-diccionario) , (put key value dic) y (get key dic) , necesarias para realizar una implementaci\u00f3n de un algoritmo recursivo con memoization y que necesitar\u00e1s en el ejercicio 4.","title":"Ejercicios"},{"location":"practicas/practica06/practica06.html#ejercicio-1","text":"a) Implementa una versi\u00f3n recursiva iterativa de la funci\u00f3n (concat lista) que toma como argumento una lista de cadenas y devuelve una cadena resultante de concatenar todas las palabras de la lista. La funci\u00f3n concat deber\u00e1 llamar a la funci\u00f3n concat-iter que es la que implementa propiamente la versi\u00f3n iterativa usando recursi\u00f3n por la cola. Ejemplo: ( concat ' ( \"hola\" \"y\" \"adi\u00f3s\" )) ; \u21d2 \"holayadi\u00f3s\" ( concat-iter ' ( \"hola\" \"y\" \"adi\u00f3s\" ) \"\" ) ; \u21d2 \"holayadi\u00f3s\" b) Define utilizando recursi\u00f3n por la cola la funci\u00f3n (min-max lista) que recibe una lista num\u00e9rica y devuelve una pareja con el m\u00ednimo y el m\u00e1ximo de sus elementos. La lista recibida como par\u00e1metro tendr\u00e1 como m\u00ednimo un elemento. Ejemplo: ( min-max ' ( 2 5 9 12 5 0 4 )) ; \u21d2 (0 . 12) ( min-max ' ( 3 2 -8 4 10 0 )) ; \u21d2 (-8 . 10) ( min-max-iter ' ( 5 9 12 -2 5 0 4 ) ( cons 2 2 )) ; \u21d2 (-2 . 12)","title":"Ejercicio 1"},{"location":"practicas/practica06/practica06.html#ejercicio-2","text":"a) Implementa utilizando recursi\u00f3n por la cola las funciones expande-pareja y expande-parejas de la pr\u00e1ctica 4. Ejemplo: ( expande-pareja ( cons ' a 4 )) ; \u21d2 (a a a a) ( expande-parejas ' ( #t . 3 ) ' ( \"LPP\" . 2 ) ' ( b . 4 )) ; \u21d2 (#t #t #t \"LPP\" \"LPP\" b b b b) b) Implementa utilizando recursi\u00f3n por la cola la funci\u00f3n (rotar k lista) que mueve k elementos de la cabeza de la lista al final. No es necesario utilizar una funci\u00f3n iterativa auxiliar , puedes hacer que la propia funci\u00f3n rotar sea iterativa usando el par\u00e1metro lista como el par\u00e1metro donde acumular el resultado. Ejemplo: ( rotar 4 ' ( a b c d e f g )) ; \u21d2 (e f g a b c d)","title":"Ejercicio 2"},{"location":"practicas/practica06/practica06.html#ejercicio-3","text":"a) Implementa utilizando recursi\u00f3n por la cola la funci\u00f3n mi-foldl que haga lo mismo que la funci\u00f3n de orden superior foldl . ( mi-foldl string-append \"****\" ' ( \"hola\" \"que\" \"tal\" )) \u21d2 \"talquehola****\" ( mi-foldl cons ' () ' ( 1 2 3 4 )) ; \u21d2 (4 3 2 1) b) Existe un algoritmo eficiente para calcular el valor decimal de un n\u00famero binario basado en usar de forma iterativa una multiplicaci\u00f3n por 2. La idea es que si a un n\u00famero binario le a\u00f1adimos un d\u00edgito a su derecha, el valor del n\u00famero resultante es el valor del n\u00famero original multiplicado por 2 m\u00e1s el d\u00edgito que hemos a\u00f1adido. Por ejemplo, si tenemos el n\u00famero 101 , que es el n\u00famero decimal 5, y le a\u00f1adimos un 1 a su derecha (obteniendo el 1011 ) el n\u00famero decimal resultante se obtendr\u00eda multiplicando por 2 el n\u00famero original ( 5*2 = 10 ) y sum\u00e1ndole el 1 que hemos a\u00f1adido ( 11 ). De esta forma, podemos calcular de forma iterativa el valor decimal de un n\u00famero binario haciendo esta operaci\u00f3n con sus d\u00edgitos de izquierda a derecha. Deber\u00edamos ir acumulando en un resultado el valor del n\u00famero procesado y, en cada nuevo paso, multiplicar por 2 ese valor y sumar el valor del nuevo d\u00edgito que estamos procesando. resultado nuevo = resultado anterior * 2 + nuevo bit Supongamos el n\u00famero binario anterior, el 1011 . Veamos una traza de c\u00f3mo se obtendr\u00eda el 11. n\u00famero nuevo resultado resultado procesado bit anterior nuevo ======================================================= 1 0 0*2 + 1 = 1 1 0 1 1*2 + 0 = 2 10 1 2 2*2 + 1 = 5 101 1 5 5*2 + 1 = 11 1011 11 Implementa, usando el algoritmo anterior iterativo, la funci\u00f3n (binario-a-decimal lista-bits) que reciba una lista de bits que representan un n\u00famero en binario (el primer elemento ser\u00e1 el bit m\u00e1s significativo) y devuelva el n\u00famero decimal equivalente. ( binario-a-decimal ' ( 1 1 1 1 )) ; \u21d2 15 ( binario-a-decimal ' ( 1 1 0 )) ; \u21d2 6 ( binario-a-decimal ' ( 1 0 )) ; \u21d2 2","title":"Ejercicio 3"},{"location":"practicas/practica06/practica06.html#ejercicio-4","text":"Realiza una implementaci\u00f3n que utilice la t\u00e9cnica de la memoization del algoritmo que devuelve la serie de Pascal . ( define diccionario ( crea-diccionario )) ( pascal-memo 8 4 diccionario ) ; \u21d2 70 ( pascal-memo 40 20 diccionario ) ; \u21d2 137846528820","title":"Ejercicio 4"},{"location":"practicas/practica06/practica06.html#ejercicio-5","text":"a) Usando la librer\u00eda de im\u00e1genes de Racket 2htdp/image implementa la figura recursiva conocida como curva de Koch . Debes definir una funci\u00f3n recursiva (koch nivel trazo) que dibuje una curva de Koch de nivel nivel y de longitud trazo . Como pista, f\u00edjate en el dibujo. Para construir una imagen de una curva de Koch de nivel n y longitud l, se deber\u00e1n juntar 4 curvas de Koch de nivel n-1 y longitud l/3. La primera y la \u00faltima imagen son la curva original y la segunda y tercera est\u00e1n rotadas 60 grados. F\u00edjate tambi\u00e9n en la alineaci\u00f3n de las im\u00e1genes. Puedes ver ejemplos de las curvas de nivel 1, 2 y 3 en las siguientes figuras: b) Usando la funci\u00f3n anterior, implementa la funci\u00f3n (copo-nieve nivel trazo) que dibuje el copo de nieve de Koch que puedes ver en los siguientes ejemplos. Esta funci\u00f3n no es recursiva, se construye combinando tres veces la curva de Koch anterior.","title":"Ejercicio 5"},{"location":"practicas/practica06/practica06.html#ejercicio-6","text":"Define la funci\u00f3n (alfombra-sierpinski tam) que construya la alfombra de Sierpinski (una variante del tri\u00e1ngulo de Sierpinski que hemos visto en teor\u00eda) de lado tam p\u00edxeles. En el caso base, cuando el tama\u00f1o sea menor que un umbral determinado, se debe dibujar un c\u00edrculo sin relleno de ancho tam . F\u00edjate que el par\u00e1metro que se le pasa a la primitiva circle es el del radio (lo puedes consultar aqu\u00ed ), por lo que para dibujar un c\u00edrculo de ancho (di\u00e1metro) tam habr\u00e1 que llamar a la primitiva con el par\u00e1metro tam/2 . Por ejemplo, la llamada a (alfombra-sierpinski 360) , poniendo como umbral 20 p\u00edxeles, debe dibujar la siguiente figura: Lenguajes y Paradigmas de Programaci\u00f3n, curso 2021-22 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Domingo Gallardo, Cristina Pomares, Antonio Bot\u00eda, Francisco Mart\u00ednez","title":"Ejercicio 6"},{"location":"practicas/practica07/practica07.html","text":"Pr\u00e1ctica 7: Listas estructuradas \u00b6 Antes de la clase de pr\u00e1cticas \u00b6 Los siguientes ejercicios est\u00e1n basados en los conceptos de teor\u00eda vistos la semana pasada. Antes de la clase de pr\u00e1cticas debes repasar todos los conceptos y probar en el DrRacket todos los ejemplos de los siguientes apartados del tema 4 Estructuras de datos recursivas 1 Listas estructuradas Ejercicios \u00b6 Descarga el fichero lpp.rkt , pulsando el bot\u00f3n derecho del rat\u00f3n y seleccionando la opci\u00f3n Guardar como lpp.rkt . Gu\u00e1rdalo en la misma carpeta en la que tengas el fichero practica7.rkt . El fichero contiene la definici\u00f3n de la funci\u00f3n (hoja? dato) y la funci\u00f3n (pinta-lista lista) que nos permite dibujar gr\u00e1ficamente una lista estructurada. Por ejemplo, si definimos una lista estructurada como ( define lista ' ( a ( b ( c d ) e ) ( f g ))) La llamada a pinta-lista dibujar\u00e1 lo siguiente: Ejercicio 1 \u00b6 a) Escribe la lista estructurada correspondiente a la siguiente representaci\u00f3n gr\u00e1fica por niveles. Para comprobar si la has definido correctamente puedes intentar obtener algunos de los elementos de la lista, como mostramos en el check-equal? que hay a continuaci\u00f3n. * / | \\ | | \\ * d * / \\ / / | \\ a b c * * h | / \\ e f g ( define lista-a ' ( ________ )) ( check-equal? ( fourth ( third lista-a )) 'h ) b) Dibuja la representaci\u00f3n en niveles de las siguientes listas estructurada. Comprueba despu\u00e9s con la funci\u00f3n (pinta-lista lista) que las has dibujado correctamente. ( define lista-b1 ' (( 2 ( 3 )) ( 4 2 ) (( 2 ) 3 ))) ( define lista-b2 ' (( b ) ( c ( a )) d ( a ))) c) Dada la definici\u00f3n de cuadrado-estruct vista en teor\u00eda: Indica qu\u00e9 devuelve la expresi\u00f3n (cuadrado-estruct lista-b1) . La lista lista-b1 es la definida en el apartado anterior. En la evaluaci\u00f3n de la expresi\u00f3n anterior, indica cu\u00e1les son los argumentos que se pasan por par\u00e1metro en las llamadas recursivas a cuadrado-estruct marcadas con 1 y 2 . En la evaluaci\u00f3n de la expresi\u00f3n anterior, indican qu\u00e9 devuelven las llamadas recursivas marcadas con 1 y 2 . d) Para entender el funcionamiento de las funciones de orden superior que trabajan sobre listas estructuradas es muy importante entender qu\u00e9 devuelve la expresi\u00f3n map que se aplica a la lista. La siguiente funci\u00f3n utiliza la funci\u00f3n (nivel-hoja-fos dato lista) vista en teor\u00eda. Indica qu\u00e9 devuelve la siguiente expresi\u00f3n. La lista lista-b2 es la definida en el apartado anterior. Utiliza el dibujo que has hecho en el ejercicio anterior para entender el funcionamiento de la expresi\u00f3n. ( map ( lambda ( elem ) ( nivel-hoja-fos ' a elem )) lista-b2 ) Ejercicio 2 \u00b6 a) Implementa la funci\u00f3n recursiva (cuenta-pares lista) que recibe una lista estructurada y cuenta la cantidad de n\u00fameros pares que contiene. Implementa dos versiones de la funci\u00f3n, una con recursi\u00f3n pura y otra con funciones de orden superior . Ejemplos: ( cuenta-pares ' ( 1 ( 2 3 ) 4 ( 5 6 ))) ; \u21d2 3 ( cuenta-pares ' ((( 1 2 ) 3 ( 4 ) 5 ) (((( 6 )))))) ; \u21d2 3 b) Implementa la funci\u00f3n recursiva (todos-positivos lista) que recibe una lista estructurada con n\u00fameros y comprueba si todos sus elementos son positivos. Implementa dos versiones de la funci\u00f3n, una con recursi\u00f3n pura y otra con funciones de orden superior . Ejemplos: ( todos-positivos-fos ' ( 1 ( 2 ( 3 ( -3 ))) 4 )) ; \u21d2 #f ( todos-positivos-fos ' ( 1 ( 2 ( 3 ( 3 ))) 4 )) ; \u21d2 #t Ejercicio 3 \u00b6 Implementa la funci\u00f3n (cumplen-predicado pred lista) que devuelva una lista con todos los elementos de lista estructurada que cumplen un predicado. Implementa dos versiones, una recursiva pura y otra usando funciones de orden superior . Ejemplo: ( cumplen-predicado even? ' ( 1 ( 2 ( 3 ( 4 ))) ( 5 6 ))) ; \u21d2 (2 4 6) ( cumplen-predicado pair? ' ((( 1 . 2 ) 3 ( 4 . 3 ) 5 ) 6 )) ; \u21d2 ((1 . 2) (4 . 3)) Utilizando la funci\u00f3n anterior implementa las siguientes funciones: Funci\u00f3n (busca-mayores n lista-num) que recibe una lista estructurada con n\u00fameros y un n\u00famero n y devuelve una lista plana con los n\u00fameros de la lista original mayores que n . ( busca-mayores 10 ' ( -1 ( 20 ( 10 12 ) ( 30 ( 25 ( 15 )))))) ; \u21d2 (20 12 30 25 15) Funci\u00f3n (empieza-por char lista-pal) que recibe una lista estructurada con s\u00edmbolos y un car\u00e1cter char y devuelve una lista plana con los s\u00edmbolos de la lista original que comienzan por el car\u00e1cter char . ( empieza-por #\\m ' (( hace ( mucho tiempo )) ( en ) ( una galaxia (( muy muy ) lejana )))) ; \u21d2 (mucho muy muy) Ejercicio 4 \u00b6 a) Implementa la funci\u00f3n (sustituye-elem elem-old elem-new lista) que recibe como argumentos una lista estructurada y dos elementos, y devuelve otra lista con la misma estructura, pero en la que se ha sustituido las ocurrencias de elem-old por elem-new . Puedes hacerla de forma recursiva o con funciones de orden superior. Ejemplo: ( sustituye-elem 'c 'h ' ( a b ( c d ( e c )) c ( f ( c ) g ))) ; \u21d2 (a b (h d (e h)) h (f (h) g)) b.1) Implementa la funci\u00f3n (intersecta lista-1 lista-2) que recibe como par\u00e1metros dos listas estructuradas y devuelve la lista estructurada resultante de recorrer ambas listas y colocar una pareja formada por la hoja de la primera y de la segunda en aquellas posiciones en las que el recorrido de ambas listas terminen al mismo tiempo en una hoja. Por ejemplo, si definimos las dos listas de la siguiente forma: ( define lista-1 ' ( a ( b c ) ( d ))) ; * ; / | \\ ; a * * ; / \\ \\ ; b c d ( define lista-2 ' (( e ) ( f ) ( g ))) ; * ; / | \\ ; * * * ; / / \\ ;e f g La intersecci\u00f3n de ambas listas ser\u00eda: ( intersecta lista-1 lista-2 ) ; \u21d2 (((b . f)) ((d . g))) ; * ; | \\ ; * * ; / \\ ; (b.f) (d.g) La funci\u00f3n recorrer\u00e1 al mismo tiempo la primera y la segunda lista. En la primera lista, en su primer elemento, llegar\u00e1 a la hoja a , mientras que en la segunda lista llegar\u00e1 a una sublista (la que contiene e ). Ah\u00ed no habr\u00e1 intersecci\u00f3n. Despu\u00e9s recorrer\u00e1 el segundo elemento de la primera y la segunda lista y llegar\u00e1 a las hojas b y f al mismo tiempo, por lo que construir\u00e1 la pareja (b . f) . Descartar\u00e1 la sublista de la segunda lista formada por la c , por no existir correspondencia en la primera lista. Y, por \u00faltimo, comprobar\u00e1 que recorriendo el \u00faltimo elemento de ambas listas se llegar\u00e1 al mismo tiempo a las hojas d y g , formando la pareja (d . g) . Puedes implementar la funci\u00f3n usando recursi\u00f3n o con funciones de orden superior. Otros ejemplos: (intersecta '(a b) '(c d)) ; \u21d2 '((a . c) (b . d)) (intersecta '(a (b) (c)) '(d e (f))) ; \u21d2 '((a . d) ((c . f))) ; \u21d2 b.2) Generaliza la funci\u00f3n anterior, haciendo que reciba otra funci\u00f3n con la operaci\u00f3n a realizar con las hojas: (intersecta-gen f lista-1 lista-2) . Escribe tres ejemplos de uso de la funci\u00f3n gen\u00e9rica con distintas funciones a aplicar a las hojas y explica qu\u00e9 devuelve cada caso. Ejercicio 5 \u00b6 Dos funciones sobre niveles: a) Define la funci\u00f3n recursiva (mezclar lista1 lista2 n) que reciba dos listas estructuradas con la misma estructura y un n\u00famero que indica un nivel. Devuelve una nueva lista estructurada con la misma estructura que las listas originales, con los elementos de lista1 que tienen un nivel menor o igual que n y los elementos de lista2 que tienen un nivel mayor que n . ( define lista1 ' ((( a b ) (( c ))) ( d ) e )) ( define lista2 ' ((( 1 2 ) (( 3 ))) ( 4 ) 5 )) ( mezclar lista1 lista2 2 ) ; \u21d2 (((1 2) ((3))) (d) e) b) Implementa la funci\u00f3n (nivel-elemento lista) que reciba una lista estructurada y devuelva una pareja (elem . nivel) , donde la parte izquierda es el elemento que se encuentra a mayor nivel y la parte derecha el nivel en el que se encuentra. Puedes definir alguna funci\u00f3n auxiliar si lo necesitas. Puedes hacerlo con recursi\u00f3n o con funciones de orden superior. ( nivel-elemento ' ( 2 ( 3 ))) ; \u21d2 (3 . 2) ( nivel-elemento ' (( 2 ) ( 3 ( 4 )(((((( 5 ))) 6 )) 7 )) 8 )) ; \u21d2 (5 . 8) Lenguajes y Paradigmas de Programaci\u00f3n, curso 2021-22 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Domingo Gallardo, Cristina Pomares, Antonio Bot\u00eda, Francisco Mart\u00ednez","title":"Pr\u00e1ctica 7"},{"location":"practicas/practica07/practica07.html#practica-7-listas-estructuradas","text":"","title":"Pr\u00e1ctica 7: Listas estructuradas"},{"location":"practicas/practica07/practica07.html#antes-de-la-clase-de-practicas","text":"Los siguientes ejercicios est\u00e1n basados en los conceptos de teor\u00eda vistos la semana pasada. Antes de la clase de pr\u00e1cticas debes repasar todos los conceptos y probar en el DrRacket todos los ejemplos de los siguientes apartados del tema 4 Estructuras de datos recursivas 1 Listas estructuradas","title":"Antes de la clase de pr\u00e1cticas"},{"location":"practicas/practica07/practica07.html#ejercicios","text":"Descarga el fichero lpp.rkt , pulsando el bot\u00f3n derecho del rat\u00f3n y seleccionando la opci\u00f3n Guardar como lpp.rkt . Gu\u00e1rdalo en la misma carpeta en la que tengas el fichero practica7.rkt . El fichero contiene la definici\u00f3n de la funci\u00f3n (hoja? dato) y la funci\u00f3n (pinta-lista lista) que nos permite dibujar gr\u00e1ficamente una lista estructurada. Por ejemplo, si definimos una lista estructurada como ( define lista ' ( a ( b ( c d ) e ) ( f g ))) La llamada a pinta-lista dibujar\u00e1 lo siguiente:","title":"Ejercicios"},{"location":"practicas/practica07/practica07.html#ejercicio-1","text":"a) Escribe la lista estructurada correspondiente a la siguiente representaci\u00f3n gr\u00e1fica por niveles. Para comprobar si la has definido correctamente puedes intentar obtener algunos de los elementos de la lista, como mostramos en el check-equal? que hay a continuaci\u00f3n. * / | \\ | | \\ * d * / \\ / / | \\ a b c * * h | / \\ e f g ( define lista-a ' ( ________ )) ( check-equal? ( fourth ( third lista-a )) 'h ) b) Dibuja la representaci\u00f3n en niveles de las siguientes listas estructurada. Comprueba despu\u00e9s con la funci\u00f3n (pinta-lista lista) que las has dibujado correctamente. ( define lista-b1 ' (( 2 ( 3 )) ( 4 2 ) (( 2 ) 3 ))) ( define lista-b2 ' (( b ) ( c ( a )) d ( a ))) c) Dada la definici\u00f3n de cuadrado-estruct vista en teor\u00eda: Indica qu\u00e9 devuelve la expresi\u00f3n (cuadrado-estruct lista-b1) . La lista lista-b1 es la definida en el apartado anterior. En la evaluaci\u00f3n de la expresi\u00f3n anterior, indica cu\u00e1les son los argumentos que se pasan por par\u00e1metro en las llamadas recursivas a cuadrado-estruct marcadas con 1 y 2 . En la evaluaci\u00f3n de la expresi\u00f3n anterior, indican qu\u00e9 devuelven las llamadas recursivas marcadas con 1 y 2 . d) Para entender el funcionamiento de las funciones de orden superior que trabajan sobre listas estructuradas es muy importante entender qu\u00e9 devuelve la expresi\u00f3n map que se aplica a la lista. La siguiente funci\u00f3n utiliza la funci\u00f3n (nivel-hoja-fos dato lista) vista en teor\u00eda. Indica qu\u00e9 devuelve la siguiente expresi\u00f3n. La lista lista-b2 es la definida en el apartado anterior. Utiliza el dibujo que has hecho en el ejercicio anterior para entender el funcionamiento de la expresi\u00f3n. ( map ( lambda ( elem ) ( nivel-hoja-fos ' a elem )) lista-b2 )","title":"Ejercicio 1"},{"location":"practicas/practica07/practica07.html#ejercicio-2","text":"a) Implementa la funci\u00f3n recursiva (cuenta-pares lista) que recibe una lista estructurada y cuenta la cantidad de n\u00fameros pares que contiene. Implementa dos versiones de la funci\u00f3n, una con recursi\u00f3n pura y otra con funciones de orden superior . Ejemplos: ( cuenta-pares ' ( 1 ( 2 3 ) 4 ( 5 6 ))) ; \u21d2 3 ( cuenta-pares ' ((( 1 2 ) 3 ( 4 ) 5 ) (((( 6 )))))) ; \u21d2 3 b) Implementa la funci\u00f3n recursiva (todos-positivos lista) que recibe una lista estructurada con n\u00fameros y comprueba si todos sus elementos son positivos. Implementa dos versiones de la funci\u00f3n, una con recursi\u00f3n pura y otra con funciones de orden superior . Ejemplos: ( todos-positivos-fos ' ( 1 ( 2 ( 3 ( -3 ))) 4 )) ; \u21d2 #f ( todos-positivos-fos ' ( 1 ( 2 ( 3 ( 3 ))) 4 )) ; \u21d2 #t","title":"Ejercicio 2"},{"location":"practicas/practica07/practica07.html#ejercicio-3","text":"Implementa la funci\u00f3n (cumplen-predicado pred lista) que devuelva una lista con todos los elementos de lista estructurada que cumplen un predicado. Implementa dos versiones, una recursiva pura y otra usando funciones de orden superior . Ejemplo: ( cumplen-predicado even? ' ( 1 ( 2 ( 3 ( 4 ))) ( 5 6 ))) ; \u21d2 (2 4 6) ( cumplen-predicado pair? ' ((( 1 . 2 ) 3 ( 4 . 3 ) 5 ) 6 )) ; \u21d2 ((1 . 2) (4 . 3)) Utilizando la funci\u00f3n anterior implementa las siguientes funciones: Funci\u00f3n (busca-mayores n lista-num) que recibe una lista estructurada con n\u00fameros y un n\u00famero n y devuelve una lista plana con los n\u00fameros de la lista original mayores que n . ( busca-mayores 10 ' ( -1 ( 20 ( 10 12 ) ( 30 ( 25 ( 15 )))))) ; \u21d2 (20 12 30 25 15) Funci\u00f3n (empieza-por char lista-pal) que recibe una lista estructurada con s\u00edmbolos y un car\u00e1cter char y devuelve una lista plana con los s\u00edmbolos de la lista original que comienzan por el car\u00e1cter char . ( empieza-por #\\m ' (( hace ( mucho tiempo )) ( en ) ( una galaxia (( muy muy ) lejana )))) ; \u21d2 (mucho muy muy)","title":"Ejercicio 3"},{"location":"practicas/practica07/practica07.html#ejercicio-4","text":"a) Implementa la funci\u00f3n (sustituye-elem elem-old elem-new lista) que recibe como argumentos una lista estructurada y dos elementos, y devuelve otra lista con la misma estructura, pero en la que se ha sustituido las ocurrencias de elem-old por elem-new . Puedes hacerla de forma recursiva o con funciones de orden superior. Ejemplo: ( sustituye-elem 'c 'h ' ( a b ( c d ( e c )) c ( f ( c ) g ))) ; \u21d2 (a b (h d (e h)) h (f (h) g)) b.1) Implementa la funci\u00f3n (intersecta lista-1 lista-2) que recibe como par\u00e1metros dos listas estructuradas y devuelve la lista estructurada resultante de recorrer ambas listas y colocar una pareja formada por la hoja de la primera y de la segunda en aquellas posiciones en las que el recorrido de ambas listas terminen al mismo tiempo en una hoja. Por ejemplo, si definimos las dos listas de la siguiente forma: ( define lista-1 ' ( a ( b c ) ( d ))) ; * ; / | \\ ; a * * ; / \\ \\ ; b c d ( define lista-2 ' (( e ) ( f ) ( g ))) ; * ; / | \\ ; * * * ; / / \\ ;e f g La intersecci\u00f3n de ambas listas ser\u00eda: ( intersecta lista-1 lista-2 ) ; \u21d2 (((b . f)) ((d . g))) ; * ; | \\ ; * * ; / \\ ; (b.f) (d.g) La funci\u00f3n recorrer\u00e1 al mismo tiempo la primera y la segunda lista. En la primera lista, en su primer elemento, llegar\u00e1 a la hoja a , mientras que en la segunda lista llegar\u00e1 a una sublista (la que contiene e ). Ah\u00ed no habr\u00e1 intersecci\u00f3n. Despu\u00e9s recorrer\u00e1 el segundo elemento de la primera y la segunda lista y llegar\u00e1 a las hojas b y f al mismo tiempo, por lo que construir\u00e1 la pareja (b . f) . Descartar\u00e1 la sublista de la segunda lista formada por la c , por no existir correspondencia en la primera lista. Y, por \u00faltimo, comprobar\u00e1 que recorriendo el \u00faltimo elemento de ambas listas se llegar\u00e1 al mismo tiempo a las hojas d y g , formando la pareja (d . g) . Puedes implementar la funci\u00f3n usando recursi\u00f3n o con funciones de orden superior. Otros ejemplos: (intersecta '(a b) '(c d)) ; \u21d2 '((a . c) (b . d)) (intersecta '(a (b) (c)) '(d e (f))) ; \u21d2 '((a . d) ((c . f))) ; \u21d2 b.2) Generaliza la funci\u00f3n anterior, haciendo que reciba otra funci\u00f3n con la operaci\u00f3n a realizar con las hojas: (intersecta-gen f lista-1 lista-2) . Escribe tres ejemplos de uso de la funci\u00f3n gen\u00e9rica con distintas funciones a aplicar a las hojas y explica qu\u00e9 devuelve cada caso.","title":"Ejercicio 4"},{"location":"practicas/practica07/practica07.html#ejercicio-5","text":"Dos funciones sobre niveles: a) Define la funci\u00f3n recursiva (mezclar lista1 lista2 n) que reciba dos listas estructuradas con la misma estructura y un n\u00famero que indica un nivel. Devuelve una nueva lista estructurada con la misma estructura que las listas originales, con los elementos de lista1 que tienen un nivel menor o igual que n y los elementos de lista2 que tienen un nivel mayor que n . ( define lista1 ' ((( a b ) (( c ))) ( d ) e )) ( define lista2 ' ((( 1 2 ) (( 3 ))) ( 4 ) 5 )) ( mezclar lista1 lista2 2 ) ; \u21d2 (((1 2) ((3))) (d) e) b) Implementa la funci\u00f3n (nivel-elemento lista) que reciba una lista estructurada y devuelva una pareja (elem . nivel) , donde la parte izquierda es el elemento que se encuentra a mayor nivel y la parte derecha el nivel en el que se encuentra. Puedes definir alguna funci\u00f3n auxiliar si lo necesitas. Puedes hacerlo con recursi\u00f3n o con funciones de orden superior. ( nivel-elemento ' ( 2 ( 3 ))) ; \u21d2 (3 . 2) ( nivel-elemento ' (( 2 ) ( 3 ( 4 )(((((( 5 ))) 6 )) 7 )) 8 )) ; \u21d2 (5 . 8) Lenguajes y Paradigmas de Programaci\u00f3n, curso 2021-22 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Domingo Gallardo, Cristina Pomares, Antonio Bot\u00eda, Francisco Mart\u00ednez","title":"Ejercicio 5"},{"location":"practicas/practica08/practica08.html","text":"Pr\u00e1ctica 7: \u00c1rboles \u00b6 Entrega de la pr\u00e1ctica \u00b6 Para entregar la pr\u00e1ctica debes subir a Moodle el fichero practica07.rkt con una cabecera inicial con tu nombre y apellidos, y las soluciones de cada ejercicio separadas por comentarios. Cada soluci\u00f3n debe incluir: La definici\u00f3n de las funciones que resuelven el ejercicio. Un conjunto de pruebas que comprueben su funcionamiento utilizando el API RackUnit . Ejercicios \u00b6 Importante Antes de empezar la pr\u00e1ctica debes haber estudiado los apartados de \u00e1rboles gen\u00e9ricos y \u00e1rboles binarios del tema 4 de teor\u00eda. Copia al principio de la pr\u00e1ctica las funciones de las barreras de abstracci\u00f3n de \u00e1rboles y \u00e1rboles binarios y utiliza esas funciones en todos los ejercicios cuando est\u00e9s realizando operaciones sobre \u00e1rboles. Ejercicio 1 \u00b6 a.1) Escribe la sentencia en Scheme que define el siguiente \u00e1rbol gen\u00e9rico y escribe utilizando las funciones de la barrera de abstracci\u00f3n de \u00e1rboles una expresi\u00f3n que devuelva el n\u00famero 10. (define arbol '(------------)) (check-equal? ------------------- 10) a.2) Las funciones que suman los datos de un \u00e1rbol utilizando recursi\u00f3n mutua y que hemos visto en teor\u00eda son las siguientes: ( define ( suma-datos-arbol arbol ) ( + ( dato-arbol arbol ) ( suma-datos-bosque ( hijos-arbol arbol )))) ( define ( suma-datos-bosque bosque ) ( if ( null? bosque ) 0 ( + ( suma-datos-arbol ( car bosque )) ( suma-datos-bosque ( cdr bosque ))))) Si realizamos la siguiente llamada a la funci\u00f3n suma-datos-bosque , siendo arbol el definido en el apartado anterior: ( suma-datos-bosque ( hijos-arbol arbol )) \u00bfQu\u00e9 devuelve la invocaci\u00f3n a (suma-datos-arbol (car bosque)) que se realiza dentro de la funci\u00f3n? \u00bfQu\u00e9 devuelve la primera llamada recursiva a suma-datos-bosque ? Escribe la contestaci\u00f3n a estas preguntas como comentarios en el fichero de la pr\u00e1ctica. a.3) La funci\u00f3n de orden superior que hemos visto en teor\u00eda y que realiza tambi\u00e9n la suma de los datos de un \u00e1rbol es: ( define ( suma-datos-arbol-fos arbol ) ( foldr + ( dato-arbol arbol ) ( map suma-datos-arbol-fos ( hijos-arbol arbol )))) Si realizamos la siguiente llamada a la funci\u00f3n, siendo arbol el definido en el apartado anterior: ( suma-datos-arbol-fos arbol ) \u00bfQu\u00e9 devuelve la invocaci\u00f3n a map dentro de la funci\u00f3n? \u00bfQu\u00e9 invocaciones se realizan a la funci\u00f3n + durante la ejecuci\u00f3n de foldr sobre la lista devuelta por la invocaci\u00f3n a map ? Enum\u00e9ralas en orden, indicando sus par\u00e1metros y el valor devuelto en cada una de ellas. b.1) Escribe la sentencia en Scheme que define el siguiente \u00e1rbol binario y escribe utilizando las funciones de la barrera de abstracci\u00f3n de \u00e1rboles binarios una expresi\u00f3n que devuelva el n\u00famero 29. (define arbolb '(------------------)) (check-equal? ---------------------- 29) Ejercicio 2 \u00b6 a) Implementa dos versiones de la funci\u00f3n (to-string-arbol arbol) que recibe un \u00e1rbol de s\u00edmbolos y devuelve la cadena resultante de concatenar todos los s\u00edmbolos en recorrido preorden. Debes implementar una versi\u00f3n con recursi\u00f3n mutua y otra (llamada to-string-arbol-fos ) con una \u00fanica funci\u00f3n en la que se use funciones de orden superior. Ejemplo: ( define arbol2 ' ( a ( b ( c ( d )) ( e )) ( f ))) ( to-string-arbol arbol2 ) ; \u21d2 \"abcdef\" b) Implementa dos versiones de la funci\u00f3n (veces-arbol dato arbol) que recibe un \u00e1rbol y un dato y comprueba el n\u00famero de veces que aparece el dato en el \u00e1rbol. Debes implementar una funci\u00f3n con recursi\u00f3n mutua y otra con funciones de orden superior. ( veces-arbol ' b ' ( a ( b ( c ) ( d )) ( b ( b ) ( f )))) ; \u21d2 3 ( veces-arbol ' g ' ( a ( b ( c ) ( d )) ( b ( b ) ( f )))) ; \u21d2 0 Ejercicio 3 \u00b6 a) Implementa dos versiones de la funci\u00f3n (hojas-cumplen pred arbol) que recibe un predicado y un \u00e1rbol y devuelve una lista con todas aquellas hojas del \u00e1rbol que cumplen el predicado. Una funci\u00f3n con recursi\u00f3n mutua y otra con funciones de orden superior. Para evitar complicar la funci\u00f3n de orden superior, suponemos que el \u00e1rbol inicial que pasamos como par\u00e1metro no es un \u00e1rbol hoja. ( define arbol1 ' ( 10 ( 2 ) ( 12 ( 4 ) ( 2 )) ( 10 ( 5 )))) ( define arbol2 ' ( 10 ( 2 ) ( 12 ( 4 ) ( 2 )) ( 10 ( 6 )))) ( hojas-cumplen even? arbol1 ) ; \u21d2 '(2 4 2) ( hojas-cumplen even? arbol2 ) ; \u21d2 '(2 4 2 6) b) Implementa dos versiones del predicado (todas-hojas-cumplen? pred arbol) que comprueba si todas las hojas de un \u00e1rbol cumplen un determinado predicado. Una funci\u00f3n con recursi\u00f3n mutua y otra con funciones de orden superior. No debes usar la funci\u00f3n anterior, tienes que hacer un recorrido por todo el \u00e1rbol. Para la funci\u00f3n de orden superior puedes usar la funci\u00f3n for-all? implementada en el tema 2 . ( todas-hojas-cumplen? even? arbol1 ) ; \u21d2 #f ( todas-hojas-cumplen? even? arbol2 ) ; \u21d2 #t Ejercicio 4 \u00b6 a) Implementa, utilizando funciones de orden superior, la funci\u00f3n (suma-raices-hijos arbol) que devuelva la suma de las ra\u00edces de los hijos de un \u00e1rbol gen\u00e9rico. Ejemplo: ( define arbol3 ' ( 20 ( 2 ) ( 8 ( 4 ) ( 2 )) ( 9 ( 5 )))) ( suma-raices-hijos arbol3 ) ; \u21d2 19 ( suma-raices-hijos ( cadr ( hijos-arbol arbol3 ))) ; \u21d2 6 b) Implementa dos versiones, una con recursi\u00f3n mutua y otra con funciones de orden superior, de la funci\u00f3n (raices-mayores-arbol? arbol) que recibe un \u00e1rbol y comprueba que su ra\u00edz sea mayor que la suma de las ra\u00edces de los hijos y que todos los hijos (nos referimos a todos los descendientes) cumplen tambi\u00e9n esta propiedad. Ejemplos: ( raices-mayores-arbol? arbol3 ) ; \u21d2 #t ( raices-mayores-arbol? ' ( 20 ( 2 ) ( 8 ( 4 ) ( 5 )) ( 9 ( 5 )))) ; \u21d2 #f c) Define la funci\u00f3n (comprueba-raices-arbol arbol) que recibe un arbol y que devuelve otro arbol en el que los nodos se han sustituido por 1 o 0 seg\u00fan si son mayores que la suma de las ra\u00edces de sus hijos o no. Ejemplos: ( comprueba-raices-arbol arbol3 ) ; \u21d2 (1 (1) (1 (1) (1)) (1 (1))) ( comprueba-raices-arbol ' ( 20 ( 2 ) ( 8 ( 4 ) ( 5 )) ( 9 ( 5 )))) ; \u21d2 (1 (1) (0 (1) (1)) (1 (1))) Ejercicio 5 \u00b6 a) Define la funci\u00f3n (es-camino? lista arbol) que debe comprobar si la secuencia de elementos de la lista se corresponde con un camino del \u00e1rbol que empieza en la ra\u00edz y que termina exactamente en una hoja. Suponemos que lista contiene al menos un elemento Por ejemplo, la lista (a b a) s\u00ed que es camino en el siguiente \u00e1rbol, pero la lista (a b) no. Ejemplos: suponiendo que arbol es el \u00e1rbol definido por la figura anterior: ( es-camino? ' ( a b a ) arbol ) ; \u21d2 #t ( es-camino? ' ( a b ) arbol ) ; \u21d2 #f ( es-camino? ' ( a b a b ) arbol ) ; \u21d2 #f b) Escribe la funci\u00f3n (nodos-nivel nivel arbol) que reciba un nivel y un \u00e1rbol gen\u00e9rico y devuelva una lista con todos los nodos que se encuentran en ese nivel. Ejemplos, suponiendo que arbol es el \u00e1rbol definido por la figura anterior: ( nodos-nivel 0 arbol ) ; \u21d2 '(1) ( nodos-nivel 1 arbol ) ; \u21d2 '(2 6) ( nodos-nivel 2 arbol ) ; \u21d2 '(3 5 7) ( nodos-nivel 3 arbol ) ; \u21d2 '(4 2) Ejercicio 6 \u00b6 a) Define la funci\u00f3n (ordenado-entre? arbolb min max) que comprueba si un \u00e1rbol binario est\u00e1 ordenado y sus datos est\u00e1 entre min y max . Un \u00e1rbol binario est\u00e1 ordenado cuando sus hijos izquierdos y derecho est\u00e1n ordenados y cuando la ra\u00edz es mayor o igual que todos los n\u00fameros del hijo izquierdo y menor o igual que todos los n\u00fameros del hijo derecho. Por ejemplo, en la siguiente figura, el \u00e1rbol binario de la izquierda ( arbolb1 ) est\u00e1 ordenado, pero el de la derecha ( arbolb2 ) no lo est\u00e1. Ejemplo: ( define arbolb1 ' ( 20 ( 13 ( 2 () ()) ( 18 () ())) ( 40 ( 25 () () ) ( 43 () ())))) ( define arbolb2 ' ( 20 ( 13 ( 2 () ()) ( 22 () ())) ( 40 ( 25 () () ) ( 43 () ())))) ( ordenado-entre? arbolb1 0 50 ) ; \u21d2 #t ( ordenado-entre? arbolb2 0 50 ) ; \u21d2 #f ( ordenado-entre? arbolb1 0 30 ) ; \u21d2 #f b) Utilizando la funci\u00f3n anterior, define las funciones (ordenado-menor? arbolb max) y (ordenado-mayor? arbolb min) que comprueban si un \u00e1rbol binario est\u00e1 ordenado y sus datos son menores o iguales o mayores o iguales que el argumento. Ejemplos: ( ordenado-menor? arbolb1 50 ) ; \u21d2 #t ( ordenado-menor? arbolb1 40 ) ; \u21d2 #f ( ordenado-menor? arbolb2 50 ) ; \u21d2 #f ( ordenado-mayor? arbolb1 0 ) ; \u21d2 #t ( ordenado-mayor? arbolb1 20 ) ; \u21d2 #f ( ordenado-mayor? arbolb2 0 ) ; \u21d2 #f c) Utilizando las funciones anteriores, define la funci\u00f3n (ordenado? arbolb) que comprueba si un \u00e1rbol binario est\u00e1 ordenado. ( ordenado? arbolb1 ) ; \u21d2 #t ( ordenado? arbolb2 ) ; \u21d2 #f Ejercicio 7 \u00b6 Dado un \u00e1rbol binario y un camino definido como una lista de s\u00edmbolos: '(< > = > > =) en el que: < : indica que nos vamos por la rama izquierda > : indica que nos vamos por la rama derecha = : indica que nos quedamos con el dato de ese nodo. Implementa la funci\u00f3n (camino-b-tree b-tree camino) que devuelva una lista con los datos recogidos por el camino. ( camino-b-tree b-tree ' ( = < < = > = )) ; \u21d2 '(9 3 4) ( camino-b-tree b-tree ' ( > = < < = )) ; \u21d2 '(15 10) Lenguajes y Paradigmas de Programaci\u00f3n, curso 2020-21 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Domingo Gallardo, Cristina Pomares, Antonio Bot\u00eda, Francisco Mart\u00ednez","title":"Pr\u00e1ctica 7: \u00c1rboles"},{"location":"practicas/practica08/practica08.html#practica-7-arboles","text":"","title":"Pr\u00e1ctica 7: \u00c1rboles"},{"location":"practicas/practica08/practica08.html#entrega-de-la-practica","text":"Para entregar la pr\u00e1ctica debes subir a Moodle el fichero practica07.rkt con una cabecera inicial con tu nombre y apellidos, y las soluciones de cada ejercicio separadas por comentarios. Cada soluci\u00f3n debe incluir: La definici\u00f3n de las funciones que resuelven el ejercicio. Un conjunto de pruebas que comprueben su funcionamiento utilizando el API RackUnit .","title":"Entrega de la pr\u00e1ctica"},{"location":"practicas/practica08/practica08.html#ejercicios","text":"Importante Antes de empezar la pr\u00e1ctica debes haber estudiado los apartados de \u00e1rboles gen\u00e9ricos y \u00e1rboles binarios del tema 4 de teor\u00eda. Copia al principio de la pr\u00e1ctica las funciones de las barreras de abstracci\u00f3n de \u00e1rboles y \u00e1rboles binarios y utiliza esas funciones en todos los ejercicios cuando est\u00e9s realizando operaciones sobre \u00e1rboles.","title":"Ejercicios"},{"location":"practicas/practica08/practica08.html#ejercicio-1","text":"a.1) Escribe la sentencia en Scheme que define el siguiente \u00e1rbol gen\u00e9rico y escribe utilizando las funciones de la barrera de abstracci\u00f3n de \u00e1rboles una expresi\u00f3n que devuelva el n\u00famero 10. (define arbol '(------------)) (check-equal? ------------------- 10) a.2) Las funciones que suman los datos de un \u00e1rbol utilizando recursi\u00f3n mutua y que hemos visto en teor\u00eda son las siguientes: ( define ( suma-datos-arbol arbol ) ( + ( dato-arbol arbol ) ( suma-datos-bosque ( hijos-arbol arbol )))) ( define ( suma-datos-bosque bosque ) ( if ( null? bosque ) 0 ( + ( suma-datos-arbol ( car bosque )) ( suma-datos-bosque ( cdr bosque ))))) Si realizamos la siguiente llamada a la funci\u00f3n suma-datos-bosque , siendo arbol el definido en el apartado anterior: ( suma-datos-bosque ( hijos-arbol arbol )) \u00bfQu\u00e9 devuelve la invocaci\u00f3n a (suma-datos-arbol (car bosque)) que se realiza dentro de la funci\u00f3n? \u00bfQu\u00e9 devuelve la primera llamada recursiva a suma-datos-bosque ? Escribe la contestaci\u00f3n a estas preguntas como comentarios en el fichero de la pr\u00e1ctica. a.3) La funci\u00f3n de orden superior que hemos visto en teor\u00eda y que realiza tambi\u00e9n la suma de los datos de un \u00e1rbol es: ( define ( suma-datos-arbol-fos arbol ) ( foldr + ( dato-arbol arbol ) ( map suma-datos-arbol-fos ( hijos-arbol arbol )))) Si realizamos la siguiente llamada a la funci\u00f3n, siendo arbol el definido en el apartado anterior: ( suma-datos-arbol-fos arbol ) \u00bfQu\u00e9 devuelve la invocaci\u00f3n a map dentro de la funci\u00f3n? \u00bfQu\u00e9 invocaciones se realizan a la funci\u00f3n + durante la ejecuci\u00f3n de foldr sobre la lista devuelta por la invocaci\u00f3n a map ? Enum\u00e9ralas en orden, indicando sus par\u00e1metros y el valor devuelto en cada una de ellas. b.1) Escribe la sentencia en Scheme que define el siguiente \u00e1rbol binario y escribe utilizando las funciones de la barrera de abstracci\u00f3n de \u00e1rboles binarios una expresi\u00f3n que devuelva el n\u00famero 29. (define arbolb '(------------------)) (check-equal? ---------------------- 29)","title":"Ejercicio 1"},{"location":"practicas/practica08/practica08.html#ejercicio-2","text":"a) Implementa dos versiones de la funci\u00f3n (to-string-arbol arbol) que recibe un \u00e1rbol de s\u00edmbolos y devuelve la cadena resultante de concatenar todos los s\u00edmbolos en recorrido preorden. Debes implementar una versi\u00f3n con recursi\u00f3n mutua y otra (llamada to-string-arbol-fos ) con una \u00fanica funci\u00f3n en la que se use funciones de orden superior. Ejemplo: ( define arbol2 ' ( a ( b ( c ( d )) ( e )) ( f ))) ( to-string-arbol arbol2 ) ; \u21d2 \"abcdef\" b) Implementa dos versiones de la funci\u00f3n (veces-arbol dato arbol) que recibe un \u00e1rbol y un dato y comprueba el n\u00famero de veces que aparece el dato en el \u00e1rbol. Debes implementar una funci\u00f3n con recursi\u00f3n mutua y otra con funciones de orden superior. ( veces-arbol ' b ' ( a ( b ( c ) ( d )) ( b ( b ) ( f )))) ; \u21d2 3 ( veces-arbol ' g ' ( a ( b ( c ) ( d )) ( b ( b ) ( f )))) ; \u21d2 0","title":"Ejercicio 2"},{"location":"practicas/practica08/practica08.html#ejercicio-3","text":"a) Implementa dos versiones de la funci\u00f3n (hojas-cumplen pred arbol) que recibe un predicado y un \u00e1rbol y devuelve una lista con todas aquellas hojas del \u00e1rbol que cumplen el predicado. Una funci\u00f3n con recursi\u00f3n mutua y otra con funciones de orden superior. Para evitar complicar la funci\u00f3n de orden superior, suponemos que el \u00e1rbol inicial que pasamos como par\u00e1metro no es un \u00e1rbol hoja. ( define arbol1 ' ( 10 ( 2 ) ( 12 ( 4 ) ( 2 )) ( 10 ( 5 )))) ( define arbol2 ' ( 10 ( 2 ) ( 12 ( 4 ) ( 2 )) ( 10 ( 6 )))) ( hojas-cumplen even? arbol1 ) ; \u21d2 '(2 4 2) ( hojas-cumplen even? arbol2 ) ; \u21d2 '(2 4 2 6) b) Implementa dos versiones del predicado (todas-hojas-cumplen? pred arbol) que comprueba si todas las hojas de un \u00e1rbol cumplen un determinado predicado. Una funci\u00f3n con recursi\u00f3n mutua y otra con funciones de orden superior. No debes usar la funci\u00f3n anterior, tienes que hacer un recorrido por todo el \u00e1rbol. Para la funci\u00f3n de orden superior puedes usar la funci\u00f3n for-all? implementada en el tema 2 . ( todas-hojas-cumplen? even? arbol1 ) ; \u21d2 #f ( todas-hojas-cumplen? even? arbol2 ) ; \u21d2 #t","title":"Ejercicio 3"},{"location":"practicas/practica08/practica08.html#ejercicio-4","text":"a) Implementa, utilizando funciones de orden superior, la funci\u00f3n (suma-raices-hijos arbol) que devuelva la suma de las ra\u00edces de los hijos de un \u00e1rbol gen\u00e9rico. Ejemplo: ( define arbol3 ' ( 20 ( 2 ) ( 8 ( 4 ) ( 2 )) ( 9 ( 5 )))) ( suma-raices-hijos arbol3 ) ; \u21d2 19 ( suma-raices-hijos ( cadr ( hijos-arbol arbol3 ))) ; \u21d2 6 b) Implementa dos versiones, una con recursi\u00f3n mutua y otra con funciones de orden superior, de la funci\u00f3n (raices-mayores-arbol? arbol) que recibe un \u00e1rbol y comprueba que su ra\u00edz sea mayor que la suma de las ra\u00edces de los hijos y que todos los hijos (nos referimos a todos los descendientes) cumplen tambi\u00e9n esta propiedad. Ejemplos: ( raices-mayores-arbol? arbol3 ) ; \u21d2 #t ( raices-mayores-arbol? ' ( 20 ( 2 ) ( 8 ( 4 ) ( 5 )) ( 9 ( 5 )))) ; \u21d2 #f c) Define la funci\u00f3n (comprueba-raices-arbol arbol) que recibe un arbol y que devuelve otro arbol en el que los nodos se han sustituido por 1 o 0 seg\u00fan si son mayores que la suma de las ra\u00edces de sus hijos o no. Ejemplos: ( comprueba-raices-arbol arbol3 ) ; \u21d2 (1 (1) (1 (1) (1)) (1 (1))) ( comprueba-raices-arbol ' ( 20 ( 2 ) ( 8 ( 4 ) ( 5 )) ( 9 ( 5 )))) ; \u21d2 (1 (1) (0 (1) (1)) (1 (1)))","title":"Ejercicio 4"},{"location":"practicas/practica08/practica08.html#ejercicio-5","text":"a) Define la funci\u00f3n (es-camino? lista arbol) que debe comprobar si la secuencia de elementos de la lista se corresponde con un camino del \u00e1rbol que empieza en la ra\u00edz y que termina exactamente en una hoja. Suponemos que lista contiene al menos un elemento Por ejemplo, la lista (a b a) s\u00ed que es camino en el siguiente \u00e1rbol, pero la lista (a b) no. Ejemplos: suponiendo que arbol es el \u00e1rbol definido por la figura anterior: ( es-camino? ' ( a b a ) arbol ) ; \u21d2 #t ( es-camino? ' ( a b ) arbol ) ; \u21d2 #f ( es-camino? ' ( a b a b ) arbol ) ; \u21d2 #f b) Escribe la funci\u00f3n (nodos-nivel nivel arbol) que reciba un nivel y un \u00e1rbol gen\u00e9rico y devuelva una lista con todos los nodos que se encuentran en ese nivel. Ejemplos, suponiendo que arbol es el \u00e1rbol definido por la figura anterior: ( nodos-nivel 0 arbol ) ; \u21d2 '(1) ( nodos-nivel 1 arbol ) ; \u21d2 '(2 6) ( nodos-nivel 2 arbol ) ; \u21d2 '(3 5 7) ( nodos-nivel 3 arbol ) ; \u21d2 '(4 2)","title":"Ejercicio 5"},{"location":"practicas/practica08/practica08.html#ejercicio-6","text":"a) Define la funci\u00f3n (ordenado-entre? arbolb min max) que comprueba si un \u00e1rbol binario est\u00e1 ordenado y sus datos est\u00e1 entre min y max . Un \u00e1rbol binario est\u00e1 ordenado cuando sus hijos izquierdos y derecho est\u00e1n ordenados y cuando la ra\u00edz es mayor o igual que todos los n\u00fameros del hijo izquierdo y menor o igual que todos los n\u00fameros del hijo derecho. Por ejemplo, en la siguiente figura, el \u00e1rbol binario de la izquierda ( arbolb1 ) est\u00e1 ordenado, pero el de la derecha ( arbolb2 ) no lo est\u00e1. Ejemplo: ( define arbolb1 ' ( 20 ( 13 ( 2 () ()) ( 18 () ())) ( 40 ( 25 () () ) ( 43 () ())))) ( define arbolb2 ' ( 20 ( 13 ( 2 () ()) ( 22 () ())) ( 40 ( 25 () () ) ( 43 () ())))) ( ordenado-entre? arbolb1 0 50 ) ; \u21d2 #t ( ordenado-entre? arbolb2 0 50 ) ; \u21d2 #f ( ordenado-entre? arbolb1 0 30 ) ; \u21d2 #f b) Utilizando la funci\u00f3n anterior, define las funciones (ordenado-menor? arbolb max) y (ordenado-mayor? arbolb min) que comprueban si un \u00e1rbol binario est\u00e1 ordenado y sus datos son menores o iguales o mayores o iguales que el argumento. Ejemplos: ( ordenado-menor? arbolb1 50 ) ; \u21d2 #t ( ordenado-menor? arbolb1 40 ) ; \u21d2 #f ( ordenado-menor? arbolb2 50 ) ; \u21d2 #f ( ordenado-mayor? arbolb1 0 ) ; \u21d2 #t ( ordenado-mayor? arbolb1 20 ) ; \u21d2 #f ( ordenado-mayor? arbolb2 0 ) ; \u21d2 #f c) Utilizando las funciones anteriores, define la funci\u00f3n (ordenado? arbolb) que comprueba si un \u00e1rbol binario est\u00e1 ordenado. ( ordenado? arbolb1 ) ; \u21d2 #t ( ordenado? arbolb2 ) ; \u21d2 #f","title":"Ejercicio 6"},{"location":"practicas/practica08/practica08.html#ejercicio-7","text":"Dado un \u00e1rbol binario y un camino definido como una lista de s\u00edmbolos: '(< > = > > =) en el que: < : indica que nos vamos por la rama izquierda > : indica que nos vamos por la rama derecha = : indica que nos quedamos con el dato de ese nodo. Implementa la funci\u00f3n (camino-b-tree b-tree camino) que devuelva una lista con los datos recogidos por el camino. ( camino-b-tree b-tree ' ( = < < = > = )) ; \u21d2 '(9 3 4) ( camino-b-tree b-tree ' ( > = < < = )) ; \u21d2 '(15 10) Lenguajes y Paradigmas de Programaci\u00f3n, curso 2020-21 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Domingo Gallardo, Cristina Pomares, Antonio Bot\u00eda, Francisco Mart\u00ednez","title":"Ejercicio 7"},{"location":"practicas/practica09/practica09.html","text":"Pr\u00e1ctica 8: Seminario de Swift \u00b6 Entrega de la pr\u00e1ctica \u00b6 Para entregar la pr\u00e1ctica debes subir a Moodle el fichero practica08.swift con una cabecera inicial con tu nombre y apellidos. Ejercicios \u00b6 El ejercicio de esta pr\u00e1ctica consistir\u00e1 en leer y probar el seminario de Swift , hasta el apartado Funciones y clausuras (incluido). Para instalar el comando swift en tu ordenador sigue las instrucciones del seminario. Dependiendo de tu sistema operativo debes realizar una instalaci\u00f3n distinta: Windows, linux y Mac sin Xcode : Sigue los pasos indicados en Ejecuci\u00f3n en una m\u00e1quina Docker . Mac con Xcode : Sigue los pasos indicados en Ejecuci\u00f3n con MacOS . En linux y Windows hay la posibilidad de realizar una instalaci\u00f3n nativa, pero no la hemos probado. Puedes hacerlo t\u00fa siguiendo los pasos indicados en la web swift.org . Tal y como se indica en el seminario, puedes ejecutar tambi\u00e9n programas Swift usando el entorno on-line http://online.swiftplayground.run . Pero debes tener en cuenta que esta opci\u00f3n tiene algunos problemas: se requiere conexi\u00f3n a Internet, el editor es muy limitado y es posible que en alguna ocasi\u00f3n el servidor est\u00e9 ca\u00eddo. Crea el fichero practica08.swift con una instrucci\u00f3n Hola mundo que imprima esa cadena. Ejec\u00fatalo en el entorno que hayas instalado y comprueba que todo funciona correctamente: $ swift practica08.swift Hola, mundo 4. Lee el seminario, copiando y modificando (siempre que sea posible) el c\u00f3digo de los ejemplos en el fichero practica08.swift . Lee bien el apartado correspondiente antes de probar cada ejemplo. Es conveniente que copies el c\u00f3digo sin hacer copy-paste , para que te acostumbres a la sintaxis del nuevo lenguaje. Incluye en la pr\u00e1ctica todos los experimentos indicados, hasta el Experimento 9 . Antes de cada experimento pon un comentario indicando el experimento. Lenguajes y Paradigmas de Programaci\u00f3n, curso 2020-21 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Domingo Gallardo, Cristina Pomares, Antonio Bot\u00eda, Francisco Mart\u00ednez","title":"Pr\u00e1ctica 8: Seminario de Swift"},{"location":"practicas/practica09/practica09.html#practica-8-seminario-de-swift","text":"","title":"Pr\u00e1ctica 8: Seminario de Swift"},{"location":"practicas/practica09/practica09.html#entrega-de-la-practica","text":"Para entregar la pr\u00e1ctica debes subir a Moodle el fichero practica08.swift con una cabecera inicial con tu nombre y apellidos.","title":"Entrega de la pr\u00e1ctica"},{"location":"practicas/practica09/practica09.html#ejercicios","text":"El ejercicio de esta pr\u00e1ctica consistir\u00e1 en leer y probar el seminario de Swift , hasta el apartado Funciones y clausuras (incluido). Para instalar el comando swift en tu ordenador sigue las instrucciones del seminario. Dependiendo de tu sistema operativo debes realizar una instalaci\u00f3n distinta: Windows, linux y Mac sin Xcode : Sigue los pasos indicados en Ejecuci\u00f3n en una m\u00e1quina Docker . Mac con Xcode : Sigue los pasos indicados en Ejecuci\u00f3n con MacOS . En linux y Windows hay la posibilidad de realizar una instalaci\u00f3n nativa, pero no la hemos probado. Puedes hacerlo t\u00fa siguiendo los pasos indicados en la web swift.org . Tal y como se indica en el seminario, puedes ejecutar tambi\u00e9n programas Swift usando el entorno on-line http://online.swiftplayground.run . Pero debes tener en cuenta que esta opci\u00f3n tiene algunos problemas: se requiere conexi\u00f3n a Internet, el editor es muy limitado y es posible que en alguna ocasi\u00f3n el servidor est\u00e9 ca\u00eddo. Crea el fichero practica08.swift con una instrucci\u00f3n Hola mundo que imprima esa cadena. Ejec\u00fatalo en el entorno que hayas instalado y comprueba que todo funciona correctamente: $ swift practica08.swift Hola, mundo 4. Lee el seminario, copiando y modificando (siempre que sea posible) el c\u00f3digo de los ejemplos en el fichero practica08.swift . Lee bien el apartado correspondiente antes de probar cada ejemplo. Es conveniente que copies el c\u00f3digo sin hacer copy-paste , para que te acostumbres a la sintaxis del nuevo lenguaje. Incluye en la pr\u00e1ctica todos los experimentos indicados, hasta el Experimento 9 . Antes de cada experimento pon un comentario indicando el experimento. Lenguajes y Paradigmas de Programaci\u00f3n, curso 2020-21 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Domingo Gallardo, Cristina Pomares, Antonio Bot\u00eda, Francisco Mart\u00ednez","title":"Ejercicios"},{"location":"practicas/practica10/practica10.html","text":"Pr\u00e1ctica 9: Programaci\u00f3n funcional en Swift (1) \u00b6 Entrega de la pr\u00e1ctica \u00b6 Para entregar la pr\u00e1ctica debes subir a Moodle el fichero practica09.swift con una cabecera inicial con tu nombre y apellidos, y las soluciones de cada ejercicio separadas por comentarios. Cada soluci\u00f3n debe incluir: La definici\u00f3n de las funciones que resuelven el ejercicio. Una visualizaci\u00f3n por pantalla con ejemplos distintos de los presentados en el enunciado que demuestren qu\u00e9 hace la funci\u00f3n . Importante Los ejemplos que muestres en pantalla deben ser distintos de los incluidos en el enunciado. Ejercicios \u00b6 Ejercicio 1 \u00b6 a) Implementa en Swift la funci\u00f3n recursiva prefijos(prefijo:palabras:) que recibe una cadena y un array de palabras. Devuelve un array de Bool con los booleanos resultantes de comprobar si la cadena es prefijo de cada una de las palabras de la lista. Ejemplo: let array = [ \"anterior\" , \"ant\u00edgona\" , \"antena\" ] let prefijo = \"ante\" print ( \" \\n ****** \\n 1a) Funci\u00f3n prefijos(prefijo:palabras:) \\n ******\" ) print ( prefijos ( prefijo : prefijo , palabras : array )) // Imprime: [true, false, true] b) Implementa en Swift la funci\u00f3n recursiva parejaMayorParImpar(numeros:) que recibe un array de enteros positivos y devuelve una pareja con dos enteros: el primero es el mayor n\u00famero impar y el segundo el mayor n\u00famero par. Si no hay ning\u00fan n\u00famero par o impar se devolver\u00e1 un 0. let numeros = [ 10 , 201 , 12 , 103 , 204 , 2 ] print ( \" \\n ****** \\n 1b) Funci\u00f3n parejaMayorParImpar(numeros:) \\n ******\" ) print ( parejaMayorParImpar ( numeros : numeros )) // Imprime: (201, 204) Ejercicio 2 \u00b6 a) Implementa en Swift la funci\u00f3n recursiva compruebaParejas(_:funcion:) con el siguiente perfil: ([Int], (Int) -> Int) -> [(Int, Int)] La funci\u00f3n recibe dos par\u00e1metros: un Array de enteros y una funci\u00f3n que recibe un entero y devuelve un entero. La funci\u00f3n devolver\u00e1 un array de tuplas que contiene las tuplas formadas por aquellos n\u00fameros contiguos del primer array que cumplan que el n\u00famero es el resultado de aplicar la funci\u00f3n al n\u00famero situado en la posici\u00f3n anterior. Ejemplo: func cuadrado ( x : Int ) -> Int { return x * x } print ( compruebaParejas ([ 2 , 4 , 16 , 5 , 10 , 100 , 105 ], funcion : cuadrado )) // Imprime [(2,4), (4,16), (10,100)] b) Implementa en Swift la funci\u00f3n recursiva coinciden(parejas: [(Int,Int)], funcion: (Int)->Int) que devuelve un array de booleanos que indica si el resultado de aplicar la funci\u00f3n al primer n\u00famero de cada pareja coincide con el segundo. let array = [( 2 , 4 ), ( 4 , 14 ), ( 4 , 16 ), ( 5 , 25 ), ( 10 , 100 )] func cuadrado ( x : Int ) -> Int { return x * x } print ( coinciden ( parejas : array , funcion : cuadrado ) \") // Imprime: [true, false, true, true, true] Ejercicio 3 \u00b6 Supongamos que estamos escribiendo un programa que debe tratar movimientos de cuentas bancarias. Define un enumerado Movimiento con valores asociados con el que podamos representar: Dep\u00f3sito (valor asociado: (Double) ) Cargo de un recibo (valor asociado: (String, Double) ) Cajero (valor asociado: (Double) ) Y define la funci\u00f3n aplica(movimientos:[Movimiento]) que reciba un array de movimientos y devuelva una pareja con el dinero resultante de acumular todos los movimientos y un array de Strings con todos los cargos realizados. Ejemplo: let movimientos : [ Movimiento ] = [. deposito ( 830.0 ), . cargoRecibo ( \"Gimnasio\" , 45.0 ), . deposito ( 400.0 ), . cajero ( 100.0 ), . cargoRecibo ( \"Fnac\" , 38.70 )] print ( aplica ( movimientos : movimientos )) //Imprime (1046.3, [\"Gimnasio\", \"Fnac\"]) Ejercicio 4 \u00b6 Implementa en Swift un tipo enumerado recursivo que permita construir \u00e1rboles binarios de enteros. El enumerado debe tener un caso en el que guardar tres valores: un Int y dos \u00e1rboles binarios (el hijo izquierdo y el hijo derecho) otro caso constante: un \u00e1rbol binario vac\u00edo Llamaremos al tipo ArbolBinario y a los casos nodo y vacio . Implem\u00e9ntalo de forma que el siguiente ejemplo funcione correctamente: let arbol : ArbolBinario = . nodo ( 8 , . nodo ( 2 , . vacio , . vacio ), . nodo ( 12 , . vacio , . vacio )) Implementa tambi\u00e9n la funci\u00f3n suma(arbolb:) que reciba una instancia de \u00e1rbol binario y devuelva la suma de todos sus nodos: print ( suma ( arbolb : arbol )) // Imprime: 22 Ejercicio 5 \u00b6 Implementa en Swift un tipo enumerado recursivo que permita construir \u00e1rboles de enteros usando el mismo enfoque que en Scheme: un nodo est\u00e1 formado por un dato (un Int ) y una colecci\u00f3n de \u00e1rboles hijos. Llamaremos al tipo Arbol . Implem\u00e9ntalo de forma que el siguiente ejemplo funcione correctamente: /* Definimos el \u00e1rbol 10 / | \\ 3 5 8 | 1 */ let arbol1 = Arbol . nodo ( 1 , []) let arbol3 = Arbol . nodo ( 3 , [ arbol1 ]) let arbol5 = Arbol . nodo ( 5 , []) let arbol8 = Arbol . nodo ( 8 , []) let arbol10 = Arbol . nodo ( 10 , [ arbol3 , arbol5 , arbol8 ]) Implementa tambi\u00e9n la funci\u00f3n suma(arbol:cumplen:) que reciba una instancia de \u00e1rbol y una funci\u00f3n (Int) -> Bool que comprueba una condici\u00f3n sobre el nodo. La funci\u00f3n debe devolver la suma de todos los nodos del \u00e1rbol que cumplan la condici\u00f3n. Implementa la funci\u00f3n usando la misma estrategia que ya utilizamos en Scheme de definir una funci\u00f3n auxiliar suma(bosque:cumplen:) y una recursi\u00f3n mutua. func esPar ( x : Int ) -> Bool { return x % 2 == 0 } print ( \"La suma del \u00e1rbol es: \\( suma ( arbol : arbol10 , cumplen : esPar )) \" ) // Imprime: La suma del \u00e1rbol gen\u00e9rico es: 18 Lenguajes y Paradigmas de Programaci\u00f3n, curso 2020-21 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Domingo Gallardo, Cristina Pomares, Antonio Bot\u00eda, Francisco Mart\u00ednez","title":"Pr\u00e1ctica 9: Programaci\u00f3n funcional en Swift (1)"},{"location":"practicas/practica10/practica10.html#practica-9-programacion-funcional-en-swift-1","text":"","title":"Pr\u00e1ctica 9: Programaci\u00f3n funcional en Swift (1)"},{"location":"practicas/practica10/practica10.html#entrega-de-la-practica","text":"Para entregar la pr\u00e1ctica debes subir a Moodle el fichero practica09.swift con una cabecera inicial con tu nombre y apellidos, y las soluciones de cada ejercicio separadas por comentarios. Cada soluci\u00f3n debe incluir: La definici\u00f3n de las funciones que resuelven el ejercicio. Una visualizaci\u00f3n por pantalla con ejemplos distintos de los presentados en el enunciado que demuestren qu\u00e9 hace la funci\u00f3n . Importante Los ejemplos que muestres en pantalla deben ser distintos de los incluidos en el enunciado.","title":"Entrega de la pr\u00e1ctica"},{"location":"practicas/practica10/practica10.html#ejercicios","text":"","title":"Ejercicios"},{"location":"practicas/practica10/practica10.html#ejercicio-1","text":"a) Implementa en Swift la funci\u00f3n recursiva prefijos(prefijo:palabras:) que recibe una cadena y un array de palabras. Devuelve un array de Bool con los booleanos resultantes de comprobar si la cadena es prefijo de cada una de las palabras de la lista. Ejemplo: let array = [ \"anterior\" , \"ant\u00edgona\" , \"antena\" ] let prefijo = \"ante\" print ( \" \\n ****** \\n 1a) Funci\u00f3n prefijos(prefijo:palabras:) \\n ******\" ) print ( prefijos ( prefijo : prefijo , palabras : array )) // Imprime: [true, false, true] b) Implementa en Swift la funci\u00f3n recursiva parejaMayorParImpar(numeros:) que recibe un array de enteros positivos y devuelve una pareja con dos enteros: el primero es el mayor n\u00famero impar y el segundo el mayor n\u00famero par. Si no hay ning\u00fan n\u00famero par o impar se devolver\u00e1 un 0. let numeros = [ 10 , 201 , 12 , 103 , 204 , 2 ] print ( \" \\n ****** \\n 1b) Funci\u00f3n parejaMayorParImpar(numeros:) \\n ******\" ) print ( parejaMayorParImpar ( numeros : numeros )) // Imprime: (201, 204)","title":"Ejercicio 1"},{"location":"practicas/practica10/practica10.html#ejercicio-2","text":"a) Implementa en Swift la funci\u00f3n recursiva compruebaParejas(_:funcion:) con el siguiente perfil: ([Int], (Int) -> Int) -> [(Int, Int)] La funci\u00f3n recibe dos par\u00e1metros: un Array de enteros y una funci\u00f3n que recibe un entero y devuelve un entero. La funci\u00f3n devolver\u00e1 un array de tuplas que contiene las tuplas formadas por aquellos n\u00fameros contiguos del primer array que cumplan que el n\u00famero es el resultado de aplicar la funci\u00f3n al n\u00famero situado en la posici\u00f3n anterior. Ejemplo: func cuadrado ( x : Int ) -> Int { return x * x } print ( compruebaParejas ([ 2 , 4 , 16 , 5 , 10 , 100 , 105 ], funcion : cuadrado )) // Imprime [(2,4), (4,16), (10,100)] b) Implementa en Swift la funci\u00f3n recursiva coinciden(parejas: [(Int,Int)], funcion: (Int)->Int) que devuelve un array de booleanos que indica si el resultado de aplicar la funci\u00f3n al primer n\u00famero de cada pareja coincide con el segundo. let array = [( 2 , 4 ), ( 4 , 14 ), ( 4 , 16 ), ( 5 , 25 ), ( 10 , 100 )] func cuadrado ( x : Int ) -> Int { return x * x } print ( coinciden ( parejas : array , funcion : cuadrado ) \") // Imprime: [true, false, true, true, true]","title":"Ejercicio 2"},{"location":"practicas/practica10/practica10.html#ejercicio-3","text":"Supongamos que estamos escribiendo un programa que debe tratar movimientos de cuentas bancarias. Define un enumerado Movimiento con valores asociados con el que podamos representar: Dep\u00f3sito (valor asociado: (Double) ) Cargo de un recibo (valor asociado: (String, Double) ) Cajero (valor asociado: (Double) ) Y define la funci\u00f3n aplica(movimientos:[Movimiento]) que reciba un array de movimientos y devuelva una pareja con el dinero resultante de acumular todos los movimientos y un array de Strings con todos los cargos realizados. Ejemplo: let movimientos : [ Movimiento ] = [. deposito ( 830.0 ), . cargoRecibo ( \"Gimnasio\" , 45.0 ), . deposito ( 400.0 ), . cajero ( 100.0 ), . cargoRecibo ( \"Fnac\" , 38.70 )] print ( aplica ( movimientos : movimientos )) //Imprime (1046.3, [\"Gimnasio\", \"Fnac\"])","title":"Ejercicio 3"},{"location":"practicas/practica10/practica10.html#ejercicio-4","text":"Implementa en Swift un tipo enumerado recursivo que permita construir \u00e1rboles binarios de enteros. El enumerado debe tener un caso en el que guardar tres valores: un Int y dos \u00e1rboles binarios (el hijo izquierdo y el hijo derecho) otro caso constante: un \u00e1rbol binario vac\u00edo Llamaremos al tipo ArbolBinario y a los casos nodo y vacio . Implem\u00e9ntalo de forma que el siguiente ejemplo funcione correctamente: let arbol : ArbolBinario = . nodo ( 8 , . nodo ( 2 , . vacio , . vacio ), . nodo ( 12 , . vacio , . vacio )) Implementa tambi\u00e9n la funci\u00f3n suma(arbolb:) que reciba una instancia de \u00e1rbol binario y devuelva la suma de todos sus nodos: print ( suma ( arbolb : arbol )) // Imprime: 22","title":"Ejercicio 4"},{"location":"practicas/practica10/practica10.html#ejercicio-5","text":"Implementa en Swift un tipo enumerado recursivo que permita construir \u00e1rboles de enteros usando el mismo enfoque que en Scheme: un nodo est\u00e1 formado por un dato (un Int ) y una colecci\u00f3n de \u00e1rboles hijos. Llamaremos al tipo Arbol . Implem\u00e9ntalo de forma que el siguiente ejemplo funcione correctamente: /* Definimos el \u00e1rbol 10 / | \\ 3 5 8 | 1 */ let arbol1 = Arbol . nodo ( 1 , []) let arbol3 = Arbol . nodo ( 3 , [ arbol1 ]) let arbol5 = Arbol . nodo ( 5 , []) let arbol8 = Arbol . nodo ( 8 , []) let arbol10 = Arbol . nodo ( 10 , [ arbol3 , arbol5 , arbol8 ]) Implementa tambi\u00e9n la funci\u00f3n suma(arbol:cumplen:) que reciba una instancia de \u00e1rbol y una funci\u00f3n (Int) -> Bool que comprueba una condici\u00f3n sobre el nodo. La funci\u00f3n debe devolver la suma de todos los nodos del \u00e1rbol que cumplan la condici\u00f3n. Implementa la funci\u00f3n usando la misma estrategia que ya utilizamos en Scheme de definir una funci\u00f3n auxiliar suma(bosque:cumplen:) y una recursi\u00f3n mutua. func esPar ( x : Int ) -> Bool { return x % 2 == 0 } print ( \"La suma del \u00e1rbol es: \\( suma ( arbol : arbol10 , cumplen : esPar )) \" ) // Imprime: La suma del \u00e1rbol gen\u00e9rico es: 18 Lenguajes y Paradigmas de Programaci\u00f3n, curso 2020-21 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Domingo Gallardo, Cristina Pomares, Antonio Bot\u00eda, Francisco Mart\u00ednez","title":"Ejercicio 5"},{"location":"practicas/practica11/practica11.html","text":"Pr\u00e1ctica 10: Programaci\u00f3n funcional en Swift (2): clausuras y funciones de orden superior \u00b6 Entrega de la pr\u00e1ctica \u00b6 Para entregar la pr\u00e1ctica debes subir a Moodle el fichero practica10.swift con una cabecera inicial con tu nombre y apellidos, y las soluciones de cada ejercicio separadas por comentarios. Cada soluci\u00f3n debe incluir: La definici\u00f3n de las funciones que resuelven el ejercicio. Una visualizaci\u00f3n por pantalla con ejemplos distintos de los presentados en el enunciado que demuestren qu\u00e9 hace la funci\u00f3n . Importante Los ejemplos que muestres en pantalla deben ser distintos de los incluidos en el enunciado. Ejercicios \u00b6 Ejercicio 1 \u00b6 a) Define la funci\u00f3n maxOpt(_ x: Int?, _ y: Int?) -> Int? que devuelve el m\u00e1ximo de dos enteros opcionales. En el caso en que ambos sean nil se devolver\u00e1 nil . En el caso en que uno sea nil y el otro no se devolver\u00e1 el entero que no es nil . En el caso en que ning\u00fan par\u00e1metro sea nil se devolver\u00e1 el mayor. Ejemplo: let res1 = maxOpt ( nil , nil ) let res2 = maxOpt ( 10 , nil ) let res3 = maxOpt ( - 10 , 30 ) print ( \"res1 = \\( String ( describing : res1 )) \" ) print ( \"res2 = \\( String ( describing : res2 )) \" ) print ( \"res3 = \\( String ( describing : res3 )) \" ) // Imprime: // res1 = nil // res2 = Optional(10) // res3 = Optional(30) b1) Escribe una nueva versi\u00f3n del ejercicio 1b) de la pr\u00e1ctica 9 que permita recibir n\u00fameros negativos y que devuelva una pareja de (Int?, Int?) con nil en la parte izquierda y/o derecha si no hay n\u00famero impares o pares. Ejemplo: let numeros = [ - 10 , 202 , 12 , 100 , 204 , 2 ] print ( \" \\n ****** \\n 1b1) Funci\u00f3n parejaMayorParImpar2(numeros:) \\n ******\" ) print ( parejaMayorParImpar2 ( numeros : numeros )) // Imprime: // parejaMayorParImpar2(numeros: [-10, 202, 12, 100, 204, 2]) // (nil, Optional(204)) b2) Escribe la funci\u00f3n sumaMaxParesImpares(numeros: [Int]) -> Int que llama a la funci\u00f3n anterior y devuelve la suma del m\u00e1ximo de los pares y el m\u00e1ximo de los impares. En el caso en que se pase un array vac\u00edo deber\u00e1 devolver un 0. print ( \"sumaMaxParesImpares(numeros: \\( numeros2 ) )\" ) print ( sumaMaxParesImpares ( numeros : numeros2 )) // Imprime: // sumaMaxParesImpares(numeros: [-10, 202, 12, 100, 204, 2]) // 204 b3) Escribe una nueva versi\u00f3n de la funci\u00f3n del ejercicio b1) en la que se devuelva nil en el caso en que se le pase como par\u00e1metro un array vac\u00edo. \u00bfC\u00f3mo se deber\u00eda cambiar la declaraci\u00f3n de la funci\u00f3n? Escribe tambi\u00e9n una nueva versi\u00f3n de la funci\u00f3n del ejercicio b2) en la que se llame a la funci\u00f3n anterior. Ejercicio 2 \u00b6 a) Indica qu\u00e9 devuelven las siguientes expresiones: a.1) let nums = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] nums . filter { $0 % 3 == 0 }. count a.2) let nums2 = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] nums2 . map { $0 + 100 }. filter { $0 % 5 == 0 }. reduce ( 0 , + ) a.3) let cadenas = [ \"En\" , \"un\" , \"lugar\" , \"de\" , \"La\" , \"Mancha\" ] cadenas . sorted { $0 . count < $1 . count }. map { $0 . count } a.4) let cadenas2 = [ \"En\" , \"un\" , \"lugar\" , \"de\" , \"La\" , \"Mancha\" ] cadenas2 . reduce ([]) { ( res : [( String , Int )], c : String ) -> [( String , Int )] in res + [( c , c . count )]}. sorted ( by : { $0 . 1 < $1 . 1 }) b) Explica qu\u00e9 hacen las siguientes funciones y pon un ejemplo de su funcionamiento: b.1) func f ( nums : [ Int ], n : Int ) -> Int { return nums . filter { $0 == n }. count } b.2) func g ( nums : [ Int ]) -> [ Int ] { return nums . reduce ([], { ( res : [ Int ], n : Int ) -> [ Int ] in if ! res . contains ( n ) { return res + [ n ] } else { return res } }) } b.3) func h ( nums : [ Int ], n : Int ) -> ([ Int ], [ Int ]) { return nums . reduce (([],[]), { ( res : ([ Int ],[ Int ]), num : Int ) -> ([ Int ],[ Int ]) in if ( num >= n ) { return ( res . 0 , res . 1 + [ num ]) } else { return (( res . 0 + [ num ], res . 1 )) } }) } c) Implementa las siguientes funciones con funciones de orden superior. c.1) Funci\u00f3n suma(palabras:contienen:) : suma ( palabras : [ String ], contienen : Character ) -> Int que recibe una array de cadenas y devuelve la suma de las longitudes de las cadenas que contiene el car\u00e1cter que se pasa como par\u00e1metro. c.2) Funci\u00f3n sumaMenoresMayores(nums:pivote:) : sumaMenoresMayores ( nums : [ Int ], pivote : Int ) -> ( Int , Int ) que recibe un array de n\u00fameros y un n\u00famero pivote y devuelve una tupla con la suma de los n\u00fameros menores y mayores o iguales que el pivote. d) (Ejercicio sobre variables capturadas por clausuras) Reflexiona sobre el siguiente c\u00f3digo y completa el hueco para obtener el resultado esperado. func bar ( f : ( Int ) -> Int ) { print ( f ( __________ )) } func foo () -> ( Int ) -> Int { var x = 3 return { x += $0 + 2 return x } } var x = 5 let g = foo () bar ( f : g ) // => 9 bar ( f : g ) // => 15 Ejercicio 3 \u00b6 Define un tipo enumerado con un \u00e1rbol gen\u00e9rico, tal y como hicimos en el \u00faltimo ejercicio de la pr\u00e1ctica anterior, que tenga como gen\u00e9rico el tipo de dato que contiene. En el siguiente ejemplo vemos c\u00f3mo deber\u00eda poderse definir con el mismo tipo gen\u00e9rico un \u00e1rbol de enteros y un \u00e1rbol de cadenas: let arbolInt : Arbol = . nodo ( 53 , [. nodo ( 13 , []), . nodo ( 32 , []), . nodo ( 41 , [. nodo ( 36 , []), . nodo ( 39 , []) ]) ]) let arbolString : Arbol = . nodo ( \"Zamora\" , [. nodo ( \"Buend\u00eda\" , [. nodo ( \"Albeza\" , []), . nodo ( \"Berenguer\" , []), . nodo ( \"Bolardo\" , []) ]), . nodo ( \"Galv\u00e1n\" , []) ]) Define las funciones gen\u00e9ricas toArray y toArrayFOS que devuelvan un array con todos los componentes del \u00e1rbol usando un recorrido preorden (primero la ra\u00edz y despu\u00e9s los hijos). La primera la debes implementar con recursi\u00f3n mutua y la segunda usando funciones de orden superior. Ejemplo: print ( toArray ( arbol : arbolInt )) // Imprime: [53, 13, 32, 41, 36, 39] print ( toArrayFOS ( arbol : arbolString )) // Imprime: [\"Zamora\", \"Buend\u00eda\", \"Albeza\", \"Berenguer\", \"Bolardo\", \"Galv\u00e1n\"] Ejercicio 4 \u00b6 Implementa en Swift la funci\u00f3n imprimirListadosNotas(alumnos:) que recibe un array de tuplas, en donde cada tupla contiene informaci\u00f3n de la evaluaci\u00f3n de un alumno de LPP (nombreAlumno, notaParcial1, notaParcial2, notaParcial3, a\u00f1osMatriculacion) y que debe imprimir por pantalla los siguientes listados: listado 1: array ordenado por nombre del alumno (orden alfab\u00e9tico creciente) listado 2: array ordenado por la nota del parcial 1 (orden decreciente de nota) listado 3: array ordenado por la nota del parcial 2 (orden creciente de nota) listado 4: array ordenado por a\u00f1o de matriculaci\u00f3n y nota del parcial 3 (orden decreciente de a\u00f1o y nota) listado 5: array ordenado por nota final (media de los tres parciales, ponderados en: 0,34, 0,33, 0,33) (orden decreciente de nota final) Las ordenaciones hay que realizarlas usando la funci\u00f3n sorted . Nota Para que los listados se muestren formateados con espacios, puedes usar la siguiente funci\u00f3n (para ello tambi\u00e9n debes incluir el import que se indica) import Foundation func imprimirListadoAlumnos ( _ alumnos : [( String , Double , Double , Double , Int )]) { print ( \"Alumno Parcial1 Parcial2 Parcial3 A\u00f1os\" ) for alu in alumnos { alu . 0. withCString { print ( String ( format : \"%-10s %5.2f %5.2f %5.2f %3d\" , $0 , alu . 1 , alu . 2 , alu . 3 , alu . 4 )) } } } Ejemplo: let listaAlumnos = [( \"Pepe\" , 8.45 , 3.75 , 6.05 , 1 ), ( \"Maria\" , 9.1 , 7.5 , 8.18 , 1 ), ( \"Jose\" , 8.0 , 6.65 , 7.96 , 1 ), ( \"Carmen\" , 6.25 , 1.2 , 5.41 , 2 ), ( \"Felipe\" , 5.65 , 0.25 , 3.16 , 3 ), ( \"Carla\" , 6.25 , 1.25 , 4.23 , 2 ), ( \"Luis\" , 6.75 , 0.25 , 4.63 , 2 ), ( \"Loli\" , 3.0 , 1.25 , 2.19 , 3 )] imprimirListadosNotas ( listaAlumnos ) Algunos de los listados que se deben mostrar ser\u00edan los siguientes: LISTADO ORIGINAL Alumno Parcial1 Parcial2 Parcial3 A\u00f1os Pepe 8.45 3.75 6.05 1 Maria 9.10 7.50 8.18 1 Jose 8.00 6.65 7.96 1 Carmen 6.25 1.20 5.41 2 Felipe 5.65 0.25 3.16 3 Carla 6.25 1.25 4.23 2 Luis 6.75 0.25 4.63 2 Loli 3.00 1.25 2.19 3 LISTADO ORDENADO por Parcial1 (decreciente) Alumno Parcial1 Parcial2 Parcial3 A\u00f1os Loli 3.00 1.25 2.19 3 Felipe 5.65 0.25 3.16 3 Carmen 6.25 1.20 5.41 2 Carla 6.25 1.25 4.23 2 Luis 6.75 0.25 4.63 2 Jose 8.00 6.65 7.96 1 Pepe 8.45 3.75 6.05 1 Maria 9.10 7.50 8.18 1 Ejercicio 5 \u00b6 Dado el array listaAlumnos del ejercicio anterior, utiliza funciones de orden superior para obtener los datos requeridos en cada caso. A) N\u00famero de alumnos que han aprobado primer parcial y suspendido el segundo print ( listaAlumnos . ________________________________ ) // Resultado: 5 B) Alumnos que han aprobado la asignatura (tienen una nota final >= 5) print ( listaAlumnos . _______________________________ ) // Resultado: [\"Pepe\", \"Maria\", \"Jose\"] C) Nota media de todos los alumnos en forma de tupla (media_p1, media_p2, media_p3) var tupla = listaAlumnos . _____________________________________ ) tupla = ( tupla . 0 / Double ( listaAlumnos . count ), tupla . 1 / Double ( listaAlumnos . count ), tupla . 2 / Double ( listaAlumnos . count )) print ( tupla ) // Resultado: (6.6812499999999995, 2.7624999999999997, 5.2262500000000003) Ejercicio 6 \u00b6 Implementa la funci\u00f3n construye con el siguiente perfil: func construye ( operador : Character ) -> ( Int , Int ) -> Int La funci\u00f3n recibe un operador que puede ser uno de los siguientes caracteres: + , - , * , / y debe devolver una clausura que reciba dos argumentos y realice la operaci\u00f3n indicada sobre ellos. Ejemplo: var f = construye ( operador : \"+\" ) print ( f ( 2 , 3 )) // Imprime 5 f = construye ( operador : \"-\" ) print ( f ( 2 , 3 )) // Imprime -1 Lenguajes y Paradigmas de Programaci\u00f3n, curso 2020-21 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Domingo Gallardo, Cristina Pomares, Antonio Bot\u00eda, Francisco Mart\u00ednez","title":"Pr\u00e1ctica 10: Programaci\u00f3n funcional en Swift (2): clausuras y funciones de orden superior"},{"location":"practicas/practica11/practica11.html#practica-10-programacion-funcional-en-swift-2-clausuras-y-funciones-de-orden-superior","text":"","title":"Pr\u00e1ctica 10: Programaci\u00f3n funcional en Swift (2): clausuras y funciones de orden superior"},{"location":"practicas/practica11/practica11.html#entrega-de-la-practica","text":"Para entregar la pr\u00e1ctica debes subir a Moodle el fichero practica10.swift con una cabecera inicial con tu nombre y apellidos, y las soluciones de cada ejercicio separadas por comentarios. Cada soluci\u00f3n debe incluir: La definici\u00f3n de las funciones que resuelven el ejercicio. Una visualizaci\u00f3n por pantalla con ejemplos distintos de los presentados en el enunciado que demuestren qu\u00e9 hace la funci\u00f3n . Importante Los ejemplos que muestres en pantalla deben ser distintos de los incluidos en el enunciado.","title":"Entrega de la pr\u00e1ctica"},{"location":"practicas/practica11/practica11.html#ejercicios","text":"","title":"Ejercicios"},{"location":"practicas/practica11/practica11.html#ejercicio-1","text":"a) Define la funci\u00f3n maxOpt(_ x: Int?, _ y: Int?) -> Int? que devuelve el m\u00e1ximo de dos enteros opcionales. En el caso en que ambos sean nil se devolver\u00e1 nil . En el caso en que uno sea nil y el otro no se devolver\u00e1 el entero que no es nil . En el caso en que ning\u00fan par\u00e1metro sea nil se devolver\u00e1 el mayor. Ejemplo: let res1 = maxOpt ( nil , nil ) let res2 = maxOpt ( 10 , nil ) let res3 = maxOpt ( - 10 , 30 ) print ( \"res1 = \\( String ( describing : res1 )) \" ) print ( \"res2 = \\( String ( describing : res2 )) \" ) print ( \"res3 = \\( String ( describing : res3 )) \" ) // Imprime: // res1 = nil // res2 = Optional(10) // res3 = Optional(30) b1) Escribe una nueva versi\u00f3n del ejercicio 1b) de la pr\u00e1ctica 9 que permita recibir n\u00fameros negativos y que devuelva una pareja de (Int?, Int?) con nil en la parte izquierda y/o derecha si no hay n\u00famero impares o pares. Ejemplo: let numeros = [ - 10 , 202 , 12 , 100 , 204 , 2 ] print ( \" \\n ****** \\n 1b1) Funci\u00f3n parejaMayorParImpar2(numeros:) \\n ******\" ) print ( parejaMayorParImpar2 ( numeros : numeros )) // Imprime: // parejaMayorParImpar2(numeros: [-10, 202, 12, 100, 204, 2]) // (nil, Optional(204)) b2) Escribe la funci\u00f3n sumaMaxParesImpares(numeros: [Int]) -> Int que llama a la funci\u00f3n anterior y devuelve la suma del m\u00e1ximo de los pares y el m\u00e1ximo de los impares. En el caso en que se pase un array vac\u00edo deber\u00e1 devolver un 0. print ( \"sumaMaxParesImpares(numeros: \\( numeros2 ) )\" ) print ( sumaMaxParesImpares ( numeros : numeros2 )) // Imprime: // sumaMaxParesImpares(numeros: [-10, 202, 12, 100, 204, 2]) // 204 b3) Escribe una nueva versi\u00f3n de la funci\u00f3n del ejercicio b1) en la que se devuelva nil en el caso en que se le pase como par\u00e1metro un array vac\u00edo. \u00bfC\u00f3mo se deber\u00eda cambiar la declaraci\u00f3n de la funci\u00f3n? Escribe tambi\u00e9n una nueva versi\u00f3n de la funci\u00f3n del ejercicio b2) en la que se llame a la funci\u00f3n anterior.","title":"Ejercicio 1"},{"location":"practicas/practica11/practica11.html#ejercicio-2","text":"a) Indica qu\u00e9 devuelven las siguientes expresiones: a.1) let nums = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] nums . filter { $0 % 3 == 0 }. count a.2) let nums2 = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] nums2 . map { $0 + 100 }. filter { $0 % 5 == 0 }. reduce ( 0 , + ) a.3) let cadenas = [ \"En\" , \"un\" , \"lugar\" , \"de\" , \"La\" , \"Mancha\" ] cadenas . sorted { $0 . count < $1 . count }. map { $0 . count } a.4) let cadenas2 = [ \"En\" , \"un\" , \"lugar\" , \"de\" , \"La\" , \"Mancha\" ] cadenas2 . reduce ([]) { ( res : [( String , Int )], c : String ) -> [( String , Int )] in res + [( c , c . count )]}. sorted ( by : { $0 . 1 < $1 . 1 }) b) Explica qu\u00e9 hacen las siguientes funciones y pon un ejemplo de su funcionamiento: b.1) func f ( nums : [ Int ], n : Int ) -> Int { return nums . filter { $0 == n }. count } b.2) func g ( nums : [ Int ]) -> [ Int ] { return nums . reduce ([], { ( res : [ Int ], n : Int ) -> [ Int ] in if ! res . contains ( n ) { return res + [ n ] } else { return res } }) } b.3) func h ( nums : [ Int ], n : Int ) -> ([ Int ], [ Int ]) { return nums . reduce (([],[]), { ( res : ([ Int ],[ Int ]), num : Int ) -> ([ Int ],[ Int ]) in if ( num >= n ) { return ( res . 0 , res . 1 + [ num ]) } else { return (( res . 0 + [ num ], res . 1 )) } }) } c) Implementa las siguientes funciones con funciones de orden superior. c.1) Funci\u00f3n suma(palabras:contienen:) : suma ( palabras : [ String ], contienen : Character ) -> Int que recibe una array de cadenas y devuelve la suma de las longitudes de las cadenas que contiene el car\u00e1cter que se pasa como par\u00e1metro. c.2) Funci\u00f3n sumaMenoresMayores(nums:pivote:) : sumaMenoresMayores ( nums : [ Int ], pivote : Int ) -> ( Int , Int ) que recibe un array de n\u00fameros y un n\u00famero pivote y devuelve una tupla con la suma de los n\u00fameros menores y mayores o iguales que el pivote. d) (Ejercicio sobre variables capturadas por clausuras) Reflexiona sobre el siguiente c\u00f3digo y completa el hueco para obtener el resultado esperado. func bar ( f : ( Int ) -> Int ) { print ( f ( __________ )) } func foo () -> ( Int ) -> Int { var x = 3 return { x += $0 + 2 return x } } var x = 5 let g = foo () bar ( f : g ) // => 9 bar ( f : g ) // => 15","title":"Ejercicio 2"},{"location":"practicas/practica11/practica11.html#ejercicio-3","text":"Define un tipo enumerado con un \u00e1rbol gen\u00e9rico, tal y como hicimos en el \u00faltimo ejercicio de la pr\u00e1ctica anterior, que tenga como gen\u00e9rico el tipo de dato que contiene. En el siguiente ejemplo vemos c\u00f3mo deber\u00eda poderse definir con el mismo tipo gen\u00e9rico un \u00e1rbol de enteros y un \u00e1rbol de cadenas: let arbolInt : Arbol = . nodo ( 53 , [. nodo ( 13 , []), . nodo ( 32 , []), . nodo ( 41 , [. nodo ( 36 , []), . nodo ( 39 , []) ]) ]) let arbolString : Arbol = . nodo ( \"Zamora\" , [. nodo ( \"Buend\u00eda\" , [. nodo ( \"Albeza\" , []), . nodo ( \"Berenguer\" , []), . nodo ( \"Bolardo\" , []) ]), . nodo ( \"Galv\u00e1n\" , []) ]) Define las funciones gen\u00e9ricas toArray y toArrayFOS que devuelvan un array con todos los componentes del \u00e1rbol usando un recorrido preorden (primero la ra\u00edz y despu\u00e9s los hijos). La primera la debes implementar con recursi\u00f3n mutua y la segunda usando funciones de orden superior. Ejemplo: print ( toArray ( arbol : arbolInt )) // Imprime: [53, 13, 32, 41, 36, 39] print ( toArrayFOS ( arbol : arbolString )) // Imprime: [\"Zamora\", \"Buend\u00eda\", \"Albeza\", \"Berenguer\", \"Bolardo\", \"Galv\u00e1n\"]","title":"Ejercicio 3"},{"location":"practicas/practica11/practica11.html#ejercicio-4","text":"Implementa en Swift la funci\u00f3n imprimirListadosNotas(alumnos:) que recibe un array de tuplas, en donde cada tupla contiene informaci\u00f3n de la evaluaci\u00f3n de un alumno de LPP (nombreAlumno, notaParcial1, notaParcial2, notaParcial3, a\u00f1osMatriculacion) y que debe imprimir por pantalla los siguientes listados: listado 1: array ordenado por nombre del alumno (orden alfab\u00e9tico creciente) listado 2: array ordenado por la nota del parcial 1 (orden decreciente de nota) listado 3: array ordenado por la nota del parcial 2 (orden creciente de nota) listado 4: array ordenado por a\u00f1o de matriculaci\u00f3n y nota del parcial 3 (orden decreciente de a\u00f1o y nota) listado 5: array ordenado por nota final (media de los tres parciales, ponderados en: 0,34, 0,33, 0,33) (orden decreciente de nota final) Las ordenaciones hay que realizarlas usando la funci\u00f3n sorted . Nota Para que los listados se muestren formateados con espacios, puedes usar la siguiente funci\u00f3n (para ello tambi\u00e9n debes incluir el import que se indica) import Foundation func imprimirListadoAlumnos ( _ alumnos : [( String , Double , Double , Double , Int )]) { print ( \"Alumno Parcial1 Parcial2 Parcial3 A\u00f1os\" ) for alu in alumnos { alu . 0. withCString { print ( String ( format : \"%-10s %5.2f %5.2f %5.2f %3d\" , $0 , alu . 1 , alu . 2 , alu . 3 , alu . 4 )) } } } Ejemplo: let listaAlumnos = [( \"Pepe\" , 8.45 , 3.75 , 6.05 , 1 ), ( \"Maria\" , 9.1 , 7.5 , 8.18 , 1 ), ( \"Jose\" , 8.0 , 6.65 , 7.96 , 1 ), ( \"Carmen\" , 6.25 , 1.2 , 5.41 , 2 ), ( \"Felipe\" , 5.65 , 0.25 , 3.16 , 3 ), ( \"Carla\" , 6.25 , 1.25 , 4.23 , 2 ), ( \"Luis\" , 6.75 , 0.25 , 4.63 , 2 ), ( \"Loli\" , 3.0 , 1.25 , 2.19 , 3 )] imprimirListadosNotas ( listaAlumnos ) Algunos de los listados que se deben mostrar ser\u00edan los siguientes: LISTADO ORIGINAL Alumno Parcial1 Parcial2 Parcial3 A\u00f1os Pepe 8.45 3.75 6.05 1 Maria 9.10 7.50 8.18 1 Jose 8.00 6.65 7.96 1 Carmen 6.25 1.20 5.41 2 Felipe 5.65 0.25 3.16 3 Carla 6.25 1.25 4.23 2 Luis 6.75 0.25 4.63 2 Loli 3.00 1.25 2.19 3 LISTADO ORDENADO por Parcial1 (decreciente) Alumno Parcial1 Parcial2 Parcial3 A\u00f1os Loli 3.00 1.25 2.19 3 Felipe 5.65 0.25 3.16 3 Carmen 6.25 1.20 5.41 2 Carla 6.25 1.25 4.23 2 Luis 6.75 0.25 4.63 2 Jose 8.00 6.65 7.96 1 Pepe 8.45 3.75 6.05 1 Maria 9.10 7.50 8.18 1","title":"Ejercicio 4"},{"location":"practicas/practica11/practica11.html#ejercicio-5","text":"Dado el array listaAlumnos del ejercicio anterior, utiliza funciones de orden superior para obtener los datos requeridos en cada caso. A) N\u00famero de alumnos que han aprobado primer parcial y suspendido el segundo print ( listaAlumnos . ________________________________ ) // Resultado: 5 B) Alumnos que han aprobado la asignatura (tienen una nota final >= 5) print ( listaAlumnos . _______________________________ ) // Resultado: [\"Pepe\", \"Maria\", \"Jose\"] C) Nota media de todos los alumnos en forma de tupla (media_p1, media_p2, media_p3) var tupla = listaAlumnos . _____________________________________ ) tupla = ( tupla . 0 / Double ( listaAlumnos . count ), tupla . 1 / Double ( listaAlumnos . count ), tupla . 2 / Double ( listaAlumnos . count )) print ( tupla ) // Resultado: (6.6812499999999995, 2.7624999999999997, 5.2262500000000003)","title":"Ejercicio 5"},{"location":"practicas/practica11/practica11.html#ejercicio-6","text":"Implementa la funci\u00f3n construye con el siguiente perfil: func construye ( operador : Character ) -> ( Int , Int ) -> Int La funci\u00f3n recibe un operador que puede ser uno de los siguientes caracteres: + , - , * , / y debe devolver una clausura que reciba dos argumentos y realice la operaci\u00f3n indicada sobre ellos. Ejemplo: var f = construye ( operador : \"+\" ) print ( f ( 2 , 3 )) // Imprime 5 f = construye ( operador : \"-\" ) print ( f ( 2 , 3 )) // Imprime -1 Lenguajes y Paradigmas de Programaci\u00f3n, curso 2020-21 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Domingo Gallardo, Cristina Pomares, Antonio Bot\u00eda, Francisco Mart\u00ednez","title":"Ejercicio 6"},{"location":"practicas/practica12/practica12.html","text":"Pr\u00e1ctica 11: Programaci\u00f3n Orientada a Objetos en Swift (1) \u00b6 Entrega de la pr\u00e1ctica \u00b6 Para entregar la pr\u00e1ctica debes subir a Moodle el fichero practica11.swift con una cabecera inicial con tu nombre y apellidos, y las soluciones de cada ejercicio separadas por comentarios. Ejercicio 1 \u00b6 Contesta los siguientes apartados sin usar el compilador de Swift. Una vez los hayas terminado, comprueba si la soluci\u00f3n que hab\u00edas indicado era correcta. a) Examina el siguiente c\u00f3digo. \u00bfQu\u00e9 error o errores tiene? Una vez que arregles el c\u00f3digo, indica qu\u00e9 se va a imprimir por pantalla. struct MiEstructura { var x = 0 } class MiClase { var x = 0 } func foo ( _ c : MiClase , _ x : Int ) { c . x = x } let s1 = MiEstructura () var s2 = s1 let c1 = MiClase () var c2 = c1 s1 . x = 10 c1 . x = 10 print ( \"s2.x: \\( s2 . x ) , c2.x: \\( c2 . x ) \" ) foo ( c1 , 20 ) print ( \"c1.x, despu\u00e9s de llamar a la funci\u00f3n: \\( c1 . x ) \" ) b) Examina el c\u00f3digo a continuaci\u00f3n y a\u00f1ade en la estructura Cuadrado dos versiones de un m\u00e9todo movido que reciba un incremento x y un incremento y y devuelva un nuevo cuadrado resultante de haber movido su esquina. Llama a la primera versi\u00f3n del m\u00e9todo movido1 y usa en ella el m\u00e9todo movida de la clase Coord . Llama a la segunda versi\u00f3n del m\u00e9todo movido2 y usa en ella el m\u00e9todo mueve de la clase Coord . struct Coord { var x : Double var y : Double func movida ( incX : Double , incY : Double ) -> Coord { return Coord ( x : x + incX , y : y + incY ) } mutating func mueve ( incX : Double , incY : Double ) { x = x + incX y = y + incY } } struct Cuadrado { var esquina = Coord ( x : 0.0 , y : 0.0 ) var lado : Double func movido1 ... { ... } func movido2 ... { ... } } c) Indica qu\u00e9 muestra por pantalla la funci\u00f3n print: func foo ( palabra pal : String ) -> String { let lon = pal . count if lon < 2 { return pal } else { let start = pal . startIndex let end = pal . index ( start , offsetBy : lon / 2 ) return String ( pal [ end ]) } } class MisPalabras { var guardadas : [ String ] = [] func guarda ( palabra : String ) { guardadas . append ( palabra ) } var x : [ String ] { get { return guardadas . map ( foo ) } } } let palabras = MisPalabras () palabras . guarda ( palabra : \"sal\" ) palabras . guarda ( palabra : \"limon\" ) print ( palabras . x ) Ejercicio 2 \u00b6 a) El siguiente c\u00f3digo usa observadores de propiedades y una variable del tipo (est\u00e1tica). \u00bfQu\u00e9 se imprime al final de su ejecuci\u00f3n? Reflexiona sobre el funcionamiento del c\u00f3digo, compru\u00e9balo con el compilador y experimenta haciendo cambios y comprobando el resultado. struct Valor { var valor : Int = 0 { willSet { Valor . z += newValue } didSet { if valor > 10 { valor = 10 } } } static var z = 0 } var c1 = Valor () var c2 = Valor () c1 . valor = 20 c2 . valor = 8 print ( c1 . valor + c2 . valor + Valor . z ) b) Escribe un ejemplo de c\u00f3digo en el que definas una relaci\u00f3n de herencia entre una clase base y una clase derivada. Comprueba en el c\u00f3digo que un objeto de la clase derivada hereda las propiedades y m\u00e9todos de la clase base. Investiga sobre el funcionamiento de la herencia en Swift. Escribe ejemplos en donde compruebes este funcionamiento. Algunos ejemplos de preguntas que puedes investigar (puedes a\u00f1adir t\u00fa m\u00e1s preguntas): \u00bfSe puede sobreescribir el valor de una propiedad almacenada? \u00bfY calculada? \u00bfSe puede a\u00f1adir un observador a una propiedad de la clase base en una clase derivada? \u00bfHereda la clase derivada propiedades y m\u00e9todos est\u00e1ticos de la clase base? \u00bfC\u00f3mo se puede llamar a la implementaci\u00f3n de un m\u00e9todo de la clase base en una sobreescritura de ese mismo m\u00e9todo en la clase derivada? Ejercicio 3 \u00b6 Tenemos que escribir un programa que permita definir resultados de partidos de f\u00fatbol y calcular la puntuaci\u00f3n de un conjunto de equipos una vez que se han jugado esos partidos. Un ejemplo de ejecuci\u00f3n del c\u00f3digo deber\u00eda ser c\u00f3mo sigue: -------------- Puntuaci\u00f3n antes de los partidos: Real Madrid: 0 puntos Barcelona: 0 puntos Atl\u00e9tico Madrid: 0 puntos Valencia: 0 puntos Athl\u00e9tic Bilbao: 0 puntos Sevilla: 0 puntos -------------- Resultados: Real Madrid 0 - Barcelona 3 Sevilla 1 - Athl\u00e9tic Bilbao 1 Valencia 2 - Atl\u00e9tico Madrid 1 -------------- Puntuaci\u00f3n despu\u00e9s de los partidos: Real Madrid: 0 puntos Barcelona: 3 puntos Atl\u00e9tico Madrid: 0 puntos Valencia: 3 puntos Athl\u00e9tic Bilbao: 1 puntos Sevilla: 1 puntos Escribe c\u00f3digo en Swift que permita resolver el problema, utilizando structs . El ejercicio se puede resolver de varias formas. Te proponemos una soluci\u00f3n con tres estructuras: Equipo : Contiene el nombre y los puntos de un equipo y un m\u00e9todo para actualizar las puntaciones Partido : Nombres de los equipos y goles del partido Liga : Contiene array de equipos y partidos jugados, as\u00ed como los m\u00e9todos para actualizar una jornada Puedes usar esta propuesta, o proponer t\u00fa alguna soluci\u00f3n alternativa. Ejercicio 4 \u00b6 En este ejercicio vamos a trabajar con figuras geom\u00e9tricas usando estructuras y clases. En el ejercicio deber\u00e1s usar la funci\u00f3n para calcular la ra\u00edz cuadrada y el valor de la constante matem\u00e1tica pi . Para usar la funci\u00f3n sqrt debes importar la librer\u00eda Foundation : import Foundation El valor de la constante matem\u00e1tica pi lo puedes obtener con la propiedad Double.pi . Suponemos que estamos trabajando con coordenadas de pantalla, en las que la coordenada (0,0) representa la coordenada de la esquina superior izquierda de la pantalla. La coordenada Y crece hacia abajo y la coordenada X crece hacia la derecha. Las coordenadas se definir\u00e1n con n\u00fameros decimales ( Double ). Vamos a definir las siguientes estructuras y clases: Estructuras: Punto , Tama\u00f1o Clases: Figura (clase padre), Cuadril\u00e1tero y Circulo (clases derivadas). Vamos a definir propiedades almacenadas y propiedades calculadas para todas las figuras geom\u00e9tricas. Estructuras Punto y Tama\u00f1o Las debes declarar tal y como aparecen en los apuntes. Clase padre Figura : Constructor: Figura(origen: Punto, tama\u00f1o: Tama\u00f1o) Propiedades de instancia almacenadas: origen ( Punto ) que define las coordenadas de la esquina superior izquierda del rect\u00e1ngulo que define la figura tama\u00f1o ( Tama\u00f1o ) que define el alto y el ancho del rect\u00e1ngulo que define la figura. Propiedades de instancia calculadas: area ( Double , solo lectura) que devuelve el \u00e1rea del rect\u00e1ngulo que engloba la figura. centro ( Punto , propiedad de lectura y escritura). Es el centro del rect\u00e1ngulo que define la figura. Si modificamos el centro se modifica la posici\u00f3n del origen de la figura. Clase derivada Cuadrilatero Un cuadril\u00e1tero se define por cuatro puntos. La figura padre representa el rect\u00e1ngulo que engloba los cuatro puntos del cuadril\u00e1tero (ver imagen arriba). Constructor: Cuadrilatero(p1: Punto, p2: Punto, p3: Punto, p4: Punto) . Los puntos se dan en el orden definido por el sentido de las agujas del reloj, aunque no siempre se empezar\u00e1 por el punto que est\u00e1 situado m\u00e1s a la derecha. Al crear el cuadril\u00e1tero deberemos actualizar las propiedades origen y tama\u00f1o de la figura. Para calcular estas propiedades deber\u00e1s obtener las coordenadas x e y m\u00ednimas y m\u00e1ximas de todos los puntos. Propiedades de instancia almacenadas propias: Los puntos del cuadril\u00e1tero p1 , p2 , p3 y p4 . Propiedades de instancia calculadas: centro ( Punto , de lectura y escritura), heredada de la clase padre. El setter modifica la posici\u00f3n de los puntos del cuadril\u00e1tero y del origen de la figura, desplaz\u00e1ndolos los mismos incrementos en los que ha sido desplazado el centro de la figura. area ( Double , s\u00f3lo lectura ) que devuelve el \u00e1rea del cuadril\u00e1tero . Clase derivada Circulo Un c\u00edrculo se define por un centro y un radio. La figura padre representa el cuadrado m\u00e1s peque\u00f1o en el que est\u00e1 inscrito el c\u00edrculo (ver imagen arriba). Constructor: Circulo(centro: Punto, radio: Double) . Al crear el c\u00edrculo deberemos actualizar las propiedades origen y tama\u00f1o de la figura. Propiedades de instancia almacenadas: radio ( Double ) que contiene la longitud del radio. Propiedades de instancia calculadas: centro ( Punto , de lectura y escritura), heredada de la clase padre. area ( Double , de lectura y escritura) que devuelve el \u00e1rea del c\u00edrculo. El setter modifica el tama\u00f1o del c\u00edrculo (su radio), manteniendo el centro en la misma posici\u00f3n. Estructura AlmacenFiguras Propiedades almacenadas: figuras : array de figuras. Propiedades calculadas: numFiguras ( Int ) que devuelve el n\u00famero total de figuras a\u00f1adidas. areaTotal ( Double ) que devuelve la suma total de las \u00e1reas de todas las figuras a\u00f1adidas. M\u00e9todos: a\u00f1ade(figura:) que a\u00f1ade una figura al array. desplaza(incX: Double, incY: Double) : desplaza todas las figuras las dimensiones especificadas incX (incremento en la coordenada X) e incY (incremento en la coordenada Y). Se deber\u00e1n mover los centros de todas las figuras en estas magnitudes. Implementa las estructuras anteriores y escribe alg\u00fan ejemplo de c\u00f3digo en el que se creen al menos un cuadril\u00e1tero y un c\u00edrculo, se prueben sus propiedades, se a\u00f1adan al almac\u00e9n de figuras y se prueben sus m\u00e9todos. Lenguajes y Paradigmas de Programaci\u00f3n, curso 2020-21 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Domingo Gallardo, Cristina Pomares, Antonio Bot\u00eda, Francisco Mart\u00ednez","title":"Pr\u00e1ctica 11: Programaci\u00f3n Orientada a Objetos en Swift (1)"},{"location":"practicas/practica12/practica12.html#practica-11-programacion-orientada-a-objetos-en-swift-1","text":"","title":"Pr\u00e1ctica 11: Programaci\u00f3n Orientada a Objetos en Swift (1)"},{"location":"practicas/practica12/practica12.html#entrega-de-la-practica","text":"Para entregar la pr\u00e1ctica debes subir a Moodle el fichero practica11.swift con una cabecera inicial con tu nombre y apellidos, y las soluciones de cada ejercicio separadas por comentarios.","title":"Entrega de la pr\u00e1ctica"},{"location":"practicas/practica12/practica12.html#ejercicio-1","text":"Contesta los siguientes apartados sin usar el compilador de Swift. Una vez los hayas terminado, comprueba si la soluci\u00f3n que hab\u00edas indicado era correcta. a) Examina el siguiente c\u00f3digo. \u00bfQu\u00e9 error o errores tiene? Una vez que arregles el c\u00f3digo, indica qu\u00e9 se va a imprimir por pantalla. struct MiEstructura { var x = 0 } class MiClase { var x = 0 } func foo ( _ c : MiClase , _ x : Int ) { c . x = x } let s1 = MiEstructura () var s2 = s1 let c1 = MiClase () var c2 = c1 s1 . x = 10 c1 . x = 10 print ( \"s2.x: \\( s2 . x ) , c2.x: \\( c2 . x ) \" ) foo ( c1 , 20 ) print ( \"c1.x, despu\u00e9s de llamar a la funci\u00f3n: \\( c1 . x ) \" ) b) Examina el c\u00f3digo a continuaci\u00f3n y a\u00f1ade en la estructura Cuadrado dos versiones de un m\u00e9todo movido que reciba un incremento x y un incremento y y devuelva un nuevo cuadrado resultante de haber movido su esquina. Llama a la primera versi\u00f3n del m\u00e9todo movido1 y usa en ella el m\u00e9todo movida de la clase Coord . Llama a la segunda versi\u00f3n del m\u00e9todo movido2 y usa en ella el m\u00e9todo mueve de la clase Coord . struct Coord { var x : Double var y : Double func movida ( incX : Double , incY : Double ) -> Coord { return Coord ( x : x + incX , y : y + incY ) } mutating func mueve ( incX : Double , incY : Double ) { x = x + incX y = y + incY } } struct Cuadrado { var esquina = Coord ( x : 0.0 , y : 0.0 ) var lado : Double func movido1 ... { ... } func movido2 ... { ... } } c) Indica qu\u00e9 muestra por pantalla la funci\u00f3n print: func foo ( palabra pal : String ) -> String { let lon = pal . count if lon < 2 { return pal } else { let start = pal . startIndex let end = pal . index ( start , offsetBy : lon / 2 ) return String ( pal [ end ]) } } class MisPalabras { var guardadas : [ String ] = [] func guarda ( palabra : String ) { guardadas . append ( palabra ) } var x : [ String ] { get { return guardadas . map ( foo ) } } } let palabras = MisPalabras () palabras . guarda ( palabra : \"sal\" ) palabras . guarda ( palabra : \"limon\" ) print ( palabras . x )","title":"Ejercicio 1"},{"location":"practicas/practica12/practica12.html#ejercicio-2","text":"a) El siguiente c\u00f3digo usa observadores de propiedades y una variable del tipo (est\u00e1tica). \u00bfQu\u00e9 se imprime al final de su ejecuci\u00f3n? Reflexiona sobre el funcionamiento del c\u00f3digo, compru\u00e9balo con el compilador y experimenta haciendo cambios y comprobando el resultado. struct Valor { var valor : Int = 0 { willSet { Valor . z += newValue } didSet { if valor > 10 { valor = 10 } } } static var z = 0 } var c1 = Valor () var c2 = Valor () c1 . valor = 20 c2 . valor = 8 print ( c1 . valor + c2 . valor + Valor . z ) b) Escribe un ejemplo de c\u00f3digo en el que definas una relaci\u00f3n de herencia entre una clase base y una clase derivada. Comprueba en el c\u00f3digo que un objeto de la clase derivada hereda las propiedades y m\u00e9todos de la clase base. Investiga sobre el funcionamiento de la herencia en Swift. Escribe ejemplos en donde compruebes este funcionamiento. Algunos ejemplos de preguntas que puedes investigar (puedes a\u00f1adir t\u00fa m\u00e1s preguntas): \u00bfSe puede sobreescribir el valor de una propiedad almacenada? \u00bfY calculada? \u00bfSe puede a\u00f1adir un observador a una propiedad de la clase base en una clase derivada? \u00bfHereda la clase derivada propiedades y m\u00e9todos est\u00e1ticos de la clase base? \u00bfC\u00f3mo se puede llamar a la implementaci\u00f3n de un m\u00e9todo de la clase base en una sobreescritura de ese mismo m\u00e9todo en la clase derivada?","title":"Ejercicio 2"},{"location":"practicas/practica12/practica12.html#ejercicio-3","text":"Tenemos que escribir un programa que permita definir resultados de partidos de f\u00fatbol y calcular la puntuaci\u00f3n de un conjunto de equipos una vez que se han jugado esos partidos. Un ejemplo de ejecuci\u00f3n del c\u00f3digo deber\u00eda ser c\u00f3mo sigue: -------------- Puntuaci\u00f3n antes de los partidos: Real Madrid: 0 puntos Barcelona: 0 puntos Atl\u00e9tico Madrid: 0 puntos Valencia: 0 puntos Athl\u00e9tic Bilbao: 0 puntos Sevilla: 0 puntos -------------- Resultados: Real Madrid 0 - Barcelona 3 Sevilla 1 - Athl\u00e9tic Bilbao 1 Valencia 2 - Atl\u00e9tico Madrid 1 -------------- Puntuaci\u00f3n despu\u00e9s de los partidos: Real Madrid: 0 puntos Barcelona: 3 puntos Atl\u00e9tico Madrid: 0 puntos Valencia: 3 puntos Athl\u00e9tic Bilbao: 1 puntos Sevilla: 1 puntos Escribe c\u00f3digo en Swift que permita resolver el problema, utilizando structs . El ejercicio se puede resolver de varias formas. Te proponemos una soluci\u00f3n con tres estructuras: Equipo : Contiene el nombre y los puntos de un equipo y un m\u00e9todo para actualizar las puntaciones Partido : Nombres de los equipos y goles del partido Liga : Contiene array de equipos y partidos jugados, as\u00ed como los m\u00e9todos para actualizar una jornada Puedes usar esta propuesta, o proponer t\u00fa alguna soluci\u00f3n alternativa.","title":"Ejercicio 3"},{"location":"practicas/practica12/practica12.html#ejercicio-4","text":"En este ejercicio vamos a trabajar con figuras geom\u00e9tricas usando estructuras y clases. En el ejercicio deber\u00e1s usar la funci\u00f3n para calcular la ra\u00edz cuadrada y el valor de la constante matem\u00e1tica pi . Para usar la funci\u00f3n sqrt debes importar la librer\u00eda Foundation : import Foundation El valor de la constante matem\u00e1tica pi lo puedes obtener con la propiedad Double.pi . Suponemos que estamos trabajando con coordenadas de pantalla, en las que la coordenada (0,0) representa la coordenada de la esquina superior izquierda de la pantalla. La coordenada Y crece hacia abajo y la coordenada X crece hacia la derecha. Las coordenadas se definir\u00e1n con n\u00fameros decimales ( Double ). Vamos a definir las siguientes estructuras y clases: Estructuras: Punto , Tama\u00f1o Clases: Figura (clase padre), Cuadril\u00e1tero y Circulo (clases derivadas). Vamos a definir propiedades almacenadas y propiedades calculadas para todas las figuras geom\u00e9tricas. Estructuras Punto y Tama\u00f1o Las debes declarar tal y como aparecen en los apuntes. Clase padre Figura : Constructor: Figura(origen: Punto, tama\u00f1o: Tama\u00f1o) Propiedades de instancia almacenadas: origen ( Punto ) que define las coordenadas de la esquina superior izquierda del rect\u00e1ngulo que define la figura tama\u00f1o ( Tama\u00f1o ) que define el alto y el ancho del rect\u00e1ngulo que define la figura. Propiedades de instancia calculadas: area ( Double , solo lectura) que devuelve el \u00e1rea del rect\u00e1ngulo que engloba la figura. centro ( Punto , propiedad de lectura y escritura). Es el centro del rect\u00e1ngulo que define la figura. Si modificamos el centro se modifica la posici\u00f3n del origen de la figura. Clase derivada Cuadrilatero Un cuadril\u00e1tero se define por cuatro puntos. La figura padre representa el rect\u00e1ngulo que engloba los cuatro puntos del cuadril\u00e1tero (ver imagen arriba). Constructor: Cuadrilatero(p1: Punto, p2: Punto, p3: Punto, p4: Punto) . Los puntos se dan en el orden definido por el sentido de las agujas del reloj, aunque no siempre se empezar\u00e1 por el punto que est\u00e1 situado m\u00e1s a la derecha. Al crear el cuadril\u00e1tero deberemos actualizar las propiedades origen y tama\u00f1o de la figura. Para calcular estas propiedades deber\u00e1s obtener las coordenadas x e y m\u00ednimas y m\u00e1ximas de todos los puntos. Propiedades de instancia almacenadas propias: Los puntos del cuadril\u00e1tero p1 , p2 , p3 y p4 . Propiedades de instancia calculadas: centro ( Punto , de lectura y escritura), heredada de la clase padre. El setter modifica la posici\u00f3n de los puntos del cuadril\u00e1tero y del origen de la figura, desplaz\u00e1ndolos los mismos incrementos en los que ha sido desplazado el centro de la figura. area ( Double , s\u00f3lo lectura ) que devuelve el \u00e1rea del cuadril\u00e1tero . Clase derivada Circulo Un c\u00edrculo se define por un centro y un radio. La figura padre representa el cuadrado m\u00e1s peque\u00f1o en el que est\u00e1 inscrito el c\u00edrculo (ver imagen arriba). Constructor: Circulo(centro: Punto, radio: Double) . Al crear el c\u00edrculo deberemos actualizar las propiedades origen y tama\u00f1o de la figura. Propiedades de instancia almacenadas: radio ( Double ) que contiene la longitud del radio. Propiedades de instancia calculadas: centro ( Punto , de lectura y escritura), heredada de la clase padre. area ( Double , de lectura y escritura) que devuelve el \u00e1rea del c\u00edrculo. El setter modifica el tama\u00f1o del c\u00edrculo (su radio), manteniendo el centro en la misma posici\u00f3n. Estructura AlmacenFiguras Propiedades almacenadas: figuras : array de figuras. Propiedades calculadas: numFiguras ( Int ) que devuelve el n\u00famero total de figuras a\u00f1adidas. areaTotal ( Double ) que devuelve la suma total de las \u00e1reas de todas las figuras a\u00f1adidas. M\u00e9todos: a\u00f1ade(figura:) que a\u00f1ade una figura al array. desplaza(incX: Double, incY: Double) : desplaza todas las figuras las dimensiones especificadas incX (incremento en la coordenada X) e incY (incremento en la coordenada Y). Se deber\u00e1n mover los centros de todas las figuras en estas magnitudes. Implementa las estructuras anteriores y escribe alg\u00fan ejemplo de c\u00f3digo en el que se creen al menos un cuadril\u00e1tero y un c\u00edrculo, se prueben sus propiedades, se a\u00f1adan al almac\u00e9n de figuras y se prueben sus m\u00e9todos. Lenguajes y Paradigmas de Programaci\u00f3n, curso 2020-21 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Domingo Gallardo, Cristina Pomares, Antonio Bot\u00eda, Francisco Mart\u00ednez","title":"Ejercicio 4"},{"location":"practicas/practica13/practica13.html","text":"Pr\u00e1ctica 12: Programaci\u00f3n Orientada a Objetos en Swift (2) \u00b6 Entrega de la pr\u00e1ctica \u00b6 Para entregar la pr\u00e1ctica debes subir a Moodle el fichero practica12.swift con una cabecera inicial con tu nombre y apellidos, y las soluciones de cada ejercicio separadas por comentarios. Ejercicios \u00b6 Ejercicio 1 \u00b6 a) Completa el c\u00f3digo de la estructura \u200b MiStruct \u200b para que compile correctamente. Hazlo primero en papel y despu\u00e9s pru\u00e9balo en el compilador. protocol A { var a : String { get } func foo ( a : String ) -> String ? } protocol B { mutating func bar () } struct MiStruct : A , B { // Completa el c\u00f3digo } b) El siguiente c\u00f3digo tiene errores. Intenta descubrir cu\u00e1les son sin utilizar el compilador. Prueba distintas formas de arreglar el c\u00f3digo cambiando lo m\u00ednimo posible de lo ya definido (por ejemplo, no debes a\u00f1adir nuevas propiedades en MiStruct ). Compru\u00e9balo con el compilador. protocol A { var a : String { get set } func foo ( a : Int , b : Int ) -> Int ? } protocol B { mutating func bar () } struct MiStruct : A , B { let a = 10 func foo ( valor1 a : Int , valor2 b : Int ) -> Int { let res = a > 10 ? a : b return res } } c) Supongamos la estructura Equipo que aparece a continuaci\u00f3n que representa un equipo en una competici\u00f3n deportiva: struct Equipo { let puntos : Int let nombre : String } Modifica la definici\u00f3n para poder comprobar la igualdad de dos equipos y que el siguiente c\u00f3digo funcione correctamente: let equipo1 = Equipo ( puntos : 10 , nombre : \"H\u00e9rcules\" ) let equipo2 = Equipo ( puntos : 8 , nombre : \"Villareal\" ) print ( equipo1 == equipo2 ) // imprime false Despu\u00e9s, modifica el c\u00f3digo otra vez para que la estructura se ajuste tambi\u00e9n al protocolo Comparable para poder comparar dos equipos . Consulta el protocolo en documentaci\u00f3n de Swift . Un equipo ser\u00e1 menor que otro cuando tenga menos puntos. En el caso en que ambos tengan los mismos puntos, ser\u00e1 menor el que tenga menor nombre en orden alfab\u00e9tico. print ( equipo1 > equipo2 ) // imprime true Una vez definidos los operadores necesarios comprueba que funcionan correctamente creando varios equipos, insert\u00e1ndolos en un array y llamando al m\u00e9todo sorted . Ejercicio 2 \u00b6 En este ejercicio deber\u00e1s implementar un conjunto de clases con las que podamos \"simular\" una carrera de coches. Funci\u00f3n Int.random(in:) \u00b6 Utilizaremos la funci\u00f3n del sistema Int.random(in:) que devuelve un n\u00famero aleatorio entero en un rango. Por ejemplo, el siguiente c\u00f3digo devuelve un n\u00famero aleatorio entre 1 y 99 for _ in 1. .. 3 { print ( Int . random ( in : 1. .. 99 )) } // Prints \"53\" // Prints \"64\" // Prints \"5\" A continuaci\u00f3n puedes ver un ejemplo de su utilizaci\u00f3n en un m\u00e9todo de tipo del enumerado MarcaCoche para devolver una marca aleatoria de coche: enum MarcaCoche : Int { case Mercedes = 0 , Ferrari , RedBull , McLaren static func random () -> MarcaCoche { let maxValue = McLaren . rawValue let r = Int . random ( in : 0. .. maxValue ) return MarcaCoche ( rawValue : r ) ! } } Enumerados y clases que gestionan los veh\u00edculos \u00b6 Deber\u00e1s implementar los siguientes enumerados y clases, con las propiedades indicadas. Enumerado MarcaCoche Posibles valores: Mercedes , Ferrari , RedBull y McLaren M\u00e9todo del tipo random() que devuelva aleatoriamente uno de los valores (consultar el c\u00f3digo anterior). Enumerado TipoCambio Posibles valores: Automatico o Manual M\u00e9todo del tipo random() que devuelve uno de esos valores. Clase base Coche Propiedades de instancia almacenadas: velocidadActual ( Double ), marcha ( Int ), distanciaRecorrida ( Double ) y marca ( MarcaCoche ). Propiedad de instancia calculada: descripcion ( String ), que devuelve la marca del coche. Propiedades del tipo: Constantes velocidadMaxima ( Double ) y marchaMaxima ( Int ) inicializadas a 150.0 y 6 Subclase CocheAutomatico Hereda de Coche y sobreescribe la descripci\u00f3n, a\u00f1adiendo la cadena \"Autom\u00e1tico\". Subclase CocheManual Hereda de Coche y sobreescribe la descripci\u00f3n, a\u00f1adiendo la cadena \"Manual\". Observadores de propiedades en las subclases La velocidad de un coche manual se modifica cambiando su propiedad marcha y la de un coche autom\u00e1tico cambiando su propiedad velocidadActual . En cada caso hay que definir observadores de propiedades que modifiquen la otra propiedad. La velocidad se calcula a partir de la marcha seg\u00fan la siguiente expresi\u00f3n: velocidadActual = 25.0 * marcha Y la marcha se calcula a partir de la velocidad con la expresi\u00f3n que puedes encontrar en los apuntes de teor\u00eda, en la definici\u00f3n de la clase CocheAutomatico . Distancia recorrida e informaci\u00f3n en pantalla Suponemos que se cambia la velocidad del coche cada hora y que en cada cambio de velocidad se actualiza la propiedad distanciaRecorrida , que ir\u00e1 acumulando la distancia recorrida por el coche desde su inicializaci\u00f3n. Cada vez que se cambia la velocidad tambi\u00e9n se imprimir\u00e1 la velocidad actual y la marca del coche en pantalla (ver el ejemplo al final del ejercicio). Esto se puede implementar tambi\u00e9n en los observadores. Clase Carrera \u00b6 Debes implementar las clases anteriores y una clase Carrera con la que simular una carrera de n coches que conducen durante k horas. Un ejemplo de uso de la clase Carrera : let carrera = Carrera ( numCoches : 2 , horas : 3 ) print ( \" \\n Descripci\u00f3n de la carrera:\" ) carrera . descripcion () print ( \" \\n !!! Comienza la carrera !!!\" ) carrera . empezar () print ( \" \\n !!! Clasificaci\u00f3n !!!\" ) carrera . clasificacion () Y su correspondiente salida por pantalla: Descripci\u00f3n de la carrera: 2 coches con una duraci\u00f3n de 3 horas McLaren Automatico Mercedes Manual !!! Comienza la carrera !!! Horas transcurridas 1 McLaren Automatico viajando a 141.0 kil\u00f3metros por hora con la marcha 6 Mercedes Manual viajando a 25.0 kil\u00f3metros por hora con la marcha 1 Horas transcurridas 2 McLaren Automatico viajando a 114.0 kil\u00f3metros por hora con la marcha 5 Mercedes Manual viajando a 25.0 kil\u00f3metros por hora con la marcha 1 Horas transcurridas 3 McLaren Automatico viajando a 105.0 kil\u00f3metros por hora con la marcha 5 Mercedes Manual viajando a 100.0 kil\u00f3metros por hora con la marcha 4 !!! Clasificaci\u00f3n !!! 1. McLaren Automatico (360.0 kil\u00f3metros recorridos) 2. Mercedes Manual (150.0 kil\u00f3metros recorridos) Ejercicio 3 \u00b6 a) Completa el bucle con el c\u00f3digo que comprueba el tipo de la variable i e imprime su propiedad p y su propiedad a1 o a2 , dependiendo de su tipo. protocol P { var p : Int { get } } class A1 : P { var p = 0 var a1 = 0 } class A2 : P { var p = 1 var a2 = 0 } var array : [ P ] = [ A1 (), A2 ()] for i in array { // C\u00f3digo a completar // } // debe imprimir: // debe imprimir: // p: 0, a1: 0 // p: 1, a2: 0 b) Completa el c\u00f3digo que hay a continuaci\u00f3n para que compile correctamente y aparezca en pantalla el resultado que se muestra. Resultado: 0.0 300.0 C\u00f3digo: protocol TieneVelocidad { func velocidadActual () -> Double } class Vehiculo { var velocidad = 0.0 func velocidadActual () -> Double { return velocidad } } class Tren { static let velocidadEnMarcha = 300.0 var pasajeros = 0 var enMarcha = false } // // C\u00f3digo a completar // var vehiculo1 = Vehiculo () var tren1 = Tren () tren1 . enMarcha = true let transportes : [ TieneVelocidad ] = [ vehiculo1 , tren1 ] for i in transportes { print ( i . velocidadActual ()) } Ejercicio 4 \u00b6 Define una estructura Timer con la que podamos ejecutar el siguiente c\u00f3digo sin errores. El temporizador se inicializa con un n\u00famero determinado de segundos y define un m\u00e9todo de instancia paso() que descuenta un segundo. F\u00edjate en el c\u00f3digo y ver\u00e1s que es posible sumar temporizadores. Por \u00faltimo, el atributo del tipo pasosTotales guarda el n\u00famero de pasos que se han realizado en todas las instancias. var t1 = Timer ( segundos : 10 ) var t2 = Timer ( segundos : 5 ) for _ in 0. .. 4 { t1 . paso () } for _ in 0. .. 2 { t2 . paso () } var t3 = t1 + t2 t3 . paso () print ( \"Segundos del temporizador 1: \\( t1 . segundos ) \" ) print ( \"Segundos del temporizador 2: \\( t2 . segundos ) \" ) print ( \"Segundos del temporizador 3: \\( t3 . segundos ) \" ) print ( \"Pasos totales: \\( Timer . pasosTotales ) \" ) // Imprime: // Segundos del temporizador 1: 5 // Segundos del temporizador 2: 2 // Segundos del temporizador 3: 6 // Pasos totales: 9 Ejercicio 5 \u00b6 Vamos, por \u00faltimo, con un ejercicio en el que veremos otra forma de trabajar con figuras geom\u00e9tricas. 1. Completa el c\u00f3digo inicial \u00b6 Comienza incluyendo en la pr\u00e1ctica el c\u00f3digo de las definiciones de las estructuras geom\u00e9tricas: Punto , Tama\u00f1o , Rectangulo y Circulo . Debes completar el c\u00f3digo para que haga lo indicado en los comentarios. struct Punto { var x = 0.0 , y = 0.0 } struct Tama\u00f1o { var ancho = 0.0 , alto = 0.0 } struct Circulo { var centro = Punto () var radio = 0.0 var area : Double { // Propiedad calculada que devuelve el // \u00e1rea del c\u00edrculo y modifica el radio // cuando se actualiza } } struct Rectangulo { var origen = Punto () var tama\u00f1o = Tama\u00f1o () var centro : Punto { // Propiedad calculada que devuelve el // centro del rect\u00e1ngulo y traslada su // origen cuando se modifica } var area : Double { // Propiedad calculada que devuelve el // \u00e1rea del rect\u00e1ngulo } } Prueba las clases escribiendo alg\u00fan c\u00f3digo en el que se creen algunas instancias y se actualicen sus propiedades. 2. Define el protocolo figura \u00b6 Define el protocolo Figura que contiene: Propiedad de lectura y escritura centro ( Punto ), que define el centro de la figura. Propiedades de s\u00f3lo lectura area ( Double ) y tama\u00f1o ( Tama\u00f1o ) que devuelven el tama\u00f1o (alto y ancho) de la figura. 3. Define extensiones \u00b6 Define las extensiones necesarias para que las clases Rectangulo , y Circulo se ajusten al protocolo Figura , a\u00f1adiendo el c\u00f3digo de implementaci\u00f3n necesario. A\u00f1ade mediante una extensi\u00f3n al protocolo Figura la propiedad calculada descripcion que devuelva un String con el centro y el \u00e1rea de la figura. Prueba el c\u00f3digo escrito hasta ahora, creando un array del tipo Figura (el protocolo) y a\u00f1adiendo en \u00e9l c\u00edrculos y rect\u00e1ngulos. 4. Estructura AlmacenFiguras \u00b6 Por \u00faltimo, implementa una estructura AlmacenFiguras . Debe tener una \u00fanica propiedad figuras que contenga un array de figuras. Como en la pr\u00e1ctica anterior, define en ella el m\u00e9todo a\u00f1ade(figura:) y las propiedades calculadas numFiguras ( Int ) y areaTotal ( Double ). Escribe el m\u00e9todo cuentaTipos() -> (Int, Int) que recorra el array de figuras y devuelva una tupla con dos enteros: n\u00famero de rect\u00e1ngulos y n\u00famero de c\u00edrculos. La funci\u00f3n debe imprimir por cada figura del array, su descripci\u00f3n por defecto proporcionada por el protocolo y el tipo de figura y sus caracter\u00edsticas espec\u00edficas. Por ejemplo: - Descripci\u00f3n de la figura: Una figura con centro Punto(x: 7.0, y: 3.5) y \u00e1rea 50.0 Rectangulo con origen Punto(x: 2.0, y: 1.0) y tama\u00f1o Tama\u00f1o(ancho: 10.0, alto: 5.0) - Descripci\u00f3n de la figura: Una figura con centro Punto(x: 0.0, y: 2.0) y \u00e1rea 78.5398163397448 Circulo con centro Punto(x: 0.0, y: 2.0) y radio 5.0 Escribe un ejemplo de c\u00f3digo en el que se guarden varias figuras en un almac\u00e9n de figuras y se llame a sus m\u00e9todos. Lenguajes y Paradigmas de Programaci\u00f3n, curso 2020-21 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Domingo Gallardo, Cristina Pomares, Antonio Bot\u00eda, Francisco Mart\u00ednez","title":"Pr\u00e1ctica 12: Programaci\u00f3n Orientada a Objetos en Swift (2)"},{"location":"practicas/practica13/practica13.html#practica-12-programacion-orientada-a-objetos-en-swift-2","text":"","title":"Pr\u00e1ctica 12: Programaci\u00f3n Orientada a Objetos en Swift (2)"},{"location":"practicas/practica13/practica13.html#entrega-de-la-practica","text":"Para entregar la pr\u00e1ctica debes subir a Moodle el fichero practica12.swift con una cabecera inicial con tu nombre y apellidos, y las soluciones de cada ejercicio separadas por comentarios.","title":"Entrega de la pr\u00e1ctica"},{"location":"practicas/practica13/practica13.html#ejercicios","text":"","title":"Ejercicios"},{"location":"practicas/practica13/practica13.html#ejercicio-1","text":"a) Completa el c\u00f3digo de la estructura \u200b MiStruct \u200b para que compile correctamente. Hazlo primero en papel y despu\u00e9s pru\u00e9balo en el compilador. protocol A { var a : String { get } func foo ( a : String ) -> String ? } protocol B { mutating func bar () } struct MiStruct : A , B { // Completa el c\u00f3digo } b) El siguiente c\u00f3digo tiene errores. Intenta descubrir cu\u00e1les son sin utilizar el compilador. Prueba distintas formas de arreglar el c\u00f3digo cambiando lo m\u00ednimo posible de lo ya definido (por ejemplo, no debes a\u00f1adir nuevas propiedades en MiStruct ). Compru\u00e9balo con el compilador. protocol A { var a : String { get set } func foo ( a : Int , b : Int ) -> Int ? } protocol B { mutating func bar () } struct MiStruct : A , B { let a = 10 func foo ( valor1 a : Int , valor2 b : Int ) -> Int { let res = a > 10 ? a : b return res } } c) Supongamos la estructura Equipo que aparece a continuaci\u00f3n que representa un equipo en una competici\u00f3n deportiva: struct Equipo { let puntos : Int let nombre : String } Modifica la definici\u00f3n para poder comprobar la igualdad de dos equipos y que el siguiente c\u00f3digo funcione correctamente: let equipo1 = Equipo ( puntos : 10 , nombre : \"H\u00e9rcules\" ) let equipo2 = Equipo ( puntos : 8 , nombre : \"Villareal\" ) print ( equipo1 == equipo2 ) // imprime false Despu\u00e9s, modifica el c\u00f3digo otra vez para que la estructura se ajuste tambi\u00e9n al protocolo Comparable para poder comparar dos equipos . Consulta el protocolo en documentaci\u00f3n de Swift . Un equipo ser\u00e1 menor que otro cuando tenga menos puntos. En el caso en que ambos tengan los mismos puntos, ser\u00e1 menor el que tenga menor nombre en orden alfab\u00e9tico. print ( equipo1 > equipo2 ) // imprime true Una vez definidos los operadores necesarios comprueba que funcionan correctamente creando varios equipos, insert\u00e1ndolos en un array y llamando al m\u00e9todo sorted .","title":"Ejercicio 1"},{"location":"practicas/practica13/practica13.html#ejercicio-2","text":"En este ejercicio deber\u00e1s implementar un conjunto de clases con las que podamos \"simular\" una carrera de coches.","title":"Ejercicio 2"},{"location":"practicas/practica13/practica13.html#ejercicio-3","text":"a) Completa el bucle con el c\u00f3digo que comprueba el tipo de la variable i e imprime su propiedad p y su propiedad a1 o a2 , dependiendo de su tipo. protocol P { var p : Int { get } } class A1 : P { var p = 0 var a1 = 0 } class A2 : P { var p = 1 var a2 = 0 } var array : [ P ] = [ A1 (), A2 ()] for i in array { // C\u00f3digo a completar // } // debe imprimir: // debe imprimir: // p: 0, a1: 0 // p: 1, a2: 0 b) Completa el c\u00f3digo que hay a continuaci\u00f3n para que compile correctamente y aparezca en pantalla el resultado que se muestra. Resultado: 0.0 300.0 C\u00f3digo: protocol TieneVelocidad { func velocidadActual () -> Double } class Vehiculo { var velocidad = 0.0 func velocidadActual () -> Double { return velocidad } } class Tren { static let velocidadEnMarcha = 300.0 var pasajeros = 0 var enMarcha = false } // // C\u00f3digo a completar // var vehiculo1 = Vehiculo () var tren1 = Tren () tren1 . enMarcha = true let transportes : [ TieneVelocidad ] = [ vehiculo1 , tren1 ] for i in transportes { print ( i . velocidadActual ()) }","title":"Ejercicio 3"},{"location":"practicas/practica13/practica13.html#ejercicio-4","text":"Define una estructura Timer con la que podamos ejecutar el siguiente c\u00f3digo sin errores. El temporizador se inicializa con un n\u00famero determinado de segundos y define un m\u00e9todo de instancia paso() que descuenta un segundo. F\u00edjate en el c\u00f3digo y ver\u00e1s que es posible sumar temporizadores. Por \u00faltimo, el atributo del tipo pasosTotales guarda el n\u00famero de pasos que se han realizado en todas las instancias. var t1 = Timer ( segundos : 10 ) var t2 = Timer ( segundos : 5 ) for _ in 0. .. 4 { t1 . paso () } for _ in 0. .. 2 { t2 . paso () } var t3 = t1 + t2 t3 . paso () print ( \"Segundos del temporizador 1: \\( t1 . segundos ) \" ) print ( \"Segundos del temporizador 2: \\( t2 . segundos ) \" ) print ( \"Segundos del temporizador 3: \\( t3 . segundos ) \" ) print ( \"Pasos totales: \\( Timer . pasosTotales ) \" ) // Imprime: // Segundos del temporizador 1: 5 // Segundos del temporizador 2: 2 // Segundos del temporizador 3: 6 // Pasos totales: 9","title":"Ejercicio 4"},{"location":"practicas/practica13/practica13.html#ejercicio-5","text":"Vamos, por \u00faltimo, con un ejercicio en el que veremos otra forma de trabajar con figuras geom\u00e9tricas.","title":"Ejercicio 5"},{"location":"seminarios/seminario1-scheme/seminario1-scheme.html","text":"Seminario 1: Seminario de Scheme \u00b6 1. El lenguaje de programaci\u00f3n Scheme \u00b6 Scheme es un lenguaje de programaci\u00f3n que surgi\u00f3 en los laboratorios del MIT en 1975, cuando Guy L. Steele y Gerarld J. Sussman buscaban un lenguaje con una sem\u00e1ntica muy clara y sencilla. Scheme es un dialecto de Lisp, es un lenguaje interpretado, muy expresivo y soporta varios paradigmas. Estuvo influenciado por el c\u00e1lculo lambda. El desarrollo de Scheme ha sido lento, ya que la gente que estandariz\u00f3 Scheme es muy conservadora en cuanto a a\u00f1adirle nuevas caracter\u00edsticas,porque la calidad ha sido siempre m\u00e1s importante que la utilidad empresarial. Por eso Scheme es considerado como uno de los lenguajes mejor dise\u00f1ados de prop\u00f3sito general. Aprender Scheme har\u00e1 que se\u00e1is mejores programadores cuando utilic\u00e9is otros lenguajes de programaci\u00f3n. 1.1. El lenguaje de programaci\u00f3n Racket \u00b6 \u00bfQu\u00e9 vamos a aprender? \u00bfRacket o Scheme? La respuesta es: Scheme trabajando en Racket. Racket se dise\u00f1\u00f3 en 1995 bas\u00e1ndose en Scheme y ampli\u00e1ndolo con nuevas funcionalidades, como la posibilidad de extenderlo con librer\u00edas. El lenguaje contiene librer\u00edas muy \u00fatiles (librer\u00edas gr\u00e1ficas, de conexi\u00f3n a servidores HTTP, de conexi\u00f3n a bases de datos, etc.) con las que se moderniza el lenguaje original y se convierte en un lenguaje pr\u00e1ctico para desarrollar todo tipo de aplicaciones, desde videojuegos a servidores web. Sin embargo, nosotros s\u00f3lo vamos a usar Racket para aprender la parte que corresponde al n\u00facleo original de Scheme. 1.2. El entorno de programaci\u00f3n DrRacket \u00b6 Veamos una peque\u00f1a introducci\u00f3n al entorno de programaci\u00f3n que proporciona DrRacket. Puedes encontrar m\u00e1s informaci\u00f3n en la documentaci\u00f3n original . 1.2.1. Descarga de DrRacket \u00b6 DrRacket es multiplataforma y puede ejecutarse en Linux, MacOS o Windows. Puedes descargarte la \u00faltima versi\u00f3n en el siguiente enlace: Descarga de DrRacket 1.2.2. Configuraci\u00f3n de DrRacket \u00b6 Para poder trabajar correctamente con DrRacket debemos asegurarnos que el lenguaje activo es The Racket Language y que la sintaxis de la salida tiene activada la opci\u00f3n write , como aparece en la siguiente imagen: Podemos modificar esa opci\u00f3n con los siguientes men\u00fas: Language > Choose Language (seleccionamos The Racket Language) > Show details > Output Syntax > write Esta opci\u00f3n determina la sintaxis de la salida del int\u00e9rprete del lenguaje, que va a ser uno de los elementos fundamentales para aprender Scheme. Aviso Una vez seleccionadas estas opciones, la configuraci\u00f3n se guarda en las preferencias del usuario. En los laboratorios de la EPS hay que realizar la configuraci\u00f3n al comienzo de cada sesi\u00f3n. Cuando lanzamos DrRacket, vemos que tiene tres partes: una fila de botones arriba, dos paneles de edici\u00f3n en el medio y una barra de estado abajo. El panel de edici\u00f3n superior es la ventana de definiciones. Se utiliza para implementar funciones, como la funci\u00f3n cuadrado en el ejemplo. El panel inferior, llamado ventana de interacci\u00f3n , se utiliza para evaluar expresiones interactivamente, usando el int\u00e9rprete de Racket. Pulsando el bot\u00f3n Run , se eval\u00faa el programa de la ventana de definiciones , haciendo que esas definiciones est\u00e9n disponibles en la ventana de interacci\u00f3n. As\u00ed, dada la definici\u00f3n de cuadrado , despu\u00e9s de pulsar Run , podemos teclear la expresi\u00f3n (cuadrado 2) en el int\u00e9rprete, se evaluar\u00e1 y mostrar\u00e1 el resultado, en este caso 4. DrRacket soporta muchos lenguajes y dialectos de Scheme. Nosotros vamos a utilizar el lenguaje por defecto, el lenguaje Racket . Para ello no es necesario realizar nada, s\u00f3lo asegurarnos de lo siguiente: En la parte inferior de la ventana aparece \" Determine language from source \" El fichero que se est\u00e1 editando en el panel de edici\u00f3n comienza con la l\u00ednea: #lang racket Finalmente, si pulsamos el bot\u00f3n Run (Ejecutar) comprobaremos que se carga ese lenguaje en el int\u00e9rprete. 1.2.3. Cambiar el idioma del entorno \u00b6 Podemos interactuar con el entorno en el idioma que queramos. Si queremos tenerlo por ejemplo en espa\u00f1ol, vamos al men\u00fa Help -> Interact\u00faa con DrRacket en espa\u00f1ol . Nos aparecer\u00e1 un di\u00e1logo que nos obligar\u00e1 a reiniciar el int\u00e9rprete para aceptar los cambios. 1.2.4. C\u00f3mo escribir en el int\u00e9rprete \u00b6 En la ventana inferior se encuentra el int\u00e9rprete de Racket. El int\u00e9rprete realiza un bucle en el que se lee una expresi\u00f3n, se eval\u00faa su resultado y se imprime. A este tipo de bucle se denomina en ingl\u00e9s REPL ( Read-Evaluate-Print Loop ). Las expresiones que escribimos en el int\u00e9rprete se guardan en un hist\u00f3rico. Podemos recuperar las expresiones anteriores y movernos por ese hist\u00f3rico usando las siguientes combinaciones de teclas: CTRL + flecha arriba/abajo Puede ser que esa combinaci\u00f3n de teclas est\u00e9 asignada a otras funciones en tu configuraci\u00f3n de sistema operativo. Puedes cambiar esa configuraci\u00f3n o usar la combinaci\u00f3n alternativa de DrRacket: ESC + p (previous) / n (next) Tambi\u00e9n podemos seleccionar con el cursor una expresi\u00f3n y al pulsar RETURN se copia autom\u00e1ticamente en el prompt . 2. El lenguaje Scheme \u00b6 2.1. Vamos a empezar probando algunos ejemplos \u00b6 Scheme es un lenguaje interpretado. Vamos a lanzar DrRacket y teclear en la ventana de interacci\u00f3n algunas expresiones. El int\u00e9rprete analizar\u00e1 la expresi\u00f3n y mostrar\u00e1 el valor resultante de evaluarla. 2 ; \u21d2 2 ( + 2 3 ) ; \u21d2 5 ( + ) ; \u21d2 0 ( + 2 4 5 6 ) ; \u21d2 17 ( + ( * 2 3 ) ( - 3 1 )) ; \u21d2 8 Las expresiones en Scheme tienen una forma denominada notaci\u00f3n prefija de Cambridge (el nombre de Cambridge es por la localidad Cambridge, Massachusets, donde reside el MIT, lugar en el que se ide\u00f3 el Lisp), en la que la expresi\u00f3n est\u00e1 delimitada por par\u00e9ntesis y el operador va seguido de los operandos. La sintaxis es la siguiente: ( <funci\u00f3n> <arg1> ... <argn> ) En Scheme podemos interpretar los par\u00e9ntesis abiertos \u2018(\u2019 como evaluadores o lanzadores de la funci\u00f3n que hay a continuaci\u00f3n. La forma que tiene Scheme de evaluar una expresi\u00f3n es muy sencilla: Eval\u00faa cada uno de los argumentos Aplica la funci\u00f3n nombrada tras el par\u00e9ntesis a los valores resultantes de la evaluaci\u00f3n anterior (+ (* 2 3) (- 3 (/ 12 3))) \u21d2 (+ 6 (- 3 (/ 12 3))) \u21d2 (+ 6 (- 3 4)) \u21d2 (+ 6 -1) \u21d2 5 En Scheme los t\u00e9rminos funci\u00f3n y procedimiento significan lo mismo y se usan de forma intercambiable. Son ejemplos de funciones o procedimientos: +, -, *. En Scheme la evaluaci\u00f3n de una funci\u00f3n siempre devuelve un valor, a no ser que se produzca un error que detiene la evaluaci\u00f3n: ( * ( + 3 4 ) ( / 3 0 )) ; Error /: division by zero 2.2. Definiendo variables y funciones \u00b6 Scheme es un lenguaje multiparadigma pero principalmente funcional, y una de sus caracter\u00edsticas principales es que los programas se construyen mediante la definici\u00f3n de funciones. Podemos utilizar en el int\u00e9rprete la forma especial define para definir variables y funciones. En clase de teor\u00eda veremos c\u00f3mo es el funcionamiento del define , pero por el momento lo utilizaremos para definir variables asociadas a valores, y para implementar funciones. Podemos definir variables en la ventana de interacci\u00f3n para facilitar la escritura de expresiones: ( define pi 3.14159 ) pi ; \u21d2 3.14159 ( sin ( / pi 2 )) ; \u21d2 0.9999999999991198 ( define a ( + 2 ( * 3 4 ))) a ; \u21d2 14 Para implementar una funci\u00f3n tambi\u00e9n se utiliza define, con la siguiente sintaxis: ( define ( <nombre-funcion> <args> ) <cuerpo-funcion> ) Por ejemplo, vamos a implementar una funci\u00f3n que toma dos n\u00fameros como par\u00e1metros y devuelve la suma de sus cuadrados: ( define ( suma-cuadrados x y ) ( + ( * x x ) ( * y y ))) Si llamamos a la funci\u00f3n pasando el 2 y el 3 como par\u00e1metros, la funci\u00f3n devuelve el n\u00famero 13: ( suma-cuadrados 2 3 ) ; \u21d2 13 Nota A diferencia de la mayor\u00eda de lenguajes de programaci\u00f3n, en Scheme no se utiliza la palabra return para indicar que una funci\u00f3n devuelve un valor. Las funciones se definen con una \u00fanica expresi\u00f3n y el resultado calculado en esa expresi\u00f3n es el que siempre se devuelve. 2.3. Lenguaje d\u00e9bilmente tipado \u00b6 Vamos a comprobar una caracter\u00edstica muy importante de Scheme: ser un lenguaje d\u00e9bilmente tipado . Por esto entendemos, entre otras cosas, que las variables, funciones y argumentos no tienen un tipo declarado. Es posible usar valores de distintos tipos de datos para asignar sucesivamente a una misma variable (en el caso de un lenguaje imperativo) o para pasar como par\u00e1metro a una misma funci\u00f3n (en el caso de un lenguaje funcional). Por ejemplo, JavaScript o PHP son tambi\u00e9n lenguajes d\u00e9bilmente tipados imperativos. Veamos c\u00f3mo funciona esto en Scheme usando la funci\u00f3n anterior como ejemplo. ( define ( suma-cuadrados x y ) ( + ( * x x ) ( * y y ))) Vemos que los argumentos x e y no tienen ning\u00fan tipo. Si se invoca a la funci\u00f3n pasando alg\u00fan dato que no sea un n\u00famero, el int\u00e9rprete no detectar\u00e1 ning\u00fan error y permitir\u00e1 asignar a los argumentos x e y esos datos. El error se produce en el momento en que se intenta evaluar la multiplicaci\u00f3n. Lo podemos comprobar con el siguiente ejemplo, en el que se muestra el mensaje de error resultante: > ( suma-cuadrados 10 \"hola\" ) *: contract violation expected: number? given: \"hola\" argument position: 1st other arguments...: Veremos m\u00e1s adelante que hay distintos tipos de n\u00fameros que podemos operar usando la divisi\u00f3n, la suma y la multiplicaci\u00f3n. La funci\u00f3n definida va a funcionar bien para todos ello. Podemos pasar a la funci\u00f3n n\u00fameros enteros, n\u00fameros reales o incluso fracciones: ( suma-cuadrados 2 5 ) ; \u21d2 29 ( suma-cuadrados 2.4 5.8 ) ; \u21d2 39.4 ( suma-cuadrados ( / 2 3 ) ( / 3 5 )) ; \u21d2 181/225 En la \u00faltima expresi\u00f3n tambi\u00e9n pueden pasarse directamente los n\u00fameros fracionales, el int\u00e9rprete de Scheme entiende esa notaci\u00f3n: ( suma-cuadrados 2/3 3/5 ) ; \u21d2 181/225 2.4. Tipos de datos simples \u00b6 Las primitivas de Scheme consisten en un conjunto de tipos de datos, formas especiales y funciones incluidas en el lenguaje. A lo largo del curso iremos introduciendo estas primitivas. Vamos a revisar algunos tipos de datos simples de Scheme, as\u00ed como algunas funciones primitivas para trabajar con valores de esos tipos. Booleanos N\u00fameros Caracteres 2.4.1. Booleanos \u00b6 Un booleano es un valor de verdad, que puede ser verdadero o falso. En Scheme, tenemos los s\u00edmbolos #t y #f para expresar verdadero y falso respectivamente, pero en muchas operaciones se considera que cualquier valor distinto de #f es verdadero. Ejemplos: #t ; verdadero #f ; falso ( > 3 1.5 ) ; \u21d2 #t ( = 3 3.0 ) ; \u21d2 #t (igualdad matem\u00e1tica) ( equal? 3 3.0 ) ; \u21d2 #f (igualdad de tipo) ( or ( < 3 1.5 ) #t ) ; \u21d2 #t ( and #t #t #f ) ; \u21d2 #f ( not #f ) ; \u21d2 #t ( not 3 ) ; \u21d2 #f (permite cualquier argumento; ; s\u00f3lo devuelve #t cuando el argumento es #f) 2.4.2. N\u00fameros \u00b6 La cantidad de tipos num\u00e9ricos que soporta Scheme es grande, incluyendo enteros de diferente precisi\u00f3n, n\u00fameros racionales, complejos e inexactos. Por ejemplo: ( / 1 3 ) ; \u21d2 Devuelve la fracci\u00f3n 1/3 ( + 1/3 1/3 ) ; \u21d2 2/3 ( + 2 3 4 2 ) ; \u21d2 11 (la funci\u00f3n + admite un n\u00famero variable de argumentos) ( + 1/3 0.0 ) ; n\u00famero real con infinita precisi\u00f3n \u21d2 0.3333333333333333 ( * ( + 1/3 0.0 ) 3 ) ; \u21d2 1 ( sqrt -1 ) ; \u21d2 0+1i (n\u00famero imaginario) ( + 3+2i 2-i ) ; \u21d2 5+1i (operaciones con n\u00fameros imaginarios) 2.4.2.1. Algunas primitivas sobre n\u00fameros \u00b6 ( <= 2 3 3 4 5 ) ; \u21d2 #t (los argumentos est\u00e1n en orden creciente) ( max 3 5 10 1000 ) ; \u21d2 #1000 ( / 22 4 ) ; Devuelve una fracci\u00f3n ( quotient 22 4 ) ; \u21d2 5 (cociente de la divisi\u00f3n entera) ( remainder 22 4 ) ; \u21d2 2 (resto de la divisi\u00f3n entera) ( equal? 0.5 ( / 1 2 )) ; \u21d2 #f (distintos tipos de datos) ( = 0.5 ( / 1 2 )) ; \u21d2 #t (igualdad matem\u00e1tica) ( abs ( * 3 -2 )) ; \u21d2 6 (valor absoluto) ( sin 2.2 ) ; relacionados: cos, tan, asin, acos, ata 2.4.2.2. Funciones de redondeo \u00b6 ; (floor x) devuelve el entero m\u00e1s grande no mayor que x ; (ceiling x) devuelve el entero m\u00e1s peque\u00f1o no menor que x ; (truncate x) devuelve el entero m\u00e1s cercano a x cuyo valor absoluto ; no es mayor que el valor absoluto de x ; (round x) devuelve el entero m\u00e1s cercano a x, redondeado ( floor -4.3 ) ; \u21d2 -5.0 ( floor 3.5 ) ; \u21d2 3.0 ( ceiling -4.3 ) ; \u21d2 -4.0 ( ceiling 3.5 ) ; \u21d2 4.0 ( truncate -4.3 ) ; \u21d2 -4.0 ( truncate 3.5 ) ; \u21d2 3.0 ( round -4.3 ) ; \u21d2 -4.0 ( round 3.5 ) ; \u21d2 4.0 2.4.2.3. Predicados sobre n\u00fameros \u00b6 Se denominan predicados a funciones que devuelven un booleano. ( positive? -4 ) ; \u21d2 #f (-4 no es positivo) ( negative? -4 ) ; \u21d2 #t (-4 es negativo) ( zero? 0.2 ) ; \u21d2 #f (comprueba si el resultado es cero) ( even? 2 ) ; \u21d2 #t (comprueba si es par) ( odd? 3 ) ; \u21d2 #t (comprueba si es impar) En Scheme tenemos predicados que nos permiten comprobar el tipo de un par\u00e1metro. En el caso de los n\u00fameros, el tipo de n\u00famero: ( number? 1 ) ; \u21d2 #t (el argumento 1 es un n\u00famero) ( integer? 2.3 ) ; \u21d2 #f (el argumento 2.3 no es un entero) ( integer? 4.0 ) ; \u21d2 #t (el n\u00famero 4.0 matem\u00e1ticamente es id\u00e9ntico ; al n\u00famero 4) ( real? 1 ) ; \u21d2 #t 2.4.3. Caracteres \u00b6 Se soportan caracteres internacionales y se codifican en UTF-8. #\\a #\\A #\\space #\\\u00f1 #\\\u00e1 2.4.3.1. Operaciones sobre caracteres \u00b6 ( char<? #\\a #\\b ) ; \u21d2 #t (el car\u00e1cter #\\a es anterior al #\\b) ( char-numeric? #\\1 ) ; \u21d2 #t (el car\u00e1cter #\\1 es un n\u00famero) ( char-alphabetic? #\\3 ) ; \u21d2 #f (el car\u00e1cter #\\3 es un n\u00famero) ( char-whitespace? #\\tab ) ; \u21d2 #t (el car\u00e1cter tabulador es un espacio ; en blanco) ( char-upper-case? #\\A ) ; \u21d2 #t (el car\u00e1cter #\\A es una letra may\u00fascula) ( char-lower-case? #\\a ) ; \u21d2 #t (el car\u00e1cter #\\a es una letra min\u00fascula) ( char-upcase #\\\u00f1 ) ; \u21d2 #\\\u00d1 (transforma la letra a may\u00fasculas) ( char-downcase #\\A ) ; \u21d2 #\\a (transforma la letra a min\u00fasculas) ( char->integer #\\space ) ; \u21d2 32 (el car\u00e1cter espacio ocupa la posici\u00f3n ; 32 en la lista de caracteres) ( integer->char 32 ) ; \u21d2 #\\space (igual que antes pero a la inversa) ( char->integer ( integer->char 5000 )) ; \u21d2 5000 2.5. Tipos de datos compuestos \u00b6 Scheme tiene tambi\u00e9n un conjunto de tipos de datos compuestos, que permiten aglutinar elementos simples de los tipos de datos vistos anteriormente. Cadenas Parejas Listas Estos dos \u00faltimos los veremos en detalle en futuras clases de teor\u00eda. 2.5.1. Cadenas \u00b6 Las cadenas son secuencias finitas de caracteres. \"hola\" \"La palabra \\\" hola \\\" tiene 4 letras\" 2.5.2. Constructores de cadenas \u00b6 ( make-string 5 #\\o ) ; \u21d2 \"ooooo\" (funci\u00f3n constructora que recibe un ; entero y un car\u00e1cter) ( string #\\h #\\o #\\l #\\a ) ; \u21d2 \"hola\" (funci\u00f3n constructora que recibe ; un n\u00famero variable de caracteres) 2.5.3. Operaciones con cadenas \u00b6 ( substring \"Hola que tal\" 2 4 ) ; \u21d2 \"la\" (subcadena que va de la ; posici\u00f3n 2 a la 4, sin llegar a ella) ( string? \"hola\" ) ; \u21d2 #t (predicado que comprueba que el argumento es ; una cadena) ( string->list \"hola\" ) ; \u21d2 (#\\h #\\o #\\l #\\a) (devuelve una lista de ; caracteres) ( string-length \"hola\" ) ; \u21d2 4 (longitud de la cadena) ( string-ref \"hola\" 0 ) ; \u21d2 #\\h (car\u00e1cter en la posici\u00f3n 0) ( string-append \"hola\" \"adios\" ) ; \u21d2 \"holaadios\" (concatenaci\u00f3n de cadenas) 2.5.4. Comparadores de cadenas \u00b6 ( string=? \"Hola\" \"hola\" ) ; \u21d2 #f ( string=? \"hola\" \"hola\" ) ; \u21d2 #t ( string<? \"aab\" \"cde\" ) ; \u21d2 #t (se compara usando el orden lexicogr\u00e1fico) ( string>=? \"www\" \"qqq\" ) ; \u21d2 #t 2.6. Parejas \u00b6 Elemento fundamental de Scheme. Es un tipo compuesto formado por dos elementos (no necesariamente del mismo tipo). ( cons 1 2 ) ; \u21d2 (1 . 2) (cons crea una pareja) ( cons #t 3 ) ; \u21d2 (#t . 3) (elementos de tipos diferentes) ( car ( cons \"hola\" 2 )) ; \u21d2 \"hola\" (elemento izquierdo de la pareja) ( cdr ( cons \"bye\" 5 )) ; \u21d2 5 (elemento derecho de la pareja) Cuando evaluamos las expresiones anteriores en el int\u00e9rprete, Scheme muestra el resultado de construir la pareja con la sintaxis: (elemento izquierdo . elemento derecho) Por ejemplo: ( cons 1 2 ) ; \u21d2 (1 . 2) La caracter\u00edstica de Scheme de que las expresiones se eval\u00faan de dentro a afuera se aplica a todas las funciones, incluyendo esta funci\u00f3n cons que construye parejas: ( cons ( + 2 3 ) ( string-append \"hola\" \"adios\" )) ; \u21d2 (5 . \"holaadios\") ( cons ( = 2 2.0 ) ( * 2 ( + 1 3 ))) ; \u21d2 (#t . 8) Las parejas pueden contener tambi\u00e9n otras parejas. Veremos que esta es la forma de definir estructuras de datos en Scheme: ( define p1 ( cons 1 2 )) ; definimos una pareja formada por 1 y 2 ( cons p1 3 ) ; definimos una pareja formada por la pareja (1 . 2) y 3 ; \u21d2 ((1 . 2) . 3) ( cons ( cons 1 2 ) 3 ) ; igual que la expresi\u00f3n anterior ; \u21d2 ((1 . 2) . 3) Hay veces que el trabajo de imprimir una pareja no es tan sencillo para Scheme. Si la pareja est\u00e1 en la parte derecha de la pareja principal el int\u00e9rprete imprime esto, que no se corresponde con lo que esperamos: ( cons 1 ( cons 2 3 )) ; \u21d2 (1 2 . 3) M\u00e1s adelante explicaremos por qu\u00e9. 2.7. Listas \u00b6 Uno de los elementos fundamentales de Scheme, y de Lisp, son las listas. Es un tipo compuesto formado por un conjunto finito de elementos (no necesariamente del mismo tipo). Vamos a ver c\u00f3mo definir, crear, recorrer y concatenar listas: Podemos crear una lista con la funci\u00f3n list : ( list 1 2 3 4 ) ;list crea una lista Las listas se representan entre par\u00e9ntesis: ( list 1 2 3 4 ) ; \u21d2 (1 2 3 4) La forma m\u00e1s sencilla de trabajar con una lista es usando las funciones first para obtener su primer elemento y rest para obtener el resto de la lista. ( define l1 ( list 1 2 3 4 )) ; se crea la lista (1 2 3 4) y se guarda en l1 ( first l1 ) ; \u21d2 1 (primer elemento de l1) ( rest l1 ) ; \u21d2 (2 3 4) (resto de la lista, resultado de quitar a la ; lista su primer elemento) Las operaciones sobre listas construyen listas nuevas y no modifican la lista que se pasa como argumento. En el ejemplo anterior, la lista l1 sigue conteniendo la lista original (1 2 3 4) . El rest de una lista siempre devuelve otra lista. El rest de una lista de un elemento es la lista vac\u00eda , que en Scheme se representa con () . ( define l2 ( list 1 2 3 )) ( rest l2 ) ; \u21d2 (2 3) ( rest ( rest l2 )) ; \u21d2 (3) ( rest ( rest ( rest l2 ))) ; \u21d2 () lista vac\u00eda null ; \u21d2 () lista vac\u00eda En Racket se define tambi\u00e9n el identificador null que tiene como valor la lista vac\u00eda: null ; \u21d2 () lista vac\u00eda En Scheme las listas se implementan con parejas. Una lista es, o bien una lista vac\u00eda () o bien una pareja cuyo primer elemento es el primer elemento de la lista y su segundo elemento es el resto de la lista. Veremos esto con m\u00e1s detalle m\u00e1s adelante. Dado que una lista se implementa con una pareja, las funciones car y cdr tambi\u00e9n se pueden usar con listas. La funci\u00f3n car nos devuelve el primer elemento de la lista y la funci\u00f3n cdr el resto: ( define l3 ( list 10 20 30 40 )) ; ( car l3 ) ; \u21d2 10 ( cdr l3 ) ; \u21d2 (20 30 40) Otra forma de definir una lista es usando el quote , una comilla colocada al comienzo de la lista. Veremos en teor\u00eda una explicaci\u00f3n m\u00e1s detallada de c\u00f3mo funciona este quote . Por ejemplo, podemos definir listas usando las las siguientes expresiones: ' ( 1 2 3 ) ; \u21d2 Construye la lista (1 2 3) ( rest ' ( 1 2 3 )) ; \u21d2 (2 3) ( define l3 ' ( 1 2 3 )) ; Construye la lista (1 2 3) y la guarda en l3 Durante el seminario usaremos tanto la funci\u00f3n list como el quote para construir listas. La funci\u00f3n list sin argumentos devuelve una lista vac\u00eda y la funci\u00f3n null? comprueba si una lista es vac\u00eda. La lista vac\u00eda tambi\u00e9n se puede definir usando quote : '() . Veremos m\u00e1s adelante que la lista vac\u00eda es el caso base de gran parte de funciones recursivas que recorren listas. ( list ) ; \u21d2 () ( null? ( list )) ; \u21d2 #t ( null? ' ()) ; \u21d2 #t ( null? ( list 1 2 3 )) ; \u21d2 #f Tambi\u00e9n podemos construir una nueva lista a\u00f1adiendo un elemento a la cabeza de una lista existente, usando la funci\u00f3n cons (la misma funci\u00f3n sobre pareja) usando como par\u00e1metro un elemento y una lista: ( cons elemento lista ) Por ejemplo: ( cons 1 ' ( 2 3 4 5 )) ; \u21d2 (1 2 3 4 5) (se a\u00f1ade 1 a la cabeza de ; la lista (2 3 4 5) ( cons 1 ' ()) ; \u21d2 (1) (se a\u00f1ade 1 a la lista vac\u00eda ( cons 1 ( cons 2 ( list ))) ; \u21d2 (1 2) ( cons 1 ( cons 2 ( cons 3 ' ()))) ; \u21d2 (1 2 3) Importante Cuando queramos a\u00f1adir un dato a la cabeza de una lista la lista siempre debe ser el segundo par\u00e1metro de la llamada a la funci\u00f3n. Si nos equivocamos y pasamos la lista como primer par\u00e1metro y el dato a a\u00f1adir como segundo, Scheme no da un error sino que construye una pareja cuyo primer elemento es una lista y su segundo elemento es el dato. Por ejemplo: ( cons ' ( 1 2 3 ) 4 ) ; \u21d2 ((1 2 3) . 4) Tambi\u00e9n podemos usar la funci\u00f3n append para concatenar dos o m\u00e1s listas ( define l3 ( list 1 )) ( define l4 ( list 2 3 4 )) ( define l5 ( list 5 6 )) ( append l3 l4 l5 ) ; \u21d2 (1 2 3 4 5 6) ( append l3 ' ()) ; \u21d2 (1) ( append ( list 1 2 3 ) ( list 4 )) ; \u21d2 (1 2 3 4) Nota Si queremos a\u00f1adir un dato al final de una lista podemos hacerlo convirti\u00e9ndolo en una lista y usando append para concatenar la lista resultante al final de la primera: ;;; Definimos la funci\u00f3n cons-al-final ( define ( a\u00f1ade-al-final x lista ) ( append lista ( list x ))) ;;; La probamos ( a\u00f1ade-al-final 10 ( list 1 2 3 )) ; \u21d2 (1 2 3 10) Igual que las parejas, las listas pueden contener distintos tipos de datos: ( list \"hola\" \"que\" \"tal\" ) ; \u21d2 (\"hola\" \"que\" \"tal\") (lista de cadenas) ( cons \"hola\" ( list #t #\\a 3 4 )) ; \u21d2 (\"hola\" #t #\\a 3 4) lista de distintos ; tipos de datos) Una lista puede incluso contener otras listas: ( list ( list 1 2 ) 3 4 ( list 5 6 )) ; \u21d2 ((1 2) 3 4 (5 6)) (lista que contiene listas) ' (( 1 2 ) 3 4 ( 5 6 )) ; \u21d2 La misma lista, definida con quote ( cons ( list 1 2 ) ( list 3 4 5 )) ; \u21d2 ((1 2) 3 4 5)) (se a\u00f1ade una ; lista como primer elemento) ( cons ' ( 1 2 ) ' ( 3 4 5 )) ; \u21d2 La misma expresi\u00f3n anterior, con quote La caracter\u00edstica de Scheme de que las expresiones se eval\u00faan de dentro a afuera se aplica a todas las funciones, incluyendo est\u00e1 funci\u00f3n list que construye listas: ( list ( + 1 2 ) ( string-append \"hola\" \"adios\" ) ( * 2 3 )) ; \u21d2 (3 \"holaadios\" 6) ( list ( cons 1 2 ) ( cons 3 4 )) ; \u21d2 ((1 . 2) (3 . 4)) (lista que contiene parejas) En clase de teor\u00eda estudiaremos con m\u00e1s profundidad las listas en Scheme, c\u00f3mo est\u00e1n implementadas y c\u00f3mo se utilizan para crear otras estructuras de datos m\u00e1s complejas como \u00e1rboles. Para este seminario de introducci\u00f3n es suficiente con estas funciones b\u00e1sicas que nos permiten crear, combinar y obtener elementos de listas. 3. Estructuras de control \u00b6 Como en cualquier lenguaje de programaci\u00f3n, las estructuras de control en Scheme nos permiten seleccionar qu\u00e9 parte de una expresi\u00f3n evaluamos en funci\u00f3n de la evaluaci\u00f3n de una expresi\u00f3n condicional. Las estructuras de control las veremos con m\u00e1s detenimiento en las clases de teor\u00eda, ahora por el momento vamos a ver ejemplos de funcionamiento. En Scheme tenemos dos tipos de estructuras de control: if y cond . 3.1. if \u00b6 Realiza una evaluaci\u00f3n condicional de las expresiones que la siguen, seg\u00fan el resultado de una condici\u00f3n. Una expresi\u00f3n if tiene siempre cuatro elementos: el propio if , la condici\u00f3n, la expresi\u00f3n que se eval\u00faa si la condici\u00f3n es verdadera y la expresi\u00f3n que se eval\u00faa si la expresi\u00f3n es falsa: ( if ( > 2 3 ) \"2 es mayor que 3\" \"2 es menor o igual que 3\" ) Al escribir c\u00f3digo en Scheme es habitual colocar el if y la condici\u00f3n en una l\u00ednea y las otras dos expresiones en las siguientes l\u00edneas: ( if ( > 2 3 ) \"2 es mayor que 3\" \"2 es menor o igual que 3\" ) En las expresiones que devuelven el valor cuando la condici\u00f3n es cierta o falsa se puede escribir cualquier expresi\u00f3n de Scheme, incluido otro if : ( if ( > 2 3 ) ( if ( < 10 5 ) \"2 es mayor que 3 y 10 es menor que 5\" \"2 es mayor que 3 y 10 es mayor o igual que 5\" ) \"2 es menor o igual que 3\" ) Un ejemplo en el que vemos una funci\u00f3n que contiene un if . La siguiente funci\u00f3n de tres argumentos devuelve la suma de los \u00faltimos si el primero es positivo o la resta en caso contrario: ( define ( suma-si-x-positivo x y z ) ( if ( >= x 0 ) ( + y z ) ( - y z ))) ( suma-si-x-positivo 2 3 5 ) ; \u21d2 8 ( suma-si-x-positivo -3 3 5 ) ; \u21d2 -2 3.2. cond \u00b6 Cuando tenemos un conjunto de alternativas o para evitar usar ifs anidados. cond eval\u00faa una serie de condiciones y devuelve el valor de la expresi\u00f3n asociada a la primera condici\u00f3n verdadera. ( cond (( > 3 4 ) \"3 es mayor que 4\" ) (( < 2 1 ) \"2 es menor que 1\" ) (( > 3 2 ) \"3 es mayor que 2\" ) ( else \"ninguna condicion es cierta\" )) 4. Comentarios \u00b6 Para comentar una l\u00ednea de c\u00f3digo en la ventana de definiciones, se escribe el s\u00edmbolo punto y coma ; al comienzo de la l\u00ednea. Si queremos comentar m\u00e1s de una l\u00ednea, podemos utilizar el men\u00fa de DrRacket: seleccionamos las l\u00edneas a comentar y pinchamos en la opci\u00f3n Racket -> comentar con punto y coma. 5. Ejemplos completos \u00b6 5.1. Ra\u00edz de segundo grado \u00b6 Vamos a resolver la ecuaci\u00f3n de segundo grado en Scheme. Vamos a implementar el procedimiento (ecuacion a b c) que devuelva una pareja con las dos ra\u00edces de la soluci\u00f3n. Nos vamos a ayudar de funciones auxiliares. Recordamos la f\u00f3rmula: x = {-b \\pm \\sqrt{b^2-4ac} \\over 2a} x = {-b \\pm \\sqrt{b^2-4ac} \\over 2a} Nota En lugar de definir una funci\u00f3n con una expresi\u00f3n muy larga compuesta de muchas expresiones anidadas, vamos a implementar la soluci\u00f3n de forma modular, definiendo funciones auxiliares . Primer definimos la funci\u00f3n que define el discriminante: ( define ( discriminante a b c ) ( - ( * b b ) ( * 4 a c ))) Despu\u00e9s definimos las funciones que devuelven la ra\u00edz positiva y la ra\u00edz negativa, usando la funci\u00f3n discriminante anterior: ( define ( raiz-pos a b c ) ( / ( + ( * b -1 ) ( sqrt ( discriminante a b c ))) ( * 2 a ))) ( define ( raiz-neg a b c ) ( / ( - ( * b -1 ) ( sqrt ( discriminante a b c ))) ( * 2 a ))) Por \u00faltimo, definimos la funci\u00f3n ecuacion que invoca a las funciones anteriores y devuelve una pareja con los valores resultantes: ( define ( ecuacion a b c ) ( cons ( raiz-pos a b c ) ( raiz-neg a b c ))) Lo probamos: ( ecuacion 1 -5 6 ) ; \u21d2 (3 . 2) ( ecuacion 2 -7 3 ) ; \u21d2 (3 . 1/2) ( ecuacion -1 7 -10 ) ; \u21d2 (2 . 5) 5.2. Conversi\u00f3n de grados Celsius a Farenheit \u00b6 Vamos a definir una funci\u00f3n llamada convertir-temperatura que permite realizar una conversi\u00f3n de grados Fahrenheit a Cent\u00edgrados o vicerversa. La funci\u00f3n toma dos argumentos, el primero ser\u00e1 un n\u00famero que representa los grados y el segundo ser\u00e1 un car\u00e1cter ( F o C ) que indica la unidad de medida en la que est\u00e1n expresados los grados. Las f\u00f3rmulas de conversi\u00f3n son las siguientes: C = (F - 32) * 5/9 C = (F - 32) * 5/9 F = (C * 9/5) + 32 F = (C * 9/5) + 32 Primero definimos unas funciones auxiliares que calculan las expresiones anteriores: ( define ( a-grados-fahrenheit grados-centigrados ) ( + ( * ( / 9 5 ) grados-centigrados ) 32 )) ( define ( a-grados-centigrados grados-fahrenheit ) ( * ( / 5 9 ) ( - grados-fahrenheit 32 ))) Y ahora ya podemos definir la funci\u00f3n principal: ( define ( convertir-temperatura grados tipo ) ( cond (( equal? tipo #\\F ) ( list ( a-grados-centigrados grados ) \"grados centigrados\" )) (( equal? tipo #\\C ) ( list ( a-grados-fahrenheit grados ) \"grados fahrenheit\" )) ( else \"tipo de cambio incorrecto\" ))) Por ejemplo: ( convertir-temperatura 50 #\\F ) ; \u21d2 (10 \"grados centigrados\") ( convertir-temperatura 50 #\\C ) ; \u21d2 (122 \"grados fahrenheit\") 6. Pruebas unitarias en Scheme \u00b6 Para verificar que las funciones que definimos tienen un funcionamiento correcto, es decir, \"hacen lo que tienen que hacer\" , podemos dise\u00f1ar distintos casos de prueba. Cada caso de prueba se caracteriza por unos datos de entrada de la funci\u00f3n y por el resultado que esperamos que devuelva dicha funci\u00f3n con esos valores de entrada. Por ejemplo, en las pruebas de la funci\u00f3n convertir-temperatura , hemos dise\u00f1ado dos casos de prueba: Datos de Entrada Resultado Esperado 50 , #\\F (10 \"grados centigrados\") 50 , #\\C (122 \"grados fahrenheit\") El resultado esperado a partir de unos valores concretos de entrada, se determina entendiendo qu\u00e9 debe hacer la funci\u00f3n. Es decir, se obtiene a partir de la especificaci\u00f3n del problema, antes de plantearnos c\u00f3mo solucionarlo. Os aconsejamos tener siempre presente la siguiente idea aunque resulte obvia: Para implementar una funci\u00f3n, primero es imprescindible entender qu\u00e9 debe hacer la funci\u00f3n . Despu\u00e9s, seremos capaces de dise\u00f1ar casos de prueba y ocuparnos de c\u00f3mo implementarla . En las pr\u00e1cticas de la asignatura, para realizar pruebas usaremos la librer\u00eda RackUnit . Para ello, lo primero que tendremos que hacer es importar esta nueva librer\u00eda. Por tanto, debemos a\u00f1adir en nuestros ficheros de pr\u00e1cticas lo siguiente: #lang racket ( require rackunit ) Una vez importada la librer\u00eda, ya podemos hacer uso de algunas de sus funciones. En concreto, utilizaremos las siguientes: check-true ( check-true expr ) ;; Comprueba si su argumento es #t. ;; En caso contrario, se imprime un mensaje de error. check-false ( check-false expr ) ;; Comprueba si su argumento es #f. ;; En caso contrario, se imprime un mensaje de error. check-equal? ( check-equal? resultado-real resultado-esperado ) ;; Comprueba si sus dos argumentos son iguales. ;; En caso contrario, se imprime un mensaje de error. Con las funciones check-true y check-false validaremos predicados (recuerda que en Scheme son funciones que devuelven un valor booleano) que hayamos implementado, comprobando si el resultado esperado es true o false , respectivamente. Con la funci\u00f3n check-equal? podremos validar si el resultado de la invocaci\u00f3n a la funci\u00f3n con unos determinados valores de entrada, representado por el argumento resultado-real , es igual al resultado que esperamos, dado por el argumento resultado-esperado . 6.1. Ejemplo de pruebas de la funci\u00f3n ecuacion definida anteriormente \u00b6 Supongamos la funci\u00f3n completa ecuacion , con pruebas incluidas: #lang racket ( require rackunit ) ( define ( discriminante a b c ) ( - ( * b b ) ( * 4 a c ))) ( define ( raiz-pos a b c ) ( / ( + ( * b -1 ) ( sqrt ( discriminante a b c ))) ( * 2 a ))) ( define ( raiz-neg a b c ) ( / ( - ( * b -1 ) ( sqrt ( discriminante a b c ))) ( * 2 a ))) ( define ( ecuacion a b c ) ( cons ( raiz-pos a b c ) ( raiz-neg a b c ))) ( check-equal? ( ecuacion 1 -5 6 ) ' ( 3 . 2 )) ( check-equal? ( ecuacion 2 -7 3 ) ' ( 3 . 1/2 )) ( check-equal? ( ecuacion -1 7 -10 ) ' ( 2 . 5 )) Las pruebas anteriores no mostrar\u00e1n ning\u00fan mensaje de error, lo que significa que nuestra funci\u00f3n ecuacion es 'CORRECTA' para estas pruebas, es decir, que con los valores de entrada utilizados, su resultado se corresponde con el esperado. Ahora vamos a suponer que nos hemos equivocado en la definici\u00f3n de la funci\u00f3n ecuacion , por ejemplo en el orden de los argumentos al invocar a la funci\u00f3n auxiliar raiz-pos , en la llamada que se hace en la parte izquierda de la pareja resultante. ( define ( ecuacion a b c ) ( cons ( raiz-pos b a c ) ( raiz-neg a b c ))) Con esta nueva definici\u00f3n, cuando ejecutemos el programa (pulsando el bot\u00f3n Run) aparecer\u00e1 el siguiente mensaje: -------------------- FAILURE actual: (-1 . 2) expected: (3 . 2) name: check-equal? location: (#<path:/.../filename.rkt>) expression: (check-equal? (ecuacion 1 -5 6) (cons 3 2)) -------------------- Esta prueba muestra un mensaje de error, lo que significa que la nueva definici\u00f3n de ecuacion 'FALLA', es decir, que el resultado que devuelve (-1 . 2) no coincide con el resultado esperado (3 . 2) . 7. Bibliograf\u00eda \u00b6 Este seminario est\u00e1 basado en los siguientes materiales. Os recomendamos que les ech\u00e9is un vistazo y, si os interesa y os queda tiempo, que explor\u00e9is tambi\u00e9n en los enlaces que hemos dejado en los apuntes para ampliar informaci\u00f3n. The Racket Guide The Racket Reference Simply Scheme Lenguajes y Paradigmas de Programaci\u00f3n, curso 2021-22 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Domingo Gallardo, Cristina Pomares, Antonio Bot\u00eda, Francisco Mart\u00ednez","title":"Seminario de Scheme"},{"location":"seminarios/seminario1-scheme/seminario1-scheme.html#seminario-1-seminario-de-scheme","text":"","title":"Seminario 1: Seminario de Scheme"},{"location":"seminarios/seminario1-scheme/seminario1-scheme.html#1-el-lenguaje-de-programacion-scheme","text":"Scheme es un lenguaje de programaci\u00f3n que surgi\u00f3 en los laboratorios del MIT en 1975, cuando Guy L. Steele y Gerarld J. Sussman buscaban un lenguaje con una sem\u00e1ntica muy clara y sencilla. Scheme es un dialecto de Lisp, es un lenguaje interpretado, muy expresivo y soporta varios paradigmas. Estuvo influenciado por el c\u00e1lculo lambda. El desarrollo de Scheme ha sido lento, ya que la gente que estandariz\u00f3 Scheme es muy conservadora en cuanto a a\u00f1adirle nuevas caracter\u00edsticas,porque la calidad ha sido siempre m\u00e1s importante que la utilidad empresarial. Por eso Scheme es considerado como uno de los lenguajes mejor dise\u00f1ados de prop\u00f3sito general. Aprender Scheme har\u00e1 que se\u00e1is mejores programadores cuando utilic\u00e9is otros lenguajes de programaci\u00f3n.","title":"1. El lenguaje de programaci\u00f3n Scheme"},{"location":"seminarios/seminario1-scheme/seminario1-scheme.html#11-el-lenguaje-de-programacion-racket","text":"\u00bfQu\u00e9 vamos a aprender? \u00bfRacket o Scheme? La respuesta es: Scheme trabajando en Racket. Racket se dise\u00f1\u00f3 en 1995 bas\u00e1ndose en Scheme y ampli\u00e1ndolo con nuevas funcionalidades, como la posibilidad de extenderlo con librer\u00edas. El lenguaje contiene librer\u00edas muy \u00fatiles (librer\u00edas gr\u00e1ficas, de conexi\u00f3n a servidores HTTP, de conexi\u00f3n a bases de datos, etc.) con las que se moderniza el lenguaje original y se convierte en un lenguaje pr\u00e1ctico para desarrollar todo tipo de aplicaciones, desde videojuegos a servidores web. Sin embargo, nosotros s\u00f3lo vamos a usar Racket para aprender la parte que corresponde al n\u00facleo original de Scheme.","title":"1.1. El lenguaje de programaci\u00f3n Racket"},{"location":"seminarios/seminario1-scheme/seminario1-scheme.html#12-el-entorno-de-programacion-drracket","text":"Veamos una peque\u00f1a introducci\u00f3n al entorno de programaci\u00f3n que proporciona DrRacket. Puedes encontrar m\u00e1s informaci\u00f3n en la documentaci\u00f3n original .","title":"1.2. El entorno de programaci\u00f3n DrRacket"},{"location":"seminarios/seminario1-scheme/seminario1-scheme.html#2-el-lenguaje-scheme","text":"","title":"2. El lenguaje Scheme"},{"location":"seminarios/seminario1-scheme/seminario1-scheme.html#21-vamos-a-empezar-probando-algunos-ejemplos","text":"Scheme es un lenguaje interpretado. Vamos a lanzar DrRacket y teclear en la ventana de interacci\u00f3n algunas expresiones. El int\u00e9rprete analizar\u00e1 la expresi\u00f3n y mostrar\u00e1 el valor resultante de evaluarla. 2 ; \u21d2 2 ( + 2 3 ) ; \u21d2 5 ( + ) ; \u21d2 0 ( + 2 4 5 6 ) ; \u21d2 17 ( + ( * 2 3 ) ( - 3 1 )) ; \u21d2 8 Las expresiones en Scheme tienen una forma denominada notaci\u00f3n prefija de Cambridge (el nombre de Cambridge es por la localidad Cambridge, Massachusets, donde reside el MIT, lugar en el que se ide\u00f3 el Lisp), en la que la expresi\u00f3n est\u00e1 delimitada por par\u00e9ntesis y el operador va seguido de los operandos. La sintaxis es la siguiente: ( <funci\u00f3n> <arg1> ... <argn> ) En Scheme podemos interpretar los par\u00e9ntesis abiertos \u2018(\u2019 como evaluadores o lanzadores de la funci\u00f3n que hay a continuaci\u00f3n. La forma que tiene Scheme de evaluar una expresi\u00f3n es muy sencilla: Eval\u00faa cada uno de los argumentos Aplica la funci\u00f3n nombrada tras el par\u00e9ntesis a los valores resultantes de la evaluaci\u00f3n anterior (+ (* 2 3) (- 3 (/ 12 3))) \u21d2 (+ 6 (- 3 (/ 12 3))) \u21d2 (+ 6 (- 3 4)) \u21d2 (+ 6 -1) \u21d2 5 En Scheme los t\u00e9rminos funci\u00f3n y procedimiento significan lo mismo y se usan de forma intercambiable. Son ejemplos de funciones o procedimientos: +, -, *. En Scheme la evaluaci\u00f3n de una funci\u00f3n siempre devuelve un valor, a no ser que se produzca un error que detiene la evaluaci\u00f3n: ( * ( + 3 4 ) ( / 3 0 )) ; Error /: division by zero","title":"2.1. Vamos a empezar probando algunos ejemplos"},{"location":"seminarios/seminario1-scheme/seminario1-scheme.html#22-definiendo-variables-y-funciones","text":"Scheme es un lenguaje multiparadigma pero principalmente funcional, y una de sus caracter\u00edsticas principales es que los programas se construyen mediante la definici\u00f3n de funciones. Podemos utilizar en el int\u00e9rprete la forma especial define para definir variables y funciones. En clase de teor\u00eda veremos c\u00f3mo es el funcionamiento del define , pero por el momento lo utilizaremos para definir variables asociadas a valores, y para implementar funciones. Podemos definir variables en la ventana de interacci\u00f3n para facilitar la escritura de expresiones: ( define pi 3.14159 ) pi ; \u21d2 3.14159 ( sin ( / pi 2 )) ; \u21d2 0.9999999999991198 ( define a ( + 2 ( * 3 4 ))) a ; \u21d2 14 Para implementar una funci\u00f3n tambi\u00e9n se utiliza define, con la siguiente sintaxis: ( define ( <nombre-funcion> <args> ) <cuerpo-funcion> ) Por ejemplo, vamos a implementar una funci\u00f3n que toma dos n\u00fameros como par\u00e1metros y devuelve la suma de sus cuadrados: ( define ( suma-cuadrados x y ) ( + ( * x x ) ( * y y ))) Si llamamos a la funci\u00f3n pasando el 2 y el 3 como par\u00e1metros, la funci\u00f3n devuelve el n\u00famero 13: ( suma-cuadrados 2 3 ) ; \u21d2 13 Nota A diferencia de la mayor\u00eda de lenguajes de programaci\u00f3n, en Scheme no se utiliza la palabra return para indicar que una funci\u00f3n devuelve un valor. Las funciones se definen con una \u00fanica expresi\u00f3n y el resultado calculado en esa expresi\u00f3n es el que siempre se devuelve.","title":"2.2. Definiendo variables y funciones"},{"location":"seminarios/seminario1-scheme/seminario1-scheme.html#23-lenguaje-debilmente-tipado","text":"Vamos a comprobar una caracter\u00edstica muy importante de Scheme: ser un lenguaje d\u00e9bilmente tipado . Por esto entendemos, entre otras cosas, que las variables, funciones y argumentos no tienen un tipo declarado. Es posible usar valores de distintos tipos de datos para asignar sucesivamente a una misma variable (en el caso de un lenguaje imperativo) o para pasar como par\u00e1metro a una misma funci\u00f3n (en el caso de un lenguaje funcional). Por ejemplo, JavaScript o PHP son tambi\u00e9n lenguajes d\u00e9bilmente tipados imperativos. Veamos c\u00f3mo funciona esto en Scheme usando la funci\u00f3n anterior como ejemplo. ( define ( suma-cuadrados x y ) ( + ( * x x ) ( * y y ))) Vemos que los argumentos x e y no tienen ning\u00fan tipo. Si se invoca a la funci\u00f3n pasando alg\u00fan dato que no sea un n\u00famero, el int\u00e9rprete no detectar\u00e1 ning\u00fan error y permitir\u00e1 asignar a los argumentos x e y esos datos. El error se produce en el momento en que se intenta evaluar la multiplicaci\u00f3n. Lo podemos comprobar con el siguiente ejemplo, en el que se muestra el mensaje de error resultante: > ( suma-cuadrados 10 \"hola\" ) *: contract violation expected: number? given: \"hola\" argument position: 1st other arguments...: Veremos m\u00e1s adelante que hay distintos tipos de n\u00fameros que podemos operar usando la divisi\u00f3n, la suma y la multiplicaci\u00f3n. La funci\u00f3n definida va a funcionar bien para todos ello. Podemos pasar a la funci\u00f3n n\u00fameros enteros, n\u00fameros reales o incluso fracciones: ( suma-cuadrados 2 5 ) ; \u21d2 29 ( suma-cuadrados 2.4 5.8 ) ; \u21d2 39.4 ( suma-cuadrados ( / 2 3 ) ( / 3 5 )) ; \u21d2 181/225 En la \u00faltima expresi\u00f3n tambi\u00e9n pueden pasarse directamente los n\u00fameros fracionales, el int\u00e9rprete de Scheme entiende esa notaci\u00f3n: ( suma-cuadrados 2/3 3/5 ) ; \u21d2 181/225","title":"2.3. Lenguaje d\u00e9bilmente tipado"},{"location":"seminarios/seminario1-scheme/seminario1-scheme.html#24-tipos-de-datos-simples","text":"Las primitivas de Scheme consisten en un conjunto de tipos de datos, formas especiales y funciones incluidas en el lenguaje. A lo largo del curso iremos introduciendo estas primitivas. Vamos a revisar algunos tipos de datos simples de Scheme, as\u00ed como algunas funciones primitivas para trabajar con valores de esos tipos. Booleanos N\u00fameros Caracteres","title":"2.4. Tipos de datos simples"},{"location":"seminarios/seminario1-scheme/seminario1-scheme.html#25-tipos-de-datos-compuestos","text":"Scheme tiene tambi\u00e9n un conjunto de tipos de datos compuestos, que permiten aglutinar elementos simples de los tipos de datos vistos anteriormente. Cadenas Parejas Listas Estos dos \u00faltimos los veremos en detalle en futuras clases de teor\u00eda.","title":"2.5. Tipos de datos compuestos"},{"location":"seminarios/seminario1-scheme/seminario1-scheme.html#3-estructuras-de-control","text":"Como en cualquier lenguaje de programaci\u00f3n, las estructuras de control en Scheme nos permiten seleccionar qu\u00e9 parte de una expresi\u00f3n evaluamos en funci\u00f3n de la evaluaci\u00f3n de una expresi\u00f3n condicional. Las estructuras de control las veremos con m\u00e1s detenimiento en las clases de teor\u00eda, ahora por el momento vamos a ver ejemplos de funcionamiento. En Scheme tenemos dos tipos de estructuras de control: if y cond .","title":"3. Estructuras de control"},{"location":"seminarios/seminario1-scheme/seminario1-scheme.html#31-if","text":"Realiza una evaluaci\u00f3n condicional de las expresiones que la siguen, seg\u00fan el resultado de una condici\u00f3n. Una expresi\u00f3n if tiene siempre cuatro elementos: el propio if , la condici\u00f3n, la expresi\u00f3n que se eval\u00faa si la condici\u00f3n es verdadera y la expresi\u00f3n que se eval\u00faa si la expresi\u00f3n es falsa: ( if ( > 2 3 ) \"2 es mayor que 3\" \"2 es menor o igual que 3\" ) Al escribir c\u00f3digo en Scheme es habitual colocar el if y la condici\u00f3n en una l\u00ednea y las otras dos expresiones en las siguientes l\u00edneas: ( if ( > 2 3 ) \"2 es mayor que 3\" \"2 es menor o igual que 3\" ) En las expresiones que devuelven el valor cuando la condici\u00f3n es cierta o falsa se puede escribir cualquier expresi\u00f3n de Scheme, incluido otro if : ( if ( > 2 3 ) ( if ( < 10 5 ) \"2 es mayor que 3 y 10 es menor que 5\" \"2 es mayor que 3 y 10 es mayor o igual que 5\" ) \"2 es menor o igual que 3\" ) Un ejemplo en el que vemos una funci\u00f3n que contiene un if . La siguiente funci\u00f3n de tres argumentos devuelve la suma de los \u00faltimos si el primero es positivo o la resta en caso contrario: ( define ( suma-si-x-positivo x y z ) ( if ( >= x 0 ) ( + y z ) ( - y z ))) ( suma-si-x-positivo 2 3 5 ) ; \u21d2 8 ( suma-si-x-positivo -3 3 5 ) ; \u21d2 -2","title":"3.1. if"},{"location":"seminarios/seminario1-scheme/seminario1-scheme.html#32-cond","text":"Cuando tenemos un conjunto de alternativas o para evitar usar ifs anidados. cond eval\u00faa una serie de condiciones y devuelve el valor de la expresi\u00f3n asociada a la primera condici\u00f3n verdadera. ( cond (( > 3 4 ) \"3 es mayor que 4\" ) (( < 2 1 ) \"2 es menor que 1\" ) (( > 3 2 ) \"3 es mayor que 2\" ) ( else \"ninguna condicion es cierta\" ))","title":"3.2. cond"},{"location":"seminarios/seminario1-scheme/seminario1-scheme.html#4-comentarios","text":"Para comentar una l\u00ednea de c\u00f3digo en la ventana de definiciones, se escribe el s\u00edmbolo punto y coma ; al comienzo de la l\u00ednea. Si queremos comentar m\u00e1s de una l\u00ednea, podemos utilizar el men\u00fa de DrRacket: seleccionamos las l\u00edneas a comentar y pinchamos en la opci\u00f3n Racket -> comentar con punto y coma.","title":"4. Comentarios"},{"location":"seminarios/seminario1-scheme/seminario1-scheme.html#5-ejemplos-completos","text":"","title":"5. Ejemplos completos"},{"location":"seminarios/seminario1-scheme/seminario1-scheme.html#51-raiz-de-segundo-grado","text":"Vamos a resolver la ecuaci\u00f3n de segundo grado en Scheme. Vamos a implementar el procedimiento (ecuacion a b c) que devuelva una pareja con las dos ra\u00edces de la soluci\u00f3n. Nos vamos a ayudar de funciones auxiliares. Recordamos la f\u00f3rmula: x = {-b \\pm \\sqrt{b^2-4ac} \\over 2a} x = {-b \\pm \\sqrt{b^2-4ac} \\over 2a} Nota En lugar de definir una funci\u00f3n con una expresi\u00f3n muy larga compuesta de muchas expresiones anidadas, vamos a implementar la soluci\u00f3n de forma modular, definiendo funciones auxiliares . Primer definimos la funci\u00f3n que define el discriminante: ( define ( discriminante a b c ) ( - ( * b b ) ( * 4 a c ))) Despu\u00e9s definimos las funciones que devuelven la ra\u00edz positiva y la ra\u00edz negativa, usando la funci\u00f3n discriminante anterior: ( define ( raiz-pos a b c ) ( / ( + ( * b -1 ) ( sqrt ( discriminante a b c ))) ( * 2 a ))) ( define ( raiz-neg a b c ) ( / ( - ( * b -1 ) ( sqrt ( discriminante a b c ))) ( * 2 a ))) Por \u00faltimo, definimos la funci\u00f3n ecuacion que invoca a las funciones anteriores y devuelve una pareja con los valores resultantes: ( define ( ecuacion a b c ) ( cons ( raiz-pos a b c ) ( raiz-neg a b c ))) Lo probamos: ( ecuacion 1 -5 6 ) ; \u21d2 (3 . 2) ( ecuacion 2 -7 3 ) ; \u21d2 (3 . 1/2) ( ecuacion -1 7 -10 ) ; \u21d2 (2 . 5)","title":"5.1. Ra\u00edz de segundo grado"},{"location":"seminarios/seminario1-scheme/seminario1-scheme.html#52-conversion-de-grados-celsius-a-farenheit","text":"Vamos a definir una funci\u00f3n llamada convertir-temperatura que permite realizar una conversi\u00f3n de grados Fahrenheit a Cent\u00edgrados o vicerversa. La funci\u00f3n toma dos argumentos, el primero ser\u00e1 un n\u00famero que representa los grados y el segundo ser\u00e1 un car\u00e1cter ( F o C ) que indica la unidad de medida en la que est\u00e1n expresados los grados. Las f\u00f3rmulas de conversi\u00f3n son las siguientes: C = (F - 32) * 5/9 C = (F - 32) * 5/9 F = (C * 9/5) + 32 F = (C * 9/5) + 32 Primero definimos unas funciones auxiliares que calculan las expresiones anteriores: ( define ( a-grados-fahrenheit grados-centigrados ) ( + ( * ( / 9 5 ) grados-centigrados ) 32 )) ( define ( a-grados-centigrados grados-fahrenheit ) ( * ( / 5 9 ) ( - grados-fahrenheit 32 ))) Y ahora ya podemos definir la funci\u00f3n principal: ( define ( convertir-temperatura grados tipo ) ( cond (( equal? tipo #\\F ) ( list ( a-grados-centigrados grados ) \"grados centigrados\" )) (( equal? tipo #\\C ) ( list ( a-grados-fahrenheit grados ) \"grados fahrenheit\" )) ( else \"tipo de cambio incorrecto\" ))) Por ejemplo: ( convertir-temperatura 50 #\\F ) ; \u21d2 (10 \"grados centigrados\") ( convertir-temperatura 50 #\\C ) ; \u21d2 (122 \"grados fahrenheit\")","title":"5.2. Conversi\u00f3n de grados Celsius a Farenheit"},{"location":"seminarios/seminario1-scheme/seminario1-scheme.html#6-pruebas-unitarias-en-scheme","text":"Para verificar que las funciones que definimos tienen un funcionamiento correcto, es decir, \"hacen lo que tienen que hacer\" , podemos dise\u00f1ar distintos casos de prueba. Cada caso de prueba se caracteriza por unos datos de entrada de la funci\u00f3n y por el resultado que esperamos que devuelva dicha funci\u00f3n con esos valores de entrada. Por ejemplo, en las pruebas de la funci\u00f3n convertir-temperatura , hemos dise\u00f1ado dos casos de prueba: Datos de Entrada Resultado Esperado 50 , #\\F (10 \"grados centigrados\") 50 , #\\C (122 \"grados fahrenheit\") El resultado esperado a partir de unos valores concretos de entrada, se determina entendiendo qu\u00e9 debe hacer la funci\u00f3n. Es decir, se obtiene a partir de la especificaci\u00f3n del problema, antes de plantearnos c\u00f3mo solucionarlo. Os aconsejamos tener siempre presente la siguiente idea aunque resulte obvia: Para implementar una funci\u00f3n, primero es imprescindible entender qu\u00e9 debe hacer la funci\u00f3n . Despu\u00e9s, seremos capaces de dise\u00f1ar casos de prueba y ocuparnos de c\u00f3mo implementarla . En las pr\u00e1cticas de la asignatura, para realizar pruebas usaremos la librer\u00eda RackUnit . Para ello, lo primero que tendremos que hacer es importar esta nueva librer\u00eda. Por tanto, debemos a\u00f1adir en nuestros ficheros de pr\u00e1cticas lo siguiente: #lang racket ( require rackunit ) Una vez importada la librer\u00eda, ya podemos hacer uso de algunas de sus funciones. En concreto, utilizaremos las siguientes: check-true ( check-true expr ) ;; Comprueba si su argumento es #t. ;; En caso contrario, se imprime un mensaje de error. check-false ( check-false expr ) ;; Comprueba si su argumento es #f. ;; En caso contrario, se imprime un mensaje de error. check-equal? ( check-equal? resultado-real resultado-esperado ) ;; Comprueba si sus dos argumentos son iguales. ;; En caso contrario, se imprime un mensaje de error. Con las funciones check-true y check-false validaremos predicados (recuerda que en Scheme son funciones que devuelven un valor booleano) que hayamos implementado, comprobando si el resultado esperado es true o false , respectivamente. Con la funci\u00f3n check-equal? podremos validar si el resultado de la invocaci\u00f3n a la funci\u00f3n con unos determinados valores de entrada, representado por el argumento resultado-real , es igual al resultado que esperamos, dado por el argumento resultado-esperado .","title":"6. Pruebas unitarias en Scheme"},{"location":"seminarios/seminario1-scheme/seminario1-scheme.html#61-ejemplo-de-pruebas-de-la-funcion-ecuacion-definida-anteriormente","text":"Supongamos la funci\u00f3n completa ecuacion , con pruebas incluidas: #lang racket ( require rackunit ) ( define ( discriminante a b c ) ( - ( * b b ) ( * 4 a c ))) ( define ( raiz-pos a b c ) ( / ( + ( * b -1 ) ( sqrt ( discriminante a b c ))) ( * 2 a ))) ( define ( raiz-neg a b c ) ( / ( - ( * b -1 ) ( sqrt ( discriminante a b c ))) ( * 2 a ))) ( define ( ecuacion a b c ) ( cons ( raiz-pos a b c ) ( raiz-neg a b c ))) ( check-equal? ( ecuacion 1 -5 6 ) ' ( 3 . 2 )) ( check-equal? ( ecuacion 2 -7 3 ) ' ( 3 . 1/2 )) ( check-equal? ( ecuacion -1 7 -10 ) ' ( 2 . 5 )) Las pruebas anteriores no mostrar\u00e1n ning\u00fan mensaje de error, lo que significa que nuestra funci\u00f3n ecuacion es 'CORRECTA' para estas pruebas, es decir, que con los valores de entrada utilizados, su resultado se corresponde con el esperado. Ahora vamos a suponer que nos hemos equivocado en la definici\u00f3n de la funci\u00f3n ecuacion , por ejemplo en el orden de los argumentos al invocar a la funci\u00f3n auxiliar raiz-pos , en la llamada que se hace en la parte izquierda de la pareja resultante. ( define ( ecuacion a b c ) ( cons ( raiz-pos b a c ) ( raiz-neg a b c ))) Con esta nueva definici\u00f3n, cuando ejecutemos el programa (pulsando el bot\u00f3n Run) aparecer\u00e1 el siguiente mensaje: -------------------- FAILURE actual: (-1 . 2) expected: (3 . 2) name: check-equal? location: (#<path:/.../filename.rkt>) expression: (check-equal? (ecuacion 1 -5 6) (cons 3 2)) -------------------- Esta prueba muestra un mensaje de error, lo que significa que la nueva definici\u00f3n de ecuacion 'FALLA', es decir, que el resultado que devuelve (-1 . 2) no coincide con el resultado esperado (3 . 2) .","title":"6.1. Ejemplo de pruebas de la funci\u00f3n ecuacion definida anteriormente"},{"location":"seminarios/seminario1-scheme/seminario1-scheme.html#7-bibliografia","text":"Este seminario est\u00e1 basado en los siguientes materiales. Os recomendamos que les ech\u00e9is un vistazo y, si os interesa y os queda tiempo, que explor\u00e9is tambi\u00e9n en los enlaces que hemos dejado en los apuntes para ampliar informaci\u00f3n. The Racket Guide The Racket Reference Simply Scheme Lenguajes y Paradigmas de Programaci\u00f3n, curso 2021-22 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Domingo Gallardo, Cristina Pomares, Antonio Bot\u00eda, Francisco Mart\u00ednez","title":"7. Bibliograf\u00eda"},{"location":"seminarios/seminario2-swift/seminario2-swift.html","text":"Seminario 2: Seminario de Swift \u00b6 El lenguaje de programaci\u00f3n Swift \u00b6 Swift es un lenguaje de programaci\u00f3n compilado, de prop\u00f3sito general y multi-paradigma desarrollado por Apple. Swift se present\u00f3 en la Conferencia de Desarrolladores de Apple (WWDC) de 2014. Durante el a\u00f1o 2014 se desarroll\u00f3 la versi\u00f3n 1.2 y en la WWDC 2015 se present\u00f3 Swift 2, una actualizaci\u00f3n importante del lenguaje. Inicialmente fue un lenguaje propietario, pero el 3 de diciembre de 2015 se hizo open source bajo la licencia Apache 2.0, para las plataformas Apple y Linux. Los cambios en el lenguaje son propuestos y discutidos por la comunidad en un proceso denominado Swift evolution . En la actualidad se ha estabilizado la versi\u00f3n 5.1 del lenguaje, que es la que utilizaremos para realizar las pr\u00e1cticas. La siguiente descripci\u00f3n se ha extra\u00eddo del repositorio GitHub de Swift: Swift es un lenguaje de programaci\u00f3n de sistemas de alta eficiencia. Tiene una sintaxis limpia y moderna, ofrece acceso transparente a c\u00f3digo y librer\u00edas existentes en C y Objective-C, y es seguro en el uso de memoria ( memory safe ). Aunque est\u00e1 inspirado en Objective-C y en muchos otros lenguajes, Swift no es en si mismo un lenguaje derivado de C. Como lenguaje completo e independiente, Swift proporciona caracter\u00edsticas fundamentales como control de flujo, estructuras de datos y funciones, junto con construcciones de alto nivel como objetos, protocolos, clausuras y gen\u00e9ricos. Swift se apoya en m\u00f3dulos, eliminando la necesidad de cabeceras y la duplicaci\u00f3n de c\u00f3digo que \u00e9stas inducen. Ejecuci\u00f3n de programas Swift \u00b6 Es posible descargar el compilador de Swift en los sistemas operativos Mac (utilizando el entorno de desarrollo Xcode) o Linux. A continuaci\u00f3n explicamos las distintas formas de ejecutar programas Swift. Ejecuci\u00f3n on-line \u00b6 Existen varios sitios on-line en los que es posible ejecutar c\u00f3digo Swift. Recomendamos la direcci\u00f3n http://online.swiftplayground.run . Ejecuci\u00f3n con MacOS \u00b6 Podemos trabajar de dos formas: ejecutando los programas Swift desde la terminal o desde Xcode. Para ambas formas lo primero que hay que hacer es instalar Xcode . La primera forma, usar la terminal, es m\u00e1s inmediata, porque no es necesario conocer Xcode. La segunda, usar Xcode, es un poco m\u00e1s complicada, porque hay que crear un proyecto Xcode y conocer algunos de sus comandos. Pero la ventaja principal es que podremos comprobar los errores de compilaci\u00f3n del c\u00f3digo conforme lo escribimos. Si tienes Mac, puedes probar las dos formas y elegir la que te parezca m\u00e1s c\u00f3moda. Ejecuci\u00f3n desde la terminal \u00b6 Una vez instalado Xcode podemos ejecutar programas Swift desde la terminal, de forma interactiva. Abre la terminar y escribe: $ swift Ver\u00e1s que se ejecuta el int\u00e9rprete de Swift y que puedes escribir y ejecutar c\u00f3digo Swift: Para editar un programa Swift puedes utilizar un editor como Visual Studio Code o el propio Xcode. En Xcode puedes crear un fichero nuevo con la opci\u00f3n File > New File... y seleccionar la plantilla macOS > Swift File . Selecciona la carpeta y el nombre del fichero y ya puedes escribir c\u00f3digo Swift: Una vez grabado el programa, puedes ejecutarlo desde el terminal: $ swift prueba.swift Hola mundo Si hay alg\u00fan error de compilaci\u00f3n se detectar\u00e1 al lanzar el comando desde el terminal. Ejecuci\u00f3n desde Xcode \u00b6 La otra forma de trabajar es crear desde Xcode un proyecto Swift. Es un poco m\u00e1s complicado (hay que conocer algunos comandos m\u00e1s de Xcode), pero tiene la ventaja de que Xcode muestra los errores en la propia ventana de edici\u00f3n. Desde Xcode pulsa la opci\u00f3n File > New Project... y selecciona la plantilla macOS > Command Line Tool . Puedes escribir el nombre que quieras, por ejemplo prueba-swift Selecciona el lugar en el disco donde se graba el proyecto y ya puedes trabajar con \u00e9l. El fichero principal se llama main.swift . Pulsando la opci\u00f3n de Run se compila el proyecto y se abre un panel con la salida: Si hay alg\u00fan error de compilaci\u00f3n se detecta cuando se escribe el c\u00f3digo y se muestra en el propio editor: Ejecuci\u00f3n en una m\u00e1quina Docker \u00b6 Docker es una tecnolog\u00eda que ha tenido una gran expansi\u00f3n en los \u00faltimos a\u00f1os. Permite construir m\u00e1quinas virtuales ligeras que utilizan el mismo sistema operativo de la m\u00e1quina host. Estas m\u00e1quinas virtuales se denominan contenedores y, al compartir el propio sistema operativo en el que se est\u00e1n ejecutando, su gesti\u00f3n (construcci\u00f3n, arranque, parada, etc.) es much\u00edsimo m\u00e1s r\u00e1pida que las m\u00e1quinas virtuales tradicionales. Docker se controla desde l\u00ednea de comando, desde la aplicaci\u00f3n Terminal de Mac o el PowerShell de Windows. Existen comandos docker para descargar im\u00e1genes, lanzar y parar contenedores, montar directorios de la m\u00e1quina host en contenedores, etc. Nosotros s\u00f3lo utilizaremos el comando docker run para lanzar un contenedor, pero te recomendamos que investigues y pruebes m\u00e1s comandos y que conozcas mejor esta interesante tecnolog\u00eda. Puedes empezar por la gu\u00eda Get started with Docker . Usaremos la imagen Docker swift:5.1.2 , que contiene el comando swift necesario para compilar y ejecutar aplicaciones Swift. Instalaci\u00f3n de Docker \u00b6 Debes instalar la versi\u00f3n de Docker Desktop correspondiente a tu sistema operativo. Desc\u00e1rgalo desde esta p\u00e1gina y sigue las instrucciones correspondientes a tu sistema operativo. Instalaci\u00f3n y ejecuci\u00f3n de la imagen Swift \u00b6 Una vez instalado Docker, abre un terminal y lanza el siguiente comando: $ docker pull swift:5.1.2 El comando descarga la imagen swift:5.1.2 a nuestro ordenador. Una vez descargada lanzamos el contenedor con el siguiente comando: $ docker run --privileged -it --rm -v \"${PWD}:/home\" swift:5.1.2 /bin/bash El contenedor arranca en muy pocos segundos y aparece su prompt, indicando que ya est\u00e1s dentro de \u00e9l y puedes ejecutar cualquier comando linux: root@97265a262a58:/# ls bin boot dev etc home lib lib64 media mnt opt proc root run sbin srv sys tmp usr var root@97265a262a58:/# Lanzamos el int\u00e9rprete de Swift con el comando swift : root@97265a262a58:/# swift Welcome to Swift version 5.1.2 (swift-5.1.2-RELEASE). Type :help for assistance. 1> \"hola\".uppercased() $R0: String = \"HOLA\" 2> Una vez hayamos terminado de trabajar podemos salir del int\u00e9rprete de Swift y del contenedor de la siguiente forma: 3> :quit root@97265a262a58:/# exit Directorio compartido entre el ordenador host y el contenedor \u00b6 El argumento -v \"${PWD}:/home\" del comando docker run hace que el contenedor monte el directorio actual del ordenador anfitri\u00f3n en el directorio /home de la m\u00e1quina docker. De esta forma podemos editar los programas Swift en el ordenador anfitri\u00f3n y ejecutarlos desde l\u00ednea de comando en el contenedor. Recomendamos utilizar un editor de textos orientado a la programaci\u00f3n para editar los programas Swift en el ordenador anfitri\u00f3n. M\u00e1s adelante hablaremos de los editores Atom y Visual Studio Code, pero cualquier otro editor orientado a programaci\u00f3n te puede valer (Sublime, Xcode en el Mac, etc.) Vamos a probar a usar el directorio compartido: Nos movemos en el ordenador anfitri\u00f3n a un directorio en el que trabajaremos con los programas en Swift: ~ $ cd swift ~/swift $ Aviso Si est\u00e1s en Windows, por una cuesti\u00f3n de permisos, el directorio de trabajo es recomendable que se encuentre bajo la ruta C:\\Users\\<usuario>\\ . Por ejemplo: $ cd /c/Users/<usuario>/Documents/Ejercicios/Swift Creamos en el directorio actual un programa llamado holaMundo.swift . Fichero holaMundo.swift : // Primer programa Swift var str = \"Mensaje\" str = \"Hola mundo!\" print ( str ) // Vamos a sumar dos n\u00fameros var firstNumber = 2 var secondNumber = 3 var totalSum = firstNumber + secondNumber firstNumber = firstNumber + 1 secondNumber = secondNumber + 1 totalSum = firstNumber + secondNumber print ( \"El resultado de la suma es = \\( totalSum ) \" ) Arrancamos el contenedor swift: $ docker run --privileged -it -v \"${PWD}:/home\" swift:5.1.2 /bin/bash Compilamos y ejecutamos el programa desde el contenedor, cambiando al directorio /home (el directorio compartido) y ejecutando el comando swift: root@3131534ce480:/# cd /home root@3131534ce480:~# swift holaMundo.swift Hola mundo! El resultado de la suma es = 7 Prueba a cambiar cualquier cosa en el programa desde el editor en el ordenador anfitri\u00f3n y a volver a ejecutar el programa desde el contenedor. Ver\u00e1s que el directorio est\u00e1 realmente compartido y que el programa se ejecuta con las modificaciones que has introducido. root@3131534ce480:~# exit exit ~/swift $ Script El siguiente script realiza la llamada a la m\u00e1quina docker y ejecuta el fichero que recibe como par\u00e1metro. Es muy c\u00f3modo para ejecutar ficheros .swift en el directorio actual. Lo puedes ejecutar en Linux , MacOS o en Windows con el Docker Quickstart Terminal . Fichero swift.sh : SWIFT_VER = 5 .1.2 docker run --privileged -it --rm -v \" ${ PWD } :/home\" \"swift: ${ SWIFT_VER } \" /bin/bash -c \" cd /home swift $* \" Puedes guardarlo en el directorio actual, hacerlo ejecutable con $ chmod +x swift.sh y llamarlo pas\u00e1ndole como par\u00e1metro el fichero swift a ejecutar: $ ./swift.sh holaMundo.swift Si est\u00e1s en Windows y quieres ejecutar el script desde un terminal normal puedes hacer el siguiente fichero .bat que ejecuta el script anterior en el terminal Docker. Fichero swift.bat : \"C:\\Program Files\\Git\\bin\\bash.exe\" --login -i \"C:\\Program Files\\Docker Toolbox\\start.sh\" \"./swift.sh %*\" Uso: > swift holaMundo.swift Instalaci\u00f3n en Linux Ubuntu \u00b6 Existe una distribuci\u00f3n oficial de Swift para Ubuntu de 64 bits (distribuciones 14.04, 16.04 y 16.10). Puedes encontrar la informaci\u00f3n completa en la web oficial de Apple . Brevemente, los pasos son los siguientes: Instalar las dependencias que encontrar\u00e1s en la p\u00e1gina anterior usando apt-get . Descargar la versi\u00f3n y plataforma deseada (fichero swift-<VERSION>-<PLATFORM>.tar.gz ). Extaer el archivo: $ tar xzf swift-<VERSION>-<PLATFORM>.tar.gz Esto crea el directorio usr/ en la localizaci\u00f3n del archivo. Actualizar el PATH o mover usr/bin/swift al directorio /usr/bin . $ export PATH=/path/to/usr/bin:\"${PATH}\" Visual Studio Code \u00b6 Para editar c\u00f3digo Swift puedes usar cualquier editor orientado a programaci\u00f3n como Visual Studio Code o Atom. Aconsejamos Visual Studio Code . Es recomendable instalar la extensi\u00f3n Swift Language que realiza un coloreado de sintaxis de Swift. Para trabajar de forma m\u00e1s c\u00f3moda podemos abrir el terminal integrado Ver > Terminal integrado y lanzar el contenedor de Swift en ese terminal. Puedes consultar los conceptos b\u00e1sicos de Visual Studio Code y el manual completo en este enlace . Un tour de Swift \u00b6 Nota El texto de este seminario es una traducci\u00f3n del documento de Apple A Swift Tour en el que se presenta una introducci\u00f3n r\u00e1pida a los conceptos fundamentales del lenguaje. En los temas siguientes de la asignatura profundizaremos en aspectos como funciones, gen\u00e9ricos, clases o protocolos. La tradici\u00f3n sugiere que el primer programa en un nuevo lenguaje deber\u00eda imprimir las palabras \"Hola, mundo!\" en la pantalla. En Swift, esto puede hacerse con una \u00fanica l\u00ednea: print ( \"Hola, mundo!\" ) Si has escrito c\u00f3digo en C o en Objective-C, esta sintaxis te parecer\u00e1 familiar. En Swift, esta l\u00ednea de c\u00f3digo es un programa completo. No necesitas importar una biblioteca separada para funcionaliades como entrada/salida o manejo de cadenas. El c\u00f3digo escrito en el \u00e1mbito global se usa como el punto de entrada del programa, por lo que no necesitas una funci\u00f3n main() . Tampoco tienes que escribir puntos y comas al final de cada sentencia. Puedes comentar l\u00edneas de c\u00f3digo de la misma forma que en C. // // Esto es un comentario // /* Y esto tambi\u00e9n es un comentario */ Este tour te da informaci\u00f3n suficiente para empezar a escribir c\u00f3digo in Swift ense\u00f1\u00e1ndote c\u00f3mo conseguir una variedad de tareas de programaci\u00f3n. La informaci\u00f3n completa sobre todos los elementos del lenguaje de programaci\u00f3n Swift se encuentra en la Gu\u00eda de Swift . Valores simples \u00b6 Usa let para crear una constante y var para crear una variable. No es necesario que se conozca en tiempo de compilaci\u00f3n el valor de una constante, pero debes asignarle un valor exactamente una vez. Esto significa que puedes usar constantes para nombrar un valor que determinas una vez pero que usas en muchos lugares. var miVariable = 42 miVariable = 50 let miConstante = 42 Una constante o variable debe tener el mismo tipo que el valor que quieres asignarle. Sin embargo, no siempre tienes que escribir el tipo expl\u00edcitamente. Cuando se proporciona un valor al crear una constante o una variable el compilador infiere su tipo. En el ejemplo anterior, el compilador infiere que myVariable es un entero porque su valor inicial es un entero. Si el valor inicial no proporciona informaci\u00f3n suficiente (o si no hay valor inicial), especifica el tipo escribi\u00e9ndolo despu\u00e9s de la variable, separ\u00e1ndolo por dos puntos. let implicitoInteger = 70 let implicitoDouble = 70.0 let explicitoDouble : Double = 70 Nota A lo largo del seminario se plantean peque\u00f1os ejercicios que debes hacer tu mismo, para practicar un poco m\u00e1s con el lenguaje. Los ver\u00e1s en los bloques encabezados con \"Experimento\". Experimento 1 Crea una constante con el tipo expl\u00edcito de Float y un valor de 4. Los valores nunca se convierten impl\u00edcitamente a otro tipo. Si necesitas convertir un valor a un tipo diferente, construye expl\u00edcitamente una instancia del tipo deseado. let etiqueta = \"El ancho es \" let ancho = 94 let anchoEtiqueta = etiqueta + String ( ancho ) Experimento 2 Intenta eliminar la conversi\u00f3n a String en la \u00faltima l\u00ednea. \u00bfQu\u00e9 error obtienes? Incl\u00fayelo traducido en el c\u00f3digo usando un comentario. Hay una forma a\u00fan m\u00e1s sencilla de incluir valores en cadenas: escribe el valor entre par\u00e9ntesis, y escribe una barra invertida ( \\ ) antes de los par\u00e9ntesis. Por ejemplo: let manzanas = 3 let naranjas = 5 let resumenManzanas = \"Tengo \\( manzanas ) manzanas.\" let resumenFrutas = \"Tengo \\( manzanas + naranjas ) frutas.\" Experimento 3 Usa \\() para imprimir una cadena con un c\u00e1lculo con punto flotante y, en otra sentencia, para imprimir una cadena que incluiya el nombre de alguien en un saludo. Crea arrays y diccionarios utilizando corchetes ( [] ), y accede a sus elementos escribiendo el \u00edndice o la clave en los corchetes. Se permite una coma despu\u00e9s del \u00faltimo elemento. var listaCompra = [ \"huevos\" , \"agua\" , \"tomates\" , \"pan\" ] listaCompra [ 1 ] = \"botella de agua\" var trabajos = [ \"Malcolm\" : \"Capit\u00e1n\" , \"Kaylee\" : \"Mec\u00e1nico\" , ] trabajos [ \"Jayne\" ] = \"Relaciones p\u00fablicas\" Para crear un array o diccionario vac\u00edo, usa la sintaxis de inicializaci\u00f3n. let arrayVacio = [ String ]() let diccionarioVacio = [ String : Float ]() Si el tipo de informaci\u00f3n puede ser inferido, puedes escribir un array vac\u00edo como [] y un diccionario vac\u00edo como [:] ; por ejemplo, cuando estableces un nuevo valor para una variable o pasas un argumento a una funci\u00f3n. listaCompra = [] trabajos = [:] Puedes encontrar m\u00e1s informaci\u00f3n sobre c\u00f3mo trabajar con arrays en el apartado correspondiente de la Gu\u00eda de Swift . Tuplas \u00b6 Una tupla agrupa varios valores en un \u00fanico valor compuesto. let http404Error = ( 404 , \"Not Found\" ) El tipo de la tupla es (Int, String) . Para obtener los valores de la tupla podemos descomponerla . Si queremos ignorar una parte podemos utilizar un subrrayado ( _ ). let ( statusCode , statusMensaje ) = http404Error let ( soloStatusCode , _ ) = http404Error Tambi\u00e9n podemos acceder por posici\u00f3n: print ( \"El c\u00f3digo de estado es \\( http404Error . 0 ) \" ) Control de flujo \u00b6 Usa if y switch para hacer condicionales y usa for-in , for , while y repeat-while para hacer bucles. Los par\u00e9ntesis alrededor de las condiciones o de la variable del bucle son opcionales. Se requieren llaves alrededor del cuerpo. let puntuacionesIndividuales = [ 75 , 43 , 103 , 87 , 12 ] var puntuacionEquipo = 0 for puntuacion in puntuacionesIndividuales { if puntuacion > 50 { puntuacionEquipo += 3 } else { puntuacionEquipo += 1 } } print ( puntuacionEquipo ) En una sentencia if , el condicional debe ser una expresi\u00f3n booleana; esto significa que c\u00f3digo como if puntuacion { ... } es un error, no una comparaci\u00f3n impl\u00edcita con cero (como se permite en C). Puedes usar if y let juntos para trabajar con valores que pueden faltar. Estos valores se representan como opcionales. Un valor opcional o bien contiene un valor o contiene nil para indicar que el valor falta. Escribe una interrogaci\u00f3n ( ? ) despu\u00e9s del tipo de un valor para marcar el valor como opcional. var cadenaOpcional : String ? = \"Hola\" print ( cadenaOpcional == nil ) var nombreOpcional : String ? = \"John Appleseed\" var saludo = \"Hola!\" if let nombre = nombreOpcional { saludo = \"Hola, \\( nombre ) \" } print ( saludo ) Experimento 4 Cambia nombreOpcional a nil . \u00bfQu\u00e9 saludo obtienes? A\u00f1ade una cl\u00e1usula else que establezca un saludo diferente si nombreOpcional es nil . Si el valor opcional es nil , el condicional es false y el c\u00f3digo en las llaves se salta. En otro caso, el valor opcional se desenvuelve y se asigna a la constante despu\u00e9s del let , lo que hace que el valor desenvuelto est\u00e9 disponible dentro del bloque de c\u00f3digo. Otra forma de manejar valores opcionales es proporcionar un valor por defecto usando el operador ?? . Si falta el valor valor opcional, se usa el valor por defecto en su lugar. let nombrePila : String ? = nil let nombreCompleto : String = \"John Appleseed\" let saludoInformal = \"\u00bfQu\u00e9 tal, \\( nombrePila ?? nombreCompleto ) ?\" Las sentencias switch permiten cualquier tipo de datos y una amplia variedad de operaciones de comparaci\u00f3n; no est\u00e1n limitados a enteros y pruebas de igualdad. let verdura = \"pimiento rojo\" switch verdura { case \"zanahoria\" : print ( \"Buena para la vista.\" ) case \"lechuga\" , \"tomates\" : print ( \"Podr\u00edas hacer una buena ensalada.\" ) default : print ( \"Siempre puedes hacer una buena sopa.\" ) } Experimento 5 Intenta eliminar el caso por defecto. \u00bfQu\u00e9 error obtienes? Despu\u00e9s de ejecutar el c\u00f3digo dentro del caso que se empareja, el programa sale de la sentencia switch . La ejecuci\u00f3n no continua con el siguiente caso, por lo que no hay necesidad de romper el switch al final del c\u00f3digo de cada caso. Usa for-in para iterar sobre elementos en un diccionario proporcionando una pareja de nombres para usar en cada pareja clave-valor. Los diccionarios son colecciones desordenadas, por lo que sus claves y valores se iteran en un orden arbitrario. let numerosInteresantes = [ \"Primos\" : [ 2 , 3 , 5 , 7 , 11 , 13 ], \"Fibonacci\" : [ 1 , 1 , 2 , 3 , 5 , 8 ], \"Cuadrados\" : [ 1 , 4 , 9 , 16 , 25 ], ] var mayor = 0 for ( clase , numeros ) in numerosInteresantes { for num in numeros { if num > mayor { mayor = num } } } print ( mayor ) Experimento 6 A\u00f1ade otra variable para seguir qu\u00e9 clase de n\u00famero es el mayor. Usa while para repetir un bloque de c\u00f3digo hasta que una condici\u00f3n cambie. La condici\u00f3n de un bucle puede estar tambi\u00e9n al final, asegurando que el bucle se ejecuta al menos una vez. var n = 2 while n < 100 { n *= 2 } print ( n ) var m = 2 repeat { m *= 2 } while m < 100 print ( m ) Puedes definir un \u00edndice en un bucle usando ..< para construir un rango de \u00edndices. var total = 0 for i in 0. .< 4 { total += i } print ( total ) Usa ..< para construir un rango que omita su valor superior, y usa ... para construir un rango que incluya ambos valores. Funciones y clausuras \u00b6 Usa func para declarar una funci\u00f3n. Usa -> para separar los nombres de los par\u00e1metros y sus tipos del tipo devuelto de la funci\u00f3n. func saluda ( nombre : String , dia : String ) -> String { return \"Hola \\( nombre ) , hoy es \\( dia ) .\" } print ( saluda ( nombre : \"Bob\" , dia : \"Martes\" )) Experimento 7 Elimina el par\u00e1metro d\u00eda. A\u00f1ade un par\u00e1metro para incluir la comida de hoy en el saludo. Por defecto, las funciones usan los nombres de los par\u00e1metros como etiquetas de los argumentos. Es posible definir una etiqueta escribi\u00e9ndola antes del nombre del par\u00e1metro, o no usar etiqueta escribiendo _ : func saluda ( _ nombre : String , el dia : String ) -> String { return \"Hola \\( nombre ) , hoy es \\( dia ) .\" } print ( saluda ( \"Bob\" , el : \"Martes\" )) Las funciones pueden devolver cualquier tipo de dato, como tuplas. func calculaEstadisticas ( puntuaciones : [ Int ]) -> ( min : Int , max : Int , sum : Int ) { var min = puntuaciones [ 0 ] var max = puntuaciones [ 0 ] var sum = 0 for puntuacion in puntuaciones { if puntuacion > max { max = puntuacion } else if puntuacion < min { min = puntuacion } sum += puntuacion } return ( min , max , sum ) } let estadisticas = calculaEstadisticas ( puntuaciones : [ 5 , 3 , 100 , 3 , 9 ]) print ( estadisticas . sum ) print ( estadisticas . 2 ) Las funciones tambi\u00e9n pueden tener un n\u00famero variable de argumentos, agrup\u00e1ndose todos ellos en un array. func suma ( numeros : Int ...) -> Int { var suma = 0 for num in numeros { suma += num } return suma } print ( suma ()) print ( suma ( numeros : 42 , 597 , 12 )) Experimento 8 Escribe una funci\u00f3n que calcule la media de sus argumentos. Las funciones pueden anidarse. Las funciones pueden acceder variables declaradas en la funci\u00f3n exterior. Puedes usar funciones anidadas para organizar el c\u00f3digo en una funci\u00f3n que es larga o complicada. func devuelveQuince () -> Int { var y = 10 func suma () { y += 5 } suma () return y } print ( devuelveQuince ()) Las funciones son un tipo de primera clase. Esto significa que una funci\u00f3n puede devolver otra funci\u00f3n como resultado. func construyeIncrementador () -> (( Int ) -> Int ) { func sumaUno ( numero : Int ) -> Int { return 1 + numero } return sumaUno } var incrementa = construyeIncrementador () print ( incrementa ( 7 )) Podemos modificar el ejemplo devuelveQuince para que se devuelva una versi\u00f3n modificada de la funci\u00f3n suma . Llamamos a la funci\u00f3n devuelveSuma . func devuelveSuma () -> (() -> Int ) { var y = 10 func suma () -> Int { y += 5 return y } return suma } let f = devuelveSuma () print ( f ()) print ( f ()) Una funci\u00f3n puede tomar otra funci\u00f3n como uno de sus argumentos. func cumpleCondicion ( lista : [ Int ], condicion : ( Int ) -> Bool ) -> Bool { for item in lista { if condicion ( item ) { return true } } return false } func menorQueDiez ( numero : Int ) -> Bool { return numero < 10 } var numeros = [ 20 , 19 , 7 , 12 ] print ( cumpleCondicion ( lista : numeros , condicion : menorQueDiez )) Las funciones son en la realidad un caso especial de clausuras: bloques de c\u00f3digo que pueden ser llamados despu\u00e9s. El c\u00f3digo en la clausura tiene acceso a cosas como variables y funciones que estaban disponibles en el \u00e1mbito ( scope ) en el que se cre\u00f3 la clausura, incluso si la clausura est\u00e1 en un \u00e1mbito distinto cuando se ejecuta; ya viste un ejemplo de esto con las funciones anidadas. Puedes escribir una clausura rodeando el c\u00f3digo con llaves ( {} ). Usa in para separar los argumentos del cuerpo. numeros . map ({ ( numero : Int ) -> Int in let resultado = 3 * numero return resultado }) Experimento 9 Reescribe la clausura para que devuelva cero para todos los n\u00fameros impares. Tienes bastantes opciones para escribir clausuras de forma m\u00e1s concisa. Cuando ya se conoce el tipo de una clausura puedes omitir el tipo de sus par\u00e1metros, el tipo devuelto o ambos. Las clausuras escritas en una sentencia devuelven impl\u00edcitamente el valor de esa \u00fanica sentencia. let numerosMapeados = numeros . map ({ numero in 3 * numero }) print ( numerosMapeados ) Puedes referirte a los par\u00e1metros por n\u00famero en lugar de por nombre; este enfoque es especialmente \u00fatil en clausuras muy cortas. Una clausura pasada como \u00faltimo argumento puede aparecer inmediatamente despu\u00e9s de los par\u00e9ntesis. Cuando una clausura es el \u00fanico argumento de una funci\u00f3n, puedes omitir los par\u00e9ntesis por completo. let numerosOrdenados = numeros . sorted { $0 > $1 } print ( numerosOrdenados ) Objetos y clases \u00b6 Usa class seguido por el nombre de la clase para crear una clase. Una declaraci\u00f3n de una propiedad en una clase se escribe de la misma forma que la declaraci\u00f3n de una constante o una variable, excepto que est\u00e1 en el contexto de una clase. De la misma forma, las declaraciones de los m\u00e9todos se escriben de la misma forma que las funciones. class Figura { var numeroDeLados = 0 func descripcionSencilla () -> String { return \"Una figura con \\( numeroDeLados ) lados.\" } } Experimento 10 A\u00f1ade una propiedad constante con let , y a\u00f1ade otro m\u00e9todo que tome un argumento. Crea una instancia de una clase poniendo par\u00e9ntesis despu\u00e9s del nombre de la clase. Usa la sintaxis de punto para acceder a las propiedades y los m\u00e9todos de la instancia. var figura = Figura () figura . numeroDeLados = 7 var descripcionFigura = figura . descripcionSencilla () A esta versi\u00f3n de la clase Figura le falta algo importante: un inicializador para preparar la clase cuando se crea una instancia. Usa init para crear uno. class FiguraConNombre { var numeroDeLados : Int = 0 var nombre : String init ( nombre : String ) { self . nombre = nombre } func descripcionSencilla () -> String { return \"Una figura con \\( numeroDeLados ) lados.\" } } F\u00edjate en c\u00f3mo se utiliza self para distinguir la propiedad nombre del argumento nombre al inicializador. Los argumentos al inicializador se pasan como una llamada a una funci\u00f3n cuando creas una instancia de la clase. Cada propiedad necesita un valor asignado; ya sea en su declaraci\u00f3n (como numeroDeLados ) o en el inicializador (como nombre ). Las subclases incluyen el nombre de su subclase despu\u00e9s del nombre de la clase, separado por dos puntos. No hay ning\u00fan requisito de que las clases deban ser subclases de alguna clase ra\u00edz, por lo que puedes omitir una superclase si as\u00ed lo necesitas. Los m\u00e9todos en una subclase que sobreescriben la implementaci\u00f3n de la superclase se marcan con override ; la sobreescritura de un m\u00e9todo por accidente, sin override , se detecta por el compilador como un error. El compilador tambi\u00e9n detecta m\u00e9todos con override que realmente no sobreescriben ning\u00fan m\u00e9todo de la superclase. class Cuadrado : FiguraConNombre { var longitudLado : Double init ( longitudLado : Double , nombre : String ) { self . longitudLado = longitudLado super . init ( nombre : nombre ) numeroDeLados = 4 } func area () -> Double { return longitudLado * longitudLado } override func descripcionSencilla () -> String { return \"Un cuadrado con lados de longitud \\( longitudLado ) .\" } } let test = Cuadrado ( longitudLado : 5.2 , nombre : \"Mi cuadrado de prueba\" ) print ( test . area ()) print ( test . descripcionSencilla ()) Experimento 11 Construye otra subclase de FiguraConNombre llamada Circulo que tome un radio y un nombre como argumentos de su inicializador. Implementa un m\u00e9todo area() y descripcionSencilla() en la clase Circulo . Adem\u00e1s de propiedades simples que se almacenan, las propiedades pueden tener un getter y un setter . class TrianguloEquilatero : FiguraConNombre { var longitudLado : Double = 0.0 init ( longitudLado : Double , nombre : String ) { self . longitudLado = longitudLado super . init ( nombre : nombre ) numeroDeLados = 3 } var perimetro : Double { get { return 3.0 * longitudLado } set { longitudLado = newValue / 3.0 } } override func descripcionSencilla () -> String { return \"Un triangulo equil\u00e1tero con lados de longitud \\( longitudLado ) .\" } } var triangulo = TrianguloEquilatero ( longitudLado : 3.1 , nombre : \"un tri\u00e1ngulo\" ) print ( triangulo . perimetro ) triangulo . perimetro = 9.9 print ( triangulo . longitudLado ) En el setter de perimetro , el nuevo valor tiene el nombre impl\u00edcito newValue . Puedes proporcionar un nombre expl\u00edcito en el par\u00e9ntesis despu\u00e9s de set . Date cuenta de que el inicializador de la clase TrianguloEquilatero tiene tres pasos diferentes: Establecer el valor de las propiedades que declara la subclase. Llamar al inicializador de la superclase. Cambiar el valor de las propiedades definidas por la superclase. Cualquier trabajo adicional que use m\u00e9todos, getters o setters puede hacerse tambi\u00e9n en este punto. Enumeraciones y estructuras \u00b6 Usa enum para crear una enumeraci\u00f3n. Como las clases y otros tipos con nombre, las enumeraciones pueden tener m\u00e9todos asociados. enum Valor : Int { case uno = 1 case dos , tres , cuatro , cinco , seis , siete , ocho , nueve , diez case sota , caballo , rey func descripcionSencilla () -> String { switch self { case . uno : return \"as\" case . sota : return \"sota\" case . caballo : return \"caballo\" case . rey : return \"rey\" default : return String ( self . rawValue ) } } } let carta = Valor . uno let valorBrutoCarta = carta . rawValue Experimento 12 Escribe una funci\u00f3n que compare dos valores Valor a trav\u00e9s de una comparaci\u00f3n de sus valores brutos. Por defecto, Swift asigna los valores brutos comenzando en cero e increment\u00e1ndolos por uno cada vez, pero puedes cambiar esta conducta especificando expl\u00edcitamente los valores. En el ejemplo anterior, a As se le da un valor bruto de 1 y el resto de los valores brutos se asignan en orden. Puedes tambi\u00e9n usar cadenas o n\u00fameros en punto flotante como valores brutos de una enumeraci\u00f3n. Utiliza la propiedad rawValue para acceder al valor bruto de una enumeraci\u00f3n. Usa el inicializador para construir un valor de una enumeraci\u00f3n a trav\u00e9s de un valor bruto. Si el valor bruto no existe, el inicializador devolver\u00e1 nil . if let valorConvertido = Valor ( rawValue : 3 ) { let descripcionTres = valorConvertido . descripcionSencilla () print ( descripcionTres ) } Los valores case de una enumeraci\u00f3n son valores reales, no una forma nueva de escribir sus valores brutos. De hecho, en los casos en los que no hay un valor bruto que tenga sentido, no tienes que proporcionar uno. enum Palo { case oros , bastos , copas , espadas func descripcionSencilla () -> String { switch self { case . oros : return \"oros\" case . bastos : return \"bastos\" case . copas : return \"copas\" case . espadas : return \"espadas\" } } } let copas = Palo . copas let descripcionCopas = copas . descripcionSencilla () Experimento 13 A\u00f1ade un m\u00e9todo color() a Palo que devuelva \"agresivo\" para bastos y espadas y devuelva \"reflexivo\" para oros y copas . Date cuenta de las dos formas en las que nos referimos al caso copas de la enumeraci\u00f3n anterior: cuando se asigna un valor a la constante copas , nos referimos al caso de la enumeraci\u00f3n Palo.copas usando su nombre completo porque la constante no tiene un tipo expl\u00edcito especificado. Dentro del switch , nos referimos al caso de la enumeraci\u00f3n con la forma abreviada .copas porque ya se sabe que el valor de self es un Palo . Puedes usar la forma abreviada en cualquier momento en que el tipo del valor ya se conozca. Una instancia de un caso de enumeraci\u00f3n puede tener valores asociados con la instancia. Instancias del mismo caso de enumeraci\u00f3n pueden tener asociados valores diferentes. Proporcionas los valores asociados cuando creas la instancia. Los valores asociados y los valores brutos son distintos: el valor bruto de un caso de enumeraci\u00f3n es el mismo para todas las instancias, mientras que proporcionas el valor asociado cuando defines la enumeraci\u00f3n. Por ejemplo, considera el caso de realizar una petici\u00f3n a un servidor de la hora de salir el sol y de la hora de ponerse el sol. El servidor responde con la informaci\u00f3n o responde con alguna informaci\u00f3n de error. enum RespuestaServidor { case resultado ( String , String ) case error ( String ) } let exito = RespuestaServidor . resultado ( \"6:00 am\" , \"8:09 pm\" ) let fallo = RespuestaServidor . error ( \"Sin queso.\" ) switch exito { case let . resultado ( salidaSol , puestaSol ): print ( \"La salida del sol es a las \\( salidaSol ) y la puesta es a \\( puestaSol ) .\" ) case let . error ( error ): print ( \"Fallo... \\( error ) \" ) } Experimento 14 A\u00f1ade un tercer caso al ServerResponse y al switch. Date cuenta de c\u00f3mo la hora de salir el sol y de ponerse el sol se extraen del ServerResponse como parte del emparejamiento entre el valor y los casos switch. Usa struct para crear una estructura. Las estructuras comparten muchas caracter\u00edsticas de las clases, incluyendo m\u00e9todos e inicializadores. Una de las diferencias m\u00e1s importantes entre estructuras y clases es que las estructuras siempre se copian cuando las pasas en tu c\u00f3digo, mientras que las clases se pasan por referencia. struct Carta { var valor : Valor var palo : Palo func descripcionSencilla () -> String { return \"El \\( valor . descripcionSencilla ()) de \\( palo . descripcionSencilla ()) \" } } let tresDeEspadas = Carta ( valor : . tres , palo : . espadas ) let descripcionTresDeEspadas = tresDeEspadas . descripcionSencilla () Experimento 15 A\u00f1ade un m\u00e9todo a Carta que cree un mazo completo de cartas, con una carta de cada combinaci\u00f3n de valor y palo. Bibliograf\u00eda y referencias \u00b6 Documentaci\u00f3n sobre Swift The Swift Programming Language (html) Recursos Swift en Apple swift.org Swift Open Source Repositorio swift en GitHub : repositorio principal de Swift, que contiene el c\u00f3digo fuente del compilador Swift, la biblioteca est\u00e1ndar y SourceKit. Repositorio swift-evolution en GitHub : documentos relacionados con la evoluci\u00f3n continua de Swift, incluyendo objetivos de las pr\u00f3ximas versiones y propuestas de cambios y extensiones de Swift. Lenguajes y Paradigmas de Programaci\u00f3n, curso 2020-21_ Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante","title":"Seminario 2: Seminario de Swift"},{"location":"seminarios/seminario2-swift/seminario2-swift.html#seminario-2-seminario-de-swift","text":"","title":"Seminario 2: Seminario de Swift"},{"location":"seminarios/seminario2-swift/seminario2-swift.html#el-lenguaje-de-programacion-swift","text":"Swift es un lenguaje de programaci\u00f3n compilado, de prop\u00f3sito general y multi-paradigma desarrollado por Apple. Swift se present\u00f3 en la Conferencia de Desarrolladores de Apple (WWDC) de 2014. Durante el a\u00f1o 2014 se desarroll\u00f3 la versi\u00f3n 1.2 y en la WWDC 2015 se present\u00f3 Swift 2, una actualizaci\u00f3n importante del lenguaje. Inicialmente fue un lenguaje propietario, pero el 3 de diciembre de 2015 se hizo open source bajo la licencia Apache 2.0, para las plataformas Apple y Linux. Los cambios en el lenguaje son propuestos y discutidos por la comunidad en un proceso denominado Swift evolution . En la actualidad se ha estabilizado la versi\u00f3n 5.1 del lenguaje, que es la que utilizaremos para realizar las pr\u00e1cticas. La siguiente descripci\u00f3n se ha extra\u00eddo del repositorio GitHub de Swift: Swift es un lenguaje de programaci\u00f3n de sistemas de alta eficiencia. Tiene una sintaxis limpia y moderna, ofrece acceso transparente a c\u00f3digo y librer\u00edas existentes en C y Objective-C, y es seguro en el uso de memoria ( memory safe ). Aunque est\u00e1 inspirado en Objective-C y en muchos otros lenguajes, Swift no es en si mismo un lenguaje derivado de C. Como lenguaje completo e independiente, Swift proporciona caracter\u00edsticas fundamentales como control de flujo, estructuras de datos y funciones, junto con construcciones de alto nivel como objetos, protocolos, clausuras y gen\u00e9ricos. Swift se apoya en m\u00f3dulos, eliminando la necesidad de cabeceras y la duplicaci\u00f3n de c\u00f3digo que \u00e9stas inducen.","title":"El lenguaje de programaci\u00f3n Swift"},{"location":"seminarios/seminario2-swift/seminario2-swift.html#ejecucion-de-programas-swift","text":"Es posible descargar el compilador de Swift en los sistemas operativos Mac (utilizando el entorno de desarrollo Xcode) o Linux. A continuaci\u00f3n explicamos las distintas formas de ejecutar programas Swift.","title":"Ejecuci\u00f3n de programas Swift"},{"location":"seminarios/seminario2-swift/seminario2-swift.html#ejecucion-on-line","text":"Existen varios sitios on-line en los que es posible ejecutar c\u00f3digo Swift. Recomendamos la direcci\u00f3n http://online.swiftplayground.run .","title":"Ejecuci\u00f3n on-line"},{"location":"seminarios/seminario2-swift/seminario2-swift.html#ejecucion-con-macos","text":"Podemos trabajar de dos formas: ejecutando los programas Swift desde la terminal o desde Xcode. Para ambas formas lo primero que hay que hacer es instalar Xcode . La primera forma, usar la terminal, es m\u00e1s inmediata, porque no es necesario conocer Xcode. La segunda, usar Xcode, es un poco m\u00e1s complicada, porque hay que crear un proyecto Xcode y conocer algunos de sus comandos. Pero la ventaja principal es que podremos comprobar los errores de compilaci\u00f3n del c\u00f3digo conforme lo escribimos. Si tienes Mac, puedes probar las dos formas y elegir la que te parezca m\u00e1s c\u00f3moda.","title":"Ejecuci\u00f3n con MacOS"},{"location":"seminarios/seminario2-swift/seminario2-swift.html#ejecucion-en-una-maquina-docker","text":"Docker es una tecnolog\u00eda que ha tenido una gran expansi\u00f3n en los \u00faltimos a\u00f1os. Permite construir m\u00e1quinas virtuales ligeras que utilizan el mismo sistema operativo de la m\u00e1quina host. Estas m\u00e1quinas virtuales se denominan contenedores y, al compartir el propio sistema operativo en el que se est\u00e1n ejecutando, su gesti\u00f3n (construcci\u00f3n, arranque, parada, etc.) es much\u00edsimo m\u00e1s r\u00e1pida que las m\u00e1quinas virtuales tradicionales. Docker se controla desde l\u00ednea de comando, desde la aplicaci\u00f3n Terminal de Mac o el PowerShell de Windows. Existen comandos docker para descargar im\u00e1genes, lanzar y parar contenedores, montar directorios de la m\u00e1quina host en contenedores, etc. Nosotros s\u00f3lo utilizaremos el comando docker run para lanzar un contenedor, pero te recomendamos que investigues y pruebes m\u00e1s comandos y que conozcas mejor esta interesante tecnolog\u00eda. Puedes empezar por la gu\u00eda Get started with Docker . Usaremos la imagen Docker swift:5.1.2 , que contiene el comando swift necesario para compilar y ejecutar aplicaciones Swift.","title":"Ejecuci\u00f3n en una m\u00e1quina Docker"},{"location":"seminarios/seminario2-swift/seminario2-swift.html#instalacion-en-linux-ubuntu","text":"Existe una distribuci\u00f3n oficial de Swift para Ubuntu de 64 bits (distribuciones 14.04, 16.04 y 16.10). Puedes encontrar la informaci\u00f3n completa en la web oficial de Apple . Brevemente, los pasos son los siguientes: Instalar las dependencias que encontrar\u00e1s en la p\u00e1gina anterior usando apt-get . Descargar la versi\u00f3n y plataforma deseada (fichero swift-<VERSION>-<PLATFORM>.tar.gz ). Extaer el archivo: $ tar xzf swift-<VERSION>-<PLATFORM>.tar.gz Esto crea el directorio usr/ en la localizaci\u00f3n del archivo. Actualizar el PATH o mover usr/bin/swift al directorio /usr/bin . $ export PATH=/path/to/usr/bin:\"${PATH}\"","title":"Instalaci\u00f3n en Linux Ubuntu"},{"location":"seminarios/seminario2-swift/seminario2-swift.html#visual-studio-code","text":"Para editar c\u00f3digo Swift puedes usar cualquier editor orientado a programaci\u00f3n como Visual Studio Code o Atom. Aconsejamos Visual Studio Code . Es recomendable instalar la extensi\u00f3n Swift Language que realiza un coloreado de sintaxis de Swift. Para trabajar de forma m\u00e1s c\u00f3moda podemos abrir el terminal integrado Ver > Terminal integrado y lanzar el contenedor de Swift en ese terminal. Puedes consultar los conceptos b\u00e1sicos de Visual Studio Code y el manual completo en este enlace .","title":"Visual Studio Code"},{"location":"seminarios/seminario2-swift/seminario2-swift.html#un-tour-de-swift","text":"Nota El texto de este seminario es una traducci\u00f3n del documento de Apple A Swift Tour en el que se presenta una introducci\u00f3n r\u00e1pida a los conceptos fundamentales del lenguaje. En los temas siguientes de la asignatura profundizaremos en aspectos como funciones, gen\u00e9ricos, clases o protocolos. La tradici\u00f3n sugiere que el primer programa en un nuevo lenguaje deber\u00eda imprimir las palabras \"Hola, mundo!\" en la pantalla. En Swift, esto puede hacerse con una \u00fanica l\u00ednea: print ( \"Hola, mundo!\" ) Si has escrito c\u00f3digo en C o en Objective-C, esta sintaxis te parecer\u00e1 familiar. En Swift, esta l\u00ednea de c\u00f3digo es un programa completo. No necesitas importar una biblioteca separada para funcionaliades como entrada/salida o manejo de cadenas. El c\u00f3digo escrito en el \u00e1mbito global se usa como el punto de entrada del programa, por lo que no necesitas una funci\u00f3n main() . Tampoco tienes que escribir puntos y comas al final de cada sentencia. Puedes comentar l\u00edneas de c\u00f3digo de la misma forma que en C. // // Esto es un comentario // /* Y esto tambi\u00e9n es un comentario */ Este tour te da informaci\u00f3n suficiente para empezar a escribir c\u00f3digo in Swift ense\u00f1\u00e1ndote c\u00f3mo conseguir una variedad de tareas de programaci\u00f3n. La informaci\u00f3n completa sobre todos los elementos del lenguaje de programaci\u00f3n Swift se encuentra en la Gu\u00eda de Swift .","title":"Un tour de Swift"},{"location":"seminarios/seminario2-swift/seminario2-swift.html#bibliografia-y-referencias","text":"Documentaci\u00f3n sobre Swift The Swift Programming Language (html) Recursos Swift en Apple swift.org Swift Open Source Repositorio swift en GitHub : repositorio principal de Swift, que contiene el c\u00f3digo fuente del compilador Swift, la biblioteca est\u00e1ndar y SourceKit. Repositorio swift-evolution en GitHub : documentos relacionados con la evoluci\u00f3n continua de Swift, incluyendo objetivos de las pr\u00f3ximas versiones y propuestas de cambios y extensiones de Swift. Lenguajes y Paradigmas de Programaci\u00f3n, curso 2020-21_ Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante","title":"Bibliograf\u00eda y referencias"},{"location":"teoria/tema00-descripcion-asignatura/tema00-descripcion-asignatura.html","text":"Lenguajes y Paradigmas de Programaci\u00f3n \u00b6 1. Datos acad\u00e9micos de la asignatura \u00b6 Departamento de Ciencia de la Computaci\u00f3n e Inteligencia Artificial 6 cr\u00e9ditos ECTS : 1 clase de teor\u00eda de 2 h. y 1 clase de pr\u00e1cticas de 2 h. a la semana Profesores : Antonio Bot\u00eda ( e-mail ): Grupos de pr\u00e1cticas: 2, 9 y 40 Domingo Gallardo ( e-mail ): Profesor coordinador de la asignatura. Grupos de teor\u00eda: 3, 4 y 40. Grupos de pr\u00e1cticas: 6 Francisco Mart\u00ednez ( e-mail ): Grupos de pr\u00e1cticas: 4, 5 y 8 Cristina Pomares ( e-mail ): Grupos de teor\u00eda: 1 y 2. Grupos de pr\u00e1cticas: 1, 3 y 7. 2. Recursos de la asignatura \u00b6 Ficha de la asignatura Apuntes de la asignatura (teor\u00eda, seminarios y pr\u00e1cticas) Sitio Moodle abierto y accesible a toda la comunidad educativa, contiene los apuntes, transparencias, pr\u00e1cticas y otros materiales docentes Foro de consultas y anuncios en el sitio Moodle (s\u00f3lo accesible a estudiantes) 3. Objetivos y competencias \u00b6 Objetivos : \u00bfQu\u00e9 elementos son comunes a los lenguajes de programaci\u00f3n? \u00bfQu\u00e9 familias o paradigmas de lenguajes podemos identificar? \u00bfQu\u00e9 es la programaci\u00f3n funcional? \u00bfC\u00f3mo es un lenguaje multi-paradigma que combina la programaci\u00f3n funcional y la programaci\u00f3n orientada a objetos? Dominando estos contenidos ser\u00e1 mucho m\u00e1s f\u00e1cil aprender nuevos lenguajes de programaci\u00f3n, identificar sus aspectos esenciales e incluso ser capaz de dise\u00f1ar lenguajes espec\u00edficos orientados a dominios concretos. Competencias : Conocer y diferenciar las caracter\u00edsticas de los distintos paradigmas de programaci\u00f3n (programaci\u00f3n funcional, procedural y orientada a objetos) e identificarlas en lenguajes de programaci\u00f3n concretos. Diferenciar entre tiempo de ejecuci\u00f3n y tiempo de compilaci\u00f3n en distintos \u00e1mbitos: detecci\u00f3n de errores o definici\u00f3n, creaci\u00f3n o \u00e1mbito de vida de variables. Conocer los principios b\u00e1sicos de la programaci\u00f3n funcional: recursi\u00f3n, inmutabilidad, funciones como objetos de primera clase, funciones de orden superior, expresiones lambda (clausuras). Conocer los problemas derivados del uso de la mutaci\u00f3n en los lenguajes de programaci\u00f3n imperativos y la forma de trabajar con estructuras inmutables en lenguajes declarativos y funcionales. Utilizar la abstracci\u00f3n y la recursi\u00f3n para dise\u00f1ar correctamente procedimientos y estructuras de datos (listas y \u00e1rboles). Ser capaz de dise\u00f1ar, implementar y corregir programas funcionales, en concreto utilizando el lenguaje de programaci\u00f3n Scheme. Ser capaz de dise\u00f1ar, implementar y corregir programas funcionales, en concreto utilizando el lenguaje de programaci\u00f3n Swift. Conocer las caracter\u00edsticas de programaci\u00f3n orientada a objetos y de comprobaci\u00f3n est\u00e1tica de tipos del lenguaje de programaci\u00f3n Swift. Conocer el uso de gen\u00e9ricos y protocolos que proporciona el lenguaje. Ser capaz de implementar programas en Swift en los que se utilicen sus caracter\u00edsticas de programaci\u00f3n orientada a objetos, gen\u00e9ricos y protocolos. 4. Temario \u00b6 4.1. Bloques tem\u00e1ticos \u00b6 La asignatura se divide en 3 bloques tem\u00e1ticos, todos ellos de igual duraci\u00f3n, en los que se utilizar\u00e1 el lenguaje de programaci\u00f3n que aparece entre par\u00e9ntesis: Programaci\u00f3n funcional (Scheme): temas 1 y 2 Procesos y estructuras recursivas (Scheme): temas 3 y 4 Programaci\u00f3n funcional en Swift y programaci\u00f3n orientada a objetos (Swift): temas 5 y 6 Los lenguajes de programaci\u00f3n se introducir\u00e1n mediante seminarios impartidos en las clases de pr\u00e1cticas. Seminario 1. El lenguaje de programaci\u00f3n Scheme : Primitivas. Tipos de datos b\u00e1sicos. S\u00edmbolos. Cadenas. Listas. Definici\u00f3n de funciones. Seminario 2. El lenguaje de programaci\u00f3n Swift . Int\u00e9rprete y scripts. Tipos de datos b\u00e1sicos. Operadores. Estructuras de control. \u00c1mbito de variables. Tipos de datos compuestos: tuplas, arrays y colecciones. Recorriendo colecciones. Valores mutables e inmutables. Inicializaci\u00f3n. Tipos de referencia y valor en Swift. 4.2. Temas \u00b6 Tema 1. Lenguajes de programaci\u00f3n : Historia de los lenguajes de programaci\u00f3n. Elementos de los lenguajes de programaci\u00f3n. Abstracci\u00f3n. Paradigmas de programaci\u00f3n. Compiladores e int\u00e9rpretes. Tema 2. Programaci\u00f3n Funcional : Caracter\u00edsticas e historia del paradigma de Programaci\u00f3n Funcional. Diferencias con el paradigma imperativo. Caracter\u00edsticas declarativas del paradigma funcional. Definici\u00f3n de funciones. Funciones como datos de primer orden. La forma especial lambda. \u00c1mbito de variables y clausuras. Datos compuestos en Scheme: parejas. Construcci\u00f3n, recorrido y operaciones sobre listas. Listas con elementos compuestos. Listas de listas. Tema 3. Procedimientos recursivos : Dise\u00f1o de funciones recursivas. Recursi\u00f3n mutua. Procesos recursivos e iterativos. Memoization. Recursi\u00f3n y gr\u00e1ficos de tortuga. Tema 4. Estructuras recursivas : Estructuras de datos recursivas: listas estructuradas y \u00e1rboles. Tema 5. Programaci\u00f3n funcional en Swift : Lenguajes multiparadigma. Programaci\u00f3n funcional en Swift. Valores opcionales. Listas. Recursi\u00f3n pura y recursi\u00f3n por la cola. Funciones como datos de primer orden. Clausuras y funciones an\u00f3nimas. Funciones de orden superior: mappings y filtros de colecciones. Tema 6. Programaci\u00f3n Orientada a Objetos en Swift : Caracter\u00edsticas e historia del paradigma de Programaci\u00f3n Orientada a Objetos. Estructuras y clases en Swift. Herencia. Conceptos avanzados de POO en Swift: Extensiones, Protocolos y Gen\u00e9ricos. El calendario de temas, pr\u00e1cticas y ex\u00e1menes se puede ver en la siguiente figura. 5. Pr\u00e1cticas \u00b6 Las pr\u00e1cticas son fundamentales en la asignatura y sirven para comprender, trabajar y profundizar los conceptos y competencias estudiados en las clases de teor\u00eda. Para el desarrollo de las pr\u00e1cticas utilizaremos los siguientes lenguajes de programaci\u00f3n y entornos de desarrollo: Racket (versi\u00f3n de Scheme, lenguaje de programaci\u00f3n funcional) Swift (lenguaje multiparadigma creado por Apple, con conceptos modernos de programaci\u00f3n funcional y programaci\u00f3n orientada a objetos) Cada semana tendr\u00e1s que realizar una hoja de ejercicios en la que se incluir\u00e1 un repaso de la teor\u00eda vista la semana anterior y 5 o 6 peque\u00f1os problemas de programaci\u00f3n relacionados con esa teor\u00eda. La hoja de ejercicios estar\u00e1 disponible al comienzo de la semana y tendr\u00e1s toda la semana para su realizaci\u00f3n. Una vez entregada la pr\u00e1ctica podr\u00e1s acceder a su soluci\u00f3n. Revisa la soluci\u00f3n de la pr\u00e1ctica Es muy importante que revises la soluci\u00f3n de la pr\u00e1ctica y la compares con la soluci\u00f3n que has obtenido. Pregunta a tu profesor de pr\u00e1cticas en caso de que tengas dudas sobre si tu soluci\u00f3n es correcta. En la clase de pr\u00e1cticas se resolver\u00e1n dudas sobre la soluci\u00f3n de la pr\u00e1ctica anterior y se trabajar\u00e1 en la hoja de ejercicios publicada esa semana. Durante la sesi\u00f3n de pr\u00e1cticas el profesor estar\u00e1 disponible para resolver dudas y dar pistas sobre c\u00f3mo atacar los problemas. Tambi\u00e9n durante la semana se podr\u00e1n consultar las dudas que puedan surgir en el foro de la asignatura (en Moodle) y con tutor\u00edas a los profesores. Es preferible el foro, porque de esta forma las contestaciones y aclaraciones ser\u00e1n compartidas con el resto de compa\u00f1eros. 6. Horarios \u00b6 La distribuci\u00f3n de grupos del curso 2021-22 es la siguiente: En los turnos de teor\u00eda es posible, de forma excepcional, asistir a un grupo distinto del asignado. En los turnos de pr\u00e1cticas se debe asistir al grupo al que se ha asignado. El cambio de turno deber\u00e1 solicitarse en la Secretar\u00eda de la EPS. 7. Evaluaci\u00f3n \u00b6 7.1. Convocatoria ordinaria C3 (evaluaci\u00f3n continua) \u00b6 La asignatura se divide en 3 bloques tem\u00e1ticos, todos ellos de igual duraci\u00f3n, en los que se utilizar\u00e1 el lenguaje de programaci\u00f3n que aparece entre par\u00e9ntesis: Programaci\u00f3n funcional (temas 1 y 2, Scheme) Recursi\u00f3n y estructuras de datos recursivas (temas 3 y 4, Scheme) Programaci\u00f3n funcional en Swift y programaci\u00f3n orientada a objetos (temas 5 y 6, Swift) Se realizar\u00e1n tres ex\u00e1menes parciales escritos sobre los conceptos de cada uno de los bloques tem\u00e1ticos (teor\u00eda y pr\u00e1ctica). Los parciales tendr\u00e1n la siguiente ponderaci\u00f3n en la nota final: Parcial 1: 35% Parcial 2: 30% Parcial 3: 35% No se exige nota m\u00ednima en ninguno de los parciales. Los parciales 1 y 2 se realizar\u00e1n durante el curso. El parcial 3 se realizar\u00e1 en la fecha del examen oficial de la convocatoria ordinaria de la asignatura. Sobre los dispositivos m\u00f3viles Durante la realizaci\u00f3n de los ex\u00e1menes no est\u00e1 permitido que llev\u00e9is encima ning\u00fan dispositivo con conexi\u00f3n a internet (smartphones, smart watches, tablets, etc). Antes de empezar la prueba, se deber\u00e1n dejar dentro de las mochilas, y \u00e9stas en el suelo. En caso de no cumplir alguna esta norma, la prueba queda invalidada con calificaci\u00f3n de 0. 7.2. Convocatoria extraordinaria C4 \u00b6 En la convocatoria extraordinaria se realizar\u00e1 un examen final sobre todos los bloques tem\u00e1ticos cuya calificaci\u00f3n representar\u00e1 el 100% de la nota de la asignatura. 8. Consejos para aprender con \u00e9xito los contenidos de la asignatura \u00b6 El consejo fundamental para aprobar la asignatura es trabajar todas las semanas e intentar seguir el ritmo de la asignatura . Los conceptos de la asignatura se van construyendo de forma progresiva y lo visto en una semana depende muchas veces de lo aprendido en semanas anteriores. \u00bfC\u00f3mo estudiar estos conceptos? Con la excepci\u00f3n de algunos temas y apartados concretos (como la historia de los lenguajes de programaci\u00f3n o las caracter\u00edsticas de los distintos paradigmas) la asignatura es fundamentalmente pr\u00e1ctica. Cuando hablamos de estudiar los ejemplos de c\u00f3digo queremos decir entenderlos, no aprenderlos de memoria . No tiene sentido aprender de memoria los ejercicios y los ejemplos vistos en clase. Hay que trabajarlos . Eso significa que, primero, hay que entenderlos sobre el papel y muy importante hay que probar todos los ejemplos en el int\u00e9rprete . Y probar significa escribir los ejemplos y jugar con ellos, proponiendo peque\u00f1as variantes, pregunt\u00e1ndose \u00bfqu\u00e9 pasar\u00eda si...? y prob\u00e1ndolo. En cuanto a las pr\u00e1cticas y a los ejercicios propuestos es fundamental pelearse con ellos e intentar hacerlos por uno mismo sin ver ninguna soluci\u00f3n . Es la \u00fanica forma de aprender: probando, equivoc\u00e1ndose y encontrando la soluci\u00f3n por uno mismo. A la hora de enfrentarse con un problema es fundamental tambi\u00e9n usar l\u00e1piz y papel para probar enfoques y encontrar la soluci\u00f3n m\u00e1s sencilla sobre el papel antes de probarla en el int\u00e9rprete. Los ejercicios que proponemos no son excesivamente complicados. Todos se resuelven con muy pocas l\u00edneas de c\u00f3digo y su codificaci\u00f3n en el ordenador no tiene dificultad, una vez que se ha encontrado la soluci\u00f3n que lo resuelve. Al usar el l\u00e1piz y papel tambi\u00e9n estar\u00e1s practicando una situaci\u00f3n similar a la que te vas a encontrar en los ex\u00e1menes de la asignatura. Resumiendo: trabajar todas las semanas, hacer uno mismo todos los ejercicios y no desanimarse ni descolgarse. Son muy interesantes algunos comentarios de antiguos estudiantes que han aprobado la asignatura. C\u00f3mo dominar los conceptos Para superar la asignatura lo que hice fue estudiar mucho. Hay que practicar y sobre todo entender los ejercicios y no sabe\u0301rselos de memoria. Una vez dominados los ejercicios yo mismo me propuse variantes de los mismos. Asi\u0301 es como se domina. El problema del cambio de paradigma El problema principal de la asignatura es enfrentarse a un cambio del paradigma de programacio\u0301n.\" Trabajar d\u00eda a d\u00eda Lo que hice fue tratar de llevar al di\u0301a toda la asignatura, adema\u0301s de trabajar con material adicional para poder ampliar y profundizar conocimientos. LPP es una asignatura de fondo en la que tienes que mantener el ritmo de trabajo de principio a fin de cuatrimestre.\" No copiar las pr\u00e1cticas El mayor problema que creo que existe es que muchas personas se relajan y se copian las pra\u0301cticas en cuanto les resultan un poco difi\u0301ciles o les lleva algo mas del tiempo que les gustari\u0301a. Esta asignatura si no haces tu los ejercicios y te peleas con ellos es pra\u0301cticamente imposible de sacar. No memorizar Otra de las cosas es que tienes que cambiar la forma de estudiar, no vale memorizar, ni hacer muchos ejercicios sin ma\u0301s. Tienes que entender bien el funcionamiento de la recursio\u0301n para luego poder practicar con ejercicios, sino no sirve. [...] En mi opinio\u0301n el problema de LPP para mucha gente es que para los exa\u0301menes se memorizan los ejercicios de pra\u0301cticas de las soluciones que se dan en clase. Plantearse uno mismo problemas Los problemas que me encontre\u0301 a la hora de cursar LPP fue que eran dos lenguajes completamente nuevos, otro tipo de programacio\u0301n que nunca habi\u0301a visto, otra forma de estudiar distinta. Para poder superarla simplemente tienes que hacer ejercicios y tambie\u0301n plantearte tu\u0301 mismo nuevos ejercicios. 9. Bibliograf\u00eda \u00b6 En Moodle se publican los apuntes de la asignatura, con ejercicios, explicaciones y ejemplos de todos los conceptos estudiados, tanto en teor\u00eda como en pr\u00e1ctica. Para ampliar algunos conceptos se recomiendan las siguientes referencias: Harold Abelson y Gerald Jay Sussman, Structure and Interpretation of Computer Programs , MIT Press, 1996 Enlace a la edici\u00f3n on-line Signatura en la Biblioteca Polit\u00e9cnica: I.06/ABE/STR Apple, The Swift Programming Language The Racket Guide Lenguajes y Paradigmas de Programaci\u00f3n, curso 2021-22 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Domingo Gallardo, Cristina Pomares, Antonio Bot\u00eda, Francisco Mart\u00ednez","title":"Descripci\u00f3n de la asignatura"},{"location":"teoria/tema00-descripcion-asignatura/tema00-descripcion-asignatura.html#lenguajes-y-paradigmas-de-programacion","text":"","title":"Lenguajes y Paradigmas de Programaci\u00f3n"},{"location":"teoria/tema00-descripcion-asignatura/tema00-descripcion-asignatura.html#1-datos-academicos-de-la-asignatura","text":"Departamento de Ciencia de la Computaci\u00f3n e Inteligencia Artificial 6 cr\u00e9ditos ECTS : 1 clase de teor\u00eda de 2 h. y 1 clase de pr\u00e1cticas de 2 h. a la semana Profesores : Antonio Bot\u00eda ( e-mail ): Grupos de pr\u00e1cticas: 2, 9 y 40 Domingo Gallardo ( e-mail ): Profesor coordinador de la asignatura. Grupos de teor\u00eda: 3, 4 y 40. Grupos de pr\u00e1cticas: 6 Francisco Mart\u00ednez ( e-mail ): Grupos de pr\u00e1cticas: 4, 5 y 8 Cristina Pomares ( e-mail ): Grupos de teor\u00eda: 1 y 2. Grupos de pr\u00e1cticas: 1, 3 y 7.","title":"1. Datos acad\u00e9micos de la asignatura"},{"location":"teoria/tema00-descripcion-asignatura/tema00-descripcion-asignatura.html#2-recursos-de-la-asignatura","text":"Ficha de la asignatura Apuntes de la asignatura (teor\u00eda, seminarios y pr\u00e1cticas) Sitio Moodle abierto y accesible a toda la comunidad educativa, contiene los apuntes, transparencias, pr\u00e1cticas y otros materiales docentes Foro de consultas y anuncios en el sitio Moodle (s\u00f3lo accesible a estudiantes)","title":"2. Recursos de la asignatura"},{"location":"teoria/tema00-descripcion-asignatura/tema00-descripcion-asignatura.html#3-objetivos-y-competencias","text":"Objetivos : \u00bfQu\u00e9 elementos son comunes a los lenguajes de programaci\u00f3n? \u00bfQu\u00e9 familias o paradigmas de lenguajes podemos identificar? \u00bfQu\u00e9 es la programaci\u00f3n funcional? \u00bfC\u00f3mo es un lenguaje multi-paradigma que combina la programaci\u00f3n funcional y la programaci\u00f3n orientada a objetos? Dominando estos contenidos ser\u00e1 mucho m\u00e1s f\u00e1cil aprender nuevos lenguajes de programaci\u00f3n, identificar sus aspectos esenciales e incluso ser capaz de dise\u00f1ar lenguajes espec\u00edficos orientados a dominios concretos. Competencias : Conocer y diferenciar las caracter\u00edsticas de los distintos paradigmas de programaci\u00f3n (programaci\u00f3n funcional, procedural y orientada a objetos) e identificarlas en lenguajes de programaci\u00f3n concretos. Diferenciar entre tiempo de ejecuci\u00f3n y tiempo de compilaci\u00f3n en distintos \u00e1mbitos: detecci\u00f3n de errores o definici\u00f3n, creaci\u00f3n o \u00e1mbito de vida de variables. Conocer los principios b\u00e1sicos de la programaci\u00f3n funcional: recursi\u00f3n, inmutabilidad, funciones como objetos de primera clase, funciones de orden superior, expresiones lambda (clausuras). Conocer los problemas derivados del uso de la mutaci\u00f3n en los lenguajes de programaci\u00f3n imperativos y la forma de trabajar con estructuras inmutables en lenguajes declarativos y funcionales. Utilizar la abstracci\u00f3n y la recursi\u00f3n para dise\u00f1ar correctamente procedimientos y estructuras de datos (listas y \u00e1rboles). Ser capaz de dise\u00f1ar, implementar y corregir programas funcionales, en concreto utilizando el lenguaje de programaci\u00f3n Scheme. Ser capaz de dise\u00f1ar, implementar y corregir programas funcionales, en concreto utilizando el lenguaje de programaci\u00f3n Swift. Conocer las caracter\u00edsticas de programaci\u00f3n orientada a objetos y de comprobaci\u00f3n est\u00e1tica de tipos del lenguaje de programaci\u00f3n Swift. Conocer el uso de gen\u00e9ricos y protocolos que proporciona el lenguaje. Ser capaz de implementar programas en Swift en los que se utilicen sus caracter\u00edsticas de programaci\u00f3n orientada a objetos, gen\u00e9ricos y protocolos.","title":"3. Objetivos y competencias"},{"location":"teoria/tema00-descripcion-asignatura/tema00-descripcion-asignatura.html#4-temario","text":"","title":"4. Temario"},{"location":"teoria/tema00-descripcion-asignatura/tema00-descripcion-asignatura.html#41-bloques-tematicos","text":"La asignatura se divide en 3 bloques tem\u00e1ticos, todos ellos de igual duraci\u00f3n, en los que se utilizar\u00e1 el lenguaje de programaci\u00f3n que aparece entre par\u00e9ntesis: Programaci\u00f3n funcional (Scheme): temas 1 y 2 Procesos y estructuras recursivas (Scheme): temas 3 y 4 Programaci\u00f3n funcional en Swift y programaci\u00f3n orientada a objetos (Swift): temas 5 y 6 Los lenguajes de programaci\u00f3n se introducir\u00e1n mediante seminarios impartidos en las clases de pr\u00e1cticas. Seminario 1. El lenguaje de programaci\u00f3n Scheme : Primitivas. Tipos de datos b\u00e1sicos. S\u00edmbolos. Cadenas. Listas. Definici\u00f3n de funciones. Seminario 2. El lenguaje de programaci\u00f3n Swift . Int\u00e9rprete y scripts. Tipos de datos b\u00e1sicos. Operadores. Estructuras de control. \u00c1mbito de variables. Tipos de datos compuestos: tuplas, arrays y colecciones. Recorriendo colecciones. Valores mutables e inmutables. Inicializaci\u00f3n. Tipos de referencia y valor en Swift.","title":"4.1. Bloques tem\u00e1ticos"},{"location":"teoria/tema00-descripcion-asignatura/tema00-descripcion-asignatura.html#42-temas","text":"Tema 1. Lenguajes de programaci\u00f3n : Historia de los lenguajes de programaci\u00f3n. Elementos de los lenguajes de programaci\u00f3n. Abstracci\u00f3n. Paradigmas de programaci\u00f3n. Compiladores e int\u00e9rpretes. Tema 2. Programaci\u00f3n Funcional : Caracter\u00edsticas e historia del paradigma de Programaci\u00f3n Funcional. Diferencias con el paradigma imperativo. Caracter\u00edsticas declarativas del paradigma funcional. Definici\u00f3n de funciones. Funciones como datos de primer orden. La forma especial lambda. \u00c1mbito de variables y clausuras. Datos compuestos en Scheme: parejas. Construcci\u00f3n, recorrido y operaciones sobre listas. Listas con elementos compuestos. Listas de listas. Tema 3. Procedimientos recursivos : Dise\u00f1o de funciones recursivas. Recursi\u00f3n mutua. Procesos recursivos e iterativos. Memoization. Recursi\u00f3n y gr\u00e1ficos de tortuga. Tema 4. Estructuras recursivas : Estructuras de datos recursivas: listas estructuradas y \u00e1rboles. Tema 5. Programaci\u00f3n funcional en Swift : Lenguajes multiparadigma. Programaci\u00f3n funcional en Swift. Valores opcionales. Listas. Recursi\u00f3n pura y recursi\u00f3n por la cola. Funciones como datos de primer orden. Clausuras y funciones an\u00f3nimas. Funciones de orden superior: mappings y filtros de colecciones. Tema 6. Programaci\u00f3n Orientada a Objetos en Swift : Caracter\u00edsticas e historia del paradigma de Programaci\u00f3n Orientada a Objetos. Estructuras y clases en Swift. Herencia. Conceptos avanzados de POO en Swift: Extensiones, Protocolos y Gen\u00e9ricos. El calendario de temas, pr\u00e1cticas y ex\u00e1menes se puede ver en la siguiente figura.","title":"4.2. Temas"},{"location":"teoria/tema00-descripcion-asignatura/tema00-descripcion-asignatura.html#5-practicas","text":"Las pr\u00e1cticas son fundamentales en la asignatura y sirven para comprender, trabajar y profundizar los conceptos y competencias estudiados en las clases de teor\u00eda. Para el desarrollo de las pr\u00e1cticas utilizaremos los siguientes lenguajes de programaci\u00f3n y entornos de desarrollo: Racket (versi\u00f3n de Scheme, lenguaje de programaci\u00f3n funcional) Swift (lenguaje multiparadigma creado por Apple, con conceptos modernos de programaci\u00f3n funcional y programaci\u00f3n orientada a objetos) Cada semana tendr\u00e1s que realizar una hoja de ejercicios en la que se incluir\u00e1 un repaso de la teor\u00eda vista la semana anterior y 5 o 6 peque\u00f1os problemas de programaci\u00f3n relacionados con esa teor\u00eda. La hoja de ejercicios estar\u00e1 disponible al comienzo de la semana y tendr\u00e1s toda la semana para su realizaci\u00f3n. Una vez entregada la pr\u00e1ctica podr\u00e1s acceder a su soluci\u00f3n. Revisa la soluci\u00f3n de la pr\u00e1ctica Es muy importante que revises la soluci\u00f3n de la pr\u00e1ctica y la compares con la soluci\u00f3n que has obtenido. Pregunta a tu profesor de pr\u00e1cticas en caso de que tengas dudas sobre si tu soluci\u00f3n es correcta. En la clase de pr\u00e1cticas se resolver\u00e1n dudas sobre la soluci\u00f3n de la pr\u00e1ctica anterior y se trabajar\u00e1 en la hoja de ejercicios publicada esa semana. Durante la sesi\u00f3n de pr\u00e1cticas el profesor estar\u00e1 disponible para resolver dudas y dar pistas sobre c\u00f3mo atacar los problemas. Tambi\u00e9n durante la semana se podr\u00e1n consultar las dudas que puedan surgir en el foro de la asignatura (en Moodle) y con tutor\u00edas a los profesores. Es preferible el foro, porque de esta forma las contestaciones y aclaraciones ser\u00e1n compartidas con el resto de compa\u00f1eros.","title":"5. Pr\u00e1cticas"},{"location":"teoria/tema00-descripcion-asignatura/tema00-descripcion-asignatura.html#6-horarios","text":"La distribuci\u00f3n de grupos del curso 2021-22 es la siguiente: En los turnos de teor\u00eda es posible, de forma excepcional, asistir a un grupo distinto del asignado. En los turnos de pr\u00e1cticas se debe asistir al grupo al que se ha asignado. El cambio de turno deber\u00e1 solicitarse en la Secretar\u00eda de la EPS.","title":"6. Horarios"},{"location":"teoria/tema00-descripcion-asignatura/tema00-descripcion-asignatura.html#7-evaluacion","text":"","title":"7. Evaluaci\u00f3n"},{"location":"teoria/tema00-descripcion-asignatura/tema00-descripcion-asignatura.html#71-convocatoria-ordinaria-c3-evaluacion-continua","text":"La asignatura se divide en 3 bloques tem\u00e1ticos, todos ellos de igual duraci\u00f3n, en los que se utilizar\u00e1 el lenguaje de programaci\u00f3n que aparece entre par\u00e9ntesis: Programaci\u00f3n funcional (temas 1 y 2, Scheme) Recursi\u00f3n y estructuras de datos recursivas (temas 3 y 4, Scheme) Programaci\u00f3n funcional en Swift y programaci\u00f3n orientada a objetos (temas 5 y 6, Swift) Se realizar\u00e1n tres ex\u00e1menes parciales escritos sobre los conceptos de cada uno de los bloques tem\u00e1ticos (teor\u00eda y pr\u00e1ctica). Los parciales tendr\u00e1n la siguiente ponderaci\u00f3n en la nota final: Parcial 1: 35% Parcial 2: 30% Parcial 3: 35% No se exige nota m\u00ednima en ninguno de los parciales. Los parciales 1 y 2 se realizar\u00e1n durante el curso. El parcial 3 se realizar\u00e1 en la fecha del examen oficial de la convocatoria ordinaria de la asignatura. Sobre los dispositivos m\u00f3viles Durante la realizaci\u00f3n de los ex\u00e1menes no est\u00e1 permitido que llev\u00e9is encima ning\u00fan dispositivo con conexi\u00f3n a internet (smartphones, smart watches, tablets, etc). Antes de empezar la prueba, se deber\u00e1n dejar dentro de las mochilas, y \u00e9stas en el suelo. En caso de no cumplir alguna esta norma, la prueba queda invalidada con calificaci\u00f3n de 0.","title":"7.1. Convocatoria ordinaria C3 (evaluaci\u00f3n continua)"},{"location":"teoria/tema00-descripcion-asignatura/tema00-descripcion-asignatura.html#72-convocatoria-extraordinaria-c4","text":"En la convocatoria extraordinaria se realizar\u00e1 un examen final sobre todos los bloques tem\u00e1ticos cuya calificaci\u00f3n representar\u00e1 el 100% de la nota de la asignatura.","title":"7.2. Convocatoria extraordinaria C4"},{"location":"teoria/tema00-descripcion-asignatura/tema00-descripcion-asignatura.html#8-consejos-para-aprender-con-exito-los-contenidos-de-la-asignatura","text":"El consejo fundamental para aprobar la asignatura es trabajar todas las semanas e intentar seguir el ritmo de la asignatura . Los conceptos de la asignatura se van construyendo de forma progresiva y lo visto en una semana depende muchas veces de lo aprendido en semanas anteriores. \u00bfC\u00f3mo estudiar estos conceptos? Con la excepci\u00f3n de algunos temas y apartados concretos (como la historia de los lenguajes de programaci\u00f3n o las caracter\u00edsticas de los distintos paradigmas) la asignatura es fundamentalmente pr\u00e1ctica. Cuando hablamos de estudiar los ejemplos de c\u00f3digo queremos decir entenderlos, no aprenderlos de memoria . No tiene sentido aprender de memoria los ejercicios y los ejemplos vistos en clase. Hay que trabajarlos . Eso significa que, primero, hay que entenderlos sobre el papel y muy importante hay que probar todos los ejemplos en el int\u00e9rprete . Y probar significa escribir los ejemplos y jugar con ellos, proponiendo peque\u00f1as variantes, pregunt\u00e1ndose \u00bfqu\u00e9 pasar\u00eda si...? y prob\u00e1ndolo. En cuanto a las pr\u00e1cticas y a los ejercicios propuestos es fundamental pelearse con ellos e intentar hacerlos por uno mismo sin ver ninguna soluci\u00f3n . Es la \u00fanica forma de aprender: probando, equivoc\u00e1ndose y encontrando la soluci\u00f3n por uno mismo. A la hora de enfrentarse con un problema es fundamental tambi\u00e9n usar l\u00e1piz y papel para probar enfoques y encontrar la soluci\u00f3n m\u00e1s sencilla sobre el papel antes de probarla en el int\u00e9rprete. Los ejercicios que proponemos no son excesivamente complicados. Todos se resuelven con muy pocas l\u00edneas de c\u00f3digo y su codificaci\u00f3n en el ordenador no tiene dificultad, una vez que se ha encontrado la soluci\u00f3n que lo resuelve. Al usar el l\u00e1piz y papel tambi\u00e9n estar\u00e1s practicando una situaci\u00f3n similar a la que te vas a encontrar en los ex\u00e1menes de la asignatura. Resumiendo: trabajar todas las semanas, hacer uno mismo todos los ejercicios y no desanimarse ni descolgarse. Son muy interesantes algunos comentarios de antiguos estudiantes que han aprobado la asignatura. C\u00f3mo dominar los conceptos Para superar la asignatura lo que hice fue estudiar mucho. Hay que practicar y sobre todo entender los ejercicios y no sabe\u0301rselos de memoria. Una vez dominados los ejercicios yo mismo me propuse variantes de los mismos. Asi\u0301 es como se domina. El problema del cambio de paradigma El problema principal de la asignatura es enfrentarse a un cambio del paradigma de programacio\u0301n.\" Trabajar d\u00eda a d\u00eda Lo que hice fue tratar de llevar al di\u0301a toda la asignatura, adema\u0301s de trabajar con material adicional para poder ampliar y profundizar conocimientos. LPP es una asignatura de fondo en la que tienes que mantener el ritmo de trabajo de principio a fin de cuatrimestre.\" No copiar las pr\u00e1cticas El mayor problema que creo que existe es que muchas personas se relajan y se copian las pra\u0301cticas en cuanto les resultan un poco difi\u0301ciles o les lleva algo mas del tiempo que les gustari\u0301a. Esta asignatura si no haces tu los ejercicios y te peleas con ellos es pra\u0301cticamente imposible de sacar. No memorizar Otra de las cosas es que tienes que cambiar la forma de estudiar, no vale memorizar, ni hacer muchos ejercicios sin ma\u0301s. Tienes que entender bien el funcionamiento de la recursio\u0301n para luego poder practicar con ejercicios, sino no sirve. [...] En mi opinio\u0301n el problema de LPP para mucha gente es que para los exa\u0301menes se memorizan los ejercicios de pra\u0301cticas de las soluciones que se dan en clase. Plantearse uno mismo problemas Los problemas que me encontre\u0301 a la hora de cursar LPP fue que eran dos lenguajes completamente nuevos, otro tipo de programacio\u0301n que nunca habi\u0301a visto, otra forma de estudiar distinta. Para poder superarla simplemente tienes que hacer ejercicios y tambie\u0301n plantearte tu\u0301 mismo nuevos ejercicios.","title":"8. Consejos para aprender con \u00e9xito los contenidos de la asignatura"},{"location":"teoria/tema00-descripcion-asignatura/tema00-descripcion-asignatura.html#9-bibliografia","text":"En Moodle se publican los apuntes de la asignatura, con ejercicios, explicaciones y ejemplos de todos los conceptos estudiados, tanto en teor\u00eda como en pr\u00e1ctica. Para ampliar algunos conceptos se recomiendan las siguientes referencias: Harold Abelson y Gerald Jay Sussman, Structure and Interpretation of Computer Programs , MIT Press, 1996 Enlace a la edici\u00f3n on-line Signatura en la Biblioteca Polit\u00e9cnica: I.06/ABE/STR Apple, The Swift Programming Language The Racket Guide Lenguajes y Paradigmas de Programaci\u00f3n, curso 2021-22 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Domingo Gallardo, Cristina Pomares, Antonio Bot\u00eda, Francisco Mart\u00ednez","title":"9. Bibliograf\u00eda"},{"location":"teoria/tema01-historia-lenguajes-programacion/tema01-historia-lenguajes-programacion.html","text":"Tema 1: Historia y conceptos de los lenguajes de programaci\u00f3n \u00b6 1. Historia de los lenguajes de programaci\u00f3n \u00b6 1.1. De las m\u00e1quinas de calcular a los computadores programables \u00b6 M\u00e1quina de Schickard (1623) Calculadora de Pascal (1650) Desde las primeras calculadoras mec\u00e1nicas dise\u00f1adas en el siglo XVII hasta los a\u00f1os 40 del siglo pasado se han inventado multitud de m\u00e1quinas y computadores mec\u00e1nicos, anal\u00f3gicos o electr\u00f3nicos que han intentado acelerar y mejorar la precisi\u00f3n de los c\u00e1lculos. El punto culminante de todos los enfoques mec\u00e1nicos para realizar c\u00e1lculos fue el famoso Motor Anal\u00edtico dise\u00f1ado por Charles Babbage en 1840. La diferencia fundamental con todos los artefactos anteriores es que se trataba de una m\u00e1quina de calcular programable mediante tarjetas perforadas (Babbage se inspir\u00f3 en el telar de Jackquard en el que el dise\u00f1o de los dibujos de las telas se pod\u00edan configurar usando tarjetas perforadas). La m\u00e1quina estaba dise\u00f1ada para trabajar en base 10 y se pod\u00eda conseguir que sus c\u00e1lculos realizaran saltos condicionales y bucles. Babbage trabaj\u00f3 durante m\u00e1s de 30 a\u00f1os para intentar construir la m\u00e1quina. Ten\u00eda una enorme complejidad para la \u00e9poca y necesitaba much\u00edsima financiaci\u00f3n. En 1871 muri\u00f3 habiendo podido construir s\u00f3lo una parte. La matem\u00e1tica Ada Lovelace tuvo un papel fundamental en la divulgaci\u00f3n de la m\u00e1quina, de su sistema de programaci\u00f3n y fue la primera que entendi\u00f3 sus posibilidades m\u00e1s all\u00e1 del c\u00e1lculo de f\u00f3rmulas. De forma poco habitual para la \u00e9poca, Ada fue educada en el campo de las ciencias y de las matem\u00e1ticas. A principios de 1840, con veinticico a\u00f1os, conoci\u00f3 el trabajo de Babbage y colabor\u00f3 con \u00e9l, dedic\u00e1ndose durante varios a\u00f1os a conocer y estudiar el dise\u00f1o y el funcionamiento del motor anal\u00edtico. En 1843 public\u00f3 el trabajo \"Sketch of the analytical engine invented by Charles Babbage\" en el que describe el Motor Anal\u00edtico, a\u00f1ade reflexiones propias sobre el alcance del invento y construye un ejemplo completo, con tablas y diagramas, de c\u00f3mo hacer que la m\u00e1quina produzca la secuencia de los n\u00fameros de Bernoulli. Se puede considerar estas tablas y diagramas como el primer programa de un computador . Antes de que existiera ning\u00fan computador real, en 1936, el matem\u00e1tico ingl\u00e9s Alan Turing formaliz\u00f3 la idea abstracta de computador, utilizando un modelo muy sencillo de procesamiento: una m\u00e1quina abstracta con un scanner que lee y escribe 0s y 1s de una cinta infinita (memoria) y se mueve y los escribe en funci\u00f3n de una tabla definida en la m\u00e1quina (programa). Con esta m\u00e1quina abstracta ( M\u00e1quina de Turing ) Turing explora la idea de lo computable y lo no computable. \u00bfExisten problemas no computables para los que no es posible inventar un algoritmo que los resuelva? Turing demuestra que s\u00ed y establece con su trabajo los l\u00edmites de la computaci\u00f3n. En el mismo trabajo Turing define el concepto de m\u00e1quina universal que es capaz de leer de la cinta un programa cualquiera y simular su comportamiento en otra parte de la cinta. Esta idea tuvo un profundo impacto en el desarrollo de los computadores, porque mostraba que es posible escribir programas que tomen como datos otros programas. Esto abre la puerta a la idea de los programas almacenados en memoria (ya que son otros datos m\u00e1s) y a la creaci\u00f3n de compiladores e int\u00e9rpretes. En la d\u00e9cada de 1940 hubo una explosi\u00f3n de m\u00e1quinas de computaci\u00f3n electr\u00f3nicas y electromec\u00e1nicas. Fue una d\u00e9cada prodigiosa en la que se desarrollaron tecnolog\u00edas cada vez m\u00e1s r\u00e1pidas y resistentes, y se consiguieron enormes avances en la velocidad y precisi\u00f3n de los c\u00e1lculos. A mitad de esa d\u00e9cada, en 1945, John Von Neumann , que trabajaba en la construcci\u00f3n del ENIAC , introdujo un avance fundamental. Propuso su famosa arquitectura en la que por primera vez se proponen las dos ideas claves de los computadores de prop\u00f3sito general: el programa almacenado en memoria y un conjunto de instrucciones de procesamiento que incluye el direccionamiento indirecto. Y en 1948, tres a\u00f1os despu\u00e9s, se construy\u00f3 en la universidad de Manchester el primer computador electr\u00f3nico digital de prop\u00f3sito general que utilizaba esta arquitectura (llamado Baby ). Fue dise\u00f1ado por Max Newmann usando la tecnolog\u00eda proporcionada por los ingenieros F.C. Williams y Tom Kilburn. Williams hab\u00eda inventado un dispositivo de memoria electr\u00f3nico (la v\u00e1lvula de Williams ) capaz de sustituir las lentas l\u00edneas de retardo de mercurio utilizadas hasta ese momento. La m\u00e1quina de Manchester fue el primer computador con un conjunto de instrucciones completo, capaz de realizar saltos, condicionales y direccionamiento indirecto. La primera ejecuci\u00f3n de un programa fue el 21 de junio de 1948. En ese a\u00f1o Alan Turing se incorpor\u00f3 a la universidad de Manchester, como director del Laboratorio de Computaci\u00f3n. Tres a\u00f1os despu\u00e9s, con un dise\u00f1o ampliado en el que tambi\u00e9n influy\u00f3 Turing, una versi\u00f3n mucho mayor de la m\u00e1quina se convirti\u00f3 en el primer computador disponible comercialmente, el Ferranti Mark I. El primero se instal\u00f3 en la universidad de Manchester en febrero de 1951, un mes antes que el UNIVAC I fuera entregado al Departamento de Censo de los EEUU. Se vendieron otras 10 m\u00e1quinas a Gran Breta\u00f1a, Canad\u00e1, Holanda e Italia. El primer programa complejo de Inteligencia Artificial, un jugador de damas escrito por Christopher Strachey, se ejecut\u00f3 en el verano de 1952 en el Ferranti Mark I en el Laboratorio de Computaci\u00f3n de Manchester. Strachey escribi\u00f3 el programa animado por Turing y usando el manual de programaci\u00f3n del Ferranti que Turing acababa de escribir. Turing particip\u00f3 tambi\u00e9n en el desarrollo de otros programas de IA, como un jugador de ajedrez basado en heur\u00edsticas. 1.2. Los primeros lenguajes de programaci\u00f3n \u00b6 Los primeros computadores electr\u00f3nicos se programaban directamente usando el conjunto de instrucciones del procesador, en c\u00f3digo m\u00e1quina, c\u00f3digo hexadecimal El primer lenguaje de un nivel algo m\u00e1s elevado que el c\u00f3digo m\u00e1quina es el ensamblador. Comienzan a crearse los primeros programas que procesan lenguajes de programaci\u00f3n, aunque se trata de programas muy sencillos, ya que hay una relaci\u00f3n casi directa entre la notaci\u00f3n en ensamblador y el c\u00f3digo hexadecimal que produce el ensamblador. A finales de la d\u00e9cada de los 40 se empiezan a intentar resolver con los primeros computadores los primeros problemas matem\u00e1ticos distintos de operaciones num\u00e9ricas: codificaci\u00f3n y descodificaci\u00f3n, problemas combinatorios como el coloreado del mapa o problemas de ordenaci\u00f3n. Uno de los primeros algoritmos de von Neumann realiza una ordenaci\u00f3n de un conjunto de n\u00fameros. Von Neumann lo describe en una carta fechada en 1945. Utiliza el conjunto de instrucciones del EDSAC cuando todav\u00eda no se hab\u00eda construido. El programa fue estudiado por Donald Knuth en el art\u00edculo Von Neumann's first Computer Program , en donde documenta que hab\u00eda un bug en las primeras instrucciones. Es el primer bug escrito del que se tiene historia. Si Von Neumann hubiera podido ejecutar el programa en el EDSAC se hubiera dado cuenta del error y hubiera sido la primera depuraci\u00f3n de un programa. Primer programa de Von Neumann (Donald Knuth, \"Von Neumann's first Computer Program\", Journal of the ACM Computing Surveys (CSUR) Surveys, Volume 2 Issue 4, Dec. 1970, Pages 247-260) 1.3. El nacimiento de los computadores comerciales \u00b6 UNIVAC El UNIVAC fue el primer computador comercial (1951). Con este computadora aparece por primera vez la figura del programador: manuales, cursos de formaci\u00f3n, ofertas de empleo, etc. UNIVAC Instalaciones comerciales del UNIVAC IBM 704 El IBM 704 fue el otro gran ordenador comercial de la d\u00e9cada de los 50. Tuvo una difusi\u00f3n mucho mayor que el UNIVAC: centros gubernamentales, universidades. Los primeros lenguajes de programaci\u00f3n de alto nivel se desarrollan para este computador. Foto IBM 704 1.3.1. Programando los primeros computadores \u00b6 El UNIVAC I era una m\u00e1quina interesante para programar, con su almacenamiento basado en l\u00edneas de retardo de mercurio y su propensi\u00f3n a fallar. Los programas se introduc\u00edan en el computador tecle\u00e1ndolos en cintas magn\u00e9ticas, una innovaci\u00f3n importante en ese tiempo. El trabajo con el IBM 704 en la Universidad de NY fue una experiencia radicalmente distinta de la del UNIVAC I. Fue construido para ejecutar aplicaciones cient\u00edficas, y su principal innovaci\u00f3n era una memoria de n\u00facleo magn\u00e9tico, reemplazando la memoria de tubos Williams del IBM 701. Tambi\u00e9n ten\u00eda una unidad aritm\u00e9tica en punto flotante. La m\u00e1quina ten\u00eda el equivalente a 128 KB de memoria principal, 32 KB de memoria secundaria y cintas magn\u00e9ticas que pod\u00eda almacenar 5 MB de datos. Operaba a 0.04 MIPS y cost\u00f3 3 millones de d\u00f3lares en 1957. George Sadowsky, My Second Computer was a UNIVAC I 1.4. Los primeros lenguajes de alto nivel \u00b6 Los primeros lenguajes de alto nivel se desarrollaron a finales de la d\u00e9cada de los 50: FORTRAN en 1956 Lisp en 1958 Ambos lenguajes planteaban dos enfoques muy distintos desde el principio: FORTRAN Primer lenguaje comercial, equipo de IBM dirigido por John W. Backus Lenguaje imperativo: estado, estructuras de control, contador de programa, celdas de memoria Lenguaje compilado Lisp Lenguaje dise\u00f1ado en un departamento de investigaci\u00f3n, un equipo del MIT dirigido por John McCarthy Lenguaje funcional: funciones, recursi\u00f3n, listas, s\u00edmbolos Lenguaje interpretado 1.4.1. FORTRAN \u00b6 Desarrollado por IBM para programar el IBM 704. Algunos datos: Su nombre proviene de FORmula TRANslating system . El primer manual de FORTRAN se imprime en octubre de 1956 para el IBM 704. El primer compilador se comercializa en abril de 1956. Cita de John Backus ( Wikipedia sobre FORTRAN ): Una gran parte de mi trabajo viene del hecho de que soy perezoso. No me gustaba escribir programas, y cuando estaba trabajando en el IBM 701, escribiendo programas para calcular la trayectoria de misiles, comenc\u00e9 a trabajar en un sistema de programaci\u00f3n que hiciera m\u00e1s f\u00e1cil escribir programas. John Backus Ejemplo FORTRAN Tomado del manual de FORTRAN del IBM 704 1.4.2. Lisp \u00b6 El otro lenguaje de alto nivel desarrollado en esa \u00e9poca es el Lisp. Desarrollado a finales de los 50 en el MIT por John McCarthy. Aunque hist\u00f3ricamente el nombre del lenguaje se sol\u00eda escribir con letras may\u00fasculas (LISP), posteriormente se ha popularizado el uso de la may\u00fascula s\u00f3lo para la primera letra (Lisp). Esta forma es m\u00e1s fiel al origen del nombre del lenguaje. Lisp no es un acr\u00f3nimo, sino la contracci\u00f3n de la expresi\u00f3n List Processing . El procesamiento de listas es una de las caracter\u00edsticas principales del Lisp. McCarthy explica en un art\u00edculo de 1979 la historia inicial del Lisp: [...] En el verano de 1956 durante el Dartmouth Summer Research Project on Artificial Intelligence, el primer estudio organizado de Inteligencia Artificial, tuve la idea de desarrollar un lenguaje algebraico para el procesamiento de listas. Quer\u00eda usarlo para el desarrollo de trabajo en inteligencia artificial en el IBM 704. [...] John McCarthy, History of LISP John McCarthy Uno de los primeros manuales de Lisp publicados es el manual de LISP de 1960 para el IBM 704 escrito por Phyllis A. Fox. del grupo de investigaci\u00f3n del MIT dirigido por McCarthy. Un ejemplo de c\u00f3digo Lisp: Ejemplo LISP Tomado de \" The Programming Language LISP \", MIT Press, 1964 1.5. La explosi\u00f3n de los lenguajes de programaci\u00f3n \u00b6 Desde 1954 hasta la actualidad se han documentado m\u00e1s de 2.500 (consultar en The Language List ). Entre 1952 y 1972 alrededor de 200 lenguajes. Una decena fueron realmente siginificativos y tuvieron influencia en el desarrollo de lenguajes posteriores. 1.5.1. Genealog\u00eda de los lenguajes de programaci\u00f3n \u00b6 Genealog\u00eda de los LP Algunas notas sobre la genealog\u00eda: APL es un lenguaje algebraico declarativo de especificaci\u00f3n de funciones y circuitos l\u00f3gicos. Su car\u00e1cter declarativo ha tenido influencia en lenguajes como Prolog o Haskell. Lisp no s\u00f3lo es un lenguaje funcional, sino que tambi\u00e9n es el primer lenguaje interpretado, con muchas caracter\u00edsticas de tiempo de ejecuci\u00f3n y poco chequeo est\u00e1tico. En esos aspectos ha influido en lenguajes din\u00e1micos no funcionales como Python o Smalltalk. Lenguajes como Smalltalk o Objective-C tambi\u00e9n heredan de Lisp algunas caracter\u00edsticas funcionales como la posibilidad de usar un bloque de c\u00f3digo como un objeto primitivo que se crea en tiempo de ejecuci\u00f3n y que se puede asignar o pasar como par\u00e1metro. Es lo que se denomina clausura en el paradigma de programaci\u00f3n funcional. SIMULA es el primer lenguaje que define conceptos como clase u objeto. Es el origen de la programaci\u00f3n orientada a objetos est\u00e1tica y fuertemente tipeada. Lenguajes como C++, Eiffel, o Java toman esta idea. Frente a esta tendencia se encuentra otra visi\u00f3n de la programaci\u00f3n orientada a objetos de lenguajes como Smalltalk u Objective-C en la que se enfatiza m\u00e1s aspectos din\u00e1micos como el paso de mensajes o la modificaci\u00f3n de clases en tiempo de ejecuci\u00f3n. 1.5.2. Algunos lenguajes importantes y su fecha de creaci\u00f3n \u00b6 1950-1960 1970 1980 1990 2000 1957 FORTRAN 1970 Pascal 1980 Smalltalk-80 1990 Haskell 2000 C# 1958 ALGOL 1972 Prolog 1983 Objective-C 1991 Python 2003 Scala 1960 Lisp 1972 C 1983 Ada 1993 Ruby 2003 Groovy 1960 COBOL 1975 Scheme 1986 C++ 1995 Java 2009 Go 1962 APL 1975 Modula 1986 Eiffel 1995 Racket 2014 Swift 1964 BASIC 1987 Perl 1967 SIMULA 1.5.3. Los creadores de los LPs \u00b6 Si comprobamos la historia de los lenguajes de programaci\u00f3n, podemos clasificar a sus creadores en tres grandes categor\u00edas: Investigadores trabajando en empresas ( Backus /IBM-FORTRAN, Gosling /Sun-Java) Investigadores en universidades y departamentos de Inform\u00e1tica ( McCarthy /MIT-Lisp, Wirth /ETH-Pascal, Odersky /EHT-Scala) Desarrolladores open source que distribuyen su trabajo a la comunidad ( Wall /Perl, Matsumoto /Ruby) 1.6. Lenguajes de programaci\u00f3n en la actualidad \u00b6 El \u00edndice TIOBE es un indicador de la popularidad de los lenguajes de programaci\u00f3n. El \u00edndice se actualiza una vez al mes. Las puntaciones se basan en estad\u00edsticas no reveladas que incluyen el n\u00famero de ingenieros en todo el mundo, cursos y aplicaciones desarrolladas. Tambi\u00e9n se utilizan resultados obtenidos en los motores de b\u00fasqueda m\u00e1s usados. El \u00edndice TIOBE no trata de medir el n\u00famero de l\u00edneas escritas en los lenguajes de programaci\u00f3n sino su popularidad e importancia en la comunidad. Lista TIOBE Tambi\u00e9n es muy interesante comprobar la evoluci\u00f3n de los 10 lenguajes m\u00e1s populares en los \u00faltimos 10 a\u00f1os. Evoluci\u00f3n TIOBE 1.6.1. La evoluci\u00f3n no se detiene \u00b6 Es interesante comprobar que cada vez es m\u00e1s f\u00e1cil desarrollar nuevos lenguajes de programaci\u00f3n. Las t\u00e9cnicas y herramientas de procesamiento de lenguajes se han popularizado cada vez m\u00e1s y son accesibles a mayor n\u00famero de personas. Los lenguajes ya no s\u00f3lo se crean en departamentos con un gran n\u00famero de investigadores, sino tambi\u00e9n en comunidades open source formadas por voluntarios interesados y motivados Ejemplos de nuevos lenguajes y sus creadores: Ruby Yukihiro Matsumoto Ruby ( Wikipedia ), un lenguaje de programaci\u00f3n ideado en 1993 por el desarrollador japon\u00e9s Yukihiro Matsumoto Lenguaje multi-paradigma interpretado y muy expresivo que actualmente se utiliza tanto para desarrollar aplicaciones web como videojuegos. Proyecto vivo, cada a\u00f1o aparecen nuevas versiones Scala Martin Odersky Scala ( Wikipedia ), dise\u00f1ado en 2003 por el profesor alem\u00e1n Martin Odersky Respuesta a los problemas de los lenguajes tradicionales imperativos para manejar la concurrencia Est\u00e1 implementado sobre Java y corre en la M\u00e1quina Virtual Java Go Ken Thompson Go ( Wikipedia ), el nuevo lenguaje de programaci\u00f3n de Google lanzado en 2009 Desarrollado, entre otros, por Ken Thompson, uno de los padres del UNIX Una mezcla de C y Python que intenta conseguir un lenguaje de programaci\u00f3n de sistemas muy eficiente, expresivo y tambi\u00e9n multiparadigma. Swift Chris Lattner Swift ( Wikipedia ), el nuevo lenguaje de programaci\u00f3n de Apple lanzado en 2014 Proyecto open source en el que se puede observar su evoluci\u00f3n y roadmap futuro Desarrollado, entre otros, por Chris Lattner , autor del sistema LLVM Compiler Infrastructure , conjunto de compilador, depurador, optimizador, etc. de c\u00f3digo C, C++ y Objective-C. Lenguaje moderno, multiparadigma (programaci\u00f3n orientada a objetos y funcional) fuertemente tipeado y compilado. 2. Elementos de los lenguajes de programaci\u00f3n \u00b6 2.1. Definici\u00f3n de la Encyclopedia of Computer Science \u00b6 Un lenguaje de programaci\u00f3n es un conjunto de caracteres, reglas para combinarlos y reglas para especificar sus efectos cuando sean ejecutados por un computador, que tienen las siguientes cuatro caracter\u00edsticas: No requiere ning\u00fan conocimiento de c\u00f3digo m\u00e1quina por parte del usuario. Tiene independencia de la m\u00e1quina. Se traduce a lenguaje m\u00e1guina. Utiliza una notaci\u00f3n que es m\u00e1s cercana al problema espec\u00edfico que se est\u00e1 resolviendo que al c\u00f3digo m\u00e1quina. 2.2. Definici\u00f3n de Abelson y Sussman \u00b6 Vamos a estudiar la idea de un proceso computacional . Los procesos computacionales son seres abstractos que habitan los computadores. Cuando est\u00e1n en marcha, los procesos manipulan otras cosas abstractas denominadas datos . La evoluci\u00f3n de un proceso est\u00e1 dirigida por un patr\u00f3n de reglas denominado un programa. [...] Y otra idea fundamental Un lenguaje de programaci\u00f3n potente es m\u00e1s que s\u00f3lo una forma de pedir a un computador que realice tareas. El lenguaje tambi\u00e9n sirve como un marco dentro del que organizamos nuestras ideas acerca de los procesos. As\u00ed, cuando describimos un lenguaje, deber\u00edamos prestar atenci\u00f3n particular a los medios que proporciona el lenguaje para combinar ideas simples para formar ideas m\u00e1s complejas. 2.3. Caracter\u00edsticas de un LP \u00b6 Define un proceso que se ejecuta en un computador Es de alto nivel, cercano a los problemas que se quieren resolver (abstracci\u00f3n) Permite construir nuevas abstracciones que se adapten al dominio que se programa 2.4. Elementos de un LP \u00b6 Para Abelson y Sussman, todos los lenguajes de progamaci\u00f3n permiten combinar ideas simples en ideas m\u00e1s complejas mediante los siguientes tres mecanismos Expresiones primitivas que representan las entidades m\u00e1s simples del lenguaje Mecanismos de combinaci\u00f3n con los que se construyen elementos compuestos a partir de elementos m\u00e1s simples Mecanismos de abstracci\u00f3n con los que dar nombre a los elementos compuestos y manipularlos como unidades 2.5. Sintaxis y sem\u00e1ntica \u00b6 Sintaxis : conjunto de reglas que definen qu\u00e9 expresiones de texto son correctas. Por ejemplo, en C todas las sentencias deben terminar en ';'. Sem\u00e1ntica : conjunto de reglas que define cu\u00e1l ser\u00e1 el resultado de la ejecuci\u00f3n de un programa en el computador. 2.6. Los lenguajes son para las personas \u00b6 Los lenguajes de programaci\u00f3n deben ser precisos, deben poder traducirse sin ambig\u00fcedad en lenguaje m\u00e1quina para que sean ejecutados por computadores. Pero deben ser utilizados (le\u00eddos, comentados, probados, etc.) por personas. La programaci\u00f3n es una actividad colaborativa y debe basarse en la comunicaci\u00f3n. 2.7. Importancia del aprendizaje de t\u00e9cnicas de LPs \u00b6 Es importante conocer c\u00f3mo funciona \"por dentro\" un lenguaje de programaci\u00f3n y sus caracter\u00edsticas comparadas. Mejora el uso del lenguaje de programaci\u00f3n Incrementa el vocabulario de los elementos de programaci\u00f3n Permite una mejor elecci\u00f3n del lenguaje de programaci\u00f3n Mejora la habilidad para desarrollar programas efectivos y eficientes Facilita el aprendizaje de un nuevo lenguaje de programaci\u00f3n Facilita el dise\u00f1o de nuevos lenguajes de programaci\u00f3n 3. Abstracci\u00f3n \u00b6 Una misi\u00f3n fundamental de los lenguajes de programaci\u00f3n es proporcionar herramientas que sirvan para construir abstracciones. Por ejemplo, estamos construyendo una abstracci\u00f3n cuando damos un nombre a una entidad del lenguaje (una variable, una funci\u00f3n, una clase, etc.). Escoger un buen nombre para los elementos que vamos construyendo en nuestro programas es fundamental para conseguir un c\u00f3digo legible y reutilizable. 3.1. Modelar como una actividad fundamental \u00b6 Para escribir un programa que preste unos servicios es fundamental modelar el dominio sobre el que va a trabajar Es necesario definir distintas abstracciones (tanto APIs, como datos) que nos permitan tratar sus elementos y comunicarnos correctamente con los usuarios que van a utilizar el programa. Las abstracciones que vamos construyendo van apoy\u00e1ndose unas en otras y permiten hacer compresible y comunicable un problema complejo Ejemplo: el modelado del funcionamiento de una biblioteca contiene abstracciones como \"libros\", \"pr\u00e9stamo\", \"reserva\", o \"libros disponibles\" que representan conceptos del dominio que deben ser implementados en nuestra soluci\u00f3n Casos de uso biblioteca 3.2. Abstracciones computacionales \u00b6 Existen abstracciones propias de la inform\u00e1tica ( computer science ), que se utilizan en m\u00faltiples dominios. Por ejemplo, abstracciones de datos como: Listas \u00c1rboles Grafos Tablas hash Tambi\u00e9n existen abstracciones que nos permiten tratar con dispositivos y ordenadores externos: Fichero Raster gr\u00e1fico Protocolo TCP/IP 3.3. Construcci\u00f3n de abstracciones \u00b6 Uno de los trabajos principales de un inform\u00e1tico es la construcci\u00f3n de abstracciones que permitan ahorrar tiempo y esfuerzo a la hora de tratar con la complejidad del mundo real. Cita de Joel Spolsky en su blog Joel on Software TCP es lo que los cient\u00edficos de computaci\u00f3n llaman una abstracci\u00f3n: una simplificaci\u00f3n de algo mucho m\u00e1s complicado que va por debajo de la cubierta. Resulta que una gran parte de la programaci\u00f3n de computadores consiste en construir abstracciones. \u00bfQu\u00e9 es una librer\u00eda de cadenas? Es una forma de hacer creer que los computadores pueden manipular cadenas tan f\u00e1cilmente como manipulan los n\u00fameros. \u00bfQu\u00e9 es un sistema de ficheros? Es una forma de hacer creer que un disco duro no es en realidad un mont\u00f3n de platos magn\u00e9ticos en rotaci\u00f3n que pueden almacenar bits en ciertas posiciones, sino en su lugar, un sistema jer\u00e1rquico de carpetas-dentro-de-carpetas que contiene ficheros individuales. 3.4. Distintos aspectos de los lenguajes de programaci\u00f3n \u00b6 La programaci\u00f3n es una disciplina compleja, que tiene que tener en cuenta m\u00faltiples aspectos de los lenguajes de programaci\u00f3n y las API: Programas como procesos runtime que se ejecutan en un computador. Tenemos que entender qu\u00e9 pasa cuando se crea un objeto, cu\u00e1nto tiempo permanece en memoria, cu\u00e1l es el \u00e1mbito de una variable, etc. Herramientas: depuradores, analizadores de rendimiento. Programas como declaraciones est\u00e1ticas. Hay que considerar un programa desde el punto de vista de una declaraci\u00f3n de nuevos tipos, nuevos m\u00e9todos, tipos gen\u00e9ricos, herencia entre clases, etc. Herramientas: entornos de programaci\u00f3n con autocompletado de c\u00f3digo, detecci\u00f3n de errores sint\u00e1cticos. Programas como comunicaci\u00f3n y actividad social. Tenemos que tener en cuenta que un programa va a ser usado por otras personas, le\u00eddo, extendido, mantenido, modificado. Los programas siempre se van a modificar. Herramientas: sistemas de control de versiones (Git, Mercurial, Github, Bitbucket), de gesti\u00f3n incidencias (Jira) , tests que evitan errores de regresi\u00f3n, ... 4. Paradigmas de programaci\u00f3n \u00b6 4.1. \u00bfQu\u00e9 es un paradigma de programaci\u00f3n? \u00b6 Un paradigma define un conjunto de caracter\u00edsticas, patrones y estilos de programaci\u00f3n basados en alguna idea fundamental. Por ejemplo el paradigma funcional se basa en la idea que una computaci\u00f3n se puede especificar como un conjunto de funciones que transforman valores de entrada en valores de salida. Es conveniente ver un paradigma como un estilo de programaci\u00f3n que puede usarse en distintos lenguajes de programaci\u00f3n y expresarse con distintas sintaxis. Por ejemplo, se puede escribir c\u00f3digo que use programaci\u00f3n l\u00f3gica en Prolog (ser\u00eda lo m\u00e1s natural), pero tambi\u00e9n en Java, usando alg\u00fan API espec\u00edfica. Normalmente todos los lenguajes tienen caracter\u00edsticas de m\u00e1s de un paradigma. Por motivos pr\u00e1cticos los lenguajes m\u00e1s populares no se limitan de forma estricta o pura a un \u00fanico paradigma de programaci\u00f3n. Por ejemplo, el Prolog es un lenguaje en su mayor parte l\u00f3gico y declarativo, pero tiene operadores imperativos como el corte . A pesar de ello, es normal adscribir un lenguaje al paradigma en el que es m\u00e1s sencillo o natural escribir c\u00f3digo usando sus construcciones. Existen lenguajes que refuerzan y promueven la expresi\u00f3n de c\u00f3digo en m\u00e1s de un paradigma de programaci\u00f3n. Y lo hacen no por necesidad o accidente, sino con el intento expl\u00edcito de fusionar m\u00e1s de un paradigma en una forma \u00fanica de programar. Estos lenguajes se denominan lenguajes multi-paradigma . Por ejemplo, Scala es lenguaje multi-paradigma en el que Martin Odersky, su creador, mezcla caracter\u00edsticas de programaci\u00f3n orientada a objetos con programaci\u00f3n funcional. Prolog o Lisp, aunque tienen caracter\u00edsticas no l\u00f3gicas o no funcionales, no pueden ser considerados multi-paradigma porque no fueron creados con la idea de integrar paradigmas variados en una forma coherente de expresi\u00f3n. Los paradigmas m\u00e1s importantes son: Paradigma funcional Paradigma l\u00f3gico Paradigma imperativo o procedural Paradigma orientado a objetos 4.2. Paradigma funcional \u00b6 Resumen de las caracter\u00edsticas principales: La computaci\u00f3n se realiza mediante la evaluaci\u00f3n de expresiones Definici\u00f3n de funciones Funciones como datos primitivos Valores sin efectos laterales, no existen referencias a celdas de memoria en las que se guarda un estado modificable Programaci\u00f3n declarativa (en la programaci\u00f3n funcional pura ) Lenguajes: Lisp, Scheme, Haskell, Scala, Clojure. Ejemplo de c\u00f3digo (Lisp): ( define ( factorial x ) ( if ( = x 0 ) 1 ( * x ( factorial ( - x 1 ))))) > ( factorial 8 ) 40320 > ( factorial 30 ) 265252859812191058636308480000000 4.3. Paradigma l\u00f3gico \u00b6 Caracter\u00edsticas: Definici\u00f3n de reglas Unificaci\u00f3n como elemento de computaci\u00f3n Programaci\u00f3n declarativa Lenguajes: Prolog, Mercury, Oz. Ejemplo de c\u00f3digo (Prolog): padrede ( 'juan' , 'maria' ). % juan es padre de maria padrede ( 'pablo' , 'juan' ). % pablo es padre de juan padrede ( 'pablo' , 'marcela' ). padrede ( 'carlos' , 'debora' ). hijode ( A , B ) :- padrede ( B , A ). abuelode ( A , B ) :- padrede ( A , C ), padrede ( C , B ). hermanode ( A , B ) :- padrede ( C , A ) , padrede ( C , B ), A \\== B . familiarde ( A , B ) :- padrede ( A , B ). familiarde ( A , B ) :- hijode ( A , B ). familiarde ( A , B ) :- hermanode ( A , B ). ?- hermanode ( 'juan' , 'marcela' ). yes ?- hermanode ( 'carlos' , 'juan' ). no ?- abuelode ( 'pablo' , 'maria' ). yes ?- abuelode ( 'maria' , 'pablo' ). no 4.4. Paradigma imperativo \u00b6 Los lenguajes de programaci\u00f3n que cumplen el paradigma imperativo se caracterizan por tener un estado impl\u00edcito que es modificado mediante instrucciones o comandos del lenguaje. Como resultado, estos lenguajes tienen una noci\u00f3n de secuenciaci\u00f3n de los comandos para permitir un control preciso y determinista del estado. Caracter\u00edsticas: Definici\u00f3n de procedimientos Definici\u00f3n de tipos de datos Chequeo de tipos en tiempo de compilaci\u00f3n Cambio de estado de variables Pasos de ejecuci\u00f3n de un proceso Ejemplo (Pascal): type tDimension = 1 .. 100 ; eMatriz ( f , c : tDimension ) = array [ 1 .. f , 1 .. c ] of real ; tRango = record f , c : tDimension value 1 ; end ; tpMatriz = ^ eMatriz ; procedure EscribirMatriz ( var m : tpMatriz ) ; var filas , col : integer ; begin for filas := 1 to m ^. f do begin for col := 1 to m ^. c do write ( m ^ [ filas , col ] : 7 : 2 ) ; writeln ( resultado ) ; writeln ( resultado ) end ; end ; 4.5. Paradigma orientado a objetos \u00b6 Caracter\u00edsticas: Definici\u00f3n de clases y herencia Objetos como abstracci\u00f3n de datos y procedimientos Polimorfismo y chequeo de tipos en tiempo de ejecuci\u00f3n Ejemplo (Java): public class Bicicleta { public int marcha ; public int velocidad ; public Bicicleta ( int velocidadInicial , int marchaInicial ) { marcha = marchaInicial ; velocidad = velocidadInicial ; } public void setMarcha ( int nuevoValor ) { marcha = nuevoValor ; } public void frenar ( int decremento ) { velocidad -= decremento ; } public void acelerar ( int incremento ) { velocidad += incremento ; } } public class MountainBike extends Bicicleta { public int alturaSillin ; public MountainBike ( int alturaInicial , int velocidadInicial , int marchaInicial ) { super ( velocidadInicial , marchaInicial ); alturaSillin = alturaInicial ; } public void setAltura ( int nuevoValor ) { alturaSillin = nuevoValor ; } } public class Excursion { public static void main ( String [] args ) { MountainBike miBicicleta = new MoutainBike ( 10 , 10 , 3 ); miBicicleta . acelerar ( 10 ); miBicicleta . setMarcha ( 4 ); miBicicleta . frenar ( 10 ); } } 5. Compiladores e int\u00e9rpretes \u00b6 En el nivel de abstracci\u00f3n m\u00e1s bajo, la ejecuci\u00f3n de un programa en un computador consiste en la ejecuci\u00f3n de un conjunto de instrucciones del c\u00f3digo m\u00e1quina del procesador. Por ejemplo, la siguiente figura muestra un ejemplo de un programa en ensamblador para un antiguo procesador (el Z80, procesador de 8 bits del m\u00edtico ZX Spectrum , uno de los primeros ordenadores personales en Europa): Ensamblador Z80 Dependiendo del tipo de lenguaje de programaci\u00f3n en el que est\u00e9 escrito este programa, el c\u00f3digo m\u00e1quina que se estar\u00e1 ejecutando ser\u00e1: el resultado de la compilaci\u00f3n del programa original (en el caso de un lenguaje compilado) el c\u00f3digo de un programa (int\u00e9rprete) que realiza la interpretaci\u00f3n del programa original (en el caso de un lenguaje interpretado) 5.1. Compilaci\u00f3n \u00b6 La siguiente figura (tomada, como las dem\u00e1s de este apartado del Programming Language Pragmatics ) muestra el proceso de generaci\u00f3n y ejecuci\u00f3n de un programa compilado. Compilaci\u00f3n El proceso de compilaci\u00f3n de un programa consiste en la traducci\u00f3n del c\u00f3digo fuente original en el lenguaje de alto nivel al c\u00f3digo m\u00e1quina espec\u00edfico del procesador en el que va a ejecutarse el programa. El c\u00f3digo m\u00e1quina resultante s\u00f3lo corre en el procesador para el que se ha generado. Por ejemplo, un programa C compilado para un procesador Intel no puede ejecutarse en un procesador ARM, como los Ax de Apple . Ejemplos: C, C++ Diferentes momentos en la vida de un programa: tiempo de compilaci\u00f3n y tiempo de ejecuci\u00f3n Mayor eficiencia 5.2. Interpretaci\u00f3n \u00b6 Interpretaci\u00f3n Ejemplos: BASIC, Lisp, Scheme, Python, Ruby No hay diferencia entre el tiempo de compilaci\u00f3n y el tiempo de ejecuci\u00f3n Mayor flexibilidad: el c\u00f3digo se puede construir y ejecutar \"on the fly\" (funciones lambda o clousures) Los lenguajes interpretados suelen proporcionar un shell o int\u00e9rprete. Se trata de un entorno interactivo en el que podemos definir y evaluar expresiones. Este entorno se denomina en los c\u00edrculos de programaci\u00f3n funcional un REPL ( Read , Eval , Print , Loop ) y ya se utiliz\u00f3 en los primeros a\u00f1os de implementaci\u00f3n del Lisp. El uso del REPL promueve una programaci\u00f3n interactiva en la que continuamente evaluamos y comprobamos el c\u00f3digo que desarrollamos. 5.3. Enfoques mixtos \u00b6 Existen tambi\u00e9n enfoques mixtos, como el usado por el lenguaje de programaci\u00f3n Java, en el que se realizan ambos procesos. En una primera fase el compilador de Java ( javac ) realiza una traducci\u00f3n del c\u00f3digo fuente original a un c\u00f3digo intermedio binario independiente del procesado, denominado bytecode . Este c\u00f3digo binario es multiplataforma. El c\u00f3digo intermedio es interpretado despu\u00e9s por un el int\u00e9rprete ( java ) que ya s\u00ed que es dependiente de la plataforma. En la figura el int\u00e9rprete se denomina Virtual machine (no confundir con el concepto de m\u00e1quina virtual que permite emular un sistema operativo, por ejemplo VirtualBox). Enfoque mixto (Java) Ejemplos: Java, Scala 6. Bibliograf\u00eda \u00b6 Introducci\u00f3n y cap\u00edtulo 1 del Structure and Interpretation of Computer Programs: Building Abstractions with Procedures Cap\u00edtulo 1.2 Programming Language Pragmatics: The Programming Language Spectrum Cap\u00edtulo 1.3 Programming Language Pragmatics, Why Study Programming Languages Cap\u00edtulo 1.4 Programming Language Pragmatics, Compilation and Interpretation Raul Rojas, \"Konrad Zuse's legacy the architecture of the Z1 and Z3\", IEEE Annals of the History of Computing, Vol. 19, No. 2, 1997 Charles Petzold, \"Code\", Microsoft Press, 2000 (Cap\u00edtulo 18: \"From Abaci to Chips\") Jack Copeland, \"The Modern History of Computing\", The Stanford Encyclopedia of Philosophy (Fall 2008 Edition), URL = http://plato.stanford.edu/archives/fall2008/entries/computing-history/ Georgi Dalakov, \"History of Computers\", URL = http://history-computer.com Lenguajes y Paradigmas de Programaci\u00f3n, curso 2021-22 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Domingo Gallardo, Cristina Pomares, Antonio Bot\u00eda, Francisco Mart\u00ednez","title":"Tema 1: Historia de los lenguajes de programaci\u00f3n"},{"location":"teoria/tema01-historia-lenguajes-programacion/tema01-historia-lenguajes-programacion.html#tema-1-historia-y-conceptos-de-los-lenguajes-de-programacion","text":"","title":"Tema 1: Historia y conceptos de los lenguajes de programaci\u00f3n"},{"location":"teoria/tema01-historia-lenguajes-programacion/tema01-historia-lenguajes-programacion.html#1-historia-de-los-lenguajes-de-programacion","text":"","title":"1. Historia de los lenguajes de programaci\u00f3n"},{"location":"teoria/tema01-historia-lenguajes-programacion/tema01-historia-lenguajes-programacion.html#11-de-las-maquinas-de-calcular-a-los-computadores-programables","text":"M\u00e1quina de Schickard (1623) Calculadora de Pascal (1650) Desde las primeras calculadoras mec\u00e1nicas dise\u00f1adas en el siglo XVII hasta los a\u00f1os 40 del siglo pasado se han inventado multitud de m\u00e1quinas y computadores mec\u00e1nicos, anal\u00f3gicos o electr\u00f3nicos que han intentado acelerar y mejorar la precisi\u00f3n de los c\u00e1lculos. El punto culminante de todos los enfoques mec\u00e1nicos para realizar c\u00e1lculos fue el famoso Motor Anal\u00edtico dise\u00f1ado por Charles Babbage en 1840. La diferencia fundamental con todos los artefactos anteriores es que se trataba de una m\u00e1quina de calcular programable mediante tarjetas perforadas (Babbage se inspir\u00f3 en el telar de Jackquard en el que el dise\u00f1o de los dibujos de las telas se pod\u00edan configurar usando tarjetas perforadas). La m\u00e1quina estaba dise\u00f1ada para trabajar en base 10 y se pod\u00eda conseguir que sus c\u00e1lculos realizaran saltos condicionales y bucles. Babbage trabaj\u00f3 durante m\u00e1s de 30 a\u00f1os para intentar construir la m\u00e1quina. Ten\u00eda una enorme complejidad para la \u00e9poca y necesitaba much\u00edsima financiaci\u00f3n. En 1871 muri\u00f3 habiendo podido construir s\u00f3lo una parte. La matem\u00e1tica Ada Lovelace tuvo un papel fundamental en la divulgaci\u00f3n de la m\u00e1quina, de su sistema de programaci\u00f3n y fue la primera que entendi\u00f3 sus posibilidades m\u00e1s all\u00e1 del c\u00e1lculo de f\u00f3rmulas. De forma poco habitual para la \u00e9poca, Ada fue educada en el campo de las ciencias y de las matem\u00e1ticas. A principios de 1840, con veinticico a\u00f1os, conoci\u00f3 el trabajo de Babbage y colabor\u00f3 con \u00e9l, dedic\u00e1ndose durante varios a\u00f1os a conocer y estudiar el dise\u00f1o y el funcionamiento del motor anal\u00edtico. En 1843 public\u00f3 el trabajo \"Sketch of the analytical engine invented by Charles Babbage\" en el que describe el Motor Anal\u00edtico, a\u00f1ade reflexiones propias sobre el alcance del invento y construye un ejemplo completo, con tablas y diagramas, de c\u00f3mo hacer que la m\u00e1quina produzca la secuencia de los n\u00fameros de Bernoulli. Se puede considerar estas tablas y diagramas como el primer programa de un computador . Antes de que existiera ning\u00fan computador real, en 1936, el matem\u00e1tico ingl\u00e9s Alan Turing formaliz\u00f3 la idea abstracta de computador, utilizando un modelo muy sencillo de procesamiento: una m\u00e1quina abstracta con un scanner que lee y escribe 0s y 1s de una cinta infinita (memoria) y se mueve y los escribe en funci\u00f3n de una tabla definida en la m\u00e1quina (programa). Con esta m\u00e1quina abstracta ( M\u00e1quina de Turing ) Turing explora la idea de lo computable y lo no computable. \u00bfExisten problemas no computables para los que no es posible inventar un algoritmo que los resuelva? Turing demuestra que s\u00ed y establece con su trabajo los l\u00edmites de la computaci\u00f3n. En el mismo trabajo Turing define el concepto de m\u00e1quina universal que es capaz de leer de la cinta un programa cualquiera y simular su comportamiento en otra parte de la cinta. Esta idea tuvo un profundo impacto en el desarrollo de los computadores, porque mostraba que es posible escribir programas que tomen como datos otros programas. Esto abre la puerta a la idea de los programas almacenados en memoria (ya que son otros datos m\u00e1s) y a la creaci\u00f3n de compiladores e int\u00e9rpretes. En la d\u00e9cada de 1940 hubo una explosi\u00f3n de m\u00e1quinas de computaci\u00f3n electr\u00f3nicas y electromec\u00e1nicas. Fue una d\u00e9cada prodigiosa en la que se desarrollaron tecnolog\u00edas cada vez m\u00e1s r\u00e1pidas y resistentes, y se consiguieron enormes avances en la velocidad y precisi\u00f3n de los c\u00e1lculos. A mitad de esa d\u00e9cada, en 1945, John Von Neumann , que trabajaba en la construcci\u00f3n del ENIAC , introdujo un avance fundamental. Propuso su famosa arquitectura en la que por primera vez se proponen las dos ideas claves de los computadores de prop\u00f3sito general: el programa almacenado en memoria y un conjunto de instrucciones de procesamiento que incluye el direccionamiento indirecto. Y en 1948, tres a\u00f1os despu\u00e9s, se construy\u00f3 en la universidad de Manchester el primer computador electr\u00f3nico digital de prop\u00f3sito general que utilizaba esta arquitectura (llamado Baby ). Fue dise\u00f1ado por Max Newmann usando la tecnolog\u00eda proporcionada por los ingenieros F.C. Williams y Tom Kilburn. Williams hab\u00eda inventado un dispositivo de memoria electr\u00f3nico (la v\u00e1lvula de Williams ) capaz de sustituir las lentas l\u00edneas de retardo de mercurio utilizadas hasta ese momento. La m\u00e1quina de Manchester fue el primer computador con un conjunto de instrucciones completo, capaz de realizar saltos, condicionales y direccionamiento indirecto. La primera ejecuci\u00f3n de un programa fue el 21 de junio de 1948. En ese a\u00f1o Alan Turing se incorpor\u00f3 a la universidad de Manchester, como director del Laboratorio de Computaci\u00f3n. Tres a\u00f1os despu\u00e9s, con un dise\u00f1o ampliado en el que tambi\u00e9n influy\u00f3 Turing, una versi\u00f3n mucho mayor de la m\u00e1quina se convirti\u00f3 en el primer computador disponible comercialmente, el Ferranti Mark I. El primero se instal\u00f3 en la universidad de Manchester en febrero de 1951, un mes antes que el UNIVAC I fuera entregado al Departamento de Censo de los EEUU. Se vendieron otras 10 m\u00e1quinas a Gran Breta\u00f1a, Canad\u00e1, Holanda e Italia. El primer programa complejo de Inteligencia Artificial, un jugador de damas escrito por Christopher Strachey, se ejecut\u00f3 en el verano de 1952 en el Ferranti Mark I en el Laboratorio de Computaci\u00f3n de Manchester. Strachey escribi\u00f3 el programa animado por Turing y usando el manual de programaci\u00f3n del Ferranti que Turing acababa de escribir. Turing particip\u00f3 tambi\u00e9n en el desarrollo de otros programas de IA, como un jugador de ajedrez basado en heur\u00edsticas.","title":"1.1. De las m\u00e1quinas de calcular a los computadores programables"},{"location":"teoria/tema01-historia-lenguajes-programacion/tema01-historia-lenguajes-programacion.html#12-los-primeros-lenguajes-de-programacion","text":"Los primeros computadores electr\u00f3nicos se programaban directamente usando el conjunto de instrucciones del procesador, en c\u00f3digo m\u00e1quina, c\u00f3digo hexadecimal El primer lenguaje de un nivel algo m\u00e1s elevado que el c\u00f3digo m\u00e1quina es el ensamblador. Comienzan a crearse los primeros programas que procesan lenguajes de programaci\u00f3n, aunque se trata de programas muy sencillos, ya que hay una relaci\u00f3n casi directa entre la notaci\u00f3n en ensamblador y el c\u00f3digo hexadecimal que produce el ensamblador. A finales de la d\u00e9cada de los 40 se empiezan a intentar resolver con los primeros computadores los primeros problemas matem\u00e1ticos distintos de operaciones num\u00e9ricas: codificaci\u00f3n y descodificaci\u00f3n, problemas combinatorios como el coloreado del mapa o problemas de ordenaci\u00f3n. Uno de los primeros algoritmos de von Neumann realiza una ordenaci\u00f3n de un conjunto de n\u00fameros. Von Neumann lo describe en una carta fechada en 1945. Utiliza el conjunto de instrucciones del EDSAC cuando todav\u00eda no se hab\u00eda construido. El programa fue estudiado por Donald Knuth en el art\u00edculo Von Neumann's first Computer Program , en donde documenta que hab\u00eda un bug en las primeras instrucciones. Es el primer bug escrito del que se tiene historia. Si Von Neumann hubiera podido ejecutar el programa en el EDSAC se hubiera dado cuenta del error y hubiera sido la primera depuraci\u00f3n de un programa. Primer programa de Von Neumann (Donald Knuth, \"Von Neumann's first Computer Program\", Journal of the ACM Computing Surveys (CSUR) Surveys, Volume 2 Issue 4, Dec. 1970, Pages 247-260)","title":"1.2. Los primeros lenguajes de programaci\u00f3n"},{"location":"teoria/tema01-historia-lenguajes-programacion/tema01-historia-lenguajes-programacion.html#13-el-nacimiento-de-los-computadores-comerciales","text":"UNIVAC El UNIVAC fue el primer computador comercial (1951). Con este computadora aparece por primera vez la figura del programador: manuales, cursos de formaci\u00f3n, ofertas de empleo, etc. UNIVAC Instalaciones comerciales del UNIVAC IBM 704 El IBM 704 fue el otro gran ordenador comercial de la d\u00e9cada de los 50. Tuvo una difusi\u00f3n mucho mayor que el UNIVAC: centros gubernamentales, universidades. Los primeros lenguajes de programaci\u00f3n de alto nivel se desarrollan para este computador. Foto IBM 704","title":"1.3. El nacimiento de los computadores comerciales"},{"location":"teoria/tema01-historia-lenguajes-programacion/tema01-historia-lenguajes-programacion.html#14-los-primeros-lenguajes-de-alto-nivel","text":"Los primeros lenguajes de alto nivel se desarrollaron a finales de la d\u00e9cada de los 50: FORTRAN en 1956 Lisp en 1958 Ambos lenguajes planteaban dos enfoques muy distintos desde el principio: FORTRAN Primer lenguaje comercial, equipo de IBM dirigido por John W. Backus Lenguaje imperativo: estado, estructuras de control, contador de programa, celdas de memoria Lenguaje compilado Lisp Lenguaje dise\u00f1ado en un departamento de investigaci\u00f3n, un equipo del MIT dirigido por John McCarthy Lenguaje funcional: funciones, recursi\u00f3n, listas, s\u00edmbolos Lenguaje interpretado","title":"1.4. Los primeros lenguajes de alto nivel"},{"location":"teoria/tema01-historia-lenguajes-programacion/tema01-historia-lenguajes-programacion.html#15-la-explosion-de-los-lenguajes-de-programacion","text":"Desde 1954 hasta la actualidad se han documentado m\u00e1s de 2.500 (consultar en The Language List ). Entre 1952 y 1972 alrededor de 200 lenguajes. Una decena fueron realmente siginificativos y tuvieron influencia en el desarrollo de lenguajes posteriores.","title":"1.5. La explosi\u00f3n de los lenguajes de programaci\u00f3n"},{"location":"teoria/tema01-historia-lenguajes-programacion/tema01-historia-lenguajes-programacion.html#16-lenguajes-de-programacion-en-la-actualidad","text":"El \u00edndice TIOBE es un indicador de la popularidad de los lenguajes de programaci\u00f3n. El \u00edndice se actualiza una vez al mes. Las puntaciones se basan en estad\u00edsticas no reveladas que incluyen el n\u00famero de ingenieros en todo el mundo, cursos y aplicaciones desarrolladas. Tambi\u00e9n se utilizan resultados obtenidos en los motores de b\u00fasqueda m\u00e1s usados. El \u00edndice TIOBE no trata de medir el n\u00famero de l\u00edneas escritas en los lenguajes de programaci\u00f3n sino su popularidad e importancia en la comunidad. Lista TIOBE Tambi\u00e9n es muy interesante comprobar la evoluci\u00f3n de los 10 lenguajes m\u00e1s populares en los \u00faltimos 10 a\u00f1os. Evoluci\u00f3n TIOBE","title":"1.6. Lenguajes de programaci\u00f3n en la actualidad"},{"location":"teoria/tema01-historia-lenguajes-programacion/tema01-historia-lenguajes-programacion.html#2-elementos-de-los-lenguajes-de-programacion","text":"","title":"2. Elementos de los lenguajes de programaci\u00f3n"},{"location":"teoria/tema01-historia-lenguajes-programacion/tema01-historia-lenguajes-programacion.html#21-definicion-de-la-encyclopedia-of-computer-science","text":"Un lenguaje de programaci\u00f3n es un conjunto de caracteres, reglas para combinarlos y reglas para especificar sus efectos cuando sean ejecutados por un computador, que tienen las siguientes cuatro caracter\u00edsticas: No requiere ning\u00fan conocimiento de c\u00f3digo m\u00e1quina por parte del usuario. Tiene independencia de la m\u00e1quina. Se traduce a lenguaje m\u00e1guina. Utiliza una notaci\u00f3n que es m\u00e1s cercana al problema espec\u00edfico que se est\u00e1 resolviendo que al c\u00f3digo m\u00e1quina.","title":"2.1. Definici\u00f3n de la Encyclopedia of Computer Science"},{"location":"teoria/tema01-historia-lenguajes-programacion/tema01-historia-lenguajes-programacion.html#22-definicion-de-abelson-y-sussman","text":"Vamos a estudiar la idea de un proceso computacional . Los procesos computacionales son seres abstractos que habitan los computadores. Cuando est\u00e1n en marcha, los procesos manipulan otras cosas abstractas denominadas datos . La evoluci\u00f3n de un proceso est\u00e1 dirigida por un patr\u00f3n de reglas denominado un programa. [...] Y otra idea fundamental Un lenguaje de programaci\u00f3n potente es m\u00e1s que s\u00f3lo una forma de pedir a un computador que realice tareas. El lenguaje tambi\u00e9n sirve como un marco dentro del que organizamos nuestras ideas acerca de los procesos. As\u00ed, cuando describimos un lenguaje, deber\u00edamos prestar atenci\u00f3n particular a los medios que proporciona el lenguaje para combinar ideas simples para formar ideas m\u00e1s complejas.","title":"2.2. Definici\u00f3n de Abelson y Sussman"},{"location":"teoria/tema01-historia-lenguajes-programacion/tema01-historia-lenguajes-programacion.html#23-caracteristicas-de-un-lp","text":"Define un proceso que se ejecuta en un computador Es de alto nivel, cercano a los problemas que se quieren resolver (abstracci\u00f3n) Permite construir nuevas abstracciones que se adapten al dominio que se programa","title":"2.3. Caracter\u00edsticas de un LP"},{"location":"teoria/tema01-historia-lenguajes-programacion/tema01-historia-lenguajes-programacion.html#24-elementos-de-un-lp","text":"Para Abelson y Sussman, todos los lenguajes de progamaci\u00f3n permiten combinar ideas simples en ideas m\u00e1s complejas mediante los siguientes tres mecanismos Expresiones primitivas que representan las entidades m\u00e1s simples del lenguaje Mecanismos de combinaci\u00f3n con los que se construyen elementos compuestos a partir de elementos m\u00e1s simples Mecanismos de abstracci\u00f3n con los que dar nombre a los elementos compuestos y manipularlos como unidades","title":"2.4. Elementos de un LP"},{"location":"teoria/tema01-historia-lenguajes-programacion/tema01-historia-lenguajes-programacion.html#25-sintaxis-y-semantica","text":"Sintaxis : conjunto de reglas que definen qu\u00e9 expresiones de texto son correctas. Por ejemplo, en C todas las sentencias deben terminar en ';'. Sem\u00e1ntica : conjunto de reglas que define cu\u00e1l ser\u00e1 el resultado de la ejecuci\u00f3n de un programa en el computador.","title":"2.5. Sintaxis y sem\u00e1ntica"},{"location":"teoria/tema01-historia-lenguajes-programacion/tema01-historia-lenguajes-programacion.html#26-los-lenguajes-son-para-las-personas","text":"Los lenguajes de programaci\u00f3n deben ser precisos, deben poder traducirse sin ambig\u00fcedad en lenguaje m\u00e1quina para que sean ejecutados por computadores. Pero deben ser utilizados (le\u00eddos, comentados, probados, etc.) por personas. La programaci\u00f3n es una actividad colaborativa y debe basarse en la comunicaci\u00f3n.","title":"2.6. Los lenguajes son para las personas"},{"location":"teoria/tema01-historia-lenguajes-programacion/tema01-historia-lenguajes-programacion.html#27-importancia-del-aprendizaje-de-tecnicas-de-lps","text":"Es importante conocer c\u00f3mo funciona \"por dentro\" un lenguaje de programaci\u00f3n y sus caracter\u00edsticas comparadas. Mejora el uso del lenguaje de programaci\u00f3n Incrementa el vocabulario de los elementos de programaci\u00f3n Permite una mejor elecci\u00f3n del lenguaje de programaci\u00f3n Mejora la habilidad para desarrollar programas efectivos y eficientes Facilita el aprendizaje de un nuevo lenguaje de programaci\u00f3n Facilita el dise\u00f1o de nuevos lenguajes de programaci\u00f3n","title":"2.7. Importancia del aprendizaje de t\u00e9cnicas de LPs"},{"location":"teoria/tema01-historia-lenguajes-programacion/tema01-historia-lenguajes-programacion.html#3-abstraccion","text":"Una misi\u00f3n fundamental de los lenguajes de programaci\u00f3n es proporcionar herramientas que sirvan para construir abstracciones. Por ejemplo, estamos construyendo una abstracci\u00f3n cuando damos un nombre a una entidad del lenguaje (una variable, una funci\u00f3n, una clase, etc.). Escoger un buen nombre para los elementos que vamos construyendo en nuestro programas es fundamental para conseguir un c\u00f3digo legible y reutilizable.","title":"3. Abstracci\u00f3n"},{"location":"teoria/tema01-historia-lenguajes-programacion/tema01-historia-lenguajes-programacion.html#31-modelar-como-una-actividad-fundamental","text":"Para escribir un programa que preste unos servicios es fundamental modelar el dominio sobre el que va a trabajar Es necesario definir distintas abstracciones (tanto APIs, como datos) que nos permitan tratar sus elementos y comunicarnos correctamente con los usuarios que van a utilizar el programa. Las abstracciones que vamos construyendo van apoy\u00e1ndose unas en otras y permiten hacer compresible y comunicable un problema complejo Ejemplo: el modelado del funcionamiento de una biblioteca contiene abstracciones como \"libros\", \"pr\u00e9stamo\", \"reserva\", o \"libros disponibles\" que representan conceptos del dominio que deben ser implementados en nuestra soluci\u00f3n Casos de uso biblioteca","title":"3.1. Modelar como una actividad fundamental"},{"location":"teoria/tema01-historia-lenguajes-programacion/tema01-historia-lenguajes-programacion.html#32-abstracciones-computacionales","text":"Existen abstracciones propias de la inform\u00e1tica ( computer science ), que se utilizan en m\u00faltiples dominios. Por ejemplo, abstracciones de datos como: Listas \u00c1rboles Grafos Tablas hash Tambi\u00e9n existen abstracciones que nos permiten tratar con dispositivos y ordenadores externos: Fichero Raster gr\u00e1fico Protocolo TCP/IP","title":"3.2. Abstracciones computacionales"},{"location":"teoria/tema01-historia-lenguajes-programacion/tema01-historia-lenguajes-programacion.html#33-construccion-de-abstracciones","text":"Uno de los trabajos principales de un inform\u00e1tico es la construcci\u00f3n de abstracciones que permitan ahorrar tiempo y esfuerzo a la hora de tratar con la complejidad del mundo real. Cita de Joel Spolsky en su blog Joel on Software TCP es lo que los cient\u00edficos de computaci\u00f3n llaman una abstracci\u00f3n: una simplificaci\u00f3n de algo mucho m\u00e1s complicado que va por debajo de la cubierta. Resulta que una gran parte de la programaci\u00f3n de computadores consiste en construir abstracciones. \u00bfQu\u00e9 es una librer\u00eda de cadenas? Es una forma de hacer creer que los computadores pueden manipular cadenas tan f\u00e1cilmente como manipulan los n\u00fameros. \u00bfQu\u00e9 es un sistema de ficheros? Es una forma de hacer creer que un disco duro no es en realidad un mont\u00f3n de platos magn\u00e9ticos en rotaci\u00f3n que pueden almacenar bits en ciertas posiciones, sino en su lugar, un sistema jer\u00e1rquico de carpetas-dentro-de-carpetas que contiene ficheros individuales.","title":"3.3. Construcci\u00f3n de abstracciones"},{"location":"teoria/tema01-historia-lenguajes-programacion/tema01-historia-lenguajes-programacion.html#34-distintos-aspectos-de-los-lenguajes-de-programacion","text":"La programaci\u00f3n es una disciplina compleja, que tiene que tener en cuenta m\u00faltiples aspectos de los lenguajes de programaci\u00f3n y las API: Programas como procesos runtime que se ejecutan en un computador. Tenemos que entender qu\u00e9 pasa cuando se crea un objeto, cu\u00e1nto tiempo permanece en memoria, cu\u00e1l es el \u00e1mbito de una variable, etc. Herramientas: depuradores, analizadores de rendimiento. Programas como declaraciones est\u00e1ticas. Hay que considerar un programa desde el punto de vista de una declaraci\u00f3n de nuevos tipos, nuevos m\u00e9todos, tipos gen\u00e9ricos, herencia entre clases, etc. Herramientas: entornos de programaci\u00f3n con autocompletado de c\u00f3digo, detecci\u00f3n de errores sint\u00e1cticos. Programas como comunicaci\u00f3n y actividad social. Tenemos que tener en cuenta que un programa va a ser usado por otras personas, le\u00eddo, extendido, mantenido, modificado. Los programas siempre se van a modificar. Herramientas: sistemas de control de versiones (Git, Mercurial, Github, Bitbucket), de gesti\u00f3n incidencias (Jira) , tests que evitan errores de regresi\u00f3n, ...","title":"3.4. Distintos aspectos de los lenguajes de programaci\u00f3n"},{"location":"teoria/tema01-historia-lenguajes-programacion/tema01-historia-lenguajes-programacion.html#4-paradigmas-de-programacion","text":"","title":"4. Paradigmas de programaci\u00f3n"},{"location":"teoria/tema01-historia-lenguajes-programacion/tema01-historia-lenguajes-programacion.html#41-que-es-un-paradigma-de-programacion","text":"Un paradigma define un conjunto de caracter\u00edsticas, patrones y estilos de programaci\u00f3n basados en alguna idea fundamental. Por ejemplo el paradigma funcional se basa en la idea que una computaci\u00f3n se puede especificar como un conjunto de funciones que transforman valores de entrada en valores de salida. Es conveniente ver un paradigma como un estilo de programaci\u00f3n que puede usarse en distintos lenguajes de programaci\u00f3n y expresarse con distintas sintaxis. Por ejemplo, se puede escribir c\u00f3digo que use programaci\u00f3n l\u00f3gica en Prolog (ser\u00eda lo m\u00e1s natural), pero tambi\u00e9n en Java, usando alg\u00fan API espec\u00edfica. Normalmente todos los lenguajes tienen caracter\u00edsticas de m\u00e1s de un paradigma. Por motivos pr\u00e1cticos los lenguajes m\u00e1s populares no se limitan de forma estricta o pura a un \u00fanico paradigma de programaci\u00f3n. Por ejemplo, el Prolog es un lenguaje en su mayor parte l\u00f3gico y declarativo, pero tiene operadores imperativos como el corte . A pesar de ello, es normal adscribir un lenguaje al paradigma en el que es m\u00e1s sencillo o natural escribir c\u00f3digo usando sus construcciones. Existen lenguajes que refuerzan y promueven la expresi\u00f3n de c\u00f3digo en m\u00e1s de un paradigma de programaci\u00f3n. Y lo hacen no por necesidad o accidente, sino con el intento expl\u00edcito de fusionar m\u00e1s de un paradigma en una forma \u00fanica de programar. Estos lenguajes se denominan lenguajes multi-paradigma . Por ejemplo, Scala es lenguaje multi-paradigma en el que Martin Odersky, su creador, mezcla caracter\u00edsticas de programaci\u00f3n orientada a objetos con programaci\u00f3n funcional. Prolog o Lisp, aunque tienen caracter\u00edsticas no l\u00f3gicas o no funcionales, no pueden ser considerados multi-paradigma porque no fueron creados con la idea de integrar paradigmas variados en una forma coherente de expresi\u00f3n. Los paradigmas m\u00e1s importantes son: Paradigma funcional Paradigma l\u00f3gico Paradigma imperativo o procedural Paradigma orientado a objetos","title":"4.1. \u00bfQu\u00e9 es un paradigma de programaci\u00f3n?"},{"location":"teoria/tema01-historia-lenguajes-programacion/tema01-historia-lenguajes-programacion.html#42-paradigma-funcional","text":"Resumen de las caracter\u00edsticas principales: La computaci\u00f3n se realiza mediante la evaluaci\u00f3n de expresiones Definici\u00f3n de funciones Funciones como datos primitivos Valores sin efectos laterales, no existen referencias a celdas de memoria en las que se guarda un estado modificable Programaci\u00f3n declarativa (en la programaci\u00f3n funcional pura ) Lenguajes: Lisp, Scheme, Haskell, Scala, Clojure. Ejemplo de c\u00f3digo (Lisp): ( define ( factorial x ) ( if ( = x 0 ) 1 ( * x ( factorial ( - x 1 ))))) > ( factorial 8 ) 40320 > ( factorial 30 ) 265252859812191058636308480000000","title":"4.2. Paradigma funcional"},{"location":"teoria/tema01-historia-lenguajes-programacion/tema01-historia-lenguajes-programacion.html#43-paradigma-logico","text":"Caracter\u00edsticas: Definici\u00f3n de reglas Unificaci\u00f3n como elemento de computaci\u00f3n Programaci\u00f3n declarativa Lenguajes: Prolog, Mercury, Oz. Ejemplo de c\u00f3digo (Prolog): padrede ( 'juan' , 'maria' ). % juan es padre de maria padrede ( 'pablo' , 'juan' ). % pablo es padre de juan padrede ( 'pablo' , 'marcela' ). padrede ( 'carlos' , 'debora' ). hijode ( A , B ) :- padrede ( B , A ). abuelode ( A , B ) :- padrede ( A , C ), padrede ( C , B ). hermanode ( A , B ) :- padrede ( C , A ) , padrede ( C , B ), A \\== B . familiarde ( A , B ) :- padrede ( A , B ). familiarde ( A , B ) :- hijode ( A , B ). familiarde ( A , B ) :- hermanode ( A , B ). ?- hermanode ( 'juan' , 'marcela' ). yes ?- hermanode ( 'carlos' , 'juan' ). no ?- abuelode ( 'pablo' , 'maria' ). yes ?- abuelode ( 'maria' , 'pablo' ). no","title":"4.3. Paradigma l\u00f3gico"},{"location":"teoria/tema01-historia-lenguajes-programacion/tema01-historia-lenguajes-programacion.html#44-paradigma-imperativo","text":"Los lenguajes de programaci\u00f3n que cumplen el paradigma imperativo se caracterizan por tener un estado impl\u00edcito que es modificado mediante instrucciones o comandos del lenguaje. Como resultado, estos lenguajes tienen una noci\u00f3n de secuenciaci\u00f3n de los comandos para permitir un control preciso y determinista del estado. Caracter\u00edsticas: Definici\u00f3n de procedimientos Definici\u00f3n de tipos de datos Chequeo de tipos en tiempo de compilaci\u00f3n Cambio de estado de variables Pasos de ejecuci\u00f3n de un proceso Ejemplo (Pascal): type tDimension = 1 .. 100 ; eMatriz ( f , c : tDimension ) = array [ 1 .. f , 1 .. c ] of real ; tRango = record f , c : tDimension value 1 ; end ; tpMatriz = ^ eMatriz ; procedure EscribirMatriz ( var m : tpMatriz ) ; var filas , col : integer ; begin for filas := 1 to m ^. f do begin for col := 1 to m ^. c do write ( m ^ [ filas , col ] : 7 : 2 ) ; writeln ( resultado ) ; writeln ( resultado ) end ; end ;","title":"4.4. Paradigma imperativo"},{"location":"teoria/tema01-historia-lenguajes-programacion/tema01-historia-lenguajes-programacion.html#45-paradigma-orientado-a-objetos","text":"Caracter\u00edsticas: Definici\u00f3n de clases y herencia Objetos como abstracci\u00f3n de datos y procedimientos Polimorfismo y chequeo de tipos en tiempo de ejecuci\u00f3n Ejemplo (Java): public class Bicicleta { public int marcha ; public int velocidad ; public Bicicleta ( int velocidadInicial , int marchaInicial ) { marcha = marchaInicial ; velocidad = velocidadInicial ; } public void setMarcha ( int nuevoValor ) { marcha = nuevoValor ; } public void frenar ( int decremento ) { velocidad -= decremento ; } public void acelerar ( int incremento ) { velocidad += incremento ; } } public class MountainBike extends Bicicleta { public int alturaSillin ; public MountainBike ( int alturaInicial , int velocidadInicial , int marchaInicial ) { super ( velocidadInicial , marchaInicial ); alturaSillin = alturaInicial ; } public void setAltura ( int nuevoValor ) { alturaSillin = nuevoValor ; } } public class Excursion { public static void main ( String [] args ) { MountainBike miBicicleta = new MoutainBike ( 10 , 10 , 3 ); miBicicleta . acelerar ( 10 ); miBicicleta . setMarcha ( 4 ); miBicicleta . frenar ( 10 ); } }","title":"4.5. Paradigma orientado a objetos"},{"location":"teoria/tema01-historia-lenguajes-programacion/tema01-historia-lenguajes-programacion.html#5-compiladores-e-interpretes","text":"En el nivel de abstracci\u00f3n m\u00e1s bajo, la ejecuci\u00f3n de un programa en un computador consiste en la ejecuci\u00f3n de un conjunto de instrucciones del c\u00f3digo m\u00e1quina del procesador. Por ejemplo, la siguiente figura muestra un ejemplo de un programa en ensamblador para un antiguo procesador (el Z80, procesador de 8 bits del m\u00edtico ZX Spectrum , uno de los primeros ordenadores personales en Europa): Ensamblador Z80 Dependiendo del tipo de lenguaje de programaci\u00f3n en el que est\u00e9 escrito este programa, el c\u00f3digo m\u00e1quina que se estar\u00e1 ejecutando ser\u00e1: el resultado de la compilaci\u00f3n del programa original (en el caso de un lenguaje compilado) el c\u00f3digo de un programa (int\u00e9rprete) que realiza la interpretaci\u00f3n del programa original (en el caso de un lenguaje interpretado)","title":"5. Compiladores e int\u00e9rpretes"},{"location":"teoria/tema01-historia-lenguajes-programacion/tema01-historia-lenguajes-programacion.html#51-compilacion","text":"La siguiente figura (tomada, como las dem\u00e1s de este apartado del Programming Language Pragmatics ) muestra el proceso de generaci\u00f3n y ejecuci\u00f3n de un programa compilado. Compilaci\u00f3n El proceso de compilaci\u00f3n de un programa consiste en la traducci\u00f3n del c\u00f3digo fuente original en el lenguaje de alto nivel al c\u00f3digo m\u00e1quina espec\u00edfico del procesador en el que va a ejecutarse el programa. El c\u00f3digo m\u00e1quina resultante s\u00f3lo corre en el procesador para el que se ha generado. Por ejemplo, un programa C compilado para un procesador Intel no puede ejecutarse en un procesador ARM, como los Ax de Apple . Ejemplos: C, C++ Diferentes momentos en la vida de un programa: tiempo de compilaci\u00f3n y tiempo de ejecuci\u00f3n Mayor eficiencia","title":"5.1. Compilaci\u00f3n"},{"location":"teoria/tema01-historia-lenguajes-programacion/tema01-historia-lenguajes-programacion.html#52-interpretacion","text":"Interpretaci\u00f3n Ejemplos: BASIC, Lisp, Scheme, Python, Ruby No hay diferencia entre el tiempo de compilaci\u00f3n y el tiempo de ejecuci\u00f3n Mayor flexibilidad: el c\u00f3digo se puede construir y ejecutar \"on the fly\" (funciones lambda o clousures) Los lenguajes interpretados suelen proporcionar un shell o int\u00e9rprete. Se trata de un entorno interactivo en el que podemos definir y evaluar expresiones. Este entorno se denomina en los c\u00edrculos de programaci\u00f3n funcional un REPL ( Read , Eval , Print , Loop ) y ya se utiliz\u00f3 en los primeros a\u00f1os de implementaci\u00f3n del Lisp. El uso del REPL promueve una programaci\u00f3n interactiva en la que continuamente evaluamos y comprobamos el c\u00f3digo que desarrollamos.","title":"5.2. Interpretaci\u00f3n"},{"location":"teoria/tema01-historia-lenguajes-programacion/tema01-historia-lenguajes-programacion.html#53-enfoques-mixtos","text":"Existen tambi\u00e9n enfoques mixtos, como el usado por el lenguaje de programaci\u00f3n Java, en el que se realizan ambos procesos. En una primera fase el compilador de Java ( javac ) realiza una traducci\u00f3n del c\u00f3digo fuente original a un c\u00f3digo intermedio binario independiente del procesado, denominado bytecode . Este c\u00f3digo binario es multiplataforma. El c\u00f3digo intermedio es interpretado despu\u00e9s por un el int\u00e9rprete ( java ) que ya s\u00ed que es dependiente de la plataforma. En la figura el int\u00e9rprete se denomina Virtual machine (no confundir con el concepto de m\u00e1quina virtual que permite emular un sistema operativo, por ejemplo VirtualBox). Enfoque mixto (Java) Ejemplos: Java, Scala","title":"5.3. Enfoques mixtos"},{"location":"teoria/tema01-historia-lenguajes-programacion/tema01-historia-lenguajes-programacion.html#6-bibliografia","text":"Introducci\u00f3n y cap\u00edtulo 1 del Structure and Interpretation of Computer Programs: Building Abstractions with Procedures Cap\u00edtulo 1.2 Programming Language Pragmatics: The Programming Language Spectrum Cap\u00edtulo 1.3 Programming Language Pragmatics, Why Study Programming Languages Cap\u00edtulo 1.4 Programming Language Pragmatics, Compilation and Interpretation Raul Rojas, \"Konrad Zuse's legacy the architecture of the Z1 and Z3\", IEEE Annals of the History of Computing, Vol. 19, No. 2, 1997 Charles Petzold, \"Code\", Microsoft Press, 2000 (Cap\u00edtulo 18: \"From Abaci to Chips\") Jack Copeland, \"The Modern History of Computing\", The Stanford Encyclopedia of Philosophy (Fall 2008 Edition), URL = http://plato.stanford.edu/archives/fall2008/entries/computing-history/ Georgi Dalakov, \"History of Computers\", URL = http://history-computer.com Lenguajes y Paradigmas de Programaci\u00f3n, curso 2021-22 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Domingo Gallardo, Cristina Pomares, Antonio Bot\u00eda, Francisco Mart\u00ednez","title":"6. Bibliograf\u00eda"},{"location":"teoria/tema02-programacion-funcional/tema02-programacion-funcional.html","text":"Tema 2: Programaci\u00f3n funcional \u00b6 1. El paradigma de Programaci\u00f3n Funcional \u00b6 1.1. Pasado y presente del paradigma funcional \u00b6 1.1.1. Definici\u00f3n y caracter\u00edsticas \u00b6 En una definici\u00f3n muy breve y concisa la programaci\u00f3n funcional define un programa de la siguiente forma: Definici\u00f3n de programa funcional En programaci\u00f3n funcional un programa es un conjunto de funciones matem\u00e1ticas que convierten unas entradas en unas salidas, sin ning\u00fan estado interno y ning\u00fan efecto lateral. Hablaremos m\u00e1s adelante de la no existencia de estado interno (variables en las que se guardan y se modifican valores) y de la ausencia de efectos laterales. Avancemos que estas son tambi\u00e9n caracter\u00edsticas de la programaci\u00f3n declarativa (frente a la programaci\u00f3n tradicional imperativa que es la que se utiliza en lenguajes como C o Java). En este sentido, la programaci\u00f3n funcional es un tipo concreto de programaci\u00f3n declarativa. Las caracter\u00edsticas principales del paradigma funcional son: Definiciones de funciones matem\u00e1ticas puras, sin estado interno ni efectos laterales Valores inmutables Uso profuso de la recursi\u00f3n en la definici\u00f3n de las funciones Uso de listas como estructuras de datos fundamentales Funciones como tipos de datos primitivos: expresiones lambda y funciones de orden superior Explicaremos estas propiedades a continuaci\u00f3n. 1.1.2. Or\u00edgenes hist\u00f3ricos \u00b6 En los a\u00f1os 30, junto con la m\u00e1quina de Turing, se propusieron distintos modelos computacionales equivalentes que formalizaban el concepto de algoritmo . Uno de estos modelos fue el denominado C\u00e1lculo lambda propuesto por Alonzo Church en los a\u00f1os 30 y basado en la evaluaci\u00f3n de expresiones matem\u00e1ticas. En este formalismo los algoritmos se expresan mediante funciones matem\u00e1ticas en las que puede ser usada la recursi\u00f3n. Una funci\u00f3n matem\u00e1tica recibe par\u00e1metros de entrada y devuelve un valor. La evaluaci\u00f3n de la funci\u00f3n se realiza evaluando sus expresiones matem\u00e1ticas mediante la sustituci\u00f3n de los par\u00e1metros formales por los valores reales que se utilizan en la invocaci\u00f3n (el denominado modelo de sustituci\u00f3n que veremos m\u00e1s adelante). El c\u00e1lculo lambda es un formalismo matem\u00e1tico, basado en operaciones abstractas. Dos d\u00e9cadas despu\u00e9s, cuando los primeros computadores electr\u00f3nicos estaban empezando a utilizarse en grandes empresas y en universidades, este formalismo dio origen a algo mucho m\u00e1s tangible y pr\u00e1ctico: un lenguaje de alto nivel, mucho m\u00e1s expresivo que el ensamblador, con el que expresar operaciones y funciones que pueden ser definidas y evaluadas en el computador , el lenguaje de programaci\u00f3n Lisp. 1.1.3. Historia y caracter\u00edsticas del Lisp \u00b6 Lisp es el primer lenguaje de programaci\u00f3n de alto nivel basado en el paradigma funcional. Creado en 1958 por John McCarthy. Lisp fue en su \u00e9poca un lenguaje revolucionario que introdujo nuevos conceptos de programaci\u00f3n no existentes entonces: funciones como objetos primitivos, funciones de orden superior, polimorfismo, listas, recursi\u00f3n, s\u00edmbolos, homogeneidad de datos y programas, bucle REPL ( Read-Eval-Print Loop ) La herencia del Lisp llega a lenguajes derivados de \u00e9l (Scheme, Golden Common Lisp) y a nuevos lenguajes de paradigmas no estrictamente funcionales, como C#, Python, Ruby, Objective-C o Scala. Lisp fue el primer lenguaje de programaci\u00f3n interpretado, con muchas caracter\u00edsticas din\u00e1micas que se ejecutan en tiempo de ejecuci\u00f3n ( run-time ). Entre estas caracter\u00edsticas podemos destacar la gesti\u00f3n de la memoria (creaci\u00f3n y destrucci\u00f3n autom\u00e1tica de memoria reservada para datos), la detecci\u00f3n de excepciones y errores en tiempo de ejecuci\u00f3n o la creaci\u00f3n en tiempo de ejecuci\u00f3n de funciones an\u00f3nimas (expresiones lambda ). Todas estas caracter\u00edsticas se ejecutan mediante un sistema de tiempo de ejecuci\u00f3n ( runtime system ) presente en la ejecuci\u00f3n de los programas. A partir del Lisp muchos otros lenguajes han usado estas caracter\u00edsticas de interpretaci\u00f3n o de sistemas de tiempo de ejecuci\u00f3n. Por ejemplo, lenguajes como BASIC, Python, Ruby o JavaScript son lenguajes interpretados. Y lenguajes como Java o C# tienen una avanzada plataforma de tiempo de ejecuci\u00f3n con soporte para la gesti\u00f3n de la memoria din\u00e1mica ( recolecci\u00f3n de basura , garbage collection ) o la compilaci\u00f3n just in time . Lisp no es un lenguaje exclusivamente funcional. Lisp se dise\u00f1\u00f3 con el objetivo de ser un lenguaje de alto nivel capaz de resolver problemas pr\u00e1cticos de Inteligencia Artificial, no con la idea de ser un lenguaje formal basado un \u00fanico modelo de computaci\u00f3n. Por ello en Lisp (y en Scheme) existen primitivas que se salen del paradigma funcional puro y permiten programar de formar imperativa (no declarativa), usando mutaci\u00f3n de estado y pasos de ejecuci\u00f3n. Sin embargo, durante la primera parte de la asignatura en la que estudiaremos la programaci\u00f3n funcional, no utilizaremos las instrucciones imperativas de Scheme sino que escribiremos c\u00f3digo exclusivamente funcional. 1.1.4. Lenguajes de programaci\u00f3n funcional \u00b6 En los a\u00f1os 60 la programaci\u00f3n funcional definida por el Lisp fue dominante en departamentos de investigaci\u00f3n en Inteligencia Artificial (MIT por ejemplo). En los a\u00f1os 70, 80 y 90 se fue relegando cada vez m\u00e1s a los nichos acad\u00e9micos y de investigaci\u00f3n; en la empresa se impusieron los lenguajes imperativos y orientados a objetos. En la primera d\u00e9cada del 2000 han aparecido lenguajes que evolucionan de Lisp y que resaltan sus aspectos funcionales, aunque actualizando su sintaxis. Destacamos entre ellos: Clojure Erlang Tambi\u00e9n hay una tendencia desde mediados de la d\u00e9cada de 2000 de incluir aspectos funcionales como las expresiones lambda o las funciones de orden superior en lenguajes imperativos orientados a objetos, dando lugar a lenguajes multi-paradigma : Ruby Python Groovy Scala Swift Por \u00faltimo, en la d\u00e9cada del 2010 tambi\u00e9n se ha hecho popular un lenguaje exclusivamente funcional como Haskell . Este lenguaje, a diferencia de Scheme y de otros lenguajes multi-paradigma, no tienen ning\u00fan elemento imperativo y consigue que todas sus expresiones sean puramente funcionales. 1.1.5. Aplicaciones pr\u00e1cticas de la programaci\u00f3n funcional \u00b6 En la actualidad el paradigma funcional es un paradigma de moda , como se puede comprobar observando la cantidad de art\u00edculos, charlas y blogs en los que se habla de \u00e9l, as\u00ed como la cantidad de lenguajes que est\u00e1n aplicando sus conceptos. Por ejemplo, solo como muestra, a continuaci\u00f3n puedes encontrar algunos enlaces a charlas y art\u00edculos interesantes publicados recientemente sobre programaci\u00f3n funcional: Lupo Montero - Introducci\u00f3n a la programaci\u00f3n funcional en JavaScript (Blog) Andr\u00e9s Marzal - Por qu\u00e9 deber\u00edas aprender programaci\u00f3n funcional ya mismo (Charla en YouTube) Mary Rose Cook - A practical introduction to functional programming (Blog) Ben Christensen - Functional Reactive Programming in the Netflix API (Charla en InfoQ) El auge reciente de estos lenguajes y del paradigma funcional se debe a varios factores, entre ellos que es un paradigma que facilita: la programaci\u00f3n de sistemas concurrentes, con m\u00faltiples hilos de ejecuci\u00f3n o con m\u00faltiples computadores ejecutando procesos conectados concurrentes. la definici\u00f3n y composici\u00f3n de m\u00faltiples operaciones sobre streams de forma muy concisa y compacta, aplicable a la programaci\u00f3n de sistemas distribuidos en Internet. la programaci\u00f3n interactiva y evolutiva. 1.1.5.1. Programaci\u00f3n de sistemas concurrentes \u00b6 Veremos m\u00e1s adelante que una de las caracter\u00edsticas principales de la programaci\u00f3n funcional es que no se usa la mutaci\u00f3n (no se modifican los valores asignados a variables ni par\u00e1metros). Esta propiedad lo hace un paradigma excelente para implementar programas concurrentes, en los que existen m\u00faltiples hilos de ejecuci\u00f3n. La programaci\u00f3n de sistemas concurrentes es muy complicada con el paradigma imperativo tradicional, en el que la modificaci\u00f3n del estado de una variable compartida por m\u00e1s de un hilo puede provocar condiciones de carrera y errores dif\u00edcilmente localizables y reproducibles. Como dice Bartosz Milewski , investigador y te\u00f3rico de ciencia de computaci\u00f3n, en su respuesta en Quora a la pregunta \u00bfpor qu\u00e9 a los ingenieros de software les gusta la programaci\u00f3n funcional? : Bartosz Milewski: \u00bfPor qu\u00e9 es popular la programaci\u00f3n funcional? Porque es la \u00fanica forma pr\u00e1ctica de escribir programas concurrentes. Intentar escribir programas concurrentes en lenguajes imperativos, no s\u00f3lo es dif\u00edcil, sino que lleva a bugs que son muy dif\u00edciles de descubrir, reproducir y arreglar. En los lenguajes imperativos y, en particular, en los lenguajes orientados a objetos se ocultan las mutaciones y se comparten datos sin darse cuenta, por lo que son extremadamente propensos a los errores de concurrencia producidos por las condiciones de carrera. 1.1.5.2. Definici\u00f3n y composici\u00f3n de operaciones sobre streams \u00b6 El paradigma funcional ha originado un estilo de programaci\u00f3n sobre streams de datos, en el que se concatenan operaciones como filter o map para definir de forma sencilla procesos y transformaciones as\u00edncronas aplicables a los elementos del stream . Este estilo de programaci\u00f3n ha hecho posible nuevas ideas de programaci\u00f3n, como la programaci\u00f3n reactiva , basada en eventos, o los futuros o promesas muy utilizados en lenguajes muy populares como JavaScript para realizar peticiones as\u00edncronas a servicios web. Por ejemplo, en el art\u00edculo Exploring the virtues of microservices with Play and Akka se explica con detalle las ventajas del uso de lenguajes y primitivas para trabajar con sistemas as\u00edncronos basados en eventos en servicios como Tumblr o Netflix. Otro ejemplo es el uso de Scala en Tumblr con el que se consigue crear c\u00f3digo que no tiene estado compartido y que es f\u00e1cilmente paralelizable entre los m\u00e1s de 800 servidores necesarios para atender picos de m\u00e1s de 40.000 peticiones por segundo: Uso de Scala en Tumblr Scala promueve que no haya estado compartido. El estado mutable se evita usando sentencias en Scala. No se usan m\u00e1quinas de estado de larga duraci\u00f3n. El estado se saca de la base de datos, se usa, y se escribe de nuevo en la base de datos. La ventaja principal es que los desarrolladores no tienen que preocuparse sobre hilos o bloqueos. 1.1.5.3. Programaci\u00f3n evolutiva \u00b6 En la metodolog\u00eda de programaci\u00f3n denominada programaci\u00f3n evolutiva o iterativa los programas complejos se construyen a base de ir definiendo y probando elementos computacionales cada vez m\u00e1s complicados. Los lenguajes de programaci\u00f3n funcional encajan perfectamente en esta forma de construir programas. Como Abelson y Sussman comentan en el libro Structure and Implementation of Computer Programs (SICP): Abelson y Sussman sobre la programaci\u00f3n incremental En general, los objetos computacionales pueden tener estructuras muy complejas, y ser\u00eda extremadamente inconveniente tener que recordar y repetir sus detalles cada vez que queremos usarlas. En lugar de ello, se construyen programas complejos componiendo, paso a paso, objetos computacionales de creciente complejidad. El int\u00e9rprete hace esta construcci\u00f3n paso-a-paso de los programas particularmente conveniente porque las asociaciones nombre-objeto se pueden crear de forma incremental en interacciones sucesivas. Esta caracter\u00edstica favorece el desarrollo y prueba incremental de programas, y es en gran medida responsable del hecho de que un programa Lisp consiste normalmente de un gran n\u00famero de procedimientos relativamente simples. No hay que confundir una metodolog\u00eda de programaci\u00f3n con un paradigma de programaci\u00f3n. Una metodolog\u00eda de programaci\u00f3n proporciona sugerencias sobre c\u00f3mo debemos dise\u00f1ar, desarrollar y mantener una aplicaci\u00f3n que va a ser usada por usuarios finales. La programaci\u00f3n funcional se puede usar con m\u00faltiples metodolog\u00edas de programaci\u00f3n, debido a que los programas resultantes son muy claros, expresivos y f\u00e1ciles de probar. 1.2. Evaluaci\u00f3n de expresiones y definici\u00f3n de funciones \u00b6 En la asignatura usaremos Scheme como primer lenguaje en el que exploraremos la programaci\u00f3n funcional. En el seminario de Scheme que se imparte en pr\u00e1cticas se estudiar\u00e1 en m\u00e1s profundidad los conceptos m\u00e1s importantes del lenguaje: tipos de datos, operadores, estructuras de control, int\u00e9rprete, etc. 1.2.1 Evaluaci\u00f3n de expresiones \u00b6 Empezamos este apartado viendo c\u00f3mo se definen y eval\u00faan expresiones Scheme. Y despu\u00e9s veremos c\u00f3mo construir nuevas funciones. Scheme es un lenguaje que viene del Lisp. Una de sus caracter\u00edsticas principales es que las expresiones se construyen utilizando par\u00e9ntesis. Ejemplos de expresiones en Scheme, junto con el resultado de su ejecuci\u00f3n: 2 ; \u21d2 2 ( + 2 3 ) ; \u21d2 5 ( + ) ; \u21d2 0 ( + 2 4 5 6 ) ; \u21d2 17 ( + ( * 2 3 ) ( - 3 1 )) ; \u21d2 8 En programaci\u00f3n funcional en lugar de decir \"ejecutar una expresi\u00f3n\" se dice \" evaluar una expresi\u00f3n \", para reforzar la idea de que se tratan de expresiones matem\u00e1ticas que siempre devuelven uno y s\u00f3lo un resultado . Las expresiones se definen con una notaci\u00f3n prefija: el primer elemento despu\u00e9s del par\u00e9ntesis de apertura es el operador de la expresi\u00f3n y el resto de elementos (hasta el par\u00e9ntesis de cierre) son sus operandos. Por ejemplo, en la expresi\u00f3n (+ 2 4 5 6) el operador es el s\u00edmbolo + que representa funci\u00f3n suma y los operandos son los n\u00fameros 2, 4, 5 y 6. Puede haber expresiones que no tengan operandos, como el ejemplo (+) , cuya evaluaci\u00f3n devuelve 0. Una idea fundamental de Lisp y Scheme es que los par\u00e9ntesis se eval\u00faan de dentro a fuera. Por ejemplo, la expresi\u00f3n ( + ( * 2 3 ) ( - 3 ( / 12 3 ))) que devuelve 5, se eval\u00faa as\u00ed: ( + ( * 2 3 ) ( - 3 ( / 12 3 ))) \u21d2 ( + 6 ( - 3 ( / 12 3 ))) \u21d2 ( + 6 ( - 3 4 )) \u21d2 ( + 6 -1 ) \u21d2 5 La evaluaci\u00f3n de cada expresi\u00f3n devuelve un valor que se utiliza para continuar calculando la expresi\u00f3n exterior. En el caso anterior primero se eval\u00faa la expresi\u00f3n (* 2 3) que devuelve 6, despu\u00e9s se eval\u00faa (/ 12 3) que devuelve 4, despu\u00e9s se eval\u00faa (- 3 4) que devuelve -1 y por \u00faltimo se eval\u00faa (+ 6 -1) que devuelve 5 Cuando se eval\u00faa una expresi\u00f3n en el int\u00e9rprete de Scheme el resultado aparece en la siguiente l\u00ednea. 1.2.2. Definici\u00f3n de funciones \u00b6 En programaci\u00f3n funcional las funciones son similares a las funciones matem\u00e1ticas: reciben par\u00e1metros y devuelven siempre un \u00fanico resultado de operar con esos par\u00e1metros. Por ejemplo, podemos definir la funci\u00f3n (cuadrado x) que devuelve el cuadrado de un n\u00famero que pasamos como par\u00e1metro: ( define ( cuadrado x ) ( * x x )) Despu\u00e9s del nombre de la funci\u00f3n se declaran sus argumentos. El n\u00famero de argumentos de una funci\u00f3n se denomina aridad de la funci\u00f3n . Por ejemplo, la funci\u00f3n cuadrado es una funci\u00f3n de aridad 1, o unaria . Despu\u00e9s de declarar los par\u00e1metros, se define el cuerpo de la funci\u00f3n. Es una expresi\u00f3n que se evaluar\u00e1 con el valor que se pase como par\u00e1metro. En el caso anterior la expresi\u00f3n es (* x x) y multiplicar\u00e1 el par\u00e1metro por si mismo. Hay que hacer notar que en Scheme no existe la palabra clave return , sino que las funciones siempre se definen con una \u00fanica expresi\u00f3n cuya evaluaci\u00f3n es el resultado que se devuelve. Una vez definida la funci\u00f3n cuadrado podemos usarla de la misma forma que las funciones primitivas de Scheme: ( cuadrado 10 ) ; \u21d2 100 ( cuadrado ( + 10 ( cuadrado ( + 2 4 )))) ; \u21d2 2116 La evaluaci\u00f3n de la \u00faltima expresi\u00f3n se hace de la siguiente forma: ( cuadrado ( + 10 ( cuadrado ( + 2 4 )))) \u21d2 ( cuadrado ( + 10 ( cuadrado 6 ))) \u21d2 ( cuadrado ( + 10 36 )) \u21d2 ( cuadrado 46 ) \u21d2 2116 1.2.3. Definici\u00f3n de funciones auxiliares \u00b6 Las funciones definidas se pueden utilizar a su vez para construir otras funciones. Lo habitual en programaci\u00f3n funcional es definir funciones muy peque\u00f1as e ir construyendo funciones cada vez de mayor nivel usando las anteriores. 1.2.3.1. Ejemplo: suma de cuadrados \u00b6 Por ejemplo, supongamos que tenemos que definir una funci\u00f3n que devuelva la suma del cuadrado de dos n\u00fameros. Podr\u00edamos definirla escribiendo la expresi\u00f3n completa, pero queda una definici\u00f3n poco legible. ; Definici\u00f3n poco legible de la suma de cuadrados ( define ( suma-cuadrados x y ) ( + ( * x x ) ( * y y ))) Podemos hacer una definici\u00f3n mucho m\u00e1s legible si usamos la funci\u00f3n cuadrado definida anteriormente: ; Definici\u00f3n de suma de cuadrados m\u00e1s legible. ; Usamos la funci\u00f3n auxiliar 'cuadrado' ( define ( cuadrado x ) ( * x x )) ( define ( suma-cuadrados x y ) ( + ( cuadrado x ) ( cuadrado y ))) Esta segunda definici\u00f3n es mucho m\u00e1s expresiva. Leyendo el c\u00f3digo queda muy claro qu\u00e9 es lo que queremos hacer. 1.2.3.2. Ejemplo: tiempo de impacto \u00b6 Veamos otro ejemplo de uso de funciones auxiliares. Supongamos que estamos programando un juego de guerra de barcos y submarinos, en el que utilizamos las coordenadas del plano para situar todos los elementos de nuestra flota. Supongamos que necesitamos calcular el tiempo que tarda un torpedo en llegar desde una posici\u00f3n (x1, y1) a otra (x2, y2) . Suponemos que la velocidad del torpedo es otro par\u00e1metro v . \u00bfC\u00f3mo calcular\u00edamos este tiempo de impacto? La forma menos correcta de hacerlo es definir todo el c\u00e1lculo en una \u00fanica expresi\u00f3n. Como en programaci\u00f3n funcional las funciones deben definirse con una \u00fanica expresi\u00f3n debemos realizar todo el c\u00e1lculo en forma de expresiones anidadas, unas dentro de otras. Esto construye una funci\u00f3n que calcula bien el resultado. El problema que tiene es que es muy dif\u00edcil de leer y entender para un compa\u00f1ero (o para nosotros mismos, cuando pasen unos meses): ; ; Definici\u00f3n incorrecta: muy poco legible ; ; La funci\u00f3n tiempo-impacto devuelve el tiempo que tarda ; en llegar un torpedo a la velocidad v desde la posici\u00f3n ; (x1, y1) a la posici\u00f3n (x2, y2) ; ( define ( tiempo-impacto x1 y1 x2 y2 v ) ( / ( sqrt ( + ( * ( - x2 x1 ) ( - x2 x1 )) ( * ( - y2 y1 ) ( - y2 y1 )))) v )) La funci\u00f3n anterior hace bien el c\u00e1lculo pero es muy complicada de modificar y de entender. La forma m\u00e1s correcta de definir la funci\u00f3n ser\u00eda usando varias funciones auxiliares. F\u00edjate que es muy importante tambi\u00e9n poner los nombres correctos a cada funci\u00f3n, para entender qu\u00e9 hace. Scheme es un lenguaje d\u00e9bilmente tipado y no tenemos la ayuda de los tipos que nos dan m\u00e1s contexto de qu\u00e9 es cada par\u00e1metro y qu\u00e9 devuelve la funci\u00f3n. ; Definici\u00f3n correcta, modular y legible de la funci\u00f3n tiempo-impacto ; ; La funci\u00f3n 'cuadrado' devuelve el cuadrado de un n\u00famero ; ( define ( cuadrado x ) ( * x x )) ; ; La funci\u00f3n 'distancia' devuelve la distancia entre dos ; coordenadas (x1, y1) y (x2, y2) ; ( define ( distancia x1 y1 x2 y2 ) ( sqrt ( + ( cuadrado ( - x2 x1 )) ( cuadrado ( - y2 y1 ))))) ; ; La funci\u00f3n 'tiempo' devuelve el tiempo que ; tarda en recorrer un m\u00f3vil una distancia d a un velocidad v ; ( define ( tiempo distancia velocidad ) ( / distancia velocidad )) ; ; La funci\u00f3n 'tiempo-impacto' devuelve el tiempo que tarda ; en llegar un torpedo a la velocidad v desde la posici\u00f3n ; (x1, y1) a la posici\u00f3n (x2, y2) ; ( define ( tiempo-impacto x1 y1 x2 y2 velocidad ) ( tiempo ( distancia x1 y1 x2 y2 ) velocidad )) En esta segunda versi\u00f3n definimos m\u00e1s funciones, pero cada una es mucho m\u00e1s legible. Adem\u00e1s las funciones como cuadrado , distancia o tiempo las vamos a poder reutilizar para otros c\u00e1lculos. 1.2.4. Funciones puras \u00b6 A diferencia de lo que hemos visto en programaci\u00f3n imperativa, en programaci\u00f3n funcional no es posible definir funciones con estado local. Las funciones que se definen son funciones matem\u00e1ticas puras, que cumplen las siguientes condiciones: No modifican los par\u00e1metros que se les pasa Devuelven un \u00fanico resultado No tienen estado local ni el resultado depende de un estado exterior mutable Esta \u00faltima propiedad es muy importante y quiere decir que la funci\u00f3n siempre devuelve el mismo valor cuando se le pasan los mismos par\u00e1metros. Las funciones puras son muy f\u00e1ciles de entender porque no es necesario tener en cuenta ning\u00fan contexto a la hora de describir su funcionamiento. El valor devuelto \u00fanicamente depende de los par\u00e1metros de entrada. Por ejemplo, funciones matem\u00e1ticas como suma, resta, cuadrado, sin, cos, etc. cumplen esta propiedad. 1.2.5. Composici\u00f3n de funciones \u00b6 Una idea fundamental de la programaci\u00f3n funcional es la composici\u00f3n de funciones que transforman unos datos de entrada en otros de salida. Es una idea muy actual, porque es la forma en la que est\u00e1n planteados muchos algoritmos de procesamiento de datos en inteligencia artificial. Por ejemplo, podemos representar de la siguiente forma el algoritmo que maneja un veh\u00edculo aut\u00f3nomo: Las cajas representa funciones que transforman los datos de entrada (im\u00e1genes tomadas por las c\u00e1maras del veh\u00edculo) en los datos de salida (acciones a realizar sobre la direcci\u00f3n y el motor del veh\u00edculo). Las funciones intermedias representan transformaciones que se realizan sobre los datos de entrada y obtienen los datos de salida. En un lenguaje de programaci\u00f3n funcional como Scheme el diagrama anterior se escribir\u00eda con el siguiente c\u00f3digo: ( define ( conduce-vehiculo imagenes ) ( obten-acciones ( reconoce ( filtra ( obten-caracteristicas imagenes ))))) Veremos m\u00e1s adelante que las expresiones en Scheme se eval\u00faan de dentro a fuera y que tienen notaci\u00f3n prefija. El resultado de cada funci\u00f3n constituye la entrada de la siguiente. En el caso de la funci\u00f3n conduce-vehiculo primero se obtienen las caracter\u00edsticas de las im\u00e1genes, despu\u00e9s se filtran, despu\u00e9s se reconoce la escena y, por \u00faltimo, se obtienen las acciones para conducir el veh\u00edculo. 1.3. Programaci\u00f3n declarativa vs. imperativa \u00b6 Hemos dicho que la programaci\u00f3n funcional es un estilo de programaci\u00f3n declarativa, frente a la programaci\u00f3n tradicional de los lenguajes denominados imperativos. Vamos a explicar esto un poco m\u00e1s. 1.3.1. Programaci\u00f3n declarativa \u00b6 Empecemos con lo que conocemos todos: un programa imperativo . Se trata de un conjunto de instrucciones que se ejecutan una tras otra (pasos de ejecuci\u00f3n) de forma secuencial. En la ejecuci\u00f3n de estas instrucciones se van cambiando los valores de las variables y, dependiendo de estos valores, se modifica el flujo de control de la ejecuci\u00f3n del programa. Para entender el funcionamiento de un programa imperativo debemos imaginar toda la evoluci\u00f3n del programa, los pasos que se ejecutan y cu\u00e1l es el flujo de control en funci\u00f3n de los cambios de los valores en las variables. En la programaci\u00f3n declarativa , sin embargo, utilizamos un paradigma totalmente distinto. Hablamos de programaci\u00f3n declarativa para referirnos a lenguajes de programaci\u00f3n (o sentencias de c\u00f3digo) en los que se declaran los valores, objetivos o caracter\u00edsticas de los elementos del programa y en cuya ejecuci\u00f3n no existe mutaci\u00f3n (modificaci\u00f3n de valores de variables) ni secuencias de pasos de ejecuci\u00f3n. De esta forma, la ejecuci\u00f3n de un programa declarativo tiene que ver m\u00e1s con alg\u00fan modelo formal o matem\u00e1tico que con un programa tradicional imperativo. Define un conjunto de reglas y definiciones de estilo matem\u00e1tico . La programaci\u00f3n declarativa no es exclusiva de los lenguajes funcionales. Existen muchos lenguajes no funcionales con caracter\u00edsticas declarativas. Por ejemplo Prolog, en el que un programa se define como un conjunto de reglas l\u00f3gicas y su ejecuci\u00f3n realiza una deducci\u00f3n l\u00f3gica matem\u00e1tica que devuelve un resultado. En dicha ejecuci\u00f3n no son relevantes los pasos internos que realiza el sistema sino las relaciones l\u00f3gicas entre los datos y los resultados finales. Un ejemplo claro de programaci\u00f3n declarativa es una hoja de c\u00e1lculo . Las celdas contiene valores o expresiones matem\u00e1ticas que se actualizan autom\u00e1ticamente cuando cambiamos los valores de entrada. La relaci\u00f3n entre valores y resultados es totalmente matem\u00e1tica y para su c\u00e1lculo no tenemos que tener en cuenta pasos de ejecuci\u00f3n. Evidente, por debajo de la hoja de c\u00e1lculo existe un programa que realiza el su c\u00e1lculo de la hoja, pero cuando estamos us\u00e1ndola no nos preocupa esa implementaci\u00f3n. Podemos no preocuparnos de ella y usar \u00fanicamente el modelo matem\u00e1tico definido en la hoja. Otro ejemplo muy actual de programaci\u00f3n declarativa es SwiftUI, el nuevo API creado por Apple para definir las interfaces de usuario de las aplicaciones iOS. En el c\u00f3digo de la imagen vemos una descripci\u00f3n de c\u00f3mo est\u00e1 definida la aplicaci\u00f3n: una lista de lugares ( landmarks ) apilada verticalmente. Para cada lugar se define su imagen, su texto, y una estrella si el lugar es favorito. El c\u00f3digo es declarativo porque no hay pasos de ejecuci\u00f3n para definir la interfaz. No existe un bucle que va a\u00f1adiendo elementos a la interfaz. Vemos una declaraci\u00f3n de c\u00f3mo la interfaz va estar definida. El compilador del lenguaje y el API son los responsables de construir esa declaraci\u00f3n y mostrar la interfaz tal y como nosotros queremos. 1.3.1.1. Declaraci\u00f3n de funciones \u00b6 La programaci\u00f3n funcional utiliza un estilo de programaci\u00f3n declarativo. Declaramos funciones en las que se transforman unos datos de entrada en unos datos de salida. Veremos que esta transformaci\u00f3n se realiza mediante la evaluaci\u00f3n de expresiones, sin definir valores intermedios, ni variables auxiliares, ni pasos de ejecuci\u00f3n. \u00danicamente se van componiendo llamadas a funciones auxiliares que construyen el valor resultante. Tal y como ya hemos visto, el siguiente ejemplo es una declaraci\u00f3n en Scheme de una funci\u00f3n que toma como entrada un n\u00famero y devuelve su cuadrado: ( define ( cuadrado x ) ( * x x )) En el cuerpo de la funci\u00f3n cuadrado vemos que no se utiliza ninguna variable auxiliar, sino que \u00fanicamente se llama a la funci\u00f3n * (multiplicaci\u00f3n) pasando el valor de x . El valor resultante es el que se devuelve. Por ejemplo, si llamamos a la funci\u00f3n pas\u00e1ndole el par\u00e1metro 4 devuelve el resultado de multiplicar 4 por si mismo, 16. ( cuadrado 4 ) ; \u21d2 16 1.3.2. Programaci\u00f3n imperativa \u00b6 Repasemos un algunas caracter\u00edsticas propias de la programaci\u00f3n imperativa que no existen en la programaci\u00f3n funcional . Son caracter\u00edsticas a las que estamos muy habituados porque son propias de los lenguajes m\u00e1s populares y con los que hemos aprendido a programar (C, C++, Java, python, etc.) Pasos de ejecuci\u00f3n Mutaci\u00f3n Efectos laterales Estado local mutable en las funciones Veremos que, aunque parece imposible, es posible programar sin utilizar estas caracter\u00edsticas. Lo demuestran lenguajes de programaci\u00f3n funcional como Haskell, Clojure o el propio Scheme. 1.3.2.1. Pasos de ejecuci\u00f3n \u00b6 Una de las caracter\u00edsticas b\u00e1sicas de la programaci\u00f3n imperativa es la utilizaci\u00f3n de pasos de ejecuci\u00f3n. Por ejemplo, en C podemos realizar los siguientes pasos de ejecuci\u00f3n: int a = cuadrado ( 8 ); int b = doble ( a ); int c = cuadrado ( b ); return c O, por ejemplo, si queremos filtrar y procesar una lista de pedidos en Swift podemos hacerlo en dos sentencias: filtrados = filtra ( pedidos ); procesados = procesa ( filtrados ); return procesados ; Sin embargo, en programaci\u00f3n funcional (por ejemplo, Scheme) no existen pasos de ejecuci\u00f3n separados por sentencias. Como hemos visto antes, la forma t\u00edpica de expresar las instrucciones anteriores es componer todas las operaciones en una \u00fanica instrucci\u00f3n: ( cuadrado ( doble ( cuadrado 8 ))) ; \u21d2 16384 El segundo ejemplo lo podemos componer de la misma forma: ( procesa ( filtra pedidos )) 1.3.2.2. Mutaci\u00f3n \u00b6 En los lenguajes imperativos es com\u00fan modificar el valor de las variables en los pasos de ejecuci\u00f3n: int x = 10 ; int x = x + 1 ; La expresi\u00f3n x = x + 1 es una expresi\u00f3n de asignaci\u00f3n que modifica el valor anterior de una variable por un nuevo valor. El estado de las variables (su valor) cambia con la ejecuci\u00f3n de los pasos del programa. A esta asignaci\u00f3n que modifica un valor ya existente se le denomina asignaci\u00f3n destructiva o mutaci\u00f3n . En programaci\u00f3n imperativa tambi\u00e9n se puede modificar (mutar) el valor de componentes de estructuras de datos, como posiciones de un array, de una lista o de un diccionario. En programaci\u00f3n funcional, por contra, las definiciones son inmutables , y una vez asignado un valor a un identificador no se puede modificar \u00e9ste. En programaci\u00f3n funcional no existe sentencia de asignaci\u00f3n que pueda modificar un valor ya definido. Se entienden las variables como variables matem\u00e1ticas, no como referencias a una posiciones de memoria que puede ser modificada. Por ejemplo, la forma especial define en Scheme crea un nuevo identificador y le da el valor definido de forma permanente. Si escribimos el siguiente c\u00f3digo en un programa en Scheme: #lang racket ( define a 12 ) ( define a 200 ) tendremos el siguiente error: module: identifier already defined in: a Nota En el int\u00e9rprete REPL del DrRacket s\u00ed que podemos definir m\u00e1s de una vez la misma funci\u00f3n o identificador. Se ha dise\u00f1ado as\u00ed para facilitar el uso del int\u00e9rprete para la prueba de expresiones en Scheme. En los lenguajes de programaci\u00f3n imperativos es habitual introducir tambi\u00e9n sentencias declarativas. Por ejemplo, en el siguiente c\u00f3digo Java las l\u00edneas 1 y 3 las podr\u00edamos considerar declarativas y las 2 y 4 imperativas: 1. int x = 1; 2. x = x+1; 3. int y = x+1; 4. y = x; 1.3.2.3. Mutaci\u00f3n y efectos laterales \u00b6 En programaci\u00f3n imperativa es habitual tambi\u00e9n trabajar con referencias y hacer que m\u00e1s de un identificador referencie el mismo valor. Esto produce la posibilidad de que la mutaci\u00f3n del valor a trav\u00e9s de uno de los identificadores produzca un efecto lateral ( side effect en ingl\u00e9s) en el que el valor de un identificador cambia sin ejecutar ninguna expresi\u00f3n en la que se utilice expl\u00edcitamente el propio identificador. Por ejemplo, en la mayor\u00eda de lenguajes orientados a objetos los identificadores guardan referencias a objetos. De forma que si asignamos un objeto a m\u00e1s de un identificador, todos los identificadores est\u00e1n accediendo al mismo objeto. Si mutamos alg\u00fan valor del objeto a trav\u00e9s de un identificador provocamos un efecto lateral en los otros identificadores. Por ejemplo, lo siguiente es un ejemplo de una mutaci\u00f3n en programaci\u00f3n imperativa, en la que se modifican los atributos de un objeto en Java: Point2D p1 = new Point2D ( 3.0 , 2.0 ); // creamos un punto 2D con coordX=3.0 y coordY=2.0 p1 . getCoordX (); // la coord x de p2 es 3.0 p1 . setCoordX ( 10.0 ); p1 . getCoordX (); // la coord x de p1 es 10.0 Si el objeto est\u00e1 asignado a m\u00e1s de una variable tendremos el efecto lateral ( side effect ) en el que el dato guardado en una variable cambia despu\u00e9s de una sentencia en la que no se ha usado esa variable: Point2D p1 = new Point2D ( 3.0 , 2.0 ); // la coord x de p1 es 3.0 p1 . getCoordX (); // la coord x de p1 es 3.0 Point2D p2 = p1 ; p2 . setCoordX ( 10.0 ); p1 . getCoordX (); // la coord x de p1 es 10.0, sin que ninguna sentencia haya modificado directamente p1 El mismo ejemplo anterior, en C: typedef struct { float x ; float y ; } TPunto ; TPunto p1 = { 3.0 , 2.0 }; printf ( \"Coordenada x: %f\" , p1 . x ); // 3.0 TPunto * p2 = & p1 ; p2 -> x = 10.0 ; printf ( \"Coordenada x: %f\" , p1 . x ); // 10.0 Efecto lateral Los efectos laterales son los responsables de muchos bugs y hay que ser muy consciente de su uso. Son especialmente complicados de depurar los bugs debidos a efectos laterales en programas concurrentes con m\u00faltiples hilos de ejecuci\u00f3n, en los que varios hilos pueden acceder a las mismas referencias y provocar condiciones de carrera . Por otro lado, tambi\u00e9n existen situaciones en las que su utilizaci\u00f3n permite ganar mucha eficiencia porque podemos definir estructuras de datos en el que los valores son compartidos por varias referencias y modificando un \u00fanico valor se actualizan de forma instant\u00e1nea esas referencias. En los lenguajes en los que no existe la mutaci\u00f3n no se producen efectos laterales, ya que no es posible modificar el valor de una variable una vez establecido. Los programas que escribamos en estos lenguajes van a estar libres de este tipo de bugs y van a poder ser ejecutado sin problemas en hilos de ejecuci\u00f3n concurrente. Por otro lado, la ausencia de mutaci\u00f3n hace que sean algo m\u00e1s costosas ciertas operaciones, como la construcci\u00f3n de estructuras de datos nuevas a partir de estructuras ya existentes. Veremos, por ejemplo, que la \u00fanica forma de a\u00f1adir un elemento al final de una lista ser\u00e1 construir una lista nueva con todos los elementos de la lista original y el nuevo elemento. Esta operaci\u00f3n tiene un coste lineal con el n\u00famero de elementos de la lista. Sin embargo, en una lista en la que pudi\u00e9ramos utilizar la mutaci\u00f3n podr\u00edamos implementar esta operaci\u00f3n con coste constante. 1.3.2.4. Estado local mutable \u00b6 Otra caracter\u00edstica de la programaci\u00f3n imperativa es lo que se denomina estado local mutable en funciones, procedimientos o m\u00e9todos. Se trata la posibilidad de que una invocaci\u00f3n a un m\u00e9todo o una funci\u00f3n modifique un cierto estado, de forma que la siguiente invocaci\u00f3n devuelva un valor distinto. Es una caracter\u00edstica b\u00e1sica de la programaci\u00f3n orientada a objetos, donde los objetos guardan valores que se modifican con la invocaciones a sus m\u00e9todos. Por ejemplo, en Java, podemos definir un contador que incrementa su valor: public class Contador { int c ; public Contador ( int valorInicial ) { c = valorInicial ; } public int valor () { c ++ ; return c ; } } Cada llamada al m\u00e9todo valor() devolver\u00e1 un valor distinto: Contador cont = new Contador ( 10 ); cont . valor (); // 11 cont . valor (); // 12 cont . valor (); // 13 Tambi\u00e9n se pueden definir funciones con estado local mutable en C: int function contador () { static int c = 0 ; c ++ ; return c ; } Cada llamada a la funci\u00f3n contador() devolver\u00e1 un valor distinto: contador () ;; 1 contador () ;; 2 contador () ;; 3 Por el contrario, los lenguajes funcionales tienen la propiedad de transparencia referencial : es posible sustituir cualquier aparici\u00f3n de una expresi\u00f3n por su resultado sin que cambia el resultado final del programa. Dicho de otra forma, en programaci\u00f3n funcional, una funci\u00f3n siempre devuelve el mismo valor cuando se le llama con los mismos par\u00e1metros . Las funciones no modifican ning\u00fan estado, no acceden a ninguna variable ni objeto global y modifican su valor. 1.3.2.5. Resumen \u00b6 Un resumen de las caracter\u00edsticas fundamentales de la programaci\u00f3n declarativa frente a la programaci\u00f3n imperativa. En los siguientes apartados explicaremos m\u00e1s estas caracter\u00edsticas. Caracter\u00edsticas de la programaci\u00f3n declarativa Variable = nombre dado a un valor (declaraci\u00f3n) En lugar de pasos de ejecuci\u00f3n se utiliza la composici\u00f3n de funciones No existe asignaci\u00f3n ni cambio de estado No existe mutaci\u00f3n, se cumple la transferencia referencial : dentro de un mismo \u00e1mbito todas las ocurrencias de una variable y las llamadas a funciones devuelven el mismo valor Caracter\u00edsticas de la programaci\u00f3n imperativa Variable = nombre de una zona de memoria Asignaci\u00f3n Referencias Pasos de ejecuci\u00f3n 1.4. Modelo de computaci\u00f3n de sustituci\u00f3n \u00b6 Un modelo computacional es un formalismo (conjunto de reglas) que definen el funcionamiento de un programa. En el caso de los lenguajes funcionales basados en la evaluaci\u00f3n de expresiones, el modelo computacional define cu\u00e1l ser\u00e1 el resultado de evaluar una expresi\u00f3n. El modelo de sustituci\u00f3n es un modelo muy sencillo que permite definir la sem\u00e1ntica de la evaluaci\u00f3n de expresiones en lenguajes funcionales como Scheme. Se basa en una versi\u00f3n simplificada de la regla de reducci\u00f3n del c\u00e1lculo lambda. Es un modelo basado en la reescritura de unos t\u00e9rminos por otros. Aunque se trata de un modelo abstracto, ser\u00eda posible escribir un int\u00e9rprete que, bas\u00e1ndose en este modelo, eval\u00fae expresiones funcionales. Supongamos un conjunto de definiciones en Scheme: ( define ( doble x ) ( + x x )) ( define ( cuadrado y ) ( * y y )) ( define ( f z ) ( + ( cuadrado ( doble z )) 1 )) ( define a 2 ) Supongamos que, una vez realizadas esas definiciones, se eval\u00faa la siguiente expresi\u00f3n: ( f ( + a 1 )) \u00bfCu\u00e1l ser\u00e1 su resultado? Si lo hacemos de forma intuitiva podemos pensar que 37 . Si lo comprobamos en el int\u00e9rprete de Scheme veremos que devuelve 37. \u00bfHemos seguido algunas reglas espec\u00edficas? \u00bfQu\u00e9 reglas son las que sigue el int\u00e9rprete? \u00bfPodr\u00edamos implementar nosotros un int\u00e9rprete similar? S\u00ed, usando las reglas del modelo de sustituci\u00f3n. El modelo de sustituci\u00f3n define cuatro reglas sencillas para evaluar una expresi\u00f3n. Llamemos a la expresi\u00f3n e . Las reglas son las siguientes: Si e es un valor primitivo (por ejemplo, un n\u00famero), devolvemos ese mismo valor. Si e es un identificador, devolvemos su valor asociado con un define (se lanzar\u00e1 un error si no existe ese valor). Si e es una expresi\u00f3n del tipo (f arg1 ... argn) , donde f es el nombre de una funci\u00f3n primitiva ( + , - , ...), evaluamos uno a uno los argumentos arg1 ... argn (con estas mismas reglas) y evaluamos la funci\u00f3n primitiva con los resultados. La regla 4 tiene dos variantes, dependiendo del orden de evaluaci\u00f3n que utilizamos. Orden aplicativo Si e es una expresi\u00f3n del tipo (f arg1 ... argn) , donde f es el nombre de una funci\u00f3n definida con un define , tenemos que evaluar primero los argumentos arg1 ... argn y despu\u00e9s sustituir f por su cuerpo , reemplazando cada par\u00e1metro formal de la funci\u00f3n por el correspondiente argumento evaluado . Despu\u00e9s evaluaremos la expresi\u00f3n resultante usando estas mismas reglas. Orden normal Si e es una expresi\u00f3n del tipo (f arg1 ... argn) , donde f es el nombre de una funci\u00f3n definida con un define , tenemos que sustituir f por su cuerpo , reemplazando cada par\u00e1metro formal de la funci\u00f3n por el correspondiente argumento sin evaluar . Despu\u00e9s evaluar la expresi\u00f3n resultante usando estas mismas reglas. En el orden aplicativo se realizan las evaluaciones antes de realizar las sustituciones, lo que define una evaluaci\u00f3n de dentro a fuera de los par\u00e9ntesis. Cuando se llega a una expresi\u00f3n primitiva se eval\u00faa. En el orden normal se realizan todas las sustituciones hasta que se tiene una larga expresi\u00f3n formada por expresiones primitivas; se eval\u00faa entonces. Ambas formas de evaluaci\u00f3n dar\u00e1n el mismo resultado en programaci\u00f3n funcional. Scheme utiliza el orden aplicativo. 1.4.1. Ejemplo 1 \u00b6 Vamos a empezar con un ejemplo sencillo para comprobar c\u00f3mo se eval\u00faa una misma expresi\u00f3n utilizando ambos modelos de sustituci\u00f3n. Supongamos las siguientes definiciones: ( define ( doble x ) ( + x x )) ( define ( cuadrado y ) ( * y y )) ( define a 2 ) Queremos evaluar la siguiente expresi\u00f3n: ( doble ( cuadrado a )) La evaluaci\u00f3n utilizando el modelo de sustituci\u00f3n aplicativo , usando paso a paso las reglas anteriores, es la siguiente (en cada l\u00ednea se indica entre par\u00e9ntesis la regla usada): (doble (cuadrado a)) \u21d2 ; Sustituimos a por su valor (R2) (doble (cuadrado 2)) \u21d2 ; Sustitumos cuadrado por su cuerpo (R4) (doble (* 2 2)) \u21d2 ; Evaluamos (* 2 2) (R3) (doble 4) \u21d2 ; Sustituimos doble por su cuerpo (R4) (+ 4 4) \u21d2 ; Evaluamos (+ 4 4) (R3) 8 Podemos comprobar que en el modelo aplicativo se intercalan las sustituciones de una funci\u00f3n por su cuerpo (regla 4) y las evaluaciones de expresiones (regla 3). Por el contrario, la evaluaci\u00f3n usando el modelo de sustituci\u00f3n normal es: (doble (cuadrado a)) \u21d2 ; Sustituimos doble por su cuerpo (R4) (+ (cuadrado a) (cuadrado a) \u21d2 ; Sustituimos cuadrado por su cuerpo (R4) (+ (* a a) (* a a) \u21d2 ; Sustitumos a por su valor (R2) (+ (* 2 2) (* 2 2) \u21d2 ; Evaluamos (* 2 2) (R3) (+ 4 (* 2 2)) \u21d2 ; Evaluamos (* 2 2) (R3) (+ 4 4) \u21d2 ; Evaluamos (+ 4 4) (R3) 8 Al usar este modelo de evaluaci\u00f3n primero se realizan todas las sustituciones (regla 4) y despu\u00e9s todas las evaluaciones (regla 3). Las sustituciones se hacen de izquierda a derecha (de fuera a dentro de los par\u00e9ntesis). Primero se sustituye doble por su cuerpo y despu\u00e9s cuadrado . 1.4.2. Ejemplo 2 \u00b6 Veamos la evaluaci\u00f3n del ejemplo algo m\u00e1s complicado que hemos planteado al comienzo: ( define ( doble x ) ( + x x )) ( define ( cuadrado y ) ( * y y )) ( define ( f z ) ( + ( cuadrado ( doble z )) 1 )) ( define a 2 ) Expresi\u00f3n a evaluar: ( f ( + a 1 )) Resultado de la evaluaci\u00f3n usando el modelo de sustituci\u00f3n aplicativo : (f (+ a 1)) \u21d2 ; Para evaluar f, evaluamos primero su argumento (+ a 1) (R4) ; y sustituimos a por 2 (R2) (f (+ 2 1)) \u21d2 ; Evaluamos (+ 2 1) (R3) (f 3) \u21d2 ; (R4) (+ (cuadrado (doble 3)) 1) \u21d2 ; Sustituimos (doble 3) (R4) (+ (cuadrado (+ 3 3)) 1) \u21d2 ; Evaluamos (+ 3 3) (R3) (+ (cuadrado 6) 1) \u21d2 ; Sustitumos (cuadrado 6) (R4) (+ (* 6 6) 1) \u21d2 ; Evaluamos (* 6 6) (R3) (+ 36 1) \u21d2 ; Evaluamos (+ 36 1) (R3) 37 Y veamos el resultado de usar el modelo de sustituci\u00f3n normal : (f (+ a 1)) \u21d2 ; Sustituimos (f (+ a 1)) ; por su definici\u00f3n, con z = (+ a 1) (R4) (+ (cuadrado (doble (+ a 1))) 1) \u21d2 ; Sustituimos (cuadrado ...) (R4) (+ (* (doble (+ a 1)) (doble (+ a 1))) 1) ; Sustituimos (doble ...) (R4) (+ (* (+ (+ a 1) (+ a 1)) (+ (+ a 1) (+ a 1))) 1) \u21d2 ; Evaluamos a (R2) (+ (* (+ (+ 2 1) (+ 2 1)) (+ (+ 2 1) (+ 2 1))) 1) \u21d2 ; Evaluamos (+ 2 1) (R3) (+ (* (+ 3 3) (+ 3 3)) 1) \u21d2 ; Evaluamos (+ 3 3) (R3) (+ (* 6 6) 1) \u21d2 ; Evaluamos (* 6 6) (R3) (+ 36 1) \u21d2 ; Evaluamos (+ 36 1) (R3) 37 En programaci\u00f3n funcional el resultado de evaluar una expresi\u00f3n es el mismo independientemente del tipo de orden. Pero si estamos fuera del paradigma funcional y las funciones tienen estado y cambian de valor entre distintas invocaciones s\u00ed que importan si escogemos un orden. Por ejemplo, supongamos una funci\u00f3n (random x) que devuelve un entero aleatorio entre 0 y x . Esta funci\u00f3n no cumplir\u00eda el paradigma funcional, porque devuelve un valor distinto con el mismo par\u00e1metro de entrada. Evaluamos las siguientes expresiones con orden aplicativo y normal, para comprobar que el resultado es distinto. ( define ( zero x ) ( - x x )) ( zero ( random 10 )) Si evaluamos la \u00faltima expresi\u00f3n en orden aplicativo: (zero (random 10)) \u21d2 ; Evaluamos (random 10) (R3) (zero 3) \u21d2 ; Sustituimos (zero ...) (R4) (- 3 3) \u21d2 ; Evaluamos - (R3) 0 Si lo evaluamos en orden normal: (zero (random 10)) \u21d2 ; Sustituimos (zero ...) (R4) (- (random 10) (random 10)) \u21d2 ; Evaluamos (random 10) (R3) (- 5 3) \u21d2 ; Evaluamos - (R3) 2 2. Scheme como lenguaje de programaci\u00f3n funcional \u00b6 Ya hemos visto c\u00f3mo definir funciones y evaluar expresiones en Scheme. Vamos continuar con ejemplos concretos de otras caracter\u00edsticas funcionales caracter\u00edsticas funcionales de Scheme. En concreto, veremos: S\u00edmbolos y primitiva quote Uso de listas Definici\u00f3n de funciones recursivas en Scheme 2.1. Funciones y formas especiales \u00b6 En el seminario de Scheme hemos visto un conjunto de primitivas que podemos utilizar en Scheme. Podemos clasificar las primitivas en funciones y formas especiales . Las funciones se eval\u00faan usando el modelo de sustituci\u00f3n aplicativo ya visto: Primero se eval\u00faan los argumentos y despu\u00e9s se sustituye la llamada a la funci\u00f3n por su cuerpo y se vuelve a evaluar la expresi\u00f3n resultante. Las expresiones siempre se eval\u00faan desde los par\u00e9ntesis interiores a los exteriores. Las formas especiales son expresiones primitivas de Scheme que tienen una forma de evaluarse propia, distinta de las funciones. 2.2. Formas especiales en Scheme \u00b6 Veamos la forma de evaluar las distintas formas especiales en Scheme. En estas formas especiales no se aplica el modelo de sustituci\u00f3n, al no ser invocaciones de funciones, sino que cada una se eval\u00faa de una forma diferente. 2.2.1. Forma especial define \u00b6 Sintaxis ( define <identificador> <expresi\u00f3n> ) Evaluaci\u00f3n Evaluar expresi\u00f3n Asociar el valor resultante con el identificador Ejemplo ( define base 10 ) ; Asociamos a 'base' el valor 10 ( define altura 12 ) ; Asociamos a 'altura' el valor 12 ( define area ( / ( * base altura ) 2 )) ; Asociamos a 'area' el valor 60 2.2.2. Forma especial define para definir funciones \u00b6 Sintaxis (define (<nombre-funcion> <argumentos>) <cuerpo>) Evaluaci\u00f3n La semana que viene veremos con m\u00e1s detalle la sem\u00e1ntica, y explicaremos la forma especial lambda que es la que realmente crea la funci\u00f3n. Hoy nos quedamos en la siguiente descripci\u00f3n de alto nivel de la sem\u00e1ntica: Crear la funci\u00f3n con el cuerpo Dar a la funci\u00f3n el nombre nombre-funci\u00f3n Ejemplo ( define ( factorial x ) ( if ( = x 0 ) 1 ( * x ( factorial ( - x 1 ))))) 2.2.3. Forma especial if \u00b6 Sintaxis ( if <condici\u00f3n> <expresi\u00f3n-true> <expresi\u00f3n-false> ) Evaluaci\u00f3n Evaluar condici\u00f3n Si el resultado es #t evaluar la expresi\u00f3n-true , en otro caso, evaluar la expresi\u00f3n-false Ejemplo ( if ( > 10 5 ) ( substring \"Hola qu\u00e9 tal\" ( + 1 1 ) 4 ) ( / 12 0 )) ;; Evaluamos (> 10 5). Como el resultado es #t, evaluamos ;; (substring \"Hola qu\u00e9 tal\" (+ 1 1) 4), que devuelve \"la\" Nota Al ser if una forma especial, no se eval\u00faa utilizando el modelo de sustituci\u00f3n, sino usando las reglas propias de la forma especial. Por ejemplo, veamos la siguiente expresi\u00f3n: ( if ( > 3 0 ) ( + 2 3 ) ( / 1 0 )) ; \u21d2 5 Si se evaluara con el modelo de sustituci\u00f3n se lanzar\u00eda un error de divisi\u00f3n por cero al intentar evaluar (/ 1 0) . Sin embargo, esa expresi\u00f3n no llega a evaluarse, porque la condici\u00f3n (> 3 0) es cierta y s\u00f3lo se eval\u00faa la suma (+ 2 3) . 2.2.4. Forma especial cond \u00b6 Sintaxis ( cond ( <exp-cond-1> <exp-consec-1> ) ( <exp-cond-2> <exp-consec-2> ) ... ( else <exp-consec-else> )) Evaluaci\u00f3n Se eval\u00faan de forma ordenada todas las exp-cond-i hasta que una de ellas devuelva #t Si alguna exp-cond-i devuelve #t , se devuelve el valor de la exp-consec-i . Si ninguna exp-cond-i es cierta, se devuelve el valor resultante de evaluar exp-consec-else . Ejemplo ( cond (( > 3 4 ) \"3 es mayor que 4\" ) (( < 2 1 ) \"2 es menor que 1\" ) (( = 3 1 ) \"3 es igual que 1\" ) (( > 3 5 ) \"3 es mayor que 2\" ) ( else \"ninguna condici\u00f3n es cierta\" )) ;; Se eval\u00faan una a una las expresiones (> 3 4), ;; (< 2 1), (= 3 1) y (> 3 5). Como ninguna de ella ;; es cierta se devuelve la cadena \"ninguna condici\u00f3n es cierta\". 2.2.4.1. Formas especiales and y or \u00b6 Las expresiones l\u00f3gicas and y or no son funciones, sino formas especiales. Lo podemos comprobar con el siguiente ejemplo: ( and #f ( / 3 0 )) ; \u21d2 #f ( or #t ( / 3 0 )) ; \u21d2 #t Si and y or fueran funciones, seguir\u00edan la regla que hemos visto de evaluar primero los argumentos y despu\u00e9s invocar a la funci\u00f3n con los resultados. Esto producir\u00eda un error al evaluar la expresi\u00f3n (/ 3 0) , al ser una divisi\u00f3n por 0. Sin embargo, vemos que las expresiones no dan error y devuelven un valor booleano. \u00bfPor qu\u00e9? Porque and y or no son funciones, sino formas especiales que se eval\u00faan de forma diferente a las funciones. En concreto, and y or van evaluando los argumentos hasta que encuentran un valor que hace que ya no sea necesario evaluar el resto. Sintaxis ( and exp1 ... expn ) ( or exp1 ... expn ) Evaluaci\u00f3n and Se eval\u00faa la expresi\u00f3n 1. Si el resultado es #f , se devuelve #f , en otro caso, se eval\u00faa la siguiente expresi\u00f3n. Se repite hasta la \u00faltima expresi\u00f3n, cuyo resultado se devuelve. Ejemplos and ( and #f ( / 3 0 )) ; \u21d2 #f ( and #t ( > 2 1 ) ( < 5 10 )) ; \u21d2 #t ( and #t ( > 2 1 ) ( < 5 10 ) ( + 2 3 )) ; \u21d2 5 La regla de evaluaci\u00f3n de and hace que sea posible que devuelva resultados no booleanos, como el \u00faltimo ejemplo. Sin embargo, no es recomendable usarlo de esta forma y en la asignatura no lo vamos a hacer nunca. Evaluaci\u00f3n or Se eval\u00faa la expresi\u00f3n 1. Si el resultado es distinto de #f se devuelve ese resultado. Si el resultado es #f se eval\u00faa la siguiente expresi\u00f3n. Se repite hasta la \u00faltima expresi\u00f3n, cuyo resultado se devuelve. Ejemplos or ( or #t ( / 3 0 )) ; \u21d2 #t ( or #f ( < 2 10 ) ( > 5 10 )) ; \u21d2 #t ( or ( + 2 3 ) ( > 5 10 )) ; \u21d2 5 Al igual que and , la regla de evaluaci\u00f3n de or hace que sea posible que devuelva resultados no booleanos, como el \u00faltimo ejemplo. Tampoco es recomendable usarlo de esta forma. 2.3. Forma especial quote y s\u00edmbolos \u00b6 Sintaxis ( quote <identificador> ) Evaluaci\u00f3n Se devuelve el identificador sin evaluar (un s\u00edmbolo). Se abrevia en con el car\u00e1cter ' . Ejemplos ( quote x ) ; el s\u00edmbolo x ' hola ; el s\u00edmbolo hola A diferencia de los lenguajes imperativos, Scheme trata a los identificadores (nombres que se les da a las variables) como datos del lenguaje de tipo symbol . En el paradigma funcional a los identificadores se les denomina s\u00edmbolos . Los s\u00edmbolos son distintos de las cadenas. Una cadena es un tipo de dato compuesto y se guardan en memoria todos y cada uno de los caracteres que la forman. Sin embargo, los s\u00edmbolos son tipos at\u00f3micos, que se representan en memoria con un \u00fanico valor determinado por el c\u00f3digo hash del identificador. Ejemplos de funciones Scheme con s\u00edmbolos: ( define x 12 ) ( symbol? ' x ) ; \u21d2 #t ( symbol? x ) ; \u21d2 #f \u00bfPor qu\u00e9? ( symbol? ' hola-que<> ) ( symbol->string ' hola-que<> ) ' ma\u00f1ana ' l\u00e1piz ; aunque sea posible, no vamos a usar acentos en los s\u00edmbolos ; pero s\u00ed en los comentarios ( symbol? \"hola\" ) ; #f ( symbol? #f ) ; #f ( symbol? ( first ' ( hola c\u00f3mo est\u00e1s ))) ; #t ( equal? ' hola ' hola ) ( equal? ' hola \"hola\" ) Como hemos visto anteriormente, un s\u00edmbolo puede asociarse o ligarse ( bind ) a un valor (cualquier dato de primera clase ) con la forma especial define . ( define pi 3.14159 ) Nota No es correcto escribir (define 'pi 3.14156) porque la forma especial define debe recibir un identificador sin quote . Cuando escribimos un s\u00edmbolo en el prompt de Scheme el int\u00e9rprete lo eval\u00faa y devuelve su valor: > pi 3.14159 Los nombres de las funciones ( equal? , sin , + , ...) son tambi\u00e9n s\u00edmbolos y Scheme tambi\u00e9n los eval\u00faa (en un par de semanas hablaremos de las funciones como objetos primitivos en Scheme): > sin #<procedure:sin> > + #<procedure:+> > (define (cuadrado x) (* x x)) > cuadrado #<procedure:cuadrado> Los s\u00edmbolos son tipos primitivos del lenguaje: pueden pasarse como par\u00e1metros o ligarse a variables. > (define x 'hola) > x hola 2.4. Forma expecial quote con expresiones \u00b6 Sintaxis ( quote <expresi\u00f3n> ) Evaluaci\u00f3n Si quote recibe una expresi\u00f3n correcta de Scheme (una expresi\u00f3n entre par\u00e9ntesis) se devuelve la lista o pareja pareja definida por la expresi\u00f3n (sin evaluar sus elementos). Ejemplos ' ( 1 2 3 ) ; \u21d2 (1 2 3) Una lista ' ( + 1 2 3 4 ) ; La lista formada por el s\u00edmbolo + y los n\u00fameros 1 2 3 4 ( quote ( 1 2 3 4 )) ; La lista formada por los n\u00fameros 1 2 3 4 ' ( a b c ) ; \u21d2 La lista con los s\u00edmbolos a, b, y c ' ( * ( + 1 ( + 2 3 )) 5 ) ; Una lista con 3 elementos, el segundo de ellos otra lista ' ( 1 . 2 ) ; \u21d2 La pareja (1 . 2) ' (( 1 . 2 ) ( 2 . 3 )) ; \u21d2 Una lista con las parejas (1 . 2) y (2 . 3) 2.5. Funci\u00f3n eval \u00b6 Una vez vista la forma especial quote podemos explicar la funci\u00f3n eval . La funci\u00f3n eval es una instrucci\u00f3n muy curiosa de los lenguajes funcionales. Permite invocar al int\u00e9rprete en tiempo de ejecuci\u00f3n y hacer que \u00e9ste eval\u00fae una expresi\u00f3n que puede haberse construido din\u00e1micamente. Sintaxis ( eval <expresi\u00f3n> ) Evaluaci\u00f3n La funci\u00f3n eval invoca al int\u00e9rprete para realizar la evaluaci\u00f3n de la expresi\u00f3n que se le pasa como par\u00e1metro y devuelve el resultado de dicha evaluaci\u00f3n. Ejemplos ( define a 10 ) ( eval ' a ) ; \u21d2 10 ( eval ' ( + 1 2 3 )) ; \u21d2 6 ( define lista ( list ' + 1 2 3 )) ( eval lista ) ; \u21d2 6 ( define a 10 ) ( define x ' a ) ( eval ' x ) ; \u21d2 a ( eval x ) ; \u21d2 10 ( eval ( eval ' x )) ; \u21d2 10 Una nota sobre la evaluaci\u00f3n de eval Al ser eval una funci\u00f3n, la expresi\u00f3n que se le pasa como par\u00e1metro se eval\u00faa previamente, antes de ser procesada por eval . En el caso de ser una expresi\u00f3n con quote , el resultado de la evaluaci\u00f3n es la propia expresi\u00f3n (una lista), que es procesada por eval . Por ejemplo, en la siguiente expresi\u00f3n ( eval ( + 2 3 )) ; \u21d2 5 primero se evaluar\u00eda la expresi\u00f3n (+ 2 3) y lo que se le pasar\u00eda a eval ser\u00eda un 5 . El resultado de evaluar un 5 ser\u00eda un 5 . Sin embargo, en la siguiente expresi\u00f3n: ( eval ' ( + 2 3 )) el resultado de evaluar '(+ 2 3) devolver\u00eda la lista (+ 2 3) que es la que se pasar\u00eda a eval . El resultado de evaluar esa expresi\u00f3n tambi\u00e9n ser\u00eda 5 . 2.6. Listas \u00b6 Otra de las caracter\u00edsticas fundamentales del paradigma funcional es la utilizaci\u00f3n de listas. Ya hemos visto en el seminario de Scheme las funciones m\u00e1s importantes para trabajar con ellas. Vamos a repasarlas de nuevo en este apartado, antes de ver alg\u00fan ejemplo de c\u00f3mo usar la recursi\u00f3n con listas. Ya hemos visto en dicho seminario que Scheme es un lenguaje d\u00e9bilmente tipado. Una variable o par\u00e1metro no se declara de un tipo y puede contener cualquier valor. Sucede igual con las listas: una lista en Scheme puede contener cualquier valor, incluyendo otras listas. 2.6.1. Diferencia entre la funci\u00f3n list y la forma especial quote \u00b6 En el seminario de Scheme explicamos que podemos crear listas de forma din\u00e1mica, llamando a la funci\u00f3n list y pas\u00e1ndole un n\u00famero variable de par\u00e1metros que son los elementos que se incluir\u00e1n en la lista: ( list 1 2 3 4 5 ) ; \u21d2 (1 2 3 4) ( list ' a ' b ' c ) ; \u21d2 (a b c) ( list 1 ' a 2 ' b 3 ' c #t ) ; \u21d2 (1 a 2 b 3 c #t) ( list 1 ( + 1 1 ) ( * 2 ( + 1 2 ))) ; \u21d2 (1 2 6) Las expresiones interiores se eval\u00faan y se llama a la funci\u00f3n list con los valores resultantes. Otro ejemplo: ( define a 1 ) ( define b 2 ) ( define c 3 ) ( list a b c ) ; \u21d2 (1 2 3) Como hemos visto cuando hemos hablado de quote , esta forma especial tambi\u00e9n puede construir una lista. Pero lo hace sin evaluar sus elementos. Por ejemplo: ' ( 1 2 3 4 ) ; \u21d2 (1 2 3 4) ( define a 1 ) ( define b 2 ) ( define c 3 ) ' ( a b c ) ; \u21d2 (a b c) ' ( 1 ( + 1 1 ) ( * 2 ( + 1 2 ))) ; \u21d2 (1 (+ 1 1) (* 2 (+ 1 2))) La \u00faltima lista tiene 3 elementos: El n\u00famero 1 La lista (+ 1 1) La lista (* 2 (+ 1 2)) Es posible definir una lista vac\u00eda (sin elementos) realizando una llamada sin argumentos a la funci\u00f3n list o utilizando el s\u00edmbolo `(): ( list ) ; \u21d2 () ` () ; \u21d2 () La diferencia entre creaci\u00f3n de listas con la funci\u00f3n list y con la forma especial quote se puede comprobar en los ejemplos. La evaluaci\u00f3n de la funci\u00f3n list funciona como cualquier funci\u00f3n, primero se eval\u00faan los argumentos y despu\u00e9s se invoca a la funci\u00f3n con los argumentos evaluados. Por ejemplo, en la siguiente invocaci\u00f3n se obtiene una lista con cuatro elementos resultantes de las invocaciones de las funciones dentro del par\u00e9ntesis: ( list 1 ( / 2 3 ) ( + 2 3 )) ; \u21d2 (1 2/3 5) Sin embargo, usamos quote obtenemos una lista con sublistas con s\u00edmbolos en sus primeras posiciones: ' ( 1 ( / 2 3 ) ( + 2 3 )) ; \u21d2 (1 (/ 2 3) (+ 2 3)) 2.6.2. Selecci\u00f3n de elementos de una lista: first y rest \u00b6 En el seminario vimos tambi\u00e9n c\u00f3mo obtener los elementos de una lista. Primer elemento: funci\u00f3n first Resto de elementos: funci\u00f3n rest (los devuelve en forma de lista) Ejemplos: ( define lista1 ' ( 1 2 3 4 )) ( first lista1 ) ; \u21d2 1 ( rest lista1 ) ; \u21d2 (2 3 4) ( define lista2 ' (( 1 2 ) 3 4 )) ( first lista2 ) \u21d2 ( 1 2 ) ( rest lista2 ) \u21d2 ( 3 4 ) 2.6.3. Composici\u00f3n de listas: cons y append \u00b6 Por \u00faltimo, en el seminario vimos tambi\u00e9n c\u00f3mo crear nuevas listas a partir de ya existentes con las funciones cons y append . La funci\u00f3n cons crea una lista nueva resultante de a\u00f1adir un elemento al comienzo de la lista. Esta funci\u00f3n es la forma habitual de construir nuevas listas a partir de una lista ya existente y un nuevo elemento. ( cons 1 ' ( 1 2 3 4 )) ; \u21d2 (1 1 2 3 4) ( cons ' hola ' ( como est\u00e1s )) ; \u21d2 (hola como est\u00e1s) ( cons ' ( 1 2 ) ' ( 1 2 3 4 )) ; \u21d2 ((1 2) 1 2 3 4) La funci\u00f3n append se usa para crear una lista nueva resultado de concatenar dos o m\u00e1s listas ( define list1 ' ( 1 2 3 4 )) ( define list2 ' ( hola como est\u00e1s )) ( append list1 list2 ) ; \u21d2 (1 2 3 4 hola como est\u00e1s) 2.7. Recursi\u00f3n \u00b6 Otra caracter\u00edstica fundamental de la programaci\u00f3n funcional es la no existencia de bucles. Un bucle implica la utilizaci\u00f3n de pasos de ejecuci\u00f3n en el programa y esto es caracter\u00edstico de la programaci\u00f3n imperativa. En programaci\u00f3n funcional las iteraciones se realizan con recursi\u00f3n. 2.7.1. Funci\u00f3n (suma-hasta x) \u00b6 Por ejemplo, podemos definir la funci\u00f3n (suma-hasta x) que devuelve la suma de los n\u00fameros hasta el par\u00e1metro x cuyo valor pasamos en la invocaci\u00f3n de la funci\u00f3n. Por ejemplo, (suma-hasta 5) devolver\u00e1 0+1+2+3+4+5 = 15 . La definici\u00f3n de la funci\u00f3n es la siguiente: ( define ( suma-hasta x ) ( if ( = 0 x ) 0 ( + ( suma-hasta ( - x 1 )) x ))) En una definici\u00f3n recursiva siempre tenemos un caso general y un caso base . El caso base define el valor que devuelve la funci\u00f3n en el caso elemental en el que no hay que hacer ning\u00fan c\u00e1lculo. El caso general define una expresi\u00f3n que contiene una llamada a la propia funci\u00f3n que estamos definiendo. El caso base es el caso en el que x vale 0. En este caso devolvemos el propio 0, no hay que realizar ning\u00fan c\u00e1lculo. El caso general es en el que se realiza la llamada recursiva. Esta llamada devuelve un valor que se utiliza para c\u00e1lculo final evaluando la expresi\u00f3n del caso general con valores concretos. En programaci\u00f3n funcional, al no existir efectos laterales, lo \u00fanico que importa cuando realizamos una recursi\u00f3n es el valor devuelto por la llamada recursiva. Ese valor devuelto se combina con el resto de la expresi\u00f3n del caso general para construir el valor resultante. Importante Para entender la recursi\u00f3n no es conveniente utilizar el depurador, ni hacer trazas, ni entrar en la recursi\u00f3n , sino que hay que suponer que la llamada recursiva se ejecuta y devuelve el valor que deber\u00eda. \u00a1Debemos confiar en la recursi\u00f3n! . El caso general del ejemplo anterior indica lo siguiente: Para calcular la suma hasta x: Llamamos a la recursi\u00f3n para que calcule la suma hasta x-1 (confiamos en que la implementaci\u00f3n funciona bien y esta llamada nos devolver\u00e1 el resultado hasta x-1) y a ese resultado le sumamos el propio n\u00famero x. Siempre es aconsejable usar un ejemplo concreto para probar el caso general. Por ejemplo, el caso general de la suma hasta 5 se calcular\u00e1 de la siguiente forma: ( + ( suma-hasta ( - 5 1 )) 5 ) ; \u21d2 ( + ( suma-hasta 4 ) 5 ) ; \u21d2 confiamos en la recursi\u00f3n: ; (suma-hasta 4) = 4+3+2+1 = 10 \u21d2 ( + 10 5 ) ; \u21d2 15 La evaluaci\u00f3n de esta funci\u00f3n calcular\u00e1 la llamada recursiva (suma-hasta 4) . Ah\u00ed es donde debemos confiar en que la recursi\u00f3n hace bien su trabajo y que esa llamada devuelve el valor resultante de 4+3+2+1, o sea, 10. Una vez obtenido ese valor hay que terminar el c\u00e1lculo sum\u00e1ndole el propio n\u00famero 5. Otra caracter\u00edstica necesaria del caso general en una definici\u00f3n recursiva, que tambi\u00e9n vemos en este ejemplo, es que la llamada recursiva debe trabajar sobre un caso m\u00e1s sencillo que la llamada general . De esta forma la recursi\u00f3n va descomponiendo el problema hasta llegar al caso base y construye la soluci\u00f3n a partir de ah\u00ed. En nuestro caso, la llamada recursiva para calcular la suma hasta 5 se hace calculando la suma hasta 4 (un caso m\u00e1s sencillo). 2.7.2. Dise\u00f1o de la funci\u00f3n (suma-hasta x) \u00b6 \u00bfC\u00f3mo hemos dise\u00f1ado esta funci\u00f3n? \u00bfC\u00f3mo hemos llegado a la soluci\u00f3n? Debemos empezar teniendo claro qu\u00e9 es lo que queremos calcular. Lo mejor es utilizar un ejemplo. Por ejemplo, (suma-hasta 5) devolver\u00e1 0+1+2+3+4+5 = 15 . Una vez que tenemos esta expresi\u00f3n de un ejemplo concreto debemos dise\u00f1ar el caso general de la recursi\u00f3n. Para ello tenemos que encontrar una expresi\u00f3n para el c\u00e1lculo de (suma-hasta 5) que use una llamada recursiva a un problema m\u00e1s peque\u00f1o. O, lo que es lo mismo, \u00bfpodemos obtener el resultado 15 con lo que nos devuelve una llamada recursiva que obtenga la suma hasta un n\u00famero m\u00e1s peque\u00f1o y haciendo algo m\u00e1s? Pues s\u00ed: para calcular la suma hasta 5, esto es, para obtener 15, podemos llamar a la recursi\u00f3n para calcular la suma hasta 4 (devuelve 10) y a este resultado sumarle el propio 5. Lo podemos expresar con el siguiente dibujo: Generalizamos este ejemplo y lo expresamos en Scheme de la siguiente forma: ( define ( suma-hasta x ) ( + ( suma-hasta ( - x 1 )) x )) Nos falta el caso base de la recursi\u00f3n. Debemos preguntarnos \u00bfcu\u00e1l es el caso m\u00e1s sencillo del problema, que podemos calcular sin hacer ninguna llamada recursiva? . En este caso podr\u00eda ser el caso en el que x es 0, en el que devolver\u00edamos 0. Podemos ya escribirlo todo en Scheme: ( define ( suma-hasta x ) ( if ( = 0 x ) 0 ( + ( suma-hasta ( - x 1 )) x ))) Una aclaraci\u00f3n sobre el caso general. En la implementaci\u00f3n anterior la llamada recursiva a suma-hasta se realiza en el primer argumento de la suma: ( + ( suma-hasta ( - x 1 )) x ) La expresi\u00f3n anterior es totalmente equivalente a la siguiente en la que la llamada recursiva aparece como segundo argumento ( + x ( suma-hasta ( - x 1 ))) Ambas expresiones son equivalentes porque en programaci\u00f3n funcional no importa el orden en el que se eval\u00faan los argumentos. Da lo mismo evaluarlos de derecha a izquierda que de izquierda a derecha. La transparencia referencial garantiza que el resultado es el mismo. 2.7.3. Funci\u00f3n (alfabeto-hasta char) \u00b6 Vamos con otro ejemplo. Queremos dise\u00f1ar una funci\u00f3n (alfabeto-hasta char) que devuelva una cadena que empieza en la letra a y termina en el car\u00e1cter que le pasamos como par\u00e1metro. Por ejemplo: ( alfabeto-hasta #\\h ) ; \u21d2 \"abcdefgh\" ( alfabeto-hasta #\\z ) ; \u21d2 \"abcdefghijklmnopqrstuvwxyz\" Pensamos en el caso general: \u00bfc\u00f3mo podr\u00edamos invocar a la propia funci\u00f3n alfabeto-hasta para que (confiando en la recursi\u00f3n) nos haga gran parte del trabajo (construya casi toda la cadena con el alfabeto)? Podr\u00edamos hacer que la llamada recursiva devolviera el alfabeto hasta el car\u00e1cter previo al que nos pasan como par\u00e1metro y despu\u00e9s nosotros a\u00f1adir ese car\u00e1cter a la cadena que devuelve la recursi\u00f3n. Veamos un ejemplo concreto: (alfabeto-hasta #\\h) = (alfabeto-hasta #\\g) + \\#h La llamada recursiva (alfabeto-hasta #\\g) devolver\u00eda la cadena \"abcdefg\" (confiando en la recursi\u00f3n) y s\u00f3lo faltar\u00eda a\u00f1adir la \u00faltima letra. Para implementar esta idea en Scheme lo \u00fanico que necesitamos es usar la funci\u00f3n string-append para concatenar cadenas y una funci\u00f3n auxiliar (anterior char) que devuelve el car\u00e1cter anterior a uno dado. ( define ( anterior char ) ( integer->char ( - ( char->integer char ) 1 ))) El caso general quedar\u00eda como sigue: ( define ( alfabeto-hasta char ) ( string-append ( alfabeto-hasta ( anterior char )) ( string char ))) Faltar\u00eda el caso base. \u00bfCu\u00e1l es el caso m\u00e1s sencillo posible que nos pueden pedir? El caso del alfabeto hasta la #\\a . En ese caso basta con devolver la cadena \"a\" . La funci\u00f3n completa quedar\u00eda as\u00ed: ( define ( alfabeto-hasta char ) ( if ( equal? char #\\a ) \"a\" ( string-append ( alfabeto-hasta ( anterior char )) ( string char )))) 2.8. Recursi\u00f3n y listas \u00b6 La utilizaci\u00f3n de la recursi\u00f3n es muy \u00fatil para trabajar con estructuras secuenciales, como listas. Vamos a empezar viendo unos sencillos ejemplos y m\u00e1s adelante veremos algunos m\u00e1s complicadas. 2.8.1. Funci\u00f3n recursiva suma-lista \u00b6 Veamos un primer ejemplo, la funci\u00f3n (suma-lista lista-nums) que recibe como par\u00e1metro una lista de n\u00fameros y devuelve la suma de todos ellos. Siempre debemos empezar escribiendo un ejemplo de la funci\u00f3n, para entenderla bien: ( suma-lista ' ( 12 3 5 1 8 )) ; \u21d2 29 Para dise\u00f1ar una implementaci\u00f3n recursiva de la funci\u00f3n tenemos que pensar en c\u00f3mo descomponer el ejemplo en una llamada recursiva a un problema m\u00e1s peque\u00f1o y en c\u00f3mo tratar el valor devuelto por la recursi\u00f3n para obtener el valor esperado. Por ejemplo, en este caso podemos pensar que para sumar la lista de n\u00fameros (12 3 5 1 8) podemos obtener un problema m\u00e1s sencillo (una lista m\u00e1s peque\u00f1a) haciendo el cdr de la lista de n\u00fameros y llamando a la recursi\u00f3n con el resultado. La llamada recursiva devolver\u00e1 la suma de esos n\u00fameros (confiamos en la recursi\u00f3n) y a ese valor basta con sumarle el primer n\u00famero de la lista. Lo podemos representar en el siguiente dibujo: Podemos generalizar este ejemplo y expresarlo en Scheme de la siguiente forma: ( define ( suma-lista lista ) ( + ( first lista ) ( suma-lista ( rest lista )))) Falta el caso base. \u00bfCu\u00e1l es la lista m\u00e1s sencilla con la que podemos calcular la suma de sus elementos sin llamar a la recursi\u00f3n?. Podr\u00eda ser una lista sin elementos, y devolvemos 0. O una lista con un \u00fanico elemento, y devolvemos el propio elemento. Escogemos como caso base el primero de ellos. Con todo junto, la recursi\u00f3n quedar\u00eda como sigue: ( define ( suma-lista lista ) ( if ( null? lista ) 0 ( + ( first lista ) ( suma-lista ( rest lista ))))) 2.8.2. Funci\u00f3n recursiva longitud \u00b6 Veamos c\u00f3mo definir la funci\u00f3n recursiva que devuelve la longitud de una lista, el n\u00famero de elementos que contiene. Comencemos como siempre con un ejemplo: ( longitud ' ( a b c d e )) ; \u21d2 5 Suponiendo que la funci\u00f3n longitud funciona correctamente, \u00bfc\u00f3mo podr\u00edamos formular el caso general de la recursi\u00f3n? \u00bfc\u00f3mo podr\u00edamos llamar a la recursi\u00f3n con un problema m\u00e1s peque\u00f1o y c\u00f3mo podemos aprovechar el resultado de esta llamada para obtener el resultado final? En este caso es bastante sencillo. Si a la lista le quitamos un elemento, cuando llamemos a la recursi\u00f3n nos va a devolver la longitud original menos uno. En este caso: ( longitud ( rest ' ( a b c d e ))) ; \u21d2 ( longitud ' ( b c d e )) \u21d2 ( confiamos en la recursi\u00f3n ) 4 De esta forma, para conseguir la longitud de la lista inicial, s\u00f3lo habr\u00eda que sumarle 1 a lo que nos devuelve la llamada recursiva. Si expresamos en Scheme este caso general: ; S\u00f3lo se define el caso general, falta el caso base ( define ( longitud lista ) ( + ( longitud ( rest lista )) 1 )) Para definir el caso base debemos preguntarnos cu\u00e1l es el caso m\u00e1s simple que le podemos pasar a la funci\u00f3n. Si en cada llamada recursiva vamos reduciendo la longitud de la lista, el caso base recibir\u00e1 la lista vac\u00eda. \u00bfCu\u00e1l es la longitud de una lista vac\u00eda? Una lista vac\u00eda no tiene elementos, por lo que es 0. De esta forma completamos la definici\u00f3n de la funci\u00f3n: ( define ( longitud lista ) ( if ( null? lista ) 0 ( + ( longitud ( rest lista )) 1 ))) En Scheme existe la funci\u00f3n length que hace lo mismo. Devuelve la longitud de una lista: ( length ' ( a b c d e )) ; \u21d2 5 2.8.3. C\u00f3mo comprobar si una lista tiene un \u00fanico elemento \u00b6 En el caso base de algunas funciones recursivas es necesario comprobar que la lista que se pasa como par\u00e1metro tiene un \u00fanico elemento. Por ejemplo, en el caso base de la funci\u00f3n recursiva que comprueba si una lista est\u00e1 ordenada. Al estar definida la funci\u00f3n length en Scheme la primera idea que se nos puede ocurrir es comprobar si la longitud de la lista es 1. Sin embargo es una mala idea. ; Ejemplo de funci\u00f3n recursiva con un caso ; base en el que se comprueba si la lista tienen ; un \u00fanico elemento ; \u00a1\u00a1MALA IDEA, NO HACERLO AS\u00cd!! ( define ( foo lista ) ( if ( = ( length lista ) 1 ) ; devuelve caso base ; caso general )) El problema de la implementaci\u00f3n anterior es que el coste de la funci\u00f3n length es lineal. Tal y como hemos visto en el apartado anterior, para calcular la longitud de la lista es necesario recorrer todos sus elementos. Adem\u00e1s, la funci\u00f3n recursiva hace esa comprobaci\u00f3n en cada llamada recursiva. El coste resultante de la funci\u00f3n foo , por tanto, es cuadr\u00e1tico. \u00bfC\u00f3mo mejorar el coste? Hay que tener en cuenta que la comprobaci\u00f3n anterior est\u00e1 haciendo cosas de m\u00e1s. Realmente no queremos saber la longitud de la lista sino \u00fanicamente si esa longitud es mayor que uno. Esta comprobaci\u00f3n s\u00ed que puede hacerse en tiempo constante. Lo \u00fanico que debemos hacer es comprobar si el cdr de la lista es la lista vac\u00eda. Si lo es, ya sabemos que la lista original ten\u00eda un \u00fanico elemento. Por tanto, la versi\u00f3n correcto del c\u00f3digo anterior ser\u00eda la siguiente: ; Versi\u00f3n correcta para comprobar si una lista tiene ; un \u00fanico elemento ( define ( foo lista ) ( if ( null? ( rest lista )) ; devuelve caso base ; caso general )) El coste de la comprobaci\u00f3n (null? (rest lista)) es constante. No depende de la longitud de la lista. 2.8.4. Funci\u00f3n recursiva veces \u00b6 Como \u00faltimo ejemplo vamos a definir la funci\u00f3n ( veces lista id ) que cuenta el n\u00famero de veces que aparece un identificador en una lista. Por ejemplo, ( veces ' ( a b c a d a ) ' a ) ; \u21d2 3 \u00bfC\u00f3mo planteamos el caso general? Llamaremos a la recursi\u00f3n con el resto de la lista. Esta llamada nos devolver\u00e1 el n\u00famero de veces que aparece el identificador en este resto de la lista. Y sumaremos al valor devuelto 1 si el primer elemento de la lista coincide con el identificador. En Scheme hay que definir este caso general en una \u00fanica expresi\u00f3n: ( if ( equal? ( first lista ) id ) ( + 1 ( veces ( rest lista ) id )) ( veces ( rest lista ) id )) Como caso base, si la lista es vac\u00eda devolvemos 0. La versi\u00f3n completa: ( define ( veces lista id ) ( cond (( null? lista ) 0 ) (( equal? ( first lista ) id ) ( + 1 ( veces ( rest lista ) id ))) ( else ( veces ( rest lista ) id )))) ( veces ' ( a b a a b b ) ' a ) ; \u21d2 3 3. Tipos de datos compuestos en Scheme \u00b6 3.1. El tipo de dato pareja \u00b6 3.1.1. Funci\u00f3n de construcci\u00f3n de parejas cons \u00b6 Ya hemos visto en el seminario de Scheme que el tipo de dato compuesto m\u00e1s simple es la pareja: una entidad formada por dos elementos. Se utiliza la funci\u00f3n cons para construirla: ( cons 1 2 ) ; \u21d2 (1 . 2) ( define c ( cons 1 2 )) Dibujamos la pareja anterior y la variable c que la referencia de la siguiente forma: Tipo compuesto pareja La instrucci\u00f3n cons construye un dato compuesto a partir de otros dos datos (que llamaremos izquierdo y derecho). La expresi\u00f3n (1 . 2) es la forma que el int\u00e9rprete tiene de imprimir las parejas. 3.1.2. Construcci\u00f3n de parejas con quote \u00b6 Al igual que las listas, es posible construir parejas con la forma especial quote , definiendo la pareja entre par\u00e9ntesis y separando su parte izquierda y derecha con un punto: ' ( 1 . 2 ) ; \u21d2 (1 . 2) Utilizaremos a veces cons y otras veces quote para definir parejas. Pero hay que tener en cuenta que, al igual que con las listas, quote no eval\u00faa sus par\u00e1metros, por lo que no lo deberemos utilizar por ejemplo dentro de una funci\u00f3n en la que queremos construir una pareja con los resultados de evaluar expresiones. Por ejemplo: ( define a 1 ) ( define b 2 ) ( cons a b ) ; \u21d2 (1 . 2) ' ( a . b ) ; \u21d2 (a . b) 3.1.3. Funciones de acceso car y cdr \u00b6 Una vez construida una pareja, podemos obtener el elemento correspondiente a su parte izquierda con la funci\u00f3n car y su parte derecha con la funci\u00f3n cdr : ( define c ( cons 1 2 )) ( car c ) ; \u21d2 1 ( cdr c ) ; \u21d2 2 3.1.3.1. Definici\u00f3n declarativa \u00b6 Las funciones cons , car y cdr quedan perfectamente definidas con las siguientes ecuaciones algebraicas: ( car ( cons x y )) = x ( cdr ( cons x y )) = y \u00bfDe d\u00f3nde vienen los nombres car y cdr ? Inicialmente los nombres eran CAR y CDR (en may\u00fasculas). La historia se remonta al a\u00f1o 1959, en los or\u00edgenes del Lisp y tiene que ver con el nombre que se les daba a ciertos registros de la memoria del IBM 709. Podemos leer la explicaci\u00f3n completa en The origin of CAR and CDR in LISP . 3.1.4. Funci\u00f3n pair? \u00b6 La funci\u00f3n pair? nos dice si un objeto es at\u00f3mico o es una pareja: ( pair? 3 ) ; \u21d2 #f ( pair? ( cons 3 4 )) ; \u21d2 #t 3.1.5. Las parejas pueden contener cualquier tipo de dato \u00b6 Ya hemos comprobado que Scheme es un lenguaje d\u00e9bilmente tipado . Las funciones pueden devolver y recibir distintos tipos de datos. Por ejemplo, podr\u00edamos definir la siguiente funci\u00f3n suma que sume tanto n\u00fameros como cadenas: ( define ( suma x y ) ( cond (( and ( number? x ) ( number? y )) ( + x y )) (( and ( string? x ) ( string? y )) ( string-append x y )) ( else ' error ))) En la funci\u00f3n anterior los par\u00e1metros x e y pueden ser n\u00fameros o cadenas (o incluso de cualquier otro tipo). Y el valor devuelto por la funci\u00f3n ser\u00e1 un n\u00famero, una cadena o el s\u00edmbolo 'error . Sucede lo mismo con el contenido de las parejas. Es posible guardar en las parejas cualquier tipo de dato y combinar distintos tipos. Por ejemplo: ( define c ( cons ' hola #f )) ( car c ) ; \u21d2 'hola ( cdr c ) ; \u21d2 #f 3.1.6. Las parejas son objetos inmutables \u00b6 Recordemos que en los paradigmas de programaci\u00f3n declarativa y funcional no existe el estado mutable . Una vez declarado un valor, no se puede modificar. Esto debe suceder tambi\u00e9n con las parejas: una vez creada una pareja no se puede modificar su contenido. En Lisp y Scheme est\u00e1ndar las parejas s\u00ed que pueden ser mutadas. Pero durante toda esta primera parte de la asignatura no lo contemplaremos, para no salirnos del paradigma funcional. En Swift y otros lenguajes de programaci\u00f3n es posible definir estructuras de datos inmutables que no pueden ser modificadas una vez creadas. Lo veremos tambi\u00e9n m\u00e1s adelante. 3.2. Las parejas son objetos de primera clase \u00b6 En un lenguaje de programaci\u00f3n un elemento es de primera clase cuando puede: Asignarse a variables Pasarse como argumento Devolverse por una funci\u00f3n Guardarse en una estructura de datos mayor Las parejas son objetos de primera clase. Una pareja puede asignarse a una variable: ( define p1 ( cons 1 2 )) ( define p2 ( cons #f \"hola\" )) Una pareja puede pasarse como argumento y devolverse en una funci\u00f3n: ( define ( suma-parejas p1 p2 ) ( cons ( + ( car p1 ) ( car p2 )) ( + ( cdr p1 ) ( cdr p2 )))) ( suma-parejas ' ( 1 . 5 ) ' ( 4 . 12 )) ; \u21d2 (5 . 17) Una vez definida esta funci\u00f3n suma-parejas podr\u00edamos ampliar la funci\u00f3n suma que vimos previamente con este nuevo tipo de datos: ( define ( suma x y ) ( cond (( and ( number? x ) ( number? y )) ( + x y )) (( and ( string? x ) ( string? y )) ( string-append x y )) (( and ( pair? x ) ( pair? y )) ( suma-parejas p1 p2 )) ( else ' error ))) Y, por \u00faltimo, las parejas pueden formar parte de otras parejas . Es lo que se denomina la propiedad de clausura de la funci\u00f3n cons : el resultado de un cons puede usarse como par\u00e1metro de nuevas llamadas a cons . Ejemplo: ( define p1 ( cons 1 2 )) ( define p2 ( cons 3 4 )) ( define p ( cons p1 p2 )) Expresi\u00f3n equivalente: ( define p ( cons ( cons 1 2 ) ( cons 3 4 ))) Podr\u00edamos representar esta estructura as\u00ed: Propiedad de clausura: las parejas pueden contener parejas Pero se har\u00eda muy complicado representar muchos niveles de anidamiento. Por eso utilizamos la siguiente representaci\u00f3n: Llamamos a estos diagramas diagramas caja-y-puntero ( box-and-pointer en ingl\u00e9s). 3.3. Diagramas caja-y-puntero \u00b6 Al escribir expresiones complicadas con cons anidados es conveniente para mejorar su legibilidad utilizar el siguiente formato: ( define p ( cons ( cons 1 ( cons 3 4 )) 2 )) Para entender la construcci\u00f3n de estas estructuras es importante recordar que las expresiones se eval\u00faan de dentro a afuera . \u00bfQu\u00e9 figura representar\u00eda la estructura anterior? Soluci\u00f3n: Es importante tener en cuenta que cada caja del diagrama representa una pareja creada en la memoria del int\u00e9rprete con la instrucci\u00f3n cons y que el resultado de evaluar una variable en la que se ha guardado una pareja devuelve la pareja reci\u00e9n creada. Por ejemplo, si el int\u00e9rprete eval\u00faa p despu\u00e9s de haber hecho la sentencia anterior devuelve la pareja contenida en p , no se crea una pareja nueva. Por ejemplo, si despu\u00e9s de haber evaluado la sentencia anterior evaluamos la siguiente: ( define p2 ( cons 5 ( cons p 6 ))) El diagrama caja y puntero resultante ser\u00eda el siguiente: Vemos que en la pareja que se crea con (cons p 6) se guarda en la parte izquierda la misma pareja que hay en p . Lo representamos con una flecha que apunta a la misma pareja que p . Nota El funcionamiento de la evaluaci\u00f3n de variables que contienen parejas es similar al de las variables que contienen objetos en lenguajes orientados a objetos como Java. Cuando se eval\u00faa una variable que contiene una pareja se devuelve la propia pareja, no una copia. En programaci\u00f3n funcional, como el contenido de las parejas es inmutable, no hay problemas de efectos laterales por el hecho de que una pareja est\u00e9 compartida. Es conveniente que pruebes a crear distintas estructuras de parejas con parejas y a dibujar su diagrama caja y puntero. Y tambi\u00e9n a recuperar un determinado dato (pareja o dato at\u00f3mico) una vez creada la estructura. La siguiente funci\u00f3n print-pareja puede ser \u00fatil a la hora de mostrar por pantalla los elementos de una pareja ( define ( print-pareja pareja ) ( if ( pair? pareja ) ( begin ( display \"(\" ) ( print-dato ( car pareja )) ( display \" . \" ) ( print-dato ( cdr pareja )) ( display \")\" )) ( display \"\" ))) ( define ( print-dato dato ) ( if ( pair? dato ) ( print-pareja dato ) ( display dato ))) \u00a1Cuidado! La funci\u00f3n anterior contiene pasos de ejecuci\u00f3n con sentencias como begin y llamadas a display dentro del c\u00f3digo de la funci\u00f3n. Estas sentencias son propias de la programaci\u00f3n imperativa. No hacerlo en programaci\u00f3n funcional . 3.3.1. Funciones c????r \u00b6 Al trabajar con estructuras de parejas anidades es muy habitual realizar llamadas del tipo: ( cdr ( cdr ( car p ))) ; \u21d2 4 Es equivalente a la funci\u00f3n cadar de Scheme: ( cddar p ) ; \u21d2 4 El nombre de la funci\u00f3n se obtiene concatenando a la letra \"c\", las letras \"a\" o \"d\" seg\u00fan hagamos un car o un cdr y terminando con la letra \"r\". Hay definidas 2^4 funciones de este tipo: caaaar , caaadr , \u2026, cddddr . 4. Listas en Scheme \u00b6 4.1. Implementaci\u00f3n de listas en Scheme \u00b6 Recordemos que Scheme permite manejar listas como un tipo de datos b\u00e1sico. Hemos visto funciones para crear, a\u00f1adir y recorrer listas. En Scheme las listas se implementan usando parejas, por lo que las funciones car y cdr tambi\u00e9n funcionan sobre listas. \u00bfQu\u00e9 devuelven cuando se aplican a una lista? \u00bfC\u00f3mo se implementan las listas con parejas? Vamos a investigarlo haciendo unas pruebas. En primer lugar, vamos a usar las funciones list? y pair? para comprobar si algo es una lista y/o una pareja. Por ejemplo, una pareja formada por dos n\u00fameros es una pareja, pero no es una lista: ( define p1 ( cons 1 2 )) ( pair? p1 ) ; \u21d2 #t ( list? p1 ) ; \u21d2 #f Si preguntamos si una lista es una pareja, nos llevaremos la sorpresa de que s\u00ed. Una lista es una lista (evidentemente) pero tambi\u00e9n es una pareja: ( define lista ' ( 1 2 3 )) ( list? lista ) ; \u21d2 #t ( pair? lista ) ; \u21d2 #t Si una lista es tambi\u00e9n una pareja tambi\u00e9n podemos aplicar las funciones car y cdr con ellas. \u00bfQu\u00e9 devuelven? Vamos a verlo: ( define lista ' ( 1 2 3 )) ( car lista ) ; \u21d2 1 ( cdr lista ) ; \u21d2 (2 3) Resulta que en la pareja que representa la lista, en la parte izquierda se guarda el primer el elemento de la lista y en la parte derecha se guarda el resto de la lista. Tambi\u00e9n podemos explicar entonces por qu\u00e9 la llamada a cons con un dato y una lista construye otra lista: ( define lista ' ( 1 2 3 )) ( define p1 ( cons 1 lista )) ( list? p1 ) ; \u21d2 #t p1 ; \u21d2 (1 1 2 3) \u00bfUna pareja con una lista vac\u00eda como parte derecha es una lista? Lo probamos: ( define p1 ( cons 1 ' ())) ( pair? p1 ) ; \u21d2 #t ( list? p1 ) ; \u21d2 #t Con estos ejemplos ya tenemos pistas para deducir la relaci\u00f3n entre listas y parejas en Scheme (y Lisp). Vamos a explicarlo. 4.1.1. Definici\u00f3n de listas con parejas \u00b6 Una lista es: Una pareja que contiene en su parte izquierda el primer elemento de la lista y en su parte derecha el resto de la lista Un s\u00edmbolo especial '() que denota la lista vac\u00eda Hay que notar que la definici\u00f3n anterior es una definici\u00f3n recursiva. Por ejemplo, una lista muy sencilla con un solo elemento, (1) , se define con la siguiente pareja: ( cons 1 ' ()) La pareja cumple las condiciones anteriores: La parte izquierda de la pareja es el primer elemento de la lista (el n\u00famero 1) La parte derecha es el resto de la lista (la lista vac\u00eda) La lista (1) El objeto es al mismo tiempo una pareja y una lista. La funci\u00f3n list? permite comprobar si un objeto es una lista: ( define l ( cons 1 ' ())) ( pair? l ) ( list? l ) Por ejemplo, la lista '(1 2 3 4) se construye con la siguiente secuencia de parejas: ( cons 1 ( cons 2 ( cons 3 ( cons 4 ' ())))) La primera pareja cumple las condiciones de ser una lista: Su primer elemento es el 1 Su parte derecha es la lista '(2 3 4) Parejas formando una lista Al comprobar la implementaci\u00f3n de las listas en Scheme, entendemos por qu\u00e9 las funciones car y cdr nos devuelven el primer elemento y el resto de la lista. De hecho, las funciones first y rest se implementan usando las funciones car y cdr . 4.1.2. Lista vac\u00eda \u00b6 La lista vac\u00eda es una lista: ( list? ' ()) ; \u21d2 #t Y no es un s\u00edmbolo ni una pareja: ( symbol? ' ()) ; \u21d2 #f ( pair? ' ()) ; \u21d2 #f Para saber si un objeto es la lista vac\u00eda, podemos utilizar la funci\u00f3n null? : ( null? ' ()) ; \u21d2 #t En Racket est\u00e1 predefinido el s\u00edmbolo null que tiene como valor la lista vac\u00eda: null ; \u21d2 () 4.2. Listas con elementos compuestos \u00b6 Las listas pueden contener cualquier tipo de elementos, incluyendo otras parejas. La siguiente estructura se denomina lista de asociaci\u00f3n . Son listas cuyos elementos son parejas ( clave , valor ): ( list ( cons ' a 1 ) ( cons ' b 2 ) ( cons ' c 3 )) ; \u21d2 ((a . 1) (b . 2) (c . 2)) \u00bfCu\u00e1l ser\u00eda el diagrama box and pointer de la estructura anterior? La expresi\u00f3n equivalente utilizando conses es: ( cons ( cons ' a 1 ) ( cons ( cons ' b 2 ) ( cons ( cons ' c 3 ) ' ()))) 4.2.1. Listas de listas \u00b6 Hemos visto que podemos construir listas que contienen otras listas: ( define lista ( list 1 ( list 1 2 3 ) 3 )) La lista anterior tambi\u00e9n se puede definir con quote: ( define lista ' ( 1 ( 1 2 3 ) 3 )) La lista resultante contiene tres elementos: el primero y el \u00faltimo son elementos at\u00f3micos (n\u00fameros) y el segundo es otra lista. Si preguntamos por la longitud de la lista Scheme nos dir\u00e1 que es una lista de 3 elementos: ( length lista ) ; \u21d2 3 Y el segundo elemento de la lista es otra lista: ( car ( cdr lista )) ; \u21d2 (1 2 3) \u00bfC\u00f3mo implementa Scheme esta lista usando parejas? Al ser una lista de tres elementos lo har\u00e1 con tres parejas enlazadas que terminan en una lista vac\u00eda en la parte derecha de la \u00faltima pareja. En las partes izquierdas de esas tres parejas tendremos los elementos de la lista propiamente dichos: un 1 y un 3 en la primera y \u00faltima pareja y una lista en la segunda pareja. El diagrama box and pointer : Lista que contiene otra lista como segundo elemento 4.2.2. Impresi\u00f3n de listas y parejas por el int\u00e9rprete de Scheme \u00b6 El int\u00e9rprete de Scheme siempre intenta mostrar una lista cuando encuentra una pareja cuyo siguiente elemento es otra pareja. Por ejemplo, si tenemos la siguiente estructura: ( define p ( cons 1 ( cons 2 3 ))) Cuando se eval\u00fae p el int\u00e9rprete imprimir\u00e1 por pantalla lo siguiente: ( 1 2 . 3 ) \u00bfPor qu\u00e9? Porque el int\u00e9rprete va construyendo la salida conforme recorre la pareja p . Como encuentra una pareja cuya parte derecha es otra pareja, lo interpreta como el comienzo de una lista, y por eso escribe (1 2 en lugar de (1 . 2 . Pero inmediatamente despu\u00e9s se encuentra con el 3 en lugar de una lista vac\u00eda. En ese momento el int\u00e9rprete \"se da cuenta\" de que no tenemos una lista y termina la expresi\u00f3n escribiendo el . 3 y el par\u00e9ntesis final. Si queremos comprobar la estructura de parejas podemos utilizar la funci\u00f3n print-pareja definida anteriormente, que imprimir\u00eda lo siguiente: ( print-pareja p ) ; \u21d2 (1 . (2 . 3)) 4.2.3. Funciones de alto nivel sobre listas \u00b6 Es importante conocer c\u00f3mo se implementan las listas usando parejas y su representaci\u00f3n con diagramas caja y puntero para definir funciones de alto nivel. Una vez conocidos los detalles de implementaci\u00f3n, podemos volver a usar las funciones que tienen un nivel de abstracci\u00f3n mayor como first y rest . Son funciones que tienen un nombre entendible y que comunican perfectamente lo que hacen (devolver el primer elemento y el resto). ( first ' ( a b c d )) ; \u21d2 a ( rest ' ( a b c d )) ; \u21d2 (b c d) Existen otras funciones de alto nivel que trabajan sobre listas. Algunas ya las conocemos, pero otras no: ( append ' ( a ( b ) c ) ' (( d ) e f )) ; \u21d2 (a (b) c (d) e f) ( list-ref ' ( a ( b ) c d ) 2 ) ; \u21d2 c ( length ' ( a ( b ( c ))) ; \u21d2 2 ( reverse ' ( a b c )) ; \u200c\u21d2 (c b a) ( list-tail ' ( a b c d ) 2 ) ; \u200c\u21d2 (c d) En los siguientes apartados veremos c\u00f3mo est\u00e1n implementadas. 4.3. Funciones recursivas que construyen listas \u00b6 Para terminar el apartado sobre las listas en Scheme vamos a ver ejemplos adicionales de funciones recursivas que trabajan con listas. Veremos alguna funci\u00f3n que recibe una lista y, como antes, usa la recursi\u00f3n para recorrerla. Pero veremos tambi\u00e9n funciones que usan la recursi\u00f3n para construir nuevas listas . Algunas de las funciones que presentamos son implementaciones de las ya existentes en Scheme. Para no solapar con las definiciones de Scheme pondremos el prefijo mi- en todas ellas. Vamos a ver las siguientes funciones: mi-list-ref : implementaci\u00f3n de la funci\u00f3n list-ref mi-list-tail : implementaci\u00f3n de la funci\u00f3n list-tail mi-append : implementaci\u00f3n de la funi\u00f3n append mi-reverse : implementaci\u00f3n de la funci\u00f3n reverse cuadrados-hasta : devuelve la lista de cuadrados hasta uno dado filtra-pares : devuelve la lista de los n\u00fameros pares de la lista que se recibe primo? : comprueba si un n\u00famero es o no primo 4.3.1. Funci\u00f3n mi-list-ref \u00b6 La funci\u00f3n (mi-list-ref n lista) devuelve el elemento n de una lista (empezando a contar por 0): ( define lista ' ( a b c d e f g )) ( mi-list-ref lista 2 ) ; \u21d2 c Veamos con el ejemplo anterior c\u00f3mo hacer la formulaci\u00f3n recursiva. Hemos visto que, en general, cuando queremos resolver un problema de forma recursiva tenemos que hacer una llamada recursiva a un problema m\u00e1s sencillo, confiar en que la llamada nos devuelva el resultado correcto y usar ese resultado para resolver el problema original. En este caso nuestro problema es obtener el n\u00famero que est\u00e1 en la posici\u00f3n 2 de la lista (a b c d e f g) . Suponemos que la funci\u00f3n que nos devuelve una posici\u00f3n de la lista ya la tenemos implementada y que la llamada recursiva nos va a devolver el resultado correcto. \u00bfC\u00f3mo podemos simplificar el problema original? Veamos la soluci\u00f3n para este caso concreto: Para devolver el elemento 2 de la lista (a b c d e f g): Obtenemos el resto de la lista (b c d e f g) y devolvemos su elemento 1. Ser\u00e1 el valor c (empezamos a contar por 0). Generalizamos el ejemplo anterior, para cualquier n y cualquier lista: Para devolver el elemento que est\u00e1 en la posici\u00f3n `n` de una lista, devuelvo el elemento n-1 de su resto. Y, por \u00faltimo, formulamos el caso base de la recursi\u00f3n, el problema m\u00e1s sencillo que se puede resolver directamente, sin hacer una llamada recursiva: Para devolver el elemento que est\u00e1 en la posici\u00f3n 0 de una lista, devuelvo el `first` de la lista. La implementaci\u00f3n de todo esto en Scheme ser\u00eda la siguiente: ( define ( mi-list-ref lista n ) ( if ( = n 0 ) ( first lista ) ( mi-list-ref ( rest lista ) ( - n 1 )))) 4.3.2. Funci\u00f3n mi-list-tail \u00b6 La funci\u00f3n (mi-list-tail lista n) devuelve la lista resultante de quitar n elementos de la cabeza de la lista original: ( mi-list-tail ' ( 1 2 3 4 5 6 7 ) 2 ) ; \u21d2 (3 4 5 6 7) Piensa en c\u00f3mo se implementar\u00eda de forma recursiva. Esta vez vamos a mostrar directamente la implementaci\u00f3n, sin dar explicaciones de c\u00f3mo se ha llegado a ella: ( define ( mi-list-tail lista n ) ( if ( = n 0 ) lista ( mi-list-tail ( rest lista ) ( - n 1 )))) 4.3.3. Funci\u00f3n mi-append \u00b6 Veamos ahora c\u00f3mo podr\u00edamos implementar de forma recursiva la funci\u00f3n append que une dos listas. La llamaremos (mi-append lista1 lista2) . Por ejemplo: ( mi-append ' ( a b c ) ' ( d e f )) ; \u21d2 (a b c d e f) Para resolver el problema de forma recursiva, debemos confiar en la recursi\u00f3n para que resuelva un problema m\u00e1s sencillo y despu\u00e9s terminar de arreglar el resultado devuelto por la recursi\u00f3n. En este caso, podemos pasarle a la recursi\u00f3n un problema m\u00e1s sencillo quitando el primer elemento de la primera lista (con la funci\u00f3n rest ) y llamando a la recursi\u00f3n para que concatene esta lista m\u00e1s peque\u00f1a con la segunda. Confiamos en que la recursi\u00f3n funciona correctamente y nos devuelve la concatenaci\u00f3n de ambas listas (mi-append (rest '(a b c)) '(d e f)) => (b c d e f) Y a\u00f1adiremos el primer elemento a la lista resultante usando un cons : (mi-append '(a b c) '(d e f)) = (cons 'a (mi-append '(b c)) '(d e f)) = (cons 'a '(b c d e f)) = (a b c d e f) En general: ( define ( mi-append lista1 lista2 ) ( cons ( first lista1 ) ( mi-append ( rest lista1 ) lista2 ))) El caso base, el caso en el que la funci\u00f3n puede devolver un valor directamente sin llamar a la recursi\u00f3n, es aquel en el que lista1 es null? . En ese caso devolvemos lista2 : (mi-append '() '(a b c)) => '(a b c) La formulaci\u00f3n recursiva completa queda como sigue: ( define ( mi-append l1 l2 ) ( if ( null? l1 ) l2 ( cons ( first l1 ) ( mi-append ( rest l1 ) l2 )))) 4.3.4. Funci\u00f3n mi-reverse \u00b6 Veamos c\u00f3mo implementar de forma recursiva la funci\u00f3n mi-reverse que invierte una lista ( mi-reverse ' ( 1 2 3 4 5 6 )) ; \u21d2 (6 5 4 3 2 1) La idea es sencilla: llamamos a la recursi\u00f3n para hacer la inversa del rest de la lista y a\u00f1adimos el primer elemento a la lista resultante que devuelve ya invertida la llamada recursiva. Podemos definir una funci\u00f3n auxiliar (a\u00f1ade-al-final dato lista) que a\u00f1ade un dato al final de una lista usando append : Veamos directamente su implementaci\u00f3n, usando mi-append para a\u00f1adir un elemento al final de la lista: ( define ( a\u00f1ade-al-final dato lista ) ( append lista ( list dato ))) La funci\u00f3n mi-reverse quedar\u00eda entonces como sigue: ( define ( mi-reverse lista ) ( if ( null? lista ) ' () ( a\u00f1ade-al-final ( first lista ) ( mi-reverse ( rest lista ))))) 4.3.5. Funci\u00f3n cuadrados-hasta \u00b6 La funci\u00f3n (cuadrados-hasta x) devuelve una lista con los cuadrados de los n\u00fameros hasta x : Para construir una lista de los cuadrados hasta x: construyo la lista de los cuadrados hasta x-1 y le a\u00f1ado el cuadrado de x El caso base de la recursi\u00f3n es el caso en el que x es 1, entonces devolvemos una lista formada por el 1. En Scheme: ( define ( cuadrados-hasta x ) ( if ( = x 1 ) ' ( 1 ) ( cons ( cuadrado x ) ( cuadrados-hasta ( - x 1 ))))) Ejemplo: ( cuadrados-hasta 10 ) ; \u21d2 (100 81 64 49 36 25 16 9 4 1) 4.3.6. Funci\u00f3n filtra-pares \u00b6 Es muy habitual recorrer una lista y comprobar condiciones de sus elementos, construyendo una lista con los que cumplan una determinada condici\u00f3n. Por ejemplo, la siguiente funci\u00f3n filtra-pares construye una lista con los n\u00fameros pares de la lista que le pasamos como par\u00e1metro: ( define ( filtra-pares lista ) ( cond (( null? lista ) ' ()) (( even? ( first lista )) ( cons ( first lista ) ( filtra-pares ( rest lista )))) ( else ( filtra-pares ( rest lista ))))) En el caso general, llamamos de forma recursiva a la funci\u00f3n para que filtre el rest de la lista. Y le a\u00f1adimos el primer elemento si es par. Cada vez llamaremos a la recursi\u00f3n con una lista m\u00e1s peque\u00f1a, por lo que en el caso base tendremos que comprobar si la lista que recibimos. En ese caso devolvemos la lista vac\u00eda. Ejemplo: ( filtra-pares ' ( 1 2 3 4 5 6 )) ; \u21d2 (2 4 6) 4.3.7. Funci\u00f3n primo? \u00b6 El uso de listas es uno de los elementos fundamentales de la programaci\u00f3n funcional. Como ejemplo, vamos a ver c\u00f3mo trabajar con listas para construir una funci\u00f3n que calcula si un n\u00famero es primo. La forma de hacerlo ser\u00e1 calcular la lista de divisores del n\u00famero y comprobar si su longitud es dos. En ese caso ser\u00e1 primo. Por ejemplo: ( divisores 8 ) ; \u21d2 (1 2 4 8) longitud = 4, no primo ( divisores 9 ) ; \u21d2 (1 3 9) longitud = 3, no primo ( divisores 11 ) ; \u21d2 (1 11) longitud = 2, primo Podemos definir entonces la funci\u00f3n (primo? x) de la siguiente forma: ( define ( primo? x ) ( = 2 ( length ( divisores x )))) \u00bfC\u00f3mo implementamos la funci\u00f3n (divisores x) que nos devuelve la lista de los divisores de un n\u00famero x . Vamos a construirla de la siguiente forma: Creamos una lista de todos los n\u00fameros del 1 a x Filtramos la lista para dejar los divisores de x La funci\u00f3n (lista-desde x) devuelve una lista de n\u00fameros x..1: ( define ( lista-desde x ) ( if ( = x 0 ) ' () ( cons x ( lista-desde ( - x 1 ))))) Ejemplos: ( lista-desde 2 ) ; \u21d2 (2 1) ( lista-desde 10 ) ; \u21d2 (10 9 8 7 6 5 4 3 2 1) Definimos la funci\u00f3n (divisor? x y) que nos diga si x es divisor de y: ( define ( divisor? x y ) ( = 0 ( mod y x ))) Ejemplos: ( divisor 2 10 ) ; \u21d2 #t ( divisor 3 10 ) ; \u21d2 #f Una vez que hemos definido La funci\u00f3n divisor? podemos utilizarla para definir la funci\u00f3n recursiva (filtra-divisores lista x) que devuelve una lista con los n\u00fameros de lista que son divisores de x : ( define ( filtra-divisores lista x ) ( cond (( null? lista ) ' ()) (( divisor? ( first lista ) x ) ( cons ( first lista ) ( filtra-divisores ( rest lista ) x ))) ( else ( filtra-divisores ( rest lista ) x )))) Ya podemos implementar la funci\u00f3n que devuelve los divisores de un n\u00famero x generando los n\u00fameros hasta x y filtrando los divisores de ese n\u00famero. Por ejemplo, para calcular los divisores de 10: ( filtra-divisores ( 1 2 3 4 5 6 7 8 9 10 ) 10 ) ; \u21d2 (1 2 5 10) Se puede implementar de una forma muy sencilla: ( define ( divisores x ) ( filtra-divisores ( lista-disde x ) x )) Y una vez definida esta funci\u00f3n, ya puede funcionar correctamente la funci\u00f3n primo? . 4.4. Funciones con n\u00famero variable de argumentos \u00b6 Hemos visto algunas funciones primitivas de Scheme, como + o max que admiten un n\u00famero variable de argumentos. \u00bfPodemos hacerlo tambi\u00e9n en funciones definidas por nosotros? La respuesta es s\u00ed, utilizando lo que se denomina notaci\u00f3n dotted-tail (punto-cola) para definir los par\u00e1metros de la funci\u00f3n. En esta notaci\u00f3n se coloca un punto antes del \u00faltimo par\u00e1metro. Los par\u00e1metros antes del punto (si existen) tendr\u00e1n como valores los argumentos usados en la llamada y el resto de argumentos se pasar\u00e1n en forma de lista en el \u00faltimo par\u00e1metro. Por ejemplo, si tenemos la definici\u00f3n ( define ( funcion-dos-o-mas-args x y . lista-args ) <cuerpo> ) podemos llamar a la funci\u00f3n anterior con dos o m\u00e1s argumentos: ( funcion-dos-o-mas-args 1 2 3 4 5 6 ) En la llamada, los par\u00e1metros x e y tomar\u00e1n los valores 1 y 2. El par\u00e1metro lista-args tomar\u00e1 como valor una lista con los argumentos restantes (3 4 5 6) . Tambi\u00e9n es posible permitir que todos los argumentos sean opcionales no poniendo ning\u00fan argumento antes del punto:: ( define ( funcion-cualquier-numero-args . lista-args ) <cuerpo> ) Si hacemos la llamada ( funcion-cualquier-numero-args 1 2 3 4 5 6 ) el par\u00e1metro lista-args tomar\u00e1 como valor la lista (1 2 3 4 5 6) . Veamos un sencillo ejemplo. Podemos implementar una funci\u00f3n mi-suma que tome al menos dos argumentos y despu\u00e9s un n\u00famero variable de argumentos y devuelva la suma de todos ellos. Es muy sencillo: recogemos todos los argumentos en la lista de argumentos variables y llamamos a la funci\u00f3n suma-lista que suma una lista de n\u00fameros: ( define ( mi-suma x y . lista-nums ) ( if ( null? lista-nums ) ( + x y ) ( + x ( + y ( suma-lista lista-nums ))))) 5. Funciones como tipos de datos de primera clase \u00b6 Hemos visto que la caracter\u00edstica fundamental de la programaci\u00f3n funcional es la definici\u00f3n de funciones. Hemos visto tambi\u00e9n que no producen efectos laterales y no tienen estado. Una funci\u00f3n toma unos datos como entrada y produce un resultado como salida. Una de las caracter\u00edsticas fundamentales de la programaci\u00f3n funcional es considerar a las funciones como objetos de primera clase . Recordemos que un tipo de primera clase es aquel que: Puede ser asignado a una variable Puede ser pasado como argumento a una funci\u00f3n Puede ser devuelto como resultado de una invocaci\u00f3n a una funci\u00f3n Puede ser parte de un tipo mayor Vamos a ver que las funciones son ejemplos de todos los casos anteriores: vamos a poder crear funciones sin nombre y asignarlas a variables, pasarlas como par\u00e1metro de otras funciones, devolverlas como resultado de invocar a otra funci\u00f3n y guardarlas en tipos de datos compuestos como listas. La posibilidad de usar funciones como objetos de primera clase es una caracter\u00edstica fundamental de los lenguajes funcionales. Es una caracter\u00edstica de muchos lenguajes multi-paradigma con caracter\u00edsticas funcionales como JavaScript , Python , Swift o a partir de la versi\u00f3n 8 de Java, Java 8 , (donde se denominan expresiones lambda ). 5.1. Forma especial lambda \u00b6 Vamos a empezar explicando la forma especial lambda de Scheme, que nos permite crear funciones an\u00f3nimas en tiempo de ejecuci\u00f3n. De la misma forma que podemos usar cadenas o enteros sin darles un nombre, en Scheme es posible usar una funci\u00f3n sin darle un nombre mediante esta forma especial. 5.1.1. Sintaxis de la forma especial lambda \u00b6 La sintaxis de la forma especial lambda es: (lambda (<arg1> ... <argn>) <cuerpo>) El cuerpo del lambda define un bloque de c\u00f3digo y sus argumentos son los par\u00e1metros necesarios para ejecutar ese bloque de c\u00f3digo. Llamamos a la funci\u00f3n resultante una funci\u00f3n an\u00f3nima . Algunos ejemplos: Una funci\u00f3n an\u00f3nima que suma dos parejas: ( lambda ( p1 p2 ) ( cons ( + ( car p1 ) ( car p2 )) ( + ( cdr p1 ) ( cdr p2 )))) Una funci\u00f3n an\u00f3nima que devuelve el mayor de dos n\u00fameros: ( lambda ( a b ) ( if ( > a b ) a b )) 5.1.2. Sem\u00e1ntica de la forma especial lambda \u00b6 La invocaci\u00f3n a la forma especial lambda construye una funci\u00f3n an\u00f3nima en tiempo de ejecuci\u00f3n. Por ejemplo, si ejecutamos una expresi\u00f3n lambda en el int\u00e9rprete veremos que devuelve un procedimiento: ( lambda ( x ) ( * x x )) ; \u21d2 #<procedure> El procedimiento construido es un bloque de c\u00f3digo que devuelve el cuadrado de un n\u00famero. \u00bfQu\u00e9 podemos hacer con este procedimiento? Podemos asignarlo a un identificador. Por ejemplo, en la siguiente expresi\u00f3n, primero se eval\u00faa la expresi\u00f3n lambda y el procedimiento resultante se asocia al identificador f . ( define f ( lambda ( x ) ( * x x ))) El ejemplo anterior funciona de una forma id\u00e9ntica al siguiente: ( define x ( + 2 3 )) En ambos casos se eval\u00faa la expresi\u00f3n derecha y el resultado se guarda en un identificador. En el primer caso la expresi\u00f3n que se eval\u00faa devuelve un procedimiento, que se guarda en la variable f y en el segundo un n\u00famero, que se guarda en la variable x . Si escribimos los identificadores f y x en el int\u00e9rprete Scheme los eval\u00faa y muestra los valores guardados: f ; \u21d2 #<procedure:f> x ; \u21d2 5 En el primer caso se devuelve un procedimiento y en el segundo un n\u00famero. F\u00edjate que Scheme trata a los procedimientos y a los n\u00fameros de la misma forma; son lo que se denominan datos de primera clase. Una vez asignado un procedimiento a un identificador, lo podemos utilizar como de la misma forma que invocamos habitualmente a una funci\u00f3n: ( f 3 ) ; \u21d2 9 No es necesario un identificador para invocar a una funci\u00f3n; podemos crear la funci\u00f3n con una expresi\u00f3n lambda e invocar a la funci\u00f3n an\u00f3nima reci\u00e9n creada: (( lambda ( x ) ( * x x )) 3 ) ; \u21d2 9 La llamada a lambda crea un procedimiento y el par\u00e9ntesis a su izquierda lo invoca con el par\u00e1metro 3: (( lambda ( x ) ( * x x )) 3 ) ; \u21d2 (#<procedure> 3) \u21d2 9 Es importante remarcar que con lambda estamos creando una funci\u00f3n en tiempo de ejecuci\u00f3n . Es c\u00f3digo que creamos para su posterior invocaci\u00f3n. Cada lenguaje de programaci\u00f3n tiene su sintaxis propia de expresiones lambda. Por ejemplo, las siguientes expresiones crean una funci\u00f3n que devuelve el cuadrado de un n\u00famero: Java 8 Integer x -> { x * x } Scala ( x : Int ) => { x * x } Objective C ^ int ( int x ) { x * x }; Swift { ( x : Int ) -> Int in return x * x } 5.1.3. Identificadores y funciones \u00b6 Tras conocer lambda ya podemos explicarnos por qu\u00e9 cuando escribimos en el int\u00e9rprete de Scheme el nombre de cualquier funci\u00f3n, se eval\u00faa a un procedure : + ; \u21d2 <procedure:+> append ; \u21d2 #<procedure:append> El identificador se eval\u00faa y devuelve el objeto funci\u00f3n al que est\u00e1 ligado. En Scheme los nombres de las funciones son realmente s\u00edmbolos a los que est\u00e1n ligados objetos de tipo funci\u00f3n . Podemos comprobar tambi\u00e9n de esta manera que and y or no son funciones. Si escribimos and o or e intentamos evaluar cualquiera de los dos s\u00edmbolos, veremos que Scheme devuelve un error: and ; and: bad syntax in: and or ; or: bad syntax in: or Podemos asignar funciones ya existentes a nuevos identificadores usando define , como en el ejemplo siguiente: + ; \u21d2 <procedure:+> ( define suma + ) ( suma 1 2 3 4 ) ; \u21d2 10 Es muy importante darse cuenta que la expresi\u00f3n (define suma +) se eval\u00faa de forma id\u00e9ntica a (define y x) . Primero se eval\u00faa el identificador + , que devuelve el objeto funci\u00f3n suma, que se asigna a la variable suma . El resultado final es que tanto + como suma tienen como valor el mismo procedimiento: La forma especial define para definir una funci\u00f3n no es m\u00e1s que azucar sint\u00e1ctico . (define (<nombre> <args>) <cuerpo>) siempre se convierte internamente en: (define <nombre> (lambda (<args>) <cuerpo>)) Por ejemplo ( define ( cuadrado x ) ( * x x )) es equivalente a: ( define cuadrado ( lambda ( x ) ( * x x ))) 5.1.4. Predicado procedure? \u00b6 Podemos comprobar si algo es una funci\u00f3n utilizando el predicado de Scheme procedure? . Por ejemplo: ( procedure? ( lambda ( x ) ( * x x ))) ; \u21d2 #t ( define suma + ) ( procedure? suma ) ; \u21d2 #t ( procedure? ' + ) ; \u21d2 #f Hemos visto que las funciones pueden asignarse a variables. Tambi\u00e9n cumplen las otras condiciones necesarias para ser consideradas objetos de primera clase. 5.2. Funciones argumentos de otras funciones \u00b6 Hemos visto ya un ejemplo de c\u00f3mo pasar una funci\u00f3n como par\u00e1metro de otra. Veamos alg\u00fan otro. Por ejemplo, podemos definir la funci\u00f3n aplica que recibe una funci\u00f3n en el par\u00e1metro func y dos valores en los par\u00e1metros x e y y devuelve el resultado de invocar a la funci\u00f3n que pasamos como par\u00e1metro con x e y . La funci\u00f3n que se pase como par\u00e1metro debe tener dos argumentos Para realizar la invocaci\u00f3n a la funci\u00f3n que se pasa como par\u00e1metro basta con usar func como su nombre. La funci\u00f3n se ha ligado al nombre func en el momento de la invocaci\u00f3n a aplica , de la misma forma que los argumentos se ligan a los par\u00e1metros x e y : ( define ( aplica f x y ) ( f x y )) Algunos ejemplos de invocaci\u00f3n, usando funciones primitivas, funciones definidas y expresiones lambda: ( aplica + 2 3 ) ; \u21d2 5 ( aplica * 4 5 ) ; \u21d2 10 ( aplica string-append \"hola\" \"adios\" ) ; \u21d2 \"holaadios\" ( define ( string-append-con-guion s1 s2 ) ( string-append s1 \"-\" s2 )) ( aplica string-append-con-guion \"hola\" \"adios\" ) ; \u21d2 \"hola-adios\" ( aplica ( lambda ( x y ) ( sqrt ( + ( * x x ) ( * y y )))) 3 4 ) ; \u21d2 5 Otro ejemplo, la funci\u00f3n aplica-2 que toma dos funciones f y g y un argumento x y devuelve el resultado de aplicar f a lo que devuelve la invocaci\u00f3n de g con x : ( define ( aplica-2 f g x ) ( f ( g x ))) ( define ( suma-5 x ) ( + x 5 )) ( define ( doble x ) ( + x x )) ( aplica-2 suma-5 doble 3 ) ; \u21d2 11 5.3. Funci\u00f3n apply \u00b6 La funci\u00f3n (apply funcion lista) de Scheme permite aplicar una funci\u00f3n de aridad n a una lista de datos de n datos, haciendo que cada uno de los datos se pasen a la funci\u00f3n en orden como par\u00e1metros. La funci\u00f3n apply recibe una funci\u00f3n y una lista y devuelve el resultado de aplicar la funci\u00f3n a los datos de la lista, tom\u00e1ndolos como par\u00e1metros. Por ejemplo, podemos aplicar la funci\u00f3n suma a una lista de n\u00fameros: ( apply + ' ( 1 2 3 4 )) ; \u21d2 10 Podemos pasar a apply una expresi\u00f3n lambda: ( apply ( lambda ( x y ) ( + x ( * 2 y ))) ' ( 2 5 )) ; \u21d2 12 La lista que pasamos como argumento de apply debe tener tantos elementos como par\u00e1metros tenga la funci\u00f3n que aplicamos. En caso contrario, se produce un error: ( apply cons ' ( a b c )) ; \u21d2 error cons: arity mismatch ; the expected number of arguments does not match the given number expected: 2 given: 3 arguments...: La forma correcta de hacerlo: ( apply cons ' ( a b )) ; \u21d2 (a . b) 5.3.1. Funci\u00f3n apply y funciones recursivas \u00b6 Usando apply podemos definir funciones recursivas con n\u00famero variable de argumentos. Por ejemplo, supongamos que queremos definir la funci\u00f3n suma-parejas que suma un n\u00famero variable de parejas: ( suma-parejas ' ( 1 . 2 ) ' ( 3 . 4 ) ' ( 5 . 6 )) ; \u21d2 '(9 . 12) Recordemos la definici\u00f3n de la funci\u00f3n que suma dos parejas: ( define ( suma-pareja p1 p2 ) ( cons ( + ( car p1 ) ( car p2 )) ( + ( cdr p1 ) ( cdr p2 )))) Podemos entonces construir la funci\u00f3n suma-parejas que recibe una lista de parejas (n\u00famero variable de argumentos) llamando a apply para que sume todas las parejas del resto de la lista. Y sumar la pareja resultante con la primera pareja de la lista: ( define ( suma-parejas . parejas ) ( if ( null? parejas ) ' ( 0 . 0 ) ( suma-pareja ( first parejas ) ( apply suma-parejas ( rest parejas ))))) Se trata de una llamada recursiva indirecta, porque se invoca a la propia funci\u00f3n suma-parejas no directamente, sino a trav\u00e9s de apply . Hay que hacer notar en que la llamada recursiva es necesario usar apply porque (cdr parejas) es una lista. No podemos invocar a suma-parejas pasando una lista como par\u00e1metro, sino que hay que pasarle todos los argumentos por separado (recibe un n\u00famero variable de argumentos). Eso lo conseguimos hacer con apply . La siguiente imagen muestra una representaci\u00f3n gr\u00e1fica del funcionamiento de la recursi\u00f3n: 5.4. Generalizaci\u00f3n \u00b6 La posibilidad de pasar funciones como par\u00e1metros de otras es una poderosa herramienta de abstracci\u00f3n. Nos va a permitir dise\u00f1ar funciones m\u00e1s gen\u00e9ricas. Veamos un ejemplo. Supongamos que queremos calcular el sumatorio de a hasta b : ( define ( sum-x a b ) ( if ( > a b ) 0 ( + a ( sum-x ( + a 1 ) b )))) ( sum-x 1 10 ) ; \u21d2 55 Supongamos ahora que queremos calcular el sumatorio de a hasta b sumando los n\u00fameros al cuadrado: ( define ( sum-cuadrado-x a b ) ( if ( > a b ) 0 ( + ( * a a ) ( sum-cuadrado-x ( + a 1 ) b )))) ( sum-cuadrado-x 1 10 ) ; \u21d2 385 Y el sumatorio de a hasta b sumando los cubos: ( define ( sum-cubo-x a b ) ( if ( > a b ) 0 ( + ( * a a a ) ( sum-cubo-x ( + a 1 ) b )))) ( sum-cubo-x 1 10 ) ; \u21d2 3025 Vemos que el c\u00f3digo de las tres funciones anteriores es muy similar, cada funci\u00f3n la podemos obtener haciendo un copy-paste de otra previa. Lo \u00fanico que cambia es la funci\u00f3n a aplicar a cada n\u00famero de la serie. Siempre que hagamos copy-paste al programar tenemos que empezar a sospechar que no estamos generalizando suficientemente el c\u00f3digo. Un copy-paste arrastra tambi\u00e9n bugs y obliga a realizar m\u00faltiples modificaciones del c\u00f3digo cuando en el futuro tengamos que cambiar cosas. La posibilidad de pasar una funci\u00f3n como par\u00e1metro viene a nuestra ayuda para generalizar el c\u00f3digo anterior. En este caso, lo \u00fanico que cambia en las tres funciones anteriores es la funci\u00f3n a aplicar a los n\u00fameros de la serie. En primer caso no se hace nada, en el segundo se eleva al cuadrado y en el tercer caso al cubo. Podemos tomar esa funci\u00f3n como un par\u00e1metro adicional y definir una funci\u00f3n gen\u00e9rica sum-f-x que generaliza las tres funciones anteriores. Tendr\u00edamos el sumatorio desde a hasta b de f(x) : ( define ( sum-f-x f a b ) ( if ( > a b ) 0 ( + ( f a ) ( sum-f-x f ( + a 1 ) b )))) Las funciones anteriores son casos particulares de esta funci\u00f3n que las generaliza. Por ejemplo, para calcular el sumatorio desde 1 hasta 10 de x al cubo: ( define ( cubo x ) ( * x x x )) ( sum-f-x cubo 1 10 ) ; \u21d2 3025 Tambi\u00e9n podemos utilizar una expresi\u00f3n lambda en la invocaci\u00f3n a sum-f que construya la funci\u00f3n que queremos aplicar a cada n\u00famero. Por ejemplo, podemos sumar la expresi\u00f3n (n/(n-1)) para todos los n\u00fameros del 2 al 100: ( sum-f-x ( lambda ( n ) ( / n ( - n 1 ))) 2 100 ) Veremos m\u00e1s adelante muchos m\u00e1s ejemplos de funciones pasadas como par\u00e1metros y de la generalidad que permite este patr\u00f3n, cuando estudiemos las funciones de orden superior. 5.5. Funciones que devuelven funciones \u00b6 Cualquier objeto de primera clase puede ser devuelto por una funci\u00f3n; enteros, booleanos, parejas, etc. son objetos primitivos y podemos definir funciones que los devuelven. En el paradigma funcional lo mismo sucede con las funciones. Podemos definir una funci\u00f3n que cuando se invoque construya otra funci\u00f3n y la devuelva como resultado. Esta es una de la caracter\u00edsticas m\u00e1s importantes que diferencia los lenguajes de programaci\u00f3n funcionales de otros que no lo son. En lenguajes como C, C++ o Java (antes de Java 8) no es posible hacer esto. Para devolver una funci\u00f3n en Scheme debemos usar la forma especial lambda en el cuerpo de una funci\u00f3n. As\u00ed, cuando se invoca a esta funci\u00f3n se eval\u00faa lambda y se devuelve la funci\u00f3n resultante. Es una funci\u00f3n que creamos en tiempo de ejecuci\u00f3n, durante la evaluaci\u00f3n de la funci\u00f3n principal. La funci\u00f3n que se devuelve se denomina clausura ( Wikipedia ). Y decimos que la funci\u00f3n que ha construido la clausura es una funci\u00f3n constructora . 5.5.1. Funci\u00f3n sumador \u00b6 Vamos a empezar con un ejemplo muy sencillo. Definimos una funci\u00f3n constructora que crea en su ejecuci\u00f3n una funci\u00f3n que suma k a un n\u00famero: ( define ( construye-sumador k ) ( lambda ( x ) ( + x k ))) El cuerpo de la funci\u00f3n (construye-sumador k) est\u00e1 formado por una expresi\u00f3n lambda. Cuando se invoca a construye-sumador se eval\u00faa esta expresi\u00f3n lambda y se devuelve el procedimiento creado. En este caso se construye otra funci\u00f3n de 1 argumento que suma k al argumento. Por ejemplo, podemos invocar a construye-sumador pasando 10 como par\u00e1metro: ( construye-sumador 10 ) ; \u21d2 #<procedure> Como hemos dicho, se devuelve un procedimiento, una funci\u00f3n. Esta funci\u00f3n devuelta debe invocarse con un argumento y devolver\u00e1 el resultado de sumar 10 a ese argumento: ( define f ( construye-sumador 10 )) ( f 3 ) ; \u21d2 13 Tambi\u00e9n podemos invocar directamente a la funci\u00f3n que devuelve la funci\u00f3n constructora, sin guardarla en una variable: (( construye-sumador 10 ) 3 ) ; \u21d2 13 Dependiendo del par\u00e1metro que le pasemos a la funci\u00f3n constructora obtendremos una funci\u00f3n sumadora que sume un n\u00famero u otro. Por ejemplo para obtener una funci\u00f3n sumadora que suma 100: ( define g ( construye-sumador 100 )) ( g 3 ) ; \u21d2 103 \u00bfC\u00f3mo funciona la clausura? \u00bfPor qu\u00e9 la invocaci\u00f3n a (g 3) devuelve 103?. Aqu\u00ed hay que apartarse bastante del modelo de evaluaci\u00f3n de sustituci\u00f3n que hemos visto y utilizar un nuevo modelo en el que se tiene en cuenta los \u00e1mbitos de las variables. No vamos a explicar en detalle este modelo, pero s\u00ed dar unas breves pinceladas. Recordemos la definici\u00f3n de construye-sumador : ( define ( construye-sumador k ) ( lambda ( x ) ( + x k ))) Y supongamos que realizamos las siguientes invocaciones: ( define g ( construye-sumador 100 )) ( g 3 ) ; \u21d2 103 ( define f ( construye-sumador 50 )) ( f 3 ) ; \u21d2 53 Podemos explicar lo que sucede en la evaluaci\u00f3n de estas funciones de la siguiente forma: Cuando invocamos a construye-sumador con un valor concreto para k (por ejemplo 100), queda vinculado el valor de 100 al par\u00e1metro k en el \u00e1mbito local de la funci\u00f3n. En este \u00e1mbito local la expresi\u00f3n lambda crea una funci\u00f3n. Esta funci\u00f3n creada en el \u00e1mbito local captura este \u00e1mbito local, con sus variables y sus valores (en este caso la variable k y su valor 100). Cuando se invoca a la funci\u00f3n desde fuera (cuando llamamos a g en el ejemplo) se ejecuta el cuerpo de la funci\u00f3n (+ x k) con x valiendo el par\u00e1metro (3) y el valor de k se obtiene del \u00e1mbito capturado (100). En el caso de la segunda invocaci\u00f3n a construye-sumador el valor del par\u00e1metro es 50 y se crea otro \u00e1mbito local en el que k vale 50. Ese valor es el capturado por la nueva clausura que crea la expresi\u00f3n lambda, que es devuelta por la funci\u00f3n y guardada en la variable f . La siguiente imagen muestra gr\u00e1ficamente la explicaci\u00f3n anterior. Se ve a la izquierda la ejecuci\u00f3n del c\u00f3digo y a la derecha el efecto que esta ejecuci\u00f3n tiene en la memoria, incluyendo los valores asociados a las variables y los \u00e1mbitos locales creados en las distintas invocaciones a las funciones. El hecho de que funci\u00f3n creada en el \u00e1mbito local capture este \u00e1mbito es lo que hace que se denomine una clausura (del ingl\u00e9s closure ). La funci\u00f3n se cierra sobre el \u00e1mbito capturado y puede utilizar sus variables. 5.5.2. Funci\u00f3n composicion \u00b6 Otro ejemplo de una funci\u00f3n que devuelve otra funci\u00f3n es la funci\u00f3n siguiente (composicion f g) que recibe dos funciones de un argumento y devuelve otra funci\u00f3n que realiza la composici\u00f3n de ambas: ( define ( composicion f g ) ( lambda ( x ) ( f ( g x )))) La funci\u00f3n devuelta invoca primero a g y el resultado se lo pasa a f . Veamos un ejemplo. Supongamos que tenemos definidas la funci\u00f3n cuadrado y doble que calculan el cuadrado y el doble de un n\u00famero respectivamente. Podremos entonces llamar a composicion con esas dos funciones para construir otra funci\u00f3n que primero calcule el cuadrado y despu\u00e9s el doble de una n\u00famero: ( define h ( composicion doble cuadrado )) La variable h contiene la funci\u00f3n devuelta por composicion . Una funci\u00f3n de un argumento que devuelve el doble del cuadrado de un n\u00famero: ( h 4 ) ; \u21d2 32 5.5.3. Funci\u00f3n construye-segura \u00b6 Vamos a ver un \u00faltimo ejemplo en el que definimos una funci\u00f3n constructora que extiende funciones ya existentes. Recordemos la funci\u00f3n lista-desde : ( define ( lista-desde x ) ( if ( = x 0 ) ' () ( cons x ( lista-desde ( - x 1 ))))) Un problema de la funci\u00f3n anterior es que si le pasamos un n\u00famero negativo entra en un bucle infinito. Definimos la funci\u00f3n (construye-segura condicion f) que recibe dos funciones: un predicado y otra funci\u00f3n, ambos de 1 argumento. Devuelve otra funci\u00f3n en la que s\u00f3lo se llamar\u00e1 a f si el argumento cumple la condicion . ( define ( construye-segura condicion f ) ( lambda ( x ) ( if ( condicion x ) ( f x ) ' error ))) La funci\u00f3n construye una funci\u00f3n an\u00f3nima de un argumento x (igual que f ) en cuyo cuerpo se comprueba si el argumento cumple la condici\u00f3n y s\u00f3lo en ese caso se llama a f . Podemos entonces construir una funci\u00f3n segura a partir de la funci\u00f3n lista-desde en la que se devuelva error si el argumento es un n\u00famero negativo: ( define lista-desde-segura ( construye-segura ( lambda ( x ) ( >= x 0 )) lista-desde )) ( lista-desde-segura 8 ) ; \u21d2 (8 7 6 5 4 3 2 1) ( lista-desde-segura -1 ) ; \u21d2 error Podr\u00edamos usar construye-segura con cualquier funci\u00f3n de 1 argumento que queramos hacer segura. Por ejemplo, la funci\u00f3n sqrt : ( define sqrt-segura ( construye-segura ( lambda ( x ) ( >= x 0 ) sqrt )) ( sqrt-segura 100 ) ; \u21d2 10 ( sqrt-segura -100 ) ; \u21d2 error La potencia de las funciones constructoras viene del hecho de que es posible crear nuevas funciones en tiempo de ejecuci\u00f3n. No es necesario conocer las condiciones y las caracter\u00edsticas de estas nuevas funciones a priori, cuando estamos compilando nuestro programa. Sino que pueden depender de datos obtenidos del usuario o de otros m\u00f3dulos del programa en tiempo de ejecuci\u00f3n. Por ejemplo, la condici\u00f3n de construye-segura podr\u00eda contener valores obtenidos en tiempo de ejecuci\u00f3n, de forma que solo se llamara a la funci\u00f3n que queremos hacer segura si el n\u00famero est\u00e1 en un rango definido esos valores: ( construye-segura ( lambda ( x ) ( and ( >= x limite-inf ) ( <= x limite-sup ))) f ) ) 5.6. Funciones en estructuras de datos \u00b6 La \u00faltima caracter\u00edstica de los tipos de primera clase es que pueden formar parte de tipos de datos compuestos, como listas. Para construir una lista de funciones debemos llamar a list con las funciones: ( define ( cuadrado x ) ( * x x )) ( define ( suma-1 x ) ( + x 1 )) ( define ( doble x ) ( * x 2 )) ( define lista ( list cuadrado suma-1 doble )) lista ; \u21d2 (#<procedure:cuadrado> #<procedure:suma-1> #<procedure:doble>) Tambi\u00e9n podemos definir las funciones con expresiones lambda. Por ejemplo, podemos a\u00f1adir a la lista una funci\u00f3n que suma 5 a un n\u00famero: ( define lista2 ( cons ( lambda ( x ) ( + x 5 )) lista )) lista2 ; \u21d2 (#<procedure> #<procedure:cuadrado> #<procedure:suma-1> #<procedure:doble>) Una vez creada una lista con funciones, \u00bfc\u00f3mo podemos invocar a alguna de ellas?. Debemos tratarlas de la misma forma que tratamos cualquier otro dato guardado en la lista, las recuperamos con las funciones first o list-ref y las invocamos. Por ejemplo, para invocar a la primera funci\u00f3n de lista2 : (( first lista2 ) 10 ) ; \u21d2 15 O a la tercera: (( list-ref lista2 2 ) 10 ) ; \u21d2 11 5.6.1. Funciones que trabajan con listas de funciones \u00b6 Veamos un ejemplo de una funci\u00f3n (aplica-funcs lista-funcs x) que recibe una lista de funciones en el par\u00e1metro lista-funcs y las aplica todas de derecha a izquierda al n\u00famero que pasamos en el par\u00e1metro x . Por ejemplo, supongamos la lista anterior, que contiene las funciones cuadrado , cubo y suma-1 : ( define lista ( list cuadrado cubo suma-1 )) la llamada a (aplica-funcs lista 5) deber\u00eda devolver el resultado de aplicar primero suma-1 a 5, despu\u00e9s cubo al resultado y despu\u00e9s cuadrado : ( cuadrado ( cubo ( suma-1 5 )) ; \u21d2 46656 Para implementar aplica-funcs tenemos que usar una recursi\u00f3n. Si vemos el ejemplo, podemos comprobar que es sencillo definir el caso general: (aplica-funcs (cuadrado cubo suma-1) 5) = (cuadrado (aplica-funcs (cubo suma-1) 5)) = (cuadrado 216) = 46656 El caso general de la recursi\u00f3n de la funci\u00f3n aplica-funcs se define entonces como: ( define ( aplica-funcs lista-funcs x ) ; falta el caso base (( first lista-funcs ) ( aplica-funcs ( rest lista-funcs ) x ))) El caso base ser\u00eda en el que la lista de funciones es vac\u00eda, en cuyo caso se devuelve el propio n\u00famero: ( if ( null? lista-funcs ) ; la lista de funciones est\u00e1 vac\u00eda x ; devolvemos el propio n\u00famero ... La implementaci\u00f3n completa es: ( define ( aplica-funcs lista-funcs x ) ( if ( null? lista-funcs ) x (( first lista-funcs ) ( aplica-funcs ( rest lista-funcs ) x )))) Un ejemplo de uso: ( define lista-funcs ( list ( lambda ( x ) ( * x x )) ( lambda ( x ) ( * x x x )) ( lambda ( x ) ( + x 1 )))) ( aplica-funcs lista-funcs 5 ) ; \u21d2 46656 5.7. Funciones de orden superior \u00b6 Llamamos funciones de orden superior ( higher order functions en ingl\u00e9s) a las funciones que toman otras como par\u00e1metro o devuelven otra funci\u00f3n. Permiten generalizar soluciones con un alto grado de abstracci\u00f3n. Ya hemos visto algunas funciones de orden superior, unas construidas por nostros y otras propias de Scheme, como apply . Adem\u00e1s de apply , los lenguajes de programaci\u00f3n funcional como Scheme, Scala o Java 8 tienen ya predefinidas algunas otras funciones de orden superior que trabajan con listas. Estas funciones permiten definir operaciones sobre las listas de una forma muy concisa y compacta. Son muy usadas, porque tambi\u00e9n se pueden utilizar sobre streams de datos obtenidos en operaciones de entrada/salida (por ejemplo, datos JSON resultantes de una petici\u00f3n HTTP). Vamos a ver las funciones m\u00e1s importantes, su uso y su implementaci\u00f3n. map filter exists? for-all? foldr y foldl Despu\u00e9s de explicar estas funciones terminaremos con un ejemplo de su aplicaci\u00f3n en el que comprobaremos c\u00f3mo la utilizaci\u00f3n de funciones de orden superior es una excelente herramienta de la programaci\u00f3n funcional que permite hacer c\u00f3digo muy conciso y expresivo. La combinaci\u00f3n de funciones de nivel superior con listas es una de las caracter\u00edsticas m\u00e1s potentes de la programaci\u00f3n funcional. 5.7.1. Funci\u00f3n map \u00b6 Comenzamos con la funci\u00f3n map . La palabra map viene del ingl\u00e9s mapping o transformaci\u00f3n. Se trata de una funci\u00f3n que transforma una lista aplicando a todos sus elementos una funci\u00f3n de transformaci\u00f3n que se pasa como par\u00e1metro. En concreto, la funci\u00f3n recibe otra funci\u00f3n y una lista: (map transforma lista) -> lista Y devuelve la lista resultante de aplicar la funci\u00f3n a todos los elementos de la lista. La funci\u00f3n de transformaci\u00f3n recibe como argumentos elementos de la lista y devuelve el resultado de transformar ese elemento. (transforma elemento) -> elemento Por ejemplo: ( map cuadrado ' ( 1 2 3 4 5 )) ; \u21d2 (1 4 9 16 25) La lista resultante es el resultado de construir una lista nueva aplicando la funci\u00f3n cuadrado a todos los elementos de la lista original. La funci\u00f3n de transformaci\u00f3n debe ser compatible con los elementos de la lista original. Por ejemplo, si la lista es una lista de parejas, la funci\u00f3n de transformaci\u00f3n debe recibir una pareja. Veamos un ejemplo de este caso, en el que a partir de una lista de parejas obtenemos una lista con las sumas de cada pareja: ( define ( suma-pareja pareja ) ( + ( car pareja ) ( cdr pareja ))) ( map suma-pareja ' (( 2 . 4 ) ( 3 . 6 ) ( 5 . 3 ))) ; \u21d2 (6 9 8) Tambi\u00e9n podr\u00edamos hacerlo con una expresi\u00f3n lambda: ( map ( lambda ( pareja ) ( + ( car pareja ) ( cdr pareja ))) ' (( 2 . 4 ) ( 3 . 6 ) ( 5 . 3 ))) ; \u21d2 (6 9 8) Un \u00faltimo ejemplo, en el que usamos map para transformar una lista de s\u00edmbolos en una lista con sus longitudes: ( map ( lambda ( s ) ( string-length ( symbol->string s ))) ' ( Esta es una lista de s\u00edmbolos )) ; \u21d2 (4 2 3 5 2 8) 5.7.1.1. Implementaci\u00f3n de map \u00b6 \u00bfC\u00f3mo se podr\u00eda implementar map de forma recursiva? Definimos la funci\u00f3n mi-map . La implementaci\u00f3n es la siguiente: ( define ( mi-map f lista ) ( if ( null? lista ) ' () ( cons ( f ( first lista )) ( mi-map f ( rest lista ))))) 5.7.1.2. Funci\u00f3n map con m\u00e1s de una lista \u00b6 La funci\u00f3n map puede recibir un n\u00famero variable de listas, todas ellas de la misma longitud: (map transforma lista_1 ... lista_n) -> lista En este caso la funci\u00f3n de transforma debe recibir tantos argumentos como listas recibe map : (transforma dato_1 ... dato_n) -> dato La funci\u00f3n map aplica transforma a los elementos cogidos de las n listas y construye as\u00ed la lista resultante. Ejemplos: ( map + ' ( 1 2 3 ) ' ( 10 20 30 )) ; \u21d2 (11 22 33) ( map cons ' ( 1 2 3 ) ' ( 10 20 30 )) ; \u21d2 ((1 . 10) (2 . 20) (3 . 30)) ( map > ' ( 12 3 40 ) ' ( 20 0 10 )) ; \u21d2 (#f #t #t) ( define ( mayor a b ) ( if ( > a b ) a b )) ( define ( mayor-de-tres a b c ) ( mayor a ( mayor b c ))) ( map mayor-de-tres ' ( 10 2 20 -1 34 ) ' ( 2 3 12 89 0 ) ' ( 100 -10 23 45 8 )) ; \u21d2 (100 3 23 89 34) Consejo La funci\u00f3n map recibe una lista de n elementos y devuelve otra de n elementos transformados. 5.7.2. Funci\u00f3n filter \u00b6 Veamos otra funci\u00f3n de orden superior que trabaja sobre listas. La funci\u00f3n (filter predicado lista) toma como par\u00e1metro un predicado y una lista y devuelve como resultado los elementos de la lista que cumplen el predicado. (filter predicado lista) -> lista La funci\u00f3n (predicado elem) que usa filter recibe elementos de la lista y devuelve #t o #f . (predicado elem) -> boolean Un ejemplo de uso: ( filter even? ' ( 1 2 3 4 5 6 7 8 )) ; \u21d2 (2 4 6 8) Otro ejemplo: supongamos que queremos filtrar una lista de parejas de n\u00fameros, devolviendo aquellas que parejas que cumplen que su parte izquierda es mayor o igual que la derecha. Lo podr\u00edamos hacer con la siguiente expresi\u00f3n: ( filter ( lambda ( pareja ) ( >= ( car pareja ) ( cdr pareja ))) ' (( 10 . 4 ) ( 2 . 4 ) ( 8 . 8 ) ( 10 . 20 ))) ; \u21d2 ((10 . 4) (8 . 8)) Y un \u00faltimo ejemplo: filtramos todos los s\u00edmbolos con longitud menor de 4. ( filter ( lambda ( s ) ( >= ( string-length ( symbol->string s )) 4 )) ' ( Esta es una lista de s\u00edmbolos )) ; \u21d2 (Esta lista s\u00edmbolos) Consejo La funci\u00f3n filter recibe una lista de n elementos y devuelve otra de con n o menos elementos originales filtrados por una condici\u00f3n. 5.7.2.1. Implementaci\u00f3n de filter \u00b6 Podemos implementar la funci\u00f3n filter de forma recursiva: ( define ( mi-filter pred lista ) ( cond (( null? lista ) ' ()) (( pred ( first lista )) ( cons ( first lista ) ( mi-filter pred ( rest lista )))) ( else ( mi-filter pred ( rest lista ))))) 5.7.3. Funci\u00f3n exists? \u00b6 La funci\u00f3n de orden superior exists? recibe un predicado y una lista y comprueba si alg\u00fan elemento de la lista cumple ese predicado. (exists? predicado lista) -> boolean Igual que en filter el predicado recibe elementos de la lista y devuelve #t o #f . (predicado elem) -> boolean La funci\u00f3n exists? no est\u00e1 definida con este nombre en Racket, aunque s\u00ed en Scheme. En Racket se llama ormap . Incorporamos su definici\u00f3n al fichero lpp.rkt para poder usarla en las pr\u00e1cticas. Ejemplo de uso: ( exits? even? ' ( 1 2 3 4 5 6 )) ; \u21d2 #t ( exits? ( lambda ( x ) ( > x 10 )) ' ( 1 3 5 8 )) ; \u21d2 #f La implementaci\u00f3n recursiva de exists? es la siguiente: ( define ( exists? predicado lista ) ( if ( null? lista ) #f ( or ( predicado ( first lista )) ( exists? predicado ( rest lista ))))) 5.7.4. Funci\u00f3n for-all? \u00b6 La funci\u00f3n de orden superior for-all? recibe un predicado y una lista y comprueba que todos los elementos de la lista cumplen ese predicado. La funci\u00f3n tampoco est\u00e1 definida con este nombre en Racket, aunque s\u00ed en Scheme. Al igual que exits? , incluimos su definici\u00f3n en el fichero lpp.rkt . En Racket existe una funci\u00f3n equivalente que se llama andmap . Ejemplo de uso: ( for-all? even? ' ( 2 4 6 )) ; \u21d2 #t ( for-all? ( lambda ( x ) ( > x 10 )) ' ( 12 30 50 80 )) ; \u21d2 #t La implementaci\u00f3n recursiva de for-all? es la siguiente: ( define ( for-all? predicado lista ) ( or ( null? lista ) ( and ( predicado ( first lista )) ( for-all? predicado ( rest lista ))))) La llamada recursiva comprueba que todos los elementos del resto de la lista cumplen el predicado y tambi\u00e9n lo debe cumplir el primer elemento. Una lista vac\u00eda cumple siempre devuelve #t (al no tener elementos, podemos decir que todos sus elementos cumplen el predicado). 5.7.5. Funci\u00f3n foldr \u00b6 Veamos ahora la funci\u00f3n (foldr combina base lista) que permite recorrer una lista aplicando una funci\u00f3n binaria de forma acumulativa a sus elementos y devolviendo un \u00fanico valor como resultado. (foldr combina base lista) -> valor El nombre fold significa plegado , indicando que la lista a la que se aplica se va \"plegando\" y al final se devuelve un \u00fanico resultado. El plegado lo realiza la funci\u00f3n de plegado (combina dato resultado) , que recibe un dato de la lista y lo acumula con el otro par\u00e1metro resultado (al que debemos dar un valor inicial y es el par\u00e1metro base de la funci\u00f3n foldr ). (combina dato resultado) -> resultado La funci\u00f3n combina se aplica a los elementos de la lista de derecha a izquierda , empezando por el \u00faltimo elemento de la lista y el valor inicial base y aplic\u00e1ndose sucesivamente a los resultados que se van obteniendo. Veamos un ejemplo. Supongamos que la funci\u00f3n de plegado es una funci\u00f3n que suma el dato que viene de la lista con el valor acumulado: ( define ( suma dato resultado ) ( + dato resultado )) Llamamos a los par\u00e1metros dato y resultado para remarcar que el primer par\u00e1metro se va a coger de la lista y el segundo del resultado calculado. Veamos qu\u00e9 pasa cuando hacemos un foldr con esta funci\u00f3n suma y la lista '(1 2 3) y con el n\u00famero 0 como base: ( foldr suma 0 ' ( 1 2 3 )) ; \u21d2 6 La funci\u00f3n suma se va a ir aplicando a todos los elementos de la lista de derecha a izquierda , empezando por el valor base (0) y el \u00faltimo elemento de la lista (3) y cogiendo el resultado obtenido y utiliz\u00e1ndolo como nuevo par\u00e1metro resultado en la siguiente llamada. En concreto, la secuencia de llamadas a la funci\u00f3n suma ser\u00e1n las siguientes: ( suma 3 0 ) ; \u21d2 3 ( suma 2 3 ) ; \u21d2 5 ( suma 1 5 ) ; \u21d2 6 Otro ejemplo de uso: ( foldr string-append \"****\" ' ( \"hola\" \"que\" \"tal\" )) ; \u21d2 \"holaquetal****\" En este caso la secuencia de llamadas a string-append que se van a producir son: ( string-append \"tal\" \"****\" ) ; \u21d2 \"tal****\" ( string-append \"que\" \"tal****\" ) ; \u21d2 \"quetal****\" ( string-append \"hola\" \"quetal****\" ) ; \u21d2 \"holaquetal****\" Otros ejemplos: ( foldr ( lambda ( x y ) ( * x y )) 1 ' ( 1 2 3 4 5 6 7 8 )) ; \u21d2 40320 ( foldr cons ' () ' ( 1 2 3 4 )) ; \u21d2 (1 2 3 4) Un \u00faltimo ejemplo: ( define ( suma-parejas lista-parejas ) ( foldr ( lambda ( pareja resultado ) ( + ( car pareja ) ( cdr pareja ) resultado )) 0 lista-parejas )) ( suma-parejas ( list ( cons 3 6 ) ( cons 2 9 ) ( cons -1 8 ) ( cons 9 3 ))) ; \u21d2 39 5.7.5.1. Implementaci\u00f3n de foldr \u00b6 Podemos implementar de forma recursiva la funci\u00f3n foldr : ( define ( mi-foldr func base lista ) ( if ( null? lista ) base ( func ( first lista ) ( mi-foldr func base ( rest lista ))))) 5.7.6. Funci\u00f3n foldl \u00b6 La funci\u00f3n (foldl combina base lista) ( fold left ) es similar a foldr con la diferencia de que la secuencia de aplicaciones de la funci\u00f3n de plegado se hace de izquierda a derecha en lugar de derecha a izquierda. El perfil de la funci\u00f3n de plegado es el mismo que en foldr : (func dato resultado) -> resultado Por ejemplo, si la funci\u00f3n de combinaci\u00f3n es string-append : ( foldl string-append \"****\" ' ( \"hola\" \"que\" \"tal\" )) ; \u21d2 \"talquehola****\" La secuencia de llamadas a string-append es: ( string-append \"hola\" \"****\" ) ; \u21d2 \"hola****\" ( string-append \"que\" \"hola****\" ) ; \u21d2 \"quehola****\" ( string-append \"tal\" \"quehola****\" ) ; \u21d2 \"talquehola****\" Otro ejemplo: ( foldl cons ' () ' ( 1 2 3 4 )) ; \u21d2 (4 3 2 1) La implementaci\u00f3n de foldl la veremos cuando hablemos de recursi\u00f3n por la cola ( tail recursion ) en el pr\u00f3ximo tema. Consejo Las funciones foldr o foldl reciben una lista de datos y devuelven un \u00fanico resultado. 5.7.7. Uso de and y or con FOS \u00b6 Hemos visto que las primitivas and y or no son funciones, sino formas especiales. Debido a esto, no podemos usarlas como funciones que se pasan a otra funci\u00f3n de orden superior. Por ejemplo, la siguiente expresi\u00f3n es incorrecta: ( foldr and #t ' ( #t #f #f )) ; and: bad syntax in: and Para comprobar expresiones booleanas en una lista podemos usar foldr con una expresi\u00f3n lambda: ( foldr ( lambda ( dato result ) ( and dato result )) #t ' ( #t #f #f )) ; \u21d2 #f O, mejor a\u00fan, es posible usar for-all? o exists? (o las funciones equivalentes de Racket andmap o ormap ). Por ejemplo, para comprobar si alg\u00fan booleano de una lista es #t podr\u00edamos hacer: ( exists? ( lambda ( x ) x ) ' ( #f #f #t #f )) ; \u21d2 #t ( ormap ( lambda ( x ) x ) ' ( #f #f #t #f )) ; \u21d2 #t 5.7.8. Funciones con FOS y expresiones lambda \u00b6 El uso de funciones de orden superior (FOS) y expresiones lambda proporciona much\u00edsima expresividad en un lenguaje de programaci\u00f3n. Es posible escribir c\u00f3digo muy conciso y construir funciones iterativas que recorren listas y operan sobre sus elementos sin usar la recursividad. 5.7.8.1. Funci\u00f3n (suma-n n lista) \u00b6 Supongamos que queremos definir una funci\u00f3n (suma-n n lista) que devuelve la lista resultante el resultado de sumar un n\u00famero n a todos los elementos de una lista. Podemos hacerlo de forma recursiva: ( define ( suma-n n lista ) ( if ( null? lista ) ' () ( cons ( + ( first lista ) n ) ( suma-n n ( rest lista ))))) Funciona de la siguiente manera: ( suma-n 10 ' ( 1 2 3 4 )) ; \u21d2 (11 12 13 14) Implementacion con map Pero si utilizamos funciones de orden superior, podemos implementar la misma funci\u00f3n de una forma mucho m\u00e1s concisa y expresiva. Lo podemos hacer utilizando la funci\u00f3n de orden superior map y una expresi\u00f3n lambda que sume el n\u00famero n a los elementos de la lista: ( define ( suma-n n lista ) ( map ( lambda ( x ) ( + x n )) lista )) Vemos que utilizamos el par\u00e1metro n en el cuerpo de la expresi\u00f3n lambda. De esta forma la funci\u00f3n que se aplica a los elementos de la lista es una funci\u00f3n que suma este n\u00famero a cada elemento. La variable x en el par\u00e1metro de la expresi\u00f3n lambda es la que va tomando el valor de los elementos de la lista. (suma-n 10 '(1 2 3 4) 10) => (map #<prodedure-que-suma-10-a-x> (1 2 3 4)) = (11 12 13 14) 5.7.8.2. Composici\u00f3n de funciones de orden superior \u00b6 Dado que muchas de las anteriores funciones de orden superior devuelven listas, es muy com\u00fan componer las llamadas, de forma que la salida de funci\u00f3n se utilice como entrada de otra. Por ejemplo, podemos implementar una funci\u00f3n que sume un n\u00famero n a todos los elementos de una lista (igual que la anterior) y despu\u00e9s que sume todos los elementos resultantes. Lo podr\u00edamos hacer reutilizando el c\u00f3digo del ejemplo anterior, y a\u00f1adiendo una llamada a foldr para que haga la suma: ( define ( suma-n-total n lista ) ( foldr + 0 ( map ( lambda ( x ) ( + x n )) lista ))) Funcionar\u00eda de la siguiente forma: ( suma-n-total 100 ' ( 1 2 3 4 )) ; \u21d2 410 Otro ejemplo. Supongamos que tenemos una lista de parejas de n\u00fameros y queremos contar aquellas parejas cuya suma de ambos n\u00fameros es mayor que un umbral (por ejemplo, 10). ( define lista-parejas ( list ( cons 1 2 ) ( cons 3 8 ) ( cons 2 3 ) ( cons 9 6 ))) ( cuenta-mayores-que 10 lista-parejas ) ; \u21d2 2 Se podr\u00eda implementar de una forma muy concisa componiendo una llamada a map para realizar la suma de cada pareja junto con una llamada a filter que compruebe que el resultado sea mayor de n . Y al final llamamos a length para contar la longitud de la lista resultante: ( define ( cuenta-mayores-que n lista-parejas ) ( length ( filter ( lambda ( x ) ( > x n )) ( map ( lambda ( pareja ) ( + ( car pareja ) ( cdr pareja ))) lista-parejas )))) 5.7.8.3. Funci\u00f3n (contienen-letra caracter lista-pal) \u00b6 Veamos otro ejemplo. Supongamos que queremos definir la funci\u00f3n (contienen-letra caracter lista-pal) que devuelve las palabras de una lista que contienen un determinado car\u00e1cter. Por ejemplo: ( contienen-letra #\\a ' ( \"En\" \"un\" \"lugar\" \"de\" \"la\" \"Mancha\" )) ; \u21d2 (\"lugar\" \"la\" \"Mancha\") Podemos implementar contienen-letra usando la funci\u00f3n de orden superior filter , con una expresi\u00f3n lambda que se aplicar\u00e1 a cada una de las palabras de la lista para comprobar si la palabra contiene el car\u00e1cter: ( define ( contienen-letra caracter lista-pal ) ( filter ( lambda ( pal ) ( letra-en-pal? caracter pal )) lista-pal )) El par\u00e1metro pal de la expresi\u00f3n lambda ir\u00e1 cogiendo el valor de todas las palabras de lista-pal y la funci\u00f3n (letra-en-pal? caracter pal) comprobar\u00e1 si la cadena contiene el car\u00e1cter. La funci\u00f3n (letra-en-pal? caracter pal) es una funci\u00f3n auxiliar que tenemos que implementar. Por ejemplo: ( letra-en-pal? #\\a \"Hola\" ) ; \u21d2 #t ( letra-en-pal? #\\a \"Pepe\" ) ; \u21d2 #f La podemos implementar de una forma muy elegante obteniendo una lista de caracteres a partir de la cadena y usando la funci\u00f3n de orden superior exists? : ( define ( letra-en-pal? caracter palabra ) ( exists? ( lambda ( c ) ( equal? c caracter )) ( string->list palabra ))) 5.7.8.4. Funci\u00f3n divisores \u00b6 Un \u00faltimo ejemplo en el que implementamos la funci\u00f3n (divisores n) utilizando una funci\u00f3n de orden superior. Suponemos que tenemos definidas las funciones (numeros-hasta n) y (divisor? x n) : ( define ( numeros-hasta n ) ( if ( = 0 n ) ' () ( cons n ( numeros-hasta ( - n 1 ))))) ( define ( divisor? x n ) ( = 0 ( mod n x ))) Entonces la funci\u00f3n (divisores n) se implementar\u00eda de la siguiente forma: ( define ( divisores n ) ( filter ( lambda ( x ) ( divisor? x n )) ( numeros-hasta n ))) 6. Bibliograf\u00eda \u00b6 Cap\u00edtulos del libro Structure and Intepretation of Computer Programs : 1.1 The Elements of Programming 1.3 Formulating Abstractions with Higher-Order Procedures 2.2.1 Representing Sequences Lenguajes y Paradigmas de Programaci\u00f3n, curso 2021-22 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Domingo Gallardo, Cristina Pomares, Antonio Bot\u00eda, Francisco Mart\u00ednez","title":"Tema 2: Programaci\u00f3n funcional"},{"location":"teoria/tema02-programacion-funcional/tema02-programacion-funcional.html#tema-2-programacion-funcional","text":"","title":"Tema 2: Programaci\u00f3n funcional"},{"location":"teoria/tema02-programacion-funcional/tema02-programacion-funcional.html#1-el-paradigma-de-programacion-funcional","text":"","title":"1. El paradigma de Programaci\u00f3n Funcional"},{"location":"teoria/tema02-programacion-funcional/tema02-programacion-funcional.html#11-pasado-y-presente-del-paradigma-funcional","text":"","title":"1.1. Pasado y presente del paradigma funcional"},{"location":"teoria/tema02-programacion-funcional/tema02-programacion-funcional.html#12-evaluacion-de-expresiones-y-definicion-de-funciones","text":"En la asignatura usaremos Scheme como primer lenguaje en el que exploraremos la programaci\u00f3n funcional. En el seminario de Scheme que se imparte en pr\u00e1cticas se estudiar\u00e1 en m\u00e1s profundidad los conceptos m\u00e1s importantes del lenguaje: tipos de datos, operadores, estructuras de control, int\u00e9rprete, etc.","title":"1.2. Evaluaci\u00f3n de expresiones y definici\u00f3n de funciones"},{"location":"teoria/tema02-programacion-funcional/tema02-programacion-funcional.html#13-programacion-declarativa-vs-imperativa","text":"Hemos dicho que la programaci\u00f3n funcional es un estilo de programaci\u00f3n declarativa, frente a la programaci\u00f3n tradicional de los lenguajes denominados imperativos. Vamos a explicar esto un poco m\u00e1s.","title":"1.3. Programaci\u00f3n declarativa vs. imperativa"},{"location":"teoria/tema02-programacion-funcional/tema02-programacion-funcional.html#14-modelo-de-computacion-de-sustitucion","text":"Un modelo computacional es un formalismo (conjunto de reglas) que definen el funcionamiento de un programa. En el caso de los lenguajes funcionales basados en la evaluaci\u00f3n de expresiones, el modelo computacional define cu\u00e1l ser\u00e1 el resultado de evaluar una expresi\u00f3n. El modelo de sustituci\u00f3n es un modelo muy sencillo que permite definir la sem\u00e1ntica de la evaluaci\u00f3n de expresiones en lenguajes funcionales como Scheme. Se basa en una versi\u00f3n simplificada de la regla de reducci\u00f3n del c\u00e1lculo lambda. Es un modelo basado en la reescritura de unos t\u00e9rminos por otros. Aunque se trata de un modelo abstracto, ser\u00eda posible escribir un int\u00e9rprete que, bas\u00e1ndose en este modelo, eval\u00fae expresiones funcionales. Supongamos un conjunto de definiciones en Scheme: ( define ( doble x ) ( + x x )) ( define ( cuadrado y ) ( * y y )) ( define ( f z ) ( + ( cuadrado ( doble z )) 1 )) ( define a 2 ) Supongamos que, una vez realizadas esas definiciones, se eval\u00faa la siguiente expresi\u00f3n: ( f ( + a 1 )) \u00bfCu\u00e1l ser\u00e1 su resultado? Si lo hacemos de forma intuitiva podemos pensar que 37 . Si lo comprobamos en el int\u00e9rprete de Scheme veremos que devuelve 37. \u00bfHemos seguido algunas reglas espec\u00edficas? \u00bfQu\u00e9 reglas son las que sigue el int\u00e9rprete? \u00bfPodr\u00edamos implementar nosotros un int\u00e9rprete similar? S\u00ed, usando las reglas del modelo de sustituci\u00f3n. El modelo de sustituci\u00f3n define cuatro reglas sencillas para evaluar una expresi\u00f3n. Llamemos a la expresi\u00f3n e . Las reglas son las siguientes: Si e es un valor primitivo (por ejemplo, un n\u00famero), devolvemos ese mismo valor. Si e es un identificador, devolvemos su valor asociado con un define (se lanzar\u00e1 un error si no existe ese valor). Si e es una expresi\u00f3n del tipo (f arg1 ... argn) , donde f es el nombre de una funci\u00f3n primitiva ( + , - , ...), evaluamos uno a uno los argumentos arg1 ... argn (con estas mismas reglas) y evaluamos la funci\u00f3n primitiva con los resultados. La regla 4 tiene dos variantes, dependiendo del orden de evaluaci\u00f3n que utilizamos. Orden aplicativo Si e es una expresi\u00f3n del tipo (f arg1 ... argn) , donde f es el nombre de una funci\u00f3n definida con un define , tenemos que evaluar primero los argumentos arg1 ... argn y despu\u00e9s sustituir f por su cuerpo , reemplazando cada par\u00e1metro formal de la funci\u00f3n por el correspondiente argumento evaluado . Despu\u00e9s evaluaremos la expresi\u00f3n resultante usando estas mismas reglas. Orden normal Si e es una expresi\u00f3n del tipo (f arg1 ... argn) , donde f es el nombre de una funci\u00f3n definida con un define , tenemos que sustituir f por su cuerpo , reemplazando cada par\u00e1metro formal de la funci\u00f3n por el correspondiente argumento sin evaluar . Despu\u00e9s evaluar la expresi\u00f3n resultante usando estas mismas reglas. En el orden aplicativo se realizan las evaluaciones antes de realizar las sustituciones, lo que define una evaluaci\u00f3n de dentro a fuera de los par\u00e9ntesis. Cuando se llega a una expresi\u00f3n primitiva se eval\u00faa. En el orden normal se realizan todas las sustituciones hasta que se tiene una larga expresi\u00f3n formada por expresiones primitivas; se eval\u00faa entonces. Ambas formas de evaluaci\u00f3n dar\u00e1n el mismo resultado en programaci\u00f3n funcional. Scheme utiliza el orden aplicativo.","title":"1.4. Modelo de computaci\u00f3n de sustituci\u00f3n"},{"location":"teoria/tema02-programacion-funcional/tema02-programacion-funcional.html#2-scheme-como-lenguaje-de-programacion-funcional","text":"Ya hemos visto c\u00f3mo definir funciones y evaluar expresiones en Scheme. Vamos continuar con ejemplos concretos de otras caracter\u00edsticas funcionales caracter\u00edsticas funcionales de Scheme. En concreto, veremos: S\u00edmbolos y primitiva quote Uso de listas Definici\u00f3n de funciones recursivas en Scheme","title":"2. Scheme como lenguaje de programaci\u00f3n funcional"},{"location":"teoria/tema02-programacion-funcional/tema02-programacion-funcional.html#21-funciones-y-formas-especiales","text":"En el seminario de Scheme hemos visto un conjunto de primitivas que podemos utilizar en Scheme. Podemos clasificar las primitivas en funciones y formas especiales . Las funciones se eval\u00faan usando el modelo de sustituci\u00f3n aplicativo ya visto: Primero se eval\u00faan los argumentos y despu\u00e9s se sustituye la llamada a la funci\u00f3n por su cuerpo y se vuelve a evaluar la expresi\u00f3n resultante. Las expresiones siempre se eval\u00faan desde los par\u00e9ntesis interiores a los exteriores. Las formas especiales son expresiones primitivas de Scheme que tienen una forma de evaluarse propia, distinta de las funciones.","title":"2.1. Funciones y formas especiales"},{"location":"teoria/tema02-programacion-funcional/tema02-programacion-funcional.html#22-formas-especiales-en-scheme","text":"Veamos la forma de evaluar las distintas formas especiales en Scheme. En estas formas especiales no se aplica el modelo de sustituci\u00f3n, al no ser invocaciones de funciones, sino que cada una se eval\u00faa de una forma diferente.","title":"2.2. Formas especiales en Scheme"},{"location":"teoria/tema02-programacion-funcional/tema02-programacion-funcional.html#23-forma-especial-quote-y-simbolos","text":"Sintaxis ( quote <identificador> ) Evaluaci\u00f3n Se devuelve el identificador sin evaluar (un s\u00edmbolo). Se abrevia en con el car\u00e1cter ' . Ejemplos ( quote x ) ; el s\u00edmbolo x ' hola ; el s\u00edmbolo hola A diferencia de los lenguajes imperativos, Scheme trata a los identificadores (nombres que se les da a las variables) como datos del lenguaje de tipo symbol . En el paradigma funcional a los identificadores se les denomina s\u00edmbolos . Los s\u00edmbolos son distintos de las cadenas. Una cadena es un tipo de dato compuesto y se guardan en memoria todos y cada uno de los caracteres que la forman. Sin embargo, los s\u00edmbolos son tipos at\u00f3micos, que se representan en memoria con un \u00fanico valor determinado por el c\u00f3digo hash del identificador. Ejemplos de funciones Scheme con s\u00edmbolos: ( define x 12 ) ( symbol? ' x ) ; \u21d2 #t ( symbol? x ) ; \u21d2 #f \u00bfPor qu\u00e9? ( symbol? ' hola-que<> ) ( symbol->string ' hola-que<> ) ' ma\u00f1ana ' l\u00e1piz ; aunque sea posible, no vamos a usar acentos en los s\u00edmbolos ; pero s\u00ed en los comentarios ( symbol? \"hola\" ) ; #f ( symbol? #f ) ; #f ( symbol? ( first ' ( hola c\u00f3mo est\u00e1s ))) ; #t ( equal? ' hola ' hola ) ( equal? ' hola \"hola\" ) Como hemos visto anteriormente, un s\u00edmbolo puede asociarse o ligarse ( bind ) a un valor (cualquier dato de primera clase ) con la forma especial define . ( define pi 3.14159 ) Nota No es correcto escribir (define 'pi 3.14156) porque la forma especial define debe recibir un identificador sin quote . Cuando escribimos un s\u00edmbolo en el prompt de Scheme el int\u00e9rprete lo eval\u00faa y devuelve su valor: > pi 3.14159 Los nombres de las funciones ( equal? , sin , + , ...) son tambi\u00e9n s\u00edmbolos y Scheme tambi\u00e9n los eval\u00faa (en un par de semanas hablaremos de las funciones como objetos primitivos en Scheme): > sin #<procedure:sin> > + #<procedure:+> > (define (cuadrado x) (* x x)) > cuadrado #<procedure:cuadrado> Los s\u00edmbolos son tipos primitivos del lenguaje: pueden pasarse como par\u00e1metros o ligarse a variables. > (define x 'hola) > x hola","title":"2.3. Forma especial quote y s\u00edmbolos"},{"location":"teoria/tema02-programacion-funcional/tema02-programacion-funcional.html#24-forma-expecial-quote-con-expresiones","text":"Sintaxis ( quote <expresi\u00f3n> ) Evaluaci\u00f3n Si quote recibe una expresi\u00f3n correcta de Scheme (una expresi\u00f3n entre par\u00e9ntesis) se devuelve la lista o pareja pareja definida por la expresi\u00f3n (sin evaluar sus elementos). Ejemplos ' ( 1 2 3 ) ; \u21d2 (1 2 3) Una lista ' ( + 1 2 3 4 ) ; La lista formada por el s\u00edmbolo + y los n\u00fameros 1 2 3 4 ( quote ( 1 2 3 4 )) ; La lista formada por los n\u00fameros 1 2 3 4 ' ( a b c ) ; \u21d2 La lista con los s\u00edmbolos a, b, y c ' ( * ( + 1 ( + 2 3 )) 5 ) ; Una lista con 3 elementos, el segundo de ellos otra lista ' ( 1 . 2 ) ; \u21d2 La pareja (1 . 2) ' (( 1 . 2 ) ( 2 . 3 )) ; \u21d2 Una lista con las parejas (1 . 2) y (2 . 3)","title":"2.4. Forma expecial quote con expresiones"},{"location":"teoria/tema02-programacion-funcional/tema02-programacion-funcional.html#25-funcion-eval","text":"Una vez vista la forma especial quote podemos explicar la funci\u00f3n eval . La funci\u00f3n eval es una instrucci\u00f3n muy curiosa de los lenguajes funcionales. Permite invocar al int\u00e9rprete en tiempo de ejecuci\u00f3n y hacer que \u00e9ste eval\u00fae una expresi\u00f3n que puede haberse construido din\u00e1micamente. Sintaxis ( eval <expresi\u00f3n> ) Evaluaci\u00f3n La funci\u00f3n eval invoca al int\u00e9rprete para realizar la evaluaci\u00f3n de la expresi\u00f3n que se le pasa como par\u00e1metro y devuelve el resultado de dicha evaluaci\u00f3n. Ejemplos ( define a 10 ) ( eval ' a ) ; \u21d2 10 ( eval ' ( + 1 2 3 )) ; \u21d2 6 ( define lista ( list ' + 1 2 3 )) ( eval lista ) ; \u21d2 6 ( define a 10 ) ( define x ' a ) ( eval ' x ) ; \u21d2 a ( eval x ) ; \u21d2 10 ( eval ( eval ' x )) ; \u21d2 10 Una nota sobre la evaluaci\u00f3n de eval Al ser eval una funci\u00f3n, la expresi\u00f3n que se le pasa como par\u00e1metro se eval\u00faa previamente, antes de ser procesada por eval . En el caso de ser una expresi\u00f3n con quote , el resultado de la evaluaci\u00f3n es la propia expresi\u00f3n (una lista), que es procesada por eval . Por ejemplo, en la siguiente expresi\u00f3n ( eval ( + 2 3 )) ; \u21d2 5 primero se evaluar\u00eda la expresi\u00f3n (+ 2 3) y lo que se le pasar\u00eda a eval ser\u00eda un 5 . El resultado de evaluar un 5 ser\u00eda un 5 . Sin embargo, en la siguiente expresi\u00f3n: ( eval ' ( + 2 3 )) el resultado de evaluar '(+ 2 3) devolver\u00eda la lista (+ 2 3) que es la que se pasar\u00eda a eval . El resultado de evaluar esa expresi\u00f3n tambi\u00e9n ser\u00eda 5 .","title":"2.5. Funci\u00f3n eval"},{"location":"teoria/tema02-programacion-funcional/tema02-programacion-funcional.html#26-listas","text":"Otra de las caracter\u00edsticas fundamentales del paradigma funcional es la utilizaci\u00f3n de listas. Ya hemos visto en el seminario de Scheme las funciones m\u00e1s importantes para trabajar con ellas. Vamos a repasarlas de nuevo en este apartado, antes de ver alg\u00fan ejemplo de c\u00f3mo usar la recursi\u00f3n con listas. Ya hemos visto en dicho seminario que Scheme es un lenguaje d\u00e9bilmente tipado. Una variable o par\u00e1metro no se declara de un tipo y puede contener cualquier valor. Sucede igual con las listas: una lista en Scheme puede contener cualquier valor, incluyendo otras listas.","title":"2.6. Listas"},{"location":"teoria/tema02-programacion-funcional/tema02-programacion-funcional.html#27-recursion","text":"Otra caracter\u00edstica fundamental de la programaci\u00f3n funcional es la no existencia de bucles. Un bucle implica la utilizaci\u00f3n de pasos de ejecuci\u00f3n en el programa y esto es caracter\u00edstico de la programaci\u00f3n imperativa. En programaci\u00f3n funcional las iteraciones se realizan con recursi\u00f3n.","title":"2.7. Recursi\u00f3n"},{"location":"teoria/tema02-programacion-funcional/tema02-programacion-funcional.html#28-recursion-y-listas","text":"La utilizaci\u00f3n de la recursi\u00f3n es muy \u00fatil para trabajar con estructuras secuenciales, como listas. Vamos a empezar viendo unos sencillos ejemplos y m\u00e1s adelante veremos algunos m\u00e1s complicadas.","title":"2.8. Recursi\u00f3n y listas"},{"location":"teoria/tema02-programacion-funcional/tema02-programacion-funcional.html#3-tipos-de-datos-compuestos-en-scheme","text":"","title":"3. Tipos de datos compuestos en Scheme"},{"location":"teoria/tema02-programacion-funcional/tema02-programacion-funcional.html#31-el-tipo-de-dato-pareja","text":"","title":"3.1. El tipo de dato pareja"},{"location":"teoria/tema02-programacion-funcional/tema02-programacion-funcional.html#32-las-parejas-son-objetos-de-primera-clase","text":"En un lenguaje de programaci\u00f3n un elemento es de primera clase cuando puede: Asignarse a variables Pasarse como argumento Devolverse por una funci\u00f3n Guardarse en una estructura de datos mayor Las parejas son objetos de primera clase. Una pareja puede asignarse a una variable: ( define p1 ( cons 1 2 )) ( define p2 ( cons #f \"hola\" )) Una pareja puede pasarse como argumento y devolverse en una funci\u00f3n: ( define ( suma-parejas p1 p2 ) ( cons ( + ( car p1 ) ( car p2 )) ( + ( cdr p1 ) ( cdr p2 )))) ( suma-parejas ' ( 1 . 5 ) ' ( 4 . 12 )) ; \u21d2 (5 . 17) Una vez definida esta funci\u00f3n suma-parejas podr\u00edamos ampliar la funci\u00f3n suma que vimos previamente con este nuevo tipo de datos: ( define ( suma x y ) ( cond (( and ( number? x ) ( number? y )) ( + x y )) (( and ( string? x ) ( string? y )) ( string-append x y )) (( and ( pair? x ) ( pair? y )) ( suma-parejas p1 p2 )) ( else ' error ))) Y, por \u00faltimo, las parejas pueden formar parte de otras parejas . Es lo que se denomina la propiedad de clausura de la funci\u00f3n cons : el resultado de un cons puede usarse como par\u00e1metro de nuevas llamadas a cons . Ejemplo: ( define p1 ( cons 1 2 )) ( define p2 ( cons 3 4 )) ( define p ( cons p1 p2 )) Expresi\u00f3n equivalente: ( define p ( cons ( cons 1 2 ) ( cons 3 4 ))) Podr\u00edamos representar esta estructura as\u00ed: Propiedad de clausura: las parejas pueden contener parejas Pero se har\u00eda muy complicado representar muchos niveles de anidamiento. Por eso utilizamos la siguiente representaci\u00f3n: Llamamos a estos diagramas diagramas caja-y-puntero ( box-and-pointer en ingl\u00e9s).","title":"3.2. Las parejas son objetos de primera clase"},{"location":"teoria/tema02-programacion-funcional/tema02-programacion-funcional.html#33-diagramas-caja-y-puntero","text":"Al escribir expresiones complicadas con cons anidados es conveniente para mejorar su legibilidad utilizar el siguiente formato: ( define p ( cons ( cons 1 ( cons 3 4 )) 2 )) Para entender la construcci\u00f3n de estas estructuras es importante recordar que las expresiones se eval\u00faan de dentro a afuera . \u00bfQu\u00e9 figura representar\u00eda la estructura anterior? Soluci\u00f3n: Es importante tener en cuenta que cada caja del diagrama representa una pareja creada en la memoria del int\u00e9rprete con la instrucci\u00f3n cons y que el resultado de evaluar una variable en la que se ha guardado una pareja devuelve la pareja reci\u00e9n creada. Por ejemplo, si el int\u00e9rprete eval\u00faa p despu\u00e9s de haber hecho la sentencia anterior devuelve la pareja contenida en p , no se crea una pareja nueva. Por ejemplo, si despu\u00e9s de haber evaluado la sentencia anterior evaluamos la siguiente: ( define p2 ( cons 5 ( cons p 6 ))) El diagrama caja y puntero resultante ser\u00eda el siguiente: Vemos que en la pareja que se crea con (cons p 6) se guarda en la parte izquierda la misma pareja que hay en p . Lo representamos con una flecha que apunta a la misma pareja que p . Nota El funcionamiento de la evaluaci\u00f3n de variables que contienen parejas es similar al de las variables que contienen objetos en lenguajes orientados a objetos como Java. Cuando se eval\u00faa una variable que contiene una pareja se devuelve la propia pareja, no una copia. En programaci\u00f3n funcional, como el contenido de las parejas es inmutable, no hay problemas de efectos laterales por el hecho de que una pareja est\u00e9 compartida. Es conveniente que pruebes a crear distintas estructuras de parejas con parejas y a dibujar su diagrama caja y puntero. Y tambi\u00e9n a recuperar un determinado dato (pareja o dato at\u00f3mico) una vez creada la estructura. La siguiente funci\u00f3n print-pareja puede ser \u00fatil a la hora de mostrar por pantalla los elementos de una pareja ( define ( print-pareja pareja ) ( if ( pair? pareja ) ( begin ( display \"(\" ) ( print-dato ( car pareja )) ( display \" . \" ) ( print-dato ( cdr pareja )) ( display \")\" )) ( display \"\" ))) ( define ( print-dato dato ) ( if ( pair? dato ) ( print-pareja dato ) ( display dato ))) \u00a1Cuidado! La funci\u00f3n anterior contiene pasos de ejecuci\u00f3n con sentencias como begin y llamadas a display dentro del c\u00f3digo de la funci\u00f3n. Estas sentencias son propias de la programaci\u00f3n imperativa. No hacerlo en programaci\u00f3n funcional .","title":"3.3. Diagramas caja-y-puntero"},{"location":"teoria/tema02-programacion-funcional/tema02-programacion-funcional.html#4-listas-en-scheme","text":"","title":"4. Listas en Scheme"},{"location":"teoria/tema02-programacion-funcional/tema02-programacion-funcional.html#41-implementacion-de-listas-en-scheme","text":"Recordemos que Scheme permite manejar listas como un tipo de datos b\u00e1sico. Hemos visto funciones para crear, a\u00f1adir y recorrer listas. En Scheme las listas se implementan usando parejas, por lo que las funciones car y cdr tambi\u00e9n funcionan sobre listas. \u00bfQu\u00e9 devuelven cuando se aplican a una lista? \u00bfC\u00f3mo se implementan las listas con parejas? Vamos a investigarlo haciendo unas pruebas. En primer lugar, vamos a usar las funciones list? y pair? para comprobar si algo es una lista y/o una pareja. Por ejemplo, una pareja formada por dos n\u00fameros es una pareja, pero no es una lista: ( define p1 ( cons 1 2 )) ( pair? p1 ) ; \u21d2 #t ( list? p1 ) ; \u21d2 #f Si preguntamos si una lista es una pareja, nos llevaremos la sorpresa de que s\u00ed. Una lista es una lista (evidentemente) pero tambi\u00e9n es una pareja: ( define lista ' ( 1 2 3 )) ( list? lista ) ; \u21d2 #t ( pair? lista ) ; \u21d2 #t Si una lista es tambi\u00e9n una pareja tambi\u00e9n podemos aplicar las funciones car y cdr con ellas. \u00bfQu\u00e9 devuelven? Vamos a verlo: ( define lista ' ( 1 2 3 )) ( car lista ) ; \u21d2 1 ( cdr lista ) ; \u21d2 (2 3) Resulta que en la pareja que representa la lista, en la parte izquierda se guarda el primer el elemento de la lista y en la parte derecha se guarda el resto de la lista. Tambi\u00e9n podemos explicar entonces por qu\u00e9 la llamada a cons con un dato y una lista construye otra lista: ( define lista ' ( 1 2 3 )) ( define p1 ( cons 1 lista )) ( list? p1 ) ; \u21d2 #t p1 ; \u21d2 (1 1 2 3) \u00bfUna pareja con una lista vac\u00eda como parte derecha es una lista? Lo probamos: ( define p1 ( cons 1 ' ())) ( pair? p1 ) ; \u21d2 #t ( list? p1 ) ; \u21d2 #t Con estos ejemplos ya tenemos pistas para deducir la relaci\u00f3n entre listas y parejas en Scheme (y Lisp). Vamos a explicarlo.","title":"4.1. Implementaci\u00f3n de listas en Scheme"},{"location":"teoria/tema02-programacion-funcional/tema02-programacion-funcional.html#42-listas-con-elementos-compuestos","text":"Las listas pueden contener cualquier tipo de elementos, incluyendo otras parejas. La siguiente estructura se denomina lista de asociaci\u00f3n . Son listas cuyos elementos son parejas ( clave , valor ): ( list ( cons ' a 1 ) ( cons ' b 2 ) ( cons ' c 3 )) ; \u21d2 ((a . 1) (b . 2) (c . 2)) \u00bfCu\u00e1l ser\u00eda el diagrama box and pointer de la estructura anterior? La expresi\u00f3n equivalente utilizando conses es: ( cons ( cons ' a 1 ) ( cons ( cons ' b 2 ) ( cons ( cons ' c 3 ) ' ())))","title":"4.2. Listas con elementos compuestos"},{"location":"teoria/tema02-programacion-funcional/tema02-programacion-funcional.html#43-funciones-recursivas-que-construyen-listas","text":"Para terminar el apartado sobre las listas en Scheme vamos a ver ejemplos adicionales de funciones recursivas que trabajan con listas. Veremos alguna funci\u00f3n que recibe una lista y, como antes, usa la recursi\u00f3n para recorrerla. Pero veremos tambi\u00e9n funciones que usan la recursi\u00f3n para construir nuevas listas . Algunas de las funciones que presentamos son implementaciones de las ya existentes en Scheme. Para no solapar con las definiciones de Scheme pondremos el prefijo mi- en todas ellas. Vamos a ver las siguientes funciones: mi-list-ref : implementaci\u00f3n de la funci\u00f3n list-ref mi-list-tail : implementaci\u00f3n de la funci\u00f3n list-tail mi-append : implementaci\u00f3n de la funi\u00f3n append mi-reverse : implementaci\u00f3n de la funci\u00f3n reverse cuadrados-hasta : devuelve la lista de cuadrados hasta uno dado filtra-pares : devuelve la lista de los n\u00fameros pares de la lista que se recibe primo? : comprueba si un n\u00famero es o no primo","title":"4.3. Funciones recursivas que construyen listas"},{"location":"teoria/tema02-programacion-funcional/tema02-programacion-funcional.html#44-funciones-con-numero-variable-de-argumentos","text":"Hemos visto algunas funciones primitivas de Scheme, como + o max que admiten un n\u00famero variable de argumentos. \u00bfPodemos hacerlo tambi\u00e9n en funciones definidas por nosotros? La respuesta es s\u00ed, utilizando lo que se denomina notaci\u00f3n dotted-tail (punto-cola) para definir los par\u00e1metros de la funci\u00f3n. En esta notaci\u00f3n se coloca un punto antes del \u00faltimo par\u00e1metro. Los par\u00e1metros antes del punto (si existen) tendr\u00e1n como valores los argumentos usados en la llamada y el resto de argumentos se pasar\u00e1n en forma de lista en el \u00faltimo par\u00e1metro. Por ejemplo, si tenemos la definici\u00f3n ( define ( funcion-dos-o-mas-args x y . lista-args ) <cuerpo> ) podemos llamar a la funci\u00f3n anterior con dos o m\u00e1s argumentos: ( funcion-dos-o-mas-args 1 2 3 4 5 6 ) En la llamada, los par\u00e1metros x e y tomar\u00e1n los valores 1 y 2. El par\u00e1metro lista-args tomar\u00e1 como valor una lista con los argumentos restantes (3 4 5 6) . Tambi\u00e9n es posible permitir que todos los argumentos sean opcionales no poniendo ning\u00fan argumento antes del punto:: ( define ( funcion-cualquier-numero-args . lista-args ) <cuerpo> ) Si hacemos la llamada ( funcion-cualquier-numero-args 1 2 3 4 5 6 ) el par\u00e1metro lista-args tomar\u00e1 como valor la lista (1 2 3 4 5 6) . Veamos un sencillo ejemplo. Podemos implementar una funci\u00f3n mi-suma que tome al menos dos argumentos y despu\u00e9s un n\u00famero variable de argumentos y devuelva la suma de todos ellos. Es muy sencillo: recogemos todos los argumentos en la lista de argumentos variables y llamamos a la funci\u00f3n suma-lista que suma una lista de n\u00fameros: ( define ( mi-suma x y . lista-nums ) ( if ( null? lista-nums ) ( + x y ) ( + x ( + y ( suma-lista lista-nums )))))","title":"4.4. Funciones con n\u00famero variable de argumentos"},{"location":"teoria/tema02-programacion-funcional/tema02-programacion-funcional.html#5-funciones-como-tipos-de-datos-de-primera-clase","text":"Hemos visto que la caracter\u00edstica fundamental de la programaci\u00f3n funcional es la definici\u00f3n de funciones. Hemos visto tambi\u00e9n que no producen efectos laterales y no tienen estado. Una funci\u00f3n toma unos datos como entrada y produce un resultado como salida. Una de las caracter\u00edsticas fundamentales de la programaci\u00f3n funcional es considerar a las funciones como objetos de primera clase . Recordemos que un tipo de primera clase es aquel que: Puede ser asignado a una variable Puede ser pasado como argumento a una funci\u00f3n Puede ser devuelto como resultado de una invocaci\u00f3n a una funci\u00f3n Puede ser parte de un tipo mayor Vamos a ver que las funciones son ejemplos de todos los casos anteriores: vamos a poder crear funciones sin nombre y asignarlas a variables, pasarlas como par\u00e1metro de otras funciones, devolverlas como resultado de invocar a otra funci\u00f3n y guardarlas en tipos de datos compuestos como listas. La posibilidad de usar funciones como objetos de primera clase es una caracter\u00edstica fundamental de los lenguajes funcionales. Es una caracter\u00edstica de muchos lenguajes multi-paradigma con caracter\u00edsticas funcionales como JavaScript , Python , Swift o a partir de la versi\u00f3n 8 de Java, Java 8 , (donde se denominan expresiones lambda ).","title":"5. Funciones como tipos de datos de primera clase"},{"location":"teoria/tema02-programacion-funcional/tema02-programacion-funcional.html#51-forma-especial-lambda","text":"Vamos a empezar explicando la forma especial lambda de Scheme, que nos permite crear funciones an\u00f3nimas en tiempo de ejecuci\u00f3n. De la misma forma que podemos usar cadenas o enteros sin darles un nombre, en Scheme es posible usar una funci\u00f3n sin darle un nombre mediante esta forma especial.","title":"5.1. Forma especial lambda"},{"location":"teoria/tema02-programacion-funcional/tema02-programacion-funcional.html#52-funciones-argumentos-de-otras-funciones","text":"Hemos visto ya un ejemplo de c\u00f3mo pasar una funci\u00f3n como par\u00e1metro de otra. Veamos alg\u00fan otro. Por ejemplo, podemos definir la funci\u00f3n aplica que recibe una funci\u00f3n en el par\u00e1metro func y dos valores en los par\u00e1metros x e y y devuelve el resultado de invocar a la funci\u00f3n que pasamos como par\u00e1metro con x e y . La funci\u00f3n que se pase como par\u00e1metro debe tener dos argumentos Para realizar la invocaci\u00f3n a la funci\u00f3n que se pasa como par\u00e1metro basta con usar func como su nombre. La funci\u00f3n se ha ligado al nombre func en el momento de la invocaci\u00f3n a aplica , de la misma forma que los argumentos se ligan a los par\u00e1metros x e y : ( define ( aplica f x y ) ( f x y )) Algunos ejemplos de invocaci\u00f3n, usando funciones primitivas, funciones definidas y expresiones lambda: ( aplica + 2 3 ) ; \u21d2 5 ( aplica * 4 5 ) ; \u21d2 10 ( aplica string-append \"hola\" \"adios\" ) ; \u21d2 \"holaadios\" ( define ( string-append-con-guion s1 s2 ) ( string-append s1 \"-\" s2 )) ( aplica string-append-con-guion \"hola\" \"adios\" ) ; \u21d2 \"hola-adios\" ( aplica ( lambda ( x y ) ( sqrt ( + ( * x x ) ( * y y )))) 3 4 ) ; \u21d2 5 Otro ejemplo, la funci\u00f3n aplica-2 que toma dos funciones f y g y un argumento x y devuelve el resultado de aplicar f a lo que devuelve la invocaci\u00f3n de g con x : ( define ( aplica-2 f g x ) ( f ( g x ))) ( define ( suma-5 x ) ( + x 5 )) ( define ( doble x ) ( + x x )) ( aplica-2 suma-5 doble 3 ) ; \u21d2 11","title":"5.2. Funciones argumentos de otras funciones"},{"location":"teoria/tema02-programacion-funcional/tema02-programacion-funcional.html#53-funcion-apply","text":"La funci\u00f3n (apply funcion lista) de Scheme permite aplicar una funci\u00f3n de aridad n a una lista de datos de n datos, haciendo que cada uno de los datos se pasen a la funci\u00f3n en orden como par\u00e1metros. La funci\u00f3n apply recibe una funci\u00f3n y una lista y devuelve el resultado de aplicar la funci\u00f3n a los datos de la lista, tom\u00e1ndolos como par\u00e1metros. Por ejemplo, podemos aplicar la funci\u00f3n suma a una lista de n\u00fameros: ( apply + ' ( 1 2 3 4 )) ; \u21d2 10 Podemos pasar a apply una expresi\u00f3n lambda: ( apply ( lambda ( x y ) ( + x ( * 2 y ))) ' ( 2 5 )) ; \u21d2 12 La lista que pasamos como argumento de apply debe tener tantos elementos como par\u00e1metros tenga la funci\u00f3n que aplicamos. En caso contrario, se produce un error: ( apply cons ' ( a b c )) ; \u21d2 error cons: arity mismatch ; the expected number of arguments does not match the given number expected: 2 given: 3 arguments...: La forma correcta de hacerlo: ( apply cons ' ( a b )) ; \u21d2 (a . b)","title":"5.3. Funci\u00f3n apply"},{"location":"teoria/tema02-programacion-funcional/tema02-programacion-funcional.html#54-generalizacion","text":"La posibilidad de pasar funciones como par\u00e1metros de otras es una poderosa herramienta de abstracci\u00f3n. Nos va a permitir dise\u00f1ar funciones m\u00e1s gen\u00e9ricas. Veamos un ejemplo. Supongamos que queremos calcular el sumatorio de a hasta b : ( define ( sum-x a b ) ( if ( > a b ) 0 ( + a ( sum-x ( + a 1 ) b )))) ( sum-x 1 10 ) ; \u21d2 55 Supongamos ahora que queremos calcular el sumatorio de a hasta b sumando los n\u00fameros al cuadrado: ( define ( sum-cuadrado-x a b ) ( if ( > a b ) 0 ( + ( * a a ) ( sum-cuadrado-x ( + a 1 ) b )))) ( sum-cuadrado-x 1 10 ) ; \u21d2 385 Y el sumatorio de a hasta b sumando los cubos: ( define ( sum-cubo-x a b ) ( if ( > a b ) 0 ( + ( * a a a ) ( sum-cubo-x ( + a 1 ) b )))) ( sum-cubo-x 1 10 ) ; \u21d2 3025 Vemos que el c\u00f3digo de las tres funciones anteriores es muy similar, cada funci\u00f3n la podemos obtener haciendo un copy-paste de otra previa. Lo \u00fanico que cambia es la funci\u00f3n a aplicar a cada n\u00famero de la serie. Siempre que hagamos copy-paste al programar tenemos que empezar a sospechar que no estamos generalizando suficientemente el c\u00f3digo. Un copy-paste arrastra tambi\u00e9n bugs y obliga a realizar m\u00faltiples modificaciones del c\u00f3digo cuando en el futuro tengamos que cambiar cosas. La posibilidad de pasar una funci\u00f3n como par\u00e1metro viene a nuestra ayuda para generalizar el c\u00f3digo anterior. En este caso, lo \u00fanico que cambia en las tres funciones anteriores es la funci\u00f3n a aplicar a los n\u00fameros de la serie. En primer caso no se hace nada, en el segundo se eleva al cuadrado y en el tercer caso al cubo. Podemos tomar esa funci\u00f3n como un par\u00e1metro adicional y definir una funci\u00f3n gen\u00e9rica sum-f-x que generaliza las tres funciones anteriores. Tendr\u00edamos el sumatorio desde a hasta b de f(x) : ( define ( sum-f-x f a b ) ( if ( > a b ) 0 ( + ( f a ) ( sum-f-x f ( + a 1 ) b )))) Las funciones anteriores son casos particulares de esta funci\u00f3n que las generaliza. Por ejemplo, para calcular el sumatorio desde 1 hasta 10 de x al cubo: ( define ( cubo x ) ( * x x x )) ( sum-f-x cubo 1 10 ) ; \u21d2 3025 Tambi\u00e9n podemos utilizar una expresi\u00f3n lambda en la invocaci\u00f3n a sum-f que construya la funci\u00f3n que queremos aplicar a cada n\u00famero. Por ejemplo, podemos sumar la expresi\u00f3n (n/(n-1)) para todos los n\u00fameros del 2 al 100: ( sum-f-x ( lambda ( n ) ( / n ( - n 1 ))) 2 100 ) Veremos m\u00e1s adelante muchos m\u00e1s ejemplos de funciones pasadas como par\u00e1metros y de la generalidad que permite este patr\u00f3n, cuando estudiemos las funciones de orden superior.","title":"5.4. Generalizaci\u00f3n"},{"location":"teoria/tema02-programacion-funcional/tema02-programacion-funcional.html#55-funciones-que-devuelven-funciones","text":"Cualquier objeto de primera clase puede ser devuelto por una funci\u00f3n; enteros, booleanos, parejas, etc. son objetos primitivos y podemos definir funciones que los devuelven. En el paradigma funcional lo mismo sucede con las funciones. Podemos definir una funci\u00f3n que cuando se invoque construya otra funci\u00f3n y la devuelva como resultado. Esta es una de la caracter\u00edsticas m\u00e1s importantes que diferencia los lenguajes de programaci\u00f3n funcionales de otros que no lo son. En lenguajes como C, C++ o Java (antes de Java 8) no es posible hacer esto. Para devolver una funci\u00f3n en Scheme debemos usar la forma especial lambda en el cuerpo de una funci\u00f3n. As\u00ed, cuando se invoca a esta funci\u00f3n se eval\u00faa lambda y se devuelve la funci\u00f3n resultante. Es una funci\u00f3n que creamos en tiempo de ejecuci\u00f3n, durante la evaluaci\u00f3n de la funci\u00f3n principal. La funci\u00f3n que se devuelve se denomina clausura ( Wikipedia ). Y decimos que la funci\u00f3n que ha construido la clausura es una funci\u00f3n constructora .","title":"5.5. Funciones que devuelven funciones"},{"location":"teoria/tema02-programacion-funcional/tema02-programacion-funcional.html#56-funciones-en-estructuras-de-datos","text":"La \u00faltima caracter\u00edstica de los tipos de primera clase es que pueden formar parte de tipos de datos compuestos, como listas. Para construir una lista de funciones debemos llamar a list con las funciones: ( define ( cuadrado x ) ( * x x )) ( define ( suma-1 x ) ( + x 1 )) ( define ( doble x ) ( * x 2 )) ( define lista ( list cuadrado suma-1 doble )) lista ; \u21d2 (#<procedure:cuadrado> #<procedure:suma-1> #<procedure:doble>) Tambi\u00e9n podemos definir las funciones con expresiones lambda. Por ejemplo, podemos a\u00f1adir a la lista una funci\u00f3n que suma 5 a un n\u00famero: ( define lista2 ( cons ( lambda ( x ) ( + x 5 )) lista )) lista2 ; \u21d2 (#<procedure> #<procedure:cuadrado> #<procedure:suma-1> #<procedure:doble>) Una vez creada una lista con funciones, \u00bfc\u00f3mo podemos invocar a alguna de ellas?. Debemos tratarlas de la misma forma que tratamos cualquier otro dato guardado en la lista, las recuperamos con las funciones first o list-ref y las invocamos. Por ejemplo, para invocar a la primera funci\u00f3n de lista2 : (( first lista2 ) 10 ) ; \u21d2 15 O a la tercera: (( list-ref lista2 2 ) 10 ) ; \u21d2 11","title":"5.6. Funciones en estructuras de datos"},{"location":"teoria/tema02-programacion-funcional/tema02-programacion-funcional.html#57-funciones-de-orden-superior","text":"Llamamos funciones de orden superior ( higher order functions en ingl\u00e9s) a las funciones que toman otras como par\u00e1metro o devuelven otra funci\u00f3n. Permiten generalizar soluciones con un alto grado de abstracci\u00f3n. Ya hemos visto algunas funciones de orden superior, unas construidas por nostros y otras propias de Scheme, como apply . Adem\u00e1s de apply , los lenguajes de programaci\u00f3n funcional como Scheme, Scala o Java 8 tienen ya predefinidas algunas otras funciones de orden superior que trabajan con listas. Estas funciones permiten definir operaciones sobre las listas de una forma muy concisa y compacta. Son muy usadas, porque tambi\u00e9n se pueden utilizar sobre streams de datos obtenidos en operaciones de entrada/salida (por ejemplo, datos JSON resultantes de una petici\u00f3n HTTP). Vamos a ver las funciones m\u00e1s importantes, su uso y su implementaci\u00f3n. map filter exists? for-all? foldr y foldl Despu\u00e9s de explicar estas funciones terminaremos con un ejemplo de su aplicaci\u00f3n en el que comprobaremos c\u00f3mo la utilizaci\u00f3n de funciones de orden superior es una excelente herramienta de la programaci\u00f3n funcional que permite hacer c\u00f3digo muy conciso y expresivo. La combinaci\u00f3n de funciones de nivel superior con listas es una de las caracter\u00edsticas m\u00e1s potentes de la programaci\u00f3n funcional.","title":"5.7. Funciones de orden superior"},{"location":"teoria/tema02-programacion-funcional/tema02-programacion-funcional.html#6-bibliografia","text":"Cap\u00edtulos del libro Structure and Intepretation of Computer Programs : 1.1 The Elements of Programming 1.3 Formulating Abstractions with Higher-Order Procedures 2.2.1 Representing Sequences Lenguajes y Paradigmas de Programaci\u00f3n, curso 2021-22 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Domingo Gallardo, Cristina Pomares, Antonio Bot\u00eda, Francisco Mart\u00ednez","title":"6. Bibliograf\u00eda"},{"location":"teoria/tema03-procedimientos-recursivos/tema03-procedimientos-recursivos.html","text":"Tema 3: Procedimientos recursivos \u00b6 Ya hemos visto muchos ejemplos de funciones recursivas. Una funci\u00f3n es recursiva cuando se llama a si misma. Una vez que uno se acostumbra a su uso, se comprueba que la recursi\u00f3n es una forma mucho m\u00e1s natural que la iteraci\u00f3n de expresar un gran n\u00famero de funciones y procedimientos. La formulaci\u00f3n matem\u00e1tica de la recursi\u00f3n es sencilla de entender, pero su implementaci\u00f3n en un lenguaje de programaci\u00f3n no lo es tanto. El primer lenguaje de programaci\u00f3n que permiti\u00f3 el uso de expresiones recursivas fue el Lisp. En el momento de su creaci\u00f3n exist\u00eda ya el Fortran, que no permit\u00eda que una funci\u00f3n se llamase a si misma. Ya hemos visto la utilidad de la recursi\u00f3n en muchos ejemplos para recorrer listas, para filtrarlas, etc. En este tema veremos algunos aspectos negativos de la recursi\u00f3n: su coste espacial y temporal. Veremos que hay soluciones a estos problemas, cambiando el estilo de la recursi\u00f3n y generando procesos iterativos o usando un enfoque autom\u00e1tico llamado memoization en el que se guardan los resultados de cada llamada recursiva. Por \u00faltimo, veremos un \u00faltimo ejemplo curioso e interesante de la recursi\u00f3n para realizar figuras fractales con gr\u00e1ficos de tortuga. 1. El coste de la recursi\u00f3n \u00b6 Hasta ahora hemos estudiado el dise\u00f1o de funciones recursivas. Vamos a tratar por primera vez su coste. Veremos que hay casos en los que es prohibitivo utilizar la recursi\u00f3n tal y como la hemos visto. Y veremos tambi\u00e9n que existen soluciones para esos casos. 1.1. La pila de la recursi\u00f3n \u00b6 Vamos a estudiar el comportamiento de la evaluaci\u00f3n de una llamada a una funci\u00f3n recursiva. Supongamos la funci\u00f3n mi-length : ( define ( mi-length items ) ( if ( null? items ) 0 ( + 1 ( mi-length ( rest items ))))) Examinamos c\u00f3mo se eval\u00faan las llamadas recursivas: (mi-length '(a b c d)) (+ 1 (mi-length '(b c d))) (+ 1 (+ 1 (mi-length '(c d)))) (+ 1 (+ 1 (+ 1 (mi-length '(d))))) (+ 1 (+ 1 (+ 1 (+ 1 (mi-length '()))))) (+ 1 (+ 1 (+ 1 (+ 1 0)))) (+ 1 (+ 1 (+ 1 1))) (+ 1 (+ 1 2)) (+ 1 3) 4 Cada llamada a la recursi\u00f3n deja una funci\u00f3n en espera de ser evaluada cuando la recursi\u00f3n devuelva un valor (en el caso anterior las funciones suma). Estas llamadas en espera, junto con sus argumentos, se almacenan en la pila de la recursi\u00f3n . Cuando la recursi\u00f3n devuelve un valor, los valores se recuperan de la pila, se realiza la llamada y se devuelve el valor a la anterior llamada en espera. Si la recursi\u00f3n est\u00e1 mal hecha y nunca termina se genera un stack overflow porque la memoria que se almacena en la pila sobrepasa la memoria reservada para el int\u00e9rprete DrRacket. 1.2. Coste espacial de la recursi\u00f3n \u00b6 El coste espacial de un programa es una funci\u00f3n que relaciona la memoria consumida por una llamada para resolver un problema con alguna variable que determina el tama\u00f1o del problema a resolver. En el caso de la funci\u00f3n mi-length el tama\u00f1o del problema viene dado por la longitud de la lista. El coste espacial de mi-lenght es O(n) , siendo n la longitud de la lista. 1.3. El coste depende del n\u00famero de llamadas a la recursi\u00f3n \u00b6 Veamos con un ejemplo que el coste de las llamadas recursivas puede dispararse. Supongamos la famosa secuencia de Fibonacci : 0,1,1,2,3,5,8,13,... Formulaci\u00f3n matem\u00e1tica de la secuencia de Fibonacci: Fibonacci(n) = Fibonacci(n-1) + Fibonacci(n-2) Fibonacci(0) = 0 Fibonacci(1) = 1 Formulaci\u00f3n recursiva en Scheme: ( define ( fib n ) ( cond (( = n 0 ) 0 ) (( = n 1 ) 1 ) ( else ( + ( fib ( - n 1 )) ( fib ( - n 2 )))))) Evaluaci\u00f3n de una llamada a Fibonacci: Cada llamada a la recursi\u00f3n produce otras dos llamadas, por lo que el n\u00famero de llamadas finales es 2^n siendo n el n\u00famero que se pasa a la funci\u00f3n. El coste espacial y temporal es exponencial, O(2^n). Esto hace inviable utilizar esta implementaci\u00f3n para realizar el c\u00e1lculo de la funci\u00f3n. Puedes comprobarlo intentando evaluar en el int\u00e9rprete (fib 35) . 2. Soluciones al coste de la recursi\u00f3n: procesos iterativos \u00b6 Diferenciamos entre procedimientos y procesos: un procedimiento es un algoritmo y un proceso es la ejecuci\u00f3n de ese algoritmo. Es posible definir procedimientos recursivos que generen procesos iterativos (como los bucles en programaci\u00f3n imperativa) en los que no se dejen llamadas recursivas en espera ni se incremente la pila de la recursi\u00f3n . Para ello construimos la recursi\u00f3n de forma que en cada llamada se haga un c\u00e1lculo parcial y en el caso base se pueda devolver directamente el resultado obtenido. Este estilo de recursi\u00f3n se denomina recursi\u00f3n por la cola ( tail recursion , en ingl\u00e9s). Se puede realizar una implementaci\u00f3n eficiente de la ejecuci\u00f3n del proceso, eliminando la pila de la recursi\u00f3n. 2.1. Factorial iterativo \u00b6 Empezamos a explicar la recursi\u00f3n por la cola con un ejemplo muy sencillo: la versi\u00f3n iterativa de la t\u00edpica funci\u00f3n factorial . Le pondremos de nombre a la funci\u00f3n factorial-iter : ( define ( factorial n ) ( fact-iter n n )) ( define ( fact-iter n result ) ( if ( = n 1 ) result ( fact-iter ( - n 1 ) ( * result ( - n 1 )) ))) La funci\u00f3n (fact-iter n result) es la que define el proceso iterativo. Su argumento n es el valor del que hay que calcular el factorial y el argumento result es un par\u00e1metro adicional en el que se van guardando los resultados intermedios. En cada llamada recursiva, n se va haciendo cada vez m\u00e1s peque\u00f1o y en result se va acumulando el c\u00e1lculo del factorial. Al final de la recursi\u00f3n el factorial debe estar calculado en result y se devuelve. Veamos la secuencia de llamadas: (factorial 4) (factorial-iter 4 4) (factorial-iter 3 4*3=12) (factorial-iter 2 12*2=24) (factorial-iter 1 24*1=24) 24 Antes de realizar cada llamada recursiva se realiza el c\u00e1lculo del resultado parcial, que se guarda en el par\u00e1metro result . Despu\u00e9s se realiza la llamada con el nuevo valor calculado de n y de result . Al final, cuando n vale 1 se devuelve el valor calculado de result . Este valor es el resultado completo de la recursi\u00f3n, ya que no hay que hacer ninguna operaci\u00f3n m\u00e1s con \u00e9l. A diferencia de los procesos recursivos, en los que se quedan llamadas en espera en la pila de la recursi\u00f3n, en los procesos iterativos no hay ninguna llamada en espera. El resultado devuelto por el caso base es directamente la soluci\u00f3n de la recursi\u00f3n, no queda nada por hacer con este resultado. Es importante el valor inicial de resultado . La funci\u00f3n factorial se encarga de inicializar este par\u00e1metro. En este caso es el mismo valor del n\u00famero n a calcular el factorial. La secuencia de llamadas recursivas acumula en la variable result el valor del factorial: 4 * 3 * 2 * 1 = 24 2.2. Versi\u00f3n iterativa de mi-length \u00b6 Veamos un segundo ejemplo. \u00bfC\u00f3mo ser\u00eda la versi\u00f3n iterativa de mi-length , la funci\u00f3n que calcula la logitud de una lista?. Tenemos que a\u00f1adir un par\u00e1metro adicional en el que iremos acumulando el resultado parcial. En este caso, cada vez que llamemos a la recursi\u00f3n eliminado un elemento de la lista, incrementaremos en 1 el valor del resultado. Para que funcione bien este enfoque, debemos inicializar este resultado a 0. La soluci\u00f3n es la siguiente: ( define ( mi-length lista ) ( mi-length-iter lista 0 )) ( define ( mi-length-iter lista result ) ( if ( null? lista ) result ( mi-length-iter ( rest lista ) ( + result 1 )))) Fijaros que, al igual que en la versi\u00f3n iterativa de factorial, no hay ninguna llamada a ning\u00fana funci\u00f3n que recoja el resultado de la llamada recursiva y haga algo con \u00e9l. Directamente el resultado de la llamada recursiva es el resultado final de la recursi\u00f3n. 2.3. Funci\u00f3n suma-lista usando recursi\u00f3n por la cola \u00b6 Veamos otro ejemplo. Supongamos que queremos calcular usando recursi\u00f3n por la cola la suma de los n\u00fameros de una lista. Deber\u00edamos a\u00f1adir un par\u00e1metro adicional en el que vamos acumulando esa suma. Inicializaremos a 0 ese par\u00e1metro e iremos en cada llamada recursiva acumulando el primer elemento de la lista: ( define ( suma-lista lista ) ( suma-lista-iter lista 0 )) ( define ( suma-lista-iter lista result ) ( if ( null? lista ) result ( suma-lista-iter ( rest lista ) ( + result ( first lista ))))) 2.4. Caracter\u00edsticas de los procesos iterativos \u00b6 Un resumen de las caracter\u00edsticas de los procesos iterativos resultantes de hacer una recursi\u00f3n por la cola: La recursi\u00f3n resultante es menos elegante. Se necesita una par\u00e1metro adicional en el que se van acumulando los resultados parciales. La \u00faltima llamada a la recursi\u00f3n devuelve el valor acumulado. El proceso resultante de la recursi\u00f3n es iterativo en el sentido de que no deja llamadas en espera ni incurre en coste espacial. 2.5. Fibonacci iterativo \u00b6 Cualquier programa recursivo se puede transformar en otro que genera un proceso iterativo. En general, las versiones iterativas son menos intuitivas y m\u00e1s dif\u00edciles de entender y depurar. Veamos, por ejemplo, la formulaci\u00f3n iterativa de Fibonacci: ( define ( fib n ) ( fib-iter 1 0 n )) ( define ( fib-iter a b count ) ( if ( = count 0 ) b ( fib-iter ( + a b ) a ( - count 1 )))) La secuencia de llamadas recursivas ser\u00eda la siguiente: (fib 6) (fib-iter 1 0 6) (fib-iter 1+0=1 1 5) (fib-iter 1+1=2 1 4) (fib-iter 2+1=3 2 3) (fib-iter 3+2=5 3 2) (fib-iter 5+3=8 5 1) (fib-iter 8+5=13 8 0) 8 En la llamada recursiva n , el par\u00e1metro a guarda el valor de fibonacci n+1 y el par\u00e1metro b guarda el valor de fibonacci n , que es el que se devuelve. Conseguimos n llamadas inicializando count a n y decrementando el par\u00e1metro en 1 cada vez. 2.6. Tri\u00e1ngulo de Pascal \u00b6 El tri\u00e1ngulo de Pascal es el siguiente tri\u00e1ngulo de n\u00fameros. 1 1 1 1 2 1 1 3 3 1 1 4 6 4 1 1 5 10 10 5 1 1 6 15 20 15 6 1 1 7 21 35 35 21 7 1 ... Si numeramos las filas y columnas empezando a contar por 0, la expresi\u00f3n general del valor en una fila y columna determinada se puede obtener con la siguiente definici\u00f3n recursiva: Pascal (n, 0) = 1 Pascal (n, n) = 1 Pascal (fila, columna) = Pascal (fila-1,columna-1) + Pascal (fila-1, columna) La funci\u00f3n s\u00f3lo est\u00e1 definida para valores de columna menores o iguales que fila . En Scheme es f\u00e1cil escribir una funci\u00f3n recursiva que implemente la definici\u00f3n anterior: ( define ( pascal fila col ) ( cond (( = col 0 ) 1 ) (( = col fila ) 1 ) ( else ( + ( pascal ( - fila 1 ) ( - col 1 )) ( pascal ( - fila 1 ) col ) )))) ( pascal 4 2 ) ; \u21d2 6 ( pascal 8 4 ) ; \u21d2 70 ( pascal 27 13 ) ; \u21d2 20058300 Hay que llamar a la funci\u00f3n con un valor de col menor o igual que fila . En el caso en que se pase un valor col mayor que fila la recursi\u00f3n no termina y se entra en un bucle infinito. La funci\u00f3n tiene una formulaci\u00f3n sencilla y funciona correctamente. Sin embargo, el coste de esta recursi\u00f3n es tambi\u00e9n exponencial, igual que pasaba en el caso de la secuencia de fibonacci. Por ejemplo, la \u00faltima expresi\u00f3n (pascal 27 13) tarda un buen rato en devolver el resultado. Ser\u00eda imposible calcular el valor de n\u00fameros de Pascal un poco m\u00e1s grandes, como (pascal 40 20) . Veamos c\u00f3mo se puede conseguir una versi\u00f3n iterativa. La idea es definir una funci\u00f3n iterativa pascal-fila a la que le pasamos el n\u00famero de fila n y nos devuelve la lista de n+1 n\u00fameros que constituyen la fila n del tri\u00e1ngulo de Pascal: fila 0 = (1) fila 1 = (1 1) fila 2 = (1 2 1) fila 3 = (1 3 3 1) fila 4 = (1 4 6 4 1) ... Esta funci\u00f3n necesitar\u00e1 un par\u00e1metro adicional ( lista-fila ) que se inicializa con la lista (1) y en el que se va guardando cada fila sucesiva. Esta fila va creciendo hasta que llegamos a la fila que tenemos que devolver. Hay que hacer la iteraci\u00f3n n veces, por lo que vamos decrementando el par\u00e1metro n hasta que se llega a 0. Para implementar esta funci\u00f3n usamos otra llamada (pascal-sig-fila lista-fila) que recibe una fila del tri\u00e1ngulo y devuelve la siguiente. Por ejemplo: ( pascal-sig-fila ' ( 1 3 3 1 )) ; \u21d2 (1 4 6 4 1) Esta funci\u00f3n la implementamos con una funci\u00f3n recursiva auxiliar (esta es recursiva pura) llamada (pascal-suma-dos-a-dos lista-fila) que es la que se encarga de realizar el c\u00e1lculo de la nueva fila. No es necesario convertir esta funci\u00f3n a iterativa porque no genera un coste exponencial. El c\u00f3digo completo es el siguiente: ( define ( pascal fila col ) ( list-ref ( pascal-fila ' ( 1 ) fila ) col )) ( define ( pascal-fila lista-fila n ) ( if ( = 0 n ) lista-fila ( pascal-fila ( pascal-sig-fila lista-fila ) ( - n 1 )))) ( define ( pascal-sig-fila lista-fila ) ( append ' ( 1 ) ( pascal-suma-dos-a-dos lista-fila ) ' ( 1 ))) ( define ( pascal-suma-dos-a-dos lista-fila ) ( if ( null? ( rest lista-fila )) ' () ( cons ( + ( first lista-fila ) ( first ( rest lista-fila ))) ( pascal-suma-dos-a-dos ( rest lista-fila ))))) Con esta implementaci\u00f3n ya no se tiene un coste exponencial y se puede calcular el valor de n\u00fameros como Pascal(40, 20): ( pascal 40 20 ) ; \u21d2 137846528820 3. Soluciones al coste de la recursi\u00f3n: memoization \u00b6 Una alternativa que mantiene la elegancia de los procesos recursivos y la eficiencia de los iterativos es la memoization . Si miramos la traza de (fib 4) podemos ver que el coste est\u00e1 producido por la repetici\u00f3n de llamadas; por ejemplo (fib 3) se eval\u00faa 2 veces. En programaci\u00f3n funcional la llamada a (fib 3) siempre va a devolver el mismo valor. La idea de la memoization es guardar el valor devuelto por la cada llamada en alguna estructura (una lista de asociaci\u00f3n, por ejemplo) y no volver a realizar la llamada a la recursi\u00f3n las siguientes veces. 3.1. Fibonacci con memoization \u00b6 Para implementar la memoization necesitamos usar un diccionario con los m\u00e9todos put y get que actualizan su informaci\u00f3n con mutaci\u00f3n. La funci\u00f3n (crea-diccionario) devuelve un diccionario vac\u00edo. La funci\u00f3n (put key value dic) asocia un valor a una clave, la guarda en el diccionario (con mutaci\u00f3n) y devuelve el valor. La funci\u00f3n (get key dic) devuelve el valor del diccionario asociado a una clave. En el caso en que no exista ning\u00fan valor se devuelve #f . Ejemplos: ( define mi-dic ( crea-diccionario )) ( put 1 10 mi-dic ) ; \u21d2 10 ( get 1 mi-dic ) ; \u21d2 10 ( get 2 mi-dic ) ; \u21d2 #f Estos m\u00e9todos son imperativos porque modifican (mutan) la estructura de datos que pasamos como par\u00e1metro. La implementaci\u00f3n de estas funciones est\u00e1 incluidas en el fichero lpp.rkt . La funci\u00f3n fib-memo realiza el c\u00e1lculo de la serie de Fibonacci utilizando exactamente la misma definici\u00f3n recursiva original, pero a\u00f1adiendo la t\u00e9cnica de memoization : lo primero que hacemos para calcular el n\u00famero de fibonacci n , antes de llamar a la recursi\u00f3n, es comprobar si est\u00e1 ya guardado en la lista de asociaci\u00f3n. En el caso en que est\u00e9, lo devolvemos. S\u00f3lo cuando el n\u00famero no est\u00e1 calculado llamamos a la recursi\u00f3n para calcularlo. La implementaci\u00f3n se muestra a continuaci\u00f3n. Vemos que para devolver el n\u00famero de fibonacci n se comprueba si ya est\u00e1 guardado en la lista. S\u00f3lo en el caso en que no est\u00e9 guardado se llama a la recursi\u00f3n para calcularlo y guardarlo. La funci\u00f3n put que guarda el nuevo valor calculado tambi\u00e9n lo devuelve. ( define ( fib-memo n dic ) ( cond (( = n 0 ) 0 ) (( = n 1 ) 1 ) (( not ( equal? ( get n dic ) #f )) ( get n dic )) ( else ( put n ( + ( fib-memo ( - n 1 ) dic ) ( fib-memo ( - n 2 ) dic )) dic )))) Podemos comprobar la diferencia de tiempos de ejecuci\u00f3n entre esta versi\u00f3n y la anterior. El coste de la funci\u00f3n memoizada es O(n). Frente al coste O(2^n) de la versi\u00f3n inicial que la hac\u00eda imposible de utilizar. ( fib-memo 200 lista ) \u21d2 280571172992510140037611932413038677189525 4. Figuras recursivas \u00b6 Vamos a terminar el apartado sobre procedimientos recursivos con un \u00faltimo ejemplo algo distinto de los vistos hasta ahora. Usaremos la recursi\u00f3n para dibujar figuras fractales usando la librer\u00eda de im\u00e1genes de Racket 2htdp/image . 4.1. Librer\u00eda de im\u00e1genes de Racket \u00b6 Racket incluye una librer\u00eda de im\u00e1genes en la que se proporcionan funciones para construir im\u00e1genes. Con esta librer\u00eda se pueden crear im\u00e1genes sencillas como rectas, c\u00edrculos, tri\u00e1ngulos u otras figuras geom\u00e9tricas. Tambi\u00e9n se pueden modificar las im\u00e1genes creadas, rot\u00e1ndolas o escal\u00e1ndolas, y formar otras im\u00e1genes mediante la combinaci\u00f3n de imagenes b\u00e1sicas. Construcci\u00f3n de im\u00e1genes b\u00e1sicas \u00b6 Veamos algunos ejemplos de las primitivas de la librer\u00eda para construir im\u00e1genes b\u00e1sicas. Podemos obtener un c\u00edrculo, un cuadrado, un rect\u00e1ngulo y un tri\u00e1ngulo equil\u00e1tero de la siguiente forma: #lang racket ( require 2htdp/image ) ( circle 30 \"solid\" \"blue\" ) ( square 30 \"outline\" \"black\" ) ( rectangle 80 40 \"solid\" \"gray\" ) ( triangle 40 \"solid\" \"red\" ) Cada instrucci\u00f3n construye la imagen correspondiente. Si lo ejecutamos en el int\u00e9rprete obtendremos lo siguiente: Las im\u00e1genes son mapas de bits y su tama\u00f1o se expresa en p\u00edxeles. En el caso del c\u00edrculo se trata del radio, para el cuadrado indicamos su lado, para el rect\u00e1ngulo la base y la altura y para el tri\u00e1ngulo equil\u00e1tero su lado. Debemos indicar tambi\u00e9n si queremos que la imagen se rellene de forma s\u00f3lida o se dibuje solo el borde. Y tambi\u00e9n su color, mediante una cadena escogida de una lista de colores permitidos . Podemos tambi\u00e9n construir un tri\u00e1ngulo is\u00f3sceles indicando la longitud de sus lados iguales y el \u00e1ngulo entre ellos: ( isosceles-triangle 60 30 \"outline\" \"black\" ) Por \u00faltimo, otra primitiva que vamos a utilizar m\u00e1s adelante es un trazo de una l\u00ednea: ( line 30 30 \"black\" ) Esta funci\u00f3n construye una imagen con una l\u00ednea hasta la posici\u00f3n (30,30) (la coordenada x crece hacia la derecha y la y hacia abajo). Prueba a construir algunas im\u00e1genes usando los comandos anteriores y cambiando sus par\u00e1metros. Operaciones y combinaciones de im\u00e1genes \u00b6 En la librer\u00eda de im\u00e1genes se definen tambi\u00e9n funciones que permiten transformar y combinar im\u00e1genes. Vamos a ver algunos de ellas. Podemos rotar una imagen un \u00e1ngulo, expresado en grados sexagesimales en el sentido contrario de las agujas del reloj. Por ejemplo, podemos rotar el tri\u00e1ngulo is\u00f3sceles anterior: ( define triangulo ( isosceles-triangle 60 30 \"outline\" \"black\" )) ( rotate 90 triangulo ) ; \u21d2 imagen rotada 90 grados en sentido contrario a las agujas del reloj ( rotate -90 triangulo ) ; \u21d2 imagen rotada 90 grados en sentido de las agujas del reloj Podemos tambi\u00e9n combinar im\u00e1genes, agrup\u00e1ndolas con las funciones above y beside . Las dos funciones reciben un n\u00famero variable de argumentos y devuelven una nueva imagen en la que las im\u00e1genes se han colocado unas sobre otras o unas al lado de otras. Por ejemplo: ( above ( ellipse 70 20 \"solid\" \"gray\" ) ( ellipse 50 20 \"solid\" \"darkgray\" ) ( ellipse 30 20 \"solid\" \"dimgray\" ) ( ellipse 10 20 \"solid\" \"black\" )) La llamada anterior devuelve la siguiente imagen: Otro ejemplo: ( beside ( ellipse 20 70 \"solid\" \"gray\" ) ( ellipse 20 50 \"solid\" \"darkgray\" ) ( ellipse 20 30 \"solid\" \"dimgray\" ) ( ellipse 20 10 \"solid\" \"black\" )) Que produce: En los dos ejemplos anteriores las im\u00e1genes agrupadas se alinean en el centro. Si queremos otra alineaci\u00f3n podemos especificarla usando las funciones above/align y beside/align . En el caso de above , que acumula las im\u00e1genes unas sobre otras, podremos especificar si queremos alinearlas a la izquierda o a la derecha: ( above/align \"left\" ( ellipse 70 20 \"solid\" \"yellowgreen\" ) ( ellipse 50 20 \"solid\" \"olivedrab\" ) ( ellipse 30 20 \"solid\" \"darkolivegreen\" ) ( ellipse 10 20 \"solid\" \"darkgreen\" )) ( above/align \"right\" ( ellipse 70 20 \"solid\" \"gold\" ) ( ellipse 50 20 \"solid\" \"goldenrod\" ) ( ellipse 30 20 \"solid\" \"darkgoldenrod\" ) ( ellipse 10 20 \"solid\" \"sienna\" )) En el caso de beside , que acumula las im\u00e1genes unas junto a otras, podemos especificar si queremos alinearla arriba o abajo: ( beside/align \"top\" ( ellipse 20 70 \"solid\" \"mediumorchid\" ) ( ellipse 20 50 \"solid\" \"darkorchid\" ) ( ellipse 20 30 \"solid\" \"purple\" ) ( ellipse 20 10 \"solid\" \"indigo\" )) ( beside/align \"bottom\" ( ellipse 20 70 \"solid\" \"lightsteelblue\" ) ( ellipse 20 50 \"solid\" \"mediumslateblue\" ) ( ellipse 20 30 \"solid\" \"slateblue\" ) ( ellipse 20 10 \"solid\" \"navy\" )) Podemos combinar todas las funciones anteriores para construir figuras complejas. Por ejemplo: ( rotate 45 ( above ( triangle 40 \"solid\" \"orange\" ) ( beside ( rectangle 40 30 \"solid\" \"black\" ) ( rectangle 40 30 \"solid\" \"olivedrab\" )))) Prueba a realizar algunas figuras combinando figuras b\u00e1sicas con las funciones anteriores. 4.2. Tri\u00e1ngulo de Sierpinski \u00b6 Vamos a utilizar las funciones anteriores que construyen im\u00e1genes para construir una figura fractal, el denominado ri\u00e1ngulo de Sierpinski, usando la recursi\u00f3n. Tri\u00e1ngulo de Sierpinski \u00bfVes alguna recursi\u00f3n en la figura? \u00bfCu\u00e1l podr\u00eda ser el par\u00e1metro de la funci\u00f3n que la dibujara? \u00bfSe te ocurre un algoritmo recursivo que la dibuje, usando las funciones de combinaci\u00f3n de im\u00e1genes vistas? La figura es autosimilar (una caracter\u00edstica de las figuras fractales). Una parte de la figura es id\u00e9ntica a la figura total, pero reducida de escala. Esto nos da una pista de que es posible dibujar la figura con un algoritmo recursivo. Para intentar encontrar una forma de enfocar el problema, vamos a pensarlo de la siguiente forma: supongamos que tenemos tres tri\u00e1ngulos de Sierpinski de anchura x . \u00bfC\u00f3mo podr\u00edamos construir el tri\u00e1ngulo de Sierpinski de anchura 2*x ? Lo podr\u00edamos hacer combinando las tres im\u00e1genes de la siguiente forma: Juntamos 2 tri\u00e1ngulos uno junto a otro. Sobre la figura resultante colocamos (alineada en el centro) el tri\u00e1ngulo restante. En la siguiente figura se muestra el esquema de esta combinaci\u00f3n. Cada rect\u00e1ngulo representa la imagen de sierpinski de anchura x y la combinaci\u00f3n representa la imagen de anchura 2*x . El algoritmo recursivo se basa en la misma idea, pero hacia atr\u00e1s . Dibujamos un tri\u00e1ngulo de anchura x bas\u00e1ndonos en 3 llamadas recursivas a tri\u00e1ngulos m\u00e1s peque\u00f1os (de anchura x/2 ). En el caso base, cuando x sea menor que un umbral h , dibujaremos un tri\u00e1ngulo elemental de base h . Veamos c\u00f3mo hacerlo con la librer\u00eda de im\u00e1genes de Racket. 4.2.1. Caso base de la recursi\u00f3n \u00b6 Para construir la imagen elemental del tri\u00e1ngulo de Sierpinski necesitamos un tri\u00e1ngulo is\u00f3sceles de \u00e1ngulo 90 y base h . Tal y como muestra la siguiente figura, podemos dividir este tri\u00e1ngulo en dos mitades. Si el \u00e1ngulo superior es 90 grados, su mitad ser\u00e1 de 45 grados, por lo que los dos subtri\u00e1ngulos ser\u00e1n tri\u00e1ngulos rect\u00e1ngulos cuyos catetos medir\u00e1n h/2 . La hipotenusa de esos tri\u00e1ngulos son los lados del tri\u00e1ngulo is\u00f3sceles original. La altura del tri\u00e1ngulo is\u00f3sceles original ser\u00e1 tambi\u00e9n h/2 . La hipotenusa de un tri\u00e1ngulo rect\u00e1ngulo con dos catetos de longitud x se calcula con la siguiente expresi\u00f3n: hipot(x) = \\sqrt{x^2+x^2} = x \\sqrt{2} hipot(x) = \\sqrt{x^2+x^2} = x \\sqrt{2} Lo podemos expresar en Racket: ( define ( hipotenusa x ) ( * x ( sqrt 2 ))) Una vez definida la funci\u00f3n hipotenusa podemos dibujar el tri\u00e1ngulo de Sierpinski elemental de base h . Ser\u00e1 un tri\u00e1ngulo is\u00f3sceles de \u00e1ngulo 90 grados y de longitud de lado hipotenusa(h/2) : ( define ( sierpinski-elem base ) ( isosceles-triangle ( hipotenusa ( / base 2 )) 90 \"outline\" \"black\" )) Por ejemplo, la llamada a ( sierpinski-elem 40 ) produce la siguiente imagen: 4.2.2. Caso general de la recursi\u00f3n \u00b6 El caso general de la recursi\u00f3n para dibujar el tri\u00e1ngulo de Sierpinski de ancho x se construye llamando a la recursi\u00f3n para que construya el tri\u00e1ngulo de ancho x/2 y componiendo la imagen resultante con el patr\u00f3n visto anteriormente. El c\u00f3digo de la funci\u00f3n completa es el siguiente: ( define ( sierpinski ancho ) ( if ( < ancho 10 ) ( sierpinski-elem ancho ) ( above ( sierpinski ( / ancho 2 )) ( beside ( sierpinski ( / ancho 2 )) ( sierpinski ( / ancho 2 )))))) Si el ancho es menor que un umbral (10) se dibuja el tri\u00e1ngulo elemental. Si el ancho es mayor o igual a 10 se hacen tres llamadas recursivas a sierpienski con el ancho / 2 . Cada llamada recursiva devolver\u00e1 la imagen con el tri\u00e1ngulo de sierpinski m\u00e1s peque\u00f1o. La llamada a beside juntar\u00e1 las dos im\u00e1genes inferiores. La llamada a above colocar\u00e1 el tercer tri\u00e1ngulo sobre la composici\u00f3n anterior, centrado en el centro. Un ejemplo de la ejecuci\u00f3n: 4.3. Curva de Hilbert \u00b6 La curva de Hilbert es una curva fractal que tiene la propiedad de rellenar completamente el plano. Su dibujo tiene una formulaci\u00f3n recursiva: La imagen H2 se puede componer a partir de cuatro im\u00e1genes H1 siguiendo un patr\u00f3n. Es el mismo patr\u00f3n con el que se puede componer la imagen H3 a partir de cuatro im\u00e1genes H2. El patr\u00f3n se muestra en la siguiente funci\u00f3n (componer imagen) : ( define trazo-horizontal ( line 16 0 \"black\" )) ( define trazo-vertical ( rotate 90 trazo-horizontal )) ( define ( componer imagen ) ( beside ( above/align \"left\" ( beside/align \"bottom\" imagen trazo-horizontal ) trazo-vertical ( rotate -90 imagen )) ( above/align \"right\" imagen trazo-vertical ( rotate 90 imagen )))) La primera llamada a above/align compone una imagen juntando la imagen original con un trazo horizontal y apilando (con una alineaci\u00f3n a la izquierda) esta imagen sobre un trazo vertical y sobre la imagen original girada 90 grados en el sentido de las agujas del reloj. La segunda llamada a above/align construye otra imagen apilando (con una alineaci\u00f3n a la derecha) la imagen original, un trazo vertical y la imagen rotada 90 grados en sentido contrario a las agujas del reloj. Por \u00faltimo la llamada a beside junta las dos im\u00e1genes anteriores. Podemos ver un ejemplo del funcionamiento de esta composici\u00f3n usando una imagen base formada por un cuadrado con un tri\u00e1ngulo dentro. ( overlay ( triangle 20 \"solid\" \"green\" ) ( rectangle 20 20 \"solid\" \"black\" )) ) Si llamamos a componer con la imagen anterior podemos ver que se construye el patr\u00f3n b\u00e1sico de la curva de Hilbert, el que construye la imagen H2 a partir de H1. ( define imagen ( overlay ( triangle 20 \"solid\" \"green\" ) ( rectangle 20 20 \"solid\" \"black\" ))) imagen ( componer imagen ) Una vez entendido este patr\u00f3n de composici\u00f3n, podemos ya formular el algoritmo recursivo: ( define ( hilbert nivel ) ( if ( = 1 nivel ) ( beside/align \"top\" trazo-vertical trazo-horizontal trazo-vertical ) ( componer ( hilbert ( - nivel 1 ))))) El caso base es el nivel 1, en el que se construye el trazo b\u00e1sico de la curva de Hilbert. Para cualquier nivel n mayor que 1, se llama a la recursi\u00f3n para formar la curva de Hilbert de nivel n-1 y, con la imagen resultante, se llama a la funci\u00f3n componer . En la siguiente imagen se muestran distintas llamadas a la funci\u00f3n hilbert : 5. Bibliograf\u00eda \u00b6 Cap\u00edtulos del libro Structure and Intepretation of Computer Programs : 1.2 - Procedures and the Processes They Generate 1.2.1 - Linear Recursion and Iteration 1.2.2 - Tree Recursion Manual de Racket: Librer\u00eda image.rkt Image Guide Lenguajes y Paradigmas de Programaci\u00f3n, curso 2021-22 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Domingo Gallardo, Cristina Pomares, Antonio Bot\u00eda, Francisco Mart\u00ednez","title":"Tema 3: Procedimientos recursivos"},{"location":"teoria/tema03-procedimientos-recursivos/tema03-procedimientos-recursivos.html#tema-3-procedimientos-recursivos","text":"Ya hemos visto muchos ejemplos de funciones recursivas. Una funci\u00f3n es recursiva cuando se llama a si misma. Una vez que uno se acostumbra a su uso, se comprueba que la recursi\u00f3n es una forma mucho m\u00e1s natural que la iteraci\u00f3n de expresar un gran n\u00famero de funciones y procedimientos. La formulaci\u00f3n matem\u00e1tica de la recursi\u00f3n es sencilla de entender, pero su implementaci\u00f3n en un lenguaje de programaci\u00f3n no lo es tanto. El primer lenguaje de programaci\u00f3n que permiti\u00f3 el uso de expresiones recursivas fue el Lisp. En el momento de su creaci\u00f3n exist\u00eda ya el Fortran, que no permit\u00eda que una funci\u00f3n se llamase a si misma. Ya hemos visto la utilidad de la recursi\u00f3n en muchos ejemplos para recorrer listas, para filtrarlas, etc. En este tema veremos algunos aspectos negativos de la recursi\u00f3n: su coste espacial y temporal. Veremos que hay soluciones a estos problemas, cambiando el estilo de la recursi\u00f3n y generando procesos iterativos o usando un enfoque autom\u00e1tico llamado memoization en el que se guardan los resultados de cada llamada recursiva. Por \u00faltimo, veremos un \u00faltimo ejemplo curioso e interesante de la recursi\u00f3n para realizar figuras fractales con gr\u00e1ficos de tortuga.","title":"Tema 3: Procedimientos recursivos"},{"location":"teoria/tema03-procedimientos-recursivos/tema03-procedimientos-recursivos.html#1-el-coste-de-la-recursion","text":"Hasta ahora hemos estudiado el dise\u00f1o de funciones recursivas. Vamos a tratar por primera vez su coste. Veremos que hay casos en los que es prohibitivo utilizar la recursi\u00f3n tal y como la hemos visto. Y veremos tambi\u00e9n que existen soluciones para esos casos.","title":"1. El coste de la recursi\u00f3n"},{"location":"teoria/tema03-procedimientos-recursivos/tema03-procedimientos-recursivos.html#11-la-pila-de-la-recursion","text":"Vamos a estudiar el comportamiento de la evaluaci\u00f3n de una llamada a una funci\u00f3n recursiva. Supongamos la funci\u00f3n mi-length : ( define ( mi-length items ) ( if ( null? items ) 0 ( + 1 ( mi-length ( rest items ))))) Examinamos c\u00f3mo se eval\u00faan las llamadas recursivas: (mi-length '(a b c d)) (+ 1 (mi-length '(b c d))) (+ 1 (+ 1 (mi-length '(c d)))) (+ 1 (+ 1 (+ 1 (mi-length '(d))))) (+ 1 (+ 1 (+ 1 (+ 1 (mi-length '()))))) (+ 1 (+ 1 (+ 1 (+ 1 0)))) (+ 1 (+ 1 (+ 1 1))) (+ 1 (+ 1 2)) (+ 1 3) 4 Cada llamada a la recursi\u00f3n deja una funci\u00f3n en espera de ser evaluada cuando la recursi\u00f3n devuelva un valor (en el caso anterior las funciones suma). Estas llamadas en espera, junto con sus argumentos, se almacenan en la pila de la recursi\u00f3n . Cuando la recursi\u00f3n devuelve un valor, los valores se recuperan de la pila, se realiza la llamada y se devuelve el valor a la anterior llamada en espera. Si la recursi\u00f3n est\u00e1 mal hecha y nunca termina se genera un stack overflow porque la memoria que se almacena en la pila sobrepasa la memoria reservada para el int\u00e9rprete DrRacket.","title":"1.1. La pila de la recursi\u00f3n"},{"location":"teoria/tema03-procedimientos-recursivos/tema03-procedimientos-recursivos.html#12-coste-espacial-de-la-recursion","text":"El coste espacial de un programa es una funci\u00f3n que relaciona la memoria consumida por una llamada para resolver un problema con alguna variable que determina el tama\u00f1o del problema a resolver. En el caso de la funci\u00f3n mi-length el tama\u00f1o del problema viene dado por la longitud de la lista. El coste espacial de mi-lenght es O(n) , siendo n la longitud de la lista.","title":"1.2. Coste espacial de la recursi\u00f3n"},{"location":"teoria/tema03-procedimientos-recursivos/tema03-procedimientos-recursivos.html#13-el-coste-depende-del-numero-de-llamadas-a-la-recursion","text":"Veamos con un ejemplo que el coste de las llamadas recursivas puede dispararse. Supongamos la famosa secuencia de Fibonacci : 0,1,1,2,3,5,8,13,... Formulaci\u00f3n matem\u00e1tica de la secuencia de Fibonacci: Fibonacci(n) = Fibonacci(n-1) + Fibonacci(n-2) Fibonacci(0) = 0 Fibonacci(1) = 1 Formulaci\u00f3n recursiva en Scheme: ( define ( fib n ) ( cond (( = n 0 ) 0 ) (( = n 1 ) 1 ) ( else ( + ( fib ( - n 1 )) ( fib ( - n 2 )))))) Evaluaci\u00f3n de una llamada a Fibonacci: Cada llamada a la recursi\u00f3n produce otras dos llamadas, por lo que el n\u00famero de llamadas finales es 2^n siendo n el n\u00famero que se pasa a la funci\u00f3n. El coste espacial y temporal es exponencial, O(2^n). Esto hace inviable utilizar esta implementaci\u00f3n para realizar el c\u00e1lculo de la funci\u00f3n. Puedes comprobarlo intentando evaluar en el int\u00e9rprete (fib 35) .","title":"1.3. El coste depende del n\u00famero de llamadas a la recursi\u00f3n"},{"location":"teoria/tema03-procedimientos-recursivos/tema03-procedimientos-recursivos.html#2-soluciones-al-coste-de-la-recursion-procesos-iterativos","text":"Diferenciamos entre procedimientos y procesos: un procedimiento es un algoritmo y un proceso es la ejecuci\u00f3n de ese algoritmo. Es posible definir procedimientos recursivos que generen procesos iterativos (como los bucles en programaci\u00f3n imperativa) en los que no se dejen llamadas recursivas en espera ni se incremente la pila de la recursi\u00f3n . Para ello construimos la recursi\u00f3n de forma que en cada llamada se haga un c\u00e1lculo parcial y en el caso base se pueda devolver directamente el resultado obtenido. Este estilo de recursi\u00f3n se denomina recursi\u00f3n por la cola ( tail recursion , en ingl\u00e9s). Se puede realizar una implementaci\u00f3n eficiente de la ejecuci\u00f3n del proceso, eliminando la pila de la recursi\u00f3n.","title":"2. Soluciones al coste de la recursi\u00f3n: procesos iterativos"},{"location":"teoria/tema03-procedimientos-recursivos/tema03-procedimientos-recursivos.html#21-factorial-iterativo","text":"Empezamos a explicar la recursi\u00f3n por la cola con un ejemplo muy sencillo: la versi\u00f3n iterativa de la t\u00edpica funci\u00f3n factorial . Le pondremos de nombre a la funci\u00f3n factorial-iter : ( define ( factorial n ) ( fact-iter n n )) ( define ( fact-iter n result ) ( if ( = n 1 ) result ( fact-iter ( - n 1 ) ( * result ( - n 1 )) ))) La funci\u00f3n (fact-iter n result) es la que define el proceso iterativo. Su argumento n es el valor del que hay que calcular el factorial y el argumento result es un par\u00e1metro adicional en el que se van guardando los resultados intermedios. En cada llamada recursiva, n se va haciendo cada vez m\u00e1s peque\u00f1o y en result se va acumulando el c\u00e1lculo del factorial. Al final de la recursi\u00f3n el factorial debe estar calculado en result y se devuelve. Veamos la secuencia de llamadas: (factorial 4) (factorial-iter 4 4) (factorial-iter 3 4*3=12) (factorial-iter 2 12*2=24) (factorial-iter 1 24*1=24) 24 Antes de realizar cada llamada recursiva se realiza el c\u00e1lculo del resultado parcial, que se guarda en el par\u00e1metro result . Despu\u00e9s se realiza la llamada con el nuevo valor calculado de n y de result . Al final, cuando n vale 1 se devuelve el valor calculado de result . Este valor es el resultado completo de la recursi\u00f3n, ya que no hay que hacer ninguna operaci\u00f3n m\u00e1s con \u00e9l. A diferencia de los procesos recursivos, en los que se quedan llamadas en espera en la pila de la recursi\u00f3n, en los procesos iterativos no hay ninguna llamada en espera. El resultado devuelto por el caso base es directamente la soluci\u00f3n de la recursi\u00f3n, no queda nada por hacer con este resultado. Es importante el valor inicial de resultado . La funci\u00f3n factorial se encarga de inicializar este par\u00e1metro. En este caso es el mismo valor del n\u00famero n a calcular el factorial. La secuencia de llamadas recursivas acumula en la variable result el valor del factorial: 4 * 3 * 2 * 1 = 24","title":"2.1. Factorial iterativo"},{"location":"teoria/tema03-procedimientos-recursivos/tema03-procedimientos-recursivos.html#22-version-iterativa-de-mi-length","text":"Veamos un segundo ejemplo. \u00bfC\u00f3mo ser\u00eda la versi\u00f3n iterativa de mi-length , la funci\u00f3n que calcula la logitud de una lista?. Tenemos que a\u00f1adir un par\u00e1metro adicional en el que iremos acumulando el resultado parcial. En este caso, cada vez que llamemos a la recursi\u00f3n eliminado un elemento de la lista, incrementaremos en 1 el valor del resultado. Para que funcione bien este enfoque, debemos inicializar este resultado a 0. La soluci\u00f3n es la siguiente: ( define ( mi-length lista ) ( mi-length-iter lista 0 )) ( define ( mi-length-iter lista result ) ( if ( null? lista ) result ( mi-length-iter ( rest lista ) ( + result 1 )))) Fijaros que, al igual que en la versi\u00f3n iterativa de factorial, no hay ninguna llamada a ning\u00fana funci\u00f3n que recoja el resultado de la llamada recursiva y haga algo con \u00e9l. Directamente el resultado de la llamada recursiva es el resultado final de la recursi\u00f3n.","title":"2.2. Versi\u00f3n iterativa de mi-length"},{"location":"teoria/tema03-procedimientos-recursivos/tema03-procedimientos-recursivos.html#23-funcion-suma-lista-usando-recursion-por-la-cola","text":"Veamos otro ejemplo. Supongamos que queremos calcular usando recursi\u00f3n por la cola la suma de los n\u00fameros de una lista. Deber\u00edamos a\u00f1adir un par\u00e1metro adicional en el que vamos acumulando esa suma. Inicializaremos a 0 ese par\u00e1metro e iremos en cada llamada recursiva acumulando el primer elemento de la lista: ( define ( suma-lista lista ) ( suma-lista-iter lista 0 )) ( define ( suma-lista-iter lista result ) ( if ( null? lista ) result ( suma-lista-iter ( rest lista ) ( + result ( first lista )))))","title":"2.3. Funci\u00f3n suma-lista usando recursi\u00f3n por la cola"},{"location":"teoria/tema03-procedimientos-recursivos/tema03-procedimientos-recursivos.html#24-caracteristicas-de-los-procesos-iterativos","text":"Un resumen de las caracter\u00edsticas de los procesos iterativos resultantes de hacer una recursi\u00f3n por la cola: La recursi\u00f3n resultante es menos elegante. Se necesita una par\u00e1metro adicional en el que se van acumulando los resultados parciales. La \u00faltima llamada a la recursi\u00f3n devuelve el valor acumulado. El proceso resultante de la recursi\u00f3n es iterativo en el sentido de que no deja llamadas en espera ni incurre en coste espacial.","title":"2.4. Caracter\u00edsticas de los procesos iterativos"},{"location":"teoria/tema03-procedimientos-recursivos/tema03-procedimientos-recursivos.html#25-fibonacci-iterativo","text":"Cualquier programa recursivo se puede transformar en otro que genera un proceso iterativo. En general, las versiones iterativas son menos intuitivas y m\u00e1s dif\u00edciles de entender y depurar. Veamos, por ejemplo, la formulaci\u00f3n iterativa de Fibonacci: ( define ( fib n ) ( fib-iter 1 0 n )) ( define ( fib-iter a b count ) ( if ( = count 0 ) b ( fib-iter ( + a b ) a ( - count 1 )))) La secuencia de llamadas recursivas ser\u00eda la siguiente: (fib 6) (fib-iter 1 0 6) (fib-iter 1+0=1 1 5) (fib-iter 1+1=2 1 4) (fib-iter 2+1=3 2 3) (fib-iter 3+2=5 3 2) (fib-iter 5+3=8 5 1) (fib-iter 8+5=13 8 0) 8 En la llamada recursiva n , el par\u00e1metro a guarda el valor de fibonacci n+1 y el par\u00e1metro b guarda el valor de fibonacci n , que es el que se devuelve. Conseguimos n llamadas inicializando count a n y decrementando el par\u00e1metro en 1 cada vez.","title":"2.5. Fibonacci iterativo"},{"location":"teoria/tema03-procedimientos-recursivos/tema03-procedimientos-recursivos.html#26-triangulo-de-pascal","text":"El tri\u00e1ngulo de Pascal es el siguiente tri\u00e1ngulo de n\u00fameros. 1 1 1 1 2 1 1 3 3 1 1 4 6 4 1 1 5 10 10 5 1 1 6 15 20 15 6 1 1 7 21 35 35 21 7 1 ... Si numeramos las filas y columnas empezando a contar por 0, la expresi\u00f3n general del valor en una fila y columna determinada se puede obtener con la siguiente definici\u00f3n recursiva: Pascal (n, 0) = 1 Pascal (n, n) = 1 Pascal (fila, columna) = Pascal (fila-1,columna-1) + Pascal (fila-1, columna) La funci\u00f3n s\u00f3lo est\u00e1 definida para valores de columna menores o iguales que fila . En Scheme es f\u00e1cil escribir una funci\u00f3n recursiva que implemente la definici\u00f3n anterior: ( define ( pascal fila col ) ( cond (( = col 0 ) 1 ) (( = col fila ) 1 ) ( else ( + ( pascal ( - fila 1 ) ( - col 1 )) ( pascal ( - fila 1 ) col ) )))) ( pascal 4 2 ) ; \u21d2 6 ( pascal 8 4 ) ; \u21d2 70 ( pascal 27 13 ) ; \u21d2 20058300 Hay que llamar a la funci\u00f3n con un valor de col menor o igual que fila . En el caso en que se pase un valor col mayor que fila la recursi\u00f3n no termina y se entra en un bucle infinito. La funci\u00f3n tiene una formulaci\u00f3n sencilla y funciona correctamente. Sin embargo, el coste de esta recursi\u00f3n es tambi\u00e9n exponencial, igual que pasaba en el caso de la secuencia de fibonacci. Por ejemplo, la \u00faltima expresi\u00f3n (pascal 27 13) tarda un buen rato en devolver el resultado. Ser\u00eda imposible calcular el valor de n\u00fameros de Pascal un poco m\u00e1s grandes, como (pascal 40 20) . Veamos c\u00f3mo se puede conseguir una versi\u00f3n iterativa. La idea es definir una funci\u00f3n iterativa pascal-fila a la que le pasamos el n\u00famero de fila n y nos devuelve la lista de n+1 n\u00fameros que constituyen la fila n del tri\u00e1ngulo de Pascal: fila 0 = (1) fila 1 = (1 1) fila 2 = (1 2 1) fila 3 = (1 3 3 1) fila 4 = (1 4 6 4 1) ... Esta funci\u00f3n necesitar\u00e1 un par\u00e1metro adicional ( lista-fila ) que se inicializa con la lista (1) y en el que se va guardando cada fila sucesiva. Esta fila va creciendo hasta que llegamos a la fila que tenemos que devolver. Hay que hacer la iteraci\u00f3n n veces, por lo que vamos decrementando el par\u00e1metro n hasta que se llega a 0. Para implementar esta funci\u00f3n usamos otra llamada (pascal-sig-fila lista-fila) que recibe una fila del tri\u00e1ngulo y devuelve la siguiente. Por ejemplo: ( pascal-sig-fila ' ( 1 3 3 1 )) ; \u21d2 (1 4 6 4 1) Esta funci\u00f3n la implementamos con una funci\u00f3n recursiva auxiliar (esta es recursiva pura) llamada (pascal-suma-dos-a-dos lista-fila) que es la que se encarga de realizar el c\u00e1lculo de la nueva fila. No es necesario convertir esta funci\u00f3n a iterativa porque no genera un coste exponencial. El c\u00f3digo completo es el siguiente: ( define ( pascal fila col ) ( list-ref ( pascal-fila ' ( 1 ) fila ) col )) ( define ( pascal-fila lista-fila n ) ( if ( = 0 n ) lista-fila ( pascal-fila ( pascal-sig-fila lista-fila ) ( - n 1 )))) ( define ( pascal-sig-fila lista-fila ) ( append ' ( 1 ) ( pascal-suma-dos-a-dos lista-fila ) ' ( 1 ))) ( define ( pascal-suma-dos-a-dos lista-fila ) ( if ( null? ( rest lista-fila )) ' () ( cons ( + ( first lista-fila ) ( first ( rest lista-fila ))) ( pascal-suma-dos-a-dos ( rest lista-fila ))))) Con esta implementaci\u00f3n ya no se tiene un coste exponencial y se puede calcular el valor de n\u00fameros como Pascal(40, 20): ( pascal 40 20 ) ; \u21d2 137846528820","title":"2.6. Tri\u00e1ngulo de Pascal"},{"location":"teoria/tema03-procedimientos-recursivos/tema03-procedimientos-recursivos.html#3-soluciones-al-coste-de-la-recursion-memoization","text":"Una alternativa que mantiene la elegancia de los procesos recursivos y la eficiencia de los iterativos es la memoization . Si miramos la traza de (fib 4) podemos ver que el coste est\u00e1 producido por la repetici\u00f3n de llamadas; por ejemplo (fib 3) se eval\u00faa 2 veces. En programaci\u00f3n funcional la llamada a (fib 3) siempre va a devolver el mismo valor. La idea de la memoization es guardar el valor devuelto por la cada llamada en alguna estructura (una lista de asociaci\u00f3n, por ejemplo) y no volver a realizar la llamada a la recursi\u00f3n las siguientes veces.","title":"3. Soluciones al coste de la recursi\u00f3n: memoization"},{"location":"teoria/tema03-procedimientos-recursivos/tema03-procedimientos-recursivos.html#31-fibonacci-con-memoization","text":"Para implementar la memoization necesitamos usar un diccionario con los m\u00e9todos put y get que actualizan su informaci\u00f3n con mutaci\u00f3n. La funci\u00f3n (crea-diccionario) devuelve un diccionario vac\u00edo. La funci\u00f3n (put key value dic) asocia un valor a una clave, la guarda en el diccionario (con mutaci\u00f3n) y devuelve el valor. La funci\u00f3n (get key dic) devuelve el valor del diccionario asociado a una clave. En el caso en que no exista ning\u00fan valor se devuelve #f . Ejemplos: ( define mi-dic ( crea-diccionario )) ( put 1 10 mi-dic ) ; \u21d2 10 ( get 1 mi-dic ) ; \u21d2 10 ( get 2 mi-dic ) ; \u21d2 #f Estos m\u00e9todos son imperativos porque modifican (mutan) la estructura de datos que pasamos como par\u00e1metro. La implementaci\u00f3n de estas funciones est\u00e1 incluidas en el fichero lpp.rkt . La funci\u00f3n fib-memo realiza el c\u00e1lculo de la serie de Fibonacci utilizando exactamente la misma definici\u00f3n recursiva original, pero a\u00f1adiendo la t\u00e9cnica de memoization : lo primero que hacemos para calcular el n\u00famero de fibonacci n , antes de llamar a la recursi\u00f3n, es comprobar si est\u00e1 ya guardado en la lista de asociaci\u00f3n. En el caso en que est\u00e9, lo devolvemos. S\u00f3lo cuando el n\u00famero no est\u00e1 calculado llamamos a la recursi\u00f3n para calcularlo. La implementaci\u00f3n se muestra a continuaci\u00f3n. Vemos que para devolver el n\u00famero de fibonacci n se comprueba si ya est\u00e1 guardado en la lista. S\u00f3lo en el caso en que no est\u00e9 guardado se llama a la recursi\u00f3n para calcularlo y guardarlo. La funci\u00f3n put que guarda el nuevo valor calculado tambi\u00e9n lo devuelve. ( define ( fib-memo n dic ) ( cond (( = n 0 ) 0 ) (( = n 1 ) 1 ) (( not ( equal? ( get n dic ) #f )) ( get n dic )) ( else ( put n ( + ( fib-memo ( - n 1 ) dic ) ( fib-memo ( - n 2 ) dic )) dic )))) Podemos comprobar la diferencia de tiempos de ejecuci\u00f3n entre esta versi\u00f3n y la anterior. El coste de la funci\u00f3n memoizada es O(n). Frente al coste O(2^n) de la versi\u00f3n inicial que la hac\u00eda imposible de utilizar. ( fib-memo 200 lista ) \u21d2 280571172992510140037611932413038677189525","title":"3.1. Fibonacci con memoization"},{"location":"teoria/tema03-procedimientos-recursivos/tema03-procedimientos-recursivos.html#4-figuras-recursivas","text":"Vamos a terminar el apartado sobre procedimientos recursivos con un \u00faltimo ejemplo algo distinto de los vistos hasta ahora. Usaremos la recursi\u00f3n para dibujar figuras fractales usando la librer\u00eda de im\u00e1genes de Racket 2htdp/image .","title":"4. Figuras recursivas"},{"location":"teoria/tema03-procedimientos-recursivos/tema03-procedimientos-recursivos.html#41-libreria-de-imagenes-de-racket","text":"Racket incluye una librer\u00eda de im\u00e1genes en la que se proporcionan funciones para construir im\u00e1genes. Con esta librer\u00eda se pueden crear im\u00e1genes sencillas como rectas, c\u00edrculos, tri\u00e1ngulos u otras figuras geom\u00e9tricas. Tambi\u00e9n se pueden modificar las im\u00e1genes creadas, rot\u00e1ndolas o escal\u00e1ndolas, y formar otras im\u00e1genes mediante la combinaci\u00f3n de imagenes b\u00e1sicas.","title":"4.1. Librer\u00eda de im\u00e1genes de Racket"},{"location":"teoria/tema03-procedimientos-recursivos/tema03-procedimientos-recursivos.html#42-triangulo-de-sierpinski","text":"Vamos a utilizar las funciones anteriores que construyen im\u00e1genes para construir una figura fractal, el denominado ri\u00e1ngulo de Sierpinski, usando la recursi\u00f3n. Tri\u00e1ngulo de Sierpinski \u00bfVes alguna recursi\u00f3n en la figura? \u00bfCu\u00e1l podr\u00eda ser el par\u00e1metro de la funci\u00f3n que la dibujara? \u00bfSe te ocurre un algoritmo recursivo que la dibuje, usando las funciones de combinaci\u00f3n de im\u00e1genes vistas? La figura es autosimilar (una caracter\u00edstica de las figuras fractales). Una parte de la figura es id\u00e9ntica a la figura total, pero reducida de escala. Esto nos da una pista de que es posible dibujar la figura con un algoritmo recursivo. Para intentar encontrar una forma de enfocar el problema, vamos a pensarlo de la siguiente forma: supongamos que tenemos tres tri\u00e1ngulos de Sierpinski de anchura x . \u00bfC\u00f3mo podr\u00edamos construir el tri\u00e1ngulo de Sierpinski de anchura 2*x ? Lo podr\u00edamos hacer combinando las tres im\u00e1genes de la siguiente forma: Juntamos 2 tri\u00e1ngulos uno junto a otro. Sobre la figura resultante colocamos (alineada en el centro) el tri\u00e1ngulo restante. En la siguiente figura se muestra el esquema de esta combinaci\u00f3n. Cada rect\u00e1ngulo representa la imagen de sierpinski de anchura x y la combinaci\u00f3n representa la imagen de anchura 2*x . El algoritmo recursivo se basa en la misma idea, pero hacia atr\u00e1s . Dibujamos un tri\u00e1ngulo de anchura x bas\u00e1ndonos en 3 llamadas recursivas a tri\u00e1ngulos m\u00e1s peque\u00f1os (de anchura x/2 ). En el caso base, cuando x sea menor que un umbral h , dibujaremos un tri\u00e1ngulo elemental de base h . Veamos c\u00f3mo hacerlo con la librer\u00eda de im\u00e1genes de Racket.","title":"4.2. Tri\u00e1ngulo de Sierpinski"},{"location":"teoria/tema03-procedimientos-recursivos/tema03-procedimientos-recursivos.html#43-curva-de-hilbert","text":"La curva de Hilbert es una curva fractal que tiene la propiedad de rellenar completamente el plano. Su dibujo tiene una formulaci\u00f3n recursiva: La imagen H2 se puede componer a partir de cuatro im\u00e1genes H1 siguiendo un patr\u00f3n. Es el mismo patr\u00f3n con el que se puede componer la imagen H3 a partir de cuatro im\u00e1genes H2. El patr\u00f3n se muestra en la siguiente funci\u00f3n (componer imagen) : ( define trazo-horizontal ( line 16 0 \"black\" )) ( define trazo-vertical ( rotate 90 trazo-horizontal )) ( define ( componer imagen ) ( beside ( above/align \"left\" ( beside/align \"bottom\" imagen trazo-horizontal ) trazo-vertical ( rotate -90 imagen )) ( above/align \"right\" imagen trazo-vertical ( rotate 90 imagen )))) La primera llamada a above/align compone una imagen juntando la imagen original con un trazo horizontal y apilando (con una alineaci\u00f3n a la izquierda) esta imagen sobre un trazo vertical y sobre la imagen original girada 90 grados en el sentido de las agujas del reloj. La segunda llamada a above/align construye otra imagen apilando (con una alineaci\u00f3n a la derecha) la imagen original, un trazo vertical y la imagen rotada 90 grados en sentido contrario a las agujas del reloj. Por \u00faltimo la llamada a beside junta las dos im\u00e1genes anteriores. Podemos ver un ejemplo del funcionamiento de esta composici\u00f3n usando una imagen base formada por un cuadrado con un tri\u00e1ngulo dentro. ( overlay ( triangle 20 \"solid\" \"green\" ) ( rectangle 20 20 \"solid\" \"black\" )) ) Si llamamos a componer con la imagen anterior podemos ver que se construye el patr\u00f3n b\u00e1sico de la curva de Hilbert, el que construye la imagen H2 a partir de H1. ( define imagen ( overlay ( triangle 20 \"solid\" \"green\" ) ( rectangle 20 20 \"solid\" \"black\" ))) imagen ( componer imagen ) Una vez entendido este patr\u00f3n de composici\u00f3n, podemos ya formular el algoritmo recursivo: ( define ( hilbert nivel ) ( if ( = 1 nivel ) ( beside/align \"top\" trazo-vertical trazo-horizontal trazo-vertical ) ( componer ( hilbert ( - nivel 1 ))))) El caso base es el nivel 1, en el que se construye el trazo b\u00e1sico de la curva de Hilbert. Para cualquier nivel n mayor que 1, se llama a la recursi\u00f3n para formar la curva de Hilbert de nivel n-1 y, con la imagen resultante, se llama a la funci\u00f3n componer . En la siguiente imagen se muestran distintas llamadas a la funci\u00f3n hilbert :","title":"4.3. Curva de Hilbert"},{"location":"teoria/tema03-procedimientos-recursivos/tema03-procedimientos-recursivos.html#5-bibliografia","text":"Cap\u00edtulos del libro Structure and Intepretation of Computer Programs : 1.2 - Procedures and the Processes They Generate 1.2.1 - Linear Recursion and Iteration 1.2.2 - Tree Recursion Manual de Racket: Librer\u00eda image.rkt Image Guide Lenguajes y Paradigmas de Programaci\u00f3n, curso 2021-22 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Domingo Gallardo, Cristina Pomares, Antonio Bot\u00eda, Francisco Mart\u00ednez","title":"5. Bibliograf\u00eda"},{"location":"teoria/tema04-estructuras-recursivas/tema04-estructuras-recursivas.html","text":"Tema 4: Estructuras de datos recursivas \u00b6 1. Listas estructuradas \u00b6 Hemos visto que las listas en Scheme se implementan como un estructura de datos recursiva, formada por una pareja que enlaza en su parte derecha el resto de la lista y que termina con una parte derecha en la que hay una lista vac\u00eda. En este apartado vamos a volver a estudiar las listas desde un nivel de abstracci\u00f3n alto, usando las funciones: (first lista) para obtener el primer elemento de una lista (rest lista) para obtener el resto de la lista (cons dato lista) para construir una nueva lista con el dato como primer elemento En la mayor\u00eda de funciones y ejemplos que hemos visto hasta ahora las listas est\u00e1n formadas por datos y el recorrido por la lista es un recorrido lineal, iterando por sus elementos. En este apartado vamos a ampliar este concepto y estudiar c\u00f3mo trabajar con listas que contienen otras listas . Veremos que esto cambia fundamentalmente la estructura de las listas y de las funciones que van a operar con ellas. El cambio fundamental es que la funci\u00f3n first lista puede devolver dos tipos de elementos: Un elemento de la lista (del tipo de elementos que hay en la lista) Otra lista (formada por el tipo de elementos de la lista) 1.1. Definici\u00f3n y ejemplos \u00b6 Las listas en Scheme pueden tener cualquier tipo de elementos, incluido otras listas. Llamaremos lista estructurada a una lista que contiene otras sublistas. Lo contrario de lista estructurada es una lista plana , una lista formada por elementos que no son listas. Llamaremos hojas a los elementos de una lista que no son sublistas. A las listas estructuradas cuyas hojas son s\u00edmbolos se les denomina en el contexto de la programaci\u00f3n funcional expresiones-S ( S-expression ). Por ejemplo, la lista estructurada: (a b (c d e) (f (g h))) es una lista estructurada con 4 elementos: El elemento 'a , una hoja El elemento 'b , otra hoja La lista plana (c d e) La lista estructurada (f (g h)) Se puede construir con cualquiera de las siguientes expresiones: ( define lista ( list ' a ' b ( list ' c ' d ' e ) ( list ' f ( list ' g ' h )))) ( define lista ' ( a b ( c d e ) ( f ( g h )))) Una lista formada por parejas la consideraremos una lista plana, ya que no contiene ninguna sublista. Por ejemplo, la lista (( a . 3 ) ( b . 5 ) ( c . 12 )) es una lista plana de tres elementos (hojas) que son parejas. 1.1.1. Definiciones en Scheme \u00b6 Vamos a escribir las definiciones anteriores de hoja , plana y estructurada usando c\u00f3digo de Scheme. 1.1.1.1. Funci\u00f3n (hoja? dato) \u00b6 Definimos una hoja como aquellos elementos de una lista estructurada que no son listas: ( define ( hoja? elem ) ( not ( list? elem ))) Utilizaremos esta funci\u00f3n para comprobar si un determinado elemento de una lista es o no una hoja. Por ejemplo, supongamos la siguiente lista: (( 1 2 ) 3 4 ( 5 6 )) Es una lista de 4 elementos, siendo el primero y el \u00faltimo otras sublistas y el segundo y el tercero hojas. Podemos comprobar si son o no hojas sus elementos: ( define lista ' (( 1 2 ) 3 4 ( 5 6 ))) ( hoja? ( first lista )) ; \u21d2 #f ( hoja? ( second lista )) ; \u21d2 #t ( hoja? ( third lista )) ; \u21d2 #t ( hoja? ( fourth lista )) ; \u21d2 #f La lista vac\u00eda no es una hoja ( hoja? ' ()) ; \u21d2 #f 1.1.1.2. Funci\u00f3n (plana? lista) \u00b6 Como hemos dicho antes, una lista es plana cuando todos sus elementos son hojas. Queremos implementar la funci\u00f3n (plana? lista) que lo compruebe. Por ejemplo: ( plana? ' ( a b c d e f )) ; \u21d2 #t ( plana? ( list ( cons ' a 1 ) \"Hola\" #f )) ; \u21d2 #t ( plana? ' ( a ( b c ) d )) ; \u21d2 #f ( plana? ' ( a () b )) ; \u21d2 #f Una definici\u00f3n recursiva de lista plana: Una lista es plana si y solo si el primer elemento es una hoja y el resto es plana. Y el caso base: Una lista vac\u00eda es plana. Usando esta definici\u00f3n recursiva, podemos implementar en Scheme la funci\u00f3n (plana? lista) que comprueba si una lista es plana: ( define ( plana? lista ) ( or ( null? lista ) ( and ( hoja? ( first lista )) ( plana? ( rest lista ))))) Se podr\u00eda tambi\u00e9n implementar la funci\u00f3n plana? usando la funci\u00f3n de orden superior for-all? que comprueba que todos los elementos de una lista cumplen una propiedad. En esta caso, ser hoja. ( define ( plana-fos? lista ) ( for-all? hoja? lista )) Funci\u00f3n for-all? Recordemos que la funci\u00f3n (for-all? predicado lista) se implementa de la siguiente forma: ( define ( for-all? predicado lista ) ( or ( null? lista ) ( and ( predicado ( first lista )) ( for-all? predicado ( rest lista ))))) 1.1.1.3. Funci\u00f3n (estructurada? lista) \u00b6 Una lista es estructurada cuando alguno de sus elementos es otra lista. Como caso base, una lista vac\u00eda no es estructurada. Queremos implementar la funci\u00f3n (estructurada? lista) que compruebe si una lista es estructurada. ( estructurada? ' ( 1 2 3 4 )) ; \u21d2 #f ( estructurada? ( list ( cons ' a 1 ) ( cons ' b 2 ) ( cons ' c 3 ))) ; \u21d2 #f ( estructurada? ' ( a () b )) ; \u21d2 #t ( estructurada? ' ( a ( b c ) d )) ; \u21d2 #t ( define ( estructurada? lista ) ( and ( not ( null? lista )) ( or ( list? ( first lista )) ( estructurada? ( rest lista ))))) Se podr\u00eda implementar tambi\u00e9n usando la funci\u00f3n de orden superior exists? para consultar si alg\u00fan elemento de la lista es tambi\u00e9n otra lista. ( define ( estructurada-fos? lista ) ( exists? list? lista )) Funci\u00f3n exists? Recordemos que la funci\u00f3n (exists? predicado lista) se implementa de la siguiente forma: ( define ( exists? predicado lista ) ( if ( null? lista ) #f ( or ( predicado ( first lista )) ( exists? predicado ( rest lista ))))) Realmente bastar\u00eda con haber hecho una de las dos definiciones y escribir la otra como la negaci\u00f3n de la primera: ( define ( estructurada? lista ) ( not ( plana? lista ))) 1.1.2. Ejemplos de listas estructuradas \u00b6 Las listas estructuradas son muy \u00fatiles para representar informaci\u00f3n jer\u00e1rquica en donde queremos representar elementos que contienen otros elementos. Por ejemplo, las expresiones de Scheme son listas estructuradas: ( = 4 ( + 2 2 )) ( if ( = x y ) ( * x y ) ( + ( / x y ) 45 )) ( define ( factorial x ) ( if ( = x 0 ) 1 ( * x ( factorial ( - x 1 ))))) El an\u00e1lisis sint\u00e1ctico de una oraci\u00f3n puede generar una lista estructurada de s\u00edmbolos, en donde se agrupan los distintos elementos de la oraci\u00f3n: (( Juan ) ( compr\u00f3 ) ( la entrada ( de la pel\u00edcula )) ( el viernes por la tarde )) Una p\u00e1gina HTML, con sus distintos elementos, unos dentro de otros, tambi\u00e9n se puede representar con una lista estructurada: (( <h1> Mi lista de la compra </h1> ) ( <ul> ( <li> naranjas </li> ) ( <li> tomates </li> ) ( <li> huevos </li> ) </ul> )) 1.1.3. Pseudo \u00e1rboles con niveles \u00b6 Las listas estructuradas definen una estructura de niveles, donde la lista inicial representa el primer nivel, y cada sublista representa un nivel inferior. Los datos de las listas representan las hojas. Por ejemplo, la representaci\u00f3n en forma de niveles de la lista ((a b c) d e) es la siguiente: Cada asterisco * representa una lista. Las ramas que salen del asterisco representan los elementos de la lista. En el ejemplo tenemos en un primer nivel una lista con 3 elementos: la lista (a b c) , d y e . Y en el segundo nivel se encuentra la lista (a b c) cuyos 3 elementos son hojas. Las hojas d y e est\u00e1n en el nivel 1 y en las posiciones 2 y 3 de la lista y las hojas a , b y c en el nivel 2. Una lista estructurada no es un \u00e1rbol Una lista estructurada no es un \u00e1rbol propiamente dicho, porque un \u00e1rbol tiene datos en todos los nodos, mientras que en la lista estructurada los datos est\u00e1n s\u00f3lo en las hojas. Las listas estructuradas sirven para agrupar de forma jer\u00e1rquica un conjunto de datos en distintos niveles. A pesar de ser distintas de los \u00e1rboles, ambas son estructuras de datos jer\u00e1rquicas (con niveles) que se pueden definir de forma recursiva y sobre las que se pueden definir algoritmos recursivos. Veremos m\u00e1s adelante c\u00f3mo definir y trabajar con \u00e1rboles en Scheme. Otro ejemplo. \u00bfCu\u00e1l ser\u00eda la representaci\u00f3n en niveles de la siguiente lista estructurada?: ( map ( lambda ( x ) ( + x 10 )) ( quote ( 1 2 3 4 ))) 1.2. Funciones recursivas sobre listas estructuradas \u00b6 1.2.1. N\u00famero de hojas \u00b6 Veamos como primer ejemplo la funci\u00f3n (num-hojas lista) que cuenta el n\u00famero de hojas de una lista estructurada. Por ejemplo: ( num-hojas ' (( 1 2 ) ( 3 4 ( 5 ) 6 ) ( 7 ))) ; \u21d2 7 Como hemos comentado antes, una cuesti\u00f3n clave en las funciones que vamos a construir sobre listas estructuradas es que el first de una lista estructurada puede ser a su vez otra lista. Para calcular el n\u00famero de hojas de una lista podemos obtener el primer elemento y el resto de la lista, y contar recursivamente el n\u00famero de hojas del primer elemento y del resto. Al ser una lista estructurada, el primer elemento puede ser a su vez otra lista, por lo que llamamos a la recursi\u00f3n para contar sus hojas. La definici\u00f3n de este caso general usando pseudoc\u00f3digo es: El n\u00famero de hojas de una lista estructurada es la suma del n\u00famero de hojas de su primer elemento (que puede ser otra lista) y del n\u00famero de hojas del resto. La recursi\u00f3n tiene dos llamadas recursivas. Una que recibe el elemento de la cabeza de la lista y otra que recibe el resto de la lista. ;Caso general num-hojas ( define ( num-hojas lista ) ; Falta caso base ( + ( num-hojas ( first lista )) ( num-hojas ( rest lista )))) No hay coste exponencial A pesar de haber dos llamadas recursivas, no pasa lo mismo que en Fibonacci o Pascal ya que no se van a repetir llamadas a la recursi\u00f3n con los mismos datos. La recursi\u00f3n recorre la lista estructurada y su coste ser\u00e1 el n\u00famero de elementos de la lista. Para considerar el caso base , veamos c\u00f3mo las llamadas recursivas reciben cada vez un problema m\u00e1s peque\u00f1o. La llamada recursiva sobre el resto de la lista recibe cada vez una lista con 1 elemento menos. Al final se llamar\u00e1 a la funci\u00f3n con una lista vac\u00eda. Ese ser\u00e1 un caso base. El n\u00famero de elementos de una lista vac\u00eda es 0. La llamada recursiva sobre la cabeza de la lista es algo distinta. Recibe una lista en la que se ha descendido un nivel y tiene, por tanto, un nivel menos. Al final se llamar\u00e1 a la funci\u00f3n con una hoja (un dato). Ese ser\u00e1 el otro caso base y habr\u00e1 que devolver 1. La definici\u00f3n completa de la funci\u00f3n queda de la siguiente forma: ( define ( num-hojas lista ) ( cond (( null? lista ) 0 ) (( hoja? lista ) 1 ) ( else ( + ( num-hojas ( first lista )) ( num-hojas ( rest lista )))))) Importante Hay que hacer notar que el par\u00e1metro lista puede ser tanto una lista como un dato at\u00f3mico. En ese caso la funci\u00f3n (hoja? lista) devuelve #t . En lenguajes de programaci\u00f3n fuertemente tipados esto no ser\u00eda posible, porque la lista y el dato ser\u00edan de distinto tipo. En ese caso el c\u00f3digo deber\u00eda ser un poco m\u00e1s largo y antes de llamar a la recursi\u00f3n habr\u00eda que comprobar si el elemento es un dato o es otra lista. En el caso de Scheme, podemos aprovecharnos de su caracter\u00edstica de ser d\u00e9bilmente tipado y podemos hacer el c\u00f3digo m\u00e1s conciso, llamando siempre a la recursi\u00f3n con el first de la lista, independientemente de si es un dato u otra lista. 1.2.1.1. Versi\u00f3n con funciones de orden superior \u00b6 Podemos usar tambi\u00e9n las funciones de orden superior map y foldr para obtener una versi\u00f3n m\u00e1s concisa. Una lista estructurada tiene como elementos en un primer nivel hojas o otras sublistas. Podemos entonces mapear una expresi\u00f3n lambda que se aplica a cada uno de esos elementos. En la expresi\u00f3n lambda comprobamos si el elemento (el par\u00e1metro sublista de la expresi\u00f3n lambda) es una hoja o una lista. En el primero caso devolvemos 1. En el segundo aplicaremos la propia funci\u00f3n que estamos definiendo sobre la sublista, con lo que se devolver\u00e1 el n\u00famero de hojas de esa sublista. El resultado del map ser\u00e1 una lista de n\u00fameros (el n\u00famero de hojas de cada componente), que podemos sumar haciendo un foldr con la funci\u00f3n + : ( define ( num-hojas-fos lista ) ( if ( hoja? lista ) 1 ( foldr + 0 ( map num-hojas-fos lista )))) Una explicaci\u00f3n gr\u00e1fica de c\u00f3mo funciona la funci\u00f3n sobre la lista (1 (2 3) (4) (5 (6 7) 8)) : Ser\u00eda equivalente hacer un apply de la suma para sumar los n\u00fameros de la lista devuelta por el map : ( define ( num-hojas-fos lista ) ( if ( hoja? lista ) 1 ( apply + ( map num-hojas-fos lista )))) Nota Es interesante conocer ambas expresiones (la del foldr y la del apply ) porque hay lenguajes de programaci\u00f3n en los que la funci\u00f3n apply no est\u00e1 definida. Por ejemplo, Swift. 1.2.2. Aplanar lista \u00b6 Veamos otro ejemplo. La funci\u00f3n (aplana lista) que devuelve una lista plana con todas las hojas de la lista. Por ejemplo: ( aplana ' ( 1 2 ( 3 ( 4 ( 5 ))) ((( 6 ))))) ; \u21d2 (1 2 3 4 5 6) La soluci\u00f3n recursiva es: ( define ( aplana lista ) ( cond (( null? lista ) ' ()) (( hoja? lista ) ( list lista )) ( else ( append ( aplana ( first lista )) ( aplana ( rest lista )))))) Con funciones de orden superior: ( define ( aplana-fos lista ) ( if ( hoja? lista ) ( list lista ) ( foldr append ' () ( map aplana-fos lista )))) Usando apply : ( define ( aplana-fos lista ) ( if ( hoja? lista ) ( list lista ) ( apply append ( map aplana-fos lista )))) 1.2.3. Otras funciones recursivas \u00b6 Vamos a dise\u00f1ar otras funciones recursivas que trabajan con la estructura jer\u00e1rquica de las listas estructuradas. (pertenece-lista? dato lista) : busca una hoja en una lista estructurada. (altura lista) : devuelve el n\u00famero de niveles de una lista estructurada. (nivel-hoja dato lista) : devuelve el nivel en el que se encuentra un dato en una lista. (cuadrado-estruct lista) : eleva todas las hojas al cuadrado (suponemos que la lista estructurada contiene n\u00fameros). (map-estruct f lista) : similar a map, aplica una funci\u00f3n a todas las hojas de la lista estructurada y devuelve el resultado (otra lista estructurada). 1.2.3.1. (pertenece-lista? dato lista) \u00b6 Comprueba si el dato aparece en la lista estructurada. ( pertenece? ' a ' ( b c ( d ( a )))) ; \u21d2 #t ( pertenece? ' a ' ( b c ( d e ( f )) g )) ; \u21d2 #f Soluci\u00f3n recursiva: ( define ( pertenece? dato lista ) ( cond (( null? lista ) #f ) (( hoja? lista ) ( equal? dato lista )) ( else ( or ( pertenece? dato ( first lista )) ( pertenece? dato ( rest lista )))))) Con funciones de orden superior: ( define ( pertenece-fos? dato lista ) ( if ( hoja? lista ) ( equal? dato lista ) ( exists? ( lambda ( elem ) ( pertenece-fos? dato elem )) lista ))) 1.2.3.2. (altura lista) \u00b6 La altura de una lista estructurada viene dada por su n\u00famero de niveles: una lista plana tiene una altura de 1, la lista ((1 2 3) 4 5) tiene una altura de 2. Para calcular la altura de una lista estructurada tenemos que obtener (de forma recursiva) la altura de su primer elemento, y la altura del resto de la lista, sumarle 1 a la altura del primer elemento y devolver el m\u00e1ximo de los dos n\u00fameros. Como casos base, la altura de una lista vac\u00eda o de una hoja (dato) es 0. En Scheme: ( define ( altura lista ) ( cond (( null? lista ) 0 ) (( hoja? lista ) 0 ) ( else ( max ( + 1 ( altura ( first lista ))) ( altura ( rest lista )))))) Por ejemplo: ( altura ' ( 1 ( 2 3 ) 4 )) ; \u21d2 2 ( altura ' ( 1 ( 2 ( 3 )) 3 )) ; \u21d2 3 1.2.3.2.1. Versi\u00f3n con funciones de orden superior \u00b6 Y la segunda versi\u00f3n, usando las funciones de orden superior map para obtener la altura de sus elementos del primer nivel (puedes ser hojas o sublistas) y foldr para quedarse con el m\u00e1ximo de la lista de valores que devuelve el map. ( define ( altura-fos lista ) ( if ( hoja? lista ) 0 ( + 1 ( foldr max 0 ( map altura-fos lista ))))) Podr\u00edamos hacerlo tambi\u00e9n sustituyendo el foldr por un apply : ( define ( altura-fos lista ) ( if ( hoja? lista ) 0 ( + 1 ( apply max ( map altura-fos lista ))))) 1.2.3.3. (nivel-hoja dato lista) \u00b6 Veamos una \u00faltima funci\u00f3n (nivel-hoja dato lista) que recorre una lista estructurada buscando el dato y devuelve el nivel en que se encuentra. Si el dato no se encuentra en la lista, se devolver\u00e1 -1. Si el dato se encuentra en m\u00e1s de un lugar de la lista se devolver\u00e1 el nivel mayor. Ejemplos: ( nivel-hoja ' b ' ( a b ( c ))) ; \u21d2 1 ( nivel-hoja ' b ' ( a ( b ) c )) ; \u21d2 2 ( nivel-hoja ' b ' ( a ( b ) d (( b )))) ; \u21d2 3 ( nivel-hoja ' b ' ( a c d (( e )))) ; \u21d2 -1 Soluci\u00f3n recursiva: ( define ( nivel-hoja dato lista ) ( cond (( null? lista ) -1 ) (( hoja? lista ) ( if ( equal? lista dato ) 0 -1 )) ( else ( max ( suma-1-si-mayor-igual-que-0 ( nivel-hoja dato ( first lista ))) ( nivel-hoja dato ( rest lista )))))) La funci\u00f3n auxiliar se define de la siguiente forma: ( define ( suma-1-si-mayor-igual-que-0 x ) ( if ( >= x 0 ) ( + x 1 ) x )) Con funciones de orden superior: ( define ( nivel-hoja-fos dato lista ) ( if ( hoja? lista ) ( if ( equal? lista dato ) 0 -1 ) ( suma-1-si-mayor-igual-que-0 ( foldr max -1 ( map ( lambda ( elem ) ( nivel-hoja-fos dato elem )) lista ))))) 1.2.3.4. (cuadrado-estruct lista) \u00b6 Vamos ahora a ver un tipo de funci\u00f3n distinta. Una que construye una lista estructurada y la devuelve. Queremos implementar la funci\u00f3n (cuadrado-estruct lista) que recibe una lista estructurada y devuelve otra lista estructurada con la misma estructura y sus n\u00fameros elevados al cuadrado. Por ejemplo: ( cuadrado-estruct ' ( 2 3 ( 4 ( 5 )))) ; \u21d2 (4 9 (16 (25)) La soluci\u00f3n recursiva es: ( define ( cuadrado-estruct lista ) ( cond (( null? elem ) ' ()) (( hoja? elem ) ( * lista lista )) ( else ( cons ( cuadrado-estruct ( first lista )) ( cuadrado-estruct ( rest lista )))))) Se llama a la recursi\u00f3n con el first y con el rest de la lista original. El resultado de ambas llamadas ser\u00e1n las correspondientes listas estructuradas con sus elementos elevados al cuadrado. Y se devuelve la lista resultante de insertar la lista devuelta en la llamada recursiva con el first en la primera posici\u00f3n de la lista devuelta en la llamada recursiva con el rest . Es muy interesante la versi\u00f3n de esta funci\u00f3n con funciones de orden superior: ( define ( cuadrado-estruct-fos lista ) ( if ( hoja? lista ) ( * lista lista ) ( map cuadrado-estruct-fos lista ))) Como una lista estructurada est\u00e1 compuesta de datos o de otras sublistas podemos aplicar map para que devuelva la lista resultante de transformar la original con la funci\u00f3n que le pasamos como par\u00e1metro. 1.2.3.5. (map-estruct f lista) \u00b6 Podemos generalizar la funci\u00f3n anterior y definir la funci\u00f3n de orden superior sobre listas estructuradas (map-estructurada f lista) que devuelve una lista estructurada igual que la original con el resultado de aplicar a cada uno de sus hojas la funci\u00f3n f Por ejemplo: ( map-estruct ( lambda ( x ) ( * x x )) ' ( 2 3 ( 4 ( 5 )))) ; \u21d2 (4 9 (16 (25)) La soluci\u00f3n recursiva es una generalizaci\u00f3n de la funci\u00f3n anterior, usando el par\u00e1metro f : ( define ( map-estruct f lista ) ( cond (( null? lista ) ' ()) (( hoja? lista ) ( f lista )) ( else ( cons ( map-estruct f ( first lista )) ( map-estruct f ( rest lista )))))) Soluci\u00f3n con map : ( define ( map-estruct-fos f lista ) ( if ( hoja? lista ) ( f lista ) ( map ( lambda ( elem ) ( map-estruct-fos f elem )) lista ))) 2. \u00c1rboles \u00b6 2.1. Definici\u00f3n de \u00e1rboles en Scheme \u00b6 2.1.1. Definici\u00f3n de \u00e1rbol \u00b6 Un \u00e1rbol es una estructura de datos definida por un valor ra\u00edz, que es el padre de toda la estructura, del que salen otros sub\u00e1rboles hijos ( Wikipedia ). Un \u00e1rbol se puede definir recursivamente de la siguiente forma: Una colecci\u00f3n de un dato (el valor de la ra\u00edz del \u00e1rbol) y una lista de hijos que tambi\u00e9n son \u00e1rboles. Una hoja ser\u00e1 un \u00e1rbol sin hijos (un dato con una lista de hijos vac\u00eda). Un ejemplo de \u00e1rbol: El \u00e1rbol anterior tiene como dato ra\u00edz el n\u00famero 30 y tiene 3 \u00e1rboles hijos: El primer hijo es un \u00e1rbol con ra\u00edz 15 y con dos hijos hoja, el 10 y el 12 El segundo hijo es un \u00e1rbol hoja, con valor 18 El tercer hijo es un \u00e1rbol con ra\u00edz 25 y con tres hijos hoja, el 19, 21 y 22. 2.1.2. Representaci\u00f3n de \u00e1rboles con listas \u00b6 En Scheme la lista es la estructura de datos principal. \u00bfC\u00f3mo podemos construir un \u00e1rbol usando listas? Podemos hacerlo de varias formas, pero escogemos la siguiente: usar una lista de n+1 elementos para representar un \u00e1rbol con n hijos: el primer elemento la lista ser\u00e1 el dato de la ra\u00edz el resto ser\u00e1n los \u00e1rboles hijos arbol -> (dato hijo-1 hijo-2 ... hijo-n) Los nodos hoja (datos al final del \u00e1rbol que no tienen ning\u00fan hijo) son tambi\u00e9n \u00e1rboles. Al no tener hijos, se representan como listas con un \u00fanico elemento, el propio dato. Nodo hoja -> (dato) La forma de representar el \u00e1rbol anterior ser\u00e1 la siguiente lista: ( 30 ( 15 ( 10 ) ( 12 )) ( 18 ) ( 25 ( 19 ) ( 21 ) ( 22 ))) Los elementos de esta lista son: El primer elemento es el n\u00famero 30 , el dato valor de la ra\u00edz del \u00e1rbol El segundo elemento es la lista (15 (10) (12)) , que representa el \u00e1rbol con dato 15 y dos hijos El tercer elemento es la lista (18) que representa el \u00e1rbol hoja formado por un 18 El tercer elemento es la lista (15 (19) (21) (22)) , que representa el \u00e1rbol con un dato 15 y tres hijos Podr\u00edamos definir el \u00e1rbol con la siguiente sentencia: ( define arbol1 ' ( 30 ( 15 ( 10 ) ( 12 )) ( 18 ) ( 25 ( 19 ) ( 21 ) ( 22 )))) Otro ejemplo m\u00e1s. \u00bfC\u00f3mo se implementa en Scheme el \u00e1rbol de la siguiente figura? Se har\u00eda con la lista de la siguiente sentencia: ( define arbol2 ' ( 40 ( 18 ( 3 ) ( 23 ( 29 ))) ( 52 ( 47 )))) 2.1.3. Barrera de abstracci\u00f3n \u00b6 Una vez definida la forma de representar \u00e1rboles, vamos a definir las funciones b\u00e1sicas para manejarlos. Veremos las funciones para obtener el dato y los hijos y la funci\u00f3n para construir un \u00e1rbol nuevo. Estas funciones proporcionan lo que se denomina barrera de abstracci\u00f3n del tipo datos \u00e1rbol . En todos los nombres de las funciones de la barrera de abstracci\u00f3n a\u00f1adimos el sufijo -arbol . Definimos dos conjuntos de funciones: constructores para construir un nuevo \u00e1rbol y selectores para obtener los elementos del \u00e1rbol. Vamos a empezar por los selectores. Selectores Funciones que obtienen los elementos de un \u00e1rbol: ( define ( dato-arbol arbol ) ( first arbol )) ( define ( hijos-arbol arbol ) ( rest arbol )) ( define ( hoja-arbol? arbol ) ( null? ( hijos-arbol arbol ))) Es importante tener claro los tipos devueltos por las dos primeras funciones: (dato-arbol arbol) : devuelve el dato de la ra\u00edz del \u00e1rbol. (hijos-arbol arbol) : devuelve una lista de \u00e1rboles hijos. En algunas ocasiones llamaremos bosque a una lista de \u00e1rboles. Podremos recorrer esa lista usando las funciones first y rest para obtener los \u00e1rboles hijos. Volvemos a mostrar el arbol1 para comprobar estas funciones. Las funciones anteriores devuelven los siguientes valores: ( dato-arbol arbol1 ) ; \u21d2 30 ( hijos-arbol arbol1 ) ; \u21d2 ((15 (10) (12)) (18) (25 (19) (21) (22))) ( hoja-arbol? ( first ( hijos-arbol arbol1 ))) ; \u21d2 #f ( hoja-arbol? ( second ( hijos-arbol arbol1 ))) ; \u21d2 #t La llamada (dato-arbol arbol1) devuelve el dato que hay en la ra\u00edz del \u00e1rbol, el n\u00famero 30 . La invocaci\u00f3n (hijos-arbol arbol1) devuelve una lista de tres elementos, los \u00e1rboles hijos: El primer elemento es la lista (15 (10) (12)) , que representa el \u00e1rbol formado por el 15 en su ra\u00edz y las hojas 10 y 12 . El segundo elemento es el \u00e1rbol hoja 18 , representado por la lista (18) . El tercero es la lista (25 (19) (21) (22)) , que representa el \u00e1rbol formado por el 25 en su ra\u00edz y las hojas 19 , 21 y 22 . Es muy importante considerar en cada caso con qu\u00e9 tipo de dato estamos trabajando y usar la barrera de abstracci\u00f3n adecuada en cada caso: La funci\u00f3n hijos-arbol siempre devuelve una lista de \u00e1rboles , que podemos recorrer usando first y rest . El first de una lista de \u00e1rboles (devuelta por hijos-arbol ) siempre es un \u00e1rbol y debemos de usar las funciones de su barrera de abstracci\u00f3n: dato-arbol e hijos-arbol . La funci\u00f3n dato-arbol devuelve un dato , del tipo que guardemos en el \u00e1rbol. En el caso del \u00e1rbol ejemplo es un n\u00famero. Por ejemplo, para obtener el n\u00famero 12 en el \u00e1rbol anterior tendr\u00edamos que hacer lo siguiente: acceder al primer elemento de la lista de hijos, despu\u00e9s al segundo hijo de \u00e9ste y por \u00faltimo acceder a su dato. Recordemos que hijos-arbol devuelve la lista de \u00e1rboles hijos, por lo que utilizaremos las funciones first y rest para recorrerlas y obtener los elementos que nos interesen: ( dato-arbol ( second ( hijos-arbol ( first ( hijos-arbol arbol1 ))))) ; \u21d2 12 Constructor Definimos una funci\u00f3n constructora que abstrae la construcci\u00f3n de un \u00e1rbol y encapsula su implementaci\u00f3n concreta. Para construir un \u00e1rbol necesitamos un dato y una lista de \u00e1rboles hijos. Si la lista de \u00e1rboles hijos es vac\u00eda, tendremos un nodo hoja. ( define ( construye-arbol dato lista-arboles ) ( cons dato lista-arboles )) Llamaremos a la funci\u00f3n construye-arbol pasando su dato (obligatorio) y la lista de arboles hijos. Si se pasa una lista vac\u00eda como par\u00e1metro estaremos definiendo un nodo hoja. Por ejemplo, para definir un nodo hoja con el dato 2: ( define arbol3 ( construye-arbol 2 ' ())) Y para definir un \u00e1rbol con 3 hijos: ( define arbol4 ( construye-arbol 10 ( list ( construye-arbol 2 ' ()) ( construye-arbol 5 ' ()) ( construye-arbol 9 ' ()))) El \u00e1rbol 1 anterior se puede construir con las siguientes llamadas al constructor. Guardamos los \u00e1rboles hijos en variables auxiliares para hacer m\u00e1s entendible la expresi\u00f3n: ( define arbol-15 ( construye-arbol 15 ( list ( construye-arbol 10 ' ()) ( construye-arbol 12 ' ())))) ( define arbol-18 ( construye-arbol 18 ' ())) ( define arbol-25 ( construye-arbol 25 ( list ( construye-arbol 19 ' ()) ( construye-arbol 21 ' ()) ( construye-arbol 22 ' ())))) ( define arbol1b ( construye-arbol 30 ( list arbol-15 arbol-18 arbol-25 ))) arbol1b ; \u21d2 (30 (15 (10) (12)) (18) (25 (19) (21) (22))) 2.1.4. Barreras de abstracci\u00f3n de \u00e1rboles y listas estructuradas \u00b6 Es importante diferenciar la barrera de abstracci\u00f3n de los \u00e1rboles de la de las listas estructuradas. Aunque un \u00e1rbol se implementa en Scheme con una lista estructurada, a la hora de definir funciones sobre \u00e1rboles hay que trabajar con las funciones definidas arriba. El siguiente esquema resumen las caracter\u00edsticas de los selectores de la barrera de abstracci\u00f3n de listas y \u00e1rboles: Importante Debemos usar la barrera de abstracci\u00f3n al trabajar con \u00e1rboles porque as\u00ed separamos nuestro c\u00f3digo de la implementaci\u00f3n subyacente del tipo de dato. De esta forma es posible cambiar la implementaci\u00f3n del tipo de dato sin afectar a las funciones que hemos definido usando la barrera. Lo \u00fanico que hay que hacer es cambiar la implementaci\u00f3n de la barrera de abstracci\u00f3n. Otras ventajas de utilizar la barrera de abstracci\u00f3n, tan importantes como la anterior, son: El c\u00f3digo es mucho m\u00e1s legible. Dado que Scheme es un lenguaje d\u00e9bilmente tipado, en una expresi\u00f3n como (dato-arbol elem) sabemos que el el elemento sobre el que se trabaja es un \u00e1rbol (no es un n\u00famero, ni un string, ni un booleano). El c\u00f3digo es trasladable a cualquier lenguaje de programaci\u00f3n. Si queremos trabajar con \u00e1rboles en JavaScript, por ejemplo, s\u00f3lo tendremos que implementar la barrera de abstracci\u00f3n en este lenguaje. Una vez hecho eso todas las funciones que trabajan con \u00e1rboles, como las que veremos a continuaci\u00f3n, funcionar\u00e1n correctamente. 2.2. Funciones recursivas sobre \u00e1rboles \u00b6 Vamos a dise\u00f1ar las siguientes funciones recursivas: (suma-datos-arbol arbol) : devuelve la suma de todos los nodos (to-list-arbol arbol) : devuelve una lista con los datos del \u00e1rbol (cuadrado-arbol arbol) : eleva al cuadrado todos los datos de un \u00e1rbol manteniendo la estructura del \u00e1rbol original (map-arbol f arbol) : devuelve un \u00e1rbol con la estructura del \u00e1rbol original aplicando la funci\u00f3n f a subdatos. (altura-arbol arbol) : devuelve la altura de un \u00e1rbol Todas comparten un patr\u00f3n similar de recursi\u00f3n mutua. 2.2.1. Funci\u00f3n suma-datos-arbol \u00b6 Vamos a implementar una funci\u00f3n recursiva que sume todos los datos de un \u00e1rbol. Un \u00e1rbol siempre va a tener un dato y una lista de hijos (que puede ser vac\u00eda) que obtenemos con las funciones dato-arbol e hijos-arbol . Podemos plantear entonces el problema de sumar los datos de un \u00e1rbol como la suma del dato de su ra\u00edz y lo que devuelva la llamada a una funci\u00f3n auxiliar que sume los datos de su lista de hijos (llamamos bosque a una lista de hijos): ( define ( suma-datos-arbol arbol ) ( + ( dato-arbol arbol ) ( suma-datos-bosque ( hijos-arbol arbol )))) Esta funci\u00f3n suma los datos de un \u00e1rbol. La podemos utilizar entonces para construir la siguiente funci\u00f3n que suma una lista de \u00e1rboles: ( define ( suma-datos-bosque bosque ) ( if ( null? bosque ) 0 ( + ( suma-datos-arbol ( first bosque )) ( suma-datos-bosque ( rest bosque ))))) Podemos visualizar el funcionamiento de la suma-datos-bosque en la siguiente figura: El caso general de la funci\u00f3n obtiene el primer \u00e1rbol de la lista (un \u00e1rbol) y llama a la funci\u00f3n suma-datos-arbol para obtener la suma de sus datos. Tambi\u00e9n obtiene el resto del bosque (otra lista de \u00e1rboles) y llama de forma recursiva a la propia funci\u00f3n para sumar todos sus \u00e1rboles. Tenemos una recursi\u00f3n mutua : para sumar los datos de una lista de \u00e1rboles llamamos a la suma de un \u00e1rbol individual que a su vez llama a la suma de sus hijos, etc. La recursi\u00f3n termina cuando calculamos la suma de un \u00e1rbol hoja. Entonces se pasa a suma-datos-bosque una lista vac\u00eda y \u00e9sta devolver\u00e1 0. ( suma-datos-arbol arbol1 ) ; \u21d2 172 Versi\u00f3n alternativa con funciones de orden superior Al igual que hac\u00edamos con las listas estructuradas, es posible conseguir una versi\u00f3n m\u00e1s concisa y elegante utilizando funciones de orden superior: ( define ( suma-datos-arbol-fos arbol ) ( foldr + ( dato-arbol arbol ) ( map suma-datos-arbol-fos ( hijos-arbol arbol )))) La funci\u00f3n map aplica la propia funci\u00f3n que estamos definiendo ( suma-datos-arbol-fos ) a cada uno de los \u00e1rboles hijos (obtenidos con la funci\u00f3n (hijos-arbol arbol) ). Confiando en que la funci\u00f3n hace su trabajo, devolver\u00e1 para cada arbol hijo la suma de todos sus nodos. De esta forma, el resultado de map ser\u00e1 una lista con la suma de los nodos de todos los \u00e1rboles hijos. La funci\u00f3n foldr suma todos esos n\u00fameros de la lista y el n\u00famero de la ra\u00edz. Nota Puede parecer que a la funci\u00f3n anterior le falta un caso base. \u00bfCu\u00e1ndo termina la recursi\u00f3n? La respuesta est\u00e1 en el funcionamiento de map , que cuando recibe una lista vac\u00eda devuelve tambi\u00e9n una lista vac\u00eda. Para comprobarlo, puedes pensar en qu\u00e9 pasar\u00eda si le pasas a la funci\u00f3n un \u00e1rbol hoja. Un ejemplo de su funcionamiento ser\u00eda el siguiente: ( suma-datos-arbol-fos ' ( 1 ( 2 ( 3 ) ( 4 )) ( 5 ) ( 6 ( 7 )))) \u21d2 ( foldr + 1 ( map suma-datos-arbol-fos ' (( 2 ( 3 ) ( 4 )) ( 5 ) ( 6 ( 7 ))))) \u21d2 ( foldr + 1 ' ( 9 5 13 )) \u21d2 28 El \u00e1rbol que queremos sumar tiene un 1 en la ra\u00edz y tres hijos: (2 (3) (4)) , (5) y (6 (7)) . La aplicaci\u00f3n de map suma-datos-arbol-fos sobre la lista de hijos devuelve una lista con la suma de los nodos de cada hijo: (9 5 13) . La funci\u00f3n foldr suma esa lista y el valor del nodo ra\u00edz ( 1 ). Podemos visualizar gr\u00e1ficamente el funcionamiento del map con la siguiente figura: 2.2.2. Funci\u00f3n to-list-arbol \u00b6 Queremos dise\u00f1ar una funci\u00f3n (to-list-arbol arbol) que devuelva una lista con los datos del \u00e1rbol en un recorrido preorden (primero el dato de la ra\u00edz y despu\u00e9s el dato de sus hijos de izquierda a derecha). La soluci\u00f3n, siguiendo el patr\u00f3n visto en suma-datos , es la siguiente. ( define ( to-list-arbol arbol ) ( cons ( dato-arbol arbol ) ( to-list-bosque ( hijos-arbol arbol )))) ( define ( to-list-bosque bosque ) ( if ( null? bosque ) ' () ( append ( to-list-arbol ( first bosque )) ( to-list-bosque ( rest bosque ))))) Igual que antes, la funci\u00f3n utiliza una recursi\u00f3n mutua : para listar todos los nodos, a\u00f1adimos el dato a la lista de nodos que nos devuelve la funci\u00f3n to-list-bosque . Esta funci\u00f3n coge una lista de \u00e1rboles (un bosque ) y devuelve la lista preorden de sus nodos. Para ello, concatena la lista de los nodos de su primer elemento (el primer \u00e1rbol) a la lista de nodos del resto de \u00e1rboles (que devuelve la llamada recursiva). Ejemplo: ( to-list-arbol ' ( * ( + ( 5 ) ( * ( 2 ) ( 3 )) ( 10 )) ( - ( 12 )))) ; \u21d2 (* + 5 * 2 3 10 - 12) Una definici\u00f3n alternativa usando funciones de orden superior: ( define ( to-list-arbol-fos arbol ) ( cons ( dato-arbol arbol ) ( foldr append ' () ( map to-list-arbol-fos ( hijos-arbol arbol ))))) Esta versi\u00f3n es muy elegante y concisa. Usa la funci\u00f3n map que aplica una funci\u00f3n a los elementos de una lista y devuelve la lista resultante. Como lo que devuelve (hijos-arbol arbol) es precisamente una lista de \u00e1rboles podemos aplicar a sus elementos cualquier funci\u00f3n definida sobre \u00e1rboles. Incluso la propia funci\u00f3n que estamos definiendo (\u00a1conf\u00eda en la recursi\u00f3n!). 2.2.3. Funci\u00f3n cuadrado-arbol \u00b6 Veamos ahora la funci\u00f3n (cuadrado-arbol arbol) que toma un \u00e1rbol de n\u00fameros y devuelve un \u00e1rbol con la misma estructura y sus datos elevados al cuadrado: ( define ( cuadrado-arbol arbol ) ( construye-arbol ( cuadrado ( dato-arbol arbol )) ( cuadrado-bosque ( hijos-arbol arbol )))) ( define ( cuadrado-bosque bosque ) ( if ( null? bosque ) ' () ( cons ( cuadrado-arbol ( first bosque )) ( cuadrado-bosque ( rest bosque ))))) Ejemplo: ( cuadrado-arbol ' ( 2 ( 3 ( 4 ) ( 5 )) ( 6 ))) ; \u21d2 (4 (9 (16) (25)) (36)) Versi\u00f3n 2, con la funci\u00f3n de orden superior map : ( define ( cuadrado-arbol-fos arbol ) ( construye-arbol ( cuadrado ( dato-arbol arbol )) ( map cuadrado-arbol-fos ( hijos-arbol arbol )))) 2.2.4. Funci\u00f3n map-arbol \u00b6 La funci\u00f3n map-arbol es una funci\u00f3n de orden superior que generaliza la funci\u00f3n anterior. Definimos un par\u00e1metro adicional en el que se pasa la funci\u00f3n a aplicar a los elementos del \u00e1rbol. ( define ( map-arbol f arbol ) ( construye-arbol ( f ( dato-arbol arbol )) ( map-bosque f ( hijos-arbol arbol )))) ( define ( map-bosque f bosque ) ( if ( null? bosque ) ' () ( cons ( map-arbol f ( first bosque )) ( map-bosque f ( rest bosque ))))) Ejemplos: ( map-arbol cuadrado ' ( 2 ( 3 ( 4 ) ( 5 )) ( 6 ))) ; \u21d2 (4 (9 (16) (25)) (36)) ( map-arbol ( lambda ( x ) ( + x 1 )) ' ( 2 ( 3 ( 4 ) ( 5 )) ( 6 ))) ; \u21d2 (3 (4 (5) (6)) (7)) Con map : ( define ( map-arbol-fos f arbol ) ( construye-arbol ( f ( dato-arbol arbol )) ( map ( lambda ( x ) ( map-arbol-fos f x )) ( hijos-arbol arbol )))) 2.2.5. Funci\u00f3n altura-arbol \u00b6 Vamos por \u00faltimo a definir una funci\u00f3n que devuelve la altura de un \u00e1rbol. Recordemos las siguientes definiciones relacionadas con los \u00e1rboles: Longitud de un camino entre dos nodos: n\u00famero de aristas. Altura de un nodo: longitud del camino m\u00e1s largo del nodo a una hoja. Profundidad de un nodo: longitud del camino de la ra\u00edz al nodo. Profundidad de un \u00e1rbol: profundidad del nodo m\u00e1s profundo. Nivel de un nodo: n\u00famero de predecesores. Altura de \u00e1rbol: altura de la ra\u00edz. Podemos implementar la altura de una forma similar a como hicimos con las listas estructuradas: calculamos la altura de los \u00e1rboles hijos, nos quedamos con la mayor, y sumamos 1 para a\u00f1adir la arista del camino de la ra\u00edz al hijo. La mayor altura de los hijos la calculamos con la funci\u00f3n altura-bosque . ( define ( altura-arbol arbol ) ( if ( hoja-arbol? arbol ) 0 ( + 1 ( altura-bosque ( hijos-arbol arbol ))))) ( define ( altura-bosque bosque ) ( if ( null? bosque ) 0 ( max ( altura-arbol ( first bosque )) ( altura-bosque ( rest bosque ))))) Ejemplos: ( altura-arbol ' ( 2 )) ; \u21d2 0 ( altura-arbol ' ( 4 ( 9 ( 16 ) ( 25 )) ( 36 ))) ; \u21d2 2 La soluci\u00f3n con funciones de orden superior es similar a la que vimos con listas estructuradas: ( define ( altura-arbol-fos arbol ) ( if ( hoja-arbol? arbol ) 0 ( + 1 ( foldr max 0 ( map altura-arbol-fos ( hijos-arbol arbol )))))) La funci\u00f3n map mapea sobre los \u00e1rboles hijos la propia funci\u00f3n, que calcula la altura de cada hijo (ser\u00e1 uno menos que la altura del padre, 0 si se trata de una hoja). La funci\u00f3n map devuelve entonces una lista altura de los hijos, de la que obtenemos el m\u00e1ximo plegando la lista con la funci\u00f3n max . Por \u00faltimo sumamos 1 para devolver la altura del \u00e1rbol completo (un nivel m\u00e1s que el nivel m\u00e1ximo de los hijos). 3. Arboles binarios \u00b6 3.1. Definici\u00f3n de \u00e1rboles binarios en Scheme \u00b6 Los \u00e1rboles binarios son \u00e1rboles cuyos nodos tienen 0, 1 o 2 hijos. Por ejemplo, el \u00e1rbol mostrado en la siguiente figura es un \u00e1rbol binario. A diferencia de los \u00e1rboles gen\u00e9ricos vistos anteriormente un \u00e1rbol binario no puede tener m\u00e1s de dos hijos. Los representaremos en Scheme utilizando una lista de tres elementos: Dato Hijo izquierdo (otro \u00e1rbol binario) Hijo derecho (otro \u00e1rbol binario) En el caso en que no exista el hijo izquierdo o el derecho (o ambos) utilizaremos una lista vac\u00eda para indicar un nodo vac\u00edo. De esta manera, un nodo hoja con el dato 10 se representar\u00e1 en Scheme con la lista: ( 10 () ()) Por ejemplo, representamos el \u00e1rbol de la figura anterior con la siguiente lista: ( 40 ( 18 ( 3 () ()) ( 23 () ( 29 () ()))) ( 52 ( 47 () ()) ())) Visualmente lo podemos representar de la siguiente forma. La no existencia de un hijo izquierdo o un hijo derecho se representa por una lista vac\u00eda. 3.1.1. Barrera de abstracci\u00f3n \u00b6 Definimos la siguiente barrera de abstracci\u00f3n para los \u00e1rboles binarios. Terminamos todos los nombres de las funciones con el sufijo -arbolb (\u00e1rbol binario). Selectores Los selectores de la barrera de abstracci\u00f3n del \u00e1rbol binario son los siguientes. ( define ( dato-arbolb arbol ) ( first arbol )) ( define ( hijo-izq-arbolb arbol ) ( second arbol )) ( define ( hijo-der-arbolb arbol ) ( third arbol )) ( define arbolb-vacio ' ()) ( define ( vacio-arbolb? arbol ) ( equal? arbol arbolb-vacio )) ( define ( hoja-arbolb? arbol ) ( and ( vacio-arbolb? ( hijo-izq-arbolb arbol )) ( vacio-arbolb? ( hijo-der-arbolb arbol )))) Como parte de la barrera de abstracci\u00f3n definimos la constante arbolb-vacio , que toma el valor de una lista vac\u00eda. Constructor ( define ( construye-arbolb dato hijo-izq hijo-der ) ( list dato hijo-izq hijo-der )) Por ejemplo, para construir un \u00e1rbol con 10 en la ra\u00edz y 8 en su hijo izquierdo y 15 en su derecho utilizando el constructor de la barrera de abstracci\u00f3n: ( define arbolb1 ( construye-arbolb 10 ( construye-arbolb 8 arbolb-vacio arbolb-vacio ) ( construye-arbolb 15 arbolb-vacio arbolb-vacio ))) Otro ejemplo, el \u00e1rbol binario de la figura anterior utilizando el constructor de la barrera de abstracci\u00f3n: ( define arbolb2 ( construye-arbolb 40 ( construye-arbolb 18 ( construye-arbolb 3 arbolb-vacio arbolb-vacio ) ( construye-arbolb 23 arbolb-vacio ( construye-arbolb 29 arbolb-vacio arbolb-vacio ))) ( construye-arbolb 52 ( construye-arbolb 47 arbolb-vacio arbolb-vacio ) arbolb-vacio ))) 3.2. Funciones recursivas sobre \u00e1rboles binarios \u00b6 Veamos las siguientes funciones recursivas sobre \u00e1rboles binarios: (suma-datos-arbolb arbol) : devuelve la suma de todos los nodos (to-list-arbolb arbol) : devuelve una lista con los datos del \u00e1rbol (cuadrado-arbolb arbol) : eleva al cuadrado todos los datos de un \u00e1rbol manteniendo la estructura del \u00e1rbol original Estas funciones utilizan una mezcla de los patrones usados en la recursi\u00f3n para trabajar con \u00e1rboles gen\u00e9ricos y la recursi\u00f3n para trabajar con listas estructuradas. Tenemos un dato en la ra\u00edz, que tenemos que combinar con lo que devuelve la recursi\u00f3n aplicada sobre el hijo izquierdo y lo que devuelve la recursi\u00f3n aplicada sobre el hijo derecho. suma-datos-arbolb ( define ( suma-datos-arbolb arbol ) ( if ( vacio-arbolb? arbol ) 0 ( + ( dato-arbolb arbol ) ( suma-datos-arbolb ( hijo-izq-arbolb arbol )) ( suma-datos-arbolb ( hijo-der-arbolb arbol ))))) ( suma-datos-arbolb arbolb2 ) ; \u21d2 212 Como el hijo izquierdo y el hijo derecho son tambi\u00e9n \u00e1rboles binarios, podemos llamar a la recursi\u00f3n con esos \u00e1rboles. Esas llamadas recursivas nos devolver\u00e1n la suma de los datos en cada sub\u00e1rbol. Y sumamos el dato de la ra\u00edz. Para definir el caso base, podemos ver que en cada llamada recursiva vamos obteniendo el hijo izquierdo y el hijo derecho. Al final llegaremos a un \u00e1rbol vac\u00edo, en cuyo caso devolvemos 0. La siguiente figura representa el funcionamiento del caso general. to-list-arbolb La funci\u00f3n to-list-arbolb es similar a la vista con los \u00e1rboles gen\u00e9ricos. Recibe un \u00e1rbol binario y devuelve una lista con los datos en un recorrido preorden. ( define ( to-list-arbolb arbol ) ( if ( vacio-arbolb? arbol ) ' () ( cons ( dato-arbolb arbol ) ( append ( to-list-arbolb ( hijo-izq-arbolb arbol )) ( to-list-arbolb ( hijo-der-arbolb arbol )))))) ( to-list-arbolb arbolb2 ) ; \u21d2 (40 18 3 23 29 52 47) El funcionamiento es similar a la suma: llamamos a la recursi\u00f3n por la izquierda y por la derecha. El resultado de las llamadas recursivas ser\u00e1n dos listas que tenemos que concatenar con append . Y por \u00faltimos a\u00f1adimos en cabeza el dato de la ra\u00edz con cons . cuadrado-arbolb Por \u00faltimo, la funci\u00f3n cuadrado-arbolb construye un nuevo \u00e1rbol binario elevando al cuadrado el dato de la ra\u00edz, su hijo izquierdo y su hijo derecho. Para construir el \u00e1rbol binario llamamos al constructor construye-arbolb . ( define ( cuadrado-arbolb arbol ) ( if ( vacio-arbolb? arbol ) arbolb-vacio ( construye-arbolb ( cuadrado ( dato-arbolb arbol )) ( cuadrado-arbolb ( hijo-izq-arbolb arbol )) ( cuadrado-arbolb ( hijo-der-arbolb arbol ))))) ( cuadrado-arbolb arbolb1 ) ; \u21d2 (100 (64 () ()) (225 () ())) 4. Bibliograf\u00eda - SICP \u00b6 En este tema explicamos conceptos de los siguientes cap\u00edtulos del libro Structure and Intepretation of Computer Programs : 2.2.2 - Hierarchical Structures Lenguajes y Paradigmas de Programaci\u00f3n, curso 2021-22 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Domingo Gallardo, Cristina Pomares, Antonio Bot\u00eda, Francisco Mart\u00ednez","title":"Tema 4: Estructuras recursivas"},{"location":"teoria/tema04-estructuras-recursivas/tema04-estructuras-recursivas.html#tema-4-estructuras-de-datos-recursivas","text":"","title":"Tema 4: Estructuras de datos recursivas"},{"location":"teoria/tema04-estructuras-recursivas/tema04-estructuras-recursivas.html#1-listas-estructuradas","text":"Hemos visto que las listas en Scheme se implementan como un estructura de datos recursiva, formada por una pareja que enlaza en su parte derecha el resto de la lista y que termina con una parte derecha en la que hay una lista vac\u00eda. En este apartado vamos a volver a estudiar las listas desde un nivel de abstracci\u00f3n alto, usando las funciones: (first lista) para obtener el primer elemento de una lista (rest lista) para obtener el resto de la lista (cons dato lista) para construir una nueva lista con el dato como primer elemento En la mayor\u00eda de funciones y ejemplos que hemos visto hasta ahora las listas est\u00e1n formadas por datos y el recorrido por la lista es un recorrido lineal, iterando por sus elementos. En este apartado vamos a ampliar este concepto y estudiar c\u00f3mo trabajar con listas que contienen otras listas . Veremos que esto cambia fundamentalmente la estructura de las listas y de las funciones que van a operar con ellas. El cambio fundamental es que la funci\u00f3n first lista puede devolver dos tipos de elementos: Un elemento de la lista (del tipo de elementos que hay en la lista) Otra lista (formada por el tipo de elementos de la lista)","title":"1. Listas estructuradas"},{"location":"teoria/tema04-estructuras-recursivas/tema04-estructuras-recursivas.html#11-definicion-y-ejemplos","text":"Las listas en Scheme pueden tener cualquier tipo de elementos, incluido otras listas. Llamaremos lista estructurada a una lista que contiene otras sublistas. Lo contrario de lista estructurada es una lista plana , una lista formada por elementos que no son listas. Llamaremos hojas a los elementos de una lista que no son sublistas. A las listas estructuradas cuyas hojas son s\u00edmbolos se les denomina en el contexto de la programaci\u00f3n funcional expresiones-S ( S-expression ). Por ejemplo, la lista estructurada: (a b (c d e) (f (g h))) es una lista estructurada con 4 elementos: El elemento 'a , una hoja El elemento 'b , otra hoja La lista plana (c d e) La lista estructurada (f (g h)) Se puede construir con cualquiera de las siguientes expresiones: ( define lista ( list ' a ' b ( list ' c ' d ' e ) ( list ' f ( list ' g ' h )))) ( define lista ' ( a b ( c d e ) ( f ( g h )))) Una lista formada por parejas la consideraremos una lista plana, ya que no contiene ninguna sublista. Por ejemplo, la lista (( a . 3 ) ( b . 5 ) ( c . 12 )) es una lista plana de tres elementos (hojas) que son parejas.","title":"1.1. Definici\u00f3n y ejemplos"},{"location":"teoria/tema04-estructuras-recursivas/tema04-estructuras-recursivas.html#12-funciones-recursivas-sobre-listas-estructuradas","text":"","title":"1.2. Funciones recursivas sobre listas estructuradas"},{"location":"teoria/tema04-estructuras-recursivas/tema04-estructuras-recursivas.html#2-arboles","text":"","title":"2. \u00c1rboles"},{"location":"teoria/tema04-estructuras-recursivas/tema04-estructuras-recursivas.html#21-definicion-de-arboles-en-scheme","text":"","title":"2.1. Definici\u00f3n de \u00e1rboles en Scheme"},{"location":"teoria/tema04-estructuras-recursivas/tema04-estructuras-recursivas.html#22-funciones-recursivas-sobre-arboles","text":"Vamos a dise\u00f1ar las siguientes funciones recursivas: (suma-datos-arbol arbol) : devuelve la suma de todos los nodos (to-list-arbol arbol) : devuelve una lista con los datos del \u00e1rbol (cuadrado-arbol arbol) : eleva al cuadrado todos los datos de un \u00e1rbol manteniendo la estructura del \u00e1rbol original (map-arbol f arbol) : devuelve un \u00e1rbol con la estructura del \u00e1rbol original aplicando la funci\u00f3n f a subdatos. (altura-arbol arbol) : devuelve la altura de un \u00e1rbol Todas comparten un patr\u00f3n similar de recursi\u00f3n mutua.","title":"2.2. Funciones recursivas sobre \u00e1rboles"},{"location":"teoria/tema04-estructuras-recursivas/tema04-estructuras-recursivas.html#3-arboles-binarios","text":"","title":"3. Arboles binarios"},{"location":"teoria/tema04-estructuras-recursivas/tema04-estructuras-recursivas.html#31-definicion-de-arboles-binarios-en-scheme","text":"Los \u00e1rboles binarios son \u00e1rboles cuyos nodos tienen 0, 1 o 2 hijos. Por ejemplo, el \u00e1rbol mostrado en la siguiente figura es un \u00e1rbol binario. A diferencia de los \u00e1rboles gen\u00e9ricos vistos anteriormente un \u00e1rbol binario no puede tener m\u00e1s de dos hijos. Los representaremos en Scheme utilizando una lista de tres elementos: Dato Hijo izquierdo (otro \u00e1rbol binario) Hijo derecho (otro \u00e1rbol binario) En el caso en que no exista el hijo izquierdo o el derecho (o ambos) utilizaremos una lista vac\u00eda para indicar un nodo vac\u00edo. De esta manera, un nodo hoja con el dato 10 se representar\u00e1 en Scheme con la lista: ( 10 () ()) Por ejemplo, representamos el \u00e1rbol de la figura anterior con la siguiente lista: ( 40 ( 18 ( 3 () ()) ( 23 () ( 29 () ()))) ( 52 ( 47 () ()) ())) Visualmente lo podemos representar de la siguiente forma. La no existencia de un hijo izquierdo o un hijo derecho se representa por una lista vac\u00eda.","title":"3.1. Definici\u00f3n de \u00e1rboles binarios en Scheme"},{"location":"teoria/tema04-estructuras-recursivas/tema04-estructuras-recursivas.html#32-funciones-recursivas-sobre-arboles-binarios","text":"Veamos las siguientes funciones recursivas sobre \u00e1rboles binarios: (suma-datos-arbolb arbol) : devuelve la suma de todos los nodos (to-list-arbolb arbol) : devuelve una lista con los datos del \u00e1rbol (cuadrado-arbolb arbol) : eleva al cuadrado todos los datos de un \u00e1rbol manteniendo la estructura del \u00e1rbol original Estas funciones utilizan una mezcla de los patrones usados en la recursi\u00f3n para trabajar con \u00e1rboles gen\u00e9ricos y la recursi\u00f3n para trabajar con listas estructuradas. Tenemos un dato en la ra\u00edz, que tenemos que combinar con lo que devuelve la recursi\u00f3n aplicada sobre el hijo izquierdo y lo que devuelve la recursi\u00f3n aplicada sobre el hijo derecho. suma-datos-arbolb ( define ( suma-datos-arbolb arbol ) ( if ( vacio-arbolb? arbol ) 0 ( + ( dato-arbolb arbol ) ( suma-datos-arbolb ( hijo-izq-arbolb arbol )) ( suma-datos-arbolb ( hijo-der-arbolb arbol ))))) ( suma-datos-arbolb arbolb2 ) ; \u21d2 212 Como el hijo izquierdo y el hijo derecho son tambi\u00e9n \u00e1rboles binarios, podemos llamar a la recursi\u00f3n con esos \u00e1rboles. Esas llamadas recursivas nos devolver\u00e1n la suma de los datos en cada sub\u00e1rbol. Y sumamos el dato de la ra\u00edz. Para definir el caso base, podemos ver que en cada llamada recursiva vamos obteniendo el hijo izquierdo y el hijo derecho. Al final llegaremos a un \u00e1rbol vac\u00edo, en cuyo caso devolvemos 0. La siguiente figura representa el funcionamiento del caso general. to-list-arbolb La funci\u00f3n to-list-arbolb es similar a la vista con los \u00e1rboles gen\u00e9ricos. Recibe un \u00e1rbol binario y devuelve una lista con los datos en un recorrido preorden. ( define ( to-list-arbolb arbol ) ( if ( vacio-arbolb? arbol ) ' () ( cons ( dato-arbolb arbol ) ( append ( to-list-arbolb ( hijo-izq-arbolb arbol )) ( to-list-arbolb ( hijo-der-arbolb arbol )))))) ( to-list-arbolb arbolb2 ) ; \u21d2 (40 18 3 23 29 52 47) El funcionamiento es similar a la suma: llamamos a la recursi\u00f3n por la izquierda y por la derecha. El resultado de las llamadas recursivas ser\u00e1n dos listas que tenemos que concatenar con append . Y por \u00faltimos a\u00f1adimos en cabeza el dato de la ra\u00edz con cons . cuadrado-arbolb Por \u00faltimo, la funci\u00f3n cuadrado-arbolb construye un nuevo \u00e1rbol binario elevando al cuadrado el dato de la ra\u00edz, su hijo izquierdo y su hijo derecho. Para construir el \u00e1rbol binario llamamos al constructor construye-arbolb . ( define ( cuadrado-arbolb arbol ) ( if ( vacio-arbolb? arbol ) arbolb-vacio ( construye-arbolb ( cuadrado ( dato-arbolb arbol )) ( cuadrado-arbolb ( hijo-izq-arbolb arbol )) ( cuadrado-arbolb ( hijo-der-arbolb arbol ))))) ( cuadrado-arbolb arbolb1 ) ; \u21d2 (100 (64 () ()) (225 () ()))","title":"3.2. Funciones recursivas sobre \u00e1rboles binarios"},{"location":"teoria/tema04-estructuras-recursivas/tema04-estructuras-recursivas.html#4-bibliografia-sicp","text":"En este tema explicamos conceptos de los siguientes cap\u00edtulos del libro Structure and Intepretation of Computer Programs : 2.2.2 - Hierarchical Structures Lenguajes y Paradigmas de Programaci\u00f3n, curso 2021-22 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Domingo Gallardo, Cristina Pomares, Antonio Bot\u00eda, Francisco Mart\u00ednez","title":"4. Bibliograf\u00eda - SICP"},{"location":"teoria/tema05-bis-programacion-imperativa/ambitos-let-clousures.html","text":"6. \u00c1mbitos de variables, let y closures \u00b6 Ahora que hemos introducido la forma especial lambda y la idea de que una funci\u00f3n es un objeto de primera clase, podemos revisar el concepto de \u00e1mbito de variables en Scheme e introducir un importante concepto: clausura ( closure en ingl\u00e9s). 6.1. \u00c1mbitos de variables \u00b6 El concepto del \u00e1mbito de vida de las variables es un concepto fundamental en los lenguajes de programaci\u00f3n. En ingl\u00e9s se utiliza el t\u00e9rmino scope . Cuando se define una variable, asoci\u00e1ndole un valor, esta asociaci\u00f3n tiene una extensi\u00f3n determinada, ya sea en t\u00e9rminos de tiempo de compilaci\u00f3n ( \u00e1mbito l\u00e9xico ) como en t\u00e9rminos de tiempo de ejecuci\u00f3n ( \u00e1mbito din\u00e1mico ). El \u00e1mbito de una variable determina cu\u00e1ndo podemos referirnos a ella para recuperar el valor asociado. Al conjunto de variables disponibles en una parte del programa o en una parte de su ejecuci\u00f3n se denomina contexto o entorno ( context o environment ). Variables de \u00e1mbito global \u00b6 Una variable definida en el programa con la instrucci\u00f3n define tiene un \u00e1mbito global. (define a \"hola\") (define b (string-append \"adios\" a)) (define cuadrado (lambda (x) (* x x))) Todas las variables definidas fuera de funciones forman parte del entorno global del programa. Variables de \u00e1mbito local \u00b6 Como en la mayor\u00eda de lenguajes de programaci\u00f3n, en Scheme se crea un entorno local cada vez que se invoca a una funci\u00f3n. En este entorno local los argumentos de la funci\u00f3n toman los valores de los par\u00e1metros usados en la llamada a la funci\u00f3n. Consideramos, por tanto, estos par\u00e1metros como variables de \u00e1mbito local de la funci\u00f3n. Podemos usar en un entorno local una variable con el mismo nombre que en el entorno global. Cuando se ejecute el c\u00f3digo de la funci\u00f3n se evaluar\u00e1 la variable de \u00e1mbito local. Por ejemplo, supongamos las expresiones: ( define x 5 ) ( define ( suma-3 x ) ( + x 3 )) ( suma-3 12 ) \u21d2 15 Cuando se ejecuta la expresi\u00f3n (+ x 3) en la invocaci\u00f3n a (suma-3 12) el valor de x es 12, no es 5, devolvi\u00e9ndose 15. Una vez realizada la invocaci\u00f3n, desparece el entorno local y las variables locales definidas en \u00e9l, recuper\u00e1ndose el contexto global. Por ejemplo, en la siguiente expresi\u00f3n, una vez realizada la invocaci\u00f3n a (suma-3 12) se devuelve el n\u00famero 15 y se eval\u00faa en el entorno global la expresi\u00f3n (+ 15 x) . En este contexto la variable x vale 5 por lo que la expresi\u00f3n devuelve 20. ( define x 5 ) ( define ( suma-3 x ) ( + x 3 )) ( + ( suma-3 12 ) x ) \u21d2 20 En el entorno local tambi\u00e9n se pueden utilizar variables definidas en el entorno global. Por ejemplo: (define y 12) (define (suma-3-bis x) (+ x y 3)) (suma-3-bis 5) \u21d2 20 La expresi\u00f3n (+ x 3 y) se eval\u00faa en el entorno local en el que x vale 5. Al no estar definida la variable y en este entorno local, se usa su definici\u00f3n de \u00e1mbito global. 6.2 Forma especial let \u00b6 Forma especial let \u00b6 En Scheme se define la forma especial let que permite crear un entorno local en el que se da valor a variables y se eval\u00faa una expresi\u00f3n. Sintaxis: ( let (( <var1> <exp-1> ) ... ( <varn> <exp-n> )) <cuerpo> ) Las variables var1 , \u2026 varn toman los valores devueltos por las expresiones exp1 , \u2026 expn y el cuerpo se eval\u00faa con esos valores. Por ejemplo: ( define x 10 ) ( define y 20 ) ( let (( x 1 ) ( y 2 ) ( z 3 )) ( + x y z )) \u21d2 6 El \u00e1mbito de las variables definidas en el let es local \u00b6 Las variables definidas en el let s\u00f3lo tienen valores en el entorno creado por la forma especial. ( define x 10 ) ( define y 20 ) ( let (( x 1 ) ( y 2 ) ( z 3 )) ( + x y z )) \u21d2 6 Cuando ha terminado la evaluaci\u00f3n del let el \u00e1mbito local desaparece y quedan los valores definidos en el \u00e1mbito global. x \u21d2 5 y \u21d2 error, no definida Let permite usar variables definidas en un \u00e1mbito en el que se ejecuta el let \u00b6 Al igual que en la invocaci\u00f3n a funciones, desde el \u00e1mbito definido por el let se puede usar las variables del entorno en el que se est\u00e1 ejecutando el let . Por ejemplo, en el siguiente c\u00f3digo se usa la variable z definida en el \u00e1mbito global. ( define z 8 ) ( let (( x 1 ) ( y 2 )) ( + x y z )) \u21d2 11 Variables en las definiciones del let \u00b6 Las expresiones que dan valor a las variables del let se eval\u00faan todas en el entorno en el que se ejecuta el let , antes de crear las variables locales. No se realiza una asignaci\u00f3n secuencial: ( define x 1 ) ( let (( w ( + x 3 )) ( z ( + w 2 ))) ;; Error: w no est\u00e1 definida ( + w z )) Sem\u00e1ntica del let \u00b6 Para evaluar una expresi\u00f3n let debemos seguir las siguientes reglas: Evaluar todas las expresiones de la derecha de las variables y guardar sus valores en variables auxiliares locales. Definir un \u00e1mbito local en el que se ligan las variables del let con los valores de las variables auxiliares. Evaluar el cuerpo del let en el \u00e1mbito local Let se define utilizando lambda \u00b6 La sem\u00e1ntica anterior queda clara cuando comprobamos que let se puede definir en funci\u00f3n de lambda. En general, la expresi\u00f3n: ( let (( <var1> <exp1> ) ... ( <varn> <expn> )) <cuerpo> ) se puede implementar con la siguiente llamada a lambda: (( lambda ( <var1> ... <varn> ) <cuerpo> ) <exp1> ... <expn> ) Para ejecutar un let con un lambda se debe crear un procedimiento en tiempo de ejecuci\u00f3n con tantas variables como las variables del let , con el cuerpo del let , y se debe invocar a dicho procedimiento con las expresiones de las variables del let . Esas expresiones se eval\u00faan antes de invocar al procedimiento y la invocaci\u00f3n se realiza con los resultados. La invocaci\u00f3n crea un entorno local con los par\u00e1metros del procedimiento (las variables del let ) asociados a los valores, y en este \u00e1mbito local se ejecuta el cuerpo del procedimiento (el cuerpo del let ). Por ejemplo: (let ((x (+ 2 3)) (y (+ x 3))) (+ x y)) Equivale a: (( lambda ( x y ) ( + x y )) ( + 2 3 ) ( + x 3 )) Let dentro de funciones \u00b6 Podemos usar let en el cuerpo de funciones para crear nuevas variables locales, adem\u00e1s de los par\u00e1metros de la funci\u00f3n ( define ( suma-cuadrados x y ) ( let (( cuadrado-x ( cuadrado x )) ( cuadrado-y ( cuadrado y ))) ( + cuadrado-x cuadrado-y ))) ( suma-cuadrados 4 10 ) \u21d2 116 Cuando se invoca (suma-cuadrados 4 10) se crea un entorno local en el que las variables x e y toman el valor 4 y 10 y en el que se ejecuta la forma especial let . Esta forma especial crea a su vez un entorno local en el que se definen las variables cuadrado-x y cuadrado-y que toman los valores devueltos por las expresiones (cuadrado x) y (cuadrado y) : 16 y 100 . En este entorno local se eval\u00faa la expresi\u00f3n (+ cuadrado-x cuadrado-y) . El uso de let permite aumentar la legibilidad de los programas, dando nombre a expresiones: Por ejemplo: ( define ( distancia x1 y1 x2 y2 ) ( let (( distancia-x ( - x2 x1 )) ( distancia-y ( - y2 y1 ))) ( sqrt ( + ( cuadrado distancia-x ) ( cuadrado distancia-y ))))) Otro ejemplo: ( define ( intersecta-intervalo a1 a2 b1 b2 ) ( let (( dentro-b1 ( and ( >= b1 a1 ) ( <= b1 a2 ))) ( dentro-b2 ( and ( >= b2 a1 ) ( <= b2 a2 )))) ( or dentro-b1 dentro-b2 ))) 6.3. Clausuras \u00b6 Vamos a terminar explicando el concepto de clausura . Hemos visto que las funciones son objetos de primera clase de Scheme y que es posible crear funciones en tiempo de ejecuci\u00f3n con la forma especial lambda . Una clausura es una funci\u00f3n devuelta por otra funci\u00f3n. La clausura captura las variables locales de la funci\u00f3n principal y puede usarlas en su propio c\u00f3digo cuando este se invoque posteriormente. Veamos un ejemplo. Supongamos que definimos la siguiente funci\u00f3n (make-sumador k) que devuelve otra funci\u00f3n. (define (make-sumador k) (lambda (x) (+ x k))) (define f (make-sumador 10)) (f 2) \u21d2 12 En la funci\u00f3n (make-sumador k) se llama a la forma especial lambda para crear un procedimiento. El procedimiento devuelto es lo que se denomina clausura . En este caso la clausura captura la variable local k (el par\u00e1metro de make-sumador ) y usa su valor cuando posteriormente se invoca. Cuando se invoca a (f 2) se ejecuta la clausura y se crea un nuevo entorno local en el que x (el par\u00e1metro de la clausura) vale 2 y en el que se usa la variable k capturada. En la invocaci\u00f3n anterior (f 2) , cuando se ejecuta la expresi\u00f3n (+ x k) las variables tienen los siguientes valores: x: 2 (variable local de la clausura) k: 10 (valor capturado del entorno local en el que se cre\u00f3 la clausura Las variables locales creadas en un let tambi\u00e9n se capturan en las clausuras \u00b6 Veamos el siguiente ejemplo, en el que creamos una funci\u00f3n en un entorno local creado por un let : ( define x 10 ) ( define y 12 ) ( define ( prueba x ) ( let (( y 3 )) ( lambda ( z ) ( + x y z )))) ( define h ( prueba 5 )) ( h 2 ) \u21d2 8 Sucede lo siguiente: Se invoca la expresi\u00f3n (prueba 5) . Esto crea un entorno local en el que se le da a la variable x (el par\u00e1metro de prueba ) el valor 5 . En este contexto se ejecuta el let , que crea otro entorno local en el que y vale 3. En el contexto del let se crea una clausura con la invocaci\u00f3n de la expresi\u00f3n lambda (lambda (z) (+ x y z)) . La clausura captura las variables locales x e y con sus valores 5 y 3 y la funci\u00f3n prueba la devuelve como resultado de la invocaci\u00f3n. La clausura se guarda en la variable h . Con la invocaci\u00f3n (h 2) se invoca a la clausura, lo que crea un entorno local en el que se encuentran las siguientes variables: z: 2 (par\u00e1metro de la clausura) x: 5 (variable local de la funci\u00f3n prueba capturada en el momento de creaci\u00f3n de la clausura)) y: 3 (variable local del let capturada en el momento de creaci\u00f3n de la clausura) En este contexto se ejecuta la expresi\u00f3n (+ x y z) , que devuelve 10. Lenguajes y Paradigmas de Programaci\u00f3n, curso 2015-16 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Domingo Gallardo, Cristina Pomares","title":"Ambitos let clousures"},{"location":"teoria/tema05-bis-programacion-imperativa/ambitos-let-clousures.html#6-ambitos-de-variables-let-y-closures","text":"Ahora que hemos introducido la forma especial lambda y la idea de que una funci\u00f3n es un objeto de primera clase, podemos revisar el concepto de \u00e1mbito de variables en Scheme e introducir un importante concepto: clausura ( closure en ingl\u00e9s).","title":"6. \u00c1mbitos de variables, let y closures"},{"location":"teoria/tema05-bis-programacion-imperativa/ambitos-let-clousures.html#61-ambitos-de-variables","text":"El concepto del \u00e1mbito de vida de las variables es un concepto fundamental en los lenguajes de programaci\u00f3n. En ingl\u00e9s se utiliza el t\u00e9rmino scope . Cuando se define una variable, asoci\u00e1ndole un valor, esta asociaci\u00f3n tiene una extensi\u00f3n determinada, ya sea en t\u00e9rminos de tiempo de compilaci\u00f3n ( \u00e1mbito l\u00e9xico ) como en t\u00e9rminos de tiempo de ejecuci\u00f3n ( \u00e1mbito din\u00e1mico ). El \u00e1mbito de una variable determina cu\u00e1ndo podemos referirnos a ella para recuperar el valor asociado. Al conjunto de variables disponibles en una parte del programa o en una parte de su ejecuci\u00f3n se denomina contexto o entorno ( context o environment ).","title":" 6.1. \u00c1mbitos de variables"},{"location":"teoria/tema05-bis-programacion-imperativa/ambitos-let-clousures.html#62-forma-especial-let","text":"","title":" 6.2 Forma especial let"},{"location":"teoria/tema05-bis-programacion-imperativa/ambitos-let-clousures.html#63-clausuras","text":"Vamos a terminar explicando el concepto de clausura . Hemos visto que las funciones son objetos de primera clase de Scheme y que es posible crear funciones en tiempo de ejecuci\u00f3n con la forma especial lambda . Una clausura es una funci\u00f3n devuelta por otra funci\u00f3n. La clausura captura las variables locales de la funci\u00f3n principal y puede usarlas en su propio c\u00f3digo cuando este se invoque posteriormente. Veamos un ejemplo. Supongamos que definimos la siguiente funci\u00f3n (make-sumador k) que devuelve otra funci\u00f3n. (define (make-sumador k) (lambda (x) (+ x k))) (define f (make-sumador 10)) (f 2) \u21d2 12 En la funci\u00f3n (make-sumador k) se llama a la forma especial lambda para crear un procedimiento. El procedimiento devuelto es lo que se denomina clausura . En este caso la clausura captura la variable local k (el par\u00e1metro de make-sumador ) y usa su valor cuando posteriormente se invoca. Cuando se invoca a (f 2) se ejecuta la clausura y se crea un nuevo entorno local en el que x (el par\u00e1metro de la clausura) vale 2 y en el que se usa la variable k capturada. En la invocaci\u00f3n anterior (f 2) , cuando se ejecuta la expresi\u00f3n (+ x k) las variables tienen los siguientes valores: x: 2 (variable local de la clausura) k: 10 (valor capturado del entorno local en el que se cre\u00f3 la clausura","title":" 6.3. Clausuras"},{"location":"teoria/tema05-bis-programacion-imperativa/tema05-programacion-imperativa.html","text":"Tema 5: Programaci\u00f3n imperativa \u00b6 Contenidos \u00b6 1. Historia y caracter\u00edsticas de la programaci\u00f3n imperativa 1.1. Historia de la programaci\u00f3n imperativa 1.2. Caracter\u00edsticas principales de la programaci\u00f3n imperativa 2. Programaci\u00f3n imperativa en Scheme 2.1. Pasos de ejecuci\u00f3n 2.2. Mutaci\u00f3n con formas especiales set! 2.3. Igualdad de referencia y de valor 3. Estructuras de datos mutables 3.1. Mutaci\u00f3n de elementos 3.2. Funciones mutadoras: make-ciclo! , append! y intercambia! 3.3. Lista ordenada mutable 3.4. Diccionario mutable 3.5. Ejemplo de mutaci\u00f3n con listas de asociaci\u00f3n 4. \u00c1mbitos de variables y clausuras 4.1. Variables de \u00e1mbito global 4.2. Variables de \u00e1mbito local 4.3. Clausuras y estado local 5. Clausuras con mutaci\u00f3n = estado local mutable 5.1. Estado local mutable 5.2. Paso de mensajes Bibliograf\u00eda \u00b6 En este tema explicamos conceptos de los siguientes cap\u00edtulos del libro Structure and Intepretation of Computer Programs : 3.3.1 Mutable List Structure 3.3.2 Representing Queues 3.3.3 Representing tables 3.1.1 Local State Variables 3.1.3 The Cost of Introducing Assignment 1. Historia y caracter\u00edsticas de la programaci\u00f3n imperativa \u00b6 1.1. Historia de la programaci\u00f3n imperativa \u00b6 1.1.1. Or\u00edgenes de la programaci\u00f3n imperativa \u00b6 La programaci\u00f3n imperativa es la forma natural de programar un computador, es el estilo de programaci\u00f3n que se utiliza en el ensamblador, el estilo m\u00e1s cercano a la arquitectura del computador Caracter\u00edsticas de la arquitectura arquitectura cl\u00e1sica de Von Newmann : memoria donde se almacenan los datos (referenciables por su direcci\u00f3n de memoria) y el programa unidad de control que ejecuta las instrucciones del programa (contador del programa) Los primeros lenguajes de programaci\u00f3n (como el Fortran) son abstracciones del ensamblador y de esta arquitectura. Lenguajes m\u00e1s modernos como el BASIC o el C han continuado con esta idea. 1.1.2. Programaci\u00f3n procedural \u00b6 Uso de procedimientos y subrutinas Los cambios de estado se localizan en estos procedimientos Los procedimientos especifican par\u00e1metros y valores devueltos (un primer paso hacia la abstracci\u00f3n y los modelos funcionales y declarativos) Primer lenguaje con estas ideas: ALGOL 1.1.3. Programaci\u00f3n estructurada \u00b6 Art\u00edculo a finales de los 60 de Edsger W. Dijkstra: GOTO statement considered harmful en el que se arremete contra la sentencia GOTO de muchos lenguajes de programaci\u00f3n de la \u00e9poca La programaci\u00f3n estructurada mantiene la programaci\u00f3n imperativa, pero haciendo \u00e9nfasis en la necesidad de que los programas sean correctos (debe ser posible de comprobar formalmente los programas), modulares y mantenibles. Lenguajes: Pascal, ALGOL 68, Ada 1.1.4. Programaci\u00f3n Orientada a Objetos \u00b6 La POO tambi\u00e9n utiliza la programaci\u00f3n imperativa, aunque extiende los conceptos de modularidad, mantenibilidad y estado local Se populariza a finales de los 70 y principios de los 80 1.2. Caracter\u00edsticas principales de la programaci\u00f3n imperativa \u00b6 Idea principal de la programaci\u00f3n imperativa: la computaci\u00f3n se realiza cambiando el estado del programa por medio de sentencias que definen pasos de ejecuci\u00f3n del computador Estado del programa modificable Sentencias de control que definen pasos de ejecuci\u00f3n Vamos a ver unos ejemplos de estas caracter\u00edsticas usando el lenguaje de programaci\u00f3n Java. 1.2.1. Modificaci\u00f3n de datos \u00b6 Uno de los elementos de la arquitectura de Von Newmann es la existencia de celdas de memoria referenciables y modificables int x = 0 ; x = x + 1 ; Otro ejemplo t\u00edpico de este concepto en los lenguajes de programaci\u00f3n es el array: una estructura de datos que se almacena directamente en memoria y que puede ser accedido y modificado. En Java los arrays son tipeados, mutables y de tama\u00f1o fijo String [] unoDosTres = { \"uno\" , \"dos\" , \"tres\" }; unoDosTres [ 0 ] = unoDosTres [ 2 ] ; Un ejemplo de un m\u00e9todo que recibe un par\u00e1metro de tipo array en Java. El par\u00e1metro se pasa por referencia: public void llenaCadenas ( String [] cadenas , String cadena ) { for ( int i = 0 ; i < cadenas . length ; i ++ ) { cadenas [ i ] = cadena ; } } Todos los ejemplos anteriores en un programa main Java: public class Main { public static void main ( String [] args ) { int x = 0 ; x = x + 1 ; System . out . println ( \"x: \" + x ); String [] unoDosTres = { \"uno\" , \"dos\" , \"tres\" }; unoDosTres [ 0 ] = unoDosTres [ 2 ] ; for ( String valor : unoDosTres ) { System . out . println ( valor ); } llenaCadenas ( unoDosTres , \"uno\" ); for ( String valor : unoDosTres ) { System . out . println ( valor ); } } public static void llenaCadenas ( String [] cadenas , String cadena ) { for ( int i = 0 ; i < cadenas . length ; i ++ ) { cadenas [ i ] = cadena ; } } } 1.2.2. Almacenamiento de datos en variables \u00b6 Todos los lenguajes de programaci\u00f3n definen variables que contienen datos Las variables pueden mantener valores (tipos de valor o value types) o referencias (tipos de referencia o reference types) En C, C++ o Java, los datos primitivos como int o char son de tipo valor y los objetos y datos compuestos son de tipo referencia La asignaci\u00f3n de un valor a una variable tiene implicaciones distintas si el tipo es de valor (se copia el valor) o de referencia (se copia la referencia) Copia de valor (datos primitivos en Java): int x = 10 ; int y = x ; x = 20 ; System . out . println ( y ); // Sigue siendo 10 Copia de referencia (objetos en Java): // import java.awt.geom.Point2D; Point2D p1 = new Point2D . Double ( 2.0 , 3.0 ); Point2D p2 = p1 ; p1 . setLocation ( 12.0 , 13.0 ); System . out . println ( \"p2.x = \" + p2 . getX ()); // 12.0 System . out . println ( \"p2.y = \" + p2 . getY ()); // 13.0 El uso de las referencias para los objetos de clases y para los tipos compuestos est\u00e1 generalizado en la mayor\u00eda de lenguajes de programaci\u00f3n Tiene efectos laterales pero permite obtener estructuras de datos eficientes 1.2.3. Igualdad de valor y de referencia \u00b6 Todos los lenguajes de programaci\u00f3n imperativos que permite la distinci\u00f3n entre valores y referencias implementan dos tipos de igualdad entre variables Igualdad de valor (el contenido de los datos de las variables es el mismo) Igualdad de referencia (las variables tienen la misma referencia) Igualdad de referencia => Igualdad de valor (pero al rev\u00e9s no) En Java la igualdad de referencia se define con == y la de valor con el m\u00e9todo equals : Point2D p1 = new Point2D . Double ( 2.0 , 3.0 ); Point2D p2 = p1 ; Point2D p3 = new Point2D . Double ( 2.0 , 3.0 ); System . out . println ( p1 == p2 ); // true System . out . println ( p1 == p3 ); // false System . out . println ( p1 . equals ( p3 )); // true 1.2.4. Sentencias de control \u00b6 Tambi\u00e9n tiene su origen en la arquitectura de Von Newmann Sentencia que modifica el contador de programa y determina cu\u00e1l ser\u00e1 la siguiente instrucci\u00f3n a ejecutar Tipos de sentencias de control en programaci\u00f3n estructurada: Las sentencias de secuencia definen instrucciones que son ejecutados una detr\u00e1s de otra de forma s\u00edncrona. Una instrucci\u00f3n no comienza hasta que la anterior ha terminado. Las sentencias de selecci\u00f3n definen una o m\u00e1s condiciones que determinan las instrucciones que se deber\u00e1n ejecutar. Las sentencias de iteraci\u00f3n definen instrucciones que se ejecutan de forma repetitiva hasta que se cumple una determinada condici\u00f3n. Bucles y variables Ejemplo imperativo que imprime en Java una tabla con los productos de los n\u00fameros del 1 al 9: for ( int i = 1 ; i <= 9 ; i ++ ) { System . out . println ( \"Tabla del \" + i ); System . out . println ( \"-----------\" ); for ( int j = 1 ; j <= 9 ; j ++ ) { System . out . println ( i + \" * \" + j + \" = \" + i * j ); } System . out . println (); } 2. Programaci\u00f3n imperativa en Scheme \u00b6 Al igual que LISP, Scheme tiene caracter\u00edsticas imperativas Vamos a ver algunas de ellas Pasos de ejecuci\u00f3n Asignaci\u00f3n con la forma especial set! Datos mutables con las formas especiales set-car! y set-cdr! Una nota importante: todos los ejemplos que hay a continuaci\u00f3n necesitan importar la librer\u00eda mutable-pairs : # lang r6rs ( import ( rnrs ) ( rnrs mutable-pairs )) 2.1. Pasos de ejecuci\u00f3n \u00b6 Es posible definir pasos de ejecuci\u00f3n con la forma especial begin Todas las sentencias de la forma especial se ejecutan de forma secuencial, una tras otra Tanto en la definici\u00f3n de funciones como en lambda es posible definir cuerpos de funci\u00f3n con m\u00faltiples sentencias que se ejecutan tambi\u00e9n de forma secuencial. Hasta ahora no hemos usado esta caracter\u00edstica porque hemos utilizado Scheme de forma funcional. Ejemplo begin : ( begin ( display \"Escribe un n\u00famero: \" ) ( define x ( read )) ( display \"Escribe otro: \" ) ( define y ( read )) ( define maximo ( max x y )) ( display ( string-append \"El m\u00e1ximo de \" ( number->string x ) \" y \" ( number->string y ) \" es \" ( number->string maximo )))) Ejemplo de pasos de ejecuci\u00f3n en la definici\u00f3n de una funci\u00f3n: ( define ( display-tres-valores a b c ) ( display a ) ( newline ) ( display b ) ( newline ) ( display c ) ( newline )) 2.2. Mutaci\u00f3n con formas especiales set! \u00b6 2.2.1. Forma especial set! \u00b6 La forma especial set! permite asignar un nuevo valor a una variable La variable debe haber sido previamente creada con define La forma especial no devuelve ning\u00fan valor, modifica el valor de la variable usada Sintaxis: (set! <variable> <nuevo-valor>) Por ejemplo, la t\u00edpica asignaci\u00f3n de los lenguajes imperativos se puede realizar de esta forma en Scheme: ( define a 10 ) ( set! a ( + a 1 )) a ; \u21d2 11 La forma especial set! funciona con cualquier tipo de datos. Por ejemplo, utilizando la caracter\u00edstica de que Scheme es d\u00e9bilmente tipeado, puede incluso asignar un nuevo tipo de valor a una variable: ( define a \"Hola\" ) a ; \u21d2 \"Hola\" ( set! a ( cons 1 2 )) a ; \u21d2 {1 . 2} 2.2.2. Datos mutables \u00b6 En Scheme se definen las formas especiales set-car! y set-cdr! que permite modificar (mutar) la parte izquierda o derecha de una pareja una vez creada Al igual que set! , no devuelven ning\u00fan valor Sintaxis: (set-car! <pareja> <nuevo-valor>) (set-cdr! <pareja> <nuevo-valor>) Ejemplo ( define p ( cons 1 2 )) ( set-car! p 10 ) ( set-cdr! p 20 ) p ; \u21d2 (10 . 20) 2.2.3. Efectos laterales \u00b6 La introducci\u00f3n de la asignaci\u00f3n y los datos mutables hace posible que Scheme se comporte como un lenguaje imperativo en el que m\u00e1s de una variable apunta a un mismo valor y se producen efectos laterales Un efecto lateral se produce cuando el valor de una variable cambia debido a una sentencia en la que no aparece la variable Podemos comprobar ahora que las parejas son datos que se copian por referencia Ejemplo: ( define p1 ( cons 1 2 )) ( define p2 p1 ) p1 ; \u21d2 (1 . 2) p2 ; \u21d2 (1 . 2) ( set-car! p1 20 ) p1 ; \u21d2 (20 . 2) p2 ; \u21d2 (20 . 2) 2.3. Igualdad de referencia y de valor \u00b6 La utilizaci\u00f3n de referencias, la mutaci\u00f3n y los efectos laterales hace tambi\u00e9n necesario definir dos tipos de igualdades: igualdad de referencia e igualdad de valor. Igualdad de referencia: dos variables son iguales cuando apuntan al mismo valor Igualdad de valor: dos variables son iguales cuando contienen el mismo valor En Scheme la funci\u00f3n eq? comprueba la igualdad de referencia y equal? la igualdad de valor Igualdad de referencia implica igualdad de valor, pero no al rev\u00e9s Ejemplo: ( define p1 ( cons 10 20 )) ( define p2 p1 ) ( define p3 ( cons 10 20 )) ( equal? p3 p1 ) ; \u21d2 #t ( eq? p3 p1 ) ; \u21d2 #f ( eq? p2 p1 ) ; \u21d2 #t ( set! p3 p1 ) ;; La asignaci\u00f3n copia referencias ( eq? p3 p1 ) ; \u21d2 #t 3. Estructuras de datos mutables \u00b6 La utilizaci\u00f3n de las formas especiales set-car! y set-cdr! permite un estilo nuevo de manejo de las estructuras de datos ya vistas (listas o \u00e1rboles) Es posible implementar funciones m\u00e1s eficientes que actualizan la estructura modificando directamente las referencias de unas celdas a otras Las operaciones no construyen estructuras nuevas, sino que modifican la ya existente 3.1. Mutaci\u00f3n de elementos \u00b6 Ejemplo 1 Vamos a empezar con un ejemplo sencillo en el que vamos a mutar un elemento de una estructura de datos formada por parejas. Supongamos la siguiente estructura: ( define datos ( cons 2 ( cons ( cons 5 ( cons 8 9 )) ( cons 3 4 )))) El diagrama box-and-pointer es el siguiente. F\u00edjate que hay elementos de las parejas que son datos at\u00f3micos y otros que son referencias a otras parejas. Vamos ahora a mutar la estructura utilizando las sentencias set-car! y set-cdr! . Para mutar una pareja acceder a la pareja y modificar su parte derecha o su parte izquierda con las sentencias anteriores. Por ejemplo, \u00bfc\u00f3mo cambiar\u00edamos el 8 por un 18 ? Deber\u00edamos obtener la pareja (8 . 9) que est\u00e1 al final de la estructura y modificar su parte izquierda: ( set-car! ( cdr ( car ( cdr datos ))) 18 ) La expresi\u00f3n (cdr (car (cdr datos))) devuelve la pareja que queremos modificar y la sentencia set-car! modifica su parte izquierda. Si ahora vemos qu\u00e9 hay en datos veremos que se ha modificado la estructura: ( print-pareja datos ) ; \u21d2 (2 . ((5 . (18 . 9)) . (3 . 4))) Recuerda que print-pareja es una funci\u00f3n que vimos anteriormente. Hemos mutado un dato por otro. Tambi\u00e9n podemos mutar las referencias a las parejas. Por ejemplo, podr\u00edamos modificar la parte derecha de la pareja que contiene el 5 para que apunte a la pareja (3 . 4) : Para ello habr\u00eda que obtener la pareja que contiene el 5 con la expresi\u00f3n (car (cdr datos)) y mutar su parte derecha ( set-cdr! ) con la referencia a la pareja (3 . 4) que se obtiene con la expresi\u00f3n (cdr (cdr datos)) : ( set-cdr! ( car ( cdr datos )) ( cdr ( cdr datos ))) Ejemplo 2 Veamos un segundo ejemplo. Supongamos las siguientes sentencias. \u00bfCu\u00e1l ser\u00eda el box-and-pointer resultante? ( define x ' (( a b ) c d )) ( define y ' ( e f )) ( set-car! x y ) ( define z ( cons y ( cdr x ))) ( set-cdr! x y ) ( set-car! z ( caar x )) Debemos ir paso a paso ejecutando cada instrucci\u00f3n y dibujando c\u00f3mo cambia el diagrama. El diagrama representa el estado del programa , y es un conjunto de parejas que contienen valores y referencias entre ellas. Es muy importante considerar cu\u00e1ndo la sentencia copia un valor y cuando copia una referencia. Las parejas siempre tienen sem\u00e1ntica de referencia. El diagrama resultante despu\u00e9s de las dos primeras sentencias es: Y el diagrama despu\u00e9s de todas las sentencias es: Los valores de las variables despu\u00e9s de todas las sentencias son los siguientes: x ; \u21d2 {{e f} e f} y ; \u21d2 {e f} z ; \u21d2 {e c d} Ejemplo 3 En este ejemplo vamos a usar una nueva forma especial de Scheme que permite crear variables locales y ejecutar expresiones en las que se utilicen esas variables. Se trata de la forma especial let . Veremos algo m\u00e1s de esta forma especial m\u00e1s adelante, cuando hablemos de \u00e1mbitos de variables. Por ahora es suficiente saber que permite crear variables locales y ejecutar un cuerpo (que puede tener m\u00e1s de una sentencia) con esas variables. ( let (( x ( + 2 3 )) ( y ( * 2 10 )) ( + x y )) ; \u21d2 25 En este caso let permite crear dos variables locales x e y y asignarles los valores 5 y 20 respectivamente. Las sentencias del cuerpo del let (en este caso la sentencia (+ x y) ) se eval\u00faan con estos valores reci\u00e9n creados. Vamos a usar esta forma especial en ocasiones para guardar valores o referencias que despu\u00e9s necesitamos asignar. Por ejemplo, \u00bfc\u00f3mo podr\u00edamos definir una funci\u00f3n que mute las referencias de una lista para intercambiar sus posiciones segunda y tercera (sin crear nuevas parejas)? Si llamamos a la funci\u00f3n intercambia! deber\u00eda hacer lo siguiente: ( define lista ' ( 1 2 3 4 5 6 )) ( intercambia! lista ) lista ; \u21d2 {1 3 2 4 5 6} Dibujando el diagrama box-and-pointer podemos ver las mutaciones que tenemos que hacer: La funci\u00f3n es la siguiente: ( define ( intercambia! lista ) ( let (( segundo ( cdr lista )) ( tercero ( cddr lista ))) ( set-cdr! lista tercero ) ( set-cdr! segundo ( cdr tercero )) ( set-cdr! tercero segundo ))) 3.2. Funciones mutadoras: make-ciclo! , append! e intercambia-lista! \u00b6 Veamos ahora varios ejemplos de funciones recursivas que recorren listas y realizan mutaciones en ellas. Normalmente las funciones mutadoras no devuelven una estructura, sino que modifican la que se pasa como par\u00e1metro. Por convenio, indicaremos que una funci\u00f3n es mutadora terminando su nombre con un signo de admiraci\u00f3n. make-ciclo! Empecemos con una funci\u00f3n muta una lista, haciendo que la parte derecha de la \u00faltima pareja apunte a la pareja inicial de la misma. Para conseguirlo, necesitamos guardar la referencia a la pareja inicial de la lista en el primer par\u00e1metro de la funci\u00f3n. Y el segundo par\u00e1metro ir\u00e1 avanzando hasta encontrar el final de la lista: ( define ( make-ciclo! lista ref ) ( if ( null? ( cdr ref )) ( set-cdr! ref lista ) ( make-ciclo! lista ( cdr ref )))) Si probamos la funci\u00f3n con una lista, podemos comprobar que DrRacket detecta el ciclo que se produce al final de la misma: ( define lista ' ( 1 2 3 4 5 6 )) ( make-ciclo! lista lista ) lista ; \u21d2 #0={1 2 3 4 5 6 . #0#} Una forma alternativa de implementar esta funci\u00f3n es mediante una funci\u00f3n que devuelva la referencia de la \u00faltima pareja de la lista: ( define ( ultima-pareja lista ) ( if ( null? ( cdr lista )) lista ( ultima-pareja ( cdr lista )))) ( define ( make-ciclo2! lista ) ( let (( ultima-pareja ( ultima-pareja lista ))) ( set-cdr! ultima-pareja lista ))) append! Y vemos a continuaci\u00f3n una versi\u00f3n mutadora de append que llamamos append! y que mejora la eficiencia de la original, copiando al final de la primera lista una referencia a la segunda: La implementaci\u00f3n es la siguiente: ( define ( append! l1 l2 ) ( if ( null? ( cdr l1 )) ( set-cdr! l1 l2 ) ( append! ( cdr l1 ) l2 ))) Ejemplo: ( define a ' ( 1 2 3 4 )) ( define b ' ( 5 6 7 )) ( append! a b ) a ; \u21d2 {1 2 3 4 5 6 7} Algunas puntualizaciones: Al igual que set! , set-car! o set-cdr! , la funci\u00f3n append! no devuelve ning\u00fan valor, sino que modifica directamente la lista que se pasa como primer par\u00e1metro. Al modificarse la lista, todas las referencias que apuntan a ellas quedan tambi\u00e9n modificadas. La funci\u00f3n dar\u00eda un error en el caso en que la llam\u00e1ramos con una lista vac\u00eda como primer argumento. intercambia-lista! Un \u00faltimo ejemplo de funci\u00f3n recursiva que muta una lista. Queremos definir una funci\u00f3n que intercambie todas las parejas excepto la primera de una lista con un n\u00famero de datos impar, pero sin usar set-car! . Llamamos a la funci\u00f3n (intercambia-lista! lista) y deber\u00eda hacer lo siguiente: ( define lista ' ( 1 2 3 4 5 6 7 )) ( intercambia-lista! lista ) lista ; \u21d2 {1 3 2 5 4 7 6} La forma de implementar esta funci\u00f3n va a ser llamando a la funci\u00f3n intercambia! (la que hemos definido anteriormente que intercambia el segundo y el tercer elemento) hasta que lleguemos al final de la lista. Lo hacemos con una recursi\u00f3n: ( define ( intercambia-lista! lista ) ( if ( not ( null? ( cdr lista ))) ( begin ( intercambia! lista ) ( intercambia-lista! ( cddr lista ))))) La funci\u00f3n termina cuando llegamos a la pareja final de la lista, la que tiene la lista vac\u00eda en su parte derecha. Si no estamos en el final de la lista llamamos a la funci\u00f3n intercambia! para intercambiar la siguiente pareja con su siguiente y llamamos a la recursi\u00f3n con la variable lista apuntando a la tercera pareja de la lista. 3.3. Lista ordenada mutable \u00b6 Veamos ahora una lista ordenada mutable de n\u00fameros, en la que insertaremos elementos de forma ordenada. Definiremos las siguientes funciones: (make-olist) : construye una lista ordenada vac\u00eda (borra-primero-olist! olist) : funci\u00f3n mutadora que elimina (con mutaci\u00f3n) el primer elemento de la lista (inserta-olist! olist n) : funci\u00f3n mutadora que inserta (con mutaci\u00f3n) de forma ordenada un n\u00famero en la lista Implementamos el tipo de datos con una lista normal con una pareja adicional en cabeza. Esta pareja adicional funcionar\u00e1 de cabecera de la lista y ser\u00e1 la referencia inmutable a la que apuntar\u00e1 cualquier variable que apunte a la lista. De esta forma podremos insertar elementos en primera posici\u00f3n de la lista. En la cabecera usaremos por convenio el s\u00edmbolo '*olist*' . ( define lista ' ( *olist* 10 20 30 )) Constructor El constructor (make-olist) devuelve una lista s\u00f3lo con la cabecera. ( define ( make-olist ) ( list '*olist* )) Mutadores Las funciones mutadoras modifican la estructura de datos. Comenzamos con la funci\u00f3n (borra-primero-olist! olist) que elimina con mutaci\u00f3n el primer elemento de la lista ordenada: ( define ( borra-primero-olist! olist ) ( set-cdr! olist ( cddr olist ))) Definimos la funci\u00f3n mutadora inserta-olist! que modifica la lista ordenada a\u00f1adiendo una nueva pareja, insert\u00e1ndola en la posici\u00f3n correcta modificando las referencias. La funci\u00f3n (add-item! item ref) es la funci\u00f3n clave que crea una nueva pareja con el item y la a\u00f1ade en el cdr de la pareja a la que apunta ref . ( define ( add-item! ref item ) ( set-cdr! ref ( cons item ( cdr ref )))) ( define ( inserta-olist! olist n ) ( cond (( null? ( cdr olist )) ( add-item! olist n )) (( < n ( cadr olist )) ( add-item! olist n )) (( = n ( cadr olist )) #f ) ; el valor devuelto no importa ( else ( inserta-olist! ( cdr olist ) n )))) Ejemplo de uso: ( define c ( make-olist )) ( inserta-olist! c 5 ) ( inserta-olist! c 10 ) ( inserta-olist! c -10 ) c ; \u21d2 {*olist* -10 5 10} 3.4. Diccionario mutable \u00b6 Veamos ahora un ejemplo m\u00e1s: un diccionario mutable definido mediante una lista de asociaci\u00f3n formada por parejas de clave y valor ( define l-assoc ( list ( cons 'a 1 ) ( cons 'b 2 ) ( cons 'c 3 ))) La funci\u00f3n de Scheme assq recorre la lista de asociaci\u00f3n y devuelve la tupla que contiene el dato que se pasa como par\u00e1metro como clave ( assq 'a l-assoc ) ; \u21d2 (a.1) ( assq 'b l-assoc ) ; \u21d2 (b.2) ( assq 'c l-assoc ) ; \u21d2 (c.3) ( assq 'd l-assoc ) ; \u21d2 #f ( cdr ( assq 'c l-assoc )) ; \u21d2 3 La funci\u00f3n assq busca en la lista de asociaci\u00f3n usando la igualdad de referencia eq? ( define p ( cons 1 2 )) ( define l-assoc ( list ( cons 'a 1 ) ( cons p 2 ) ( cons 'c 3 ))) ( assq ( cons 1 2 ) l-assoc ) ; \u21d2 #f ( assq p l-assoc ) ; \u21d2 {{1 . 2} . 2} Las funciones que vamos a implementar del diccionario son las siguientes: (make-dic) : construye un diccionario vac\u00edo (put-dic! dic clave valor) : inserta en el diccionario un nuevo valor asociado a una clave (get-dic dic clave) : devuelve el valor asociado a una clave en un diccionario Al igual que la lista ordenada mutable, el diccionario necesita una cabecera: ( define ( make-dic ) ( list '*dic* )) La funci\u00f3n (get-dic dic clave) usa la funci\u00f3n assq para buscar la pareja que contiene una clave determinada en la lista de asociaci\u00f3n (el cdr de dic). Y despu\u00e9s devuelve el cdr de esa pareja (el valor guardado junto con la clave: ( define ( get-dic dic clave ) ( let ( pareja ( assq clave ( cdr dic ))) ( if ( not pareja ) #f ( cdr pareja )))) La funci\u00f3n (put-dic! dic clave valor) usa igual que antes la funci\u00f3n assq para comprobar si la clave ya est\u00e1 en la lista de asociaci\u00f3n. Si existe, sustituye el valor por el nuevo. Si no existe, crea una pareja con la clave y el valor y la inserta al comienzo del diccionario (despu\u00e9s de la cabecera): ( define ( put-dic! dic clave valor ) ( let ( pareja ( assq clave ( cdr dic ))) ( if ( not pareja ) ( set-cdr! dic ( cons ( cons clave valor ) ( cdr dic ))) ( set-cdr! pareja valor ))) 'ok ) En las funciones anteriores volvemos a usar la forma especial let . Ejemplos de uso: ( define dic ( make-dic )) ( put-dic! dic 'a 10 ) ; \u21d2 ok ( get-dic dic 'a ) ; \u21d2 10 ( put-dic! dic 'b ' ( a b c )) ; \u21d2 ok ( get-dic dic 'b ) ; \u21d2 {a b c} ( put-dic! dic 'a 'ardilla ) ; \u21d2 ok ( get-dic dic 'a ) ; \u21d2 ardilla 3.5. Ejemplo de mutaci\u00f3n con listas de asociaci\u00f3n \u00b6 Una vez introducidos distintas estructuras de datos mutables, incluyendo listas de asociaci\u00f3n, vamos a terminar estos ejemplos con un ejemplo pr\u00e1ctico en el que intervienen las listas y las listas de asociaci\u00f3n. Se trata de escribir un procedimiento regular->assoc! que transforme una lista regular en una lista de asociaci\u00f3n sin crear nuevas parejas. La lista regular (k1 v1 k2 v2 k3 v3 ...) deber\u00e1 convertirse en la lista de asociaci\u00f3n ((k1 . v1) (k2 . v2) (k3 . v3) ...) . Ejemplo: ( define my-list ( list 'a 1 'b 2 'c 3 )) lista ; \u21d2 (a 1 b 2 c 3) ( regular->assoc! my-list ) lista ; \u21d2 ((a . 1) (b . 2) (c . 3)) Una posible soluci\u00f3n a este problema ser\u00eda la siguiente (no es la \u00fanica soluci\u00f3n): Cuando trabajamos con este tipo de problemas, es muy \u00fatil ayudarse con los diagramas caja y puntero. Vamos a crear los diagramas caja y puntero para el ejemplo anterior: Antes de llamar a regular->assoc!: Despu\u00e9s de llamar a regular->assoc!: Queremos hacer la transformaci\u00f3n sin crear nuevas parejas, por lo que cada pareja en el primer diagrama corresponde a una pareja particular en el segundo diagrama. No podemos modificar la primera pareja de la lista (porque perder\u00edamos la ligadura de la variable lista ), por lo que es primera pareja tiene que permanecer en el primer lugar. Por otra parte, a y 1 van a formar parte del mismo par en la lista de asociaci\u00f3n, por lo que vamos a considerar el siguiente cambio de las dos primeras parejas. Diagrama inicial: Despu\u00e9s del cambio de las dos primeras parejas: La siguiente funci\u00f3n manejar-dos-parejas! es la encargada de hacer esta mutaci\u00f3n: ( define ( manejar-dos-parejas! p ) ( let (( key ( car p ))) ;; 1 ( set-car! p ( cdr p )) ;; 2 ( set-cdr! p ( cdar p )) ;; 3 ( set-cdr! ( car p ) ( caar p )) ;; 4 ( set-car! ( car p ) key ))) ;; 5 Se han numerado las l\u00edneas para una mejor explicaci\u00f3n. En la l\u00ednea 1, (define key (car p)) , creamos una variable local key que guarda el valor actual del (car p) , ese valor ser\u00e1 la clave de la primera pareja de la lista de asociaci\u00f3n; necesitamos almacenarlo para no perderlo. En la l\u00ednea 2, (set-car! p (cdr p)) , cambiamos el car de p para que apunte a la siguiente pareja (la azul): En la l\u00ednea 3, (set-cdr! p (cdar p)) , copiamos en el cdr de p el cdr de la pareja en azul para que ambos apunten a la siguiente pareja: En la l\u00ednea 4, (set-cdr! (car p) (caar p)) , cambiamos el cdr de la pareja en azul al car de la misma pareja. Hacemos \u00e9sto porque en una lista de asociaci\u00f3n, los valores se guardan en los cdrs y las claves en los cars : Por \u00faltimo, en la l\u00ednea 5 (set-car! (car p) key) , completamos el problema poniendo la clave que hab\u00edamos guardado, en el car de la pareja azul: Reordenamos el diagrama para verlo m\u00e1s claro: Hemos definido un procedimiento que maneja un subproblema (dos parejas) del problema. Ahora s\u00f3lo nos queda definir la funci\u00f3n que maneja toda la lista: ( define ( regular->assoc! lista ) ( if ( null? lista ) 'ok ( begin ( manejar-dos-parejas! lista ) ( regular->assoc! ( cdr lista ))))) 4. \u00c1mbitos de variables y clausuras \u00b6 El concepto del \u00e1mbito de vida de las variables es un concepto fundamental en los lenguajes de programaci\u00f3n. Utilizaremos las palabras \u00e1mbito y entorno como sin\u00f3nimos. En ingl\u00e9s se utiliza el t\u00e9rmino scope . Cuando se define una variable, asoci\u00e1ndole un valor, esta asociaci\u00f3n tiene una extensi\u00f3n determinada, ya sea en t\u00e9rminos de tiempo de compilaci\u00f3n ( \u00e1mbito l\u00e9xico ) como en t\u00e9rminos de tiempo de ejecuci\u00f3n ( \u00e1mbito din\u00e1mico ). El \u00e1mbito de una variable determina cu\u00e1ndo podemos referirnos a ella para recuperar el valor asociado. Al conjunto de variables disponibles en una parte del programa o en una parte de su ejecuci\u00f3n se denomina contexto o entorno ( context o environment ). 4.1. Variables de \u00e1mbito global \u00b6 Una variable definida en el programa con la instrucci\u00f3n define tiene un \u00e1mbito global. ( define a \"hola\" ) ( define b ( string-append \"adios\" a )) ( define cuadrado ( lambda ( x ) ( * x x ))) Todas las variables definidas fuera de funciones forman parte del entorno global del programa. 4.2. Variables de \u00e1mbito local \u00b6 En Scheme existen dos formas de definir variables de \u00e1mbito local: la forma especial define dentro de una funci\u00f3n y la forma especial let . 4.2.1 Variables locales con define \u00b6 Como en la mayor\u00eda de lenguajes de programaci\u00f3n, en Scheme se crea un entorno o \u00e1mbito local (memoria local de la invocaci\u00f3n de la funci\u00f3n) cada vez que se invoca a una funci\u00f3n. En este entorno local toman valor los par\u00e1metros y las variables locales de la funci\u00f3n. Es posible definir variables locales en una funci\u00f3n utilizando la forma especial define dentro de la propia funci\u00f3n. Esto no lo hac\u00edamos dentro del paradigma funcional, para evitar realizar pasos de ejecuci\u00f3n. Pero ahora que estamos en el paradigma imperativo podemos utilizarlo. ( define ( distancia x1 y1 x2 y2 ) ( define distancia-x ( - x2 x1 )) ( define distancia-y ( - y2 y1 )) ( sqrt ( + ( cuadrado distancia-x ) ( cuadrado distancia-y )))) Podemos usar en un entorno local una variable con el mismo nombre que en el entorno global. Cuando se ejecute el c\u00f3digo de la funci\u00f3n se utilizar\u00e1 el valor local. Por ejemplo, supongamos las siguientes expresiones: ( define x 5 ) ( define ( suma-10 y ) ( define x 10 ) ( + x y )) ( suma-10 3 ) ; \u21d2 13 La primera sentencia de la funci\u00f3n (suma y) define una variable local x a la que se asigna un valor inicial de 10. Cuando se ejecuta la expresi\u00f3n (+ x y) , en la invocaci\u00f3n a (suma 3) el valor de x es entonces 10 (el valor local que hemos definido en la sentencia anterior), no es 5, devolvi\u00e9ndose 15. Sucede igual si un par\u00e1metro tiene el mismo nombre que una variable global: ( define x 5 ) ( define ( suma-3 x ) ( + x 3 )) ( suma-3 12 ) ; \u21d2 15 Cuando se ejecuta la expresi\u00f3n (+ x 3) en la invocaci\u00f3n a (suma-3 12) el valor de x es 12, no es 5, devolvi\u00e9ndose 15. En el entorno local tambi\u00e9n se pueden utilizar variables definidas en el entorno global. Por ejemplo: ( define z 12 ) ( define ( foo y ) ( define x 10 ) ( + x y z )) ( foo 5 ) ; \u21d2 27 La expresi\u00f3n (+ x y z) se eval\u00faa en el entorno local en el que x vale 10 e y vale 5. Al no estar definida la variable z en este entorno local, se usa su definici\u00f3n de \u00e1mbito global. Una vez realizada la invocaci\u00f3n, desparece el entorno local junto con las variables locales definidas en \u00e9l, y se recupera el contexto global. Por ejemplo, en la siguiente expresi\u00f3n, una vez realizada la invocaci\u00f3n a (suma-10 2) se devuelve el n\u00famero 12 y se eval\u00faa en el entorno global la expresi\u00f3n (+ 12 x) . En este contexto la variable x vale 5 por lo que la expresi\u00f3n devuelve 17. ( define x 5 ) ( define ( suma-10 y ) ( define x 10 ) ( + x y )) ( + ( suma-10 2 ) x ) ; \u21d2 17 Otro ejemplo: ( define x 10 ) ( define ( foo2 y ) ( define z 5 ) ( + x y z )) ( foo2 2 ) ; \u21d2 17 x ; \u21d2 10 z ; \u21d2 error, no definida y ; \u21d2 error, no definida Define en el cuerpo de una funci\u00f3n La forma especial define para crear variables locales s\u00f3lo puede utilizarse al comienzo de la definici\u00f3n de una funci\u00f3n. Si intentamos utilizarla a mitad del c\u00f3digo de la funci\u00f3n tendremos un error: ( define ( suma-10-si-mayor-que-0 x ) ( if ( > x 0 ) ( begin ;; ERROR: ;; no es posible usar define a mitad del c\u00f3digo ;; de una funci\u00f3n ( define y 10 ) ( + x y )) x )) 4.2.1 Variables locales con let \u00b6 La otra forma de definir variables locales en Scheme es con la forma especial let . La forma especial let permite crear un \u00e1mbito local en el que se da valor a variables y se eval\u00faan expresiones. Sintaxis: ( let (( <var1> <exp-1> ) ... ( <varn> <exp-n> )) <cuerpo> ) Las variables var1 , \u2026 varn toman los valores devueltos por las expresiones exp1 , \u2026 expn y el cuerpo se eval\u00faa con esos valores. Esas variables s\u00f3lo tienen valor en el \u00e1mbito de la forma especial. Por ejemplo: ( define x 10 ) ( let (( x ( + 1 2 )) ( y ( * 10 2 )) ( + x y )) ; \u21d2 23 x ; \u21d2 10 y ; \u21d2 error, no definida Cuando ha terminado la evaluaci\u00f3n del let el \u00e1mbito local desaparece y quedan los valores definidos en el \u00e1mbito anterior. Las expresiones que dan valor a las variables del let se eval\u00faan antes de crear el \u00e1mbito local. Por ejemplo, en el siguiente c\u00f3digo, las expresiones (+ x 3) y (+ y 2) devuelven 4 y 7 respectivamente: ( define x 1 ) ( define y 5 ) ( let (( w ( + x 3 )) ( z ( + y 2 ))) ( + w z )) ; \u21d2 11 En el cuerpo del let puede haber m\u00e1s de una expresi\u00f3n: ( let (( x 10 ) ( y 20 )) ( display \"x: \" ) ( display x ) ( display \"\\ny: \" ) ( display y )) Let en el cuerpo de una funci\u00f3n A diferencia de define s\u00ed que es posible usar let en cualquier expresi\u00f3n de Scheme, por ejemplo, en un if : ( define ( suma-10-si-mayor-que-0 x ) ( if ( > x 0 ) ( let (( y 10 )) ( + x y )) x )) 4.3. Clausuras y estado local \u00b6 Recordemos que la forma especial lambda permite crear funciones an\u00f3nimas en tiempo de ejecuci\u00f3n. Si ejecutamos una forma especial lambda como \u00faltimo paso de una funci\u00f3n, se devolver\u00e1 la funci\u00f3n reci\u00e9n creada. \u00bfQu\u00e9 sucede si utilizamos en el cuerpo de esta funci\u00f3n an\u00f3nima una variable local definida en la funci\u00f3n principal? Vamos a verlo: ( define ( make-sumador ) ( define z 10 ) ( lambda ( x ) ( + x z ))) La funci\u00f3n make-sumador define una variable local z con el valor de 10. Y despu\u00e9s construye una funci\u00f3n con la expresi\u00f3n lambda . Al ser la \u00faltima expresi\u00f3n de la funci\u00f3n make-sumador , esta funci\u00f3n construida en tiempo de ejecuci\u00f3n es lo que se devuelve. Si invocamos a make-sumador vemos que devuelve un procedimiento: ( make-sumador ) ; \u21d2 #<procedure> Si guardamos el procedimiento en una variable y despu\u00e9s lo invocamos, tendremos que pasarle un par\u00e1metro (correspondiente al argumento x de la expresi\u00f3n lambda ). \u00bfQu\u00e9 devolver\u00e1 esa invocaci\u00f3n? ( define f ( make-sumador )) ( f 5 ) ; \u21d2 ??? Al invocar a f se ejecutar\u00e1 el cuerpo del procedimiento, esto es, la expresi\u00f3n (+ x z) . La variable x valdr\u00e1 5 (el valor del par\u00e1metro). Pero, \u00bfcu\u00e1l es el valor de la variable z?. Podemos comprobar que es 10, porque la invocaci\u00f3n devuelve devuelve 15: ( f 5 ) ; \u21d2 15 \u00bfPor qu\u00e9? Lo que est\u00e1 pasando es que la funci\u00f3n an\u00f3nima que crea la expresi\u00f3n lambda captura las variables locales definidas en el \u00e1mbito en el que se crea. Por eso recibe el nombre de clausura , porque encierra los valores que tienen esas variables en el momento de su creaci\u00f3n y esos valores son los que usa en las variables libres cuando posteriormente la invoquemos. En el ejemplo anterior se est\u00e1 capturando la variable z con su valor 10. Cuando despu\u00e9s invocamos a (f 5) se eval\u00faa el cuerpo (+ x z) con x valiendo 5 y z valiendo el valor capturado (10). Tambi\u00e9n podemos utilizar como estado local el valor de un par\u00e1metro. Por ejemplo: ( define ( make-sumador k ) ( lambda ( x ) ( + x k ))) ( define f ( make-sumador 10 )) ( f 2 ) ; \u21d2 12 En la funci\u00f3n (make-sumador k) se llama a la forma especial lambda para crear una clausura. La clausura captura la variable local k (el par\u00e1metro de make-sumador ) y usar\u00e1 su valor cuando posteriormente se eval\u00fae. En este caso, la clausura se ha creado con k valiendo 10, y captura este valor. Cuando despu\u00e9s se invoca a (f 2) se ejecuta la clausura en un nuevo \u00e1mbito local con las siguientes variables y valores: x: 2 (variable local de la clausura) k: 10 (valor capturado del entorno local en el que se cre\u00f3 la clausura En este \u00e1mbito se ejecuta la expresi\u00f3n (+ x k) , devolvi\u00e9ndose el valor 12. Por \u00faltimo, tambi\u00e9n es posible crear la clausura dentro de un estado local definido con un let y usar en el cuerpo del lambda variables locales definidas en el let : ( define ( make-sumador-cuadrado k ) ( if ( > k 0 ) ( let (( y ( cuadrado k ))) ( lambda ( x ) ( + x y ))) ( lambda ( x ) x ))) La funci\u00f3n anterior tiene un condicional en el que se comprueba si k es mayor que 0. Si lo es, se devuelve una clausura creada en el \u00e1mbito del let con la variable y capturada con el valor del cuadrado de k . Esta clausura suma a su entrada el valor de y . Por ejemplo: ( define f ( make-sumador-cuadrado 4 )) ( f 3 ) ; \u21d2 19 En el caso en que k menor o igual que 0, se devuelve una clausura que devuelve siempre el valor que recibe: ( define f ( make-sumador-cuadrado -8 )) ( f 3 ) ; \u21d2 3 La definici\u00f3n de clausuras con un estado local inicializado a un valor creado en tiempo de ejecuci\u00f3n es una caracter\u00edstica muy potente. Permite no s\u00f3lo crear funciones en tiempo de ejecuci\u00f3n para utilizarlas posteriormente, sino configurarlas con el estado local que nos interese. Veremos en el apartado siguiente que la combinaci\u00f3n de clausuras y mutaci\u00f3n permite crear funciones con estado local mutable, algo equivalente a objetos que encapsulan c\u00f3digo y estado. 5. Clausuras con mutaci\u00f3n = estado local mutable \u00b6 5.1. Estado local mutable \u00b6 Si combinamos una clausura con la posibilidad de mutar las variables capturadas por la clausura obtenemos un estado local mutable asociado a funciones creadas en tiempo de ejecuci\u00f3n. Veamos, por ejemplo, la siguiente funci\u00f3n (make-contador i) : ( define ( make-contador i ) ( define x i ) ( lambda () ( set! x ( + x 1 )) x ))) La funci\u00f3n make-contador define una clausura que captura la variable local x inicializada a i . En cada invocaci\u00f3n a la clausura se ejecuta una sentencia set que modifica el valor de la variable capturada. Y despu\u00e9s se devuelve el nuevo valor de la variable. Estamos implementando un contador asociado a la clausura. ( define f ( make-contador 10 )) ( f ) \u21d2 11 ( f ) \u21d2 12 El estado (el valor del contador) se mantiene y se modifica entre distintas invocaciones a f . A diferencia del paradigma funcional podemos comprobar que distintas invocaciones a la misma funci\u00f3n devuelven valores distintos (dependiente del estado de la clausura). Podemos crear distintas clausuras, cada una con su variable capturada, en distintas invocaciones a make-contador : ( define h ( make-contador 10 )) ( define g ( make-contador 100 )) ( h ) \u21d2 11 ( h ) \u21d2 12 ( g ) \u21d2 101 ( g ) \u21d2 102 Una forma alternativa de crear la clausura, sin usar la forma especial lambda es defini\u00e9ndola con un define en el cuerpo de make-contador . Despu\u00e9s de los dos define la \u00faltima sentencia devuelve la funci\u00f3n incrementa (la clausura). ( define ( make-contador i ) ( define x i ) ( define ( incrementa ) ( set! x ( + x 1 )) x ) incrementa ) 5.2. Paso de mensajes \u00b6 En el ejemplo anterior creamos una clausura que siempre incrementa el valor del contador. \u00bfC\u00f3mo podr\u00edamos crear una clausura que permitiera hacer distintas cosas con el valor capturado? Una forma de hacerlo es definir en la clausura un par\u00e1metro adicional (un s\u00edmbolo que llamamos mensaje ) y devolver distintas clausuras en funci\u00f3n del valor de ese par\u00e1metro adicional: ( define ( make-contador i ) ( define x i ) ( define ( get ) x ) ( define ( inc-1 ) ( set! x ( + x 1 )) x ) ( define ( inc y ) ( set! x ( + x y )) x ) ( define ( dispatcher mensaje ) ( cond (( equal? mensaje 'get ) get ) (( equal? mensaje 'inc-1 ) inc-1 ) (( equal? mensaje 'inc ) inc ) ( else \"Error: mensaje desconocido\" ))) dispatcher ) La funci\u00f3n make-contador devuelve la clausura dispatcher que se encarga de procesar el mensaje y devolver la clausura asociada a ese mensaje. Cuando invoquemos al dispatcher con un s\u00edmbolo, devuelve otro procedimiento que hay que volver a invocar con los par\u00e1metros adecuados (sin par\u00e1metros en los dos primeros casos y con el valor a incrementar en el \u00faltimo caso): Si recibe el s\u00edmbolo 'get devuelve la clausura que devuelve el valor del contador Si recibe el s\u00edmbolo 'inc-1 devuelve la clausura que incrementa el valor del contador en 1 Si recibe el s\u00edmbolo 'inc devuelve la clausura que incrementa el valor del contador una cantidad determinada Por ejemplo: ( define c ( make-contador 100 )) (( c 'get )) \u21d2 100 (( c 'inc-1 )) \u21d2 101 (( c 'inc ) 10 ) \u21d2 111 Lenguajes y Paradigmas de Programaci\u00f3n, curso 2016-17 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Domingo Gallardo, Cristina Pomares","title":"Tema 5: Programaci\u00f3n imperativa"},{"location":"teoria/tema05-bis-programacion-imperativa/tema05-programacion-imperativa.html#tema-5-programacion-imperativa","text":"","title":"Tema 5: Programaci\u00f3n imperativa"},{"location":"teoria/tema05-bis-programacion-imperativa/tema05-programacion-imperativa.html#contenidos","text":"1. Historia y caracter\u00edsticas de la programaci\u00f3n imperativa 1.1. Historia de la programaci\u00f3n imperativa 1.2. Caracter\u00edsticas principales de la programaci\u00f3n imperativa 2. Programaci\u00f3n imperativa en Scheme 2.1. Pasos de ejecuci\u00f3n 2.2. Mutaci\u00f3n con formas especiales set! 2.3. Igualdad de referencia y de valor 3. Estructuras de datos mutables 3.1. Mutaci\u00f3n de elementos 3.2. Funciones mutadoras: make-ciclo! , append! y intercambia! 3.3. Lista ordenada mutable 3.4. Diccionario mutable 3.5. Ejemplo de mutaci\u00f3n con listas de asociaci\u00f3n 4. \u00c1mbitos de variables y clausuras 4.1. Variables de \u00e1mbito global 4.2. Variables de \u00e1mbito local 4.3. Clausuras y estado local 5. Clausuras con mutaci\u00f3n = estado local mutable 5.1. Estado local mutable 5.2. Paso de mensajes","title":"Contenidos"},{"location":"teoria/tema05-bis-programacion-imperativa/tema05-programacion-imperativa.html#bibliografia","text":"En este tema explicamos conceptos de los siguientes cap\u00edtulos del libro Structure and Intepretation of Computer Programs : 3.3.1 Mutable List Structure 3.3.2 Representing Queues 3.3.3 Representing tables 3.1.1 Local State Variables 3.1.3 The Cost of Introducing Assignment","title":"Bibliograf\u00eda"},{"location":"teoria/tema05-bis-programacion-imperativa/tema05-programacion-imperativa.html#1-historia-y-caracteristicas-de-la-programacion-imperativa","text":"","title":" 1. Historia y caracter\u00edsticas de la programaci\u00f3n imperativa"},{"location":"teoria/tema05-bis-programacion-imperativa/tema05-programacion-imperativa.html#11-historia-de-la-programacion-imperativa","text":"","title":"1.1. Historia de la programaci\u00f3n imperativa"},{"location":"teoria/tema05-bis-programacion-imperativa/tema05-programacion-imperativa.html#12-caracteristicas-principales-de-la-programacion-imperativa","text":"Idea principal de la programaci\u00f3n imperativa: la computaci\u00f3n se realiza cambiando el estado del programa por medio de sentencias que definen pasos de ejecuci\u00f3n del computador Estado del programa modificable Sentencias de control que definen pasos de ejecuci\u00f3n Vamos a ver unos ejemplos de estas caracter\u00edsticas usando el lenguaje de programaci\u00f3n Java.","title":" 1.2. Caracter\u00edsticas principales de la programaci\u00f3n imperativa"},{"location":"teoria/tema05-bis-programacion-imperativa/tema05-programacion-imperativa.html#2-programacion-imperativa-en-scheme","text":"Al igual que LISP, Scheme tiene caracter\u00edsticas imperativas Vamos a ver algunas de ellas Pasos de ejecuci\u00f3n Asignaci\u00f3n con la forma especial set! Datos mutables con las formas especiales set-car! y set-cdr! Una nota importante: todos los ejemplos que hay a continuaci\u00f3n necesitan importar la librer\u00eda mutable-pairs : # lang r6rs ( import ( rnrs ) ( rnrs mutable-pairs ))","title":" 2. Programaci\u00f3n imperativa en Scheme"},{"location":"teoria/tema05-bis-programacion-imperativa/tema05-programacion-imperativa.html#21-pasos-de-ejecucion","text":"Es posible definir pasos de ejecuci\u00f3n con la forma especial begin Todas las sentencias de la forma especial se ejecutan de forma secuencial, una tras otra Tanto en la definici\u00f3n de funciones como en lambda es posible definir cuerpos de funci\u00f3n con m\u00faltiples sentencias que se ejecutan tambi\u00e9n de forma secuencial. Hasta ahora no hemos usado esta caracter\u00edstica porque hemos utilizado Scheme de forma funcional. Ejemplo begin : ( begin ( display \"Escribe un n\u00famero: \" ) ( define x ( read )) ( display \"Escribe otro: \" ) ( define y ( read )) ( define maximo ( max x y )) ( display ( string-append \"El m\u00e1ximo de \" ( number->string x ) \" y \" ( number->string y ) \" es \" ( number->string maximo )))) Ejemplo de pasos de ejecuci\u00f3n en la definici\u00f3n de una funci\u00f3n: ( define ( display-tres-valores a b c ) ( display a ) ( newline ) ( display b ) ( newline ) ( display c ) ( newline ))","title":" 2.1. Pasos de ejecuci\u00f3n"},{"location":"teoria/tema05-bis-programacion-imperativa/tema05-programacion-imperativa.html#22-mutacion-con-formas-especiales-set","text":"","title":" 2.2. Mutaci\u00f3n con formas especiales set!"},{"location":"teoria/tema05-bis-programacion-imperativa/tema05-programacion-imperativa.html#23-igualdad-de-referencia-y-de-valor","text":"La utilizaci\u00f3n de referencias, la mutaci\u00f3n y los efectos laterales hace tambi\u00e9n necesario definir dos tipos de igualdades: igualdad de referencia e igualdad de valor. Igualdad de referencia: dos variables son iguales cuando apuntan al mismo valor Igualdad de valor: dos variables son iguales cuando contienen el mismo valor En Scheme la funci\u00f3n eq? comprueba la igualdad de referencia y equal? la igualdad de valor Igualdad de referencia implica igualdad de valor, pero no al rev\u00e9s Ejemplo: ( define p1 ( cons 10 20 )) ( define p2 p1 ) ( define p3 ( cons 10 20 )) ( equal? p3 p1 ) ; \u21d2 #t ( eq? p3 p1 ) ; \u21d2 #f ( eq? p2 p1 ) ; \u21d2 #t ( set! p3 p1 ) ;; La asignaci\u00f3n copia referencias ( eq? p3 p1 ) ; \u21d2 #t","title":" 2.3. Igualdad de referencia y de valor"},{"location":"teoria/tema05-bis-programacion-imperativa/tema05-programacion-imperativa.html#3-estructuras-de-datos-mutables","text":"La utilizaci\u00f3n de las formas especiales set-car! y set-cdr! permite un estilo nuevo de manejo de las estructuras de datos ya vistas (listas o \u00e1rboles) Es posible implementar funciones m\u00e1s eficientes que actualizan la estructura modificando directamente las referencias de unas celdas a otras Las operaciones no construyen estructuras nuevas, sino que modifican la ya existente","title":" 3. Estructuras de datos mutables"},{"location":"teoria/tema05-bis-programacion-imperativa/tema05-programacion-imperativa.html#31-mutacion-de-elementos","text":"Ejemplo 1 Vamos a empezar con un ejemplo sencillo en el que vamos a mutar un elemento de una estructura de datos formada por parejas. Supongamos la siguiente estructura: ( define datos ( cons 2 ( cons ( cons 5 ( cons 8 9 )) ( cons 3 4 )))) El diagrama box-and-pointer es el siguiente. F\u00edjate que hay elementos de las parejas que son datos at\u00f3micos y otros que son referencias a otras parejas. Vamos ahora a mutar la estructura utilizando las sentencias set-car! y set-cdr! . Para mutar una pareja acceder a la pareja y modificar su parte derecha o su parte izquierda con las sentencias anteriores. Por ejemplo, \u00bfc\u00f3mo cambiar\u00edamos el 8 por un 18 ? Deber\u00edamos obtener la pareja (8 . 9) que est\u00e1 al final de la estructura y modificar su parte izquierda: ( set-car! ( cdr ( car ( cdr datos ))) 18 ) La expresi\u00f3n (cdr (car (cdr datos))) devuelve la pareja que queremos modificar y la sentencia set-car! modifica su parte izquierda. Si ahora vemos qu\u00e9 hay en datos veremos que se ha modificado la estructura: ( print-pareja datos ) ; \u21d2 (2 . ((5 . (18 . 9)) . (3 . 4))) Recuerda que print-pareja es una funci\u00f3n que vimos anteriormente. Hemos mutado un dato por otro. Tambi\u00e9n podemos mutar las referencias a las parejas. Por ejemplo, podr\u00edamos modificar la parte derecha de la pareja que contiene el 5 para que apunte a la pareja (3 . 4) : Para ello habr\u00eda que obtener la pareja que contiene el 5 con la expresi\u00f3n (car (cdr datos)) y mutar su parte derecha ( set-cdr! ) con la referencia a la pareja (3 . 4) que se obtiene con la expresi\u00f3n (cdr (cdr datos)) : ( set-cdr! ( car ( cdr datos )) ( cdr ( cdr datos ))) Ejemplo 2 Veamos un segundo ejemplo. Supongamos las siguientes sentencias. \u00bfCu\u00e1l ser\u00eda el box-and-pointer resultante? ( define x ' (( a b ) c d )) ( define y ' ( e f )) ( set-car! x y ) ( define z ( cons y ( cdr x ))) ( set-cdr! x y ) ( set-car! z ( caar x )) Debemos ir paso a paso ejecutando cada instrucci\u00f3n y dibujando c\u00f3mo cambia el diagrama. El diagrama representa el estado del programa , y es un conjunto de parejas que contienen valores y referencias entre ellas. Es muy importante considerar cu\u00e1ndo la sentencia copia un valor y cuando copia una referencia. Las parejas siempre tienen sem\u00e1ntica de referencia. El diagrama resultante despu\u00e9s de las dos primeras sentencias es: Y el diagrama despu\u00e9s de todas las sentencias es: Los valores de las variables despu\u00e9s de todas las sentencias son los siguientes: x ; \u21d2 {{e f} e f} y ; \u21d2 {e f} z ; \u21d2 {e c d} Ejemplo 3 En este ejemplo vamos a usar una nueva forma especial de Scheme que permite crear variables locales y ejecutar expresiones en las que se utilicen esas variables. Se trata de la forma especial let . Veremos algo m\u00e1s de esta forma especial m\u00e1s adelante, cuando hablemos de \u00e1mbitos de variables. Por ahora es suficiente saber que permite crear variables locales y ejecutar un cuerpo (que puede tener m\u00e1s de una sentencia) con esas variables. ( let (( x ( + 2 3 )) ( y ( * 2 10 )) ( + x y )) ; \u21d2 25 En este caso let permite crear dos variables locales x e y y asignarles los valores 5 y 20 respectivamente. Las sentencias del cuerpo del let (en este caso la sentencia (+ x y) ) se eval\u00faan con estos valores reci\u00e9n creados. Vamos a usar esta forma especial en ocasiones para guardar valores o referencias que despu\u00e9s necesitamos asignar. Por ejemplo, \u00bfc\u00f3mo podr\u00edamos definir una funci\u00f3n que mute las referencias de una lista para intercambiar sus posiciones segunda y tercera (sin crear nuevas parejas)? Si llamamos a la funci\u00f3n intercambia! deber\u00eda hacer lo siguiente: ( define lista ' ( 1 2 3 4 5 6 )) ( intercambia! lista ) lista ; \u21d2 {1 3 2 4 5 6} Dibujando el diagrama box-and-pointer podemos ver las mutaciones que tenemos que hacer: La funci\u00f3n es la siguiente: ( define ( intercambia! lista ) ( let (( segundo ( cdr lista )) ( tercero ( cddr lista ))) ( set-cdr! lista tercero ) ( set-cdr! segundo ( cdr tercero )) ( set-cdr! tercero segundo )))","title":" 3.1. Mutaci\u00f3n de elementos"},{"location":"teoria/tema05-bis-programacion-imperativa/tema05-programacion-imperativa.html#32-funciones-mutadoras-make-ciclo-append-e-intercambia-lista","text":"Veamos ahora varios ejemplos de funciones recursivas que recorren listas y realizan mutaciones en ellas. Normalmente las funciones mutadoras no devuelven una estructura, sino que modifican la que se pasa como par\u00e1metro. Por convenio, indicaremos que una funci\u00f3n es mutadora terminando su nombre con un signo de admiraci\u00f3n. make-ciclo! Empecemos con una funci\u00f3n muta una lista, haciendo que la parte derecha de la \u00faltima pareja apunte a la pareja inicial de la misma. Para conseguirlo, necesitamos guardar la referencia a la pareja inicial de la lista en el primer par\u00e1metro de la funci\u00f3n. Y el segundo par\u00e1metro ir\u00e1 avanzando hasta encontrar el final de la lista: ( define ( make-ciclo! lista ref ) ( if ( null? ( cdr ref )) ( set-cdr! ref lista ) ( make-ciclo! lista ( cdr ref )))) Si probamos la funci\u00f3n con una lista, podemos comprobar que DrRacket detecta el ciclo que se produce al final de la misma: ( define lista ' ( 1 2 3 4 5 6 )) ( make-ciclo! lista lista ) lista ; \u21d2 #0={1 2 3 4 5 6 . #0#} Una forma alternativa de implementar esta funci\u00f3n es mediante una funci\u00f3n que devuelva la referencia de la \u00faltima pareja de la lista: ( define ( ultima-pareja lista ) ( if ( null? ( cdr lista )) lista ( ultima-pareja ( cdr lista )))) ( define ( make-ciclo2! lista ) ( let (( ultima-pareja ( ultima-pareja lista ))) ( set-cdr! ultima-pareja lista ))) append! Y vemos a continuaci\u00f3n una versi\u00f3n mutadora de append que llamamos append! y que mejora la eficiencia de la original, copiando al final de la primera lista una referencia a la segunda: La implementaci\u00f3n es la siguiente: ( define ( append! l1 l2 ) ( if ( null? ( cdr l1 )) ( set-cdr! l1 l2 ) ( append! ( cdr l1 ) l2 ))) Ejemplo: ( define a ' ( 1 2 3 4 )) ( define b ' ( 5 6 7 )) ( append! a b ) a ; \u21d2 {1 2 3 4 5 6 7} Algunas puntualizaciones: Al igual que set! , set-car! o set-cdr! , la funci\u00f3n append! no devuelve ning\u00fan valor, sino que modifica directamente la lista que se pasa como primer par\u00e1metro. Al modificarse la lista, todas las referencias que apuntan a ellas quedan tambi\u00e9n modificadas. La funci\u00f3n dar\u00eda un error en el caso en que la llam\u00e1ramos con una lista vac\u00eda como primer argumento. intercambia-lista! Un \u00faltimo ejemplo de funci\u00f3n recursiva que muta una lista. Queremos definir una funci\u00f3n que intercambie todas las parejas excepto la primera de una lista con un n\u00famero de datos impar, pero sin usar set-car! . Llamamos a la funci\u00f3n (intercambia-lista! lista) y deber\u00eda hacer lo siguiente: ( define lista ' ( 1 2 3 4 5 6 7 )) ( intercambia-lista! lista ) lista ; \u21d2 {1 3 2 5 4 7 6} La forma de implementar esta funci\u00f3n va a ser llamando a la funci\u00f3n intercambia! (la que hemos definido anteriormente que intercambia el segundo y el tercer elemento) hasta que lleguemos al final de la lista. Lo hacemos con una recursi\u00f3n: ( define ( intercambia-lista! lista ) ( if ( not ( null? ( cdr lista ))) ( begin ( intercambia! lista ) ( intercambia-lista! ( cddr lista ))))) La funci\u00f3n termina cuando llegamos a la pareja final de la lista, la que tiene la lista vac\u00eda en su parte derecha. Si no estamos en el final de la lista llamamos a la funci\u00f3n intercambia! para intercambiar la siguiente pareja con su siguiente y llamamos a la recursi\u00f3n con la variable lista apuntando a la tercera pareja de la lista.","title":" 3.2. Funciones mutadoras: make-ciclo!, append! e intercambia-lista!"},{"location":"teoria/tema05-bis-programacion-imperativa/tema05-programacion-imperativa.html#33-lista-ordenada-mutable","text":"Veamos ahora una lista ordenada mutable de n\u00fameros, en la que insertaremos elementos de forma ordenada. Definiremos las siguientes funciones: (make-olist) : construye una lista ordenada vac\u00eda (borra-primero-olist! olist) : funci\u00f3n mutadora que elimina (con mutaci\u00f3n) el primer elemento de la lista (inserta-olist! olist n) : funci\u00f3n mutadora que inserta (con mutaci\u00f3n) de forma ordenada un n\u00famero en la lista Implementamos el tipo de datos con una lista normal con una pareja adicional en cabeza. Esta pareja adicional funcionar\u00e1 de cabecera de la lista y ser\u00e1 la referencia inmutable a la que apuntar\u00e1 cualquier variable que apunte a la lista. De esta forma podremos insertar elementos en primera posici\u00f3n de la lista. En la cabecera usaremos por convenio el s\u00edmbolo '*olist*' . ( define lista ' ( *olist* 10 20 30 )) Constructor El constructor (make-olist) devuelve una lista s\u00f3lo con la cabecera. ( define ( make-olist ) ( list '*olist* )) Mutadores Las funciones mutadoras modifican la estructura de datos. Comenzamos con la funci\u00f3n (borra-primero-olist! olist) que elimina con mutaci\u00f3n el primer elemento de la lista ordenada: ( define ( borra-primero-olist! olist ) ( set-cdr! olist ( cddr olist ))) Definimos la funci\u00f3n mutadora inserta-olist! que modifica la lista ordenada a\u00f1adiendo una nueva pareja, insert\u00e1ndola en la posici\u00f3n correcta modificando las referencias. La funci\u00f3n (add-item! item ref) es la funci\u00f3n clave que crea una nueva pareja con el item y la a\u00f1ade en el cdr de la pareja a la que apunta ref . ( define ( add-item! ref item ) ( set-cdr! ref ( cons item ( cdr ref )))) ( define ( inserta-olist! olist n ) ( cond (( null? ( cdr olist )) ( add-item! olist n )) (( < n ( cadr olist )) ( add-item! olist n )) (( = n ( cadr olist )) #f ) ; el valor devuelto no importa ( else ( inserta-olist! ( cdr olist ) n )))) Ejemplo de uso: ( define c ( make-olist )) ( inserta-olist! c 5 ) ( inserta-olist! c 10 ) ( inserta-olist! c -10 ) c ; \u21d2 {*olist* -10 5 10}","title":" 3.3. Lista ordenada mutable"},{"location":"teoria/tema05-bis-programacion-imperativa/tema05-programacion-imperativa.html#34-diccionario-mutable","text":"Veamos ahora un ejemplo m\u00e1s: un diccionario mutable definido mediante una lista de asociaci\u00f3n formada por parejas de clave y valor ( define l-assoc ( list ( cons 'a 1 ) ( cons 'b 2 ) ( cons 'c 3 ))) La funci\u00f3n de Scheme assq recorre la lista de asociaci\u00f3n y devuelve la tupla que contiene el dato que se pasa como par\u00e1metro como clave ( assq 'a l-assoc ) ; \u21d2 (a.1) ( assq 'b l-assoc ) ; \u21d2 (b.2) ( assq 'c l-assoc ) ; \u21d2 (c.3) ( assq 'd l-assoc ) ; \u21d2 #f ( cdr ( assq 'c l-assoc )) ; \u21d2 3 La funci\u00f3n assq busca en la lista de asociaci\u00f3n usando la igualdad de referencia eq? ( define p ( cons 1 2 )) ( define l-assoc ( list ( cons 'a 1 ) ( cons p 2 ) ( cons 'c 3 ))) ( assq ( cons 1 2 ) l-assoc ) ; \u21d2 #f ( assq p l-assoc ) ; \u21d2 {{1 . 2} . 2} Las funciones que vamos a implementar del diccionario son las siguientes: (make-dic) : construye un diccionario vac\u00edo (put-dic! dic clave valor) : inserta en el diccionario un nuevo valor asociado a una clave (get-dic dic clave) : devuelve el valor asociado a una clave en un diccionario Al igual que la lista ordenada mutable, el diccionario necesita una cabecera: ( define ( make-dic ) ( list '*dic* )) La funci\u00f3n (get-dic dic clave) usa la funci\u00f3n assq para buscar la pareja que contiene una clave determinada en la lista de asociaci\u00f3n (el cdr de dic). Y despu\u00e9s devuelve el cdr de esa pareja (el valor guardado junto con la clave: ( define ( get-dic dic clave ) ( let ( pareja ( assq clave ( cdr dic ))) ( if ( not pareja ) #f ( cdr pareja )))) La funci\u00f3n (put-dic! dic clave valor) usa igual que antes la funci\u00f3n assq para comprobar si la clave ya est\u00e1 en la lista de asociaci\u00f3n. Si existe, sustituye el valor por el nuevo. Si no existe, crea una pareja con la clave y el valor y la inserta al comienzo del diccionario (despu\u00e9s de la cabecera): ( define ( put-dic! dic clave valor ) ( let ( pareja ( assq clave ( cdr dic ))) ( if ( not pareja ) ( set-cdr! dic ( cons ( cons clave valor ) ( cdr dic ))) ( set-cdr! pareja valor ))) 'ok ) En las funciones anteriores volvemos a usar la forma especial let . Ejemplos de uso: ( define dic ( make-dic )) ( put-dic! dic 'a 10 ) ; \u21d2 ok ( get-dic dic 'a ) ; \u21d2 10 ( put-dic! dic 'b ' ( a b c )) ; \u21d2 ok ( get-dic dic 'b ) ; \u21d2 {a b c} ( put-dic! dic 'a 'ardilla ) ; \u21d2 ok ( get-dic dic 'a ) ; \u21d2 ardilla","title":" 3.4. Diccionario mutable"},{"location":"teoria/tema05-bis-programacion-imperativa/tema05-programacion-imperativa.html#35-ejemplo-de-mutacion-con-listas-de-asociacion","text":"Una vez introducidos distintas estructuras de datos mutables, incluyendo listas de asociaci\u00f3n, vamos a terminar estos ejemplos con un ejemplo pr\u00e1ctico en el que intervienen las listas y las listas de asociaci\u00f3n. Se trata de escribir un procedimiento regular->assoc! que transforme una lista regular en una lista de asociaci\u00f3n sin crear nuevas parejas. La lista regular (k1 v1 k2 v2 k3 v3 ...) deber\u00e1 convertirse en la lista de asociaci\u00f3n ((k1 . v1) (k2 . v2) (k3 . v3) ...) . Ejemplo: ( define my-list ( list 'a 1 'b 2 'c 3 )) lista ; \u21d2 (a 1 b 2 c 3) ( regular->assoc! my-list ) lista ; \u21d2 ((a . 1) (b . 2) (c . 3)) Una posible soluci\u00f3n a este problema ser\u00eda la siguiente (no es la \u00fanica soluci\u00f3n): Cuando trabajamos con este tipo de problemas, es muy \u00fatil ayudarse con los diagramas caja y puntero. Vamos a crear los diagramas caja y puntero para el ejemplo anterior: Antes de llamar a regular->assoc!: Despu\u00e9s de llamar a regular->assoc!: Queremos hacer la transformaci\u00f3n sin crear nuevas parejas, por lo que cada pareja en el primer diagrama corresponde a una pareja particular en el segundo diagrama. No podemos modificar la primera pareja de la lista (porque perder\u00edamos la ligadura de la variable lista ), por lo que es primera pareja tiene que permanecer en el primer lugar. Por otra parte, a y 1 van a formar parte del mismo par en la lista de asociaci\u00f3n, por lo que vamos a considerar el siguiente cambio de las dos primeras parejas. Diagrama inicial: Despu\u00e9s del cambio de las dos primeras parejas: La siguiente funci\u00f3n manejar-dos-parejas! es la encargada de hacer esta mutaci\u00f3n: ( define ( manejar-dos-parejas! p ) ( let (( key ( car p ))) ;; 1 ( set-car! p ( cdr p )) ;; 2 ( set-cdr! p ( cdar p )) ;; 3 ( set-cdr! ( car p ) ( caar p )) ;; 4 ( set-car! ( car p ) key ))) ;; 5 Se han numerado las l\u00edneas para una mejor explicaci\u00f3n. En la l\u00ednea 1, (define key (car p)) , creamos una variable local key que guarda el valor actual del (car p) , ese valor ser\u00e1 la clave de la primera pareja de la lista de asociaci\u00f3n; necesitamos almacenarlo para no perderlo. En la l\u00ednea 2, (set-car! p (cdr p)) , cambiamos el car de p para que apunte a la siguiente pareja (la azul): En la l\u00ednea 3, (set-cdr! p (cdar p)) , copiamos en el cdr de p el cdr de la pareja en azul para que ambos apunten a la siguiente pareja: En la l\u00ednea 4, (set-cdr! (car p) (caar p)) , cambiamos el cdr de la pareja en azul al car de la misma pareja. Hacemos \u00e9sto porque en una lista de asociaci\u00f3n, los valores se guardan en los cdrs y las claves en los cars : Por \u00faltimo, en la l\u00ednea 5 (set-car! (car p) key) , completamos el problema poniendo la clave que hab\u00edamos guardado, en el car de la pareja azul: Reordenamos el diagrama para verlo m\u00e1s claro: Hemos definido un procedimiento que maneja un subproblema (dos parejas) del problema. Ahora s\u00f3lo nos queda definir la funci\u00f3n que maneja toda la lista: ( define ( regular->assoc! lista ) ( if ( null? lista ) 'ok ( begin ( manejar-dos-parejas! lista ) ( regular->assoc! ( cdr lista )))))","title":" 3.5. Ejemplo de mutaci\u00f3n con listas de asociaci\u00f3n"},{"location":"teoria/tema05-bis-programacion-imperativa/tema05-programacion-imperativa.html#4-ambitos-de-variables-y-clausuras","text":"El concepto del \u00e1mbito de vida de las variables es un concepto fundamental en los lenguajes de programaci\u00f3n. Utilizaremos las palabras \u00e1mbito y entorno como sin\u00f3nimos. En ingl\u00e9s se utiliza el t\u00e9rmino scope . Cuando se define una variable, asoci\u00e1ndole un valor, esta asociaci\u00f3n tiene una extensi\u00f3n determinada, ya sea en t\u00e9rminos de tiempo de compilaci\u00f3n ( \u00e1mbito l\u00e9xico ) como en t\u00e9rminos de tiempo de ejecuci\u00f3n ( \u00e1mbito din\u00e1mico ). El \u00e1mbito de una variable determina cu\u00e1ndo podemos referirnos a ella para recuperar el valor asociado. Al conjunto de variables disponibles en una parte del programa o en una parte de su ejecuci\u00f3n se denomina contexto o entorno ( context o environment ).","title":" 4. \u00c1mbitos de variables y clausuras"},{"location":"teoria/tema05-bis-programacion-imperativa/tema05-programacion-imperativa.html#41-variables-de-ambito-global","text":"Una variable definida en el programa con la instrucci\u00f3n define tiene un \u00e1mbito global. ( define a \"hola\" ) ( define b ( string-append \"adios\" a )) ( define cuadrado ( lambda ( x ) ( * x x ))) Todas las variables definidas fuera de funciones forman parte del entorno global del programa.","title":" 4.1. Variables de \u00e1mbito global"},{"location":"teoria/tema05-bis-programacion-imperativa/tema05-programacion-imperativa.html#42-variables-de-ambito-local","text":"En Scheme existen dos formas de definir variables de \u00e1mbito local: la forma especial define dentro de una funci\u00f3n y la forma especial let .","title":" 4.2. Variables de \u00e1mbito local"},{"location":"teoria/tema05-bis-programacion-imperativa/tema05-programacion-imperativa.html#43-clausuras-y-estado-local","text":"Recordemos que la forma especial lambda permite crear funciones an\u00f3nimas en tiempo de ejecuci\u00f3n. Si ejecutamos una forma especial lambda como \u00faltimo paso de una funci\u00f3n, se devolver\u00e1 la funci\u00f3n reci\u00e9n creada. \u00bfQu\u00e9 sucede si utilizamos en el cuerpo de esta funci\u00f3n an\u00f3nima una variable local definida en la funci\u00f3n principal? Vamos a verlo: ( define ( make-sumador ) ( define z 10 ) ( lambda ( x ) ( + x z ))) La funci\u00f3n make-sumador define una variable local z con el valor de 10. Y despu\u00e9s construye una funci\u00f3n con la expresi\u00f3n lambda . Al ser la \u00faltima expresi\u00f3n de la funci\u00f3n make-sumador , esta funci\u00f3n construida en tiempo de ejecuci\u00f3n es lo que se devuelve. Si invocamos a make-sumador vemos que devuelve un procedimiento: ( make-sumador ) ; \u21d2 #<procedure> Si guardamos el procedimiento en una variable y despu\u00e9s lo invocamos, tendremos que pasarle un par\u00e1metro (correspondiente al argumento x de la expresi\u00f3n lambda ). \u00bfQu\u00e9 devolver\u00e1 esa invocaci\u00f3n? ( define f ( make-sumador )) ( f 5 ) ; \u21d2 ??? Al invocar a f se ejecutar\u00e1 el cuerpo del procedimiento, esto es, la expresi\u00f3n (+ x z) . La variable x valdr\u00e1 5 (el valor del par\u00e1metro). Pero, \u00bfcu\u00e1l es el valor de la variable z?. Podemos comprobar que es 10, porque la invocaci\u00f3n devuelve devuelve 15: ( f 5 ) ; \u21d2 15 \u00bfPor qu\u00e9? Lo que est\u00e1 pasando es que la funci\u00f3n an\u00f3nima que crea la expresi\u00f3n lambda captura las variables locales definidas en el \u00e1mbito en el que se crea. Por eso recibe el nombre de clausura , porque encierra los valores que tienen esas variables en el momento de su creaci\u00f3n y esos valores son los que usa en las variables libres cuando posteriormente la invoquemos. En el ejemplo anterior se est\u00e1 capturando la variable z con su valor 10. Cuando despu\u00e9s invocamos a (f 5) se eval\u00faa el cuerpo (+ x z) con x valiendo 5 y z valiendo el valor capturado (10). Tambi\u00e9n podemos utilizar como estado local el valor de un par\u00e1metro. Por ejemplo: ( define ( make-sumador k ) ( lambda ( x ) ( + x k ))) ( define f ( make-sumador 10 )) ( f 2 ) ; \u21d2 12 En la funci\u00f3n (make-sumador k) se llama a la forma especial lambda para crear una clausura. La clausura captura la variable local k (el par\u00e1metro de make-sumador ) y usar\u00e1 su valor cuando posteriormente se eval\u00fae. En este caso, la clausura se ha creado con k valiendo 10, y captura este valor. Cuando despu\u00e9s se invoca a (f 2) se ejecuta la clausura en un nuevo \u00e1mbito local con las siguientes variables y valores: x: 2 (variable local de la clausura) k: 10 (valor capturado del entorno local en el que se cre\u00f3 la clausura En este \u00e1mbito se ejecuta la expresi\u00f3n (+ x k) , devolvi\u00e9ndose el valor 12. Por \u00faltimo, tambi\u00e9n es posible crear la clausura dentro de un estado local definido con un let y usar en el cuerpo del lambda variables locales definidas en el let : ( define ( make-sumador-cuadrado k ) ( if ( > k 0 ) ( let (( y ( cuadrado k ))) ( lambda ( x ) ( + x y ))) ( lambda ( x ) x ))) La funci\u00f3n anterior tiene un condicional en el que se comprueba si k es mayor que 0. Si lo es, se devuelve una clausura creada en el \u00e1mbito del let con la variable y capturada con el valor del cuadrado de k . Esta clausura suma a su entrada el valor de y . Por ejemplo: ( define f ( make-sumador-cuadrado 4 )) ( f 3 ) ; \u21d2 19 En el caso en que k menor o igual que 0, se devuelve una clausura que devuelve siempre el valor que recibe: ( define f ( make-sumador-cuadrado -8 )) ( f 3 ) ; \u21d2 3 La definici\u00f3n de clausuras con un estado local inicializado a un valor creado en tiempo de ejecuci\u00f3n es una caracter\u00edstica muy potente. Permite no s\u00f3lo crear funciones en tiempo de ejecuci\u00f3n para utilizarlas posteriormente, sino configurarlas con el estado local que nos interese. Veremos en el apartado siguiente que la combinaci\u00f3n de clausuras y mutaci\u00f3n permite crear funciones con estado local mutable, algo equivalente a objetos que encapsulan c\u00f3digo y estado.","title":" 4.3. Clausuras y estado local"},{"location":"teoria/tema05-bis-programacion-imperativa/tema05-programacion-imperativa.html#5-clausuras-con-mutacion-estado-local-mutable","text":"","title":" 5. Clausuras con mutaci\u00f3n = estado local mutable"},{"location":"teoria/tema05-bis-programacion-imperativa/tema05-programacion-imperativa.html#51-estado-local-mutable","text":"Si combinamos una clausura con la posibilidad de mutar las variables capturadas por la clausura obtenemos un estado local mutable asociado a funciones creadas en tiempo de ejecuci\u00f3n. Veamos, por ejemplo, la siguiente funci\u00f3n (make-contador i) : ( define ( make-contador i ) ( define x i ) ( lambda () ( set! x ( + x 1 )) x ))) La funci\u00f3n make-contador define una clausura que captura la variable local x inicializada a i . En cada invocaci\u00f3n a la clausura se ejecuta una sentencia set que modifica el valor de la variable capturada. Y despu\u00e9s se devuelve el nuevo valor de la variable. Estamos implementando un contador asociado a la clausura. ( define f ( make-contador 10 )) ( f ) \u21d2 11 ( f ) \u21d2 12 El estado (el valor del contador) se mantiene y se modifica entre distintas invocaciones a f . A diferencia del paradigma funcional podemos comprobar que distintas invocaciones a la misma funci\u00f3n devuelven valores distintos (dependiente del estado de la clausura). Podemos crear distintas clausuras, cada una con su variable capturada, en distintas invocaciones a make-contador : ( define h ( make-contador 10 )) ( define g ( make-contador 100 )) ( h ) \u21d2 11 ( h ) \u21d2 12 ( g ) \u21d2 101 ( g ) \u21d2 102 Una forma alternativa de crear la clausura, sin usar la forma especial lambda es defini\u00e9ndola con un define en el cuerpo de make-contador . Despu\u00e9s de los dos define la \u00faltima sentencia devuelve la funci\u00f3n incrementa (la clausura). ( define ( make-contador i ) ( define x i ) ( define ( incrementa ) ( set! x ( + x 1 )) x ) incrementa )","title":" 5.1. Estado local mutable"},{"location":"teoria/tema05-bis-programacion-imperativa/tema05-programacion-imperativa.html#52-paso-de-mensajes","text":"En el ejemplo anterior creamos una clausura que siempre incrementa el valor del contador. \u00bfC\u00f3mo podr\u00edamos crear una clausura que permitiera hacer distintas cosas con el valor capturado? Una forma de hacerlo es definir en la clausura un par\u00e1metro adicional (un s\u00edmbolo que llamamos mensaje ) y devolver distintas clausuras en funci\u00f3n del valor de ese par\u00e1metro adicional: ( define ( make-contador i ) ( define x i ) ( define ( get ) x ) ( define ( inc-1 ) ( set! x ( + x 1 )) x ) ( define ( inc y ) ( set! x ( + x y )) x ) ( define ( dispatcher mensaje ) ( cond (( equal? mensaje 'get ) get ) (( equal? mensaje 'inc-1 ) inc-1 ) (( equal? mensaje 'inc ) inc ) ( else \"Error: mensaje desconocido\" ))) dispatcher ) La funci\u00f3n make-contador devuelve la clausura dispatcher que se encarga de procesar el mensaje y devolver la clausura asociada a ese mensaje. Cuando invoquemos al dispatcher con un s\u00edmbolo, devuelve otro procedimiento que hay que volver a invocar con los par\u00e1metros adecuados (sin par\u00e1metros en los dos primeros casos y con el valor a incrementar en el \u00faltimo caso): Si recibe el s\u00edmbolo 'get devuelve la clausura que devuelve el valor del contador Si recibe el s\u00edmbolo 'inc-1 devuelve la clausura que incrementa el valor del contador en 1 Si recibe el s\u00edmbolo 'inc devuelve la clausura que incrementa el valor del contador una cantidad determinada Por ejemplo: ( define c ( make-contador 100 )) (( c 'get )) \u21d2 100 (( c 'inc-1 )) \u21d2 101 (( c 'inc ) 10 ) \u21d2 111 Lenguajes y Paradigmas de Programaci\u00f3n, curso 2016-17 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Domingo Gallardo, Cristina Pomares","title":" 5.2. Paso de mensajes"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html","text":"Tema 5: Programaci\u00f3n Funcional con Swift \u00b6 1. Introducci\u00f3n \u00b6 Te recomendamos que leas el seminario de Swift en el que se introduce el lenguaje y se explica c\u00f3mo ejecutar programas en este lenguaje: Seminario de Swift 1.2. Conceptos fundamentales de Programaci\u00f3n Funcional \u00b6 Vamos a repasar en este tema c\u00f3mo se implementan en Swift conceptos principalmente funcionales como: Valores inmutables Tipos de datos recursivos Funciones como objetos de primera clase y clasuras Funciones de orden superior Repasamos r\u00e1pidamente algunos conceptos b\u00e1sicos de programaci\u00f3n funcional, vistos en los primeros temas de la asignatura. Programaci\u00f3n Funcional: La Programaci\u00f3n Funcional es un paradigma de programaci\u00f3n que trata la computaci\u00f3n como la evaluaci\u00f3n de funciones matem\u00e1ticas y que evita cambios de estado y datos mutables. Funciones matem\u00e1ticas o puras: Las funciones matem\u00e1ticas tienen la caracter\u00edstica de que cuando las invocas con el mismo argumento siempre te devolver\u00e1n el mismo resultado. Funciones como objetos de primera clase: En programaci\u00f3n funcional, las funciones son objetos de primera clase del lenguaje, similares a enteros o strings . Podemos pasar funciones como argumentos en las denominadas funciones de orden superior o devolver funciones creadas en tiempo de ejecuci\u00f3n (clausuras). 1.3. Caracter\u00edsticas b\u00e1sicas de Swift \u00b6 Swift es un lenguaje principalmente imperativo, pero en su dise\u00f1o se han introducido conceptos modernos de programaci\u00f3n funcional, extra\u00eddos de lenguajes como Rust o Haskell. Por ello se puede considerar un lenguaje multi-paradigma , en el que se puede definir c\u00f3digo funcional que se puede ejecutar junto con c\u00f3digo imperativo. Como dice su creador Chris Lattner : El lenguaje Swift es el resultado de un esfuerzo incansable de un equipo de expertos en lenguajes, gur\u00fas de documentaci\u00f3n, ninjas de optimizaci\u00f3n de compiladores [..]. Por supuesto, tambi\u00e9n se benefici\u00f3 enormemente de las experiencias ganadas en muchos otros lenguajes, tomando ideas de Objective-C, Rust, Haskell, Ruby, Python, C#, CLU, y demasiados otros para ser enumerados. 1.3.1. Lenguaje fuertemente tipado \u00b6 A diferencia de Scheme, Swift es un lenguaje fuertemente tipado en el que hay que definir los tipos de variables, par\u00e1metros y funciones. Por ejemplo, en las siguientes declaraciones definimos variables de distintos tipos: let n : Int = 10 let str : String = \"Hola\" let array : [ Int ] = [ 1 , 2 , 3 , 4 , 5 ] El compilador de Swift permite identificar los tipos de las variables cuando se realiza una asignaci\u00f3n. La t\u00e9cnica se denomina inferencia de tipos y permite declarar variables sin escribir su tipo. Por ejemplo, las variables anteriores se pueden declarar tambi\u00e9n asi: let n = 10 let str = \"Hola\" let array = [ 1 , 2 , 3 , 4 , 5 ] Aunque no hayamos declarado expl\u00edcitamente el tipo de las variables, el compilador les ha asignado el tipo correspondiente. Por ejemplo, no podemos asignarles un valor de distinto tipo: var x = 5 x = 4 // correcto x = 6.0 // error // error: cannot assign value of type 'Double' to type 'Int' // x = 5.0 // ^~~ // Int( ) El compilador indica el error e incluso sugiere una posible soluci\u00f3n del mismo. En este caso llamar al constructor Int() pas\u00e1ndole un Double como par\u00e1metro. 1.3.2. Lenguaje multi-paradigma \u00b6 Swift permite combinar caracter\u00edsticas funcionales con caracter\u00edsticas imperativas y de programaci\u00f3n orientada a objetos. Veremos en este tema muchas caracter\u00edsticas funcionales que podremos utilizar en cualquier programa Swift que desarrollemos. Por ejemplo, cuando declaramos una variable podemos declararla como mutable, usando la declaraci\u00f3n var , o como inmutable, usando la declaraci\u00f3n let . Si queremos utilizar un enfoque funcional preferiremos siempre declarar las variables con let . var x = 10 x = 20 // x es mutable let y = 10 y = 20 // error: y es inmutable Una ventaja de la inmutabilidad es que permite que el compilador de Swift optimice el c\u00f3digo de forma muy eficiente. De hecho, el propio compilador nos indica que es preferible definir una variable como let si no la vamos a modificar: func saluda ( nombre : String ) -> String { var saludo = \"Hola \" + nombre + \"!\" return saludo } //warning: variable 'saludo' was never mutated; consider changing to 'let' constant // var saludo = \"Hola \" + nombre // ~~~ ^ // let 2. Inmutabilidad \u00b6 Una de las caracter\u00edsticas funcionales importantes de Swift es el \u00e9nfasis en la inmutabilidad para reforzar la seguridad del lenguaje. Hemos visto que la palabra clave let permite definir constantes y que Swift recomienda su uso si el valor que definimos es un valor que no va a ser modificado. El valor asignado a una constante let puede no conocerse en tiempo de compilaci\u00f3n, sino que puede ser obtenido en tiempo de ejecuci\u00f3n como un valor devuelto por una funci\u00f3n: let respuesta : String = respuestaUsuario . respuesta () Al declarar una variable como let se bloquea su contenido y no se permite su modificaci\u00f3n. Una de las ventajas del paradigma funcional y de la inmutabilidad es que garantiza que el c\u00f3digo que escribimos no tiene efectos laterales y puede ser ejecutado sin problemas en entornos multi-procesador o multi-hilo. 2.1. Creaci\u00f3n de nuevas estructuras y mutaci\u00f3n \u00b6 En la biblioteca est\u00e1ndar de Swift existen una gran cantidad de estructuras (como Int , Double , Bool , String , Array , Dictionary , etc.) que tienen dos tipos de m\u00e9todos: m\u00e9todos que mutan la estructura y m\u00e9todos que devuelven una nueva estructura. Cuando estemos escribiendo c\u00f3digo con estilo funcional deberemos utilizar siempre estos \u00faltimos m\u00e9todos, los que construyen estructuras nuevas. Por ejemplo, en el struct Array se define el m\u00e9todo sort y el m\u00e9todo sorted . El primero ordena el array con mutaci\u00f3n y el segundo devuelve una copia ordenada, sin modificar el array original. En el siguiente c\u00f3digo no se modifica el array original, sino que se construye un array nuevo ordenado: // C\u00f3digo recomendable en programaci\u00f3n funcional // porque utiliza el m\u00e9todo sorted que devuelve una // copia del array original let miArray = [ 10 , - 1 , 3 , 80 ] let arrayOrdenado = miArray . sorted () print ( miArray ) print ( arrayOrdenado ) // Imprime: // [10, -1, 3, 80] // [-1, 3, 10, 80] Este c\u00f3digo es el recomendable cuando estemos escribiendo c\u00f3digo con un estilo de programaci\u00f3n funcional. Sin embargo, el siguiente c\u00f3digo es imperativo y utiliza la mutaci\u00f3n del array original: // C\u00f3digo no recomendable en programaci\u00f3n funcional // porque utiliza el m\u00e9todo sort que muta el array original var miArray = [ 10 , - 1 , 3 , 80 ] miArray . sort () print ( miArray ) // Imprime: // [-1, 3, 10, 80] Otro ejemplo es en la forma de a\u00f1adir elementos a un array. Podemos hacerlo con un enfoque funcional, usando el operador + que construye un array nuevo: // C\u00f3digo recomendable en programaci\u00f3n funcional let miArray = [ 10 , - 1 , 3 , 80 ] let array2 = miArray + [ 100 ] print ( array2 ) // Imprime: // [10, -1, 3, 80, 100] Y podemos hacerlo usando un enfoque imperativo, con el m\u00e9todo append : // C\u00f3digo no recomendable en programaci\u00f3n funcional var miArray = [ 10 , - 1 , 3 , 80 ] miArray . append ( 100 ) print ( miArray ) // Imprime: // [10, -1, 3, 80, 100] Importante En programaci\u00f3n funcional debemos usar siempre los m\u00e9todos que no modifican las estructuras . As\u00ed evitaremos los efectos laterales y nuestro c\u00f3digo funcionar\u00e1 correctamente en entornos multi-hilo. Cuando definimos una variable de tipo let el valor que se asigne a esa variable se convierte en inmutable. Si se trata de una estructura o una clase con m\u00e9todos mutables el compilador dar\u00e1 un error. Por ejemplo: let miArray = [ 10 , - 1 , 3 , 80 ] miArray . append ( 100 ) // error: cannot use mutating member on immutable value: 'miArray' is a 'let' constant Otro ejemplo. El m\u00e9todo append(_:) de un String es un m\u00e9todo mutable. Si definimos una cadena con let no podremos modificarla y dar\u00eda error el siguiente c\u00f3digo: var cadenaMutable = \"Hola\" let cadenaInmutable = \"Adios\" cadenaMutable . append ( cadenaInmutable ) // cadenaMutable es \"HolaAdios\" cadenaInmutable . append ( \"Adios\" ) // error: cannot use mutating member on immutable value: 'cadenaInmutable' is a 'let' constant 3. Funciones \u00b6 3.1. Definici\u00f3n de una funci\u00f3n en Swift \u00b6 Para definir una funci\u00f3n en Swift se debe usar la palabra func , definir el nombre de la funci\u00f3n, sus par\u00e1metros y el tipo de vuelto. El valor devuelto por la funci\u00f3n se debe devolver usando la palabra return . C\u00f3digo de la funci\u00f3n saluda(nombre:) : func saluda ( nombre : String ) -> String { let saludo = \"Hola, \" + nombre + \"!\" return saludo } Para invocar a la funci\u00f3n saluda(nombre:) : print ( saluda ( nombre : \"Ana\" )) print ( saluda ( nombre : \"Pedro\" )) // Imprime \"Hola, Ana!\" // Imprime \"Hola, Pedro!\" 3.2. Etiquetas de argumentos y nombres de par\u00e1metros \u00b6 Cada par\u00e1metro de una funci\u00f3n tiene una etiqueta del argumento y un nombre de par\u00e1metro. La etiqueta del argumento se usa cuando se llama a la funci\u00f3n y el nombre del par\u00e1metro se usa internamente en su implementaci\u00f3n. Por defecto, los par\u00e1metros usan su nombre de par\u00e1metro como etiqueta del argumento: func unaFuncion ( primerNombreParametro : Int , segundoNombreParametro : Int ) { // En el cuerpo de la funci\u00f3n, primerNombreParametro y // segundoNombreParametro se refieren a los valores de los // argumentos del primer y el segundo par\u00e1metro } unaFuncion ( primerNombreParametro : 1 , segundoNombreParametro : 2 ) Es posible hacer distintos la etiqueta del argumento del nombre del par\u00e1metro: func saluda ( nombre : String , de ciudad : String ) -> String { return \"Hola \\( nombre ) ! Me alegro de que hayas podido visitarnos desde \\( ciudad ) .\" } print ( saluda ( nombre : \"Bill\" , de : \"Cupertino\" )) // Imprime \"Hola Bill! Me alegro de que hayas podido visitarnos desde Cupertino.\" En este caso el nombre externo del par\u00e1metro (el que usamos al invocar la funci\u00f3n) es de y el nombre interno (el que se usa en el cuerpo de la funci\u00f3n) es ciudad . Otro ejemplo, la siguiente funci\u00f3n concatena(palabra:con:) : func concatena ( palabra str1 : String , con str2 : String ) -> String { return str1 + str2 } print ( concatena ( palabra : \"Hola\" , con : \"adios\" )) Si no se quiere una etiqueta del argumento para un par\u00e1metro, se puede escribir un subrayado ( _ ) en lugar de una etiqueta del argumento expl\u00edcita para ese par\u00e1metro. Esto nos permite llamar a la funci\u00f3n sin usar un nombre de par\u00e1metro. Por ejemplo, la funci\u00f3n max(_:_:) y la funci\u00f3n divide(_:entre:) : func max ( _ x : Int , _ y : Int ) -> Int { if x > y { return x } else { return y } } print ( max ( 10 , 3 )) func divide ( _ x : Double , entre y : Double ) -> Double { return x / y } print ( divide ( 30 , entre : 4 )) El perfil de la funci\u00f3n est\u00e1 formado por el nombre de la funci\u00f3n, las etiquetas de los argumentos y el tipo devuelto por la funci\u00f3n. En la documentaci\u00f3n de las funciones usaremos las etiquetas separadas por dos puntos. Por ejemplo, las funciones anteriores son max(_:_:) y divide(_:entre:) . Las etiquetas de los argumentos son parte del nombre de la funci\u00f3n. Es posible definir funciones distintas con s\u00f3lo distintos nombres de argumentos, como las siguientes funciones mitad(par:) y mitad(impar:) : func mitad ( par : Int ) -> Int { return par / 2 } func mitad ( impar : Int ) -> Int { return ( impar + 1 ) / 2 } print ( mitad ( par : 8 )) // Imprime 4 print ( mitad ( impar : 9 )) // Imprime 5 3.3. Par\u00e1metros y valores devueltos \u00b6 Es posible definir funciones sin par\u00e1metros: func diHolaMundo () -> String { return \"hola, mundo\" } print ( diHolaMundo ()) // Imprime \"hola, mundo\" Podemos definir funciones sin valor devuelto. Por ejemplo, la siguiente funci\u00f3n diAdios(nombre:) . No hay que escribir flecha con el tipo devuelto. Cuidado, no ser\u00eda propiamente programaci\u00f3n funcional. func diAdios ( nombre : String ) { print ( \"Adi\u00f3s, \\( nombre ) !\" ) } diAdios ( nombre : \"Dave\" ) // Imprime \"Adi\u00f3s, Dave!\" Es posible devolver m\u00faltiples valores, construyendo una tupla. Por ejemplo, la siguiente funci\u00f3n ecuacion(a:b:c:) calcula las dos soluciones de una ecuaci\u00f3n de segundo grado: func ecuacion ( a : Double , b : Double , c : Double ) -> ( pos : Double , neg : Double ) { let discriminante = b * b - 4 * a * c let raizPositiva = ( - b + discriminante . squareRoot ()) / 2 * a let raizNegativa = ( - b - discriminante . squareRoot ()) / 2 * a return ( raizPositiva , raizNegativa ) } Recordemos (consultar el seminario de Swift) que podemos acceder a los valores de la tupla por posici\u00f3n: let resultado = ecuacion ( a : 1 , b : - 5 , c : 6 ) print ( \"Las ra\u00edces de la ecuaci\u00f3n son \\( resultado . 0 ) y \\( resultado . 1 ) \" ) //Imprime \"Las ra\u00edces de la ecuaci\u00f3n son 3.0 y 2.0\" En este caso en la definici\u00f3n del tipo devuelto por la funci\u00f3n estamos etiquetando esos valores con las etiquetas pos y neg . De esta forma podemos acceder a los componentes de la tupla usando esas etiquetas definidas: let resultado = ecuacion ( a : 1 , b : - 5 , c : 6 ) print ( \"Las ra\u00edces de la ecuaci\u00f3n son \\( resultado . pos ) y \\( resultado . neg ) \" ) //Imprime \"Las ra\u00edces de la ecuaci\u00f3n son 3.0 y 2.0\" 4. Recursi\u00f3n \u00b6 Veamos algunos ejemplos de funciones recursivas en Swift. Primero una funci\u00f3n suma(hasta:) que devuelve la suma desde 0 hasta el n\u00famero que le pasamos como par\u00e1metro. func suma ( hasta x : Int ) -> Int { if x == 0 { return 0 } else { return x + suma ( hasta : x - 1 ) } } print ( suma ( hasta : 5 )) // Imprime \"15\" Tambi\u00e9n es posible definir recursiones que recorran arrays de una forma similar a c\u00f3mo trabaj\u00e1bamos en Scheme. Los arrays en Swift no funcionan exactamente como las listas de Scheme (no son listas de parejas), pero podemos obtener el primer elemento y el resto de la siguiente forma. let a = [ 10 , 20 , 30 , 40 , 50 , 60 ] let primero = a [ 0 ] let resto = Array ( a . dropFirst ()) En primero se guarda el n\u00famero 10. En resto se guarda el Array del 20 al 60. El m\u00e9todo dropFirst devuelve una ArraySlice , que es una vista de un rango de elementos del array, en este caso el que va desde la posici\u00f3n 1 hasta la 5 (la posici\u00f3n inicial de un array es la 0). Es necesario el constructor Array para convertir ese ArraySlice en un Array . Usando las instrucciones anteriores podemos definir la funci\u00f3n recursiva que suma los valores de un Array de la siguiente forma similar a c\u00f3mo lo hac\u00edamos en Scheme: func sumaValores ( _ valores : [ Int ]) -> Int { if ( valores . isEmpty ) { return 0 } else { let primero = valores [ 0 ] let resto = Array ( valores . dropFirst ()) return primero + sumaValores ( resto ) } } print ( sumaValores ([ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 ])) // Imprime \"36\" Un \u00faltimo ejemplo es la siguiente funci\u00f3n minMax(array:) que devuelve el n\u00famero m\u00e1s peque\u00f1o y m\u00e1s grande de un array de enteros: func minMax ( array : [ Int ]) -> ( min : Int , max : Int ) { if ( array . count == 1 ) { return ( array [ 0 ], array [ 0 ]) } else { let primero = array [ 0 ] let resto = Array ( array . dropFirst ()) // Llamada recursiva que devuelve el m\u00ednimo y el m\u00e1ximo del // resto del array let minMaxResto = minMax ( array : resto ) let minimo = min ( primero , minMaxResto . min ) let maximo = max ( primero , minMaxResto . max ) return ( minimo , maximo ) } } let limites = minMax ( array : [ 8 , - 6 , 2 , 100 , 3 , 71 ]) print ( \"El m\u00ednimo es \\( limites . min ) y el m\u00e1ximo es \\( limites . max ) \" ) // Imprime \"El m\u00edmimo es -6 y el m\u00e1ximo es 100\" En este ejemplo nos apartamos un poco de la soluci\u00f3n vista en Scheme porque permitimos pasos de ejecuci\u00f3n que inicializan variables. Pero no nos salimos del paradigma funcional, porque todas son variables inmutables definidas con let . 5. Tipos funci\u00f3n \u00b6 En Swift las funciones son objetos de primera clase y podemos asignarlas a variables, pasarlas como par\u00e1metro o devolverlas como resultado de otra funci\u00f3n. Al ser un lenguaje fuertemente tipado, las variables, par\u00e1metros o resultados deben ser objetos de tipo funci\u00f3n. Cada funci\u00f3n tiene un tipo espec\u00edfico, definido por el tipo de sus par\u00e1metros y el tipo del valor devuelto. func sumaDosInts ( a : Int , b : Int ) -> Int { return a + b } func multiplicaDosInts ( a : Int , b : Int ) -> Int { return a * b } El tipo de estas funciones es (Int, Int) -> Int , que se puede leer como: \"Un tipo funci\u00f3n que tiene dos par\u00e1metros, ambos de tipo Int y que devuelve un valor de tipo Int \". En Swift se puede usar un tipo funci\u00f3n de la misma forma que cualquier otro tipo, por ejemplo asignando la funci\u00f3n a una variable: var f = sumaDosInts print ( f ( 2 , 3 )) // Imprime \"5\" f = multiplicaDosInts print ( f ( 2 , 3 )) // Imprime \"6\" La variable f es una variable de tipo (Int, Int) -> Int , o sea, una variable que contiene funciones de dos argumentos Int que devuelven un Int . Nota Habr\u00e1s notado que al invocar a f no se ponen etiquetas en los argumentos. De hecho, si las pusi\u00e9ramos el compilador de Swift se quejar\u00eda: print ( f ( a : 2 , b : 3 )) //error: extraneous argument labels 'a:b:' in call Esto es debido a que al ser f una variable se le puede asignar cualquier funci\u00f3n que tenga el perfil (Int, Int) -> Int sin tener en cuenta las etiquetas de los argumentos. 5.1. Funciones que reciben otras funciones \u00b6 Podemos usar un tipo funci\u00f3n en par\u00e1metros de otras funciones: func printResultado ( funcion : ( Int , Int ) -> Int , _ a : Int , _ b : Int ) { print ( \"Resultado: \\( funcion ( a , b )) \" ) } printResultado ( funcion : sumaDosInts , 3 , 5 ) // Prints \"Resultado: 8\" La funci\u00f3n printResultado(funcion:_:_:) toma como primer par\u00e1metro otra funci\u00f3n que recibe dos Int y devuelve un Int , y como segundo y tercer par\u00e1metro dos Int . Y en el cuerpo llama a la funci\u00f3n que se pasa como par\u00e1metro con los argumentos a y b . Veamos otro ejemplo, que ya vimos en Scheme. Supongamos que queremos calcular el sumatorio desde a hasta b en el que aplicamos una funci\u00f3n f a cada n\u00famero que sumamos: sumatorio(a, b, f) = f(a) + f(a+1) + f(a+2) + ... + f(b) Recordamos que se resuelve con la siguiente recursi\u00f3n: sumatorio(a, b, f) = f(a) + sumatorio(a+1, b, f) sumatorio(a, b, f) = 0 si a > b Veamos c\u00f3mo se implementa en Swift: func sumatorio ( desde a : Int , hasta b : Int , func f : ( Int ) -> Int ) -> Int { if a > b { return 0 } else { return f ( a ) + sumatorio ( desde : a + 1 , hasta : b , func : f ) } } func identidad ( _ x : Int ) -> Int { return x } func doble ( _ x : Int ) -> Int { return x + x } func cuadrado ( _ x : Int ) -> Int { return x * x } print ( sumatorio ( desde : 0 , hasta : 10 , func : identidad )) // Imprime 55 print ( sumatorio ( desde : 0 , hasta : 10 , func : doble )) // Imprime 110 print ( sumatorio ( desde : 0 , hasta : 10 , func : cuadrado )) // Imprime 385 5.2. Funciones en estructuras \u00b6 Como cualquier otro tipo Las funciones pueden tambi\u00e9n incluirse en estructuras de datos compuestas, como arrays: var funciones = [ identidad , doble , cuadrado ] print ( funciones [ 0 ]( 10 )) // 10 print ( funciones [ 1 ]( 10 )) // 20 print ( funciones [ 2 ]( 10 )) // 100 El tipo de la variable funciones ser\u00eda [(Int) -> Int] . Al ser Swift fuertemente tipado, no podr\u00edamos hacer un array con distintos tipos de funciones. Por ejemplo el siguiente c\u00f3digo dar\u00eda un error: func suma ( _ x : Int , _ y : Int ) -> Int { return x + y } // La siguiente l\u00ednea genera un error var misFunciones = [ doble , cuadrado , suma ] // error: heterogenous collection literal could only be inferred to // '[Any]'; add explicit type annotation if this is intentional 5.3 Funciones que devuelven otras funciones \u00b6 Por \u00faltimo, veamos un ejemplo de funciones que devuelven otras funciones. Es un ejemplo sencillo, una funci\u00f3n que devuelve otra que suma 10: func construyeSumador10 () -> ( Int ) -> Int { func suma10 ( x : Int ) -> Int { return x + 10 } return suma10 } var g = construyeSumador10 () print ( g ( 20 )) // Imprime 30 La funci\u00f3n devuelta por construyeSumador10() es una funci\u00f3n con el tipo (Int) -> Int (recibe un par\u00e1metro entero y devuelve un entero). En la llamada a construyeSumador10() se crea esa funci\u00f3n y se asigna a la variable g . Estas funciones devueltas se denominan clausuras . M\u00e1s adelante hablaremos algo m\u00e1s de ellas. Veremos tambi\u00e9n m\u00e1s adelante que es posible usar expresiones de clausura que construyen clausuras an\u00f3nimas. Podemos modificar el ejemplo anterior, haciendo que la funci\u00f3n construyeSumador reciba el n\u00famero a sumar como par\u00e1metro: func construyeSumador ( inc : Int ) -> ( Int ) -> Int { func suma ( x : Int ) -> Int { return x + inc } return suma } var f2 = construyeSumador ( inc : 10 ) var f3 = construyeSumador ( inc : 100 ) print ( f2 ( 20 )) // Imprime \"30\" print ( f3 ( 20 )) // Imprime \"120\" Invocamos dos veces a construyeSumador(inc:) y guardamos las clausuras construidas en las variables f2 y f3 . En f2 se guarda una funci\u00f3n que suma 10 a su argumento y en f3 otra que suma 100 . 6. Tipos \u00b6 Entre las ventajas del uso de tipos est\u00e1 la detecci\u00f3n de errores en los programas en tiempo de compilaci\u00f3n o las ayudas del entorno de desarrollo para autocompletar c\u00f3digo. Entre los inconvenientes se encuentra la necesidad de ser m\u00e1s estrictos a la hora de definir los par\u00e1metros y los valores devueltos por las funciones, lo que impide la flexibilidad de Scheme. Se utilizan tipos para definir los posibles valores de: variables par\u00e1metros de funciones valores devueltos por funciones Tal y como hemos visto cuando hemos comentado que Swift es fuertemente tipado las definiciones de tipos van precedidas de dos puntos en las variables y par\u00e1metros, o de una flecha ( -> ) en la definici\u00f3n de los tipos de los valores devueltos por una funci\u00f3n: let valorDouble : Double = 3.0 let unaCadena : String = \"Hola\" func calculaEstadisticas ( valores : Array < Int >) -> ( min : Int , max : Int , media : Int ) { ... } En Swift existen dos clases de tipos: tipos con nombre y tipos compuestos. 6.1. Tipos con nombre \u00b6 Un tipo con nombre es un tipo al que podemos dar un nombre determinado cuando se define. Por ejemplo, al definir un nombre de una clase o de un enumerado estamos tambi\u00e9n definiendo un nombre de un tipo. En Swift es posible definir los siguientes tipos con nombre: nombres de clases nombres de estructuras nombres de enumeraciones nombres de protocolos Por ejemplo, instancias de una clase definida por el usuario llamada MiClase tienen el tipo MiClase . Adem\u00e1s de los tipos definidos por el usuario, la biblioteca est\u00e1ndar de Swift tiene un gran n\u00famero de tipos predefinidos. A diferencia de otros lenguajes, estos tipos no son parte del propio lenguaje sino que se definen en su mayor\u00eda como estructuras implementadas en esta biblioteca est\u00e1ndar. Por ejemplo, arrays, diccionarios o incluso los tipos m\u00e1s b\u00e1sicos como String o Int est\u00e1n construidos en esa biblioteca. La implementaci\u00f3n de estos elementos est\u00e1 disponible en abierto en el sitio GitHub de Swift . 6.2. Tipos compuestos \u00b6 Los tipos compuestos son tipos sin nombre. En Swift se definen dos: tuplas y tipos funci\u00f3n. Un tipo compuesto puede tener tipos con nombre y otros tipos compuestos. Por ejemplo la tupla (Int, (Int, Int)) contiene dos elementos: el primero es el tipo con nombre Int y el segundo el tipo compuesto que define la tupla (Int, Int) . Los tipos funci\u00f3n los hemos visto previamente. let tupla : ( Int , Int , String ) = ( 2 , 3 , \"Hola\" ) let otraTupla : ( Int , Int , String ) = ( 5 , 8 , \"Adios\" ) func sumaTupla ( tupla t1 : ( Int , Int ), con t2 : ( Int , Int )) -> ( Int , Int ) { return ( t1 . 0 + t2 . 0 , t1 . 1 + t2 . 1 ) } print ( sumaTupla ( tupla : ( tupla . 0 , tupla . 1 ), con : ( otraTupla . 0 , otraTupla . 1 ))) // Imprime (7, 11) 6.2.1. Typealias \u00b6 En Swift se define la palabra clave typealias para darle un nombre asignado a cualquier otro tipo. Ambos tipos son iguales a todos los efectos (es \u00fanicamente az\u00facar sint\u00e1ctico). Por ejemplo, en el siguiente c\u00f3digo definimos un typealias llamado Resultado que corresponde a una tupla con dos Int correspondientes al resultado de un partido de futbol. Una vez definido, podemos usarlo como un tipo. La funci\u00f3n quiniela(partido:) devuelve un String correspondiente al resultado de la quiniela de un partido: typealias Resultado = ( Int , Int ) func quiniela ( partido : Resultado ) -> String { switch partido { case let ( goles1 , goles2 ) where goles1 < goles2 : return \"Dos\" case let ( goles1 , goles2 ) where goles1 > goles2 : return \"Uno\" default : return \"Equis\" } } print ( quiniela ( partido : ( 1 , 3 ))) // Imprime \"Dos\" print ( quiniela ( partido : ( 2 , 2 ))) // Imprime \"Equis\" En el ejemplo se usa una sentencia switch que recibe el resultado del partido. Este resultado es una tupla de dos enteros. En el case let se instancia los valores de esa tupla en las variables goles1 y goles2 y despu\u00e9s se define una condici\u00f3n para entrar en el caso. En el primer caso, que goles1 sea menor que goles2 y en el segundo que goles1 sea mayor que goles2 . 6.3. Tipos valor y tipos referencia \u00b6 En Swift existen dos tipos de construcciones que forman la base de la programaci\u00f3n orientada a objetos: las estructuras ( structs ) y las clases. En el tema siguiente hablaremos sobre ello. En la biblioteca est\u00e1ndar de Swift la mayor parte de los tipos definidos (como Int , Double , Bool , String , Array , Dictionary , etc.) son estructuras, no clases. Una de las diferencias m\u00e1s importantes entre estructuras y clases es su comportamiento en una asignaci\u00f3n: las estructuras tienen una sem\u00e1ntica de copia (son tipos valor) y las clases tienen una sem\u00e1ntica de referencia (son tipos referencia). Un tipo valor es un tipo que tiene sem\u00e1ntica de copia en las asignaciones y cuando se pasan como par\u00e1metro en llamadas a funciones. Los tipos valor son muy \u00fatiles porque evitan los efectos laterales en los programas y simplifican el comportamiento del compilador en la gesti\u00f3n de memoria. Al no existir referencias, se simplifica enormemente la gesti\u00f3n de memoria de estas estructuras. No es necesario llevar la cuenta de qu\u00e9 referencias apuntan a un determinado valor, sino que se puede liberar la memoria en cuanto se elimina el \u00e1mbito actual. Frente a un tipo valor, un tipo de referencia es aquel en los que los valores se asignan a variables con una sem\u00e1ntica de referencia. Cuando se realizan varias asignaciones de una misma instancia a distintas variables todas ellas guardan una referencia a la misma instancia. Si la instancia se modifica, todas las variables reflejar\u00e1n el nuevo valor. Cuando veamos las clases en el pr\u00f3ximo tema veremos algunos ejemplos. Veamos ahora algunos ejemplos de copia por valor en estructuras. Por ejemplo, si asignamos una cadena a otra, se realiza una copia: var str1 = \"Hola\" var str2 = str1 str1 . append ( \"Adios\" ) print ( str1 ) // Imprime \"HolaAdios\" print ( str2 ) // Imprime \"Hola\" Los arrays tambi\u00e9n son estructuras y, por tanto, tambi\u00e9n tienen sem\u00e1ntica de copia: var array1 = [ 1 , 2 , 3 , 4 ] var array2 = array1 array1 [ 0 ] = 10 print ( array1 ) // [10, 2, 3, 4] print ( array2 ) // [1, 2, 3, 4] A diferencia de otros lenguajes como Java, los par\u00e1metros de una funci\u00f3n siempre son inmutables y se pasan por copia, para reforzar el car\u00e1cter funcional de las funciones. Por ejemplo, es incorrecto escribir lo siguiente: func ponCero(array: [Int], pos: Int) { array[pos] = 0 // error: cannot assign through subscript: 'array' is a 'let' constant } Se podr\u00eda pensar que es muy costoso copiar un array entero. Por ejemplo, si asignamos o pasamos como par\u00e1metro un array de 1000 elementos. Pero no es as\u00ed. El compilador de Swift optimiza estas sentencias y s\u00f3lo realiza la copia en el momento en que hay una modificaci\u00f3n de una de las variables que comparten el array. Es lo que se llama copy on write . 7. Enumeraciones \u00b6 Las enumeraciones definen un tipo con un valor restringido de posibles valores: enum Direccion { case norte case sur case este case oeste } Cualquier variable del tipo Direccion solo puede tener uno de los cuatro valores definidos. Se obtiene el valor escribiendo el nombre de la enumeraci\u00f3n, un punto y el valor definido. Si el tipo de enumeraci\u00f3n se puede inferir no es necesario escribirlo. let hemosGirado = true var direccionActual = Direccion . norte if hemosGirado { direccionActual = . sur } En sentencias switch: let direccionAIr = Direccion . sur switch direccionAIr { case . norte : print ( \"Nos vamos al norte\" ) case . sur : print ( \"Cuidado con los pinguinos\" ) case . este : print ( \"Donde nace el sol\" ) case . oeste : print ( \"Donde el cielo es azul\" ) } // Imprime \"Cuidado con los pinguinos\" Otro ejemplo: enum Planeta { case mercurio , venus , tierra , marte , jupiter , saturno , urano , neptuno } Y, por \u00faltimo, es m\u00e1s correcto definir el resultado de una quiniela con un enumerado en lugar de con un String : enum Quiniela { case uno , equis , dos } 7.1. Valores brutos de enumeraciones \u00b6 Es posible asignar a las constantes del enumerado un valor concreto de un tipo subyacente, por ejemplo enteros: enum Quiniela : Int { case uno = 1 , equis = 0 , dos = 2 } Se puede obtener el valor bruto a partir del propio tipo o de una variable del tipo, usando rawValue : // Obtenemos el valor bruto a partir del tipo let valorEquis : Int = Quiniela . equis . rawValue // Obtenemos el valor bruto a partir de una variable let res = Quiniela . equis let valorEquis = res . rawValue Tambi\u00e9n se puede asignar los valores de forma impl\u00edcita, dando un valor a la primera constante. Las siguientes tienen el valor consecutivo: enum Planeta : Int { case mercurio = 1 , venus , tierra , marte , jupiter , saturno , urano , neptuno } let posicionTierra = Planeta . tierra . rawValue // posicionTierra es 3 Podemos escoger cualquier tipo subyacente. Por ejemplo el tipo Character : enum CaracterControlASCII : Character { case tab = \" \\t \" case lineFeed = \" \\n \" case carriageReturn = \" \\r \" } El car\u00e1cter nueva l\u00ednea ( lineFeed ) se puede obtener de la siguiente forma: let nuevaLinea = CaracterControlASCII.LineFeed.rawValue Y por \u00faltimo, se puede definir como tipo subyacente String y los valores brutos de las constantes ser\u00e1n sus nombres convertidos a cadenas: enum Direccion : String { case norte , sur , este , oeste } let direccionAtardecer = Direccion . oeste . rawValue // direccionAtardecer es \"oeste\" En este caso, tambi\u00e9n se puede inicializar el valor bruto con una asignaci\u00f3n expl\u00edcita y no usar el propio nombre: enum Direccion : String { case norte = \"north\" case sur = \"south\" case este = \"east\" case oeste = \"west\" } let direccionAtardecer = Direccion . oeste . rawValue // direccionAtardecer es \"west\" Cuando se definen valores brutos es posible inicializar el enumerado de una forma similar a una estructura o una clase pasando el valor bruto. Devuelve el valor enumerado correspondiente o nil (un opcional): let posiblePlaneta = Planeta ( rawValue : 7 ) // posiblePlaneta es de tipo Planeta? y es igual a Planeta.urano 8. Enumeraciones instanciables \u00b6 Una caracter\u00edstica singular de las enumeraciones en Swift es que permiten definir valores variables asociados a cada caso de la enumeraci\u00f3n, creando algo muy parecido a una instancia de la enumeraci\u00f3n. 8.1. Valores asociados a instancias de enumeraciones \u00b6 Veamos un ejemplo inicial muy sencillo, con una enumeraci\u00f3n con un \u00fanico caso, en el que se define una variable de tipo Int : enum Prueba { case num ( Int ) } Esta notaci\u00f3n obliga a definir un valor concreto del Int asociado al caso num en el momento de creaci\u00f3n del enumerado: let valor1 = Prueba . num ( 10 ) let valor2 = Prueba . num ( 40 ) Las variables valor1 y valor2 son de tipo Prueba y tiene como valor el caso num , y el entero asociado a ese caso ( 10 y 40 en cada instancia). Son parecidas a instancias de una clase. Para obtener el valor asociado debemos usar una expresi\u00f3n case let en una sentencia switch con una variable a la que se asigna el valor. Por ejemplo, en el siguiente c\u00f3digo el valor del enumerado se asigna a la variable x : switch valor1 { case let . num ( x ): print ( \"Valor asociado al caso num: \\( x ) \" ) } // Imprime \"Valor asociado al caso num: 10 No hay que confundir un valor asociado a un caso y un valor bruto: el valor bruto de un caso de enumeraci\u00f3n es el mismo para todas las instancias, mientras que el valor asociado es distinto y se proporciona cuando se define el valor concreto de la enumeraci\u00f3n. Cuando unimos a la caracter\u00edstica del valor asociado la posibilidad de los enumerados de tener m\u00e1s de un caso tenemos lo que en otros lenguajes de programaci\u00f3n se llaman uniones etiquetadas o variantes . Por ejemplo, podemos definir un enumerado que permita guardar un Int o un String : enum Multiple { case num ( Int ) case str ( String ) } De esta forma, podemos crear valores de tipo Multiple que contienen un Int (instanciando el caso num ) o un String (instanciando el caso str ): let valor3 = Multiple . num ( 10 ) let valor4 = Multiple . str ( \"Hola\" ) Y podemos definir una funci\u00f3n que reciba instancias de tipo Multiple y use un switch para comprobar qu\u00e9 caso tienen instanciado: func imprime ( multiple : Multiple ) { switch multiple { case let . num ( x ): print ( \"Multiple tiene un Int: \\( x ) \" ) case let . str ( s ): print ( \"Multiple tiene un String: \\( s ) \" ) } } imprime ( multiple : valor3 ) // Imprime \"Multiple tiene un Int: 10\" imprime ( multiple : valor4 ) // Imprime \"Multiple tiene un String: Hola En un \u00faltimo ejemplo podemos ver que el tipo del caso tambi\u00e9n puede ser un tipo compuesto, como una tupla. Usamos un enum para definir posibles valores de un c\u00f3digo de barras, en el que incluimos dos posibles tipos de c\u00f3digo de barras: el c\u00f3digo de barras lineal (denominado UPC) y el c\u00f3digo QR: enum CodigoBarras { case upc ( Int , Int , Int , Int ) case qrCode ( String ) } Se lee de la siguiente forma: \u201cDefinimos un tipo enumerado llamado CodigoBarras , que puede tomar como valor un upc (c\u00f3digo de barras lineal) con un valor asociado de tipo (Int, Int, Int, Int) (una tupla de 4 enteros que representan los 4 n\u00fameros que hay en los c\u00f3digos de barras lineales) o un valor qrCode con valor asociado de tipo String \". Veamos un ejemplo de uso, en el que creamos un c\u00f3digo de barras de producto de tipo UPC, despu\u00e9s lo modificamos a otro de tipo c\u00f3digo QR y por \u00faltimo lo imprimimos: var codigoBarrasProducto = CodigoBarras . upc ( 8 , 85909 , 51226 , 3 ) codigoBarrasProducto = . qrCode ( \"ABCDEFGHIJKLMNOP\" ) switch codigoBarrasProducto { case let . upc ( sistemaNumeracion , fabricante , producto , control ): print ( \"UPC: \\( sistemaNumeracion ) , \\( fabricante ) , \\( producto ) , \\( control ) .\" ) case let . qrCode ( codigoProducto ): print ( \"C\u00f3digo QR: \\( codigoProducto ) .\" ) } // Imprime \"C\u00f3digo QR : ABCDEFGHIJKLMNOP.\" 8.2. Enumeraciones recursivas \u00b6 Es posible combinar las caracter\u00edsticas de las enumeraciones con valor con la recursi\u00f3n para crear enumeraciones recursivas. Hay que preceder la palabra clave enum con indirect : indirect enum ExpresionAritmetica { case numero ( Int ) case suma ( ExpresionAritmetica , ExpresionAritmetica ) case multiplicacion ( ExpresionAritmetica , ExpresionAritmetica ) } let cinco = ExpresionAritmetica . numero ( 5 ) let cuatro = ExpresionAritmetica . numero ( 4 ) let suma = ExpresionAritmetica . suma ( cinco , cuatro ) let producto = ExpresionAritmetica . multiplicacion ( suma , ExpresionAritmetica . numero ( 2 )) Es muy c\u00f3modo manejar enumeraciones recursivas de forma recursiva: func evalua ( expresion : ExpresionAritmetica ) -> Int { switch expresion { case let . numero ( valor ): return valor case let . suma ( izquierda , derecha ): return evalua ( expresion : izquierda ) + evalua ( expresion : derecha ) case let . multiplicacion ( izquierda , derecha ): return evalua ( expresion : izquierda ) * evalua ( expresion : derecha ) } } print ( evalua ( expresion : producto )) // Imprime 18 Otro ejemplo de enums recursivos, para definir un tipo de datos Lista similar al que vimos en Scheme. La lista puede ser una lista vac\u00eda o puede contener dos elementos: un valor Int y otra lista: indirect enum Lista { case vacia case nodo ( Int , Lista ) } Para crear una lista de tipo nodo deberemos dar un valor entero (el valor de la cabeza de la lista) y otra lista (el resto de la lista). Tambi\u00e9n podemos crear una lista vac\u00eda. Por ejemplo, podemos crear la lista (10, 20, 30) de la siguiente manera: let lista1 = Lista . nodo ( 30 , Lista . vacia ) let lista2 = Lista . nodo ( 20 , lista1 ) let lista3 = Lista . nodo ( 10 , lista2 ) Podr\u00edamos crear esta misma lista de una forma m\u00e1s abreviada: let lista : Lista = . nodo ( 10 , . nodo ( 20 , . nodo ( 30 , . vacia ))) Una vez definido el tipo enumerado, podemos definir funciones que trabajen con \u00e9l. La siguiente funci\u00f3n, por ejemplo, es una funci\u00f3n recursiva que recibe una lista y devuelve la suma de sus elementos. Funciona de una forma muy similar a la definici\u00f3n que hicimos en Scheme: func suma ( lista : Lista ) -> Int { switch lista { case . vacia : return 0 case let . nodo ( car , cdr ): return car + suma ( lista : cdr ) } } let z : Lista = . nodo ( 20 , . nodo ( 10 , . vacia )) print ( suma ( lista : z )) // Imprime 30 Podemos tambi\u00e9n definir una funci\u00f3n recursiva construye(lista:[Int]) que devuelve una lista a partir de una array de enteros: func construye ( lista : [ Int ]) -> Lista { if ( lista . isEmpty ) { return Lista . vacia } else { let primero = lista [ 0 ] let resto = Array ( lista . dropFirst ()) return Lista . nodo ( primero , construye ( lista : resto )) } } let lista2 = construye ( lista : [ 1 , 2 , 3 , 4 , 5 ]) print ( suma ( lista : lista2 )) // Imprime 15 9. Opcionales \u00b6 Una de las caracter\u00edsticas principales que Swift intenta promover es la seguridad y la robustez. Debe ser dif\u00edcil que el desarrollador escriba c\u00f3digo con errores y que rompa la aplicaci\u00f3n. Por ejemplo, la comprobaci\u00f3n est\u00e1tica de los tipos de datos o el manejo autom\u00e1tico de la gesti\u00f3n de memoria son dos caracter\u00edsticas del lenguaje que van en esta direcci\u00f3n. Otro de los elementos m\u00e1s importantes del lenguaje para promover la seguridad son los opcionales. Vamos a estudiar su uso y utilidad. En muchos lenguajes existe el concepto de valor vac\u00edo . Por ejemplo, en Java se usa null o en Python None . Nota Tony Hoare introdujo el concepto de Null en ALGOL, en 1965. En una conferencia en 2009 habla sobre esta idea y la considera un costoso error: Null References: The Billion Dollar Mistake . El concepto de null es un concepto peligroso, como lo saben bien los desarrolladores Java. En Java, si intentamos usar una variable que contiene null se produce la t\u00edpica excepci\u00f3n null pointer exception y la aplicaci\u00f3n se rompe. Todos hemos ca\u00eddo en este error, y con m\u00e1s frecuencia de la que ser\u00eda deseable. En Swift tambi\u00e9n existe el valor nulo. La forma de representarlo es el identificador nil . La caracter\u00edstica de seguridad que introduce Swift con respecto a Java y a otros lenguajes es que no es posible asignar nil a una variable de un tipo normal. Por ejemplo, la siguiente l\u00ednea dar\u00eda un error de compilaci\u00f3n: let cadena : String = nil // error: 'nil' cannot initialize specified type 'String' Si queremos utilizar nil debemos declarar la variable usando lo que se denomina tipo opcional : var cadena : String ? = \"Hola\" cadena = nil El tipo String? indica que podemos tener un valor nil o un valor del tipo original. Primero estamos definiendo la variable cadena del tipo String? ( String opcional) y le estamos asignando un valor determinado (de tipo String ). Y despu\u00e9s le asignamos nil . El uso de opcionales es necesario en situaciones en las que podemos obtener un valor desconocido. Por ejemplo, en alguna funci\u00f3n en la que pedimos un valor al usuario y el usuario puede no introducir ninguno. O en estructuras de datos en las que hacemos b\u00fasquedas que pueden no devolver ning\u00fan valor, como en un diccionario: var edades = [ \"Raquel\" : 30 , \"Pedro\" : 22 , ] let edad1 = edades [ \"Raquel\" ] let edad2 = edades [ \"Ana\" ] // devuelve nil En el c\u00f3digo anterior definimos un diccionario edades con claves de tipo String y valores Int . Despu\u00e9s buscamos en el diccionario por la clave \"Raquel\" y se devuelve el valor 30 , que se guarda en la variable edad1 . Cuando se busca por la clave \"Ana\" se devuelve un nil porque no est\u00e1 definida. Por ello, la variable edad2 ser\u00e1 de tipo Int? ( Int opcional) y contendr\u00e1 un nil . Un valor opcional no puede ser usado directamente. Primero debemos comprobar si el valor es distinto de nil y s\u00f3lo despu\u00e9s podremos usarlo. Para reforzar esto, Swift esconde o envuelve ( wrap ) el valor real del opcional y obliga a llamar al operador ! para desenvolverlo ( unwrap ) y usarlo. Este operador se denomina de desenvoltura forzosa ( forced unwrapping ). Por ejemplo, el siguiente c\u00f3digo produce un error de compilaci\u00f3n porque intentamos usar un opcional sin desenvolverlo: var x : Int ? = 10 let y = x + 10 // error: value of optional type 'Int?' must be unwrapped to a value of type 'Int' Para usar el valor asignado a x debemos desenvolverlo con el operador ! : var x : Int ? = 10 let y = x ! + 10 print ( y ) // Imprime \"20\" Si se aplica el operador ! a un valor nil se produce un error en tiempo de ejecuci\u00f3n y la aplicaci\u00f3n se rompe: var respuestaEncuesta : String ? print ( respuestaEncuesta !) // Fatal error: Unexpectedly found nil while unwrapping an Optional value Podemos definir como opcional variables, par\u00e1metros o valores devueltos por funciones de cualquier tipo, a\u00f1adi\u00e9ndoles la interrogaci\u00f3n al final. Por ejemplo, la siguiente funci\u00f3n max es una funci\u00f3n que devuelve un Int? , un entero opcional en el caso de que se le pase un array vac\u00edo. Al devolver un opcional, debemos desenvolver el valor devuelto cuando queramos usarlo como Int (por ejemplo, en la llamada recursiva). func max ( array :[ Int ]) -> Int ? { if ( array . isEmpty ) { return nil } else if ( array . count == 1 ) { return array [ 0 ] } else { let primero = array [ 0 ] let resto = Array ( array . dropFirst ()) return max ( primero , max ( array : resto ) ! ) } } let maximo = max ( array :[ 10 , 200 , - 100 , 2 ]) print ( maximo !) // Imprime \"200\" Una variable opcional sin asignar ning\u00fan valor se inicializa autom\u00e1ticamente a nil : var respuestaEncuesta : String ? // respuestaEncuesta es inicializado autom\u00e1ticamente a nil 9.1 Ligado opcional \u00b6 Para comprobar si un valor opcional es nil podemos usar un if . Es obligado hacerlo si desconocemos el valor que nos llega. Por ejemplo, supongamos que la funci\u00f3n leerRespuesta() lee una respuesta del usuario y devuelve un String? . Para usar esta funci\u00f3n deber\u00edamos comprobar si el valor devuelto es distinto de nil : let respuestaEncuesta = leerRespuesta () if respuestaEncuesta != nil { let respuesta = respuestaEncuesta ! print ( \"Respuesta: \" + respuesta ) } Como es muy habitual hacer lo anterior, en Swift es posible comprobar si un opcional tiene valor y asignar su valor a otra variable al mismo tiempo con una construcci\u00f3n llamada ligado opcional ( optional binding ): let respuestaEncuesta = leerRespuesta () if let respuesta = respuestaEncuesta { print ( \"Respuesta: \" + respuesta ) } Podemos leer el c\u00f3digo anterior de la siguiente forma: \"Si el opcional respuestaEncuesta contiene un valor, define la constante respuesta con el valor contenido en el opcional\". Una forma a\u00fan mejor de escribir el c\u00f3digo anterior ser\u00eda la siguiente, en la que s\u00f3lo usamos una variable: // Mejor este c\u00f3digo que el anterior if let respuesta = leerRespuesta () { print ( \"Respuesta: \" + respuesta ) } Nota Para no tener que buscar un nuevo nombre de variable, Swift permite usar el mismo nombre de variable en la sentencia if let : var x : Int ? = 0 if let x = x { print ( x ) } La variable x creada por el if let es de tipo no opcional y s\u00f3lo tiene valor en el \u00e1mbito del if . Otro ejemplo, el m\u00e9todo first de un array devuelve un opcional que contiene nil si el array est\u00e1 vac\u00edo o el primer elemento del array en el caso en que exista. El siguiente c\u00f3digo utiliza un ligado opcional para implementar otra versi\u00f3n de la funci\u00f3n que suma los valores de un array: func sumaValores ( _ valores : [ Int ]) -> Int { if let primero = valores . first { let resto = Array ( valores . dropFirst ()) return primero + sumaValores ( resto ) } else { return 0 } } print ( sumaValores ([ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 ])) // Imprime \"36\" Si tenemos varios opcionales es posible comprobar que todos ellos son distintos de nil usando varios let en el mismo if : var x1 : Int ? = pedirNumUsuario () var x2 : Int ? = pedirNumUsuario () var x3 : Int ? = pedirNumUsuario () if let dato1 = x1 , let dato2 = x2 , let dato3 = x3 { let suma = dato1 + dato2 + dato3 print ( \"Ning\u00fan nil y la suma de todos los datos es: \\( suma ) \" ) } else { print ( \"Alg\u00fan dato del usuario es nil\" ) } 9.2. Operador nil-coalescing \u00b6 El operador nil-coalescing ( ?? ) permite definir un valor por defecto en una asignaci\u00f3n si un opcional es nil. let a : Int ? = nil let b : Int ? = 10 let x = a ?? - 1 let y = b ?? - 1 print ( \"Resultado: \\( x ) , \\( y ) \" ) // Imprime Resultado: -1, 10 En el ejemplo anterior, en la variable x se guardar\u00e1 el valor -1 y en la variable y el valor 10 . 9.3. Encadenamiento de opcionales \u00b6 El encadenamiento de opcionales ( optional chaining ) permite llamar a un m\u00e9todo de una variable que contiene un opcional. Si la variable no es nil , se ejecuta el m\u00e9todo y se devuelve su valor como un opcional. Si la variable es nil se devuelve nil . let nombre1 : String ? = \"Pedro\" let nombre2 : String ? = nil // Error: let str1 = nombre1.lowercased() // No podemos llamar al m\u00e9todo lowercased() del String // porque nombre es opcional y puede tener nil let str1 = nombre1 ?. lowercased () let str2 = nombre2 ?. lowercased () // str1: String? = \"pedro\" // str2: String? = nil 9.4. Definici\u00f3n de Lista con opcionales \u00b6 Veamos como \u00faltimo ejemplo una segunda versi\u00f3n del enum Lista , en el que utilizamos un \u00fanico case , pero dando la posibilidad de que el resto de la lista sea nil haci\u00e9ndolo opcional. Definimos el enumerado y tambi\u00e9n la funci\u00f3n suma(lista:) : indirect enum Lista { case nodo ( Int , Lista ?) } func suma ( lista : Lista ) -> Int { switch lista { case let . nodo ( car , cdr ): if ( cdr == nil ) { return car } else { return car + suma ( lista : cdr !) } } } let z : Lista = . nodo ( 20 , . nodo ( 10 , nil )) print ( suma ( lista : z )) /// Devuelve 30 10. Clausuras \u00b6 Ya hemos visto previamente que en Swift las funciones son objetos de primera clase del lenguaje y que es posible definir funciones y pasarlas como par\u00e1metro de otras funciones. Tambi\u00e9n es posible construir clausuras, funciones definidas en el \u00e1mbito de otras funcionas y devueltas como resultados. Veremos primero c\u00f3mo definir de forma compacta funciones que se pasan como par\u00e1metro de otras, utilizando expresiones de clausuras . Y despu\u00e9s veremos c\u00f3mo las clausuras definidas en el interior de otras funciones capturan las variables definidas en el \u00e1mbito de la funci\u00f3n principal. 10.1. Expresiones de clausuras \u00b6 Swift permite definir expresiones compactas con las que construir estas funciones que se pasan como par\u00e1metro de otras funciones. Se denominan expresiones de clausuras ( closure expressions ). Estas expresiones proporcionan optimizaciones de sintaxis para escribir clausuras de forma concisa y clara. Vamos a ver las distintas optimizaciones utilizando como ejemplo el m\u00e9todo sorted(by:) . 10.2. El m\u00e9todo sorted(by:) \u00b6 Tal y como hemos visto anteriormente la biblioteca st\u00e1ndar de Swift define un m\u00e9todo sorted() que devuelve los elementos ordenados de un Array . El array original no se modifica. La comparaci\u00f3n entre los elementos se realiza usando el comparador < . Veamos un ejemplo con un array de cadenas: let estudiantes = [ \"Kofi\" , \"Abena\" , \"Peter\" , \"Kweku\" , \"Akosua\" ] let ordenados = estudiantes . sorted () print ( ordenados ) // Imprime \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\" Esta funci\u00f3n es similar a las que hay en muchos lenguajes. El \u00fanico aspecto funcional es que el array original no se modifica, sino que la ordenaci\u00f3n construye un nuevo array (existe una funci\u00f3n alternativa mutable que se denomina sort() ). Lo interesante relacionado con las clausuras est\u00e1 en la funci\u00f3n sorted(by:) . En esta funci\u00f3n se utiliza una clausura como par\u00e1metro para modificar la comparaci\u00f3n entre elementos y resultar en una ordenaci\u00f3n distinta. Es una de las distintas funciones de orden superior que se definen en las colecciones (m\u00e1s adelante veremos otras). El perfil de la funci\u00f3n sorted(by:) es: func sorted(by areInIncreasingOrder: (Element, Element) -> Bool) El par\u00e1metro es una funci\u00f3n de dos par\u00e1metros (del tipo de los elementos del array) que devuelve un booleano indicando si el primer par\u00e1metro va antes que el segundo en el array ordenado. La clausura de ordenaci\u00f3n devuelve true si el primer valor deber\u00eda aparecer antes del segundo valor y false en otro caso. Por ejemplo, podr\u00edamos ordenar un array de cadenas en orden alfab\u00e9tico inverso. func primeroMayor ( s1 : String , s2 : String ) -> Bool { return s1 > s2 } let estudiantes = [ \"Kofi\" , \"Abena\" , \"Peter\" , \"Kweku\" , \"Akosua\" ] let alreves = estudiantes . sorted ( by : primeroMayor ) print ( alreves ) // Imprime [\"Peter\", \"Kweku\", \"Kofi\", \"Akosua\", \"Abena\"] Si la primera cadena ( s1 ) es mayor que la segunda cadena ( s2 ), la funci\u00f3n primeroMayor(s1:s2:) devolver\u00e1 true , indicando que s1 deber\u00eda aparecer antes que s2 en el array ordenado. La ordenaci\u00f3n mayor o menor se refiere a la ordenaci\u00f3n alfab\u00e9tica, al estar tratando con caracteres. La versi\u00f3n anterior esta es una forma bastante complicada de escribir lo que b\u00e1sicamente es una funci\u00f3n de una \u00fanica expresi\u00f3n ( a > b ). En este ejemplo, ser\u00eda preferible escribir la clausura de ordenaci\u00f3n inline , utilizando la sintaxis de expresiones de clausuras. 10.3. Sintaxis de las expresiones de clausura \u00b6 La sintaxis de las expresiones de clausura tiene la siguiente forma general: { ( <parametros>) -> <tipo devuelto> in <sentencias> } Si aplicamos esta sintaxis al ejemplo anterior: let alreves = estudiantes . sorted ( by : { ( s1 : String , s2 : String ) -> Bool in return s1 > s2 }) Hay que hacer notar que la declaraci\u00f3n de los par\u00e1metros y el tipo devuelto por esta clausura inline es id\u00e9ntica a la declaraci\u00f3n de la funci\u00f3n primeroMayor(s1:s2:) . En ambos casos, se escribe como (s1: String, s2: String) -> Bool . Sin embargo, en la expresi\u00f3n de clausura los par\u00e1metros y el tipo devuelto se escribe dentro de las llaves, no fuera. El comienzo del cuerpo de la clausura se introduce por la palabra clave in . Esta palabra clave indica que la definici\u00f3n de los par\u00e1metros y del tipo devuelto por la clausura ha terminado, y que el cuerpo de la clausura va a comenzar. Como el cuerpo de la clausura es corto, podemos incluso escribirlo en una \u00fanica l\u00ednea: let alreves = estudiantes . sorted ( by : { ( s1 : String , s2 : String ) -> Bool in return s1 > s2 } ) 10.4. Inferencia del tipo por el contexto \u00b6 Como la clausura de ordenaci\u00f3n se pasa como argumento de un m\u00e9todo, Swift puede inferir los tipos de sus par\u00e1metros y el tipo del valor que devuelve. El m\u00e9todo sorted(by:) se llama sobre un array de cadenas, por lo que su argumento debe ser una funci\u00f3n del tipo (String, String) -> Bool . Esto significa que los tipos (String, String) y Bool no necesitan escribirse como parte de la definici\u00f3n de la expresi\u00f3n de la clausura. Debido a que todos los tipos pueden ser inferidos, la flecha del tipo devuelto y los par\u00e9ntesis alrededor de los nombres de los par\u00e1metros tambi\u00e9n pueden omitirse: let alreves = estudiantes . sorted ( by : { s1 , s2 in return s1 > s2 } ) 10.5. Devoluciones impl\u00edcitas en clausuras con una \u00fanica expresi\u00f3n \u00b6 En clausuras con una \u00fanica expresi\u00f3n podemos omitir tambi\u00e9n la palabra clave return : let alreves = estudiantes . sorted ( by : { s1 , s2 in s1 > s2 } ) 10.6. Abreviaturas en los nombres de los argumentos \u00b6 Swift proporciona autom\u00e1ticamente abreviaturas para los nombres de argumentos de las clausuras inline que pueden usarse para referirse a los valores de los argumentos de la clausura usando los nombres $0 , $1 , $2 , etc. Si se usa estos argumentos abreviados, se puede omitir la definici\u00f3n de la lista de los argumentos: let alreves = estudiantes . sorted ( by : { $0 > $1 } ) 10.7. Funciones operadoras \u00b6 Incluso hay una forma aun m\u00e1s corta de escribir la expresi\u00f3n de clausura anterior. Swift define una implementaci\u00f3n espec\u00edfica de cadenas del operador mayor-que ( > ) como una funci\u00f3n que tiene dos par\u00e1metros de tipo String y devuelve un Bool . Esto es exactamente lo que necesita el m\u00e9todo sorted(by:) . Podemos, por tanto, pasar simplemente este operador mayor-que, y Swift inferir\u00e1 que queremos usar el espec\u00edfico de cadenas: let alreves = estudiantes . sorted ( by : > ) 10.8. Clausuras al final \u00b6 Si necesitamos pasar una expresi\u00f3n de clausura a una funci\u00f3n como el argumento final de la clausura y la expresi\u00f3n es larga, puede ser \u00fatil escribirla en su lugar como una clausura al final ( trailing closure ). Una clausura al final es una expresi\u00f3n de clausura que se escribe fuera de (y despu\u00e9s de) los par\u00e9ntesis de la funci\u00f3n a la que se le pasa como par\u00e1metro: let alreves = estudiantes . sorted () { $0 > $1 } Cuando se proporciona una expresi\u00f3n de clausura como \u00fanico argumento de una funci\u00f3n o m\u00e9todo y se pasa como una clausura al final, no es necesario escribir los par\u00e9ntesis tras el nombre de la funci\u00f3n: let alreves = estudiantes . sorted { $0 > $1 } 10.9. Variables capturadas \u00b6 Cuidado Los ejemplos que vamos a ver a continuaci\u00f3n no usan programaci\u00f3n funcional, porque la variable capturada por la clausura es una variable mutable (se ha definido con var y no con let ). Por eso las funciones resultantes no son funciones puras, sino que devuelven un valor distinto cada vez que son invocadas. Son funciones con estado local mutable. Una clausura puede capturar constantes y variables del contexto en el que se define. La clausura puede referirse y modificar esos valores dentro de su cuerpo, incluso si ya no existe el \u00e1mbito ( scope ) original en el que se definieron estas constantes y variables. En Swift, la forma m\u00e1s sencilla de una clausura que captura variables es una funci\u00f3n anidada ( nested function ) escrita en el cuerpo de otra funci\u00f3n. Una funci\u00f3n anidada puede capturar cualquiera de los argumentos de su funci\u00f3n exterior y tambi\u00e9n puede capturar cualquier constante y variable definida dentro de la funci\u00f3n exterior. Veamos un ejemplo similar al que vimos en Scheme. La funci\u00f3n construyeIncrementador contiene una funci\u00f3n anidada llamada incrementador . Esta funci\u00f3n captura dos variables de su contexto: totalAcumulado y cantidad . Despu\u00e9s de capturar estas variables, incrementador es devuelto por construyeIncrementador como una clausura que incrementa totalAcumulado en cantidad cada vez que se llama. func construyeIncrementador ( incremento cantidad : Int ) -> () -> Int { var totalAcumulado = 0 func incrementador () -> Int { totalAcumulado += cantidad return totalAcumulado } return incrementador } El tipo devuelto de construyeIncrementador es () -> Int . Esto significa que devuelve una funci\u00f3n que no tiene par\u00e1metros y que devuelve un Int cada vez que es llamada. La funci\u00f3n construyeIncrementador(incremento:) tiene un \u00fanico par\u00e1metro Int con nombre externo incremento y nombre local cantidad . El argumento pasado a este par\u00e1metro especifica cu\u00e1nto ser\u00e1 incrementado totalAcumulado cada vez que se llama a la funci\u00f3n incrementador devuelta. La funci\u00f3n construyeIncrementador define una funci\u00f3n anidada llamada incrementador , que realiza el incremento real. Esta funci\u00f3n simplemente a\u00f1ade cantidad a totalAcumulado , y devuelve el resultado. Si la consideramos aislada, la funci\u00f3n anidada incrementador() podr\u00eda parecer extra\u00f1a: func incrementador () -> Int { totalAcumulado += cantidad return totalAcumulado } La funci\u00f3n no tiene ning\u00fan par\u00e1metro, y sin embargo se refiere a totalAcumulado y a cantidad en su cuerpo. Lo puede hacer porque ha capturado una referencia a estas variables de la funci\u00f3n de alrededor y las usa en su propio cuerpo. Al capturar estas referencias las variables totalAcumulado y cantidad no desaparecen cuando termina la llamada a construyeIncrementador . Estas variables tambi\u00e9n estar\u00e1n disponibles la pr\u00f3xima vez que se llame la funci\u00f3n incrementador . Aqu\u00ed hay un ejemplo de construyeIncrementador en acci\u00f3n: let incrementaDiez = construyeIncrementador ( incremento : 10 ) Este ejemplo define una constante llamada incrementaDiez para referenciar la funci\u00f3n incrementador que devuelve construyeIncrementador . Esta funci\u00f3n a\u00f1ade 10 a la variable totalAcumulado cada vez que se es llamada. Si llamamos a la funci\u00f3n m\u00e1s de una vez podemos comprobar su conducta en acci\u00f3n: incrementaDiez () // devuelve 10 incrementaDiez () // devuelve 20 incrementaDiez () // devuelve 30 Si creamos un segundo incrementador, tendr\u00e1 sus propias referencias a un variable totalAcumulado nueva, distinta de la anterior: let incrementaSiete = construyeIncrementador ( incremento : 7 ) incrementaSiete () // devuelve 7 Si llamamos a la funci\u00f3n incrementador original ( incrementaDiez ) vemos que sigue incrementando su propia variable totalAcumulado y que no se ve afectada por la variable capturada por incrementaSiete : incrementaDiez () // devuelve 40 10.10. Clausuras con expresiones de clausura \u00b6 En el ejemplo anterior hemos usado una definici\u00f3n interna de una funci\u00f3n para definir la clausura que se devuelve. Lo hemos hecho por claridad, pero no es necesario. Es posible escribir un c\u00f3digo m\u00e1s compacto usando expresiones de clausura. Por ejemplo, la funci\u00f3n construyeSumador() vista en el apartado \"Funciones que devuelven otras funciones\": func construyeSumador10 () -> ( Int ) -> Int { func suma10 ( x : Int ) -> Int { return x + 10 } return suma10 } Una versi\u00f3n de esta misma funci\u00f3n usando una expresi\u00f3n de clausura es la siguiente: func construyeSumador10 () -> ( Int ) -> Int { return { $0 + 10 } } var f = construyeSumador10 () print ( f ( 20 )) // Imprime \"30\" Y lo mismo con la funci\u00f3n constryeIncrementador(incremento:) vista en el apartado anterior: func construyeIncrementador ( incremento cantidad : Int ) -> () -> Int { var totalAcumulado = 0 func incrementador () -> Int { totalAcumulado += cantidad return totalAcumulado } return incrementador } La versi\u00f3n con una expresi\u00f3n de clausura: func construyeIncrementador ( incremento cantidad : Int ) -> () -> Int { var totalAcumulado = 0 return { totalAcumulado += cantidad return totalAcumulado } } let incrementaDiez = construyeIncrementador ( incremento : 10 ) print ( incrementaDiez ()) // Imprime \"10\" print ( incrementaDiez ()) // Imprime \"20\" 10.11. Variables capturadas por clausuras y variables del \u00e1mbito de invocaci\u00f3n \u00b6 Las clasuras usan las variables capturadas y no las variables declaradas en el \u00e1mbito en el que se invoca a la clausura. Vamos a explicarlo con un ejemplo. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 func construyeFunc () -> () -> Int { var x = 0 return { x = x + 1 return x } } let f = construyeFunc () print ( f ()) // -> 1 print ( f ()) // -> 2 func usaFunc ( _ f : () -> Int ) -> Int { var x = 10 return f () } print ( usaFunc ( f )) // -> 3 var x = 100 print ( usaFunc { return x + 10 }) // -> 110 En el c\u00f3digo anterior se resaltan las tres declaraciones de variables x . Es muy importante comprobar el \u00e1mbito en el que se realizan esas declaraciones. La primera declaraci\u00f3n se realiza dentro de la funci\u00f3n construyeFunc() , la segunda dentro de la funci\u00f3n usaFunc() y la tercera en el \u00e1mbito global. En cada caso, la variable se inicializar\u00e1 cuando se ejecute esa l\u00ednea de c\u00f3digo. La funci\u00f3n usaFunc definida en la l\u00ednea 13 recibe una funci\u00f3n f sin par\u00e1metros que devuelve un entero. En el \u00e1mbito local de usaFunc se define la variable local x que tiene el valor 10 antes de invocar a la funci\u00f3n f recibida. \u00bfQu\u00e9 pasa si la funci\u00f3n recibida es una clausura que ha capturado una variable que tambi\u00e9n se llama x ? En el caso de la invocaci\u00f3n a usaFunc que hay en la l\u00ednea 18, la funci\u00f3n f que se pasa como par\u00e1metro es la clausura obtenida en la l\u00ednea 9. Esta clausura ha capturado la variable x definida en la l\u00ednea 2. Y en ese momento esa variable tiene el valor 2. El c\u00f3digo de la clausura es el definido en las l\u00edneas 3 a 6: { x = x + 1 return x } \u00bfA qu\u00e9 variable x se refiere ese c\u00f3digo? \u00bfA la variable capturada que tiene un valor de 2? \u00bfO a la variable en el \u00e1mbito de ejecuci\u00f3n (l\u00ednea 14) que tiene un valor de 10? Si ejecutamos el c\u00f3digo veremos que la expresi\u00f3n devuelve 3. O sea que las clausuras usan siempre las variables capturadas. Podemos comprobarlo tambi\u00e9n en la invocaci\u00f3n de la l\u00ednea 21. Ah\u00ed la clausura que se pasa es una expresi\u00f3n de clausura que captura la variable x definida en la l\u00ednea anterior. Por eso cuando se ejecuta la sentencia se imprime el valor 110 y no el valor 20 . 10.12. Las clausuras son tipos de referencia \u00b6 En el ejemplo anterior, incrementaSiete e incrementaDiez son constantes, pero las clausuras a las que estas constantes se refieren pueden incrementar la variable totalAcumulado que han capturado. Esto es porque funciones y clausuras son tipos referencia. Siempre que asignamos una funci\u00f3n o una clausura a una constante o una variable, estamos realmente estableciendo que la constante o variable es una referencia a la funci\u00f3n o la clausura. En el ejemplo anterior, es la elecci\u00f3n de la clausura a la que referencia incrementaDiez la que es constante, no los contenidos propios de la clausura. Esto tambi\u00e9n significa que si asignamos una clausura a dos constantes o variables distintas, ambas constantes o variables se referir\u00e1n a la misma clausura: let tambienIncrementaDiez = incrementaDiez tambienIncrementaDiez () // devuelve 50 11. Funciones de orden superior \u00b6 Una de las caracter\u00edsticas funcionales que m\u00e1s hemos usado para trabajar con listas en Scheme son las funciones de orden superior como map , filter o foldr . Swift tiene definidas funciones equivalentes para trabajar con colecciones. Se denominan map , filter y reduce . Todas ellas aceptan expresiones de clausura como argumento. 11.1 Map \u00b6 El m\u00e9todo map se define en el protocolo CollectionType y es adoptado por m\u00faltiples estructuras como Array , Dictionary , Set . El perfil del m\u00e9todo map es el siguiente: func map < T >( _ transform : ( Element ) -> T ) -> [ T ] Se trata de un m\u00e9todo gen\u00e9rico (lo veremos m\u00e1s adelante) que recibe como par\u00e1metro una funci\u00f3n unaria (funci\u00f3n de transformaci\u00f3n) del tipo de los elementos de la colecci\u00f3n y que devuelve otro elemento (puede ser del mismo o de distinto tipo que los elementos de la colecci\u00f3n). Devuelve un array que contiene el resultado de aplicar la funci\u00f3n de transformaci\u00f3n a cada elemento del array original. Por ejemplo: let numeros = [ Int ]( 0. .. 5 ) numeros . map { $0 * $0 } // devuelve [0, 1, 4, 9, 16, 25] Otro ejemplo, en el que usamos map para implementar la funci\u00f3n sumaParejas(parejas: [(Int, Int)]) -> [Int] que devuelve recibe el array parejas de tuplas de dos enteros y devuelve un array con el resultado de sumar los dos elementos de cada pareja: func suma ( parejas : [( Int , Int )]) -> [ Int ] { return parejas . map ({( pareja : ( Int , Int )) -> Int in return pareja . 0 + pareja . 1 }) } suma ( parejas :[( 1 , 1 ), ( 2 , 2 ), ( 3 , 3 ), ( 4 , 4 )]) // devuelve [2, 4, 6, 8] Podemos usar en el cuerpo de la expresi\u00f3n de clausura de map una variable capturada. Por ejemplo en la siguiente funci\u00f3n incrementaValores(_:con:) que suma con a todos los n\u00fameros de un array que se le pasa por par\u00e1metro: func incrementa ( valores : [ Int ], con : Int ) -> [ Int ] { return valores . map ({( x : Int ) -> Int in return x + con }) } incrementa ( valores :[ 10 , 20 , 30 ], con : 5 ) // devuelve [15, 25, 35] La versi\u00f3n abreviada de la expresi\u00f3n de clausura es: func incrementa ( valores : [ Int ], con inc : Int ) -> [ Int ] { return valores . map { $0 + inc } } incrementa ( valores : [ 10 , 20 , 30 ], con : 5 ) // devuelve [15, 25, 35] 11.2. Filter \u00b6 La funci\u00f3n filter es tambi\u00e9n igual que la definida en Scheme. Su perfil es: func filter ( _ isIncluded : ( Element ) -> Bool ) -> [ Element ] Recibe una clausura de un argumento que devuelve un booleano. La funci\u00f3n devuelve un array con los elementos de la colecci\u00f3n para los que la clausura devuelve true . Ejemplo: let numeros = [ Int ]( 0. .. 10 ) numeros . filter { $0 % 2 == 0 } // devuelve [0, 2, 4, 6, 8, 10] 11.3. Reduce \u00b6 Similar al foldr de Scheme. Su perfil es el siguiente: func reduce < Result >( _ initialResult : Result , _ nextPartialResult : ( Result , Element ) -> Result ) -> Result Es una funci\u00f3n gen\u00e9rica que devuelve un valor de un tipo gen\u00e9rico (el tipo del resultado que se construye en la funci\u00f3n). Recibe como par\u00e1metro un valor inicial y una funci\u00f3n de plegado que se aplica al resultado anterior y al elemento de la colecci\u00f3n, devolviendo un resultado. El resultado final es el resultado de aplicar la funci\u00f3n de plegado a todos los elementos de la colecci\u00f3n, empezando por el valor inicial. Por ejemplo, podemos usar reduce para sumar todos los n\u00fameros de un array: let numeros = [ Int ]( 0. .. 10 ) numeros . reduce ( 0 , + ) La funci\u00f3n combina los elementos de la colecci\u00f3n usando la funci\u00f3n de combinaci\u00f3n que se pasa como par\u00e1metro. La funci\u00f3n que se pasa como par\u00e1metro recibe dos par\u00e1metros: el primero es el resultado de la combinaci\u00f3n y el segundo se coge de la colecci\u00f3n. Por ejemplo, el siguiente c\u00f3digo usa reduce para sumar la longitud de todas las cadenas de un array: let cadenas = [ \"Patatas\" , \"Arroz\" , \"Huevos\" ] cadenas . reduce ( 0 , {( i : Int , c : String ) -> Int in c . count + i }) // devuelve 18 Es posible simplificar la notaci\u00f3n anterior: cadenas . reduce ( 0 , { $1 . count + $0 }) Tambi\u00e9n se puede utilizar la notaci\u00f3n de clausura al final: cadenas . reduce ( 0 ) { $1 . count + $0 } La combinaci\u00f3n se hace de izquierda a derecha: let cadenas = [ \"Patatas\" , \"Arroz\" , \"Huevos\" ] let cadenas = [ \"Patatas\" , \"Arroz\" , \"Huevos\" ] print ( cadenas . reduce ( \"*\" , { $0 + \"-\" + $1 })) // Imprime \"*-Patatas-Arroz-Huevos\" El primer argumento de la funci\u00f3n de plegado ( $0 ) es el resultado anterior (empieza por \"*\" ) y el segundo argumento ( $1 ) se coge del array de cadenas. 11.4. Combinaci\u00f3n de funciones de orden superior \u00b6 Cuando el resultado de aplicar una funci\u00f3n de orden superior a una colecci\u00f3n es otra colecci\u00f3n es posible aplicar otra funci\u00f3n de orden superior a este resultado. Por ejemplo, la siguiente sentencia devuelve todos los n\u00fameros pares del array inicial elevados al cuadrado: let numeros = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] numeros . filter { $0 % 2 == 0 }. map { $0 * $0 } // Devuelve el array [4,16,36,64,100] Y la siguiente devuelve la suma n\u00fameros mayores de 100: let numeros = [ 103 , 2 , 330 , 42 , 532 , 6 , 125 ] numeros . filter { $0 >= 100 }. reduce ( 0 , + ) // Devuelve 1090 12. Gen\u00e9ricos \u00b6 Empecemos con un ejemplo sencillo. Supongamos la siguiente funci\u00f3n intercambia(_:) que recibe una tupla (Int, String) y devuelve una tupla (String, Int) con los valores intercambiados. func intercambia ( _ tupla : ( Int , String )) -> ( String , Int ) { let tuplaNueva = ( tupla . 1 , tupla . 0 ) return tuplaNueva } let tupla = ( 10 , \"Hola\" ) intercambia ( tupla ) // devuelve (\"Hola\", 10) La funci\u00f3n es interesante, pero s\u00f3lo recibe tuplas cuya primera componente es un Int y su segunda componente es un String . Supongamos que queremos hacer la misma funci\u00f3n para intercambiar elementos de una tupla (Int, Int) . Tendr\u00edamos que usar el mismo c\u00f3digo, pero cambiando los tipos: func intercambia ( _ tupla : ( Int , Int )) -> ( Int , Int ) { let tuplaNueva = ( tupla . 1 , tupla . 0 ) return tuplaNueva } let tupla = ( 10 , 20 ) intercambia ( tupla ) // devuelve (20, 10) El c\u00f3digo es el mismo, lo \u00fanico distinto son los tipos. \u00bfPodr\u00edamos generalizar las funciones anteriores para hacer que el c\u00f3digo pueda trabajar con cualquier tipo? La respuesta es s\u00ed, usando funci\u00f3n gen\u00e9rica : func intercambia < A , B >( _ tupla : ( A , B )) -> ( B , A ) { let tuplaNueva = ( tupla . 1 , tupla . 0 ) return tuplaNueva } El cuerpo de la funci\u00f3n es id\u00e9ntico a la funci\u00f3n anterior. La diferencia es que en la versi\u00f3n gen\u00e9rica se usan placeholders (los s\u00edmbolos A y B ) en lugar de tipos concretos. Son tipos gen\u00e9ricos, que se definen usando un identificador entre s\u00edmbolos de < y > . Los tipos reales que se van a usar en la funci\u00f3n se determinan en cada invocaci\u00f3n a la funci\u00f3n, dependiendo del tipo del par\u00e1metro que se utiliza en la llamada: let tupla = ( 10 , \"Hola\" ) intercambia ( tupla ) // devuelve (\"Hola\", 10) let tupla2 = ( 10 , 20 ) intercambia ( tupla2 ) // devuelve (10, 20) let tupla3 = ( true , 10.5 ) intercambia ( tupla3 ) // devuelve (10.5, true) En el primer ejemplo, los tipos A y B se infieren como Int y String . En el segundo ejemplo como Int e Int . Y en el tercero como Bool y Double . Los tipos gen\u00e9ricos se pueden usar en la definici\u00f3n de todos los elementos de Swift: funciones, enums, estructuras, clases, protocolos o extensiones. Terminamos con un ejemplo en el que incluimos muchos conceptos vistos en este tema. Se trata de la implementaci\u00f3n en Swift de listas al estilo Scheme, con las funciones car , cdr y vacia usando un enum recursivo con un tipo gen\u00e9rico que permite generalizar el tipo de elementos de la lista. indirect enum Lista < T > { case vacia case nodo ( T , Lista < T >) } func car < T >( _ lista : Lista < T >) -> T ? { switch lista { case let . nodo ( primero , _ ): return primero case . vacia : return nil } } func cdr < T >( _ lista : Lista < T >) -> Lista < T >? { switch lista { case let . nodo ( _ , resto ): return resto case . vacia : return nil } } func vacia < T >( _ lista : Lista < T >) -> Bool { switch lista { case . vacia : return true default : return false } } let lista : Lista = . nodo ( 20 , . nodo ( 30 , . nodo ( 40 , . vacia ))) print ( car ( lista ) ! ) // Imprime 20 print ( car ( cdr ( lista ) ! ) ! ) // Imprime 30 print ( car ( cdr ( cdr ( lista ) ! ) ! ) ! ) // Imprime 40 print ( vacia ( cdr ( cdr ( cdr ( lista ) ! ) ! ) ! )) // Imprime true 13. Bibliograf\u00eda \u00b6 Swift Language Guide The Basics Collection Types Functions Closures Enumerations Generics Biblioteca est\u00e1ndar de Swift Lenguajes y Paradigmas de Programaci\u00f3n, curso 2021\u201322 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Domingo Gallardo, Cristina Pomares, Antonio Bot\u00eda, Francisco Mart\u00ednez","title":"Tema 5: Programaci\u00f3n Funcional con Swift"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#tema-5-programacion-funcional-con-swift","text":"","title":"Tema 5: Programaci\u00f3n Funcional con Swift"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#1-introduccion","text":"Te recomendamos que leas el seminario de Swift en el que se introduce el lenguaje y se explica c\u00f3mo ejecutar programas en este lenguaje: Seminario de Swift","title":"1. Introducci\u00f3n"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#12-conceptos-fundamentales-de-programacion-funcional","text":"Vamos a repasar en este tema c\u00f3mo se implementan en Swift conceptos principalmente funcionales como: Valores inmutables Tipos de datos recursivos Funciones como objetos de primera clase y clasuras Funciones de orden superior Repasamos r\u00e1pidamente algunos conceptos b\u00e1sicos de programaci\u00f3n funcional, vistos en los primeros temas de la asignatura. Programaci\u00f3n Funcional: La Programaci\u00f3n Funcional es un paradigma de programaci\u00f3n que trata la computaci\u00f3n como la evaluaci\u00f3n de funciones matem\u00e1ticas y que evita cambios de estado y datos mutables. Funciones matem\u00e1ticas o puras: Las funciones matem\u00e1ticas tienen la caracter\u00edstica de que cuando las invocas con el mismo argumento siempre te devolver\u00e1n el mismo resultado. Funciones como objetos de primera clase: En programaci\u00f3n funcional, las funciones son objetos de primera clase del lenguaje, similares a enteros o strings . Podemos pasar funciones como argumentos en las denominadas funciones de orden superior o devolver funciones creadas en tiempo de ejecuci\u00f3n (clausuras).","title":"1.2. Conceptos fundamentales de Programaci\u00f3n Funcional"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#13-caracteristicas-basicas-de-swift","text":"Swift es un lenguaje principalmente imperativo, pero en su dise\u00f1o se han introducido conceptos modernos de programaci\u00f3n funcional, extra\u00eddos de lenguajes como Rust o Haskell. Por ello se puede considerar un lenguaje multi-paradigma , en el que se puede definir c\u00f3digo funcional que se puede ejecutar junto con c\u00f3digo imperativo. Como dice su creador Chris Lattner : El lenguaje Swift es el resultado de un esfuerzo incansable de un equipo de expertos en lenguajes, gur\u00fas de documentaci\u00f3n, ninjas de optimizaci\u00f3n de compiladores [..]. Por supuesto, tambi\u00e9n se benefici\u00f3 enormemente de las experiencias ganadas en muchos otros lenguajes, tomando ideas de Objective-C, Rust, Haskell, Ruby, Python, C#, CLU, y demasiados otros para ser enumerados.","title":"1.3. Caracter\u00edsticas b\u00e1sicas de Swift"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#2-inmutabilidad","text":"Una de las caracter\u00edsticas funcionales importantes de Swift es el \u00e9nfasis en la inmutabilidad para reforzar la seguridad del lenguaje. Hemos visto que la palabra clave let permite definir constantes y que Swift recomienda su uso si el valor que definimos es un valor que no va a ser modificado. El valor asignado a una constante let puede no conocerse en tiempo de compilaci\u00f3n, sino que puede ser obtenido en tiempo de ejecuci\u00f3n como un valor devuelto por una funci\u00f3n: let respuesta : String = respuestaUsuario . respuesta () Al declarar una variable como let se bloquea su contenido y no se permite su modificaci\u00f3n. Una de las ventajas del paradigma funcional y de la inmutabilidad es que garantiza que el c\u00f3digo que escribimos no tiene efectos laterales y puede ser ejecutado sin problemas en entornos multi-procesador o multi-hilo.","title":"2. Inmutabilidad"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#21-creacion-de-nuevas-estructuras-y-mutacion","text":"En la biblioteca est\u00e1ndar de Swift existen una gran cantidad de estructuras (como Int , Double , Bool , String , Array , Dictionary , etc.) que tienen dos tipos de m\u00e9todos: m\u00e9todos que mutan la estructura y m\u00e9todos que devuelven una nueva estructura. Cuando estemos escribiendo c\u00f3digo con estilo funcional deberemos utilizar siempre estos \u00faltimos m\u00e9todos, los que construyen estructuras nuevas. Por ejemplo, en el struct Array se define el m\u00e9todo sort y el m\u00e9todo sorted . El primero ordena el array con mutaci\u00f3n y el segundo devuelve una copia ordenada, sin modificar el array original. En el siguiente c\u00f3digo no se modifica el array original, sino que se construye un array nuevo ordenado: // C\u00f3digo recomendable en programaci\u00f3n funcional // porque utiliza el m\u00e9todo sorted que devuelve una // copia del array original let miArray = [ 10 , - 1 , 3 , 80 ] let arrayOrdenado = miArray . sorted () print ( miArray ) print ( arrayOrdenado ) // Imprime: // [10, -1, 3, 80] // [-1, 3, 10, 80] Este c\u00f3digo es el recomendable cuando estemos escribiendo c\u00f3digo con un estilo de programaci\u00f3n funcional. Sin embargo, el siguiente c\u00f3digo es imperativo y utiliza la mutaci\u00f3n del array original: // C\u00f3digo no recomendable en programaci\u00f3n funcional // porque utiliza el m\u00e9todo sort que muta el array original var miArray = [ 10 , - 1 , 3 , 80 ] miArray . sort () print ( miArray ) // Imprime: // [-1, 3, 10, 80] Otro ejemplo es en la forma de a\u00f1adir elementos a un array. Podemos hacerlo con un enfoque funcional, usando el operador + que construye un array nuevo: // C\u00f3digo recomendable en programaci\u00f3n funcional let miArray = [ 10 , - 1 , 3 , 80 ] let array2 = miArray + [ 100 ] print ( array2 ) // Imprime: // [10, -1, 3, 80, 100] Y podemos hacerlo usando un enfoque imperativo, con el m\u00e9todo append : // C\u00f3digo no recomendable en programaci\u00f3n funcional var miArray = [ 10 , - 1 , 3 , 80 ] miArray . append ( 100 ) print ( miArray ) // Imprime: // [10, -1, 3, 80, 100] Importante En programaci\u00f3n funcional debemos usar siempre los m\u00e9todos que no modifican las estructuras . As\u00ed evitaremos los efectos laterales y nuestro c\u00f3digo funcionar\u00e1 correctamente en entornos multi-hilo. Cuando definimos una variable de tipo let el valor que se asigne a esa variable se convierte en inmutable. Si se trata de una estructura o una clase con m\u00e9todos mutables el compilador dar\u00e1 un error. Por ejemplo: let miArray = [ 10 , - 1 , 3 , 80 ] miArray . append ( 100 ) // error: cannot use mutating member on immutable value: 'miArray' is a 'let' constant Otro ejemplo. El m\u00e9todo append(_:) de un String es un m\u00e9todo mutable. Si definimos una cadena con let no podremos modificarla y dar\u00eda error el siguiente c\u00f3digo: var cadenaMutable = \"Hola\" let cadenaInmutable = \"Adios\" cadenaMutable . append ( cadenaInmutable ) // cadenaMutable es \"HolaAdios\" cadenaInmutable . append ( \"Adios\" ) // error: cannot use mutating member on immutable value: 'cadenaInmutable' is a 'let' constant","title":"2.1. Creaci\u00f3n de nuevas estructuras y mutaci\u00f3n"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#3-funciones","text":"","title":"3. Funciones"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#31-definicion-de-una-funcion-en-swift","text":"Para definir una funci\u00f3n en Swift se debe usar la palabra func , definir el nombre de la funci\u00f3n, sus par\u00e1metros y el tipo de vuelto. El valor devuelto por la funci\u00f3n se debe devolver usando la palabra return . C\u00f3digo de la funci\u00f3n saluda(nombre:) : func saluda ( nombre : String ) -> String { let saludo = \"Hola, \" + nombre + \"!\" return saludo } Para invocar a la funci\u00f3n saluda(nombre:) : print ( saluda ( nombre : \"Ana\" )) print ( saluda ( nombre : \"Pedro\" )) // Imprime \"Hola, Ana!\" // Imprime \"Hola, Pedro!\"","title":"3.1. Definici\u00f3n de una funci\u00f3n en Swift"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#32-etiquetas-de-argumentos-y-nombres-de-parametros","text":"Cada par\u00e1metro de una funci\u00f3n tiene una etiqueta del argumento y un nombre de par\u00e1metro. La etiqueta del argumento se usa cuando se llama a la funci\u00f3n y el nombre del par\u00e1metro se usa internamente en su implementaci\u00f3n. Por defecto, los par\u00e1metros usan su nombre de par\u00e1metro como etiqueta del argumento: func unaFuncion ( primerNombreParametro : Int , segundoNombreParametro : Int ) { // En el cuerpo de la funci\u00f3n, primerNombreParametro y // segundoNombreParametro se refieren a los valores de los // argumentos del primer y el segundo par\u00e1metro } unaFuncion ( primerNombreParametro : 1 , segundoNombreParametro : 2 ) Es posible hacer distintos la etiqueta del argumento del nombre del par\u00e1metro: func saluda ( nombre : String , de ciudad : String ) -> String { return \"Hola \\( nombre ) ! Me alegro de que hayas podido visitarnos desde \\( ciudad ) .\" } print ( saluda ( nombre : \"Bill\" , de : \"Cupertino\" )) // Imprime \"Hola Bill! Me alegro de que hayas podido visitarnos desde Cupertino.\" En este caso el nombre externo del par\u00e1metro (el que usamos al invocar la funci\u00f3n) es de y el nombre interno (el que se usa en el cuerpo de la funci\u00f3n) es ciudad . Otro ejemplo, la siguiente funci\u00f3n concatena(palabra:con:) : func concatena ( palabra str1 : String , con str2 : String ) -> String { return str1 + str2 } print ( concatena ( palabra : \"Hola\" , con : \"adios\" )) Si no se quiere una etiqueta del argumento para un par\u00e1metro, se puede escribir un subrayado ( _ ) en lugar de una etiqueta del argumento expl\u00edcita para ese par\u00e1metro. Esto nos permite llamar a la funci\u00f3n sin usar un nombre de par\u00e1metro. Por ejemplo, la funci\u00f3n max(_:_:) y la funci\u00f3n divide(_:entre:) : func max ( _ x : Int , _ y : Int ) -> Int { if x > y { return x } else { return y } } print ( max ( 10 , 3 )) func divide ( _ x : Double , entre y : Double ) -> Double { return x / y } print ( divide ( 30 , entre : 4 )) El perfil de la funci\u00f3n est\u00e1 formado por el nombre de la funci\u00f3n, las etiquetas de los argumentos y el tipo devuelto por la funci\u00f3n. En la documentaci\u00f3n de las funciones usaremos las etiquetas separadas por dos puntos. Por ejemplo, las funciones anteriores son max(_:_:) y divide(_:entre:) . Las etiquetas de los argumentos son parte del nombre de la funci\u00f3n. Es posible definir funciones distintas con s\u00f3lo distintos nombres de argumentos, como las siguientes funciones mitad(par:) y mitad(impar:) : func mitad ( par : Int ) -> Int { return par / 2 } func mitad ( impar : Int ) -> Int { return ( impar + 1 ) / 2 } print ( mitad ( par : 8 )) // Imprime 4 print ( mitad ( impar : 9 )) // Imprime 5","title":"3.2. Etiquetas de argumentos y nombres de par\u00e1metros"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#33-parametros-y-valores-devueltos","text":"Es posible definir funciones sin par\u00e1metros: func diHolaMundo () -> String { return \"hola, mundo\" } print ( diHolaMundo ()) // Imprime \"hola, mundo\" Podemos definir funciones sin valor devuelto. Por ejemplo, la siguiente funci\u00f3n diAdios(nombre:) . No hay que escribir flecha con el tipo devuelto. Cuidado, no ser\u00eda propiamente programaci\u00f3n funcional. func diAdios ( nombre : String ) { print ( \"Adi\u00f3s, \\( nombre ) !\" ) } diAdios ( nombre : \"Dave\" ) // Imprime \"Adi\u00f3s, Dave!\" Es posible devolver m\u00faltiples valores, construyendo una tupla. Por ejemplo, la siguiente funci\u00f3n ecuacion(a:b:c:) calcula las dos soluciones de una ecuaci\u00f3n de segundo grado: func ecuacion ( a : Double , b : Double , c : Double ) -> ( pos : Double , neg : Double ) { let discriminante = b * b - 4 * a * c let raizPositiva = ( - b + discriminante . squareRoot ()) / 2 * a let raizNegativa = ( - b - discriminante . squareRoot ()) / 2 * a return ( raizPositiva , raizNegativa ) } Recordemos (consultar el seminario de Swift) que podemos acceder a los valores de la tupla por posici\u00f3n: let resultado = ecuacion ( a : 1 , b : - 5 , c : 6 ) print ( \"Las ra\u00edces de la ecuaci\u00f3n son \\( resultado . 0 ) y \\( resultado . 1 ) \" ) //Imprime \"Las ra\u00edces de la ecuaci\u00f3n son 3.0 y 2.0\" En este caso en la definici\u00f3n del tipo devuelto por la funci\u00f3n estamos etiquetando esos valores con las etiquetas pos y neg . De esta forma podemos acceder a los componentes de la tupla usando esas etiquetas definidas: let resultado = ecuacion ( a : 1 , b : - 5 , c : 6 ) print ( \"Las ra\u00edces de la ecuaci\u00f3n son \\( resultado . pos ) y \\( resultado . neg ) \" ) //Imprime \"Las ra\u00edces de la ecuaci\u00f3n son 3.0 y 2.0\"","title":"3.3. Par\u00e1metros y valores devueltos"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#4-recursion","text":"Veamos algunos ejemplos de funciones recursivas en Swift. Primero una funci\u00f3n suma(hasta:) que devuelve la suma desde 0 hasta el n\u00famero que le pasamos como par\u00e1metro. func suma ( hasta x : Int ) -> Int { if x == 0 { return 0 } else { return x + suma ( hasta : x - 1 ) } } print ( suma ( hasta : 5 )) // Imprime \"15\" Tambi\u00e9n es posible definir recursiones que recorran arrays de una forma similar a c\u00f3mo trabaj\u00e1bamos en Scheme. Los arrays en Swift no funcionan exactamente como las listas de Scheme (no son listas de parejas), pero podemos obtener el primer elemento y el resto de la siguiente forma. let a = [ 10 , 20 , 30 , 40 , 50 , 60 ] let primero = a [ 0 ] let resto = Array ( a . dropFirst ()) En primero se guarda el n\u00famero 10. En resto se guarda el Array del 20 al 60. El m\u00e9todo dropFirst devuelve una ArraySlice , que es una vista de un rango de elementos del array, en este caso el que va desde la posici\u00f3n 1 hasta la 5 (la posici\u00f3n inicial de un array es la 0). Es necesario el constructor Array para convertir ese ArraySlice en un Array . Usando las instrucciones anteriores podemos definir la funci\u00f3n recursiva que suma los valores de un Array de la siguiente forma similar a c\u00f3mo lo hac\u00edamos en Scheme: func sumaValores ( _ valores : [ Int ]) -> Int { if ( valores . isEmpty ) { return 0 } else { let primero = valores [ 0 ] let resto = Array ( valores . dropFirst ()) return primero + sumaValores ( resto ) } } print ( sumaValores ([ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 ])) // Imprime \"36\" Un \u00faltimo ejemplo es la siguiente funci\u00f3n minMax(array:) que devuelve el n\u00famero m\u00e1s peque\u00f1o y m\u00e1s grande de un array de enteros: func minMax ( array : [ Int ]) -> ( min : Int , max : Int ) { if ( array . count == 1 ) { return ( array [ 0 ], array [ 0 ]) } else { let primero = array [ 0 ] let resto = Array ( array . dropFirst ()) // Llamada recursiva que devuelve el m\u00ednimo y el m\u00e1ximo del // resto del array let minMaxResto = minMax ( array : resto ) let minimo = min ( primero , minMaxResto . min ) let maximo = max ( primero , minMaxResto . max ) return ( minimo , maximo ) } } let limites = minMax ( array : [ 8 , - 6 , 2 , 100 , 3 , 71 ]) print ( \"El m\u00ednimo es \\( limites . min ) y el m\u00e1ximo es \\( limites . max ) \" ) // Imprime \"El m\u00edmimo es -6 y el m\u00e1ximo es 100\" En este ejemplo nos apartamos un poco de la soluci\u00f3n vista en Scheme porque permitimos pasos de ejecuci\u00f3n que inicializan variables. Pero no nos salimos del paradigma funcional, porque todas son variables inmutables definidas con let .","title":"4. Recursi\u00f3n"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#5-tipos-funcion","text":"En Swift las funciones son objetos de primera clase y podemos asignarlas a variables, pasarlas como par\u00e1metro o devolverlas como resultado de otra funci\u00f3n. Al ser un lenguaje fuertemente tipado, las variables, par\u00e1metros o resultados deben ser objetos de tipo funci\u00f3n. Cada funci\u00f3n tiene un tipo espec\u00edfico, definido por el tipo de sus par\u00e1metros y el tipo del valor devuelto. func sumaDosInts ( a : Int , b : Int ) -> Int { return a + b } func multiplicaDosInts ( a : Int , b : Int ) -> Int { return a * b } El tipo de estas funciones es (Int, Int) -> Int , que se puede leer como: \"Un tipo funci\u00f3n que tiene dos par\u00e1metros, ambos de tipo Int y que devuelve un valor de tipo Int \". En Swift se puede usar un tipo funci\u00f3n de la misma forma que cualquier otro tipo, por ejemplo asignando la funci\u00f3n a una variable: var f = sumaDosInts print ( f ( 2 , 3 )) // Imprime \"5\" f = multiplicaDosInts print ( f ( 2 , 3 )) // Imprime \"6\" La variable f es una variable de tipo (Int, Int) -> Int , o sea, una variable que contiene funciones de dos argumentos Int que devuelven un Int . Nota Habr\u00e1s notado que al invocar a f no se ponen etiquetas en los argumentos. De hecho, si las pusi\u00e9ramos el compilador de Swift se quejar\u00eda: print ( f ( a : 2 , b : 3 )) //error: extraneous argument labels 'a:b:' in call Esto es debido a que al ser f una variable se le puede asignar cualquier funci\u00f3n que tenga el perfil (Int, Int) -> Int sin tener en cuenta las etiquetas de los argumentos.","title":"5. Tipos funci\u00f3n"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#51-funciones-que-reciben-otras-funciones","text":"Podemos usar un tipo funci\u00f3n en par\u00e1metros de otras funciones: func printResultado ( funcion : ( Int , Int ) -> Int , _ a : Int , _ b : Int ) { print ( \"Resultado: \\( funcion ( a , b )) \" ) } printResultado ( funcion : sumaDosInts , 3 , 5 ) // Prints \"Resultado: 8\" La funci\u00f3n printResultado(funcion:_:_:) toma como primer par\u00e1metro otra funci\u00f3n que recibe dos Int y devuelve un Int , y como segundo y tercer par\u00e1metro dos Int . Y en el cuerpo llama a la funci\u00f3n que se pasa como par\u00e1metro con los argumentos a y b . Veamos otro ejemplo, que ya vimos en Scheme. Supongamos que queremos calcular el sumatorio desde a hasta b en el que aplicamos una funci\u00f3n f a cada n\u00famero que sumamos: sumatorio(a, b, f) = f(a) + f(a+1) + f(a+2) + ... + f(b) Recordamos que se resuelve con la siguiente recursi\u00f3n: sumatorio(a, b, f) = f(a) + sumatorio(a+1, b, f) sumatorio(a, b, f) = 0 si a > b Veamos c\u00f3mo se implementa en Swift: func sumatorio ( desde a : Int , hasta b : Int , func f : ( Int ) -> Int ) -> Int { if a > b { return 0 } else { return f ( a ) + sumatorio ( desde : a + 1 , hasta : b , func : f ) } } func identidad ( _ x : Int ) -> Int { return x } func doble ( _ x : Int ) -> Int { return x + x } func cuadrado ( _ x : Int ) -> Int { return x * x } print ( sumatorio ( desde : 0 , hasta : 10 , func : identidad )) // Imprime 55 print ( sumatorio ( desde : 0 , hasta : 10 , func : doble )) // Imprime 110 print ( sumatorio ( desde : 0 , hasta : 10 , func : cuadrado )) // Imprime 385","title":"5.1. Funciones que reciben otras funciones"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#52-funciones-en-estructuras","text":"Como cualquier otro tipo Las funciones pueden tambi\u00e9n incluirse en estructuras de datos compuestas, como arrays: var funciones = [ identidad , doble , cuadrado ] print ( funciones [ 0 ]( 10 )) // 10 print ( funciones [ 1 ]( 10 )) // 20 print ( funciones [ 2 ]( 10 )) // 100 El tipo de la variable funciones ser\u00eda [(Int) -> Int] . Al ser Swift fuertemente tipado, no podr\u00edamos hacer un array con distintos tipos de funciones. Por ejemplo el siguiente c\u00f3digo dar\u00eda un error: func suma ( _ x : Int , _ y : Int ) -> Int { return x + y } // La siguiente l\u00ednea genera un error var misFunciones = [ doble , cuadrado , suma ] // error: heterogenous collection literal could only be inferred to // '[Any]'; add explicit type annotation if this is intentional","title":"5.2. Funciones en estructuras"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#53-funciones-que-devuelven-otras-funciones","text":"Por \u00faltimo, veamos un ejemplo de funciones que devuelven otras funciones. Es un ejemplo sencillo, una funci\u00f3n que devuelve otra que suma 10: func construyeSumador10 () -> ( Int ) -> Int { func suma10 ( x : Int ) -> Int { return x + 10 } return suma10 } var g = construyeSumador10 () print ( g ( 20 )) // Imprime 30 La funci\u00f3n devuelta por construyeSumador10() es una funci\u00f3n con el tipo (Int) -> Int (recibe un par\u00e1metro entero y devuelve un entero). En la llamada a construyeSumador10() se crea esa funci\u00f3n y se asigna a la variable g . Estas funciones devueltas se denominan clausuras . M\u00e1s adelante hablaremos algo m\u00e1s de ellas. Veremos tambi\u00e9n m\u00e1s adelante que es posible usar expresiones de clausura que construyen clausuras an\u00f3nimas. Podemos modificar el ejemplo anterior, haciendo que la funci\u00f3n construyeSumador reciba el n\u00famero a sumar como par\u00e1metro: func construyeSumador ( inc : Int ) -> ( Int ) -> Int { func suma ( x : Int ) -> Int { return x + inc } return suma } var f2 = construyeSumador ( inc : 10 ) var f3 = construyeSumador ( inc : 100 ) print ( f2 ( 20 )) // Imprime \"30\" print ( f3 ( 20 )) // Imprime \"120\" Invocamos dos veces a construyeSumador(inc:) y guardamos las clausuras construidas en las variables f2 y f3 . En f2 se guarda una funci\u00f3n que suma 10 a su argumento y en f3 otra que suma 100 .","title":"5.3 Funciones que devuelven otras funciones"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#6-tipos","text":"Entre las ventajas del uso de tipos est\u00e1 la detecci\u00f3n de errores en los programas en tiempo de compilaci\u00f3n o las ayudas del entorno de desarrollo para autocompletar c\u00f3digo. Entre los inconvenientes se encuentra la necesidad de ser m\u00e1s estrictos a la hora de definir los par\u00e1metros y los valores devueltos por las funciones, lo que impide la flexibilidad de Scheme. Se utilizan tipos para definir los posibles valores de: variables par\u00e1metros de funciones valores devueltos por funciones Tal y como hemos visto cuando hemos comentado que Swift es fuertemente tipado las definiciones de tipos van precedidas de dos puntos en las variables y par\u00e1metros, o de una flecha ( -> ) en la definici\u00f3n de los tipos de los valores devueltos por una funci\u00f3n: let valorDouble : Double = 3.0 let unaCadena : String = \"Hola\" func calculaEstadisticas ( valores : Array < Int >) -> ( min : Int , max : Int , media : Int ) { ... } En Swift existen dos clases de tipos: tipos con nombre y tipos compuestos.","title":"6. Tipos"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#61-tipos-con-nombre","text":"Un tipo con nombre es un tipo al que podemos dar un nombre determinado cuando se define. Por ejemplo, al definir un nombre de una clase o de un enumerado estamos tambi\u00e9n definiendo un nombre de un tipo. En Swift es posible definir los siguientes tipos con nombre: nombres de clases nombres de estructuras nombres de enumeraciones nombres de protocolos Por ejemplo, instancias de una clase definida por el usuario llamada MiClase tienen el tipo MiClase . Adem\u00e1s de los tipos definidos por el usuario, la biblioteca est\u00e1ndar de Swift tiene un gran n\u00famero de tipos predefinidos. A diferencia de otros lenguajes, estos tipos no son parte del propio lenguaje sino que se definen en su mayor\u00eda como estructuras implementadas en esta biblioteca est\u00e1ndar. Por ejemplo, arrays, diccionarios o incluso los tipos m\u00e1s b\u00e1sicos como String o Int est\u00e1n construidos en esa biblioteca. La implementaci\u00f3n de estos elementos est\u00e1 disponible en abierto en el sitio GitHub de Swift .","title":"6.1. Tipos con nombre"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#62-tipos-compuestos","text":"Los tipos compuestos son tipos sin nombre. En Swift se definen dos: tuplas y tipos funci\u00f3n. Un tipo compuesto puede tener tipos con nombre y otros tipos compuestos. Por ejemplo la tupla (Int, (Int, Int)) contiene dos elementos: el primero es el tipo con nombre Int y el segundo el tipo compuesto que define la tupla (Int, Int) . Los tipos funci\u00f3n los hemos visto previamente. let tupla : ( Int , Int , String ) = ( 2 , 3 , \"Hola\" ) let otraTupla : ( Int , Int , String ) = ( 5 , 8 , \"Adios\" ) func sumaTupla ( tupla t1 : ( Int , Int ), con t2 : ( Int , Int )) -> ( Int , Int ) { return ( t1 . 0 + t2 . 0 , t1 . 1 + t2 . 1 ) } print ( sumaTupla ( tupla : ( tupla . 0 , tupla . 1 ), con : ( otraTupla . 0 , otraTupla . 1 ))) // Imprime (7, 11)","title":"6.2. Tipos compuestos"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#63-tipos-valor-y-tipos-referencia","text":"En Swift existen dos tipos de construcciones que forman la base de la programaci\u00f3n orientada a objetos: las estructuras ( structs ) y las clases. En el tema siguiente hablaremos sobre ello. En la biblioteca est\u00e1ndar de Swift la mayor parte de los tipos definidos (como Int , Double , Bool , String , Array , Dictionary , etc.) son estructuras, no clases. Una de las diferencias m\u00e1s importantes entre estructuras y clases es su comportamiento en una asignaci\u00f3n: las estructuras tienen una sem\u00e1ntica de copia (son tipos valor) y las clases tienen una sem\u00e1ntica de referencia (son tipos referencia). Un tipo valor es un tipo que tiene sem\u00e1ntica de copia en las asignaciones y cuando se pasan como par\u00e1metro en llamadas a funciones. Los tipos valor son muy \u00fatiles porque evitan los efectos laterales en los programas y simplifican el comportamiento del compilador en la gesti\u00f3n de memoria. Al no existir referencias, se simplifica enormemente la gesti\u00f3n de memoria de estas estructuras. No es necesario llevar la cuenta de qu\u00e9 referencias apuntan a un determinado valor, sino que se puede liberar la memoria en cuanto se elimina el \u00e1mbito actual. Frente a un tipo valor, un tipo de referencia es aquel en los que los valores se asignan a variables con una sem\u00e1ntica de referencia. Cuando se realizan varias asignaciones de una misma instancia a distintas variables todas ellas guardan una referencia a la misma instancia. Si la instancia se modifica, todas las variables reflejar\u00e1n el nuevo valor. Cuando veamos las clases en el pr\u00f3ximo tema veremos algunos ejemplos. Veamos ahora algunos ejemplos de copia por valor en estructuras. Por ejemplo, si asignamos una cadena a otra, se realiza una copia: var str1 = \"Hola\" var str2 = str1 str1 . append ( \"Adios\" ) print ( str1 ) // Imprime \"HolaAdios\" print ( str2 ) // Imprime \"Hola\" Los arrays tambi\u00e9n son estructuras y, por tanto, tambi\u00e9n tienen sem\u00e1ntica de copia: var array1 = [ 1 , 2 , 3 , 4 ] var array2 = array1 array1 [ 0 ] = 10 print ( array1 ) // [10, 2, 3, 4] print ( array2 ) // [1, 2, 3, 4] A diferencia de otros lenguajes como Java, los par\u00e1metros de una funci\u00f3n siempre son inmutables y se pasan por copia, para reforzar el car\u00e1cter funcional de las funciones. Por ejemplo, es incorrecto escribir lo siguiente: func ponCero(array: [Int], pos: Int) { array[pos] = 0 // error: cannot assign through subscript: 'array' is a 'let' constant } Se podr\u00eda pensar que es muy costoso copiar un array entero. Por ejemplo, si asignamos o pasamos como par\u00e1metro un array de 1000 elementos. Pero no es as\u00ed. El compilador de Swift optimiza estas sentencias y s\u00f3lo realiza la copia en el momento en que hay una modificaci\u00f3n de una de las variables que comparten el array. Es lo que se llama copy on write .","title":"6.3. Tipos valor y tipos referencia"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#7-enumeraciones","text":"Las enumeraciones definen un tipo con un valor restringido de posibles valores: enum Direccion { case norte case sur case este case oeste } Cualquier variable del tipo Direccion solo puede tener uno de los cuatro valores definidos. Se obtiene el valor escribiendo el nombre de la enumeraci\u00f3n, un punto y el valor definido. Si el tipo de enumeraci\u00f3n se puede inferir no es necesario escribirlo. let hemosGirado = true var direccionActual = Direccion . norte if hemosGirado { direccionActual = . sur } En sentencias switch: let direccionAIr = Direccion . sur switch direccionAIr { case . norte : print ( \"Nos vamos al norte\" ) case . sur : print ( \"Cuidado con los pinguinos\" ) case . este : print ( \"Donde nace el sol\" ) case . oeste : print ( \"Donde el cielo es azul\" ) } // Imprime \"Cuidado con los pinguinos\" Otro ejemplo: enum Planeta { case mercurio , venus , tierra , marte , jupiter , saturno , urano , neptuno } Y, por \u00faltimo, es m\u00e1s correcto definir el resultado de una quiniela con un enumerado en lugar de con un String : enum Quiniela { case uno , equis , dos }","title":"7. Enumeraciones"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#71-valores-brutos-de-enumeraciones","text":"Es posible asignar a las constantes del enumerado un valor concreto de un tipo subyacente, por ejemplo enteros: enum Quiniela : Int { case uno = 1 , equis = 0 , dos = 2 } Se puede obtener el valor bruto a partir del propio tipo o de una variable del tipo, usando rawValue : // Obtenemos el valor bruto a partir del tipo let valorEquis : Int = Quiniela . equis . rawValue // Obtenemos el valor bruto a partir de una variable let res = Quiniela . equis let valorEquis = res . rawValue Tambi\u00e9n se puede asignar los valores de forma impl\u00edcita, dando un valor a la primera constante. Las siguientes tienen el valor consecutivo: enum Planeta : Int { case mercurio = 1 , venus , tierra , marte , jupiter , saturno , urano , neptuno } let posicionTierra = Planeta . tierra . rawValue // posicionTierra es 3 Podemos escoger cualquier tipo subyacente. Por ejemplo el tipo Character : enum CaracterControlASCII : Character { case tab = \" \\t \" case lineFeed = \" \\n \" case carriageReturn = \" \\r \" } El car\u00e1cter nueva l\u00ednea ( lineFeed ) se puede obtener de la siguiente forma: let nuevaLinea = CaracterControlASCII.LineFeed.rawValue Y por \u00faltimo, se puede definir como tipo subyacente String y los valores brutos de las constantes ser\u00e1n sus nombres convertidos a cadenas: enum Direccion : String { case norte , sur , este , oeste } let direccionAtardecer = Direccion . oeste . rawValue // direccionAtardecer es \"oeste\" En este caso, tambi\u00e9n se puede inicializar el valor bruto con una asignaci\u00f3n expl\u00edcita y no usar el propio nombre: enum Direccion : String { case norte = \"north\" case sur = \"south\" case este = \"east\" case oeste = \"west\" } let direccionAtardecer = Direccion . oeste . rawValue // direccionAtardecer es \"west\" Cuando se definen valores brutos es posible inicializar el enumerado de una forma similar a una estructura o una clase pasando el valor bruto. Devuelve el valor enumerado correspondiente o nil (un opcional): let posiblePlaneta = Planeta ( rawValue : 7 ) // posiblePlaneta es de tipo Planeta? y es igual a Planeta.urano","title":"7.1. Valores brutos de enumeraciones"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#8-enumeraciones-instanciables","text":"Una caracter\u00edstica singular de las enumeraciones en Swift es que permiten definir valores variables asociados a cada caso de la enumeraci\u00f3n, creando algo muy parecido a una instancia de la enumeraci\u00f3n.","title":"8. Enumeraciones instanciables"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#81-valores-asociados-a-instancias-de-enumeraciones","text":"Veamos un ejemplo inicial muy sencillo, con una enumeraci\u00f3n con un \u00fanico caso, en el que se define una variable de tipo Int : enum Prueba { case num ( Int ) } Esta notaci\u00f3n obliga a definir un valor concreto del Int asociado al caso num en el momento de creaci\u00f3n del enumerado: let valor1 = Prueba . num ( 10 ) let valor2 = Prueba . num ( 40 ) Las variables valor1 y valor2 son de tipo Prueba y tiene como valor el caso num , y el entero asociado a ese caso ( 10 y 40 en cada instancia). Son parecidas a instancias de una clase. Para obtener el valor asociado debemos usar una expresi\u00f3n case let en una sentencia switch con una variable a la que se asigna el valor. Por ejemplo, en el siguiente c\u00f3digo el valor del enumerado se asigna a la variable x : switch valor1 { case let . num ( x ): print ( \"Valor asociado al caso num: \\( x ) \" ) } // Imprime \"Valor asociado al caso num: 10 No hay que confundir un valor asociado a un caso y un valor bruto: el valor bruto de un caso de enumeraci\u00f3n es el mismo para todas las instancias, mientras que el valor asociado es distinto y se proporciona cuando se define el valor concreto de la enumeraci\u00f3n. Cuando unimos a la caracter\u00edstica del valor asociado la posibilidad de los enumerados de tener m\u00e1s de un caso tenemos lo que en otros lenguajes de programaci\u00f3n se llaman uniones etiquetadas o variantes . Por ejemplo, podemos definir un enumerado que permita guardar un Int o un String : enum Multiple { case num ( Int ) case str ( String ) } De esta forma, podemos crear valores de tipo Multiple que contienen un Int (instanciando el caso num ) o un String (instanciando el caso str ): let valor3 = Multiple . num ( 10 ) let valor4 = Multiple . str ( \"Hola\" ) Y podemos definir una funci\u00f3n que reciba instancias de tipo Multiple y use un switch para comprobar qu\u00e9 caso tienen instanciado: func imprime ( multiple : Multiple ) { switch multiple { case let . num ( x ): print ( \"Multiple tiene un Int: \\( x ) \" ) case let . str ( s ): print ( \"Multiple tiene un String: \\( s ) \" ) } } imprime ( multiple : valor3 ) // Imprime \"Multiple tiene un Int: 10\" imprime ( multiple : valor4 ) // Imprime \"Multiple tiene un String: Hola En un \u00faltimo ejemplo podemos ver que el tipo del caso tambi\u00e9n puede ser un tipo compuesto, como una tupla. Usamos un enum para definir posibles valores de un c\u00f3digo de barras, en el que incluimos dos posibles tipos de c\u00f3digo de barras: el c\u00f3digo de barras lineal (denominado UPC) y el c\u00f3digo QR: enum CodigoBarras { case upc ( Int , Int , Int , Int ) case qrCode ( String ) } Se lee de la siguiente forma: \u201cDefinimos un tipo enumerado llamado CodigoBarras , que puede tomar como valor un upc (c\u00f3digo de barras lineal) con un valor asociado de tipo (Int, Int, Int, Int) (una tupla de 4 enteros que representan los 4 n\u00fameros que hay en los c\u00f3digos de barras lineales) o un valor qrCode con valor asociado de tipo String \". Veamos un ejemplo de uso, en el que creamos un c\u00f3digo de barras de producto de tipo UPC, despu\u00e9s lo modificamos a otro de tipo c\u00f3digo QR y por \u00faltimo lo imprimimos: var codigoBarrasProducto = CodigoBarras . upc ( 8 , 85909 , 51226 , 3 ) codigoBarrasProducto = . qrCode ( \"ABCDEFGHIJKLMNOP\" ) switch codigoBarrasProducto { case let . upc ( sistemaNumeracion , fabricante , producto , control ): print ( \"UPC: \\( sistemaNumeracion ) , \\( fabricante ) , \\( producto ) , \\( control ) .\" ) case let . qrCode ( codigoProducto ): print ( \"C\u00f3digo QR: \\( codigoProducto ) .\" ) } // Imprime \"C\u00f3digo QR : ABCDEFGHIJKLMNOP.\"","title":"8.1. Valores asociados a instancias de enumeraciones"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#82-enumeraciones-recursivas","text":"Es posible combinar las caracter\u00edsticas de las enumeraciones con valor con la recursi\u00f3n para crear enumeraciones recursivas. Hay que preceder la palabra clave enum con indirect : indirect enum ExpresionAritmetica { case numero ( Int ) case suma ( ExpresionAritmetica , ExpresionAritmetica ) case multiplicacion ( ExpresionAritmetica , ExpresionAritmetica ) } let cinco = ExpresionAritmetica . numero ( 5 ) let cuatro = ExpresionAritmetica . numero ( 4 ) let suma = ExpresionAritmetica . suma ( cinco , cuatro ) let producto = ExpresionAritmetica . multiplicacion ( suma , ExpresionAritmetica . numero ( 2 )) Es muy c\u00f3modo manejar enumeraciones recursivas de forma recursiva: func evalua ( expresion : ExpresionAritmetica ) -> Int { switch expresion { case let . numero ( valor ): return valor case let . suma ( izquierda , derecha ): return evalua ( expresion : izquierda ) + evalua ( expresion : derecha ) case let . multiplicacion ( izquierda , derecha ): return evalua ( expresion : izquierda ) * evalua ( expresion : derecha ) } } print ( evalua ( expresion : producto )) // Imprime 18 Otro ejemplo de enums recursivos, para definir un tipo de datos Lista similar al que vimos en Scheme. La lista puede ser una lista vac\u00eda o puede contener dos elementos: un valor Int y otra lista: indirect enum Lista { case vacia case nodo ( Int , Lista ) } Para crear una lista de tipo nodo deberemos dar un valor entero (el valor de la cabeza de la lista) y otra lista (el resto de la lista). Tambi\u00e9n podemos crear una lista vac\u00eda. Por ejemplo, podemos crear la lista (10, 20, 30) de la siguiente manera: let lista1 = Lista . nodo ( 30 , Lista . vacia ) let lista2 = Lista . nodo ( 20 , lista1 ) let lista3 = Lista . nodo ( 10 , lista2 ) Podr\u00edamos crear esta misma lista de una forma m\u00e1s abreviada: let lista : Lista = . nodo ( 10 , . nodo ( 20 , . nodo ( 30 , . vacia ))) Una vez definido el tipo enumerado, podemos definir funciones que trabajen con \u00e9l. La siguiente funci\u00f3n, por ejemplo, es una funci\u00f3n recursiva que recibe una lista y devuelve la suma de sus elementos. Funciona de una forma muy similar a la definici\u00f3n que hicimos en Scheme: func suma ( lista : Lista ) -> Int { switch lista { case . vacia : return 0 case let . nodo ( car , cdr ): return car + suma ( lista : cdr ) } } let z : Lista = . nodo ( 20 , . nodo ( 10 , . vacia )) print ( suma ( lista : z )) // Imprime 30 Podemos tambi\u00e9n definir una funci\u00f3n recursiva construye(lista:[Int]) que devuelve una lista a partir de una array de enteros: func construye ( lista : [ Int ]) -> Lista { if ( lista . isEmpty ) { return Lista . vacia } else { let primero = lista [ 0 ] let resto = Array ( lista . dropFirst ()) return Lista . nodo ( primero , construye ( lista : resto )) } } let lista2 = construye ( lista : [ 1 , 2 , 3 , 4 , 5 ]) print ( suma ( lista : lista2 )) // Imprime 15","title":"8.2. Enumeraciones recursivas"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#9-opcionales","text":"Una de las caracter\u00edsticas principales que Swift intenta promover es la seguridad y la robustez. Debe ser dif\u00edcil que el desarrollador escriba c\u00f3digo con errores y que rompa la aplicaci\u00f3n. Por ejemplo, la comprobaci\u00f3n est\u00e1tica de los tipos de datos o el manejo autom\u00e1tico de la gesti\u00f3n de memoria son dos caracter\u00edsticas del lenguaje que van en esta direcci\u00f3n. Otro de los elementos m\u00e1s importantes del lenguaje para promover la seguridad son los opcionales. Vamos a estudiar su uso y utilidad. En muchos lenguajes existe el concepto de valor vac\u00edo . Por ejemplo, en Java se usa null o en Python None . Nota Tony Hoare introdujo el concepto de Null en ALGOL, en 1965. En una conferencia en 2009 habla sobre esta idea y la considera un costoso error: Null References: The Billion Dollar Mistake . El concepto de null es un concepto peligroso, como lo saben bien los desarrolladores Java. En Java, si intentamos usar una variable que contiene null se produce la t\u00edpica excepci\u00f3n null pointer exception y la aplicaci\u00f3n se rompe. Todos hemos ca\u00eddo en este error, y con m\u00e1s frecuencia de la que ser\u00eda deseable. En Swift tambi\u00e9n existe el valor nulo. La forma de representarlo es el identificador nil . La caracter\u00edstica de seguridad que introduce Swift con respecto a Java y a otros lenguajes es que no es posible asignar nil a una variable de un tipo normal. Por ejemplo, la siguiente l\u00ednea dar\u00eda un error de compilaci\u00f3n: let cadena : String = nil // error: 'nil' cannot initialize specified type 'String' Si queremos utilizar nil debemos declarar la variable usando lo que se denomina tipo opcional : var cadena : String ? = \"Hola\" cadena = nil El tipo String? indica que podemos tener un valor nil o un valor del tipo original. Primero estamos definiendo la variable cadena del tipo String? ( String opcional) y le estamos asignando un valor determinado (de tipo String ). Y despu\u00e9s le asignamos nil . El uso de opcionales es necesario en situaciones en las que podemos obtener un valor desconocido. Por ejemplo, en alguna funci\u00f3n en la que pedimos un valor al usuario y el usuario puede no introducir ninguno. O en estructuras de datos en las que hacemos b\u00fasquedas que pueden no devolver ning\u00fan valor, como en un diccionario: var edades = [ \"Raquel\" : 30 , \"Pedro\" : 22 , ] let edad1 = edades [ \"Raquel\" ] let edad2 = edades [ \"Ana\" ] // devuelve nil En el c\u00f3digo anterior definimos un diccionario edades con claves de tipo String y valores Int . Despu\u00e9s buscamos en el diccionario por la clave \"Raquel\" y se devuelve el valor 30 , que se guarda en la variable edad1 . Cuando se busca por la clave \"Ana\" se devuelve un nil porque no est\u00e1 definida. Por ello, la variable edad2 ser\u00e1 de tipo Int? ( Int opcional) y contendr\u00e1 un nil . Un valor opcional no puede ser usado directamente. Primero debemos comprobar si el valor es distinto de nil y s\u00f3lo despu\u00e9s podremos usarlo. Para reforzar esto, Swift esconde o envuelve ( wrap ) el valor real del opcional y obliga a llamar al operador ! para desenvolverlo ( unwrap ) y usarlo. Este operador se denomina de desenvoltura forzosa ( forced unwrapping ). Por ejemplo, el siguiente c\u00f3digo produce un error de compilaci\u00f3n porque intentamos usar un opcional sin desenvolverlo: var x : Int ? = 10 let y = x + 10 // error: value of optional type 'Int?' must be unwrapped to a value of type 'Int' Para usar el valor asignado a x debemos desenvolverlo con el operador ! : var x : Int ? = 10 let y = x ! + 10 print ( y ) // Imprime \"20\" Si se aplica el operador ! a un valor nil se produce un error en tiempo de ejecuci\u00f3n y la aplicaci\u00f3n se rompe: var respuestaEncuesta : String ? print ( respuestaEncuesta !) // Fatal error: Unexpectedly found nil while unwrapping an Optional value Podemos definir como opcional variables, par\u00e1metros o valores devueltos por funciones de cualquier tipo, a\u00f1adi\u00e9ndoles la interrogaci\u00f3n al final. Por ejemplo, la siguiente funci\u00f3n max es una funci\u00f3n que devuelve un Int? , un entero opcional en el caso de que se le pase un array vac\u00edo. Al devolver un opcional, debemos desenvolver el valor devuelto cuando queramos usarlo como Int (por ejemplo, en la llamada recursiva). func max ( array :[ Int ]) -> Int ? { if ( array . isEmpty ) { return nil } else if ( array . count == 1 ) { return array [ 0 ] } else { let primero = array [ 0 ] let resto = Array ( array . dropFirst ()) return max ( primero , max ( array : resto ) ! ) } } let maximo = max ( array :[ 10 , 200 , - 100 , 2 ]) print ( maximo !) // Imprime \"200\" Una variable opcional sin asignar ning\u00fan valor se inicializa autom\u00e1ticamente a nil : var respuestaEncuesta : String ? // respuestaEncuesta es inicializado autom\u00e1ticamente a nil","title":"9. Opcionales"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#91-ligado-opcional","text":"Para comprobar si un valor opcional es nil podemos usar un if . Es obligado hacerlo si desconocemos el valor que nos llega. Por ejemplo, supongamos que la funci\u00f3n leerRespuesta() lee una respuesta del usuario y devuelve un String? . Para usar esta funci\u00f3n deber\u00edamos comprobar si el valor devuelto es distinto de nil : let respuestaEncuesta = leerRespuesta () if respuestaEncuesta != nil { let respuesta = respuestaEncuesta ! print ( \"Respuesta: \" + respuesta ) } Como es muy habitual hacer lo anterior, en Swift es posible comprobar si un opcional tiene valor y asignar su valor a otra variable al mismo tiempo con una construcci\u00f3n llamada ligado opcional ( optional binding ): let respuestaEncuesta = leerRespuesta () if let respuesta = respuestaEncuesta { print ( \"Respuesta: \" + respuesta ) } Podemos leer el c\u00f3digo anterior de la siguiente forma: \"Si el opcional respuestaEncuesta contiene un valor, define la constante respuesta con el valor contenido en el opcional\". Una forma a\u00fan mejor de escribir el c\u00f3digo anterior ser\u00eda la siguiente, en la que s\u00f3lo usamos una variable: // Mejor este c\u00f3digo que el anterior if let respuesta = leerRespuesta () { print ( \"Respuesta: \" + respuesta ) } Nota Para no tener que buscar un nuevo nombre de variable, Swift permite usar el mismo nombre de variable en la sentencia if let : var x : Int ? = 0 if let x = x { print ( x ) } La variable x creada por el if let es de tipo no opcional y s\u00f3lo tiene valor en el \u00e1mbito del if . Otro ejemplo, el m\u00e9todo first de un array devuelve un opcional que contiene nil si el array est\u00e1 vac\u00edo o el primer elemento del array en el caso en que exista. El siguiente c\u00f3digo utiliza un ligado opcional para implementar otra versi\u00f3n de la funci\u00f3n que suma los valores de un array: func sumaValores ( _ valores : [ Int ]) -> Int { if let primero = valores . first { let resto = Array ( valores . dropFirst ()) return primero + sumaValores ( resto ) } else { return 0 } } print ( sumaValores ([ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 ])) // Imprime \"36\" Si tenemos varios opcionales es posible comprobar que todos ellos son distintos de nil usando varios let en el mismo if : var x1 : Int ? = pedirNumUsuario () var x2 : Int ? = pedirNumUsuario () var x3 : Int ? = pedirNumUsuario () if let dato1 = x1 , let dato2 = x2 , let dato3 = x3 { let suma = dato1 + dato2 + dato3 print ( \"Ning\u00fan nil y la suma de todos los datos es: \\( suma ) \" ) } else { print ( \"Alg\u00fan dato del usuario es nil\" ) }","title":"9.1 Ligado opcional"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#92-operador-nil-coalescing","text":"El operador nil-coalescing ( ?? ) permite definir un valor por defecto en una asignaci\u00f3n si un opcional es nil. let a : Int ? = nil let b : Int ? = 10 let x = a ?? - 1 let y = b ?? - 1 print ( \"Resultado: \\( x ) , \\( y ) \" ) // Imprime Resultado: -1, 10 En el ejemplo anterior, en la variable x se guardar\u00e1 el valor -1 y en la variable y el valor 10 .","title":"9.2. Operador nil-coalescing"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#93-encadenamiento-de-opcionales","text":"El encadenamiento de opcionales ( optional chaining ) permite llamar a un m\u00e9todo de una variable que contiene un opcional. Si la variable no es nil , se ejecuta el m\u00e9todo y se devuelve su valor como un opcional. Si la variable es nil se devuelve nil . let nombre1 : String ? = \"Pedro\" let nombre2 : String ? = nil // Error: let str1 = nombre1.lowercased() // No podemos llamar al m\u00e9todo lowercased() del String // porque nombre es opcional y puede tener nil let str1 = nombre1 ?. lowercased () let str2 = nombre2 ?. lowercased () // str1: String? = \"pedro\" // str2: String? = nil","title":"9.3. Encadenamiento de opcionales"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#94-definicion-de-lista-con-opcionales","text":"Veamos como \u00faltimo ejemplo una segunda versi\u00f3n del enum Lista , en el que utilizamos un \u00fanico case , pero dando la posibilidad de que el resto de la lista sea nil haci\u00e9ndolo opcional. Definimos el enumerado y tambi\u00e9n la funci\u00f3n suma(lista:) : indirect enum Lista { case nodo ( Int , Lista ?) } func suma ( lista : Lista ) -> Int { switch lista { case let . nodo ( car , cdr ): if ( cdr == nil ) { return car } else { return car + suma ( lista : cdr !) } } } let z : Lista = . nodo ( 20 , . nodo ( 10 , nil )) print ( suma ( lista : z )) /// Devuelve 30","title":"9.4. Definici\u00f3n de Lista con opcionales"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#10-clausuras","text":"Ya hemos visto previamente que en Swift las funciones son objetos de primera clase del lenguaje y que es posible definir funciones y pasarlas como par\u00e1metro de otras funciones. Tambi\u00e9n es posible construir clausuras, funciones definidas en el \u00e1mbito de otras funcionas y devueltas como resultados. Veremos primero c\u00f3mo definir de forma compacta funciones que se pasan como par\u00e1metro de otras, utilizando expresiones de clausuras . Y despu\u00e9s veremos c\u00f3mo las clausuras definidas en el interior de otras funciones capturan las variables definidas en el \u00e1mbito de la funci\u00f3n principal.","title":"10. Clausuras"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#101-expresiones-de-clausuras","text":"Swift permite definir expresiones compactas con las que construir estas funciones que se pasan como par\u00e1metro de otras funciones. Se denominan expresiones de clausuras ( closure expressions ). Estas expresiones proporcionan optimizaciones de sintaxis para escribir clausuras de forma concisa y clara. Vamos a ver las distintas optimizaciones utilizando como ejemplo el m\u00e9todo sorted(by:) .","title":"10.1. Expresiones de clausuras"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#102-el-metodo-sortedby","text":"Tal y como hemos visto anteriormente la biblioteca st\u00e1ndar de Swift define un m\u00e9todo sorted() que devuelve los elementos ordenados de un Array . El array original no se modifica. La comparaci\u00f3n entre los elementos se realiza usando el comparador < . Veamos un ejemplo con un array de cadenas: let estudiantes = [ \"Kofi\" , \"Abena\" , \"Peter\" , \"Kweku\" , \"Akosua\" ] let ordenados = estudiantes . sorted () print ( ordenados ) // Imprime \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\" Esta funci\u00f3n es similar a las que hay en muchos lenguajes. El \u00fanico aspecto funcional es que el array original no se modifica, sino que la ordenaci\u00f3n construye un nuevo array (existe una funci\u00f3n alternativa mutable que se denomina sort() ). Lo interesante relacionado con las clausuras est\u00e1 en la funci\u00f3n sorted(by:) . En esta funci\u00f3n se utiliza una clausura como par\u00e1metro para modificar la comparaci\u00f3n entre elementos y resultar en una ordenaci\u00f3n distinta. Es una de las distintas funciones de orden superior que se definen en las colecciones (m\u00e1s adelante veremos otras). El perfil de la funci\u00f3n sorted(by:) es: func sorted(by areInIncreasingOrder: (Element, Element) -> Bool) El par\u00e1metro es una funci\u00f3n de dos par\u00e1metros (del tipo de los elementos del array) que devuelve un booleano indicando si el primer par\u00e1metro va antes que el segundo en el array ordenado. La clausura de ordenaci\u00f3n devuelve true si el primer valor deber\u00eda aparecer antes del segundo valor y false en otro caso. Por ejemplo, podr\u00edamos ordenar un array de cadenas en orden alfab\u00e9tico inverso. func primeroMayor ( s1 : String , s2 : String ) -> Bool { return s1 > s2 } let estudiantes = [ \"Kofi\" , \"Abena\" , \"Peter\" , \"Kweku\" , \"Akosua\" ] let alreves = estudiantes . sorted ( by : primeroMayor ) print ( alreves ) // Imprime [\"Peter\", \"Kweku\", \"Kofi\", \"Akosua\", \"Abena\"] Si la primera cadena ( s1 ) es mayor que la segunda cadena ( s2 ), la funci\u00f3n primeroMayor(s1:s2:) devolver\u00e1 true , indicando que s1 deber\u00eda aparecer antes que s2 en el array ordenado. La ordenaci\u00f3n mayor o menor se refiere a la ordenaci\u00f3n alfab\u00e9tica, al estar tratando con caracteres. La versi\u00f3n anterior esta es una forma bastante complicada de escribir lo que b\u00e1sicamente es una funci\u00f3n de una \u00fanica expresi\u00f3n ( a > b ). En este ejemplo, ser\u00eda preferible escribir la clausura de ordenaci\u00f3n inline , utilizando la sintaxis de expresiones de clausuras.","title":"10.2. El m\u00e9todo sorted(by:)"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#103-sintaxis-de-las-expresiones-de-clausura","text":"La sintaxis de las expresiones de clausura tiene la siguiente forma general: { ( <parametros>) -> <tipo devuelto> in <sentencias> } Si aplicamos esta sintaxis al ejemplo anterior: let alreves = estudiantes . sorted ( by : { ( s1 : String , s2 : String ) -> Bool in return s1 > s2 }) Hay que hacer notar que la declaraci\u00f3n de los par\u00e1metros y el tipo devuelto por esta clausura inline es id\u00e9ntica a la declaraci\u00f3n de la funci\u00f3n primeroMayor(s1:s2:) . En ambos casos, se escribe como (s1: String, s2: String) -> Bool . Sin embargo, en la expresi\u00f3n de clausura los par\u00e1metros y el tipo devuelto se escribe dentro de las llaves, no fuera. El comienzo del cuerpo de la clausura se introduce por la palabra clave in . Esta palabra clave indica que la definici\u00f3n de los par\u00e1metros y del tipo devuelto por la clausura ha terminado, y que el cuerpo de la clausura va a comenzar. Como el cuerpo de la clausura es corto, podemos incluso escribirlo en una \u00fanica l\u00ednea: let alreves = estudiantes . sorted ( by : { ( s1 : String , s2 : String ) -> Bool in return s1 > s2 } )","title":"10.3. Sintaxis de las expresiones de clausura"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#104-inferencia-del-tipo-por-el-contexto","text":"Como la clausura de ordenaci\u00f3n se pasa como argumento de un m\u00e9todo, Swift puede inferir los tipos de sus par\u00e1metros y el tipo del valor que devuelve. El m\u00e9todo sorted(by:) se llama sobre un array de cadenas, por lo que su argumento debe ser una funci\u00f3n del tipo (String, String) -> Bool . Esto significa que los tipos (String, String) y Bool no necesitan escribirse como parte de la definici\u00f3n de la expresi\u00f3n de la clausura. Debido a que todos los tipos pueden ser inferidos, la flecha del tipo devuelto y los par\u00e9ntesis alrededor de los nombres de los par\u00e1metros tambi\u00e9n pueden omitirse: let alreves = estudiantes . sorted ( by : { s1 , s2 in return s1 > s2 } )","title":"10.4. Inferencia del tipo por el contexto"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#105-devoluciones-implicitas-en-clausuras-con-una-unica-expresion","text":"En clausuras con una \u00fanica expresi\u00f3n podemos omitir tambi\u00e9n la palabra clave return : let alreves = estudiantes . sorted ( by : { s1 , s2 in s1 > s2 } )","title":"10.5. Devoluciones impl\u00edcitas en clausuras con una \u00fanica expresi\u00f3n"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#106-abreviaturas-en-los-nombres-de-los-argumentos","text":"Swift proporciona autom\u00e1ticamente abreviaturas para los nombres de argumentos de las clausuras inline que pueden usarse para referirse a los valores de los argumentos de la clausura usando los nombres $0 , $1 , $2 , etc. Si se usa estos argumentos abreviados, se puede omitir la definici\u00f3n de la lista de los argumentos: let alreves = estudiantes . sorted ( by : { $0 > $1 } )","title":"10.6. Abreviaturas en los nombres de los argumentos"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#107-funciones-operadoras","text":"Incluso hay una forma aun m\u00e1s corta de escribir la expresi\u00f3n de clausura anterior. Swift define una implementaci\u00f3n espec\u00edfica de cadenas del operador mayor-que ( > ) como una funci\u00f3n que tiene dos par\u00e1metros de tipo String y devuelve un Bool . Esto es exactamente lo que necesita el m\u00e9todo sorted(by:) . Podemos, por tanto, pasar simplemente este operador mayor-que, y Swift inferir\u00e1 que queremos usar el espec\u00edfico de cadenas: let alreves = estudiantes . sorted ( by : > )","title":"10.7. Funciones operadoras"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#108-clausuras-al-final","text":"Si necesitamos pasar una expresi\u00f3n de clausura a una funci\u00f3n como el argumento final de la clausura y la expresi\u00f3n es larga, puede ser \u00fatil escribirla en su lugar como una clausura al final ( trailing closure ). Una clausura al final es una expresi\u00f3n de clausura que se escribe fuera de (y despu\u00e9s de) los par\u00e9ntesis de la funci\u00f3n a la que se le pasa como par\u00e1metro: let alreves = estudiantes . sorted () { $0 > $1 } Cuando se proporciona una expresi\u00f3n de clausura como \u00fanico argumento de una funci\u00f3n o m\u00e9todo y se pasa como una clausura al final, no es necesario escribir los par\u00e9ntesis tras el nombre de la funci\u00f3n: let alreves = estudiantes . sorted { $0 > $1 }","title":"10.8. Clausuras al final"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#109-variables-capturadas","text":"Cuidado Los ejemplos que vamos a ver a continuaci\u00f3n no usan programaci\u00f3n funcional, porque la variable capturada por la clausura es una variable mutable (se ha definido con var y no con let ). Por eso las funciones resultantes no son funciones puras, sino que devuelven un valor distinto cada vez que son invocadas. Son funciones con estado local mutable. Una clausura puede capturar constantes y variables del contexto en el que se define. La clausura puede referirse y modificar esos valores dentro de su cuerpo, incluso si ya no existe el \u00e1mbito ( scope ) original en el que se definieron estas constantes y variables. En Swift, la forma m\u00e1s sencilla de una clausura que captura variables es una funci\u00f3n anidada ( nested function ) escrita en el cuerpo de otra funci\u00f3n. Una funci\u00f3n anidada puede capturar cualquiera de los argumentos de su funci\u00f3n exterior y tambi\u00e9n puede capturar cualquier constante y variable definida dentro de la funci\u00f3n exterior. Veamos un ejemplo similar al que vimos en Scheme. La funci\u00f3n construyeIncrementador contiene una funci\u00f3n anidada llamada incrementador . Esta funci\u00f3n captura dos variables de su contexto: totalAcumulado y cantidad . Despu\u00e9s de capturar estas variables, incrementador es devuelto por construyeIncrementador como una clausura que incrementa totalAcumulado en cantidad cada vez que se llama. func construyeIncrementador ( incremento cantidad : Int ) -> () -> Int { var totalAcumulado = 0 func incrementador () -> Int { totalAcumulado += cantidad return totalAcumulado } return incrementador } El tipo devuelto de construyeIncrementador es () -> Int . Esto significa que devuelve una funci\u00f3n que no tiene par\u00e1metros y que devuelve un Int cada vez que es llamada. La funci\u00f3n construyeIncrementador(incremento:) tiene un \u00fanico par\u00e1metro Int con nombre externo incremento y nombre local cantidad . El argumento pasado a este par\u00e1metro especifica cu\u00e1nto ser\u00e1 incrementado totalAcumulado cada vez que se llama a la funci\u00f3n incrementador devuelta. La funci\u00f3n construyeIncrementador define una funci\u00f3n anidada llamada incrementador , que realiza el incremento real. Esta funci\u00f3n simplemente a\u00f1ade cantidad a totalAcumulado , y devuelve el resultado. Si la consideramos aislada, la funci\u00f3n anidada incrementador() podr\u00eda parecer extra\u00f1a: func incrementador () -> Int { totalAcumulado += cantidad return totalAcumulado } La funci\u00f3n no tiene ning\u00fan par\u00e1metro, y sin embargo se refiere a totalAcumulado y a cantidad en su cuerpo. Lo puede hacer porque ha capturado una referencia a estas variables de la funci\u00f3n de alrededor y las usa en su propio cuerpo. Al capturar estas referencias las variables totalAcumulado y cantidad no desaparecen cuando termina la llamada a construyeIncrementador . Estas variables tambi\u00e9n estar\u00e1n disponibles la pr\u00f3xima vez que se llame la funci\u00f3n incrementador . Aqu\u00ed hay un ejemplo de construyeIncrementador en acci\u00f3n: let incrementaDiez = construyeIncrementador ( incremento : 10 ) Este ejemplo define una constante llamada incrementaDiez para referenciar la funci\u00f3n incrementador que devuelve construyeIncrementador . Esta funci\u00f3n a\u00f1ade 10 a la variable totalAcumulado cada vez que se es llamada. Si llamamos a la funci\u00f3n m\u00e1s de una vez podemos comprobar su conducta en acci\u00f3n: incrementaDiez () // devuelve 10 incrementaDiez () // devuelve 20 incrementaDiez () // devuelve 30 Si creamos un segundo incrementador, tendr\u00e1 sus propias referencias a un variable totalAcumulado nueva, distinta de la anterior: let incrementaSiete = construyeIncrementador ( incremento : 7 ) incrementaSiete () // devuelve 7 Si llamamos a la funci\u00f3n incrementador original ( incrementaDiez ) vemos que sigue incrementando su propia variable totalAcumulado y que no se ve afectada por la variable capturada por incrementaSiete : incrementaDiez () // devuelve 40","title":"10.9. Variables capturadas"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#1010-clausuras-con-expresiones-de-clausura","text":"En el ejemplo anterior hemos usado una definici\u00f3n interna de una funci\u00f3n para definir la clausura que se devuelve. Lo hemos hecho por claridad, pero no es necesario. Es posible escribir un c\u00f3digo m\u00e1s compacto usando expresiones de clausura. Por ejemplo, la funci\u00f3n construyeSumador() vista en el apartado \"Funciones que devuelven otras funciones\": func construyeSumador10 () -> ( Int ) -> Int { func suma10 ( x : Int ) -> Int { return x + 10 } return suma10 } Una versi\u00f3n de esta misma funci\u00f3n usando una expresi\u00f3n de clausura es la siguiente: func construyeSumador10 () -> ( Int ) -> Int { return { $0 + 10 } } var f = construyeSumador10 () print ( f ( 20 )) // Imprime \"30\" Y lo mismo con la funci\u00f3n constryeIncrementador(incremento:) vista en el apartado anterior: func construyeIncrementador ( incremento cantidad : Int ) -> () -> Int { var totalAcumulado = 0 func incrementador () -> Int { totalAcumulado += cantidad return totalAcumulado } return incrementador } La versi\u00f3n con una expresi\u00f3n de clausura: func construyeIncrementador ( incremento cantidad : Int ) -> () -> Int { var totalAcumulado = 0 return { totalAcumulado += cantidad return totalAcumulado } } let incrementaDiez = construyeIncrementador ( incremento : 10 ) print ( incrementaDiez ()) // Imprime \"10\" print ( incrementaDiez ()) // Imprime \"20\"","title":"10.10. Clausuras con expresiones de clausura"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#1011-variables-capturadas-por-clausuras-y-variables-del-ambito-de-invocacion","text":"Las clasuras usan las variables capturadas y no las variables declaradas en el \u00e1mbito en el que se invoca a la clausura. Vamos a explicarlo con un ejemplo. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 func construyeFunc () -> () -> Int { var x = 0 return { x = x + 1 return x } } let f = construyeFunc () print ( f ()) // -> 1 print ( f ()) // -> 2 func usaFunc ( _ f : () -> Int ) -> Int { var x = 10 return f () } print ( usaFunc ( f )) // -> 3 var x = 100 print ( usaFunc { return x + 10 }) // -> 110 En el c\u00f3digo anterior se resaltan las tres declaraciones de variables x . Es muy importante comprobar el \u00e1mbito en el que se realizan esas declaraciones. La primera declaraci\u00f3n se realiza dentro de la funci\u00f3n construyeFunc() , la segunda dentro de la funci\u00f3n usaFunc() y la tercera en el \u00e1mbito global. En cada caso, la variable se inicializar\u00e1 cuando se ejecute esa l\u00ednea de c\u00f3digo. La funci\u00f3n usaFunc definida en la l\u00ednea 13 recibe una funci\u00f3n f sin par\u00e1metros que devuelve un entero. En el \u00e1mbito local de usaFunc se define la variable local x que tiene el valor 10 antes de invocar a la funci\u00f3n f recibida. \u00bfQu\u00e9 pasa si la funci\u00f3n recibida es una clausura que ha capturado una variable que tambi\u00e9n se llama x ? En el caso de la invocaci\u00f3n a usaFunc que hay en la l\u00ednea 18, la funci\u00f3n f que se pasa como par\u00e1metro es la clausura obtenida en la l\u00ednea 9. Esta clausura ha capturado la variable x definida en la l\u00ednea 2. Y en ese momento esa variable tiene el valor 2. El c\u00f3digo de la clausura es el definido en las l\u00edneas 3 a 6: { x = x + 1 return x } \u00bfA qu\u00e9 variable x se refiere ese c\u00f3digo? \u00bfA la variable capturada que tiene un valor de 2? \u00bfO a la variable en el \u00e1mbito de ejecuci\u00f3n (l\u00ednea 14) que tiene un valor de 10? Si ejecutamos el c\u00f3digo veremos que la expresi\u00f3n devuelve 3. O sea que las clausuras usan siempre las variables capturadas. Podemos comprobarlo tambi\u00e9n en la invocaci\u00f3n de la l\u00ednea 21. Ah\u00ed la clausura que se pasa es una expresi\u00f3n de clausura que captura la variable x definida en la l\u00ednea anterior. Por eso cuando se ejecuta la sentencia se imprime el valor 110 y no el valor 20 .","title":"10.11. Variables capturadas por clausuras y variables del \u00e1mbito de invocaci\u00f3n"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#1012-las-clausuras-son-tipos-de-referencia","text":"En el ejemplo anterior, incrementaSiete e incrementaDiez son constantes, pero las clausuras a las que estas constantes se refieren pueden incrementar la variable totalAcumulado que han capturado. Esto es porque funciones y clausuras son tipos referencia. Siempre que asignamos una funci\u00f3n o una clausura a una constante o una variable, estamos realmente estableciendo que la constante o variable es una referencia a la funci\u00f3n o la clausura. En el ejemplo anterior, es la elecci\u00f3n de la clausura a la que referencia incrementaDiez la que es constante, no los contenidos propios de la clausura. Esto tambi\u00e9n significa que si asignamos una clausura a dos constantes o variables distintas, ambas constantes o variables se referir\u00e1n a la misma clausura: let tambienIncrementaDiez = incrementaDiez tambienIncrementaDiez () // devuelve 50","title":"10.12. Las clausuras son tipos de referencia"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#11-funciones-de-orden-superior","text":"Una de las caracter\u00edsticas funcionales que m\u00e1s hemos usado para trabajar con listas en Scheme son las funciones de orden superior como map , filter o foldr . Swift tiene definidas funciones equivalentes para trabajar con colecciones. Se denominan map , filter y reduce . Todas ellas aceptan expresiones de clausura como argumento.","title":"11. Funciones de orden superior"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#111-map","text":"El m\u00e9todo map se define en el protocolo CollectionType y es adoptado por m\u00faltiples estructuras como Array , Dictionary , Set . El perfil del m\u00e9todo map es el siguiente: func map < T >( _ transform : ( Element ) -> T ) -> [ T ] Se trata de un m\u00e9todo gen\u00e9rico (lo veremos m\u00e1s adelante) que recibe como par\u00e1metro una funci\u00f3n unaria (funci\u00f3n de transformaci\u00f3n) del tipo de los elementos de la colecci\u00f3n y que devuelve otro elemento (puede ser del mismo o de distinto tipo que los elementos de la colecci\u00f3n). Devuelve un array que contiene el resultado de aplicar la funci\u00f3n de transformaci\u00f3n a cada elemento del array original. Por ejemplo: let numeros = [ Int ]( 0. .. 5 ) numeros . map { $0 * $0 } // devuelve [0, 1, 4, 9, 16, 25] Otro ejemplo, en el que usamos map para implementar la funci\u00f3n sumaParejas(parejas: [(Int, Int)]) -> [Int] que devuelve recibe el array parejas de tuplas de dos enteros y devuelve un array con el resultado de sumar los dos elementos de cada pareja: func suma ( parejas : [( Int , Int )]) -> [ Int ] { return parejas . map ({( pareja : ( Int , Int )) -> Int in return pareja . 0 + pareja . 1 }) } suma ( parejas :[( 1 , 1 ), ( 2 , 2 ), ( 3 , 3 ), ( 4 , 4 )]) // devuelve [2, 4, 6, 8] Podemos usar en el cuerpo de la expresi\u00f3n de clausura de map una variable capturada. Por ejemplo en la siguiente funci\u00f3n incrementaValores(_:con:) que suma con a todos los n\u00fameros de un array que se le pasa por par\u00e1metro: func incrementa ( valores : [ Int ], con : Int ) -> [ Int ] { return valores . map ({( x : Int ) -> Int in return x + con }) } incrementa ( valores :[ 10 , 20 , 30 ], con : 5 ) // devuelve [15, 25, 35] La versi\u00f3n abreviada de la expresi\u00f3n de clausura es: func incrementa ( valores : [ Int ], con inc : Int ) -> [ Int ] { return valores . map { $0 + inc } } incrementa ( valores : [ 10 , 20 , 30 ], con : 5 ) // devuelve [15, 25, 35]","title":"11.1 Map"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#112-filter","text":"La funci\u00f3n filter es tambi\u00e9n igual que la definida en Scheme. Su perfil es: func filter ( _ isIncluded : ( Element ) -> Bool ) -> [ Element ] Recibe una clausura de un argumento que devuelve un booleano. La funci\u00f3n devuelve un array con los elementos de la colecci\u00f3n para los que la clausura devuelve true . Ejemplo: let numeros = [ Int ]( 0. .. 10 ) numeros . filter { $0 % 2 == 0 } // devuelve [0, 2, 4, 6, 8, 10]","title":"11.2. Filter"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#113-reduce","text":"Similar al foldr de Scheme. Su perfil es el siguiente: func reduce < Result >( _ initialResult : Result , _ nextPartialResult : ( Result , Element ) -> Result ) -> Result Es una funci\u00f3n gen\u00e9rica que devuelve un valor de un tipo gen\u00e9rico (el tipo del resultado que se construye en la funci\u00f3n). Recibe como par\u00e1metro un valor inicial y una funci\u00f3n de plegado que se aplica al resultado anterior y al elemento de la colecci\u00f3n, devolviendo un resultado. El resultado final es el resultado de aplicar la funci\u00f3n de plegado a todos los elementos de la colecci\u00f3n, empezando por el valor inicial. Por ejemplo, podemos usar reduce para sumar todos los n\u00fameros de un array: let numeros = [ Int ]( 0. .. 10 ) numeros . reduce ( 0 , + ) La funci\u00f3n combina los elementos de la colecci\u00f3n usando la funci\u00f3n de combinaci\u00f3n que se pasa como par\u00e1metro. La funci\u00f3n que se pasa como par\u00e1metro recibe dos par\u00e1metros: el primero es el resultado de la combinaci\u00f3n y el segundo se coge de la colecci\u00f3n. Por ejemplo, el siguiente c\u00f3digo usa reduce para sumar la longitud de todas las cadenas de un array: let cadenas = [ \"Patatas\" , \"Arroz\" , \"Huevos\" ] cadenas . reduce ( 0 , {( i : Int , c : String ) -> Int in c . count + i }) // devuelve 18 Es posible simplificar la notaci\u00f3n anterior: cadenas . reduce ( 0 , { $1 . count + $0 }) Tambi\u00e9n se puede utilizar la notaci\u00f3n de clausura al final: cadenas . reduce ( 0 ) { $1 . count + $0 } La combinaci\u00f3n se hace de izquierda a derecha: let cadenas = [ \"Patatas\" , \"Arroz\" , \"Huevos\" ] let cadenas = [ \"Patatas\" , \"Arroz\" , \"Huevos\" ] print ( cadenas . reduce ( \"*\" , { $0 + \"-\" + $1 })) // Imprime \"*-Patatas-Arroz-Huevos\" El primer argumento de la funci\u00f3n de plegado ( $0 ) es el resultado anterior (empieza por \"*\" ) y el segundo argumento ( $1 ) se coge del array de cadenas.","title":"11.3. Reduce"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#114-combinacion-de-funciones-de-orden-superior","text":"Cuando el resultado de aplicar una funci\u00f3n de orden superior a una colecci\u00f3n es otra colecci\u00f3n es posible aplicar otra funci\u00f3n de orden superior a este resultado. Por ejemplo, la siguiente sentencia devuelve todos los n\u00fameros pares del array inicial elevados al cuadrado: let numeros = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] numeros . filter { $0 % 2 == 0 }. map { $0 * $0 } // Devuelve el array [4,16,36,64,100] Y la siguiente devuelve la suma n\u00fameros mayores de 100: let numeros = [ 103 , 2 , 330 , 42 , 532 , 6 , 125 ] numeros . filter { $0 >= 100 }. reduce ( 0 , + ) // Devuelve 1090","title":"11.4. Combinaci\u00f3n de funciones de orden superior"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#12-genericos","text":"Empecemos con un ejemplo sencillo. Supongamos la siguiente funci\u00f3n intercambia(_:) que recibe una tupla (Int, String) y devuelve una tupla (String, Int) con los valores intercambiados. func intercambia ( _ tupla : ( Int , String )) -> ( String , Int ) { let tuplaNueva = ( tupla . 1 , tupla . 0 ) return tuplaNueva } let tupla = ( 10 , \"Hola\" ) intercambia ( tupla ) // devuelve (\"Hola\", 10) La funci\u00f3n es interesante, pero s\u00f3lo recibe tuplas cuya primera componente es un Int y su segunda componente es un String . Supongamos que queremos hacer la misma funci\u00f3n para intercambiar elementos de una tupla (Int, Int) . Tendr\u00edamos que usar el mismo c\u00f3digo, pero cambiando los tipos: func intercambia ( _ tupla : ( Int , Int )) -> ( Int , Int ) { let tuplaNueva = ( tupla . 1 , tupla . 0 ) return tuplaNueva } let tupla = ( 10 , 20 ) intercambia ( tupla ) // devuelve (20, 10) El c\u00f3digo es el mismo, lo \u00fanico distinto son los tipos. \u00bfPodr\u00edamos generalizar las funciones anteriores para hacer que el c\u00f3digo pueda trabajar con cualquier tipo? La respuesta es s\u00ed, usando funci\u00f3n gen\u00e9rica : func intercambia < A , B >( _ tupla : ( A , B )) -> ( B , A ) { let tuplaNueva = ( tupla . 1 , tupla . 0 ) return tuplaNueva } El cuerpo de la funci\u00f3n es id\u00e9ntico a la funci\u00f3n anterior. La diferencia es que en la versi\u00f3n gen\u00e9rica se usan placeholders (los s\u00edmbolos A y B ) en lugar de tipos concretos. Son tipos gen\u00e9ricos, que se definen usando un identificador entre s\u00edmbolos de < y > . Los tipos reales que se van a usar en la funci\u00f3n se determinan en cada invocaci\u00f3n a la funci\u00f3n, dependiendo del tipo del par\u00e1metro que se utiliza en la llamada: let tupla = ( 10 , \"Hola\" ) intercambia ( tupla ) // devuelve (\"Hola\", 10) let tupla2 = ( 10 , 20 ) intercambia ( tupla2 ) // devuelve (10, 20) let tupla3 = ( true , 10.5 ) intercambia ( tupla3 ) // devuelve (10.5, true) En el primer ejemplo, los tipos A y B se infieren como Int y String . En el segundo ejemplo como Int e Int . Y en el tercero como Bool y Double . Los tipos gen\u00e9ricos se pueden usar en la definici\u00f3n de todos los elementos de Swift: funciones, enums, estructuras, clases, protocolos o extensiones. Terminamos con un ejemplo en el que incluimos muchos conceptos vistos en este tema. Se trata de la implementaci\u00f3n en Swift de listas al estilo Scheme, con las funciones car , cdr y vacia usando un enum recursivo con un tipo gen\u00e9rico que permite generalizar el tipo de elementos de la lista. indirect enum Lista < T > { case vacia case nodo ( T , Lista < T >) } func car < T >( _ lista : Lista < T >) -> T ? { switch lista { case let . nodo ( primero , _ ): return primero case . vacia : return nil } } func cdr < T >( _ lista : Lista < T >) -> Lista < T >? { switch lista { case let . nodo ( _ , resto ): return resto case . vacia : return nil } } func vacia < T >( _ lista : Lista < T >) -> Bool { switch lista { case . vacia : return true default : return false } } let lista : Lista = . nodo ( 20 , . nodo ( 30 , . nodo ( 40 , . vacia ))) print ( car ( lista ) ! ) // Imprime 20 print ( car ( cdr ( lista ) ! ) ! ) // Imprime 30 print ( car ( cdr ( cdr ( lista ) ! ) ! ) ! ) // Imprime 40 print ( vacia ( cdr ( cdr ( cdr ( lista ) ! ) ! ) ! )) // Imprime true","title":"12. Gen\u00e9ricos"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#13-bibliografia","text":"Swift Language Guide The Basics Collection Types Functions Closures Enumerations Generics Biblioteca est\u00e1ndar de Swift Lenguajes y Paradigmas de Programaci\u00f3n, curso 2021\u201322 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Domingo Gallardo, Cristina Pomares, Antonio Bot\u00eda, Francisco Mart\u00ednez","title":"13. Bibliograf\u00eda"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html","text":"Tema 6: Programaci\u00f3n Orientada a Objetos con Swift \u00b6 1. Introducci\u00f3n a la Programaci\u00f3n Orientada a Objetos \u00b6 La Programaci\u00f3n Orientada a Objetos (POO) es un paradigma de programaci\u00f3n que explota en los 80 pero nace a partir de ideas a finales de los 60 y 70. Por ejemplo, el primer lenguaje con las ideas b\u00e1sicas de POO fue Simula , un lenguaje creado en la d\u00e9cada de los 60. En la d\u00e9cada de los 60 lo habitual era la programaci\u00f3n procedural. Los programas se defin\u00edan usando tipos de datos abstractos y funciones. La modularizaci\u00f3n se realizaba mediante funciones. Como hemos mencionado, a finales de los 60, el lenguaje Simula introduce el concepto de clase. Una abstracci\u00f3n que agrupa estado y funciones en una \u00fanica entidad. Sin embargo, tuvo que pasar m\u00e1s de una d\u00e9cada, hasta principios de los 80, para que el paradigma orientado a objetos se popularizara. Una de las razones principales de esta popularizaci\u00f3n fue el lenguaje Smalltalk , un lenguaje creado en Xerox PARC que fue revolucionario en muchos aspectos. Por ejemplo, Smaltallk introdujo conceptos como las interfaces gr\u00e1ficas de usuario (el uso del rat\u00f3n, de las ventanas) o un entorno integrado de programaci\u00f3n que estaba escrito en el propio Smalltalk y que el programador pod\u00eda adaptar y ampliar. En la figura de la derecha podemos ver un ejemplo del entorno, en el que se muestra un ejemplo de escritorio con m\u00faltiples ventanas que se solapan, men\u00fas desplegables, paneles gr\u00e1ficos, etc. Alan Kay fue uno de los padres de Smalltalk, el creador del t\u00e9rmino \u201cObject-Oriented\u201d y una de las figuras fundamentales de la historia de la inform\u00e1tica moderna. Trabaj\u00f3 en Xerox PARC y desarroll\u00f3 all\u00ed ideas que han sido clave para la inform\u00e1tica personal (como el Dynabook, precursor de tablets y dispositivos m\u00f3viles y el lenguajes de programaci\u00f3n Smalltalk). Se puede tener una idea de toda esta gesta en su art\u00edculo \u201cThe Early History of Smalltalk\u201d . Algunas frases de Alan Kay: \u201cI invented the term Object-Oriented and I can tell you I did not have C++ in mind.\u201d \u201cSmalltalk is not only NOT its syntax or the class library, it is not even about classes. I'm sorry that I long ago coined the term objects for this topic because it gets many people to focus on the lesser idea. The big idea is messaging.\u201d \u201cSmalltalk's design\u2013and existence\u2013is due to the insight that everything we can describe can be represented by the recursive composition of a single kind of behavioral building block that hides its combination of state and process inside itself and can be dealt with only through the exchange of messages.\u201d En la d\u00e9cada de los 80 el paradigma orientado a objetos tuvo una enorme repercusi\u00f3n y, a partir de ah\u00ed, casi todos los lenguajes lo han adoptado. Lenguajes como Smalltalk, Java, Scala, Ruby, Python, C#, C++, Swift, etc. utilizan el paradigma orientado a objetos. Entre las caracter\u00edsticas principales del paradigma de programaci\u00f3n orientado a objetos podemos destacar: Las clases son plantillas est\u00e1ticas definidas en tiempo de compilaci\u00f3n. Los objetos se instancian a partir de las clases y se modifican e interact\u00faan en tiempo de ejecuci\u00f3n. Los objetos agrupan estado interno (las denominadas propiedades , campos o variables de instancias ) y conducta (los m\u00e9todos a los que puede responder el objeto). Existe el polimorfismo . Un mismo m\u00e9todo puede estar definido en m\u00e1s de una clase. Dependiendo del tipo de la instancia el c\u00f3digo que se ejecuta es distinto. Por ejemplo, podr\u00edamos definir un m\u00e9todo suma en la clase Int y otro m\u00e9todo con el mismo nombre en otra clase String . El primer m\u00e9todo suma dos enteros y el segundo concatena dos cadenas. En algunos lenguajes orientados a objetos (como Python o Ruby) la invocaci\u00f3n los m\u00e9todos se hace usando un dispatch din\u00e1mico : cuando una operaci\u00f3n es invocada sobre un objeto, el propio objeto determina en tiempo de ejecuci\u00f3n qu\u00e9 c\u00f3digo se ejecuta. Una caracter\u00edstica fundamental de la POO es la herencia . Las clases se pueden definir utilizando otras clases como plantillas y modificando sus m\u00e9todos y/o variables de instancia para hacerlas m\u00e1s especializadas. Existen dos tendencias ortogonales en el dise\u00f1o de lenguajes orientados a objetos. Por un lado una familia de lenguajes orientados a objetos son lenguajes muy din\u00e1micos . Son lenguajes con un tipado d\u00e9bil en los que muchas caracter\u00edsticas de los programas se obtienen en tiempo de ejecuci\u00f3n. Estos lenguajes permiten mayor flexibilidad y generalidad del c\u00f3digo, y tienen caracter\u00edsticas como el dispatch din\u00e1mico o la reflexi\u00f3n (posibilidad de consultar caracter\u00edsticas de la instancia como nombres de m\u00e9todos o propiedades en tiempo de ejecuci\u00f3n). Ejemplos de este tipo de lenguajes son Smalltalk, Ruby, Python, JavaScript o Java (en menor medida). Por otro lado, existen lenguajes de programaci\u00f3n orientados a objetos que tienen un alto componente est\u00e1tico, donde la mayor\u00eda de caracter\u00edsticas del programa se obtienen en tiempo de compilaci\u00f3n. En este tipo de lenguajes se prima que el compilador sea muy robusto y detecte la mayor cantidad de errores a priori y que genere c\u00f3digo muy eficiente. Son lenguajes fuertemente tipados como C++ o Swift. Vamos a detallar a continuaci\u00f3n las caracter\u00edsticas m\u00e1s importantes de Programaci\u00f3n Orientada a Objetos de Swift. 2. Clases y estructuras \u00b6 En el caso de Swift, las clases y las estructuras son muchas m\u00e1s cercanas en funcionalidad que en otros lenguajes, como C o C++, y tienen muchas caracter\u00edsticas comunes. Muchas caracter\u00edsticas de las instancias de una clase se pueden aplicar tambi\u00e9n a las instancias de una estructura. Por eso en Swift se suele hablar de instancias (un t\u00e9rmino m\u00e1s general) en lugar de objetos . Las clases y las estructuras en Swift tienen muchas cosas en com\u00fan. Ambos pueden: Definir propiedades y almacenar valores Definir m\u00e9todos para proporcionar funcionalidad Definir sub\u00edndices para proporcionar acceso a sus valores usando una sintaxis de sub\u00edndice Definir inicializadores para configurar el estado inicial Ser extendidas para expandir su funcionalidad m\u00e1s all\u00e1 de una implementaci\u00f3n por defecto Ajustarse a un protocolo La diferencia fundamental es que las estructuras son tipos valor, mientras que las clases son tipos referencia. La sem\u00e1ntica de copia de ambas es radicalmente distinta. Cuando asignamos una instancia de una estructura a una variable estamos realizando una copia de su valor (por ejemplo, cuando asignamos un n\u00famero entero). Sin embargo, cuando asignamos una instancia de una clase a una variable estamos guardando su referencia. De esta forma en las clases se permiten que existan m\u00e1s de una referencia apuntando a una instancia de una clase. Otras caracter\u00edsticas adicionales de las clases que no tienen las estructuras: Mediante la herencia una clase puede heredar las caracter\u00edsticas de otra El casting de tipos permite comprobar e interpretar el tipo de una instancia de una clase en tiempo de ejecuci\u00f3n Los deinicializadores permiten a una instancia de una clase liberar los recursos que ha asignado 2.1. Definici\u00f3n \u00b6 class UnaClase { // definici\u00f3n de clase } struct UnaEstructura { // definici\u00f3n de una estructura } struct CoordsPantalla { var posX = 0 var posY = 0 } class Ventana { var esquina = CoordsPantalla () var altura = 0 var anchura = 0 var visible = true var etiqueta : String ? } El ejemplo define una nueva estructura llamada CoordsPantalla , que describe una coordenada de pantalla con posiciones basadas en p\u00edxeles. La estructura tiene dos propiedades almacenadas llamadas posX y posY . Las propiedades son constantes o variables que se almacenan en la instancia de la clase o de la estructura. El compilador infiere que estas dos propiedades son Int al inicializarlas a los valores iniciales de 0. El ejemplo tambi\u00e9n define una nueva clase llamada Ventana que describe una ventana en una pantalla. Esta clase tiene cinco propiedades variables. La primera, esquina , se inicializa con una instancia nueva de una estructura CoorsPantalla y se infiere que es de tipo CoordsPantalla . Representa la posici\u00f3n superior izquierda de la ventana. Las propiedades altura y anchura representan el n\u00famero de p\u00edxeles de las dimensiones de la pantalla. Se inicializan a 0. La propiedad visible es un Bool que indica si la ventana es visible en pantalla. Por ejemplo, una ventana que est\u00e9 minimizada no ser\u00e1 visible. Por \u00faltimo, etiqueta representa el nombre que aparece en la parte superior de la ventana. Es un String opcional que se inicializa a nil porque no se le asigna un valor inicial. 2.2. Instancias de clases y estructuras \u00b6 La definici\u00f3n de las estructuras y las clases \u00fanicamente definen sus aspectos generales. Para describir una configuraci\u00f3n espec\u00edfica (una resoluci\u00f3n o un modo de v\u00eddeo concreto) es necesario crear una instancia de una estructura o una clase. La sintaxis para crear ambas es similar: var unasCoordsPantalla = CoordsPantalla () var unaVentana = Ventana () La forma m\u00e1s sencilla de inicializaci\u00f3n es la anterior. Se utiliza el nombre del tipo de la clase o estructura seguidos de par\u00e9ntesis vac\u00edos. Esto crea una nueva instancia de una clase o estructura, con sus propiedades inicializadas a los valores por defecto definidos en la declaraci\u00f3n de las propiedades. Swift proporciona este inicializador por defecto para clases y estructuras, siempre que no se defina alg\u00fan inicializador expl\u00edcito. M\u00e1s adelante comentaremos c\u00f3mo definir estos inicializadores expl\u00edcitos. En el caso de la instancia unasCoordsPantalla los valores a los que se han inicializado sus propiedades son: unasCoordsPantalla . posX // 0 unasCoordsPantalla . posY // 0 Las propiedades de la instancia unaVentana son: unaVentana . esquina // CoordsPantalla con posX = 0 y posY = 0 unaVentana . altura // 0 unaVentana . anchura // 0 unaVentana . visible // true unaVentana . etiqueta // nil Todas las propiedades de una instancia deben estar definidas despu\u00e9s de haberse inicializado, a no ser que la propiedad sea un opcional. 2.3. Acceso a propiedades \u00b6 Se puede acceder y modificar las propiedades usando la sintaxis de punto : // Accedemos a la propiedad unasCoordsPantalla . posX // Devuelve 0 // Actualizamos la propiedad unasCoordsPantalla . posX = 100 unaVentana . esquina . posY = 100 2.4. Inicializaci\u00f3n de las estructuras por sus propiedades \u00b6 Si en las estructuras no se se definen inicializadores expl\u00edcitos (veremos m\u00e1s adelante c\u00f3mo hacerlo) podemos utilizar un inicializador memberwise en el que podemos proporcionar valores de sus propiedades. En las clases no existen los inicializadores memberwise , s\u00f3lo en las estructuras. Por ejemplo, podemos crear una instancia de la estructura anterior con valores distintos de los valores por defecto definidos en la propia estructura. let coords = CoordsPantalla ( posX : 200 , posY : 400 ) Cuando se llama al inicializador memberwise podemos omitir valores de cualquier propiedad que tenga un valor por defecto, o que sea un opcional. En el ejemplo anterior, la estructura CoordsPantalla tiene valores por defecto de las propiedades posX y posY . Podr\u00edamos omitir cualquier propiedad o ambas y el inicializador usar\u00e1 el valor por defecto de lo que omitamos. Por ejemplo: let coords1 = CoordsPantalla ( posX : 200 ) print ( coords1 . posX , coords1 . posY ) // Imprime 200 0 2.5. Estructuras y enumeraciones son tipos valor \u00b6 Un tipo valor es un tipo cuyo valor se copia cuando se asigna a una variable o constante, o cuando se pasa a una funci\u00f3n. Todos los tipos b\u00e1sicos de Swift -enteros, n\u00fameros en punto flotante, cadenas, arrays y diccionarios- son tipos valor y se implementan como estructuras. Las estructuras y las enumeraciones son tipos valor en Swift. 1 2 3 4 var coords1 = CoordsPantalla ( posX : 600 , posY : 600 ) var coords2 = coords1 coords2 . posX = 1000 coords1 . posX // devuelve 600 En el ejemplo se declara una constante llamada coords1 y se asigna a una instancia de CoordsPantalla inicializada con la posici\u00f3n x de 600 y la posici\u00f3n y de 600. Despu\u00e9s se declara una variable llamada coords2 y se asigna al valor actual de coors1 . Debido a que CoordsPantalla es una estructura, se crea una copia de la instancia existente y esta nueva copia se asigna a coords2 . Aunque ahora coords2 y coords1 tienen las mismas posX y posY , son dos instancias completamente distintas. Despu\u00e9s, la propiedad posX de coords2 se actualiza a 1000. Podemos comprobar que la propiedad se modifica, pero que el valor de posX en coords1 sigue siendo el mismo. 2.6. Las clases son tipos referencia \u00b6 A diferencia de los tipos valor, los tipos de referencias no se copian cuando se asignan o se pasan a funciones. En su lugar se usa una referencia a la misma instancia existente. En Swift las clases son tipos referencias. Veamos, por ejemplo, una instancia de la clase Ventana : 1 2 3 4 5 6 7 8 var ventana1 = Ventana () ventana1 . esquina = coords1 ventana1 . altura = 800 ventana1 . anchura = 800 ventana1 . etiqueta = \"Finder\" var ventana2 = ventana1 ventana2 . anchura = 1000 ventana1 . anchura // devuelve 1000 Declaramos una variable llamada ventana1 inicializada con una instancia nueva de la clase Ventana . Le asignamos a la propiedad esquina una copia de la resoluci\u00f3n anterior coords1 . Despu\u00e9s declaramos la altura, anchura y etiqueta de la ventana. Y, por \u00faltimo, ventana1 se asigna a una nueva constante llamada ventan2 , y la anchura se modifica. Debido a que son tipos de referencia, ventana1 y ventana2 se refieren a la misma instancia de Ventana . Son s\u00f3lo dos nombres distintos para la misma \u00fanica instancia. Lo podemos comprobar modificando una propiedad mediante una variable y viendo que esa misma propiedad en la otra variable se ha modificado tambi\u00e9n (l\u00edneas 7 y 8). Si tienes experiencia con C, C++, o Objective-C, puedes saber que estos lenguajes usan punteros para referirse a una direcci\u00f3n de memoria. Una constante o variable en Swift que se refiere a una instancia de un tipo referencia es similar a un puntero en C, pero no es un puntero que apunta a una direcci\u00f3n de memoria y no requiere que se escriba un asterisco (*) para indicar que estas creando una referencia. En su lugar, estas referencias se definen como cualquier otra constante o variable en Swift. 2.7. Declaraci\u00f3n de instancias con let \u00b6 Las estructuras y clases tambi\u00e9n tienen comportamientos distintos cuando se declaran las variables con let . Si definimos con let una instancia de una estructura estamos declarando constante la variable y todas las propiedades de la instancia. No podremos modificar ninguna: let coords3 = CoordsPantalla ( posX : 400 , posY : 400 ) coords3 . posX = 800 // error: cannot assign to property: 'coords3' is a 'let' constant Si definimos con un let una instancia de una clase s\u00f3lo estamos declarando constante la variable. No podremos reasignarla, pero s\u00ed que podremos modificar las propiedades de la instancia referenciada por la variable: let ventana3 = Ventana () // S\u00ed que podemos modificar una propiedad de la instancia: ventana3 . etiqueta = \"Listado\" // Pero no podemos reasignar la variable: ventana3 = ventana1 // error: cannot assign to value: 'ventana3' is a 'let' constant 2.8. Operadores de identidad \u00b6 A veces puede ser \u00fatil descubrir si dos constantes o variables se refieren exactamente a la misma instancia de una clase. Para permitir esto, Swift proporciona dos operadores de identidad: Id\u00e9ntico a ( === ) No id\u00e9ntico a ( !== ) ventana1 === ventana2 // devuelve true ventana1 === ventana3 // devuelve false Estos operadores \"id\u00e9ntico a\" no son los mismos que los de \"igual a\" (representado por dos signos iguales == ): \"Id\u00e9ntico a\" significa que dos constantes o variables de una clase se refieren exactamente a la misma instancia de la clase. \"Igual a\" significa que dos instancias se consideran \"iguales\" o \"equivalentes\" en su valor. Es responsabilidad del dise\u00f1ador de la clase definir la implementaci\u00f3n de estos operadores. 2.9. Paso como par\u00e1metro \u00b6 En Swift los par\u00e1metros de las funciones son constantes, se definen usando el operador let . Esto hace que sea muy distinto el comportamiento de un par\u00e1metro dependiendo de si es una estructura o una clase. Si la instancia que se pasa como par\u00e1metro a una funci\u00f3n es una estructura su contenido no se podr\u00e1 modificar. Sin embargo, si lo que se pasa es una instancia de una clase, podremos modificar su contenido, ya que (como hemos visto anteriormente) el let hace constante \u00fanicamente la referencia, pero no el contenido. Por ejemplo, la siguiente funci\u00f3n es t\u00edpica de programaci\u00f3n imperativa o procedural. El par\u00e1metro ventana se pasa por referencia y se modifica en el interior de la funci\u00f3n. Su estado cambia. Una vez terminada la funci\u00f3n la variable que hemos pasado como par\u00e1metro contiene una instancia cambiada. Podemos hacerlo porque ventana es una clase. func mueve ( ventana : Ventana , incX : Int , incY : Int ) { var nuevaPos = CoordsPantalla () nuevaPos . posX = ventana . esquina . posX + incX nuevaPos . posY = ventana . esquina . posY + incY ventana . esquina = nuevaPos } var ventana1 = Ventana () mueve ( ventana : ventana1 , incX : 500 , incY : 500 ) print ( ventana1 . esquina ) // Imprime: CoordsPantalla(posX: 500, posY: 500) Sin embargo, si pasamos como par\u00e1metro una instancia de una estructura, \u00e9sta ser\u00e1 inmutable. El siguiente c\u00f3digo genera un error en el compilador que indica que el par\u00e1metro coordsPantalla es una constante y no puede ser modificado: // \u00a1\u00a1C\u00d3DIGO ERR\u00d3NEO!! func mueve ( coordsPantalla : CoordsPantalla , incX : Int , incY : Int ) { coordsPantalla . posX = coordsPantalla . posX + incX coordsPantalla . posY = coordsPantalla . posY + incY } // error: cannot assign to property: 'coordsPantalla' is a 'let' constant Si necesitamos hacer una funci\u00f3n con la que se obtenga un valor modificado de una estructura, podemos usar el enfoque funcional de crear una nueva estructura y devolverla como resultado: func mueve ( coordsPantalla : CoordsPantalla , incX : Int , incY : Int ) -> CoordsPantalla { var nuevaCoord = CoordsPantalla () nuevaCoord . posX = coordsPantalla . posX + incX nuevaCoord . posY = coordsPantalla . posY + incY return nuevaCoord } let coord1 = CoordsPantalla () let coord2 = mueve ( coordsPantalla : coord1 , incX : 100 , incY : 100 ) print ( coord1 ) // Imprime CoordsPantalla(posX: 100, posY: 100) Vemos en el c\u00f3digo que se crea una nueva instancia y que se modifica su valor de forma acorde a lo que quiere hacer la funci\u00f3n y que se devuelve ese nuevo valor. Usando esta \u00faltima funci\u00f3n podr\u00edamos reescribir el c\u00f3digo de la funci\u00f3n que mueve una ventana de la siguiente forma: func mueve ( ventana : Ventana , incX : Int , incY : Int ) { ventana . esquina = mueve ( coordsPantalla : ventana . esquina , incX : incX , incY : incY ) } Nota Igual que en C, en Swift hay una forma de pasar como referencia una estructura. Hay que utilizar el operador inout precediendo el nombre del par\u00e1metro. Puedes encontrar m\u00e1s informaci\u00f3n en la documentaci\u00f3n oficial de Swift. Busca el apartado In-Out paremeters en la p\u00e1gina sobre Funciones . 2.10. Criterios para usar estructuras y clases \u00b6 Podemos usar tanto clases como estructuras para definir nuestros tipos de datos y utilizarlos como bloques de construcci\u00f3n del c\u00f3digo de nuestros programas. Sin embargo, se utilizan para distintos tipos de tareas. Como regla general, utilizaremos una estructura cuando se cumplen una o m\u00e1s de las siguientes condiciones: El principal objetivo de la estructura es encapsular unos pocos datos relativamente sencillos. Es razonable esperar que los valores encapsulados ser\u00e1n copiados, m\u00e1s que referenciados, cuando asignamos o pasamos una instancia de esa estructura. Todas las propiedades almacenadas en la estructura son a su vez tipos valor, que tambi\u00e9n se espera que sean copiados m\u00e1s que referenciados. La estructura no necesita heredar propiedades o conducta de otro tipo existente. Ejemplos de buenos candidatos de estructuras incluyen: El tama\u00f1o de una forma geom\u00e9trica, encapsulando por ejemplo las propiedades ancho y alto de tipo Double . Una forma de referirse a rangos dentro de una serie, encapsulando por ejemplo, una propiedad comienzo y otra longitud , ambos del tipo Int . Un punto en un sistema de coordenadas 3D, encapsulando quiz\u00e1s las propiedades x , y y z , todos ellos de tipo Double . Usaremos clases cuando queramos utilizar una sem\u00e1ntica de referencia en lugar de una sem\u00e1ntica de valor. Por ejemplo, si queremos tener un grafo de objetos en los que m\u00e1s de un objeto refiere a otro. Tambi\u00e9n cuando queramos utilizar herencia y polimorfismo en nuestro c\u00f3digo. En la pr\u00e1ctica, esto representa que la mayor\u00eda de datos que construiremos en nuestros programas ser\u00e1n clases, no estructuras. Aunque usaremos muchas de las estructuras est\u00e1ndar de Swift. 3. Propiedades \u00b6 Las propiedades asocian valores con una clase, estructura o enumeraci\u00f3n particular. Las propiedades almacenadas ( stored properties ) almacenan valores constantes y variables como parte de una instancia, mientras que las propiedades calculadas ( computed properties ) calculan (en lugar de almacenar) un valor. Las propiedades calculadas se definen en clases, estructuras y enumeraciones. Las propiedades almacenadas se definen s\u00f3lo en clases y estructuras. Enumeraciones: pueden contener s\u00f3lo propiedades calculadas. Clases y estructuras: pueden contener propiedades almacenadas y calculadas. Las propiedades calculadas y almacenadas se asocian habitualmente con instancias de un tipo particular. Sin embargo, las propiedades tambi\u00e9n pueden asociarse con el propio tipo. Estas propiedades se conocen como propiedades del tipo ( type properties ). Adem\u00e1s, en Swift es posible definir observadores de propiedades que monitoricen cambios en los valores de una propiedad, a los que podemos responder con acciones programadas. Los observadores de propiedades pueden a\u00f1adirse tanto a propiedades almacenadas definidas por nosotros como a propiedades heredadas de la superclase. 3.1. Propiedades almacenadas \u00b6 En su forma m\u00e1s simple, una propiedad almacenada es una constante o variable que est\u00e1 almacenada como parte de una instancia de una clase o estructura particular. Las propiedades almacenadas pueden ser o bien variables (usando la palabra clave var ) o bien constantes (usando la palabra clave let ). Podemos proporcionar un valor por defecto para la inicializaci\u00f3n de las propiedades almacenadas, tanto variables como constantes. El siguiente ejemplo define una estructura llamada RangoLongitudFija que describe un rango de valores enteros cuya longitud no puede ser modificada una vez que se crea: struct RangoLongitudFija { var primerValor : Int let longitud : Int } var rangoTresItems = RangoLongitudFija ( primerValor : 0 , longitud : 3 ) // el rango representa ahora 0, 1, 2 rangoTresItems . primerValor = 6 // el rango representa ahora 6, 7, 8 Las instancias de RangoLongitudFija tienen una propiedad almacenada variable llamada primerValor y una propiedad almacenada constante llamada longitud . En el ejemplo, longitud se inicializa cuando se crea el nuevo rango y no puede ser cambiada en el futuro, por ser una propiedad constante. 3.2. Propiedades calculadas \u00b6 Adem\u00e1s de las propiedades almacenadas, las clases, estructuras y enumeraciones pueden definir propiedades calculadas , que no almacenan realmente un valor. En su lugar, proporcionan un getter y un opcional setter que devuelven y modifican otras propiedades y valores de forma indirecta. struct Punto { var x = 0.0 , y = 0.0 } struct Tama\u00f1o { var ancho = 0.0 , alto = 0.0 } struct Rectangulo { var origen = Punto () var tama\u00f1o = Tama\u00f1o () var centro : Punto { get { let centroX = origen . x + ( tama\u00f1o . ancho / 2 ) let centroY = origen . y + ( tama\u00f1o . alto / 2 ) return Punto ( x : centroX , y : centroY ) } set ( centroNuevo ) { origen . x = centroNuevo . x - ( tama\u00f1o . ancho / 2 ) origen . y = centroNuevo . y - ( tama\u00f1o . alto / 2 ) } } } var cuadrado = Rectangulo ( origen : Punto ( x : 0.0 , y : 0.0 ), tama\u00f1o : Tama\u00f1o ( ancho : 10.0 , alto : 10.0 )) let centroCuadradoInicial = cuadrado . centro cuadrado . centro = Punto ( x : 15.0 , y : 15.0 ) print ( \"cuadrado.origen est\u00e1 ahora en ( \\( cuadrado . origen . x ) , \\( cuadrado . origen . y ) )\" ) // Imprime \"cuadrado.origen est\u00e1 ahora en (10.0, 10.0)\" Este ejemplo define tres estructuras para trabajar con formas geom\u00e9tricas: Punto encapsula una coordenada (x, y) Tama\u00f1o encapsula un ancho y un alto Rectangulo define una rect\u00e1ngulo por un punto de origen y un tama\u00f1o La estructura Rectangulo proporciona una propiedad calculada llamada centro . La posici\u00f3n actual del centro de un Rectangulo puede ser siempre determinada a partir de su origen y su tama\u00f1o, por lo que no necesitamos almacenarlo como un Punto expl\u00edcito. En su lugar, Rectangulo define un getter y un setter programado para una variable calculada llamada centro , para permitirnos trabajar con el centro del rect\u00e1ngulo como si fuera una propiedad almacenada. En el ejemplo se crea una variable Rectangulo llamada cuadrado . La variable cuadrado se inicializa un punto origen de (0, 0) y un ancho y tama\u00f1o de 10 . Este cuadrado est\u00e1 representado por el cuadrado azul en el diagrama de abajo. Accedemos entonces a la propiedad centro de la variable cuadrado usando la sintaxis del punto ( cuadrado.centro ), lo que causa que se llame al getter de centro para devolver el valor actual de la propiedad. En lugar de devolver los valores existentes, el getter calcula realmente y devuelve un nuevo Punto para representar el centro del cuadrado. Como puede verse arriba, el getter devuelve correctamente un punto con los valores (5, 5) . Despu\u00e9s la propiedad centro se actualiza al nuevo valor de (15, 15) lo que mueve el cuadrado arriba a la derecha, a la nueva posici\u00f3n mostrada por el cuadrado naranja en el diagrama de abajo. Al asignar el nuevo valor a la propiedad se llama al setter del centro, lo que modifica los valores x e y de las propiedades almacenadas originales, y mueve el cuadrado a su nueva posici\u00f3n. Se puede definir una versi\u00f3n acortada del setter usando la variable por defecto newValue que contiene el nuevo valor asignado en el setter : struct Rectangulo { var origen = Punto () var tama\u00f1o = Tama\u00f1o () var centro : Punto { get { let centroX = origen . x + ( tama\u00f1o . ancho / 2 ) let centroY = origen . y + ( tama\u00f1o . alto / 2 ) return Punto ( x : centroX , y : centroY ) } set { origen . x = newValue . x - ( tama\u00f1o . ancho / 2 ) origen . y = newValue . y - ( tama\u00f1o . alto / 2 ) } } } 3.3. Propiedades solo-lectura \u00b6 Una propiedad calculada con un getter y sin setter se conoce como una propiedad calculada de solo-lectura. Una propiedad calculada de solo-lectura siempre devuelve un valor, y puede accederse a ella usando la sintaxis de punto, pero no puede modificarse a un valor distinto. Es posible simplificar la declaraci\u00f3n de una propiedad calculada de solo-lectura eliminando la palabra clave get y sus llaves: struct Cuboide { var ancho = 0.0 , alto = 0.0 , profundo = 0.0 var volumen : Double { return ancho * alto * profundo } } let cuatroPorCincoPorDos = Cuboide ( ancho : 4.0 , alto : 5.0 , profundo : 2.0 ) print ( \"el volumen de cuatroPorCincoPorDos es \\( cuatroPorCincoPorDos . volumen ) \" ) // Imprime \"el volumen de cuatroPorCincoPorDos es 40.0\" Este ejemplo define una nueva estructura llamada Cubiode , que representa una caja rectangular 3D con propiedades ancho , alto y profundo . Esta estructura tiene una propiedad calculada llamada volumen , que calcula y devuelve el volumen actual del cuboide. No tendr\u00eda sentido que el volumen fuera modificable, porque no ser\u00eda ambiguo determinar qu\u00e9 valores concretos de ancho, alto y profundo deber\u00edan usarse para un valor particular del volumen. 3.4. Observadores de propiedades \u00b6 Los observadores de propiedades ( property observers ) observan y responden a cambios en el valor de una propiedad. Los observadores de propiedades se llaman cada vez que el valor de una propiedad es actualizado, incluso si el nuevo valor es el mismo que el valor actual de la propiedad. Se pueden a\u00f1adir observadores a cualquier propiedad almacenada que se definan. Se pueden tambi\u00e9n a\u00f1adir observadores a cualquier propiedad heredada (ya sea almacenada o calculada) sobreescribiendo la propiedad en la subclase. No es necesario definir observadores de propiedades calculadas no sobreescritas porque siempre es posible observar y responder a cambios en su valor en el setter de la propiedad. Es posible definir alguno o ambos de estos observadores sobre una propiedad: willSet es llamado justo antes de que el nuevo valor se almacena en la propiedad. didSet es llamado inmediatamente despu\u00e9s de que el nuevo valor es almacenado en la propiedad. Si implementamos un observador willSet , se le pasa el nuevo valor de la propiedad como un par\u00e1metro constante. Podemos especificar un nombre para este par\u00e1metro como parte de la implementaci\u00f3n de willSet . Si no escribimos el nombre del par\u00e1metro y los par\u00e9ntesis dentro de la implementaci\u00f3n, el par\u00e1metro estar\u00e1 disponible con el nombre por defecto de newValue . De forma similar, si implementamos un observador didSet , se pasa como un par\u00e1metro constante que contiene el valor antiguo de la propiedad. Podemos darle nombre al par\u00e1metro o usar el nombre por defecto de oldValue . Si asignamos un valor a la propiedad dentro de su propio observador didSet , el nuevo valor que asignamos reemplaza el que acaba de a\u00f1adirse a la propiedad. A continuaci\u00f3n podemos ver un ejemplo de willSet y didSet en acci\u00f3n. En \u00e9l definimos una clase nueva llamada CuentaPasos , que hace un seguimiento del n\u00famero total de pasos que una persona hace al caminar. Esta clase puede usarse con datos de entrada de un pod\u00f3metro o cualquier otro sistema de seguir el ejercicio de la persona durante su rutina diaria. class ContadorPasos { var totalPasos : Int = 0 { willSet ( nuevoTotalPasos ) { print ( \"Voy a actualizar totalPasos a \\( nuevoTotalPasos ) \" ) } didSet { if totalPasos > oldValue { print ( \"A\u00f1adidos \\( totalPasos - oldValue ) pasos\" ) } } } } let contadorPasos = ContadorPasos () contadorPasos . totalPasos = 200 // Imprime: \"Voy a actualizar totalPasos a 200\" // Imprime: \"A\u00f1adidos 200 pasos\" contadorPasos . totalPasos = 360 // Imprime: \"Voy a actualizar totalPasos a 360\" // Imprime: \"A\u00f1adidos 160 pasos\" contadorPasos . totalPasos = 896 // Imprime: \"Voy a actualizar totalPasos a 896\" // Imprime: \"A\u00f1adidos 536 pasos\" La clase CuentaPasos declara la propiedad totalPasos de tipo Int . Esta es una propiedad almacenada con observadores willSet y didSet . Los observadores willSet y didSet de totalPasos se llaman siempre que se le asigna un nuevo valor a la propiedad. Esto es as\u00ed incluso si el nuevo valor es el mismo que el valor actual. El observador willSet usa un par\u00e1metro definido por nosotros con el nombre de nuevoTotalPasos para el valor que llega. En el ejemplo, sencillamente imprime el valor que est\u00e1 a punto de establecer. El observador didSet se llama despu\u00e9s de que el valor de totalPasos se ha actualizado. Compara el nuevo valor de totalPasos con el valor antiguo. Si el n\u00famero total de pasos se ha incrementado, se imprime un mensaje indicando cu\u00e1ntos pasos se han tomado. El observador didSet no proporciona un par\u00e1metro definido por nosotros para el valor antiguo, sino que usa el nombre por defecto oldValue . 3.5. Variables locales y globales \u00b6 Las capacidades anteriores de propiedades calculadas y de observadores tambi\u00e9n est\u00e1n disponibles para variables globales y locales. El siguiente ejemplo muestra un ejemplo con una variable calculada a partir de otras dos: var x = 10 { didSet { print ( \"El nuevo valor: \\( x ) y el valor antiguo: \\( oldValue ) \" ) } } var y = 2 * x var z : Int { get { return x + y } set { x = newValue / 2 y = newValue / 2 } } print ( z ) z = 100 print ( x ) 3.6. Propiedades del tipo \u00b6 Las propiedades de las instancias son propiedades que pertenecen a una instancia de un tipo particular. Cada vez que creamos una nueva instancia de ese tipo, tiene su propio conjunto de valores de propiedades, separados de los de cualquier otra instancia. Podemos definir tambi\u00e9n propiedades que pertenecen al tipo propiamente dicho, no a ninguna de las instancias de ese tipo. S\u00f3lo habr\u00e1 una copia de estas propiedades, sea cual sea el n\u00famero de instancias de ese tipo que creemos. Estos tipos de propiedades se llaman propiedades del tipo ( type propierties ). Se pueden definir en tanto en estructuras, clases como en enumeraciones. Las propiedades del tipo son \u00fatiles para definir valores que son universales a todas las instancias de un tipo particular, como una propiedad constante que todas las instancias pueden usar (como una constante est\u00e1tica en C), o una propiedad variable que almacena un valor que es global a todas las instancias de ese tipo (como una variable est\u00e1tica en C). Las propiedades del tipo almacenadas pueden ser variables o constantes. Las propiedades del tipo calculadas se declaran siempre como propiedades variables, de la misma forma que las propiedades calculadas de instancias. A diferencia de las propiedades almacenadas de instancias, debemos siempre proporcionar un valor por defecto para las propiedades almacenadas de tipo. Esto es debido a que el tipo por si mismo no tiene un inicializador que pueda asignar un valor en tiempo de inicializaci\u00f3n. En Swift, las propiedades del tipo se definen como parte de la definici\u00f3n del tipo, dentro de las llaves del tipo. Las propiedades del tipo toman valor en el \u00e1mbito del tipo. Para definir una propiedad del tipo hay que usar la palabra clave static . Para propiedades de tipo calculadas de clases, podemos usar en su lugar la palabra clave class para permitir a las subclases que sobreescriban la implementaci\u00f3n de la superclase. Las propiedades del tipo pueden ser tambi\u00e9n constantes ( let ) o variables ( var ). Ejemplo: struct UnaEstructura { static var almacenada = \"A\" static var calculada : Int { return 1 } } enum UnaEnumeracion { static var almacenada = \"A\" static var calculada : Int { return 1 } } class UnaClase { static var almacenada = \"A\" static var calculada : Int { return 1 } } Las propiedades del tipo se consultan y actualizan usando tambi\u00e9n la sintaxis de punto, pero sobre el tipo : UnaEstructura . almacenada // devuelve \"A\" UnaEstructura . almacenada = \"B\" UnaClase . calculada // devuelve 1 No es posible acceder a la variable del tipo a trav\u00e9s de una instancia: let a = UnaEstructura () a . almacenada // error El siguiente ejemplo muestra c\u00f3mo es posible usar una variable del tipo para almacenar informaci\u00f3n global a todas las instancias de ese tipo: struct Valor { var valor : Int = 0 { didSet { Valor . sumaValores += valor } } static var sumaValores = 0 } var c1 = Valor () var c2 = Valor () var c3 = Valor () c1 . valor = 10 c2 . valor = 20 c3 . valor = 30 print ( \"Suma de los cambios de valores: \\( Valor . sumaValores ) \" ) // Imprime 60 4. M\u00e9todos \u00b6 Los m\u00e9todos son funciones que est\u00e1n asociadas a un tipo particular. Las clases, estructuras y enumeraciones pueden definir todas ellas m\u00e9todos de instancia, que encapsulan tareas y funcionalidades espec\u00edficas que trabajan con una instancia de un tipo dado. Las clases, estructuras y enumeraciones tambi\u00e9n pueden definir m\u00e9todos del tipo, que est\u00e1n asociados con el propio tipo. Los m\u00e9todos del tipo son similares a los m\u00e9todos de clase en Java. El hecho de que las estructuras y las enumeraciones puedan definir m\u00e9todos en Swift es una diferencia importante con C y Objective-C. 4.1. M\u00e9todos de instancia \u00b6 Los m\u00e9todos de instancia son funciones que pertenecen a instancias de una clase, estructura o enumeraci\u00f3n. Proporcionan la funcionalidad de esas instancias, bien proporcionando formas de acceder y modificar propiedades de las instancias, o bien proporcionando funcionalidades relacionadas con el prop\u00f3sito de la instancia. Los m\u00e9todos de instancia tienen exactamente la misma sintaxis que las funciones. Los m\u00e9todos de instancia se escriben dentro de las llaves del tipo al que pertenecen. Un m\u00e9todo de instancia tiene acceso impl\u00edcito a todos los otros m\u00e9todos de instancia y propiedades del tipo. Un m\u00e9todo de instancia puede ser invocado s\u00f3lo sobre una instancia espec\u00edfica del tipo al que pertenece. No puede ser invocado de forma aislada sin una instancia existente. A continuaci\u00f3n podemos ver un ejemplo que define una sencilla clase Contador , que puede usarse para contar el n\u00famero de veces que sucede una acci\u00f3n: class Contador { var veces = 0 func incrementa () { veces += 1 } func incrementa ( en cantidad : Int ) { veces += cantidad } func reset () { veces = 0 } } Y un ejemplo de uso: let contador = Contador () // el valor inicial del contador es 0 contador . incrementa () // el valor del contador es ahora 1 contador . incrementa ( en : 5 ) // el valor del contador es ahora 6 contador . reset () // el valor del contador es ahora 0 En el ejemplo anterior, los m\u00e9todos no devuelven ning\u00fan valor. Podemos modificar el ejemplo para que los m\u00e9todos devuelvan el valor actualizado del contador: class Contador { var veces = 0 func incrementa () -> Int { veces += 1 return veces } func incrementa ( en cantidad : Int ) -> Int { veces += cantidad return veces } func reset () -> Int { veces = 0 return veces } } 4.2. Nombres locales y externos de par\u00e1metros \u00b6 Ya vimos que los par\u00e1metros de las funciones pueden tener un nombre interno y un nombre externo. Lo mismo sucede con los m\u00e9todos, porque los m\u00e9todos no son m\u00e1s que funciones asociadas con un tipo. Los nombres de los m\u00e9todos en Swift se refieren normalmente al primer par\u00e1metro usando una preposici\u00f3n como con , en , a o por , como hemos visto en el ejemplo anterior incrementa(en:) . El uso de la preposici\u00f3n permite que el m\u00e9todo se lea como una frase. El nombre de un par\u00e1metro se utiliza tambi\u00e9n como etiqueta del argumento (nombre externo). Al igual que en las funciones, es posible definir dos nombres del par\u00e1metro, uno externo y otro interno. Y el nombre externo puede ser un _ para indicar que no es necesario usar la etiqueta del argumento. Esta forma de invocar a los m\u00e9todos hace que el lenguaje sea m\u00e1s expresivo, sin necesidad de nombres largos de m\u00e9todos o funciones. Consideremos por ejemplo esta versi\u00f3n alternativa de la clase Contador , que define una forma m\u00e1s compleja del m\u00e9todo incrementa(en:) : class Contador { var veces = 0 func incrementa ( en cantidad : Int , numeroDeVeces : Int ) { veces += cantidad * numeroDeVeces } } El m\u00e9todo incrementa(en:numeroDeVeces:) tiene dos par\u00e1metros: cantidad y numeroDeVeces . El primer par\u00e1metro tiene un nombre externo y otro interno. En el cuerpo del m\u00e9todo se utiliza el nombre interno ( cantidad ). El segundo par\u00e1metro numeroDeVeces es tanto nombre externo como interno. Podemos llamar al m\u00e9todo de la siguiente forma: let contador = Contador () contador . incrementa ( en : 5 , numeroDeVeces : 3 ) // el valor del contador es ahora 15 Al igual que en las funciones, podemos definir expl\u00edcitamente los nombres externos de los par\u00e1metros y usar el subrayado ( _ ) para indicar que ese par\u00e1metro no tendr\u00e1 nombre externo. 4.3. La propiedad self \u00b6 Toda instancia de un tipo tiene una propiedad impl\u00edcita llamada self , que es exactamente equivalente a la instancia misma. Podemos usar la propiedad self para referirnos a la instancia actual dentro de sus propios m\u00e9todos de instancia. El m\u00e9todo incrementa() en el ejemplo anterior podr\u00eda haberse escrito de esta forma: class Contador { var veces = 0 func incrementa () { self . veces += 1 } } En la pr\u00e1ctica no es necesario usar self casi nunca. Swift asume que cualquier referencia a una propiedad dentro de un m\u00e9todo se refiere a la propiedad de la instancia. Es obligado usarlo es cuando el nombre de la propiedad coincide con el nombre de un par\u00e1metro. En esta situaci\u00f3n el nombre del par\u00e1metro toma precedencia y es necesario usar self para poder referirse a la propiedad de la instancia. Un ejemplo: struct Punto { var x = 0.0 , y = 0.0 func estaAlaDerecha ( de x : Double ) -> Bool { return self . x > x } } let unPunto = Punto ( x : 4.0 , y : 5.0 ) if unPunto . estaAlaDerecha ( de : 1.0 ) { print ( \"Este punto est\u00e1 a la derecha de la l\u00ednea donde x == 1.0\" ) } // Imprime \"Este punto est\u00e1 a la derecha de la l\u00ednea donde x == 1.0\" 4.4. Operaciones con instancias de tipo valor \u00b6 Las estructuras y las enumeraciones son tipos valor . Por defecto, las propiedades de un tipo valor no pueden ser modificadas desde dentro de los m\u00e9todos de instancia. Si queremos modificar una propiedad de un tipo valor la forma m\u00e1s natural de hacerlo es creando una instancia nueva, usando el estilo de programaci\u00f3n funcional: struct Punto { var x = 0.0 , y = 0.0 func incrementado ( incX : Double , incY : Double ) -> Punto { return Punto ( x : x + incX , y : y + incY ) } } let unPunto = Punto ( x : 1.0 , y : 1.0 ) var puntoMovido = unPunto . incrementado ( incX : 2.0 , incY : 3.0 ) print ( \"Hemos movido el punto a ( \\( puntoMovido . x ) , \\( puntoMovido . y ) )\" ) // Imprime \"Hemos movido el punto a (3.0, 4.0)\" Nota En la biblioteca est\u00e1ndar de Swift se utiliza el convenio de nombrar los m\u00e9todos no mutadores (que devuelven un objeto nuevo) con el verbo en participio ( array.sorted() ) y los m\u00e9todos mutadores (que modifican la propia estructura y no devuelven nada) con el verbo en imperativo ( array.sort() ). 4.5. Modificaci\u00f3n de tipos valor desde dentro de la instancia \u00b6 Sin embargo, hay ocasiones en las que necesitamos modificar las propiedades de nuestra estructura o enumeraci\u00f3n dentro de un m\u00e9todo particular. Necesitamos conseguir una conducta mutadora para ese m\u00e9todo. El m\u00e9todo puede mutar (esto es, cambiar) sus propiedades desde dentro del m\u00e9todo, as\u00ed como asignar una instancia completamente nueva a su propiedad impl\u00edcita self , con lo que esta nueva instancia reemplazar\u00e1 la existente cuando el m\u00e9todo termine. Podemos conseguir esta conducta colocando la palabra clave mutating antes de la palabra func del m\u00e9todo: struct Punto { var x = 0.0 , y = 0.0 mutating func incrementa ( incX : Double , incY : Double ) { x += incX y += incY } } var unPunto = Punto ( x : 1.0 , y : 1.0 ) unPunto . incrementa ( incX : 2.0 , incY : 3.0 ) print ( \"El punto est\u00e1 ahora en ( \\( unPunto . x ) , \\( unPunto . y ) )\" ) // Imprime \"El punto est\u00e1 ahora en (3.0, 4.0)\" La estructura Punto anterior define un m\u00e9todo mutador incrementa(incX:incY:) que mueve una instancia de Punto una cierta cantidad. En lugar de devolver un nuevo punto, el m\u00e9todo modifica realmente el punto en el que es llamado. La palabra clave mutating se a\u00f1ade a su definici\u00f3n para permitirle modificar sus propiedades. Hay que hacer notar que no es posible llamar a un m\u00e9todo mutador sobre una constante de un tipo estructura, porque sus propiedades no se pueden cambiar, incluso aunque sean propiedades variables: let puntoFijo = Punto ( x : 3.0 , y : 3.0 ) puntoFijo . incrementa ( incX : 2.0 , incY : 3.0 ) // esto provocar\u00e1 un error 4.6. Asignaci\u00f3n a self en un m\u00e9todo mutador \u00b6 Los m\u00e9todos mutadores pueden asignar una nueva instancia completamente nueva a la propiedad self . El anterior ejemplo Punto podr\u00eda habers escrito de la siguiente forma: struct Punto { var x = 0.0 , y = 0.0 mutating func incrementa ( incX : Double , incY : Double ) { self = Punto ( x : x + incX , y : y + incY ) } } Esta versi\u00f3n del m\u00e9todo mutador incrementa(incX:incY:) crea una estructura nueva cuyos valores x e y se inicializan a los valores deseados. El resutado final de llamar a esta versi\u00f3n alternativa ser\u00e1 exactamente el mismo que llamar a la versi\u00f3n anterior (aunque con una peque\u00f1a penalizaci\u00f3n de eficiencia: este m\u00e9todo es 1,3 veces m\u00e1s lento que el anterior en la versi\u00f3n 2.2 del compilador de Swift). Los m\u00e9todos mutadores de enumeraciones pueden establecer el par\u00e1metro self impl\u00edcito para que tenga un subtipo distinto de la misma enumeraci\u00f3n: enum InterruptorTriEstado { case apagado , medio , alto mutating func siguiente () { switch self { case . apagado : self = . medio case . medio : self = . alto case . alto : self = . apagado } } } var luzHorno = InterruptorTriEstado . medio luzHorno . siguiente () // luzHorno es ahora .alto luzHorno . siguiente () // luzHorno es ahora .apagado 4.7. M\u00e9todos del tipo \u00b6 Los m\u00e9todos de instancia, como los descritos antes, se llaman en instancias de un tipo particular. Es posible tambi\u00e9n definir m\u00e9todos que se llaman en el propio tipo. Esta clase de m\u00e9todos se denominan m\u00e9todos del tipo . Se define un m\u00e9todo del tipo escribiendo la palabra clave static antes de la palabra clave func del m\u00e9todo. Las clases tambi\u00e9n pueden usar la palabra clave class para permitir a las subclases sobreescribir la implementaci\u00f3n del m\u00e9todo. Los m\u00e9todos del tipo se invocan tambi\u00e9n con la sintaxis de punto, escribiendo el nombre del tipo. Por ejemplo: class NuevaClase { static func unMetodoDelTipo () { print ( \"Hola desde el tipo\" ) } } NuevaClase . unMetodoDelTipo () Dentro del cuerpo del m\u00e9todo, la propiedad impl\u00edcita self se refiere al propio tipo, m\u00e1s que a una instancia de ese tipo. Para clases, estructuras y enumeraciones, esto significa que puedes usar self para desambiguar entre propiedades del tipo y los par\u00e1metros del m\u00e9todo, de la misma forma que se hace en los m\u00e9todos de instancias. Cualquier nombre de m\u00e9todo o propiedad que se utilice en el cuerpo de un m\u00e9todo del tipo se referir\u00e1 a otras propiedades o m\u00e9todos de nivel del tipo. Se puede utilizar estos nombres sin necesidad de a\u00f1adir el prefijo del nombre del tipo. Por ejemplo, podemos a\u00f1adir a la clase Ventana una propiedad y m\u00e9todo de clase con la que almacenar instancias de ventanas. Inicialmente guardamos un array vac\u00edo. class Ventana { // Propiedades static var ventanas : [ Ventana ] = [] static func registrar ( ventana : Ventana ) { ventanas . append ( ventana ) } } Cada vez que creamos una ventana podemos llamar al m\u00e9todo registrar de la clase para a\u00f1adirlo a la colecci\u00f3n de ventanas de la clase: let v1 = Ventana () Ventana . registrar ( ventana : v1 ) print ( \"Se han registrado \\( Ventana . ventanas . count ) ventanas\" ) // Imprime \"Se han registrado 1 ventanas\" 5. Inicializaci\u00f3n \u00b6 Inicializaci\u00f3n es el proceso de preparar para su uso una instancia de una clase, estructura o enumeraci\u00f3n. Este proceso incluye la asignaci\u00f3n de un valor inicial para cada propiedad almacenada y la ejecuci\u00f3n de cualquier otra operaci\u00f3n de inicializaci\u00f3n que se necesite para que la nueva instancia est\u00e9 lista para usarse. Para implementar este proceso de inicializaci\u00f3n hay que definir inicializadores , que son como m\u00e9todos especiales que pueden llamarse para crear una nueva instancia de un tipo particular. A diferencia de otros lenguajes, los inicializadores en Swift no devuelven un valor. Su papel principal es que las nuevas instancias del tipo est\u00e9n correctamente inicializadas antes de poder ser usadas por primera vez. Tambi\u00e9n es posible implementar deinicializadores , m\u00e9todos que se ejecutan cuando las instancias son eliminadas de la memoria (no vamos a explicarlos por falta de tiempo). El proceso de inicializaci\u00f3n de una instancia puede resultar un proceso complicado, sobre todo cuando se tienen relaciones de herencia y hay que especificar tambi\u00e9n c\u00f3mo realizar la inicializaci\u00f3n de la subclase utilizando la superclase. Por falta de tiempo no vamos a explicar todo el proceso completo. Recomendamos consultar la documentaci\u00f3n original de Swift . 5.1. Inicializadores por defecto y memberwise \u00b6 Ya hemos visto que es posible inicializar clases y estructuras definiendo valores por defecto a todas sus propiedades (con la posible excepci\u00f3n de las que tienen un tipo opcional). En ese caso, podemos no definir ning\u00fan inicializador y usar el inicializador por defecto que proporciona Swift. struct Punto2D { var x = 0.0 var y = 0.0 } class Segmento { var p1 = Punto2D () var p2 = Punto2D () } var s = Segmento () Tambi\u00e9n es posible en las estructuras utilizar el inicializador memberwise , en el que especificamos todos los valores de las propiedades: var p = Punto2D ( x : 10.0 , y : 10.0 ) Los inicializadores por defecto y memberwise desaparecen en el momento en que definimos alg\u00fan inicializador con la palabra init . Veamos c\u00f3mo definir inicializadores. 5.2. Inicializaci\u00f3n de propiedades almacenadas \u00b6 Como hemos dicho, las clases y estructuras deben definir todas sus propiedades almacenadas a un valor inicial en el momento en que la instancia se crea, a no ser que \u00e9stas sean opcionales, en cuyo caso quedar\u00edan inicializadas a nil . Podemos definir el valor inicial para una propiedad en un inicializador o asign\u00e1ndole un valor por defecto como parte de la definici\u00f3n de la propiedad. Un inicializador , en su forma m\u00e1s simple se escribe con la palabra clave init : init () { // realizar alguna inicializaci\u00f3n aqu\u00ed } Por ejemplo, podemos definir la estructura Farenheit que almacena una temperatura en grados Farenheit. Tiene una propiedad almacenada de tipo Double . Definimos un inicializador que inicializa las instancias a 32.0 (equivalente a 0.0 grados Celsius). struct Fahrenheit { var temperatura : Double init () { temperatura = 32.0 } } var f = Fahrenheit () print ( \"La temperatura por defecto es \\( f . temperatura ) Fahrenheit\" ) // Imprime \"La temperatura por defecto es 32.0\u00b0 Fahrenheit\" La implementaci\u00f3n anterior es equivalente a la que ya hemos visto con el inicializador por defecto: struct Fahrenheit { var temperatura = 32.0 } 5.3. Inicializadores personalizados \u00b6 Podemos proporcionar par\u00e1metros de inicializaci\u00f3n como parte de la definici\u00f3n de un inicializador, para definir los tipos y los nombres de los valores que personalizan el proceso de inicializaci\u00f3n. Los par\u00e1metros de inicializaci\u00f3n tienen las mismas capacidades y sintaxis que los par\u00e1metros de funciones y m\u00e9todos. struct Celsius { var temperaturaEnCelsius : Double init ( desdeFahrenheit fahrenheit : Double ) { temperaturaEnCelsius = ( fahrenheit - 32.0 ) / 1.8 } init ( desdeKelvin kelvin : Double ) { temperaturaEnCelsius = kelvin - 273.15 } } let puntoDeEbullicionDelAgua = Celsius ( desdeFahrenheit : 212.0 ) // puntoDeEbullicionDelAgua.temperaturaEnCelsius es 100.0 let puntoDeCongelacionDelAgua = Celsius ( desdeKelvin : 273.15 ) // puntoDeCongelacionDelAgua.temperaturaEnCelsius is 0.0 Vemos que dependiendo del nombre de par\u00e1metro proporcionado se escoge un inicializador u otro. En los inicializadores es obligatorio proporcionar los nombres de todos los par\u00e1metros: struct Color { let rojo , verde , azul : Double init ( rojo : Double , verde : Double , azul : Double ) { self . rojo = rojo self . verde = verde self . azul = azul } init ( blanco : Double ) { rojo = blanco verde = blanco azul = blanco } } let magenta = Color ( rojo : 1.0 , verde : 0.0 , azul : 1.0 ) let medioGris = Color ( blanco : 0.5 ) Podemos evitar proporcionar nombres externos usando un subrayado. Por ejemplo, podemos a\u00f1adir al struct anterior Celsius un inicializador sin nombre externo para el caso en que pasemos la temperatura inicial precisamente en Celsius: struct Celsius { var temperaturaEnCelsius : Double init ( desdeFahrenheit fahrenheit : Double ) { temperaturaEnCelsius = ( fahrenheit - 32.0 ) / 1.8 } init ( desdeKelvin kelvin : Double ) { temperaturaEnCelsius = kelvin - 273.15 } init ( _ celsius : Double ) { temperaturaEnCelsius = celsius } } let temperaturaCuerpo = Celsius ( 37.0 ) // temperaturaCuerpo.temperaturaEnCelsius es 37.0 Por \u00faltimo, es posible inicializar propiedades constantes definidas con let . S\u00f3lo toman valor en el momento de la inicializaci\u00f3n y despu\u00e9s no pueden modificarse. class PreguntaEncuesta { let texto : String var respuesta : String ? init ( texto : String ) { self . texto = texto } func pregunta () { print ( texto ) } } let preguntaQueso = PreguntaEncuesta ( texto : \"\u00bfTe gusta el queso?\" ) preguntaQueso . pregunta () // -> \"\u00bfTe gusta el queso? preguntaQueso . respuesta // -> nil La propiedad respuesta se inicializa a nil al ser un opcional y no inicializarla en el inicializador. Por \u00faltimo, es posible definir m\u00e1s de un inicializador, as\u00ed como invocar a inicializadores m\u00e1s b\u00e1sicos desde otros. struct Rectangulo { var origen = Punto () var tama\u00f1o = Tama\u00f1o () init (){} init ( origen : Punto , tama\u00f1o : Tama\u00f1o ) { self . origen = origen self . tama\u00f1o = tama\u00f1o } init ( centro : Punto , tama\u00f1o : Tama\u00f1o ) { let origenX = centro . x - ( tama\u00f1o . ancho / 2 ) let origenY = centro . y - ( tama\u00f1o . ancho / 2 ) self . init ( origen : Punto ( x : origenX , y : origenY ), tama\u00f1o : tama\u00f1o ) } } let basicRectangulo = Rectangulo () // el origen de basicRectangulo es (0.0, 0.0) y su tama\u00f1o (0.0, 0.0) let origenRectangulo = Rectangulo ( origen : Punto ( x : 2.0 , y : 2.0 ), tama\u00f1o : Tama\u00f1o ( ancho : 5.0 , alto : 5.0 )) // el origne de origenRectangulo es (2.0, 2.0) y su tama\u00f1o (5.0, 5.0) let centroRectangulo = Rectangulo ( centro : Punto ( x : 4.0 , y : 4.0 ), tama\u00f1o : Tama\u00f1o ( ancho : 3.0 , alto : 3.0 )) // el origen de centroRectangulo es (2.5, 2.5) y su tama\u00f1o (3.0, 3.0) El inicializador init(){} permite inicializar el Rectangulo a los valores por defecto definidos en las propiedades. Proporciona la misma funcionalidad que el inicializador por defecto, que tal y como hemos comentado, no se crea en una estructura o clase en la que definimos sus propios inicializadores. 6. Herencia \u00b6 Una clase puede heredar m\u00e9todos, propiedades y otras caracter\u00edsticas de otra clase. Cuando una clase hereda de otra, la clase que hereda se denomina subclase , y la clase de la que se hereda se denomina su superclase . La herencia es una conducta fundamental que diferencia las clases de otros tipos en Swift. Las clases en Swift pueden llamar y acceder a m\u00e9todos y propiedades que pertenecen a su superclase y pueden proporcionar sus propias versiones que sobreescriben esos m\u00e9todos y propiedades. Para sobreescribir un m\u00e9todo o una propiedad es necesario cumplir con la definici\u00f3n proporcionada por la superclase. Las clases tambi\u00e9n pueden a\u00f1adir observadores a las propiedades heredadas para ser notificadas cuando cambia el valor de una propiedad. A cualquier propiedad heredada se le puede a\u00f1adir un observador de propiedad, independientemente de si es originalmente una propiedad almacenada o calculada. 6.1. Definici\u00f3n de una clase base \u00b6 Una clase que no hereda de ninguna otra se denomina una clase base ( base class ). A diferencia de otros lenguajes orientados a objetos, las clases en Swift no heredan de una clase base universal. Tambi\u00e9n a diferencia de otros lenguajes orientados a objetos Swift no permite definir clases abstractas que no permiten crear instancias. Cualquier clase en Swift puede ser instanciada. El siguiente ejemplo define una clase base llamada Vehiculo . Esta clase base define una propiedad almacenada llamada velocidadActual con un valor por defecto de 0.0. Esta propiedad se utiliza por una propiedad String calculada llamada descripcion que crea una descripci\u00f3n del veh\u00edculo. La clase base Vehiculo tambi\u00e9n define un m\u00e9todo llamdo hazRuido . Este m\u00e9todo no hace nada realmente para una instancia de un veh\u00edculo base, pero ser\u00e1 modificado m\u00e1s adelante por las subclases de Vehiculo . class Vehiculo { var velocidadActual = 0.0 var descripcion : String { return \"viajando a \\( velocidadActual ) kil\u00f3metros por hora\" } func hazRuido () -> String { // Devuelve una cadena vac\u00eda - un veh\u00edculo arbitrario no hace // ruido necesariamente return \"\" } } Creamos una instancia nueva de Vehiculo con la sintaxis de inicializaci\u00f3n que hemos visto, en la que se escribe el nombre del tipo de la clase seguido por par\u00e9ntesis vac\u00edos: let unVehiculo = Vehiculo () Habiendo creado una instancia nueva de Vehiculo , podemos acceder a su descripci\u00f3n: print ( \"Veh\u00edculo: \\( unVehiculo . descripcion ) \" ) // Veh\u00edculo: viajando a 0.0 kil\u00f3metros por hora La clase Vehiculo define caracter\u00edsticas comunes para un veh\u00edculo arbitrario, pero no es de mucha utilidad por si misma. Para hacerla m\u00e1s \u00fatil, tenemos que refinarla para describir tipos de veh\u00edculos m\u00e1s espec\u00edficos. 6.2. Construcci\u00f3n de subclases \u00b6 La construcci\u00f3n de una subclase ( subclassing ) es la acci\u00f3n de basar una nueva clase en una clase existente. La subclase hereda caracter\u00edsticas de la clase existente, que despu\u00e9s podemos refinar. Tambi\u00e9n podemos a\u00f1adir nuevas caracter\u00edsticas a la subclase. Para indicar que una subclase tiene una superclase hay que escribir el nombre de la subclase antes de el de la superclase, separadas por dos puntos ( : ): class UnaSubclase : UnaSuperClase { // definici\u00f3n de la subclase } En el ejemplo anterior del Vehiculo podemos definir una subclase Bicicleta : class Bicicleta : Vehiculo { var tieneCesta = false } La nueva clase Bicicleta obtiene autom\u00e1ticamente todas las caracter\u00edsticas del Vehiculo , como sus propiedades velocidadActual y descripcion y su m\u00e9todo haceRuido() . Adem\u00e1s de las caracter\u00edsticas que hereda, la clase Bicicleta define una nueva propiedad almacenada, tieneCesta , con un valor por defecto de false . Por defecto, cualquier instancia nueva de Bicicleta no tendr\u00e1 una cesta. Puedes establecer la propiedad tieneCesta a true para una instancia particular de Bicicleta despu\u00e9s de crearla: let bicicleta = Bicicleta () bicicleta . tieneCesta = true Podemos tambi\u00e9n modificar la propiedad heredada velocidadActual y preguntar por la propiedad descripcion : bicicleta . velocidadActual = 10.0 print ( \"Bicicleta: \\( bicicleta . descripcion ) \" ) // Bicicleta: viajando a 10.0 kil\u00f3metros por hora Podemos construir subclases a partir de otras subclases. El siguiente ejemplo crea una subclase de Bicicleta que representa una bicicleta de dos sillines (un \"tandem\"): class Tandem : Bicicleta { var numeroActualDePasajeros = 0 } Tandem hereda todas las propiedades y m\u00e9todos de Bicicleta , que a su vez hereda todas sus propiedades y m\u00e9todos de Vehiculo . La subclase Tandem tambi\u00e9n a\u00f1ade una nueva propiedad almacenada llamada numeroActualDePasajeros , con un valor por defecto de 0. Si creamos una instancia de Tandem podremos trabajar con cualquiera de sus propiedades nuevas y heredadas, y preguntar a la descripci\u00f3n de solo lectura que hereda de Vehiculo : let tandem = Tandem () tandem . tieneCesta = true tandem . numeroActualDePasajeros = 2 tandem . velocidadActual = 18.0 print ( \"Tandem: \\( tandem . descripcion ) \" ) // Tandem: viajando a 18.0 kil\u00f3metros por hora 6.3. Sobreescritura \u00b6 Una subclase puede proporcionar su propia implementaci\u00f3n de un m\u00e9todo de la instancia, m\u00e9todo del tipo, propiedad de la instancia o propiedad del tipo que hereda de su superclase. Esto se conoce como sobreescritura ( overriding ). Para sobreescribir una caracter\u00edstica que ser\u00eda de otra forma heredada debemos usar el prefijo override . De esta forma se clarifica que intentamos proporcionar una sobreescritura y que no lo hacemos por error. Esta palabra clave tambi\u00e9n hace que el compilador comprueba que la superclase (o una de sus clases padre) tiene una declaraci\u00f3n que empareja con la que proporcionamos en la sobreescritura. Cuando proporcionamos una sobreescritura puede ser \u00fatil acceder a los valores proporcionados por la clase padre. Para acceder a ellos podemos usar el prefijo super . El siguiente ejemplo define una nueva subclase de Vehiculo llamada Tren , que sobreescribe el m\u00e9todo hazRuido() : class Tren : Vehiculo { override func hazRuido () -> String { return \"Chuu Chuu\" } } Si creamos una nueva instancia de Tren y llamamos al m\u00e9todo hazRuido podemos comprobar que se llama a la versi\u00f3n del m\u00e9todo de la subclase: let tren = Tren () print ( tren . hazRuido ()) // Imprime \"Chuu Chuu\" Podemos sobreescribir cualquier propiedad heredada del tipo o de la instancia y proporcionar nuestros propios getters y setters para esa propiedad, o a\u00f1adir observadores de propiedades para observar cuando cambian los valores subyacentes de la propiedad. Podemos proporcionar un getter (o setter , si es apropiado) para sobreescribir cualquier propiedad heredada, independientemente de si la propiedad heredada se implementa como una propiedad almacenada o calculada. La naturaleza almacenada o calculada no se conoce por la subclase, que solo conoce su nombre y su tipo. Es posible convertir una propiedad heredada de solo-lectura en una de lectura-escritura. No es posible presentar una propiedad heredada de lectura-escritura como de solo-lectura. El siguiente ejemplo define una nueva clase llamada Coche , que es una subclase de Vehiculo . La clase Coche introduce una nueva propiedad almacenada llamada marcha , con un valor por defecto de 1. Tambi\u00e9n sobreescribe la propiedad heredada descripcion , incluyendo la marcha actual en la descripci\u00f3n: class Coche : Vehiculo { var marcha = 1 override var descripcion : String { return super . descripcion + \" con la marcha \\( marcha ) \" } } Podemos ver el funcionamiento en el siguiente ejemplo: let coche = Coche () coche . velocidadActual = 50.0 coche . marcha = 3 print ( \"Coche: \\( coche . descripcion ) \" ) // Coche: viajando a 50.0 kil\u00f3metros por hora con la marcha 3 Por \u00faltimo, podemos a\u00f1adir observadores a propiedades heredadas. Esto nos permite ser notificados cuando el valor de una propiedad heredada cambia, independientemente de si esa propiedad se ha implementado en la subclase o en la superclase. El siguiente ejemplo define una nueva clase llamada CocheAutomatico que es una subclase de Coche . La clase CocheAutomatico representa un coche con una caja de cambios autom\u00e1tica, que selecciona autom\u00e1ticamente la marcha bas\u00e1ndose en la velocidad actual: class CocheAutomatico : Coche { override var velocidadActual : Double { didSet { marcha = min ( Int ( velocidadActual / 25.0 ) + 1 , 5 ) } } } En cualquier momento que se modifica la propiedad velocidadActual de una instancia de CocheAutomatico , el observador didSet establece la propiedad marcha a un valor apropiado para la nueva velocidad. Un ejemplo de ejecuci\u00f3n: let automatico = CocheAutomatico () automatico . velocidadActual = 100.0 print ( \"CocheAutomatico: \\( automatico . descripcion ) \" ) // CocheAutomatico: viajando a 100.0 kil\u00f3metros por hora con la marcha 5 6.6. Modificador final \u00b6 Por \u00faltimo, es posible prevenir un m\u00e9todo o propiedad de ser sobreescrito declar\u00e1ndolo como final . Para ello, hay que escribir el modificador final antes del nombre de la palabra clave que introduce el m\u00e9todo o la propiedad (como final var , final func ). Tambi\u00e9n es posible marcar la clase completa como final, escribiendo el modificador antes de class ( final class ). 7. Protocolos \u00b6 Un protocolo ( protocol ) define un esquema de m\u00e9todos, propiedades y otros requisitos que encajan en una tarea particular o un trozo de funcionalidad. El protocolo puede luego ser adoptado ( adopted ) por una clase, estructura o enumeraci\u00f3n para proporcionar una implementaci\u00f3n real de esos requisitos. Cualquier tipo que satisface los requerimientos de un protocolo se dice que se ajusta o cumple ( conform ) ese protocolo. Podemos considerar los protocolos como una construcci\u00f3n de Swift que ampl\u00eda la idea de las interfaces de Java. Adem\u00e1s de especificar los requisitos de los tipos que cumplen el protocolo, tambi\u00e9n se puede extender un protocolo (lo veremos m\u00e1s adelante, cuando hablemos de extensiones ) para proporcionar una implementaci\u00f3n de algunos de los m\u00e9todos requeridos por el protocolo. La utilizaci\u00f3n de protocolos permite un estilo de programaci\u00f3n muy flexible que puede ser usado para definir bibliotecas que se adaptan f\u00e1cilmente a nuevos requisitos. En la charla de la conferencia de desarrolladores de Apple de 2015 (WWDC15) Protocol Oriented Programming Dave Abrahams, uno de los responsables del dise\u00f1o de la biblioteca est\u00e1ndar de Swift, propone la utilizaci\u00f3n de protocolos en un nuevo estilo de programaci\u00f3n que contrapone al estilo tradicional de la programaci\u00f3n orientada a objetos que usa herencia y clases abstractas. 7.1. Sintaxis \u00b6 Los protocolos se definen de forma similar a las clases, estructuras y enumeraciones: protocol UnProtocolo { // definici\u00f3n del protocolo } Para definir un tipo que se ajusta a un protocolo particular se debe poner el nombre del protocolo tras el nombre del tipo, separado por dos puntos. Podemos listar m\u00e1s de un protocolo, y se separan por comas: struct UnStruct : PrimerProtocolo , OtroProtocolo { // definici\u00f3n del struct } Si una clase tiene una superclase, se escribe el nombre de la superclase antes de los protocolos, seguido por una coma: class UnaClase : UnaSuperClase , PrimerProtocolo , OtroProto { // definici\u00f3n de la clase } 7.2. Requisitos de propiedades \u00b6 Un protocolo puede requerir a cualquier tipo que se ajuste a \u00e9l que proporcione una propiedad de instancia o de tipo con un nombre y tipo particular. El protocolo no especifica si la propiedad es una propiedad calculada o almacenada, s\u00f3lo especifica el nombre y el tipo de la propiedad requerida. El protocolo tambi\u00e9n especifica si la propiedad debe ser de lectura y escritura o s\u00f3lo de lectura. Si un protocolo requiere que una propiedad sea de lectura y escritura, el requisito no puede ser satisfecho por una propiedad constante almacenada o por una propiedad calculada de s\u00f3lo lectura. Si el protocolo s\u00f3lo requiere que la propiedad sea de lectura, el requisito puede ser satisfecho por cualquier tipo de propiedad, y es v\u00e1lido que la propiedad sea tambi\u00e9n de escritura si es \u00fatil para nuestro propio c\u00f3digo. Los requisitos de la propiedad se declaran siempre como propiedades variables, precedido por la palabra clave var . Las propiedades de lectura y escritura se indican escribiendo { get set } despu\u00e9s de la declaraci\u00f3n de su tipo, y las propiedades de s\u00f3lo lectura se indican escribiendo { get } . protocol UnProtocolo { var debeSerEscribible : Int { get set } var noTienePorQueSerEscribible : Int { get } } Para definir una propiedad de tipo hay que precederla en el protocolo con la palabra clave static : protocol OtroProtocolo { static var unaPropiedadDeTipo : Int { get set } } Veamos un ejemplo. Definimos el protocolo TieneNombre en el que se requiere que cualquier clase que se ajuste a \u00e9l debe tener una propiedad de instancia de lectura de tipo String que se llame nombreCompleto : protocol TieneNombre { var nombreCompleto : String { get } } Un ejemplo de una sencilla estructura que adopta el protocolo: struct Persona : TieneNombre { var edad : Int var nombreCompleto : String } let john = Persona ( edad : 35 , nombreCompleto : \"John Appleseed\" ) // john.nombreCompleto es \"John Appleseed\" Este ejemplo define una estructure llamada Persona , que representa una persona con una edad y un nombre espec\u00edfico. En la primera l\u00ednea se declara que se adopta el protocolo TieneNombre . Cada instancia de Persona tiene la propiedad almacenada llamada nombreCompleto , que es de tipo String . Esto cumple el \u00fanico requisito del protocolo TieneNombre , y signifca que Persona se ajusta correctamente al protocolo (Swift informa de un error en tiempo de compilaci\u00f3n si un requisito de un protocolo no se cumple). Otro ejemplo de una clase m\u00e1s compleja, que tambi\u00e9n adopta el protocolo: class NaveEstelar : TieneNombre { var prefijo : String ? var nombre : String init ( nombre : String , prefijo : String ? = nil ) { self . nombre = nombre self . prefijo = prefijo } var nombreCompleto : String { return ( prefijo != nil ? prefijo ! + \" \" : \"\" ) + nombre } } var ncc1701 = NaveEstelar ( nombre : \"Enterprise\" , prefijo : \"USS\" ) // ncc1701.nombreCompleto es \"USS Enterprise\" Esta clase implementa el requisito de la propiedad nombreCompleto como una propiedad calculada de solo lectura para una nave estelar. Cada instancia de NavaEstelar almacena un nombre obligatorio y un prefijo opcional. La propiedad nombreCompleto usa el valor del prefijo si existe, y la a\u00f1ade al comienzo del nombre para crear un nombre completo de la nave estelar. 7.3. Requisitos de m\u00e9todos \u00b6 Los protocolos pueden requerir que los tipos que se ajusten a ellos implementen m\u00e9todos de instancia y de tipos espec\u00edficos. Estos m\u00e9todos se escriben como parte de la definici\u00f3n del protocolo de la misma forma que los m\u00e9todos normales, pero sin sus cuerpos: protocol UnProtocolo { func unMetodo () -> Int } Los m\u00e9todos del tipo en el protocolo deben indicarse con la palabra clave static : protocol UnProtocolo { static func unMetodoDelTipo () } Un ejemplo: protocol GeneradorNumerosAleatorios { func random () -> Double } Este protocolo, GeneradorNumerosAleatorios , requiere que cualquier tipo que se ajuste a \u00e9l tenga un m\u00e9todo de instancia llamado random , que devuelve un valor Double cada vez que se llama. Aunque no est\u00e1 especificado en el protocolo, se asume que este valor ser\u00e1 un n\u00famero entre 0.0 y 1.0 (sin incluirlo). El protocolo GeneradorNumerosAleatorios no hace ninguna suposici\u00f3n sobre c\u00f3mo ser\u00e1 generado cada n\u00famero aleatorio, simplemente requiere al generador que proporcione una forma est\u00e1ndar de generarlo. Una implementaci\u00f3n de una clase que adopta el protocolo: class GeneradorLinealCongruente : GeneradorNumerosAleatorios { var ultimoRandom = 42.0 let m = 139968.0 let a = 3877.0 let c = 29573.0 func random () -> Double { let number = ultimoRandom * a + c ultimoRandom = number . truncatingRemainder ( dividingBy : m ) return ultimoRandom / m } } let generador = GeneradorLinealCongruente () print ( \"Un n\u00famero aleatorio: \\( generador . random ()) \" ) // Imprime \"Un n\u00famero aleatorio: 0.37464991998171\" print ( \"Y otro: \\( generador . random ()) \" ) // Imprime \"Y otro: 0.729023776863283\" 7.4. Requisito de m\u00e9todo mutating \u00b6 Si definimos un protocolo con un requisito de m\u00e9todo de instancia que pretenda mutar las instancias del tipo que adopte el protocolo, se debe marcar el m\u00e9todo con la palabra mutating . Esto permite a las estructuras y enumeraciones que adopten el protocolo definir ese m\u00e9todo como mutating . No es necesario hacerlo con las clases, porque la palabra mutating solo es necesaria en estructuras y enumeraciones. Un ejemplo: protocol Conmutable { mutating func conmutar () } enum Interruptor : Conmutable { case apagado , encendido mutating func conmutar () { switch self { case . apagado : self = . encendido case . encendido : self = . apagado } } } var interruptorLampara = Interruptor . apagado interruptorLampara . conmutar () // interruptorLampara es ahora igual a .encendido 7.5. Protocolos como tipos \u00b6 Los protocolos no implementan realmente ninguna funcionalidad por ellos mismos. Sin embargo, cualquier protocolo que definamos se convierte autom\u00e1ticamente en un tipo con todas sus propiedades que podemos usar en nuestro c\u00f3digo. Podemos entonces usar el protocolo en cualquier sitio donde permitamos otros tipos, incluyendo: El tipo de un par\u00e1metro de una funci\u00f3n, m\u00e9todo o inicializador o de sus valores devueltos. El tipo de una constante, variable o propiedad El tipo de los \u00edtems de un array, diccionario u otro contenedor class Dado { let caras : Int let generador : GeneradorNumerosAleatorios init ( caras : Int , generador : GeneradorNumerosAleatorios ) { self . caras = caras self . generador = generador } func tirar () -> Int { return Int ( generador . random () * Double ( caras )) + 1 } } Este ejemplo define una nueva clase llamada Dado , que representa un dado de n caras que se puede usar en un juego de tablero. Las instancias de dados tienen una propiedad llamada caras , que representa cu\u00e1ntas caras tienen, y una propiedad llamada generador , que proporciona un generador a partir del cual crear valores de tiradas. La propiedad generador es del tipo GeneradorNumerosAleatorios . Podemos asignarle una instancia de cualquier tipo que adopte el protocolo GeneradorNumerosAleatorios . Dado tiene tambi\u00e9n un inicializador, para configurar sus estado inicial. El inicializador tiene un par\u00e1metro llamado generador , que tambi\u00e9n es del tipo GeneradorNumerosAleatorios . Podemos pasarle un valor de cualquier instancia que se ajuste a este tipo. Y tambi\u00e9n proporciona un m\u00e9todo de instancia llamado tirar , que devuelve un valor entero entre 1 y el n\u00famero de caras del dado. Este m\u00e9todo llama al m\u00e9todo random() del generador para crear un nuevo n\u00famero aleatorio entre 0.0 y 1.0 y usa este n\u00famero aleatorio para crear un valor de tirada que est\u00e9 dentro del rango correcto. Debido a que sabemos que el generador se ajusta al protocolo GeneradorNumerosAleatorios tenemos la garant\u00eda de que va a existir un m\u00e9todo random() al que llamar. Un ejemplo de uso del c\u00f3digo: var d6 = Dado ( caras : 6 , generador : GeneradorLinealCongruente ()) for _ in 1. .. 5 { print ( \"La tirada del dado es \\( d6 . tirar ()) \" ) } // La tirada del dado es 3 // La tirada del dado es 5 // La tirada del dado es 4 // La tirada del dado es 5 // La tirada del dado es 4 7.6. Colecciones de tipos protocolo \u00b6 Como hemos comentado anteriormente, un protocolo puede usarse como el tipo que se almacena un una colecci\u00f3n (array, diccionario, etc.). Veamos un ejemplo: var peterParker = Persona ( edad : 24 , nombreCompleto : \"Peter Parker\" ) var ncc1701 = NaveEstelar ( nombre : \"Enterprise\" , prefijo : \"USS\" ) let cosasConNombre : [ TieneNombre ] = [ peterParker , ncc1701 ] for cosa in cosasConNombre { print ( cosa . nombreCompleto ) } // Peter Parker // USS Enterprise Hay que hacer notar que la constante cosa que itera sobre los elementos del array es de tipo TieneNombre ], no es de tipo Persona ni de tipo NaveEstelar , incluso aunque las instancias que hay tras de escena son do esos tipos. Por ser del tipo TieneNombre sabemos que tiene una propiedad nombreCompleto que podemos usar sobre la variable iteradora. 7.7. Protocolo Equatable \u00b6 En la biblioteca est\u00e1ndar de Swift se definen distintos protocolos como Collection y Equatable que describen abstracciones comunes. Muchos de estos protocolos incorporan implementaciones por defecto de algunos de sus m\u00e9todos mediante extensiones definidas en la propia biblioteca est\u00e1ndar. Veamos por ejemplo el protocolo Equatable . Se trata de un protocolo importante que define las operaciones de igualdad ( == ) y diferencia ( != ). Debemos implementar la operaci\u00f3n de igualdad en cualquier clase que se ajuste al protocolo, pero la operaci\u00f3n de diferencia ya tiene una implementaci\u00f3n por defecto. Un ejemplo: class Punto3D : Equatable { let x , y , z : Double init ( x : Double , y : Double , z : Double ) { self . x = x self . y = y self . z = z } static func == ( izquierda : Punto3D , derecha : Punto3D ) -> Bool { return izquierda . x == derecha . x && izquierda . y == derecha . y && izquierda . z == derecha . z } } let p1 = Punto3D ( x : 0.0 , y : 0.0 , z : 0.0 ) let p2 = Punto3D ( x : 0.0 , y : 0.0 , z : 0.0 ) print ( p1 == p2 ) // Imprime true print ( p1 != p2 ) // Imprime false El operador == se define en la propia clase. Se utiliza la palabra static para indicar que se trata de un operador que estamos sobrecargando (hablaremos m\u00e1s adelante de los operadores). El operador != que se usa en la \u00faltima instrucci\u00f3n se define en una implementaci\u00f3n por defecto. En Swift 5 el compilador define una implementaci\u00f3n autom\u00e1tica del operador == en las estructuras y enumeraciones al a\u00f1adir el protocolo Equatable , siempre que las propiedades almacenadas y los valores asociados cumplan ese protocolo. Por ejemplo, si en lugar de una clase definimos un struct Punto3D el c\u00f3digo quedar\u00eda como sigue (no es necesario definir ni el inicializador por defecto ni el operador == ): struct Punto3D : Equatable { let x , y , z : Double } let p1 = Punto3D ( x : 0.0 , y : 0.0 , z : 0.0 ) let p2 = Punto3D ( x : 0.0 , y : 0.0 , z : 0.0 ) print ( p1 == p2 ) // Imprime true print ( p1 != p2 ) // Imprime false 8. Casting de tipos \u00b6 El casting de tipos es una forma de comprobar el tipo de una instancia o de tratar esa instancia como de una superclase distinta o conseguir una subclase de alg\u00fan otro sitio en la propia jerarqu\u00eda de clase. La forma de implementarlo es utilizando los operadores is y as . Estos operadores proporcionan una forma simple y expresiva de comprobar el tipo de un valor o transformar un valor en uno de otro tipo. Tambi\u00e9n se puede usar el casting de tipos para comprobar si un tipo se ajusta a un protocolo. 8.1. Una jerarqu\u00eda de clases para el casting de tipos \u00b6 Vamos a comenzar construyendo una jerarqu\u00eda de clases y subclases con las que trabajar. Utilizaremos el casting de tipos para comprobar el tipo de una instancia particular de una clase y para convertir esa instancia en otra clase dentro de la misma jerarqu\u00eda. En el primer fragmento de c\u00f3digo definimos una clase nueva llamada MediaItem . Esta clase proporciona la funcionalidad b\u00e1sica de cualquier tipo de \u00edtem que aparece en una biblioteca de medios digitales. Espec\u00edficamente, declara una propiedad nombre de tipo String y un inicializador init nombre (suponemos que todos los \u00edtems, incluyendo pel\u00edculas y canciones, tendr\u00e1n un nombre). class MediaItem { var nombre : String init ( nombre : String ) { self . nombre = nombre } } El siguiente fragmento define dos subclases de MediaItem . La primera subclase, Pelicula , encapsula informaci\u00f3n adicional sobre una pel\u00edcula. A\u00f1ade una propiedad director a la clase base MediaItem , con su correspondiente inicializador. La segunda subclase, Cancion , a\u00f1ade una propiedad artista y un inicializador a la clase base: class Pelicula : MediaItem { var director : String init ( nombre : String , director : String ) { self . director = director super . init ( nombre : nombre ) } } class Cancion : MediaItem { var artista : String init ( nombre : String , artista : String ) { self . artista = artista super . init ( nombre : nombre ) } } Por \u00faltimo, creamos un array constante llamado biblioteca , que contienen dos instancias de Pelicula y tres instancias de Cancion . let biblioteca : [ MediaItem ] = [ Pelicula ( nombre : \"El Se\u00f1or de los Anillos\" , director : \"Peter Jackson\" ), Cancion ( nombre : \"Child in Time\" , artista : \"Deep Purple\" ), Pelicula ( nombre : \"El Puente de los Esp\u00edas\" , director : \"Steven Spielberg\" ), Cancion ( nombre : \"I Wish You Were Here\" , artista : \"Pink Floyd\" ), Cancion ( nombre : \"Yellow\" , artista : \"Coldplay\" ) ] Podr\u00edamos tambi\u00e9n dejar que el compilador infiera el tipo del array. Es capaz de deducir que Pelicula y Cancion tienen una superclase com\u00fan MediaItem , por lo que infiere que el tipo del array es [MediaItem] : // Declaraci\u00f3n equivalente a la anterior let biblioteca = [ Pelicula ( nombre : \"El Se\u00f1or de los Anillos\" , director : \"Peter Jackson\" ), Cancion ( nombre : \"Child in Time\" , artista : \"Deep Purple\" ), Pelicula ( nombre : \"El Puente de los Esp\u00edas\" , director : \"Steven Spielberg\" ), Cancion ( nombre : \"I Wish You Were Here\" , artista : \"Pink Floyd\" ), Cancion ( nombre : \"Yellow\" , artista : \"Coldplay\" ) ] Los \u00edtems almacenados en la biblioteca son todav\u00eda instancias de Pelicula y Cancion . Sin embargo, si iteramos sobre los contenidos de este array, los \u00edtems que recibiremos tendr\u00e1n el tipo MediaItem y no Pelicula o Cancion . Para trabajar con ellos como su tipo nativo, debemos chequear su tipo, y hacer un downcast a su tipo concreto. Lo veremos m\u00e1s adelante. Sucede igual en el ejemplo visto anteriormente en el que se guardan en un array de tipo TieneNombre (un protocolo) dos instancias de estructuras distinas (una Persona y una NaveEstelar ) que cumplen el protocolo. var peterParker = Persona ( edad : 24 , nombreCompleto : \"Peter Parker\" ) var ncc1701 = NaveEstelar ( nombre : \"Enterprise\" , prefijo : \"USS\" ) let cosasConNombre : [ TieneNombre ] = [ peterParker , ncc1701 ] for cosa in cosasConNombre { print ( cosa . nombreCompleto ) } // Peter Parker // USS Enterprise Tambi\u00e9n podemos aplicar los operadores de comprobaci\u00f3n de tipo y de downcasting que veremos a continuaci\u00f3n a este caso en el que instancias concretas est\u00e1n en variables del tipo del protocolo. 8.2. Comprobaci\u00f3n del tipo \u00b6 Podemos usar el operador de comprobaci\u00f3n ( check operator ) is para comprobar si una instancia es de un cierto tipo. El operador de comprobaci\u00f3n devuelve true si la instancia es del tipo y false si no. Lo podemos comprobar en el siguiente ejemplo, en el que contamos las instancias de pel\u00edculas y canciones en el array biblioteca : var contadorPeliculas = 0 var contadorCanciones = 0 for item in biblioteca { if item is Pelicula { contadorPeliculas += 1 } else if item is Cancion { contadorCanciones += 1 } } print ( \"La biblioteca contiene \\( contadorCanciones ) pel\u00edculas y \\( contadorPeliculas ) canciones\" ) // Imprime \"La biblioteca contiene 3 pel\u00edculas y 2 canciones\" El ejemplo itera por todos los \u00edtems del array biblioteca . En cada paso, el bucle for-in guarda en la constante item el siguiente MediaItem del array. La instrucci\u00f3n item is Pelicula devuelve true si el MediaItem actual es una instancia de Pelicula y false en otro caso. De forma similar, item is Cancion comprueba si el \u00edtem es una instancia de Cancion . Al final del bucle for-in , los valores de contadorPeliculas y contadorCanciones contendr\u00e1n una cuenta de cuantas instancias MediaItem de cada tipo se han encontrado. La misma comprobaci\u00f3n se puede hacer en el array cosasConNombre para contar el n\u00famero de \u00edtems que son de tipo Persona y NaveEspacial . 8.3. Downcasting \u00b6 Una constante o variable de un cierto tipo de clase puede referirse (contener) a una instancia de una subclase. Tambi\u00e9n, una variable declarada con el tipo de un protocolo contiene una instancia de un tipo concreto, que cumple el protocolo. Cuando sucede esto, podemos hacer un downcast al tipo de la subclase o del tipo que cumple el protocolo con un operador de cast ( as? o as! ). Como el downcast puede fallar, la versi\u00f3n condicional, as? , devuelve un valor opcional del tipo al que estamos intentando hacer el downcasting . La versi\u00f3n forzosa, as! , intenta el downcast y fuerza la desenvoltura del resultado en un \u00fanica acci\u00f3n compuesta. Debemos usar la versi\u00f3n condicional ( as? ) cuando no estamos seguros si el downcast tendr\u00e1 \u00e9xito. Se devolver\u00e1 un valor opcional y el valor ser\u00e1 nil si no es posible hacer el downcast . Esto permitir\u00e1 comprobar si ha habido un downcast con \u00e9xito. La otra versi\u00f3n ( as! ) se usa s\u00f3lo cuando estamos seguros de que el downcast tendr\u00e1 \u00e9xito. Esta versi\u00f3n del operador lanzar\u00e1 un error en tiempo de ejecuci\u00f3n si intentamos hacer un downcast a un tipo incorrecto. El siguiente ejemplo itera sobre cada MediaItem en biblioteca , e imprime una descripci\u00f3n apropiada para cada \u00edtem. Para hacerlo, necesita acceder a cada \u00edtem como una Pelicula o Cancion y no s\u00f3lo como una MediaItem . Esto es necesario para poder acceder a la propiedad director o artista de una instancia de Pelicula o Cancion . En este ejemplo, cada \u00edtem en el array podr\u00eda ser un Pelicula o podr\u00eda ser una Cancion . No sabemos por anticipado la clase verdadera de cada \u00edtem, por lo que es apropiado usar la versi\u00f3n condicional ( as? ) para comprobar el downcast cada vez a lo largo del bucle: for item in biblioteca { if let pelicula = item as ? Pelicula { print ( \"Pel\u00edcula: \\( pelicula . nombre ) , dir. \\( pelicula . director ) \" ) } else if let cancion = item as ? Cancion { print ( \"Cancion: \\( cancion . nombre ) , de \\( cancion . artista ) \" ) } } // Pel\u00edcula: El Se\u00f1or de los Anillos, dir. Peter Jackson // Cancion: Child in Time, de Deep Purple // Pel\u00edcula: El Puente de los Esp\u00edas, dir. Steven Spielberg // Cancion: I Wish You Were Here, de Pink Floyd // Cancion: Yellow, de Coldplay El ejemplo comienza intentando hacer downcast del \u00edtem a una Pelicula . Debido a que es una instancia de MediaItme , es posible que sea un Pelicula o una Cancion , o incluso el tipo base MediaItem . Debido a esta incertidumbre, debemos usar la versi\u00f3n as? para devolver un valor opcional. El resultado ser\u00e1 una \"Pelicula opcional\". Podemos desenvolver el valor Pelicula usando un if let como vimos en el apartado de opcionales. Si tiene \u00e9xito el downcasting , las propiedades de la pel\u00edcula se pueden usar para imprimir una descripci\u00f3n de la pel\u00edcula llamando a los correspondientes m\u00e9todos de la clase Pelicula . Igual con Cancion . El mismo ejemplo se puede aplicar al array cosasConNombre . Prueba a adaptar el c\u00f3digo anterior a este array, recorri\u00e9ndolo y haciendo el downcasting a los tipos Persona y NaveEspacial . 8.4. El tipo Any \u00b6 El tipo Any puede representar una instancia de cualquier tipo, incluyendo tipos funci\u00f3n: var array = [ Any ]() array . append ( 0 ) array . append ( 0.0 ) array . append ( 42 ) array . append ( 3.14159 ) array . append ( \"hola\" ) array . append (( 3.0 , 5.0 )) array . append ( Pelicula ( nombre : \"Ghostbusters\" , director : \"Ivan Reitman\" )) array . append ({ ( name : String ) -> String in \"Hola, \\( name ) \" }) El array contiene dos valores Int , dos valores Double , un valor String , una tupla del tipo (Double, Double) , la pel\u00edcula \"Ghostbusters\", y una clausura que toma un String y devuelve otro String . Puedes usar los operadores is y as en una sentencia switch para descubrir en tiempo de ejecuci\u00f3n el tipo espec\u00edfico de una constante o variable de la que s\u00f3lo se sabe que es de tipo Any : for item in array { switch item { case 0 as Int : print ( \"cero como un Int\" ) case 0 as Double : print ( \"cero como un Double\" ) case let someInt as Int : print ( \"un valor entero de \\( someInt ) \" ) case let unDouble as Double where unDouble > 0 : print ( \"a valor positivo de \\( unDouble ) \" ) case is Double : print ( \"alg\u00fan otro valor double que no quiero imprimir\" ) case let someString as String : print ( \"una cadena con valor de \\\" \\( someString ) \\\" \" ) case let ( x , y ) as ( Double , Double ): print ( \"un punto (x, y) en \\( x ) , \\( y ) \" ) case let pelicula as Pelicula : print ( \"una pel\u00edcula: \\( pelicula . nombre ) , dir. \\( pelicula . director ) \" ) case let stringConverter as ( String ) -> String : print ( stringConverter ( \"Michael\" )) default : print ( \"alguna otra cosa\" ) } } // cero como un Int // cero como un Double // un valor entero de 42 // a valor positivo de 3.14159 // una cadena con valor de \"hola\" // un punto (x, y) en 3.0, 5.0 // una pel\u00edcula: Ghostbusters, dir. Ivan Reitman // Hola, Michael 8.5. Comprobaci\u00f3n de ajustarse a un protocolo \u00b6 Podemos usar tambi\u00e9n los operadores anteriores is y as (y as? y as! ) para comprobar si una instancia se ajusta a un protocolo y para hacer un cast a un protocolo espec\u00edfico. Veamos un ejemplo. Definimos el protocolo TieneArea con el \u00fanico requisito de una propiedad de lectura llamada area de tipo Double : protocol TieneArea { var area : Double { get } } Definimos dos clases Circulo y Pais que se ajustan ambos al protocolo: class Circulo : TieneArea { let pi = 3.1415927 var radio : Double var area : Double { return pi * radio * radio } init ( radio : Double ) { self . radio = radio } } class Pais : TieneArea { var area : Double init ( area : Double ) { self . area = area } } La clase Circulo implementa el requisito como una propiedad calculada, basada en la propiedad almacenada radio . La clase Pais implementa el requisito directamente como una propiedad almacenada. Ambas clases se ajustan correctamente al protocolo TieneArea . Definimos una clase Animal que no se ajusta al protocolo: class Animal { var patas : Int init ( patas : Int ) { self . patas = patas } } Las clases Circulo , Pais y Animal no tienen ninguna clase base compartida. Sin embargo, todas son clases, por lo que las instancias de los tres tipos pueden usarse para inicializar un array que almacena valores de tipo Any : let objetos : [ Any ] = [ Circulo ( radio : 2.0 ), Pais ( area : 243_610 ), Animal ( patas : 4 ) ] Y ahora podemos iterar sobre el array de objetos, comprobando para cada \u00edtem si la instancia se ajusta al protocolo TieneArea : for objecto in objetos { if let objetoConArea = objecto as ? TieneArea { print ( \"El \u00e1rea es \\( objetoConArea . area ) \" ) } else { print ( \"Algo que no tiene un \u00e1rea\" ) } } // El \u00e1rea es 12.5663708 // El \u00e1rea es 243610.0 // Algo que no tiene un \u00e1rea Cuando un objeto en el array se ajusta al protocolo TieneArea , el valor opcional devuelto por el operador as? se desenvuelve con un ligado opcional en una constante llamada objetoConArea . Esta constante tiene el tipo TieneArea , por lo que su propiedad area podr\u00e1 ser accedida e impresa. Hay que notar que los objetos subyacentes no cambian en el proceso de casting . Siguen siendo un Circulo , un Pais y un Animal . Sin embargo, en el momento en se almacenan en la constante objetoConArea , s\u00f3lo se sabe que son del tipo TieneArea , por lo que s\u00f3lo podremos acceder a su propiedad area . 9. Extensiones \u00b6 Las extensiones a\u00f1aden nueva funcionalidad a una clase, estructura, enumeraci\u00f3n o protocolo. Esto incluye la posibilidad de extender tipos para los que no tenemos acceso al c\u00f3digo fuente original (esto se conoce como modelado retroactivo ). Entre otras cosas, las extensiones pueden: A\u00f1adir propiedades calculadas de instancia y de tipo Definir m\u00e9todos de instancia y de tipo Proporcionar nuevos inicializadores Hacer que un tipo existente se ajuste a un protocolo 9.1. Sintaxis \u00b6 Para declarar una extensi\u00f3n hay que usar la palabra clave extension , indicando despu\u00e9s el tipo que se quiere extender (enumeraci\u00f3n, clase, estructura o protocolo) extension UnTipoExistente { // nueva funcionalidad para a\u00f1adir a UnTipo } 9.2. Propiedades calculadas \u00b6 Las extensiones pueden a\u00f1adir propiedades calculadas de instancias y de tipos. Como primer ejemplo, recordemos el tipo Persona : protocol TieneNombre { var nombreCompleto : String { get } } struct Persona : TieneNombre { var edad : Int var nombreCompleto : String } Vamos a a\u00f1adir a la estructura la propiedad calculada mayorEdad , un Bool que indica si la edad de la persona es mayor o igual de 18: extension Persona { var mayorEdad : Bool { return edad >= 18 } } Una vez definida esta extensi\u00f3n, hemos ampliado la clase con esta nueva propiedad, sin modificar el c\u00f3digo inicial con la definici\u00f3n de la clase. Podemos preguntar si una persona es mayor de edad: var p = Persona ( edad : 15 , nombreCompleto : \"Luc\u00eda\" ) p . mayorEdad // false Es posible incluso extender clases de las librer\u00edas est\u00e1ndar de Swift, como Int , Double , Array , etc. Por ejemplo, podemos a\u00f1adir propiedades calculadas a la clase Double para trabajar con unidades de distancia. Las siguientes propiedades convierten una cantidad en las unidades correspondientes a su equivalente en metros: extension Double { var km : Double { return self * 1_000.0 } var m : Double { return self } var cm : Double { return self / 100.0 } var mm : Double { return self / 1_000.0 } var ft : Double { return self / 3.28084 } } Una vez definida la extensi\u00f3n, podemos usarla en cualquier variable Double . Incluso la podemos usar en literales: let distancia = 11. km // En distancia tendremos 11000 metros let unaPulgada = 25.4 . mm print ( \"Una pulgada es \\( unaPulgada ) metros\" ) // Una pulgada es 0.0254 metros let tresPies = 3. ft print ( \"Tres pies son \\( tresPies ) metros\" ) // Tres pies son 0.914399970739201 metros Por ejemplo, cuando se escribe 11.km se pide el valor de la propiedad calculada km de la instancia 11 . La propiedad calculada devuelve el resultado de multiplicar 11 por 1000 , esto es, los metros correspondientes a 11 kil\u00f3metros. De forma similar, hay 3.28084 pies en un metro, por lo que la propiedad calculada ft divide el valor Double subyacente por 3.28084, para conventirlo de pies a metros. Estas propiedades son propiedades calculadas de solo lectura, por lo que se expresan sin la palabra clave get , por brevedad. Sus valores devueltos son de tipo Double , y pueden usarse en c\u00e1lculos matem\u00e1ticos en cualquier sitio que se acepte un Double : let unMaraton = 42. km + 195. m print ( \"Un marat\u00f3n tiene una longitud de \\( unMaraton ) metros\" ) // Un marat\u00f3n tiene una longitud de 42195.0 metros 9.3. Inicializadores \u00b6 Las extensiones pueden a\u00f1adir nuevos inicializadores a tipos existentes. Esto nos permite extender otros tipos para aceptar nuestros propios tipos como par\u00e1metros de la inicializaci\u00f3n, o para proporcionar opciones adicionales que no estaban incluidos en la implementaci\u00f3n original del tipo. Recordemos la estructura Rectangulo , definida por un Punto y un Tama\u00f1o . Supongamos que la definimos sin inicializadores: struct Tama\u00f1o { var ancho = 0.0 , alto = 0.0 } struct Punto { var x = 0.0 , y = 0.0 } struct Rectangulo { var origen = Punto () var tama\u00f1o = Tama\u00f1o () } Recordemos que debido a que la estructura Rectangulo proporciona valores por defecto para todas sus propiedades, tiene un inicializador por defecto que puede utilizarse para crear nuevas instancias. Tambi\u00e9n podemos inicializarlo asignando todas sus propieades: let rectanguloPorDefecto = Rectangulo () let rectanguloInicializado = Rectangulo ( origen : Punto ( x : 2.0 , y : 2.0 ), tama\u00f1o : Tama\u00f1o ( ancho : 5.0 , alto : 5.0 )) Podemos ahora extender la estructura Rectangulo para proporcionar un inicializador adicional que toma un punto espec\u00edfico del centro y un tama\u00f1o: extension Rectangulo { init ( centro : Punto , tama\u00f1o : Tama\u00f1o ) { let origenX = centro . x - ( tama\u00f1o . ancho / 2 ) let origenY = centro . y - ( tama\u00f1o . alto / 2 ) self . init ( origen : Punto ( x : origenX , y : origenY ), tama\u00f1o : tama\u00f1o ) } } Este nuevo inicializador empieza por calcular un punto de origen basado en el centro propuesto y en el tama\u00f1o. El inicializador llama despu\u00e9s al inicializador autom\u00e1tico de la estructura init(origen:tama\u00f1o:) , que almacena los nuevos valores de las propiedades: let rectanguloCentro = Rectangulo ( centro : Punto ( x : 4.0 , y : 4.0 ), tama\u00f1o : Tama\u00f1o ( ancho : 3.0 , alto : 3.0 )) // el origen del rectanguloCentro es is (2.5, 2.5) y su tama\u00f1o es (3.0, 3.0) 9.4. M\u00e9todos \u00b6 Las extensiones pueden a\u00f1adir nuevos m\u00e9todos de instancia y nuevos m\u00e9todos del tipo. Por ejemplo, podemos a\u00f1adir el m\u00e9todo descripcion() a la estructura Persona : extension Persona { func descripcion () -> String { return \"Me llamo \\( nombreCompleto ) y tengo \\( edad ) a\u00f1os\" } } let reedRichards = Persona ( edad : 40 , nombreCompleto : \"Reed Richards\" ) print ( reedRichards . descripcion ()) Tambi\u00e9n podemos a\u00f1adir m\u00e9todos a clases y estructuras importadas. Por ejemplo podemos a\u00f1adir un nuevo m\u00e9todo de instancia llamado repeticiones al tipo Int : extension Int { func repeticiones ( _ tarea : () -> Void ) { for _ in 0. .< self { tarea () } } } El m\u00e9todo repeticiones(_:) toma un \u00fanico argumento de tipo () -> Void , que indica una funci\u00f3n que no tiene par\u00e1metros y no devuelve ning\u00fan valor. Despu\u00e9s de definir esta extensi\u00f3n, podemos llamar al m\u00e9todo repeticiones(_:) en cualquier n\u00famero entero para ejecutar una tarea un cierto n\u00famero de veces: 3. repeticiones ({ print ( \"Hola!\" ) }) // Hola! // Hola! // Hola! Usando clausuras por la cola podemos hacer la llamada m\u00e1s concisa: 3. repeticiones { print ( \"Adios!\" ) } // Adios! // Adios! // Adios! 9.5. M\u00e9todos de instancia mutadores \u00b6 Los m\u00e9todos de instancia a\u00f1adidos con una extensi\u00f3n tambi\u00e9n pueden modificar (o mutar) la propia instancia. Los m\u00e9todos de las estructuras y los enumerados que modifican self o sus propiedades deben marcarse como mutating . Por ejemplo: extension Int { mutating func cuadrado () { self = self * self } } var unInt = 3 unInt . cuadrado () // unInt es ahora 9 9.6. Ajustar un tipo a un protocolo mediante una extensi\u00f3n \u00b6 Una extensi\u00f3n puede extender un tipo existente para hacer que se ajuste a uno o m\u00e1s protocolos. En este caso, los nombres de los protocolos se escriben exactamente de la misma forma que en una clase o estructura: extension UnTipo : UnProtocolo , OtroProtocolo { // implementaci\u00f3n de los requisitos del protocolo } Las instancias del tipo adoptar\u00e1n autom\u00e1ticamente el protocolo y se ajustar\u00e1n al protocolo con las propiedades y m\u00e9todos a\u00f1adidos por la extensi\u00f3n. Por ejemplo, este protocolo, llamado RepresentableComoTexto puede ser implementado por cualquier tipo que tenga una forma de representarse como texto. Esto puede ser una descripci\u00f3n de si mismo o una versi\u00f3n de texto de su estado actual: protocol RepresentableComoTexto { var descripcionTextual : String { get } } La clase Dado que vimos anteriormente puede extenderse para ajustarse al protocolo: extension Dado : RepresentableComoTexto { var descripcionTextual : String { return \"Un dado de \\( caras ) caras\" } } Esta extensi\u00f3n adopta el nuevo protocolo exactamente como si el Dado lo hubiera proporcionado en su implementaci\u00f3n original. El nombre del protocolo se indica tras el nombre del tipo, separado por dos puntos, y se proporciona una implementaci\u00f3n entre llaves. Cualquier instancia de un dado se puede tratar ahora como RepresentableComoTexto : let d12 = Dado ( caras : 12 , generador : GeneradorLinealCongruente ()) print ( d12 . descripcionTextual ) // Un dado de 12 caras De forma similar, un Rectangulo tambi\u00e9n puede extenderse para adoptar y ajustarse al protocolo: extension Rectangulo : RepresentableComoTexto { var descripcionTextual : String { return \"Un rect\u00e1ngulo situado en ( \\( origen . x ) , \\( origen . y ) )\" } } let rectanguloInicializado = Rectangulo ( origen : Punto ( x : 2.0 , y : 2.0 ), tama\u00f1o : Tama\u00f1o ( ancho : 5.0 , alto : 5.0 )) print ( rectanguloInicializado . descripcionTextual ) // Un rect\u00e1ngulo situado en (2.0, 2.0) 9.7. Declaraci\u00f3n de la adopci\u00f3n de un protocolo con una extensi\u00f3n \u00b6 Si un tipo ya se ajusta a todos los requisitos de un protocolo, pero todav\u00eda no se ha declarado que se ajusta al protocolo, podemos hacer que lo adopte con una extensi\u00f3n vac\u00eda: struct Hamster { var nombre : String var descripcionTextual : String { return \"Un hamster llamado \\( nombre ) \" } } extension Hamster : RepresentableComoTexto {} Las instancias de Hamster pueden ahora usarse en cualquier sitio que se requiera un tipo RepresentableComoTexto : let simonElHamster = Hamster ( nombre : \"Simon\" ) let algoRepresentableComoTexto : RepresentableComoTexto = simonElHamster print ( algoRepresentableComoTexto . descripcionTextual ) // Un hamster llamado Simon 9.8. Implementaci\u00f3n de m\u00e9todos de un protocolo \u00b6 Podemos definir extensiones en los protocolos para proporcionar implementaciones de m\u00e9todos y propiedades a todos los tipos que se ajustan a \u00e9l. Esto permite definir conductas en los propios protocolos, m\u00e1s que en cada tipo individual o en una funci\u00f3n global. Por ejemplo, el protocolo GeneradorNumerosAleatorios puede ser extendido para proporcionar un m\u00e9todo boolAleatorio() , que usa el resultado del random() requerido para devolver un valor Bool aleatorio: extension GeneradorNumerosAleatorios { func randomBool () -> Bool { return random () > 0.5 } } Al crear una extensi\u00f3n en el protocolo, todos los tipos que se ajustan a \u00e9l adquieren autom\u00e1ticamente esta implementaci\u00f3n sin ninguna modificaci\u00f3n adicional. let generator = GeneradorLinealCongruente() print(\"Un n\u00famero aleatorio: \\(generator.random())\") // Imprime \"Un n\u00famero aleatorio: 0.37464991998171\" print(\"Y un booleano aleatorio: \\(generator.randomBool())\") // Imprime \"Un booleano aleatorio: true\" El tipo que se ajusta al protocolo puede proporcionar su propia implementaci\u00f3n, que se usar\u00e1 en lugar de la proporcionada por la extensi\u00f3n. 9.9. Restricci\u00f3n en las extensiones de un protocolo \u00b6 En una extensi\u00f3n de un protocolo es posible definir una restricci\u00f3n indicando una condici\u00f3n que se debe cumplir para que la extensi\u00f3n se pueda aplicar. Los m\u00e9todos y propiedades de la extensi\u00f3n s\u00f3lo estar\u00e1n disponibles en aquellos tipos que se ajusten al protocolo y cumplan el requisito. El requisito se definen usando una cl\u00e1usula gen\u00e9rica where en la que se indica una condici\u00f3n sobre alg\u00fan tipo asociado definido en el protocolo. Nota No hemos visto el concepto de tipo asociado en un protocolo. Es una especie de tipo gen\u00e9rico que se define en el protocolo y que se convierte en un tipo concreto en la clase que se ajusta al protocolo. Por ejemplo, podemos definir una extensi\u00f3n al protocolo Collection que se aplique a cualquier colecci\u00f3n cuyos elementos cumplen el protocolo Equatable . De esta forma nos aseguramos de que los operadores == y != est\u00e1n definidos y podemos usarlos en la extensi\u00f3n: extension Collection where Element : Equatable { func allEqual () -> Bool { for element in self { if element != self . first { return false } } return true } } El nombre Element es un nombre definido en el protocolo Collection que se refiere al tipo de los elementos de la colecci\u00f3n. Es un tipo asociado . El m\u00e9todo allEqual() devuelve true si y s\u00f3lo si todos los elementos en la colecci\u00f3n son iguales. Un ejemplo: let numerosIguales = [ 100 , 100 , 100 , 100 , 100 ] let numerosDiferentes = [ 100 , 100 , 200 , 100 , 200 ] Dado que ambos arrays cumplen el protocolo Collection y los enteros cumplen el protocolo Equatable podemos usar el m\u00e9todo allEqual() : print(numerosIguales.allEqual()) // Prints \"true\" print(numerosDiferentes.allEqual()) // Prints \"false\" En una colecci\u00f3n cuyos elementos no cumplen el protocolo Equatable no se puede utilizar el m\u00e9todo de la extensi\u00f3n: let tormenta = Persona ( edad : 32 , nombreCompleto : \"Ororo Munroe\" ) let superHeroes = [ tormenta , peterParker , reedRichards ] print ( superHeroes . allEqual ()) //error: type 'Persona' does not conform to protocol 'Equatable' 10. Funciones operadoras \u00b6 Las clases y las estructuras pueden proporcionar sus propias implementaciones de operadores existentes. Esto se conoce como sobrecarga de los operadores existentes. En el siguiente ejemplo se muestra c\u00f3mo implementar el operador de suma ( + ) para una estructura. El operador suma es un operador binario (tiene dos operandos) e infijo (aparece junto entre los dos operandos). Definimos una estructura Vector2D para un vector de posici\u00f3n de dos dimensiones: struct Vector2D { var x = 0.0 , y = 0.0 static func + ( izquierdo : Vector2D , derecho : Vector2D ) -> Vector2D { return Vector2D ( x : izquierdo . x + derecho . x , y : izquierdo . y + derecho . y ) } } La funci\u00f3n operador se define como una funci\u00f3n est\u00e1tica con un un nombre de funci\u00f3n que empareja con el operador a sobrecargar ( + ). Debido a que la suma aritm\u00e9tica se define como un operador binario, esta funci\u00f3n operador toma dos par\u00e1metros de entrada de tipo Vector2D y devuelve un \u00fanico valor de salida, tambi\u00e9n de tipo Vector2D . En esta implementaci\u00f3n, llamamos a los par\u00e1metros de entrada izquierdo y derecho para representar las instancias de Vector2D que estar\u00e1n a la izquierda y a la derecha del operador + . Son nombres arbitrarios, lo importante es la posici\u00f3n. El primer par\u00e1metro de la funci\u00f3n es el que hace de primer operador. La funci\u00f3n devuelve una nueva instancia de Vector2D , cuyas propiedades x e y se inicializan con la suma de las propiedades x e y de las instancias de Vector2D que se est\u00e1n sumando. La funci\u00f3n se define globalmente, m\u00e1s que como un m\u00e9todo en la estructura Vector2D , para que pueda usarse como un operador infijo entre instancias existentes de Vector2D : let vector = Vector2D ( x : 3.0 , y : 1.0 ) let otroVector = Vector2D ( x : 2.0 , y : 4.0 ) let vectorSuma = vector + otroVector // vectorSuma es una instancia de Vector2D con valores de (5.0, 5.0) 10.1. Operadores prefijos y postfijos \u00b6 El ejemplo anterior demuestra una implementaci\u00f3n propia de un operador binario infijo. Las clases y las estructuras pueden tambi\u00e9n proporcionar implementaciones de los operadores unarios est\u00e1ndar. Los operadores unarios operan sobre un \u00fanico objetivo. Son prefijos se preceden el objetivo (como -a ) y postfijos si siguen su objetivo (como en b! ). Para implementar un operador unario prefijo o postfijo se debe escribir el modificador prefix o postfix antes de la palabra clave func en la declaraci\u00f3n de la funci\u00f3n operador: struct Vector2D { ... static prefix func - ( vector : Vector2D ) -> Vector2D { return Vector2D ( x : - vector . x , y : - vector . y ) } } El ejemplo anterior implementa el operador unario negaci\u00f3n ( -a ) para instancias de Vector2D . Por ejemplo: let positivo = Vector2D ( x : 3.0 , y : 4.0 ) let negativo = - positivo // negativo es una instancia de Vector2D con valores de (-3.0, -4.0) let tambienPositivo = - negativo // tambienPositivo es una instancia de Vector2D con valores de (3.0, 4.0) 11. Gen\u00e9ricos \u00b6 Veamos c\u00f3mo podemos utilizar los gen\u00e9ricos con clases y estructuras. Vamos a utilizar como ejemplo un tipo de dato muy sencillo: una pila ( stack ) en la que se podr\u00e1n a\u00f1adir ( push ) y retirar ( pop ) elementos. La versi\u00f3n no gen\u00e9rica del tipo de dato es la siguiente, en la que se implementa una pila de enteros. struct IntStack { var items = [ Int ]() mutating func push ( _ item : Int ) { items . append ( item ) } mutating func pop () -> Int { return items . removeLast () } } La estructura usa un array para guardar los \u00edtems y los m\u00e9todos push y pop a\u00f1aden y retiran los elementos. El problema de esta estructura es su falta de genericidad; s\u00f3lo puede almacenar enteros. Aqu\u00ed est\u00e1 una versi\u00f3n gen\u00e9rica del mismo c\u00f3digo: struct Stack < Element > { var items = [ Element ]() mutating func push ( _ item : Element ) { items . append ( item ) } mutating func pop () -> Element { return items . removeLast () } } El par\u00e1metro del tipo Element define un tipo gen\u00e9rico que se utiliza como placeholder del tipo real del que se declare la estructura. Podemos ver que se utiliza en la definici\u00f3n de los distintos elementos de la estructura. Por ejemplo, el array de \u00edtems es un array de Element s. Y los \u00edtems a\u00f1adidos y retirados de la pila son tambi\u00e9n objetos de tipo Element . Por ejemplo, podemos crear una pila de cadenas: var stackOfStrings = Stack < String >() stackOfStrings . push ( \"uno\" ) stackOfStrings . push ( \"dos\" ) stackOfStrings . push ( \"tres\" ) stackOfStrings . push ( \"cuatro\" ) // la pila contiene ahora 4 cadenas Y podemos retirar la \u00faltima cadena de la pila: let fromTheTop = stackOfStrings . pop () 11.1. Extensi\u00f3n de un tipo gen\u00e9rico \u00b6 Cuando se extiende un tipo gen\u00e9rico, no hace falta a\u00f1adir el par\u00e1metro del tipo entre <> . El tipo gen\u00e9rico est\u00e1 disponible a partir de la definici\u00f3n original y se puede usar tal cual en el cuerpo de la extensi\u00f3n. Por ejemplo, podemos extender el tipo gen\u00e9rico Stack para a\u00f1adir una propiedad computable de s\u00f3lo lectura que devuelva el tope de la pila: extension Stack { var topItem : Element ? { return items . isEmpty ? nil : items [ items . count - 1 ] } } En la extensi\u00f3n se utiliza el nombre gen\u00e9rico Element sin tener que declararlo despu\u00e9s de Stack , porque est\u00e1 definido en la estructura original. Ahora ya se puede acceder al tope de la pila sin retirar el elemento: if let topItem = stackOfStrings . topItem { print ( \"El \u00edtem en el tope de la pila es \\( topItem ) .\" ) } // Imprime \"El \u00edtem en el tope de la pila es tres.\" 12. Bibliograf\u00eda \u00b6 Swift Language Guide Classes and Structures Properties Methods Inheritance Initialization Protocolos Casting de tipos Extensiones Funciones operador Gen\u00e9ricos Lenguajes y Paradigmas de Programaci\u00f3n, curso 2021\u201322 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Domingo Gallardo, Cristina Pomares, Antonio Bot\u00eda, Francisco Mart\u00ednez","title":"Tema06 programacion orientada objetos swift"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#tema-6-programacion-orientada-a-objetos-con-swift","text":"","title":"Tema 6: Programaci\u00f3n Orientada a Objetos con Swift"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#1-introduccion-a-la-programacion-orientada-a-objetos","text":"La Programaci\u00f3n Orientada a Objetos (POO) es un paradigma de programaci\u00f3n que explota en los 80 pero nace a partir de ideas a finales de los 60 y 70. Por ejemplo, el primer lenguaje con las ideas b\u00e1sicas de POO fue Simula , un lenguaje creado en la d\u00e9cada de los 60. En la d\u00e9cada de los 60 lo habitual era la programaci\u00f3n procedural. Los programas se defin\u00edan usando tipos de datos abstractos y funciones. La modularizaci\u00f3n se realizaba mediante funciones. Como hemos mencionado, a finales de los 60, el lenguaje Simula introduce el concepto de clase. Una abstracci\u00f3n que agrupa estado y funciones en una \u00fanica entidad. Sin embargo, tuvo que pasar m\u00e1s de una d\u00e9cada, hasta principios de los 80, para que el paradigma orientado a objetos se popularizara. Una de las razones principales de esta popularizaci\u00f3n fue el lenguaje Smalltalk , un lenguaje creado en Xerox PARC que fue revolucionario en muchos aspectos. Por ejemplo, Smaltallk introdujo conceptos como las interfaces gr\u00e1ficas de usuario (el uso del rat\u00f3n, de las ventanas) o un entorno integrado de programaci\u00f3n que estaba escrito en el propio Smalltalk y que el programador pod\u00eda adaptar y ampliar. En la figura de la derecha podemos ver un ejemplo del entorno, en el que se muestra un ejemplo de escritorio con m\u00faltiples ventanas que se solapan, men\u00fas desplegables, paneles gr\u00e1ficos, etc. Alan Kay fue uno de los padres de Smalltalk, el creador del t\u00e9rmino \u201cObject-Oriented\u201d y una de las figuras fundamentales de la historia de la inform\u00e1tica moderna. Trabaj\u00f3 en Xerox PARC y desarroll\u00f3 all\u00ed ideas que han sido clave para la inform\u00e1tica personal (como el Dynabook, precursor de tablets y dispositivos m\u00f3viles y el lenguajes de programaci\u00f3n Smalltalk). Se puede tener una idea de toda esta gesta en su art\u00edculo \u201cThe Early History of Smalltalk\u201d . Algunas frases de Alan Kay: \u201cI invented the term Object-Oriented and I can tell you I did not have C++ in mind.\u201d \u201cSmalltalk is not only NOT its syntax or the class library, it is not even about classes. I'm sorry that I long ago coined the term objects for this topic because it gets many people to focus on the lesser idea. The big idea is messaging.\u201d \u201cSmalltalk's design\u2013and existence\u2013is due to the insight that everything we can describe can be represented by the recursive composition of a single kind of behavioral building block that hides its combination of state and process inside itself and can be dealt with only through the exchange of messages.\u201d En la d\u00e9cada de los 80 el paradigma orientado a objetos tuvo una enorme repercusi\u00f3n y, a partir de ah\u00ed, casi todos los lenguajes lo han adoptado. Lenguajes como Smalltalk, Java, Scala, Ruby, Python, C#, C++, Swift, etc. utilizan el paradigma orientado a objetos. Entre las caracter\u00edsticas principales del paradigma de programaci\u00f3n orientado a objetos podemos destacar: Las clases son plantillas est\u00e1ticas definidas en tiempo de compilaci\u00f3n. Los objetos se instancian a partir de las clases y se modifican e interact\u00faan en tiempo de ejecuci\u00f3n. Los objetos agrupan estado interno (las denominadas propiedades , campos o variables de instancias ) y conducta (los m\u00e9todos a los que puede responder el objeto). Existe el polimorfismo . Un mismo m\u00e9todo puede estar definido en m\u00e1s de una clase. Dependiendo del tipo de la instancia el c\u00f3digo que se ejecuta es distinto. Por ejemplo, podr\u00edamos definir un m\u00e9todo suma en la clase Int y otro m\u00e9todo con el mismo nombre en otra clase String . El primer m\u00e9todo suma dos enteros y el segundo concatena dos cadenas. En algunos lenguajes orientados a objetos (como Python o Ruby) la invocaci\u00f3n los m\u00e9todos se hace usando un dispatch din\u00e1mico : cuando una operaci\u00f3n es invocada sobre un objeto, el propio objeto determina en tiempo de ejecuci\u00f3n qu\u00e9 c\u00f3digo se ejecuta. Una caracter\u00edstica fundamental de la POO es la herencia . Las clases se pueden definir utilizando otras clases como plantillas y modificando sus m\u00e9todos y/o variables de instancia para hacerlas m\u00e1s especializadas. Existen dos tendencias ortogonales en el dise\u00f1o de lenguajes orientados a objetos. Por un lado una familia de lenguajes orientados a objetos son lenguajes muy din\u00e1micos . Son lenguajes con un tipado d\u00e9bil en los que muchas caracter\u00edsticas de los programas se obtienen en tiempo de ejecuci\u00f3n. Estos lenguajes permiten mayor flexibilidad y generalidad del c\u00f3digo, y tienen caracter\u00edsticas como el dispatch din\u00e1mico o la reflexi\u00f3n (posibilidad de consultar caracter\u00edsticas de la instancia como nombres de m\u00e9todos o propiedades en tiempo de ejecuci\u00f3n). Ejemplos de este tipo de lenguajes son Smalltalk, Ruby, Python, JavaScript o Java (en menor medida). Por otro lado, existen lenguajes de programaci\u00f3n orientados a objetos que tienen un alto componente est\u00e1tico, donde la mayor\u00eda de caracter\u00edsticas del programa se obtienen en tiempo de compilaci\u00f3n. En este tipo de lenguajes se prima que el compilador sea muy robusto y detecte la mayor cantidad de errores a priori y que genere c\u00f3digo muy eficiente. Son lenguajes fuertemente tipados como C++ o Swift. Vamos a detallar a continuaci\u00f3n las caracter\u00edsticas m\u00e1s importantes de Programaci\u00f3n Orientada a Objetos de Swift.","title":"1. Introducci\u00f3n a la Programaci\u00f3n Orientada a Objetos"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#2-clases-y-estructuras","text":"En el caso de Swift, las clases y las estructuras son muchas m\u00e1s cercanas en funcionalidad que en otros lenguajes, como C o C++, y tienen muchas caracter\u00edsticas comunes. Muchas caracter\u00edsticas de las instancias de una clase se pueden aplicar tambi\u00e9n a las instancias de una estructura. Por eso en Swift se suele hablar de instancias (un t\u00e9rmino m\u00e1s general) en lugar de objetos . Las clases y las estructuras en Swift tienen muchas cosas en com\u00fan. Ambos pueden: Definir propiedades y almacenar valores Definir m\u00e9todos para proporcionar funcionalidad Definir sub\u00edndices para proporcionar acceso a sus valores usando una sintaxis de sub\u00edndice Definir inicializadores para configurar el estado inicial Ser extendidas para expandir su funcionalidad m\u00e1s all\u00e1 de una implementaci\u00f3n por defecto Ajustarse a un protocolo La diferencia fundamental es que las estructuras son tipos valor, mientras que las clases son tipos referencia. La sem\u00e1ntica de copia de ambas es radicalmente distinta. Cuando asignamos una instancia de una estructura a una variable estamos realizando una copia de su valor (por ejemplo, cuando asignamos un n\u00famero entero). Sin embargo, cuando asignamos una instancia de una clase a una variable estamos guardando su referencia. De esta forma en las clases se permiten que existan m\u00e1s de una referencia apuntando a una instancia de una clase. Otras caracter\u00edsticas adicionales de las clases que no tienen las estructuras: Mediante la herencia una clase puede heredar las caracter\u00edsticas de otra El casting de tipos permite comprobar e interpretar el tipo de una instancia de una clase en tiempo de ejecuci\u00f3n Los deinicializadores permiten a una instancia de una clase liberar los recursos que ha asignado","title":"2. Clases y estructuras"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#21-definicion","text":"class UnaClase { // definici\u00f3n de clase } struct UnaEstructura { // definici\u00f3n de una estructura } struct CoordsPantalla { var posX = 0 var posY = 0 } class Ventana { var esquina = CoordsPantalla () var altura = 0 var anchura = 0 var visible = true var etiqueta : String ? } El ejemplo define una nueva estructura llamada CoordsPantalla , que describe una coordenada de pantalla con posiciones basadas en p\u00edxeles. La estructura tiene dos propiedades almacenadas llamadas posX y posY . Las propiedades son constantes o variables que se almacenan en la instancia de la clase o de la estructura. El compilador infiere que estas dos propiedades son Int al inicializarlas a los valores iniciales de 0. El ejemplo tambi\u00e9n define una nueva clase llamada Ventana que describe una ventana en una pantalla. Esta clase tiene cinco propiedades variables. La primera, esquina , se inicializa con una instancia nueva de una estructura CoorsPantalla y se infiere que es de tipo CoordsPantalla . Representa la posici\u00f3n superior izquierda de la ventana. Las propiedades altura y anchura representan el n\u00famero de p\u00edxeles de las dimensiones de la pantalla. Se inicializan a 0. La propiedad visible es un Bool que indica si la ventana es visible en pantalla. Por ejemplo, una ventana que est\u00e9 minimizada no ser\u00e1 visible. Por \u00faltimo, etiqueta representa el nombre que aparece en la parte superior de la ventana. Es un String opcional que se inicializa a nil porque no se le asigna un valor inicial.","title":"2.1. Definici\u00f3n"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#22-instancias-de-clases-y-estructuras","text":"La definici\u00f3n de las estructuras y las clases \u00fanicamente definen sus aspectos generales. Para describir una configuraci\u00f3n espec\u00edfica (una resoluci\u00f3n o un modo de v\u00eddeo concreto) es necesario crear una instancia de una estructura o una clase. La sintaxis para crear ambas es similar: var unasCoordsPantalla = CoordsPantalla () var unaVentana = Ventana () La forma m\u00e1s sencilla de inicializaci\u00f3n es la anterior. Se utiliza el nombre del tipo de la clase o estructura seguidos de par\u00e9ntesis vac\u00edos. Esto crea una nueva instancia de una clase o estructura, con sus propiedades inicializadas a los valores por defecto definidos en la declaraci\u00f3n de las propiedades. Swift proporciona este inicializador por defecto para clases y estructuras, siempre que no se defina alg\u00fan inicializador expl\u00edcito. M\u00e1s adelante comentaremos c\u00f3mo definir estos inicializadores expl\u00edcitos. En el caso de la instancia unasCoordsPantalla los valores a los que se han inicializado sus propiedades son: unasCoordsPantalla . posX // 0 unasCoordsPantalla . posY // 0 Las propiedades de la instancia unaVentana son: unaVentana . esquina // CoordsPantalla con posX = 0 y posY = 0 unaVentana . altura // 0 unaVentana . anchura // 0 unaVentana . visible // true unaVentana . etiqueta // nil Todas las propiedades de una instancia deben estar definidas despu\u00e9s de haberse inicializado, a no ser que la propiedad sea un opcional.","title":"2.2. Instancias de clases y estructuras"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#23-acceso-a-propiedades","text":"Se puede acceder y modificar las propiedades usando la sintaxis de punto : // Accedemos a la propiedad unasCoordsPantalla . posX // Devuelve 0 // Actualizamos la propiedad unasCoordsPantalla . posX = 100 unaVentana . esquina . posY = 100","title":"2.3. Acceso a propiedades"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#24-inicializacion-de-las-estructuras-por-sus-propiedades","text":"Si en las estructuras no se se definen inicializadores expl\u00edcitos (veremos m\u00e1s adelante c\u00f3mo hacerlo) podemos utilizar un inicializador memberwise en el que podemos proporcionar valores de sus propiedades. En las clases no existen los inicializadores memberwise , s\u00f3lo en las estructuras. Por ejemplo, podemos crear una instancia de la estructura anterior con valores distintos de los valores por defecto definidos en la propia estructura. let coords = CoordsPantalla ( posX : 200 , posY : 400 ) Cuando se llama al inicializador memberwise podemos omitir valores de cualquier propiedad que tenga un valor por defecto, o que sea un opcional. En el ejemplo anterior, la estructura CoordsPantalla tiene valores por defecto de las propiedades posX y posY . Podr\u00edamos omitir cualquier propiedad o ambas y el inicializador usar\u00e1 el valor por defecto de lo que omitamos. Por ejemplo: let coords1 = CoordsPantalla ( posX : 200 ) print ( coords1 . posX , coords1 . posY ) // Imprime 200 0","title":"2.4. Inicializaci\u00f3n de las estructuras por sus propiedades"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#25-estructuras-y-enumeraciones-son-tipos-valor","text":"Un tipo valor es un tipo cuyo valor se copia cuando se asigna a una variable o constante, o cuando se pasa a una funci\u00f3n. Todos los tipos b\u00e1sicos de Swift -enteros, n\u00fameros en punto flotante, cadenas, arrays y diccionarios- son tipos valor y se implementan como estructuras. Las estructuras y las enumeraciones son tipos valor en Swift. 1 2 3 4 var coords1 = CoordsPantalla ( posX : 600 , posY : 600 ) var coords2 = coords1 coords2 . posX = 1000 coords1 . posX // devuelve 600 En el ejemplo se declara una constante llamada coords1 y se asigna a una instancia de CoordsPantalla inicializada con la posici\u00f3n x de 600 y la posici\u00f3n y de 600. Despu\u00e9s se declara una variable llamada coords2 y se asigna al valor actual de coors1 . Debido a que CoordsPantalla es una estructura, se crea una copia de la instancia existente y esta nueva copia se asigna a coords2 . Aunque ahora coords2 y coords1 tienen las mismas posX y posY , son dos instancias completamente distintas. Despu\u00e9s, la propiedad posX de coords2 se actualiza a 1000. Podemos comprobar que la propiedad se modifica, pero que el valor de posX en coords1 sigue siendo el mismo.","title":"2.5. Estructuras y enumeraciones son tipos valor"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#26-las-clases-son-tipos-referencia","text":"A diferencia de los tipos valor, los tipos de referencias no se copian cuando se asignan o se pasan a funciones. En su lugar se usa una referencia a la misma instancia existente. En Swift las clases son tipos referencias. Veamos, por ejemplo, una instancia de la clase Ventana : 1 2 3 4 5 6 7 8 var ventana1 = Ventana () ventana1 . esquina = coords1 ventana1 . altura = 800 ventana1 . anchura = 800 ventana1 . etiqueta = \"Finder\" var ventana2 = ventana1 ventana2 . anchura = 1000 ventana1 . anchura // devuelve 1000 Declaramos una variable llamada ventana1 inicializada con una instancia nueva de la clase Ventana . Le asignamos a la propiedad esquina una copia de la resoluci\u00f3n anterior coords1 . Despu\u00e9s declaramos la altura, anchura y etiqueta de la ventana. Y, por \u00faltimo, ventana1 se asigna a una nueva constante llamada ventan2 , y la anchura se modifica. Debido a que son tipos de referencia, ventana1 y ventana2 se refieren a la misma instancia de Ventana . Son s\u00f3lo dos nombres distintos para la misma \u00fanica instancia. Lo podemos comprobar modificando una propiedad mediante una variable y viendo que esa misma propiedad en la otra variable se ha modificado tambi\u00e9n (l\u00edneas 7 y 8). Si tienes experiencia con C, C++, o Objective-C, puedes saber que estos lenguajes usan punteros para referirse a una direcci\u00f3n de memoria. Una constante o variable en Swift que se refiere a una instancia de un tipo referencia es similar a un puntero en C, pero no es un puntero que apunta a una direcci\u00f3n de memoria y no requiere que se escriba un asterisco (*) para indicar que estas creando una referencia. En su lugar, estas referencias se definen como cualquier otra constante o variable en Swift.","title":"2.6. Las clases son tipos referencia"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#27-declaracion-de-instancias-con-let","text":"Las estructuras y clases tambi\u00e9n tienen comportamientos distintos cuando se declaran las variables con let . Si definimos con let una instancia de una estructura estamos declarando constante la variable y todas las propiedades de la instancia. No podremos modificar ninguna: let coords3 = CoordsPantalla ( posX : 400 , posY : 400 ) coords3 . posX = 800 // error: cannot assign to property: 'coords3' is a 'let' constant Si definimos con un let una instancia de una clase s\u00f3lo estamos declarando constante la variable. No podremos reasignarla, pero s\u00ed que podremos modificar las propiedades de la instancia referenciada por la variable: let ventana3 = Ventana () // S\u00ed que podemos modificar una propiedad de la instancia: ventana3 . etiqueta = \"Listado\" // Pero no podemos reasignar la variable: ventana3 = ventana1 // error: cannot assign to value: 'ventana3' is a 'let' constant","title":"2.7. Declaraci\u00f3n de instancias con let"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#28-operadores-de-identidad","text":"A veces puede ser \u00fatil descubrir si dos constantes o variables se refieren exactamente a la misma instancia de una clase. Para permitir esto, Swift proporciona dos operadores de identidad: Id\u00e9ntico a ( === ) No id\u00e9ntico a ( !== ) ventana1 === ventana2 // devuelve true ventana1 === ventana3 // devuelve false Estos operadores \"id\u00e9ntico a\" no son los mismos que los de \"igual a\" (representado por dos signos iguales == ): \"Id\u00e9ntico a\" significa que dos constantes o variables de una clase se refieren exactamente a la misma instancia de la clase. \"Igual a\" significa que dos instancias se consideran \"iguales\" o \"equivalentes\" en su valor. Es responsabilidad del dise\u00f1ador de la clase definir la implementaci\u00f3n de estos operadores.","title":"2.8. Operadores de identidad"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#29-paso-como-parametro","text":"En Swift los par\u00e1metros de las funciones son constantes, se definen usando el operador let . Esto hace que sea muy distinto el comportamiento de un par\u00e1metro dependiendo de si es una estructura o una clase. Si la instancia que se pasa como par\u00e1metro a una funci\u00f3n es una estructura su contenido no se podr\u00e1 modificar. Sin embargo, si lo que se pasa es una instancia de una clase, podremos modificar su contenido, ya que (como hemos visto anteriormente) el let hace constante \u00fanicamente la referencia, pero no el contenido. Por ejemplo, la siguiente funci\u00f3n es t\u00edpica de programaci\u00f3n imperativa o procedural. El par\u00e1metro ventana se pasa por referencia y se modifica en el interior de la funci\u00f3n. Su estado cambia. Una vez terminada la funci\u00f3n la variable que hemos pasado como par\u00e1metro contiene una instancia cambiada. Podemos hacerlo porque ventana es una clase. func mueve ( ventana : Ventana , incX : Int , incY : Int ) { var nuevaPos = CoordsPantalla () nuevaPos . posX = ventana . esquina . posX + incX nuevaPos . posY = ventana . esquina . posY + incY ventana . esquina = nuevaPos } var ventana1 = Ventana () mueve ( ventana : ventana1 , incX : 500 , incY : 500 ) print ( ventana1 . esquina ) // Imprime: CoordsPantalla(posX: 500, posY: 500) Sin embargo, si pasamos como par\u00e1metro una instancia de una estructura, \u00e9sta ser\u00e1 inmutable. El siguiente c\u00f3digo genera un error en el compilador que indica que el par\u00e1metro coordsPantalla es una constante y no puede ser modificado: // \u00a1\u00a1C\u00d3DIGO ERR\u00d3NEO!! func mueve ( coordsPantalla : CoordsPantalla , incX : Int , incY : Int ) { coordsPantalla . posX = coordsPantalla . posX + incX coordsPantalla . posY = coordsPantalla . posY + incY } // error: cannot assign to property: 'coordsPantalla' is a 'let' constant Si necesitamos hacer una funci\u00f3n con la que se obtenga un valor modificado de una estructura, podemos usar el enfoque funcional de crear una nueva estructura y devolverla como resultado: func mueve ( coordsPantalla : CoordsPantalla , incX : Int , incY : Int ) -> CoordsPantalla { var nuevaCoord = CoordsPantalla () nuevaCoord . posX = coordsPantalla . posX + incX nuevaCoord . posY = coordsPantalla . posY + incY return nuevaCoord } let coord1 = CoordsPantalla () let coord2 = mueve ( coordsPantalla : coord1 , incX : 100 , incY : 100 ) print ( coord1 ) // Imprime CoordsPantalla(posX: 100, posY: 100) Vemos en el c\u00f3digo que se crea una nueva instancia y que se modifica su valor de forma acorde a lo que quiere hacer la funci\u00f3n y que se devuelve ese nuevo valor. Usando esta \u00faltima funci\u00f3n podr\u00edamos reescribir el c\u00f3digo de la funci\u00f3n que mueve una ventana de la siguiente forma: func mueve ( ventana : Ventana , incX : Int , incY : Int ) { ventana . esquina = mueve ( coordsPantalla : ventana . esquina , incX : incX , incY : incY ) } Nota Igual que en C, en Swift hay una forma de pasar como referencia una estructura. Hay que utilizar el operador inout precediendo el nombre del par\u00e1metro. Puedes encontrar m\u00e1s informaci\u00f3n en la documentaci\u00f3n oficial de Swift. Busca el apartado In-Out paremeters en la p\u00e1gina sobre Funciones .","title":"2.9. Paso como par\u00e1metro"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#210-criterios-para-usar-estructuras-y-clases","text":"Podemos usar tanto clases como estructuras para definir nuestros tipos de datos y utilizarlos como bloques de construcci\u00f3n del c\u00f3digo de nuestros programas. Sin embargo, se utilizan para distintos tipos de tareas. Como regla general, utilizaremos una estructura cuando se cumplen una o m\u00e1s de las siguientes condiciones: El principal objetivo de la estructura es encapsular unos pocos datos relativamente sencillos. Es razonable esperar que los valores encapsulados ser\u00e1n copiados, m\u00e1s que referenciados, cuando asignamos o pasamos una instancia de esa estructura. Todas las propiedades almacenadas en la estructura son a su vez tipos valor, que tambi\u00e9n se espera que sean copiados m\u00e1s que referenciados. La estructura no necesita heredar propiedades o conducta de otro tipo existente. Ejemplos de buenos candidatos de estructuras incluyen: El tama\u00f1o de una forma geom\u00e9trica, encapsulando por ejemplo las propiedades ancho y alto de tipo Double . Una forma de referirse a rangos dentro de una serie, encapsulando por ejemplo, una propiedad comienzo y otra longitud , ambos del tipo Int . Un punto en un sistema de coordenadas 3D, encapsulando quiz\u00e1s las propiedades x , y y z , todos ellos de tipo Double . Usaremos clases cuando queramos utilizar una sem\u00e1ntica de referencia en lugar de una sem\u00e1ntica de valor. Por ejemplo, si queremos tener un grafo de objetos en los que m\u00e1s de un objeto refiere a otro. Tambi\u00e9n cuando queramos utilizar herencia y polimorfismo en nuestro c\u00f3digo. En la pr\u00e1ctica, esto representa que la mayor\u00eda de datos que construiremos en nuestros programas ser\u00e1n clases, no estructuras. Aunque usaremos muchas de las estructuras est\u00e1ndar de Swift.","title":"2.10. Criterios para usar estructuras y clases"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#3-propiedades","text":"Las propiedades asocian valores con una clase, estructura o enumeraci\u00f3n particular. Las propiedades almacenadas ( stored properties ) almacenan valores constantes y variables como parte de una instancia, mientras que las propiedades calculadas ( computed properties ) calculan (en lugar de almacenar) un valor. Las propiedades calculadas se definen en clases, estructuras y enumeraciones. Las propiedades almacenadas se definen s\u00f3lo en clases y estructuras. Enumeraciones: pueden contener s\u00f3lo propiedades calculadas. Clases y estructuras: pueden contener propiedades almacenadas y calculadas. Las propiedades calculadas y almacenadas se asocian habitualmente con instancias de un tipo particular. Sin embargo, las propiedades tambi\u00e9n pueden asociarse con el propio tipo. Estas propiedades se conocen como propiedades del tipo ( type properties ). Adem\u00e1s, en Swift es posible definir observadores de propiedades que monitoricen cambios en los valores de una propiedad, a los que podemos responder con acciones programadas. Los observadores de propiedades pueden a\u00f1adirse tanto a propiedades almacenadas definidas por nosotros como a propiedades heredadas de la superclase.","title":"3. Propiedades"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#31-propiedades-almacenadas","text":"En su forma m\u00e1s simple, una propiedad almacenada es una constante o variable que est\u00e1 almacenada como parte de una instancia de una clase o estructura particular. Las propiedades almacenadas pueden ser o bien variables (usando la palabra clave var ) o bien constantes (usando la palabra clave let ). Podemos proporcionar un valor por defecto para la inicializaci\u00f3n de las propiedades almacenadas, tanto variables como constantes. El siguiente ejemplo define una estructura llamada RangoLongitudFija que describe un rango de valores enteros cuya longitud no puede ser modificada una vez que se crea: struct RangoLongitudFija { var primerValor : Int let longitud : Int } var rangoTresItems = RangoLongitudFija ( primerValor : 0 , longitud : 3 ) // el rango representa ahora 0, 1, 2 rangoTresItems . primerValor = 6 // el rango representa ahora 6, 7, 8 Las instancias de RangoLongitudFija tienen una propiedad almacenada variable llamada primerValor y una propiedad almacenada constante llamada longitud . En el ejemplo, longitud se inicializa cuando se crea el nuevo rango y no puede ser cambiada en el futuro, por ser una propiedad constante.","title":"3.1. Propiedades almacenadas"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#32-propiedades-calculadas","text":"Adem\u00e1s de las propiedades almacenadas, las clases, estructuras y enumeraciones pueden definir propiedades calculadas , que no almacenan realmente un valor. En su lugar, proporcionan un getter y un opcional setter que devuelven y modifican otras propiedades y valores de forma indirecta. struct Punto { var x = 0.0 , y = 0.0 } struct Tama\u00f1o { var ancho = 0.0 , alto = 0.0 } struct Rectangulo { var origen = Punto () var tama\u00f1o = Tama\u00f1o () var centro : Punto { get { let centroX = origen . x + ( tama\u00f1o . ancho / 2 ) let centroY = origen . y + ( tama\u00f1o . alto / 2 ) return Punto ( x : centroX , y : centroY ) } set ( centroNuevo ) { origen . x = centroNuevo . x - ( tama\u00f1o . ancho / 2 ) origen . y = centroNuevo . y - ( tama\u00f1o . alto / 2 ) } } } var cuadrado = Rectangulo ( origen : Punto ( x : 0.0 , y : 0.0 ), tama\u00f1o : Tama\u00f1o ( ancho : 10.0 , alto : 10.0 )) let centroCuadradoInicial = cuadrado . centro cuadrado . centro = Punto ( x : 15.0 , y : 15.0 ) print ( \"cuadrado.origen est\u00e1 ahora en ( \\( cuadrado . origen . x ) , \\( cuadrado . origen . y ) )\" ) // Imprime \"cuadrado.origen est\u00e1 ahora en (10.0, 10.0)\" Este ejemplo define tres estructuras para trabajar con formas geom\u00e9tricas: Punto encapsula una coordenada (x, y) Tama\u00f1o encapsula un ancho y un alto Rectangulo define una rect\u00e1ngulo por un punto de origen y un tama\u00f1o La estructura Rectangulo proporciona una propiedad calculada llamada centro . La posici\u00f3n actual del centro de un Rectangulo puede ser siempre determinada a partir de su origen y su tama\u00f1o, por lo que no necesitamos almacenarlo como un Punto expl\u00edcito. En su lugar, Rectangulo define un getter y un setter programado para una variable calculada llamada centro , para permitirnos trabajar con el centro del rect\u00e1ngulo como si fuera una propiedad almacenada. En el ejemplo se crea una variable Rectangulo llamada cuadrado . La variable cuadrado se inicializa un punto origen de (0, 0) y un ancho y tama\u00f1o de 10 . Este cuadrado est\u00e1 representado por el cuadrado azul en el diagrama de abajo. Accedemos entonces a la propiedad centro de la variable cuadrado usando la sintaxis del punto ( cuadrado.centro ), lo que causa que se llame al getter de centro para devolver el valor actual de la propiedad. En lugar de devolver los valores existentes, el getter calcula realmente y devuelve un nuevo Punto para representar el centro del cuadrado. Como puede verse arriba, el getter devuelve correctamente un punto con los valores (5, 5) . Despu\u00e9s la propiedad centro se actualiza al nuevo valor de (15, 15) lo que mueve el cuadrado arriba a la derecha, a la nueva posici\u00f3n mostrada por el cuadrado naranja en el diagrama de abajo. Al asignar el nuevo valor a la propiedad se llama al setter del centro, lo que modifica los valores x e y de las propiedades almacenadas originales, y mueve el cuadrado a su nueva posici\u00f3n. Se puede definir una versi\u00f3n acortada del setter usando la variable por defecto newValue que contiene el nuevo valor asignado en el setter : struct Rectangulo { var origen = Punto () var tama\u00f1o = Tama\u00f1o () var centro : Punto { get { let centroX = origen . x + ( tama\u00f1o . ancho / 2 ) let centroY = origen . y + ( tama\u00f1o . alto / 2 ) return Punto ( x : centroX , y : centroY ) } set { origen . x = newValue . x - ( tama\u00f1o . ancho / 2 ) origen . y = newValue . y - ( tama\u00f1o . alto / 2 ) } } }","title":"3.2. Propiedades calculadas"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#33-propiedades-solo-lectura","text":"Una propiedad calculada con un getter y sin setter se conoce como una propiedad calculada de solo-lectura. Una propiedad calculada de solo-lectura siempre devuelve un valor, y puede accederse a ella usando la sintaxis de punto, pero no puede modificarse a un valor distinto. Es posible simplificar la declaraci\u00f3n de una propiedad calculada de solo-lectura eliminando la palabra clave get y sus llaves: struct Cuboide { var ancho = 0.0 , alto = 0.0 , profundo = 0.0 var volumen : Double { return ancho * alto * profundo } } let cuatroPorCincoPorDos = Cuboide ( ancho : 4.0 , alto : 5.0 , profundo : 2.0 ) print ( \"el volumen de cuatroPorCincoPorDos es \\( cuatroPorCincoPorDos . volumen ) \" ) // Imprime \"el volumen de cuatroPorCincoPorDos es 40.0\" Este ejemplo define una nueva estructura llamada Cubiode , que representa una caja rectangular 3D con propiedades ancho , alto y profundo . Esta estructura tiene una propiedad calculada llamada volumen , que calcula y devuelve el volumen actual del cuboide. No tendr\u00eda sentido que el volumen fuera modificable, porque no ser\u00eda ambiguo determinar qu\u00e9 valores concretos de ancho, alto y profundo deber\u00edan usarse para un valor particular del volumen.","title":"3.3. Propiedades solo-lectura"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#34-observadores-de-propiedades","text":"Los observadores de propiedades ( property observers ) observan y responden a cambios en el valor de una propiedad. Los observadores de propiedades se llaman cada vez que el valor de una propiedad es actualizado, incluso si el nuevo valor es el mismo que el valor actual de la propiedad. Se pueden a\u00f1adir observadores a cualquier propiedad almacenada que se definan. Se pueden tambi\u00e9n a\u00f1adir observadores a cualquier propiedad heredada (ya sea almacenada o calculada) sobreescribiendo la propiedad en la subclase. No es necesario definir observadores de propiedades calculadas no sobreescritas porque siempre es posible observar y responder a cambios en su valor en el setter de la propiedad. Es posible definir alguno o ambos de estos observadores sobre una propiedad: willSet es llamado justo antes de que el nuevo valor se almacena en la propiedad. didSet es llamado inmediatamente despu\u00e9s de que el nuevo valor es almacenado en la propiedad. Si implementamos un observador willSet , se le pasa el nuevo valor de la propiedad como un par\u00e1metro constante. Podemos especificar un nombre para este par\u00e1metro como parte de la implementaci\u00f3n de willSet . Si no escribimos el nombre del par\u00e1metro y los par\u00e9ntesis dentro de la implementaci\u00f3n, el par\u00e1metro estar\u00e1 disponible con el nombre por defecto de newValue . De forma similar, si implementamos un observador didSet , se pasa como un par\u00e1metro constante que contiene el valor antiguo de la propiedad. Podemos darle nombre al par\u00e1metro o usar el nombre por defecto de oldValue . Si asignamos un valor a la propiedad dentro de su propio observador didSet , el nuevo valor que asignamos reemplaza el que acaba de a\u00f1adirse a la propiedad. A continuaci\u00f3n podemos ver un ejemplo de willSet y didSet en acci\u00f3n. En \u00e9l definimos una clase nueva llamada CuentaPasos , que hace un seguimiento del n\u00famero total de pasos que una persona hace al caminar. Esta clase puede usarse con datos de entrada de un pod\u00f3metro o cualquier otro sistema de seguir el ejercicio de la persona durante su rutina diaria. class ContadorPasos { var totalPasos : Int = 0 { willSet ( nuevoTotalPasos ) { print ( \"Voy a actualizar totalPasos a \\( nuevoTotalPasos ) \" ) } didSet { if totalPasos > oldValue { print ( \"A\u00f1adidos \\( totalPasos - oldValue ) pasos\" ) } } } } let contadorPasos = ContadorPasos () contadorPasos . totalPasos = 200 // Imprime: \"Voy a actualizar totalPasos a 200\" // Imprime: \"A\u00f1adidos 200 pasos\" contadorPasos . totalPasos = 360 // Imprime: \"Voy a actualizar totalPasos a 360\" // Imprime: \"A\u00f1adidos 160 pasos\" contadorPasos . totalPasos = 896 // Imprime: \"Voy a actualizar totalPasos a 896\" // Imprime: \"A\u00f1adidos 536 pasos\" La clase CuentaPasos declara la propiedad totalPasos de tipo Int . Esta es una propiedad almacenada con observadores willSet y didSet . Los observadores willSet y didSet de totalPasos se llaman siempre que se le asigna un nuevo valor a la propiedad. Esto es as\u00ed incluso si el nuevo valor es el mismo que el valor actual. El observador willSet usa un par\u00e1metro definido por nosotros con el nombre de nuevoTotalPasos para el valor que llega. En el ejemplo, sencillamente imprime el valor que est\u00e1 a punto de establecer. El observador didSet se llama despu\u00e9s de que el valor de totalPasos se ha actualizado. Compara el nuevo valor de totalPasos con el valor antiguo. Si el n\u00famero total de pasos se ha incrementado, se imprime un mensaje indicando cu\u00e1ntos pasos se han tomado. El observador didSet no proporciona un par\u00e1metro definido por nosotros para el valor antiguo, sino que usa el nombre por defecto oldValue .","title":"3.4. Observadores de propiedades"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#35-variables-locales-y-globales","text":"Las capacidades anteriores de propiedades calculadas y de observadores tambi\u00e9n est\u00e1n disponibles para variables globales y locales. El siguiente ejemplo muestra un ejemplo con una variable calculada a partir de otras dos: var x = 10 { didSet { print ( \"El nuevo valor: \\( x ) y el valor antiguo: \\( oldValue ) \" ) } } var y = 2 * x var z : Int { get { return x + y } set { x = newValue / 2 y = newValue / 2 } } print ( z ) z = 100 print ( x )","title":"3.5. Variables locales y globales"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#36-propiedades-del-tipo","text":"Las propiedades de las instancias son propiedades que pertenecen a una instancia de un tipo particular. Cada vez que creamos una nueva instancia de ese tipo, tiene su propio conjunto de valores de propiedades, separados de los de cualquier otra instancia. Podemos definir tambi\u00e9n propiedades que pertenecen al tipo propiamente dicho, no a ninguna de las instancias de ese tipo. S\u00f3lo habr\u00e1 una copia de estas propiedades, sea cual sea el n\u00famero de instancias de ese tipo que creemos. Estos tipos de propiedades se llaman propiedades del tipo ( type propierties ). Se pueden definir en tanto en estructuras, clases como en enumeraciones. Las propiedades del tipo son \u00fatiles para definir valores que son universales a todas las instancias de un tipo particular, como una propiedad constante que todas las instancias pueden usar (como una constante est\u00e1tica en C), o una propiedad variable que almacena un valor que es global a todas las instancias de ese tipo (como una variable est\u00e1tica en C). Las propiedades del tipo almacenadas pueden ser variables o constantes. Las propiedades del tipo calculadas se declaran siempre como propiedades variables, de la misma forma que las propiedades calculadas de instancias. A diferencia de las propiedades almacenadas de instancias, debemos siempre proporcionar un valor por defecto para las propiedades almacenadas de tipo. Esto es debido a que el tipo por si mismo no tiene un inicializador que pueda asignar un valor en tiempo de inicializaci\u00f3n. En Swift, las propiedades del tipo se definen como parte de la definici\u00f3n del tipo, dentro de las llaves del tipo. Las propiedades del tipo toman valor en el \u00e1mbito del tipo. Para definir una propiedad del tipo hay que usar la palabra clave static . Para propiedades de tipo calculadas de clases, podemos usar en su lugar la palabra clave class para permitir a las subclases que sobreescriban la implementaci\u00f3n de la superclase. Las propiedades del tipo pueden ser tambi\u00e9n constantes ( let ) o variables ( var ). Ejemplo: struct UnaEstructura { static var almacenada = \"A\" static var calculada : Int { return 1 } } enum UnaEnumeracion { static var almacenada = \"A\" static var calculada : Int { return 1 } } class UnaClase { static var almacenada = \"A\" static var calculada : Int { return 1 } } Las propiedades del tipo se consultan y actualizan usando tambi\u00e9n la sintaxis de punto, pero sobre el tipo : UnaEstructura . almacenada // devuelve \"A\" UnaEstructura . almacenada = \"B\" UnaClase . calculada // devuelve 1 No es posible acceder a la variable del tipo a trav\u00e9s de una instancia: let a = UnaEstructura () a . almacenada // error El siguiente ejemplo muestra c\u00f3mo es posible usar una variable del tipo para almacenar informaci\u00f3n global a todas las instancias de ese tipo: struct Valor { var valor : Int = 0 { didSet { Valor . sumaValores += valor } } static var sumaValores = 0 } var c1 = Valor () var c2 = Valor () var c3 = Valor () c1 . valor = 10 c2 . valor = 20 c3 . valor = 30 print ( \"Suma de los cambios de valores: \\( Valor . sumaValores ) \" ) // Imprime 60","title":"3.6. Propiedades del tipo"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#4-metodos","text":"Los m\u00e9todos son funciones que est\u00e1n asociadas a un tipo particular. Las clases, estructuras y enumeraciones pueden definir todas ellas m\u00e9todos de instancia, que encapsulan tareas y funcionalidades espec\u00edficas que trabajan con una instancia de un tipo dado. Las clases, estructuras y enumeraciones tambi\u00e9n pueden definir m\u00e9todos del tipo, que est\u00e1n asociados con el propio tipo. Los m\u00e9todos del tipo son similares a los m\u00e9todos de clase en Java. El hecho de que las estructuras y las enumeraciones puedan definir m\u00e9todos en Swift es una diferencia importante con C y Objective-C.","title":"4. M\u00e9todos"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#41-metodos-de-instancia","text":"Los m\u00e9todos de instancia son funciones que pertenecen a instancias de una clase, estructura o enumeraci\u00f3n. Proporcionan la funcionalidad de esas instancias, bien proporcionando formas de acceder y modificar propiedades de las instancias, o bien proporcionando funcionalidades relacionadas con el prop\u00f3sito de la instancia. Los m\u00e9todos de instancia tienen exactamente la misma sintaxis que las funciones. Los m\u00e9todos de instancia se escriben dentro de las llaves del tipo al que pertenecen. Un m\u00e9todo de instancia tiene acceso impl\u00edcito a todos los otros m\u00e9todos de instancia y propiedades del tipo. Un m\u00e9todo de instancia puede ser invocado s\u00f3lo sobre una instancia espec\u00edfica del tipo al que pertenece. No puede ser invocado de forma aislada sin una instancia existente. A continuaci\u00f3n podemos ver un ejemplo que define una sencilla clase Contador , que puede usarse para contar el n\u00famero de veces que sucede una acci\u00f3n: class Contador { var veces = 0 func incrementa () { veces += 1 } func incrementa ( en cantidad : Int ) { veces += cantidad } func reset () { veces = 0 } } Y un ejemplo de uso: let contador = Contador () // el valor inicial del contador es 0 contador . incrementa () // el valor del contador es ahora 1 contador . incrementa ( en : 5 ) // el valor del contador es ahora 6 contador . reset () // el valor del contador es ahora 0 En el ejemplo anterior, los m\u00e9todos no devuelven ning\u00fan valor. Podemos modificar el ejemplo para que los m\u00e9todos devuelvan el valor actualizado del contador: class Contador { var veces = 0 func incrementa () -> Int { veces += 1 return veces } func incrementa ( en cantidad : Int ) -> Int { veces += cantidad return veces } func reset () -> Int { veces = 0 return veces } }","title":"4.1. M\u00e9todos de instancia"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#42-nombres-locales-y-externos-de-parametros","text":"Ya vimos que los par\u00e1metros de las funciones pueden tener un nombre interno y un nombre externo. Lo mismo sucede con los m\u00e9todos, porque los m\u00e9todos no son m\u00e1s que funciones asociadas con un tipo. Los nombres de los m\u00e9todos en Swift se refieren normalmente al primer par\u00e1metro usando una preposici\u00f3n como con , en , a o por , como hemos visto en el ejemplo anterior incrementa(en:) . El uso de la preposici\u00f3n permite que el m\u00e9todo se lea como una frase. El nombre de un par\u00e1metro se utiliza tambi\u00e9n como etiqueta del argumento (nombre externo). Al igual que en las funciones, es posible definir dos nombres del par\u00e1metro, uno externo y otro interno. Y el nombre externo puede ser un _ para indicar que no es necesario usar la etiqueta del argumento. Esta forma de invocar a los m\u00e9todos hace que el lenguaje sea m\u00e1s expresivo, sin necesidad de nombres largos de m\u00e9todos o funciones. Consideremos por ejemplo esta versi\u00f3n alternativa de la clase Contador , que define una forma m\u00e1s compleja del m\u00e9todo incrementa(en:) : class Contador { var veces = 0 func incrementa ( en cantidad : Int , numeroDeVeces : Int ) { veces += cantidad * numeroDeVeces } } El m\u00e9todo incrementa(en:numeroDeVeces:) tiene dos par\u00e1metros: cantidad y numeroDeVeces . El primer par\u00e1metro tiene un nombre externo y otro interno. En el cuerpo del m\u00e9todo se utiliza el nombre interno ( cantidad ). El segundo par\u00e1metro numeroDeVeces es tanto nombre externo como interno. Podemos llamar al m\u00e9todo de la siguiente forma: let contador = Contador () contador . incrementa ( en : 5 , numeroDeVeces : 3 ) // el valor del contador es ahora 15 Al igual que en las funciones, podemos definir expl\u00edcitamente los nombres externos de los par\u00e1metros y usar el subrayado ( _ ) para indicar que ese par\u00e1metro no tendr\u00e1 nombre externo.","title":"4.2. Nombres locales y externos de par\u00e1metros"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#43-la-propiedad-self","text":"Toda instancia de un tipo tiene una propiedad impl\u00edcita llamada self , que es exactamente equivalente a la instancia misma. Podemos usar la propiedad self para referirnos a la instancia actual dentro de sus propios m\u00e9todos de instancia. El m\u00e9todo incrementa() en el ejemplo anterior podr\u00eda haberse escrito de esta forma: class Contador { var veces = 0 func incrementa () { self . veces += 1 } } En la pr\u00e1ctica no es necesario usar self casi nunca. Swift asume que cualquier referencia a una propiedad dentro de un m\u00e9todo se refiere a la propiedad de la instancia. Es obligado usarlo es cuando el nombre de la propiedad coincide con el nombre de un par\u00e1metro. En esta situaci\u00f3n el nombre del par\u00e1metro toma precedencia y es necesario usar self para poder referirse a la propiedad de la instancia. Un ejemplo: struct Punto { var x = 0.0 , y = 0.0 func estaAlaDerecha ( de x : Double ) -> Bool { return self . x > x } } let unPunto = Punto ( x : 4.0 , y : 5.0 ) if unPunto . estaAlaDerecha ( de : 1.0 ) { print ( \"Este punto est\u00e1 a la derecha de la l\u00ednea donde x == 1.0\" ) } // Imprime \"Este punto est\u00e1 a la derecha de la l\u00ednea donde x == 1.0\"","title":"4.3. La propiedad self"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#44-operaciones-con-instancias-de-tipo-valor","text":"Las estructuras y las enumeraciones son tipos valor . Por defecto, las propiedades de un tipo valor no pueden ser modificadas desde dentro de los m\u00e9todos de instancia. Si queremos modificar una propiedad de un tipo valor la forma m\u00e1s natural de hacerlo es creando una instancia nueva, usando el estilo de programaci\u00f3n funcional: struct Punto { var x = 0.0 , y = 0.0 func incrementado ( incX : Double , incY : Double ) -> Punto { return Punto ( x : x + incX , y : y + incY ) } } let unPunto = Punto ( x : 1.0 , y : 1.0 ) var puntoMovido = unPunto . incrementado ( incX : 2.0 , incY : 3.0 ) print ( \"Hemos movido el punto a ( \\( puntoMovido . x ) , \\( puntoMovido . y ) )\" ) // Imprime \"Hemos movido el punto a (3.0, 4.0)\" Nota En la biblioteca est\u00e1ndar de Swift se utiliza el convenio de nombrar los m\u00e9todos no mutadores (que devuelven un objeto nuevo) con el verbo en participio ( array.sorted() ) y los m\u00e9todos mutadores (que modifican la propia estructura y no devuelven nada) con el verbo en imperativo ( array.sort() ).","title":"4.4. Operaciones con instancias de tipo valor"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#45-modificacion-de-tipos-valor-desde-dentro-de-la-instancia","text":"Sin embargo, hay ocasiones en las que necesitamos modificar las propiedades de nuestra estructura o enumeraci\u00f3n dentro de un m\u00e9todo particular. Necesitamos conseguir una conducta mutadora para ese m\u00e9todo. El m\u00e9todo puede mutar (esto es, cambiar) sus propiedades desde dentro del m\u00e9todo, as\u00ed como asignar una instancia completamente nueva a su propiedad impl\u00edcita self , con lo que esta nueva instancia reemplazar\u00e1 la existente cuando el m\u00e9todo termine. Podemos conseguir esta conducta colocando la palabra clave mutating antes de la palabra func del m\u00e9todo: struct Punto { var x = 0.0 , y = 0.0 mutating func incrementa ( incX : Double , incY : Double ) { x += incX y += incY } } var unPunto = Punto ( x : 1.0 , y : 1.0 ) unPunto . incrementa ( incX : 2.0 , incY : 3.0 ) print ( \"El punto est\u00e1 ahora en ( \\( unPunto . x ) , \\( unPunto . y ) )\" ) // Imprime \"El punto est\u00e1 ahora en (3.0, 4.0)\" La estructura Punto anterior define un m\u00e9todo mutador incrementa(incX:incY:) que mueve una instancia de Punto una cierta cantidad. En lugar de devolver un nuevo punto, el m\u00e9todo modifica realmente el punto en el que es llamado. La palabra clave mutating se a\u00f1ade a su definici\u00f3n para permitirle modificar sus propiedades. Hay que hacer notar que no es posible llamar a un m\u00e9todo mutador sobre una constante de un tipo estructura, porque sus propiedades no se pueden cambiar, incluso aunque sean propiedades variables: let puntoFijo = Punto ( x : 3.0 , y : 3.0 ) puntoFijo . incrementa ( incX : 2.0 , incY : 3.0 ) // esto provocar\u00e1 un error","title":"4.5. Modificaci\u00f3n de tipos valor desde dentro de la instancia"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#46-asignacion-a-self-en-un-metodo-mutador","text":"Los m\u00e9todos mutadores pueden asignar una nueva instancia completamente nueva a la propiedad self . El anterior ejemplo Punto podr\u00eda habers escrito de la siguiente forma: struct Punto { var x = 0.0 , y = 0.0 mutating func incrementa ( incX : Double , incY : Double ) { self = Punto ( x : x + incX , y : y + incY ) } } Esta versi\u00f3n del m\u00e9todo mutador incrementa(incX:incY:) crea una estructura nueva cuyos valores x e y se inicializan a los valores deseados. El resutado final de llamar a esta versi\u00f3n alternativa ser\u00e1 exactamente el mismo que llamar a la versi\u00f3n anterior (aunque con una peque\u00f1a penalizaci\u00f3n de eficiencia: este m\u00e9todo es 1,3 veces m\u00e1s lento que el anterior en la versi\u00f3n 2.2 del compilador de Swift). Los m\u00e9todos mutadores de enumeraciones pueden establecer el par\u00e1metro self impl\u00edcito para que tenga un subtipo distinto de la misma enumeraci\u00f3n: enum InterruptorTriEstado { case apagado , medio , alto mutating func siguiente () { switch self { case . apagado : self = . medio case . medio : self = . alto case . alto : self = . apagado } } } var luzHorno = InterruptorTriEstado . medio luzHorno . siguiente () // luzHorno es ahora .alto luzHorno . siguiente () // luzHorno es ahora .apagado","title":"4.6. Asignaci\u00f3n a self en un m\u00e9todo mutador"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#47-metodos-del-tipo","text":"Los m\u00e9todos de instancia, como los descritos antes, se llaman en instancias de un tipo particular. Es posible tambi\u00e9n definir m\u00e9todos que se llaman en el propio tipo. Esta clase de m\u00e9todos se denominan m\u00e9todos del tipo . Se define un m\u00e9todo del tipo escribiendo la palabra clave static antes de la palabra clave func del m\u00e9todo. Las clases tambi\u00e9n pueden usar la palabra clave class para permitir a las subclases sobreescribir la implementaci\u00f3n del m\u00e9todo. Los m\u00e9todos del tipo se invocan tambi\u00e9n con la sintaxis de punto, escribiendo el nombre del tipo. Por ejemplo: class NuevaClase { static func unMetodoDelTipo () { print ( \"Hola desde el tipo\" ) } } NuevaClase . unMetodoDelTipo () Dentro del cuerpo del m\u00e9todo, la propiedad impl\u00edcita self se refiere al propio tipo, m\u00e1s que a una instancia de ese tipo. Para clases, estructuras y enumeraciones, esto significa que puedes usar self para desambiguar entre propiedades del tipo y los par\u00e1metros del m\u00e9todo, de la misma forma que se hace en los m\u00e9todos de instancias. Cualquier nombre de m\u00e9todo o propiedad que se utilice en el cuerpo de un m\u00e9todo del tipo se referir\u00e1 a otras propiedades o m\u00e9todos de nivel del tipo. Se puede utilizar estos nombres sin necesidad de a\u00f1adir el prefijo del nombre del tipo. Por ejemplo, podemos a\u00f1adir a la clase Ventana una propiedad y m\u00e9todo de clase con la que almacenar instancias de ventanas. Inicialmente guardamos un array vac\u00edo. class Ventana { // Propiedades static var ventanas : [ Ventana ] = [] static func registrar ( ventana : Ventana ) { ventanas . append ( ventana ) } } Cada vez que creamos una ventana podemos llamar al m\u00e9todo registrar de la clase para a\u00f1adirlo a la colecci\u00f3n de ventanas de la clase: let v1 = Ventana () Ventana . registrar ( ventana : v1 ) print ( \"Se han registrado \\( Ventana . ventanas . count ) ventanas\" ) // Imprime \"Se han registrado 1 ventanas\"","title":"4.7. M\u00e9todos del tipo"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#5-inicializacion","text":"Inicializaci\u00f3n es el proceso de preparar para su uso una instancia de una clase, estructura o enumeraci\u00f3n. Este proceso incluye la asignaci\u00f3n de un valor inicial para cada propiedad almacenada y la ejecuci\u00f3n de cualquier otra operaci\u00f3n de inicializaci\u00f3n que se necesite para que la nueva instancia est\u00e9 lista para usarse. Para implementar este proceso de inicializaci\u00f3n hay que definir inicializadores , que son como m\u00e9todos especiales que pueden llamarse para crear una nueva instancia de un tipo particular. A diferencia de otros lenguajes, los inicializadores en Swift no devuelven un valor. Su papel principal es que las nuevas instancias del tipo est\u00e9n correctamente inicializadas antes de poder ser usadas por primera vez. Tambi\u00e9n es posible implementar deinicializadores , m\u00e9todos que se ejecutan cuando las instancias son eliminadas de la memoria (no vamos a explicarlos por falta de tiempo). El proceso de inicializaci\u00f3n de una instancia puede resultar un proceso complicado, sobre todo cuando se tienen relaciones de herencia y hay que especificar tambi\u00e9n c\u00f3mo realizar la inicializaci\u00f3n de la subclase utilizando la superclase. Por falta de tiempo no vamos a explicar todo el proceso completo. Recomendamos consultar la documentaci\u00f3n original de Swift .","title":"5. Inicializaci\u00f3n"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#51-inicializadores-por-defecto-y-memberwise","text":"Ya hemos visto que es posible inicializar clases y estructuras definiendo valores por defecto a todas sus propiedades (con la posible excepci\u00f3n de las que tienen un tipo opcional). En ese caso, podemos no definir ning\u00fan inicializador y usar el inicializador por defecto que proporciona Swift. struct Punto2D { var x = 0.0 var y = 0.0 } class Segmento { var p1 = Punto2D () var p2 = Punto2D () } var s = Segmento () Tambi\u00e9n es posible en las estructuras utilizar el inicializador memberwise , en el que especificamos todos los valores de las propiedades: var p = Punto2D ( x : 10.0 , y : 10.0 ) Los inicializadores por defecto y memberwise desaparecen en el momento en que definimos alg\u00fan inicializador con la palabra init . Veamos c\u00f3mo definir inicializadores.","title":"5.1. Inicializadores por defecto y memberwise"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#52-inicializacion-de-propiedades-almacenadas","text":"Como hemos dicho, las clases y estructuras deben definir todas sus propiedades almacenadas a un valor inicial en el momento en que la instancia se crea, a no ser que \u00e9stas sean opcionales, en cuyo caso quedar\u00edan inicializadas a nil . Podemos definir el valor inicial para una propiedad en un inicializador o asign\u00e1ndole un valor por defecto como parte de la definici\u00f3n de la propiedad. Un inicializador , en su forma m\u00e1s simple se escribe con la palabra clave init : init () { // realizar alguna inicializaci\u00f3n aqu\u00ed } Por ejemplo, podemos definir la estructura Farenheit que almacena una temperatura en grados Farenheit. Tiene una propiedad almacenada de tipo Double . Definimos un inicializador que inicializa las instancias a 32.0 (equivalente a 0.0 grados Celsius). struct Fahrenheit { var temperatura : Double init () { temperatura = 32.0 } } var f = Fahrenheit () print ( \"La temperatura por defecto es \\( f . temperatura ) Fahrenheit\" ) // Imprime \"La temperatura por defecto es 32.0\u00b0 Fahrenheit\" La implementaci\u00f3n anterior es equivalente a la que ya hemos visto con el inicializador por defecto: struct Fahrenheit { var temperatura = 32.0 }","title":"5.2. Inicializaci\u00f3n de propiedades almacenadas"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#53-inicializadores-personalizados","text":"Podemos proporcionar par\u00e1metros de inicializaci\u00f3n como parte de la definici\u00f3n de un inicializador, para definir los tipos y los nombres de los valores que personalizan el proceso de inicializaci\u00f3n. Los par\u00e1metros de inicializaci\u00f3n tienen las mismas capacidades y sintaxis que los par\u00e1metros de funciones y m\u00e9todos. struct Celsius { var temperaturaEnCelsius : Double init ( desdeFahrenheit fahrenheit : Double ) { temperaturaEnCelsius = ( fahrenheit - 32.0 ) / 1.8 } init ( desdeKelvin kelvin : Double ) { temperaturaEnCelsius = kelvin - 273.15 } } let puntoDeEbullicionDelAgua = Celsius ( desdeFahrenheit : 212.0 ) // puntoDeEbullicionDelAgua.temperaturaEnCelsius es 100.0 let puntoDeCongelacionDelAgua = Celsius ( desdeKelvin : 273.15 ) // puntoDeCongelacionDelAgua.temperaturaEnCelsius is 0.0 Vemos que dependiendo del nombre de par\u00e1metro proporcionado se escoge un inicializador u otro. En los inicializadores es obligatorio proporcionar los nombres de todos los par\u00e1metros: struct Color { let rojo , verde , azul : Double init ( rojo : Double , verde : Double , azul : Double ) { self . rojo = rojo self . verde = verde self . azul = azul } init ( blanco : Double ) { rojo = blanco verde = blanco azul = blanco } } let magenta = Color ( rojo : 1.0 , verde : 0.0 , azul : 1.0 ) let medioGris = Color ( blanco : 0.5 ) Podemos evitar proporcionar nombres externos usando un subrayado. Por ejemplo, podemos a\u00f1adir al struct anterior Celsius un inicializador sin nombre externo para el caso en que pasemos la temperatura inicial precisamente en Celsius: struct Celsius { var temperaturaEnCelsius : Double init ( desdeFahrenheit fahrenheit : Double ) { temperaturaEnCelsius = ( fahrenheit - 32.0 ) / 1.8 } init ( desdeKelvin kelvin : Double ) { temperaturaEnCelsius = kelvin - 273.15 } init ( _ celsius : Double ) { temperaturaEnCelsius = celsius } } let temperaturaCuerpo = Celsius ( 37.0 ) // temperaturaCuerpo.temperaturaEnCelsius es 37.0 Por \u00faltimo, es posible inicializar propiedades constantes definidas con let . S\u00f3lo toman valor en el momento de la inicializaci\u00f3n y despu\u00e9s no pueden modificarse. class PreguntaEncuesta { let texto : String var respuesta : String ? init ( texto : String ) { self . texto = texto } func pregunta () { print ( texto ) } } let preguntaQueso = PreguntaEncuesta ( texto : \"\u00bfTe gusta el queso?\" ) preguntaQueso . pregunta () // -> \"\u00bfTe gusta el queso? preguntaQueso . respuesta // -> nil La propiedad respuesta se inicializa a nil al ser un opcional y no inicializarla en el inicializador. Por \u00faltimo, es posible definir m\u00e1s de un inicializador, as\u00ed como invocar a inicializadores m\u00e1s b\u00e1sicos desde otros. struct Rectangulo { var origen = Punto () var tama\u00f1o = Tama\u00f1o () init (){} init ( origen : Punto , tama\u00f1o : Tama\u00f1o ) { self . origen = origen self . tama\u00f1o = tama\u00f1o } init ( centro : Punto , tama\u00f1o : Tama\u00f1o ) { let origenX = centro . x - ( tama\u00f1o . ancho / 2 ) let origenY = centro . y - ( tama\u00f1o . ancho / 2 ) self . init ( origen : Punto ( x : origenX , y : origenY ), tama\u00f1o : tama\u00f1o ) } } let basicRectangulo = Rectangulo () // el origen de basicRectangulo es (0.0, 0.0) y su tama\u00f1o (0.0, 0.0) let origenRectangulo = Rectangulo ( origen : Punto ( x : 2.0 , y : 2.0 ), tama\u00f1o : Tama\u00f1o ( ancho : 5.0 , alto : 5.0 )) // el origne de origenRectangulo es (2.0, 2.0) y su tama\u00f1o (5.0, 5.0) let centroRectangulo = Rectangulo ( centro : Punto ( x : 4.0 , y : 4.0 ), tama\u00f1o : Tama\u00f1o ( ancho : 3.0 , alto : 3.0 )) // el origen de centroRectangulo es (2.5, 2.5) y su tama\u00f1o (3.0, 3.0) El inicializador init(){} permite inicializar el Rectangulo a los valores por defecto definidos en las propiedades. Proporciona la misma funcionalidad que el inicializador por defecto, que tal y como hemos comentado, no se crea en una estructura o clase en la que definimos sus propios inicializadores.","title":"5.3. Inicializadores personalizados"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#6-herencia","text":"Una clase puede heredar m\u00e9todos, propiedades y otras caracter\u00edsticas de otra clase. Cuando una clase hereda de otra, la clase que hereda se denomina subclase , y la clase de la que se hereda se denomina su superclase . La herencia es una conducta fundamental que diferencia las clases de otros tipos en Swift. Las clases en Swift pueden llamar y acceder a m\u00e9todos y propiedades que pertenecen a su superclase y pueden proporcionar sus propias versiones que sobreescriben esos m\u00e9todos y propiedades. Para sobreescribir un m\u00e9todo o una propiedad es necesario cumplir con la definici\u00f3n proporcionada por la superclase. Las clases tambi\u00e9n pueden a\u00f1adir observadores a las propiedades heredadas para ser notificadas cuando cambia el valor de una propiedad. A cualquier propiedad heredada se le puede a\u00f1adir un observador de propiedad, independientemente de si es originalmente una propiedad almacenada o calculada.","title":"6. Herencia"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#61-definicion-de-una-clase-base","text":"Una clase que no hereda de ninguna otra se denomina una clase base ( base class ). A diferencia de otros lenguajes orientados a objetos, las clases en Swift no heredan de una clase base universal. Tambi\u00e9n a diferencia de otros lenguajes orientados a objetos Swift no permite definir clases abstractas que no permiten crear instancias. Cualquier clase en Swift puede ser instanciada. El siguiente ejemplo define una clase base llamada Vehiculo . Esta clase base define una propiedad almacenada llamada velocidadActual con un valor por defecto de 0.0. Esta propiedad se utiliza por una propiedad String calculada llamada descripcion que crea una descripci\u00f3n del veh\u00edculo. La clase base Vehiculo tambi\u00e9n define un m\u00e9todo llamdo hazRuido . Este m\u00e9todo no hace nada realmente para una instancia de un veh\u00edculo base, pero ser\u00e1 modificado m\u00e1s adelante por las subclases de Vehiculo . class Vehiculo { var velocidadActual = 0.0 var descripcion : String { return \"viajando a \\( velocidadActual ) kil\u00f3metros por hora\" } func hazRuido () -> String { // Devuelve una cadena vac\u00eda - un veh\u00edculo arbitrario no hace // ruido necesariamente return \"\" } } Creamos una instancia nueva de Vehiculo con la sintaxis de inicializaci\u00f3n que hemos visto, en la que se escribe el nombre del tipo de la clase seguido por par\u00e9ntesis vac\u00edos: let unVehiculo = Vehiculo () Habiendo creado una instancia nueva de Vehiculo , podemos acceder a su descripci\u00f3n: print ( \"Veh\u00edculo: \\( unVehiculo . descripcion ) \" ) // Veh\u00edculo: viajando a 0.0 kil\u00f3metros por hora La clase Vehiculo define caracter\u00edsticas comunes para un veh\u00edculo arbitrario, pero no es de mucha utilidad por si misma. Para hacerla m\u00e1s \u00fatil, tenemos que refinarla para describir tipos de veh\u00edculos m\u00e1s espec\u00edficos.","title":"6.1. Definici\u00f3n de una clase base"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#62-construccion-de-subclases","text":"La construcci\u00f3n de una subclase ( subclassing ) es la acci\u00f3n de basar una nueva clase en una clase existente. La subclase hereda caracter\u00edsticas de la clase existente, que despu\u00e9s podemos refinar. Tambi\u00e9n podemos a\u00f1adir nuevas caracter\u00edsticas a la subclase. Para indicar que una subclase tiene una superclase hay que escribir el nombre de la subclase antes de el de la superclase, separadas por dos puntos ( : ): class UnaSubclase : UnaSuperClase { // definici\u00f3n de la subclase } En el ejemplo anterior del Vehiculo podemos definir una subclase Bicicleta : class Bicicleta : Vehiculo { var tieneCesta = false } La nueva clase Bicicleta obtiene autom\u00e1ticamente todas las caracter\u00edsticas del Vehiculo , como sus propiedades velocidadActual y descripcion y su m\u00e9todo haceRuido() . Adem\u00e1s de las caracter\u00edsticas que hereda, la clase Bicicleta define una nueva propiedad almacenada, tieneCesta , con un valor por defecto de false . Por defecto, cualquier instancia nueva de Bicicleta no tendr\u00e1 una cesta. Puedes establecer la propiedad tieneCesta a true para una instancia particular de Bicicleta despu\u00e9s de crearla: let bicicleta = Bicicleta () bicicleta . tieneCesta = true Podemos tambi\u00e9n modificar la propiedad heredada velocidadActual y preguntar por la propiedad descripcion : bicicleta . velocidadActual = 10.0 print ( \"Bicicleta: \\( bicicleta . descripcion ) \" ) // Bicicleta: viajando a 10.0 kil\u00f3metros por hora Podemos construir subclases a partir de otras subclases. El siguiente ejemplo crea una subclase de Bicicleta que representa una bicicleta de dos sillines (un \"tandem\"): class Tandem : Bicicleta { var numeroActualDePasajeros = 0 } Tandem hereda todas las propiedades y m\u00e9todos de Bicicleta , que a su vez hereda todas sus propiedades y m\u00e9todos de Vehiculo . La subclase Tandem tambi\u00e9n a\u00f1ade una nueva propiedad almacenada llamada numeroActualDePasajeros , con un valor por defecto de 0. Si creamos una instancia de Tandem podremos trabajar con cualquiera de sus propiedades nuevas y heredadas, y preguntar a la descripci\u00f3n de solo lectura que hereda de Vehiculo : let tandem = Tandem () tandem . tieneCesta = true tandem . numeroActualDePasajeros = 2 tandem . velocidadActual = 18.0 print ( \"Tandem: \\( tandem . descripcion ) \" ) // Tandem: viajando a 18.0 kil\u00f3metros por hora","title":"6.2. Construcci\u00f3n de subclases"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#63-sobreescritura","text":"Una subclase puede proporcionar su propia implementaci\u00f3n de un m\u00e9todo de la instancia, m\u00e9todo del tipo, propiedad de la instancia o propiedad del tipo que hereda de su superclase. Esto se conoce como sobreescritura ( overriding ). Para sobreescribir una caracter\u00edstica que ser\u00eda de otra forma heredada debemos usar el prefijo override . De esta forma se clarifica que intentamos proporcionar una sobreescritura y que no lo hacemos por error. Esta palabra clave tambi\u00e9n hace que el compilador comprueba que la superclase (o una de sus clases padre) tiene una declaraci\u00f3n que empareja con la que proporcionamos en la sobreescritura. Cuando proporcionamos una sobreescritura puede ser \u00fatil acceder a los valores proporcionados por la clase padre. Para acceder a ellos podemos usar el prefijo super . El siguiente ejemplo define una nueva subclase de Vehiculo llamada Tren , que sobreescribe el m\u00e9todo hazRuido() : class Tren : Vehiculo { override func hazRuido () -> String { return \"Chuu Chuu\" } } Si creamos una nueva instancia de Tren y llamamos al m\u00e9todo hazRuido podemos comprobar que se llama a la versi\u00f3n del m\u00e9todo de la subclase: let tren = Tren () print ( tren . hazRuido ()) // Imprime \"Chuu Chuu\" Podemos sobreescribir cualquier propiedad heredada del tipo o de la instancia y proporcionar nuestros propios getters y setters para esa propiedad, o a\u00f1adir observadores de propiedades para observar cuando cambian los valores subyacentes de la propiedad. Podemos proporcionar un getter (o setter , si es apropiado) para sobreescribir cualquier propiedad heredada, independientemente de si la propiedad heredada se implementa como una propiedad almacenada o calculada. La naturaleza almacenada o calculada no se conoce por la subclase, que solo conoce su nombre y su tipo. Es posible convertir una propiedad heredada de solo-lectura en una de lectura-escritura. No es posible presentar una propiedad heredada de lectura-escritura como de solo-lectura. El siguiente ejemplo define una nueva clase llamada Coche , que es una subclase de Vehiculo . La clase Coche introduce una nueva propiedad almacenada llamada marcha , con un valor por defecto de 1. Tambi\u00e9n sobreescribe la propiedad heredada descripcion , incluyendo la marcha actual en la descripci\u00f3n: class Coche : Vehiculo { var marcha = 1 override var descripcion : String { return super . descripcion + \" con la marcha \\( marcha ) \" } } Podemos ver el funcionamiento en el siguiente ejemplo: let coche = Coche () coche . velocidadActual = 50.0 coche . marcha = 3 print ( \"Coche: \\( coche . descripcion ) \" ) // Coche: viajando a 50.0 kil\u00f3metros por hora con la marcha 3 Por \u00faltimo, podemos a\u00f1adir observadores a propiedades heredadas. Esto nos permite ser notificados cuando el valor de una propiedad heredada cambia, independientemente de si esa propiedad se ha implementado en la subclase o en la superclase. El siguiente ejemplo define una nueva clase llamada CocheAutomatico que es una subclase de Coche . La clase CocheAutomatico representa un coche con una caja de cambios autom\u00e1tica, que selecciona autom\u00e1ticamente la marcha bas\u00e1ndose en la velocidad actual: class CocheAutomatico : Coche { override var velocidadActual : Double { didSet { marcha = min ( Int ( velocidadActual / 25.0 ) + 1 , 5 ) } } } En cualquier momento que se modifica la propiedad velocidadActual de una instancia de CocheAutomatico , el observador didSet establece la propiedad marcha a un valor apropiado para la nueva velocidad. Un ejemplo de ejecuci\u00f3n: let automatico = CocheAutomatico () automatico . velocidadActual = 100.0 print ( \"CocheAutomatico: \\( automatico . descripcion ) \" ) // CocheAutomatico: viajando a 100.0 kil\u00f3metros por hora con la marcha 5","title":"6.3. Sobreescritura"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#66-modificador-final","text":"Por \u00faltimo, es posible prevenir un m\u00e9todo o propiedad de ser sobreescrito declar\u00e1ndolo como final . Para ello, hay que escribir el modificador final antes del nombre de la palabra clave que introduce el m\u00e9todo o la propiedad (como final var , final func ). Tambi\u00e9n es posible marcar la clase completa como final, escribiendo el modificador antes de class ( final class ).","title":"6.6. Modificador final"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#7-protocolos","text":"Un protocolo ( protocol ) define un esquema de m\u00e9todos, propiedades y otros requisitos que encajan en una tarea particular o un trozo de funcionalidad. El protocolo puede luego ser adoptado ( adopted ) por una clase, estructura o enumeraci\u00f3n para proporcionar una implementaci\u00f3n real de esos requisitos. Cualquier tipo que satisface los requerimientos de un protocolo se dice que se ajusta o cumple ( conform ) ese protocolo. Podemos considerar los protocolos como una construcci\u00f3n de Swift que ampl\u00eda la idea de las interfaces de Java. Adem\u00e1s de especificar los requisitos de los tipos que cumplen el protocolo, tambi\u00e9n se puede extender un protocolo (lo veremos m\u00e1s adelante, cuando hablemos de extensiones ) para proporcionar una implementaci\u00f3n de algunos de los m\u00e9todos requeridos por el protocolo. La utilizaci\u00f3n de protocolos permite un estilo de programaci\u00f3n muy flexible que puede ser usado para definir bibliotecas que se adaptan f\u00e1cilmente a nuevos requisitos. En la charla de la conferencia de desarrolladores de Apple de 2015 (WWDC15) Protocol Oriented Programming Dave Abrahams, uno de los responsables del dise\u00f1o de la biblioteca est\u00e1ndar de Swift, propone la utilizaci\u00f3n de protocolos en un nuevo estilo de programaci\u00f3n que contrapone al estilo tradicional de la programaci\u00f3n orientada a objetos que usa herencia y clases abstractas.","title":"7. Protocolos"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#71-sintaxis","text":"Los protocolos se definen de forma similar a las clases, estructuras y enumeraciones: protocol UnProtocolo { // definici\u00f3n del protocolo } Para definir un tipo que se ajusta a un protocolo particular se debe poner el nombre del protocolo tras el nombre del tipo, separado por dos puntos. Podemos listar m\u00e1s de un protocolo, y se separan por comas: struct UnStruct : PrimerProtocolo , OtroProtocolo { // definici\u00f3n del struct } Si una clase tiene una superclase, se escribe el nombre de la superclase antes de los protocolos, seguido por una coma: class UnaClase : UnaSuperClase , PrimerProtocolo , OtroProto { // definici\u00f3n de la clase }","title":"7.1. Sintaxis"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#72-requisitos-de-propiedades","text":"Un protocolo puede requerir a cualquier tipo que se ajuste a \u00e9l que proporcione una propiedad de instancia o de tipo con un nombre y tipo particular. El protocolo no especifica si la propiedad es una propiedad calculada o almacenada, s\u00f3lo especifica el nombre y el tipo de la propiedad requerida. El protocolo tambi\u00e9n especifica si la propiedad debe ser de lectura y escritura o s\u00f3lo de lectura. Si un protocolo requiere que una propiedad sea de lectura y escritura, el requisito no puede ser satisfecho por una propiedad constante almacenada o por una propiedad calculada de s\u00f3lo lectura. Si el protocolo s\u00f3lo requiere que la propiedad sea de lectura, el requisito puede ser satisfecho por cualquier tipo de propiedad, y es v\u00e1lido que la propiedad sea tambi\u00e9n de escritura si es \u00fatil para nuestro propio c\u00f3digo. Los requisitos de la propiedad se declaran siempre como propiedades variables, precedido por la palabra clave var . Las propiedades de lectura y escritura se indican escribiendo { get set } despu\u00e9s de la declaraci\u00f3n de su tipo, y las propiedades de s\u00f3lo lectura se indican escribiendo { get } . protocol UnProtocolo { var debeSerEscribible : Int { get set } var noTienePorQueSerEscribible : Int { get } } Para definir una propiedad de tipo hay que precederla en el protocolo con la palabra clave static : protocol OtroProtocolo { static var unaPropiedadDeTipo : Int { get set } } Veamos un ejemplo. Definimos el protocolo TieneNombre en el que se requiere que cualquier clase que se ajuste a \u00e9l debe tener una propiedad de instancia de lectura de tipo String que se llame nombreCompleto : protocol TieneNombre { var nombreCompleto : String { get } } Un ejemplo de una sencilla estructura que adopta el protocolo: struct Persona : TieneNombre { var edad : Int var nombreCompleto : String } let john = Persona ( edad : 35 , nombreCompleto : \"John Appleseed\" ) // john.nombreCompleto es \"John Appleseed\" Este ejemplo define una estructure llamada Persona , que representa una persona con una edad y un nombre espec\u00edfico. En la primera l\u00ednea se declara que se adopta el protocolo TieneNombre . Cada instancia de Persona tiene la propiedad almacenada llamada nombreCompleto , que es de tipo String . Esto cumple el \u00fanico requisito del protocolo TieneNombre , y signifca que Persona se ajusta correctamente al protocolo (Swift informa de un error en tiempo de compilaci\u00f3n si un requisito de un protocolo no se cumple). Otro ejemplo de una clase m\u00e1s compleja, que tambi\u00e9n adopta el protocolo: class NaveEstelar : TieneNombre { var prefijo : String ? var nombre : String init ( nombre : String , prefijo : String ? = nil ) { self . nombre = nombre self . prefijo = prefijo } var nombreCompleto : String { return ( prefijo != nil ? prefijo ! + \" \" : \"\" ) + nombre } } var ncc1701 = NaveEstelar ( nombre : \"Enterprise\" , prefijo : \"USS\" ) // ncc1701.nombreCompleto es \"USS Enterprise\" Esta clase implementa el requisito de la propiedad nombreCompleto como una propiedad calculada de solo lectura para una nave estelar. Cada instancia de NavaEstelar almacena un nombre obligatorio y un prefijo opcional. La propiedad nombreCompleto usa el valor del prefijo si existe, y la a\u00f1ade al comienzo del nombre para crear un nombre completo de la nave estelar.","title":"7.2. Requisitos de propiedades"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#73-requisitos-de-metodos","text":"Los protocolos pueden requerir que los tipos que se ajusten a ellos implementen m\u00e9todos de instancia y de tipos espec\u00edficos. Estos m\u00e9todos se escriben como parte de la definici\u00f3n del protocolo de la misma forma que los m\u00e9todos normales, pero sin sus cuerpos: protocol UnProtocolo { func unMetodo () -> Int } Los m\u00e9todos del tipo en el protocolo deben indicarse con la palabra clave static : protocol UnProtocolo { static func unMetodoDelTipo () } Un ejemplo: protocol GeneradorNumerosAleatorios { func random () -> Double } Este protocolo, GeneradorNumerosAleatorios , requiere que cualquier tipo que se ajuste a \u00e9l tenga un m\u00e9todo de instancia llamado random , que devuelve un valor Double cada vez que se llama. Aunque no est\u00e1 especificado en el protocolo, se asume que este valor ser\u00e1 un n\u00famero entre 0.0 y 1.0 (sin incluirlo). El protocolo GeneradorNumerosAleatorios no hace ninguna suposici\u00f3n sobre c\u00f3mo ser\u00e1 generado cada n\u00famero aleatorio, simplemente requiere al generador que proporcione una forma est\u00e1ndar de generarlo. Una implementaci\u00f3n de una clase que adopta el protocolo: class GeneradorLinealCongruente : GeneradorNumerosAleatorios { var ultimoRandom = 42.0 let m = 139968.0 let a = 3877.0 let c = 29573.0 func random () -> Double { let number = ultimoRandom * a + c ultimoRandom = number . truncatingRemainder ( dividingBy : m ) return ultimoRandom / m } } let generador = GeneradorLinealCongruente () print ( \"Un n\u00famero aleatorio: \\( generador . random ()) \" ) // Imprime \"Un n\u00famero aleatorio: 0.37464991998171\" print ( \"Y otro: \\( generador . random ()) \" ) // Imprime \"Y otro: 0.729023776863283\"","title":"7.3. Requisitos de m\u00e9todos"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#74-requisito-de-metodo-mutating","text":"Si definimos un protocolo con un requisito de m\u00e9todo de instancia que pretenda mutar las instancias del tipo que adopte el protocolo, se debe marcar el m\u00e9todo con la palabra mutating . Esto permite a las estructuras y enumeraciones que adopten el protocolo definir ese m\u00e9todo como mutating . No es necesario hacerlo con las clases, porque la palabra mutating solo es necesaria en estructuras y enumeraciones. Un ejemplo: protocol Conmutable { mutating func conmutar () } enum Interruptor : Conmutable { case apagado , encendido mutating func conmutar () { switch self { case . apagado : self = . encendido case . encendido : self = . apagado } } } var interruptorLampara = Interruptor . apagado interruptorLampara . conmutar () // interruptorLampara es ahora igual a .encendido","title":"7.4. Requisito de m\u00e9todo mutating"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#75-protocolos-como-tipos","text":"Los protocolos no implementan realmente ninguna funcionalidad por ellos mismos. Sin embargo, cualquier protocolo que definamos se convierte autom\u00e1ticamente en un tipo con todas sus propiedades que podemos usar en nuestro c\u00f3digo. Podemos entonces usar el protocolo en cualquier sitio donde permitamos otros tipos, incluyendo: El tipo de un par\u00e1metro de una funci\u00f3n, m\u00e9todo o inicializador o de sus valores devueltos. El tipo de una constante, variable o propiedad El tipo de los \u00edtems de un array, diccionario u otro contenedor class Dado { let caras : Int let generador : GeneradorNumerosAleatorios init ( caras : Int , generador : GeneradorNumerosAleatorios ) { self . caras = caras self . generador = generador } func tirar () -> Int { return Int ( generador . random () * Double ( caras )) + 1 } } Este ejemplo define una nueva clase llamada Dado , que representa un dado de n caras que se puede usar en un juego de tablero. Las instancias de dados tienen una propiedad llamada caras , que representa cu\u00e1ntas caras tienen, y una propiedad llamada generador , que proporciona un generador a partir del cual crear valores de tiradas. La propiedad generador es del tipo GeneradorNumerosAleatorios . Podemos asignarle una instancia de cualquier tipo que adopte el protocolo GeneradorNumerosAleatorios . Dado tiene tambi\u00e9n un inicializador, para configurar sus estado inicial. El inicializador tiene un par\u00e1metro llamado generador , que tambi\u00e9n es del tipo GeneradorNumerosAleatorios . Podemos pasarle un valor de cualquier instancia que se ajuste a este tipo. Y tambi\u00e9n proporciona un m\u00e9todo de instancia llamado tirar , que devuelve un valor entero entre 1 y el n\u00famero de caras del dado. Este m\u00e9todo llama al m\u00e9todo random() del generador para crear un nuevo n\u00famero aleatorio entre 0.0 y 1.0 y usa este n\u00famero aleatorio para crear un valor de tirada que est\u00e9 dentro del rango correcto. Debido a que sabemos que el generador se ajusta al protocolo GeneradorNumerosAleatorios tenemos la garant\u00eda de que va a existir un m\u00e9todo random() al que llamar. Un ejemplo de uso del c\u00f3digo: var d6 = Dado ( caras : 6 , generador : GeneradorLinealCongruente ()) for _ in 1. .. 5 { print ( \"La tirada del dado es \\( d6 . tirar ()) \" ) } // La tirada del dado es 3 // La tirada del dado es 5 // La tirada del dado es 4 // La tirada del dado es 5 // La tirada del dado es 4","title":"7.5. Protocolos como tipos"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#76-colecciones-de-tipos-protocolo","text":"Como hemos comentado anteriormente, un protocolo puede usarse como el tipo que se almacena un una colecci\u00f3n (array, diccionario, etc.). Veamos un ejemplo: var peterParker = Persona ( edad : 24 , nombreCompleto : \"Peter Parker\" ) var ncc1701 = NaveEstelar ( nombre : \"Enterprise\" , prefijo : \"USS\" ) let cosasConNombre : [ TieneNombre ] = [ peterParker , ncc1701 ] for cosa in cosasConNombre { print ( cosa . nombreCompleto ) } // Peter Parker // USS Enterprise Hay que hacer notar que la constante cosa que itera sobre los elementos del array es de tipo TieneNombre ], no es de tipo Persona ni de tipo NaveEstelar , incluso aunque las instancias que hay tras de escena son do esos tipos. Por ser del tipo TieneNombre sabemos que tiene una propiedad nombreCompleto que podemos usar sobre la variable iteradora.","title":"7.6. Colecciones de tipos protocolo"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#77-protocolo-equatable","text":"En la biblioteca est\u00e1ndar de Swift se definen distintos protocolos como Collection y Equatable que describen abstracciones comunes. Muchos de estos protocolos incorporan implementaciones por defecto de algunos de sus m\u00e9todos mediante extensiones definidas en la propia biblioteca est\u00e1ndar. Veamos por ejemplo el protocolo Equatable . Se trata de un protocolo importante que define las operaciones de igualdad ( == ) y diferencia ( != ). Debemos implementar la operaci\u00f3n de igualdad en cualquier clase que se ajuste al protocolo, pero la operaci\u00f3n de diferencia ya tiene una implementaci\u00f3n por defecto. Un ejemplo: class Punto3D : Equatable { let x , y , z : Double init ( x : Double , y : Double , z : Double ) { self . x = x self . y = y self . z = z } static func == ( izquierda : Punto3D , derecha : Punto3D ) -> Bool { return izquierda . x == derecha . x && izquierda . y == derecha . y && izquierda . z == derecha . z } } let p1 = Punto3D ( x : 0.0 , y : 0.0 , z : 0.0 ) let p2 = Punto3D ( x : 0.0 , y : 0.0 , z : 0.0 ) print ( p1 == p2 ) // Imprime true print ( p1 != p2 ) // Imprime false El operador == se define en la propia clase. Se utiliza la palabra static para indicar que se trata de un operador que estamos sobrecargando (hablaremos m\u00e1s adelante de los operadores). El operador != que se usa en la \u00faltima instrucci\u00f3n se define en una implementaci\u00f3n por defecto. En Swift 5 el compilador define una implementaci\u00f3n autom\u00e1tica del operador == en las estructuras y enumeraciones al a\u00f1adir el protocolo Equatable , siempre que las propiedades almacenadas y los valores asociados cumplan ese protocolo. Por ejemplo, si en lugar de una clase definimos un struct Punto3D el c\u00f3digo quedar\u00eda como sigue (no es necesario definir ni el inicializador por defecto ni el operador == ): struct Punto3D : Equatable { let x , y , z : Double } let p1 = Punto3D ( x : 0.0 , y : 0.0 , z : 0.0 ) let p2 = Punto3D ( x : 0.0 , y : 0.0 , z : 0.0 ) print ( p1 == p2 ) // Imprime true print ( p1 != p2 ) // Imprime false","title":"7.7. Protocolo Equatable"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#8-casting-de-tipos","text":"El casting de tipos es una forma de comprobar el tipo de una instancia o de tratar esa instancia como de una superclase distinta o conseguir una subclase de alg\u00fan otro sitio en la propia jerarqu\u00eda de clase. La forma de implementarlo es utilizando los operadores is y as . Estos operadores proporcionan una forma simple y expresiva de comprobar el tipo de un valor o transformar un valor en uno de otro tipo. Tambi\u00e9n se puede usar el casting de tipos para comprobar si un tipo se ajusta a un protocolo.","title":"8. Casting de tipos"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#81-una-jerarquia-de-clases-para-el-casting-de-tipos","text":"Vamos a comenzar construyendo una jerarqu\u00eda de clases y subclases con las que trabajar. Utilizaremos el casting de tipos para comprobar el tipo de una instancia particular de una clase y para convertir esa instancia en otra clase dentro de la misma jerarqu\u00eda. En el primer fragmento de c\u00f3digo definimos una clase nueva llamada MediaItem . Esta clase proporciona la funcionalidad b\u00e1sica de cualquier tipo de \u00edtem que aparece en una biblioteca de medios digitales. Espec\u00edficamente, declara una propiedad nombre de tipo String y un inicializador init nombre (suponemos que todos los \u00edtems, incluyendo pel\u00edculas y canciones, tendr\u00e1n un nombre). class MediaItem { var nombre : String init ( nombre : String ) { self . nombre = nombre } } El siguiente fragmento define dos subclases de MediaItem . La primera subclase, Pelicula , encapsula informaci\u00f3n adicional sobre una pel\u00edcula. A\u00f1ade una propiedad director a la clase base MediaItem , con su correspondiente inicializador. La segunda subclase, Cancion , a\u00f1ade una propiedad artista y un inicializador a la clase base: class Pelicula : MediaItem { var director : String init ( nombre : String , director : String ) { self . director = director super . init ( nombre : nombre ) } } class Cancion : MediaItem { var artista : String init ( nombre : String , artista : String ) { self . artista = artista super . init ( nombre : nombre ) } } Por \u00faltimo, creamos un array constante llamado biblioteca , que contienen dos instancias de Pelicula y tres instancias de Cancion . let biblioteca : [ MediaItem ] = [ Pelicula ( nombre : \"El Se\u00f1or de los Anillos\" , director : \"Peter Jackson\" ), Cancion ( nombre : \"Child in Time\" , artista : \"Deep Purple\" ), Pelicula ( nombre : \"El Puente de los Esp\u00edas\" , director : \"Steven Spielberg\" ), Cancion ( nombre : \"I Wish You Were Here\" , artista : \"Pink Floyd\" ), Cancion ( nombre : \"Yellow\" , artista : \"Coldplay\" ) ] Podr\u00edamos tambi\u00e9n dejar que el compilador infiera el tipo del array. Es capaz de deducir que Pelicula y Cancion tienen una superclase com\u00fan MediaItem , por lo que infiere que el tipo del array es [MediaItem] : // Declaraci\u00f3n equivalente a la anterior let biblioteca = [ Pelicula ( nombre : \"El Se\u00f1or de los Anillos\" , director : \"Peter Jackson\" ), Cancion ( nombre : \"Child in Time\" , artista : \"Deep Purple\" ), Pelicula ( nombre : \"El Puente de los Esp\u00edas\" , director : \"Steven Spielberg\" ), Cancion ( nombre : \"I Wish You Were Here\" , artista : \"Pink Floyd\" ), Cancion ( nombre : \"Yellow\" , artista : \"Coldplay\" ) ] Los \u00edtems almacenados en la biblioteca son todav\u00eda instancias de Pelicula y Cancion . Sin embargo, si iteramos sobre los contenidos de este array, los \u00edtems que recibiremos tendr\u00e1n el tipo MediaItem y no Pelicula o Cancion . Para trabajar con ellos como su tipo nativo, debemos chequear su tipo, y hacer un downcast a su tipo concreto. Lo veremos m\u00e1s adelante. Sucede igual en el ejemplo visto anteriormente en el que se guardan en un array de tipo TieneNombre (un protocolo) dos instancias de estructuras distinas (una Persona y una NaveEstelar ) que cumplen el protocolo. var peterParker = Persona ( edad : 24 , nombreCompleto : \"Peter Parker\" ) var ncc1701 = NaveEstelar ( nombre : \"Enterprise\" , prefijo : \"USS\" ) let cosasConNombre : [ TieneNombre ] = [ peterParker , ncc1701 ] for cosa in cosasConNombre { print ( cosa . nombreCompleto ) } // Peter Parker // USS Enterprise Tambi\u00e9n podemos aplicar los operadores de comprobaci\u00f3n de tipo y de downcasting que veremos a continuaci\u00f3n a este caso en el que instancias concretas est\u00e1n en variables del tipo del protocolo.","title":"8.1. Una jerarqu\u00eda de clases para el casting de tipos"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#82-comprobacion-del-tipo","text":"Podemos usar el operador de comprobaci\u00f3n ( check operator ) is para comprobar si una instancia es de un cierto tipo. El operador de comprobaci\u00f3n devuelve true si la instancia es del tipo y false si no. Lo podemos comprobar en el siguiente ejemplo, en el que contamos las instancias de pel\u00edculas y canciones en el array biblioteca : var contadorPeliculas = 0 var contadorCanciones = 0 for item in biblioteca { if item is Pelicula { contadorPeliculas += 1 } else if item is Cancion { contadorCanciones += 1 } } print ( \"La biblioteca contiene \\( contadorCanciones ) pel\u00edculas y \\( contadorPeliculas ) canciones\" ) // Imprime \"La biblioteca contiene 3 pel\u00edculas y 2 canciones\" El ejemplo itera por todos los \u00edtems del array biblioteca . En cada paso, el bucle for-in guarda en la constante item el siguiente MediaItem del array. La instrucci\u00f3n item is Pelicula devuelve true si el MediaItem actual es una instancia de Pelicula y false en otro caso. De forma similar, item is Cancion comprueba si el \u00edtem es una instancia de Cancion . Al final del bucle for-in , los valores de contadorPeliculas y contadorCanciones contendr\u00e1n una cuenta de cuantas instancias MediaItem de cada tipo se han encontrado. La misma comprobaci\u00f3n se puede hacer en el array cosasConNombre para contar el n\u00famero de \u00edtems que son de tipo Persona y NaveEspacial .","title":"8.2. Comprobaci\u00f3n del tipo"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#83-downcasting","text":"Una constante o variable de un cierto tipo de clase puede referirse (contener) a una instancia de una subclase. Tambi\u00e9n, una variable declarada con el tipo de un protocolo contiene una instancia de un tipo concreto, que cumple el protocolo. Cuando sucede esto, podemos hacer un downcast al tipo de la subclase o del tipo que cumple el protocolo con un operador de cast ( as? o as! ). Como el downcast puede fallar, la versi\u00f3n condicional, as? , devuelve un valor opcional del tipo al que estamos intentando hacer el downcasting . La versi\u00f3n forzosa, as! , intenta el downcast y fuerza la desenvoltura del resultado en un \u00fanica acci\u00f3n compuesta. Debemos usar la versi\u00f3n condicional ( as? ) cuando no estamos seguros si el downcast tendr\u00e1 \u00e9xito. Se devolver\u00e1 un valor opcional y el valor ser\u00e1 nil si no es posible hacer el downcast . Esto permitir\u00e1 comprobar si ha habido un downcast con \u00e9xito. La otra versi\u00f3n ( as! ) se usa s\u00f3lo cuando estamos seguros de que el downcast tendr\u00e1 \u00e9xito. Esta versi\u00f3n del operador lanzar\u00e1 un error en tiempo de ejecuci\u00f3n si intentamos hacer un downcast a un tipo incorrecto. El siguiente ejemplo itera sobre cada MediaItem en biblioteca , e imprime una descripci\u00f3n apropiada para cada \u00edtem. Para hacerlo, necesita acceder a cada \u00edtem como una Pelicula o Cancion y no s\u00f3lo como una MediaItem . Esto es necesario para poder acceder a la propiedad director o artista de una instancia de Pelicula o Cancion . En este ejemplo, cada \u00edtem en el array podr\u00eda ser un Pelicula o podr\u00eda ser una Cancion . No sabemos por anticipado la clase verdadera de cada \u00edtem, por lo que es apropiado usar la versi\u00f3n condicional ( as? ) para comprobar el downcast cada vez a lo largo del bucle: for item in biblioteca { if let pelicula = item as ? Pelicula { print ( \"Pel\u00edcula: \\( pelicula . nombre ) , dir. \\( pelicula . director ) \" ) } else if let cancion = item as ? Cancion { print ( \"Cancion: \\( cancion . nombre ) , de \\( cancion . artista ) \" ) } } // Pel\u00edcula: El Se\u00f1or de los Anillos, dir. Peter Jackson // Cancion: Child in Time, de Deep Purple // Pel\u00edcula: El Puente de los Esp\u00edas, dir. Steven Spielberg // Cancion: I Wish You Were Here, de Pink Floyd // Cancion: Yellow, de Coldplay El ejemplo comienza intentando hacer downcast del \u00edtem a una Pelicula . Debido a que es una instancia de MediaItme , es posible que sea un Pelicula o una Cancion , o incluso el tipo base MediaItem . Debido a esta incertidumbre, debemos usar la versi\u00f3n as? para devolver un valor opcional. El resultado ser\u00e1 una \"Pelicula opcional\". Podemos desenvolver el valor Pelicula usando un if let como vimos en el apartado de opcionales. Si tiene \u00e9xito el downcasting , las propiedades de la pel\u00edcula se pueden usar para imprimir una descripci\u00f3n de la pel\u00edcula llamando a los correspondientes m\u00e9todos de la clase Pelicula . Igual con Cancion . El mismo ejemplo se puede aplicar al array cosasConNombre . Prueba a adaptar el c\u00f3digo anterior a este array, recorri\u00e9ndolo y haciendo el downcasting a los tipos Persona y NaveEspacial .","title":"8.3. Downcasting"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#84-el-tipo-any","text":"El tipo Any puede representar una instancia de cualquier tipo, incluyendo tipos funci\u00f3n: var array = [ Any ]() array . append ( 0 ) array . append ( 0.0 ) array . append ( 42 ) array . append ( 3.14159 ) array . append ( \"hola\" ) array . append (( 3.0 , 5.0 )) array . append ( Pelicula ( nombre : \"Ghostbusters\" , director : \"Ivan Reitman\" )) array . append ({ ( name : String ) -> String in \"Hola, \\( name ) \" }) El array contiene dos valores Int , dos valores Double , un valor String , una tupla del tipo (Double, Double) , la pel\u00edcula \"Ghostbusters\", y una clausura que toma un String y devuelve otro String . Puedes usar los operadores is y as en una sentencia switch para descubrir en tiempo de ejecuci\u00f3n el tipo espec\u00edfico de una constante o variable de la que s\u00f3lo se sabe que es de tipo Any : for item in array { switch item { case 0 as Int : print ( \"cero como un Int\" ) case 0 as Double : print ( \"cero como un Double\" ) case let someInt as Int : print ( \"un valor entero de \\( someInt ) \" ) case let unDouble as Double where unDouble > 0 : print ( \"a valor positivo de \\( unDouble ) \" ) case is Double : print ( \"alg\u00fan otro valor double que no quiero imprimir\" ) case let someString as String : print ( \"una cadena con valor de \\\" \\( someString ) \\\" \" ) case let ( x , y ) as ( Double , Double ): print ( \"un punto (x, y) en \\( x ) , \\( y ) \" ) case let pelicula as Pelicula : print ( \"una pel\u00edcula: \\( pelicula . nombre ) , dir. \\( pelicula . director ) \" ) case let stringConverter as ( String ) -> String : print ( stringConverter ( \"Michael\" )) default : print ( \"alguna otra cosa\" ) } } // cero como un Int // cero como un Double // un valor entero de 42 // a valor positivo de 3.14159 // una cadena con valor de \"hola\" // un punto (x, y) en 3.0, 5.0 // una pel\u00edcula: Ghostbusters, dir. Ivan Reitman // Hola, Michael","title":"8.4. El tipo Any"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#85-comprobacion-de-ajustarse-a-un-protocolo","text":"Podemos usar tambi\u00e9n los operadores anteriores is y as (y as? y as! ) para comprobar si una instancia se ajusta a un protocolo y para hacer un cast a un protocolo espec\u00edfico. Veamos un ejemplo. Definimos el protocolo TieneArea con el \u00fanico requisito de una propiedad de lectura llamada area de tipo Double : protocol TieneArea { var area : Double { get } } Definimos dos clases Circulo y Pais que se ajustan ambos al protocolo: class Circulo : TieneArea { let pi = 3.1415927 var radio : Double var area : Double { return pi * radio * radio } init ( radio : Double ) { self . radio = radio } } class Pais : TieneArea { var area : Double init ( area : Double ) { self . area = area } } La clase Circulo implementa el requisito como una propiedad calculada, basada en la propiedad almacenada radio . La clase Pais implementa el requisito directamente como una propiedad almacenada. Ambas clases se ajustan correctamente al protocolo TieneArea . Definimos una clase Animal que no se ajusta al protocolo: class Animal { var patas : Int init ( patas : Int ) { self . patas = patas } } Las clases Circulo , Pais y Animal no tienen ninguna clase base compartida. Sin embargo, todas son clases, por lo que las instancias de los tres tipos pueden usarse para inicializar un array que almacena valores de tipo Any : let objetos : [ Any ] = [ Circulo ( radio : 2.0 ), Pais ( area : 243_610 ), Animal ( patas : 4 ) ] Y ahora podemos iterar sobre el array de objetos, comprobando para cada \u00edtem si la instancia se ajusta al protocolo TieneArea : for objecto in objetos { if let objetoConArea = objecto as ? TieneArea { print ( \"El \u00e1rea es \\( objetoConArea . area ) \" ) } else { print ( \"Algo que no tiene un \u00e1rea\" ) } } // El \u00e1rea es 12.5663708 // El \u00e1rea es 243610.0 // Algo que no tiene un \u00e1rea Cuando un objeto en el array se ajusta al protocolo TieneArea , el valor opcional devuelto por el operador as? se desenvuelve con un ligado opcional en una constante llamada objetoConArea . Esta constante tiene el tipo TieneArea , por lo que su propiedad area podr\u00e1 ser accedida e impresa. Hay que notar que los objetos subyacentes no cambian en el proceso de casting . Siguen siendo un Circulo , un Pais y un Animal . Sin embargo, en el momento en se almacenan en la constante objetoConArea , s\u00f3lo se sabe que son del tipo TieneArea , por lo que s\u00f3lo podremos acceder a su propiedad area .","title":"8.5. Comprobaci\u00f3n de ajustarse a un protocolo"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#9-extensiones","text":"Las extensiones a\u00f1aden nueva funcionalidad a una clase, estructura, enumeraci\u00f3n o protocolo. Esto incluye la posibilidad de extender tipos para los que no tenemos acceso al c\u00f3digo fuente original (esto se conoce como modelado retroactivo ). Entre otras cosas, las extensiones pueden: A\u00f1adir propiedades calculadas de instancia y de tipo Definir m\u00e9todos de instancia y de tipo Proporcionar nuevos inicializadores Hacer que un tipo existente se ajuste a un protocolo","title":"9. Extensiones"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#91-sintaxis","text":"Para declarar una extensi\u00f3n hay que usar la palabra clave extension , indicando despu\u00e9s el tipo que se quiere extender (enumeraci\u00f3n, clase, estructura o protocolo) extension UnTipoExistente { // nueva funcionalidad para a\u00f1adir a UnTipo }","title":"9.1. Sintaxis"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#92-propiedades-calculadas","text":"Las extensiones pueden a\u00f1adir propiedades calculadas de instancias y de tipos. Como primer ejemplo, recordemos el tipo Persona : protocol TieneNombre { var nombreCompleto : String { get } } struct Persona : TieneNombre { var edad : Int var nombreCompleto : String } Vamos a a\u00f1adir a la estructura la propiedad calculada mayorEdad , un Bool que indica si la edad de la persona es mayor o igual de 18: extension Persona { var mayorEdad : Bool { return edad >= 18 } } Una vez definida esta extensi\u00f3n, hemos ampliado la clase con esta nueva propiedad, sin modificar el c\u00f3digo inicial con la definici\u00f3n de la clase. Podemos preguntar si una persona es mayor de edad: var p = Persona ( edad : 15 , nombreCompleto : \"Luc\u00eda\" ) p . mayorEdad // false Es posible incluso extender clases de las librer\u00edas est\u00e1ndar de Swift, como Int , Double , Array , etc. Por ejemplo, podemos a\u00f1adir propiedades calculadas a la clase Double para trabajar con unidades de distancia. Las siguientes propiedades convierten una cantidad en las unidades correspondientes a su equivalente en metros: extension Double { var km : Double { return self * 1_000.0 } var m : Double { return self } var cm : Double { return self / 100.0 } var mm : Double { return self / 1_000.0 } var ft : Double { return self / 3.28084 } } Una vez definida la extensi\u00f3n, podemos usarla en cualquier variable Double . Incluso la podemos usar en literales: let distancia = 11. km // En distancia tendremos 11000 metros let unaPulgada = 25.4 . mm print ( \"Una pulgada es \\( unaPulgada ) metros\" ) // Una pulgada es 0.0254 metros let tresPies = 3. ft print ( \"Tres pies son \\( tresPies ) metros\" ) // Tres pies son 0.914399970739201 metros Por ejemplo, cuando se escribe 11.km se pide el valor de la propiedad calculada km de la instancia 11 . La propiedad calculada devuelve el resultado de multiplicar 11 por 1000 , esto es, los metros correspondientes a 11 kil\u00f3metros. De forma similar, hay 3.28084 pies en un metro, por lo que la propiedad calculada ft divide el valor Double subyacente por 3.28084, para conventirlo de pies a metros. Estas propiedades son propiedades calculadas de solo lectura, por lo que se expresan sin la palabra clave get , por brevedad. Sus valores devueltos son de tipo Double , y pueden usarse en c\u00e1lculos matem\u00e1ticos en cualquier sitio que se acepte un Double : let unMaraton = 42. km + 195. m print ( \"Un marat\u00f3n tiene una longitud de \\( unMaraton ) metros\" ) // Un marat\u00f3n tiene una longitud de 42195.0 metros","title":"9.2. Propiedades calculadas"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#93-inicializadores","text":"Las extensiones pueden a\u00f1adir nuevos inicializadores a tipos existentes. Esto nos permite extender otros tipos para aceptar nuestros propios tipos como par\u00e1metros de la inicializaci\u00f3n, o para proporcionar opciones adicionales que no estaban incluidos en la implementaci\u00f3n original del tipo. Recordemos la estructura Rectangulo , definida por un Punto y un Tama\u00f1o . Supongamos que la definimos sin inicializadores: struct Tama\u00f1o { var ancho = 0.0 , alto = 0.0 } struct Punto { var x = 0.0 , y = 0.0 } struct Rectangulo { var origen = Punto () var tama\u00f1o = Tama\u00f1o () } Recordemos que debido a que la estructura Rectangulo proporciona valores por defecto para todas sus propiedades, tiene un inicializador por defecto que puede utilizarse para crear nuevas instancias. Tambi\u00e9n podemos inicializarlo asignando todas sus propieades: let rectanguloPorDefecto = Rectangulo () let rectanguloInicializado = Rectangulo ( origen : Punto ( x : 2.0 , y : 2.0 ), tama\u00f1o : Tama\u00f1o ( ancho : 5.0 , alto : 5.0 )) Podemos ahora extender la estructura Rectangulo para proporcionar un inicializador adicional que toma un punto espec\u00edfico del centro y un tama\u00f1o: extension Rectangulo { init ( centro : Punto , tama\u00f1o : Tama\u00f1o ) { let origenX = centro . x - ( tama\u00f1o . ancho / 2 ) let origenY = centro . y - ( tama\u00f1o . alto / 2 ) self . init ( origen : Punto ( x : origenX , y : origenY ), tama\u00f1o : tama\u00f1o ) } } Este nuevo inicializador empieza por calcular un punto de origen basado en el centro propuesto y en el tama\u00f1o. El inicializador llama despu\u00e9s al inicializador autom\u00e1tico de la estructura init(origen:tama\u00f1o:) , que almacena los nuevos valores de las propiedades: let rectanguloCentro = Rectangulo ( centro : Punto ( x : 4.0 , y : 4.0 ), tama\u00f1o : Tama\u00f1o ( ancho : 3.0 , alto : 3.0 )) // el origen del rectanguloCentro es is (2.5, 2.5) y su tama\u00f1o es (3.0, 3.0)","title":"9.3. Inicializadores"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#94-metodos","text":"Las extensiones pueden a\u00f1adir nuevos m\u00e9todos de instancia y nuevos m\u00e9todos del tipo. Por ejemplo, podemos a\u00f1adir el m\u00e9todo descripcion() a la estructura Persona : extension Persona { func descripcion () -> String { return \"Me llamo \\( nombreCompleto ) y tengo \\( edad ) a\u00f1os\" } } let reedRichards = Persona ( edad : 40 , nombreCompleto : \"Reed Richards\" ) print ( reedRichards . descripcion ()) Tambi\u00e9n podemos a\u00f1adir m\u00e9todos a clases y estructuras importadas. Por ejemplo podemos a\u00f1adir un nuevo m\u00e9todo de instancia llamado repeticiones al tipo Int : extension Int { func repeticiones ( _ tarea : () -> Void ) { for _ in 0. .< self { tarea () } } } El m\u00e9todo repeticiones(_:) toma un \u00fanico argumento de tipo () -> Void , que indica una funci\u00f3n que no tiene par\u00e1metros y no devuelve ning\u00fan valor. Despu\u00e9s de definir esta extensi\u00f3n, podemos llamar al m\u00e9todo repeticiones(_:) en cualquier n\u00famero entero para ejecutar una tarea un cierto n\u00famero de veces: 3. repeticiones ({ print ( \"Hola!\" ) }) // Hola! // Hola! // Hola! Usando clausuras por la cola podemos hacer la llamada m\u00e1s concisa: 3. repeticiones { print ( \"Adios!\" ) } // Adios! // Adios! // Adios!","title":"9.4. M\u00e9todos"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#95-metodos-de-instancia-mutadores","text":"Los m\u00e9todos de instancia a\u00f1adidos con una extensi\u00f3n tambi\u00e9n pueden modificar (o mutar) la propia instancia. Los m\u00e9todos de las estructuras y los enumerados que modifican self o sus propiedades deben marcarse como mutating . Por ejemplo: extension Int { mutating func cuadrado () { self = self * self } } var unInt = 3 unInt . cuadrado () // unInt es ahora 9","title":"9.5. M\u00e9todos de instancia mutadores"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#96-ajustar-un-tipo-a-un-protocolo-mediante-una-extension","text":"Una extensi\u00f3n puede extender un tipo existente para hacer que se ajuste a uno o m\u00e1s protocolos. En este caso, los nombres de los protocolos se escriben exactamente de la misma forma que en una clase o estructura: extension UnTipo : UnProtocolo , OtroProtocolo { // implementaci\u00f3n de los requisitos del protocolo } Las instancias del tipo adoptar\u00e1n autom\u00e1ticamente el protocolo y se ajustar\u00e1n al protocolo con las propiedades y m\u00e9todos a\u00f1adidos por la extensi\u00f3n. Por ejemplo, este protocolo, llamado RepresentableComoTexto puede ser implementado por cualquier tipo que tenga una forma de representarse como texto. Esto puede ser una descripci\u00f3n de si mismo o una versi\u00f3n de texto de su estado actual: protocol RepresentableComoTexto { var descripcionTextual : String { get } } La clase Dado que vimos anteriormente puede extenderse para ajustarse al protocolo: extension Dado : RepresentableComoTexto { var descripcionTextual : String { return \"Un dado de \\( caras ) caras\" } } Esta extensi\u00f3n adopta el nuevo protocolo exactamente como si el Dado lo hubiera proporcionado en su implementaci\u00f3n original. El nombre del protocolo se indica tras el nombre del tipo, separado por dos puntos, y se proporciona una implementaci\u00f3n entre llaves. Cualquier instancia de un dado se puede tratar ahora como RepresentableComoTexto : let d12 = Dado ( caras : 12 , generador : GeneradorLinealCongruente ()) print ( d12 . descripcionTextual ) // Un dado de 12 caras De forma similar, un Rectangulo tambi\u00e9n puede extenderse para adoptar y ajustarse al protocolo: extension Rectangulo : RepresentableComoTexto { var descripcionTextual : String { return \"Un rect\u00e1ngulo situado en ( \\( origen . x ) , \\( origen . y ) )\" } } let rectanguloInicializado = Rectangulo ( origen : Punto ( x : 2.0 , y : 2.0 ), tama\u00f1o : Tama\u00f1o ( ancho : 5.0 , alto : 5.0 )) print ( rectanguloInicializado . descripcionTextual ) // Un rect\u00e1ngulo situado en (2.0, 2.0)","title":"9.6. Ajustar un tipo a un protocolo mediante una extensi\u00f3n"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#97-declaracion-de-la-adopcion-de-un-protocolo-con-una-extension","text":"Si un tipo ya se ajusta a todos los requisitos de un protocolo, pero todav\u00eda no se ha declarado que se ajusta al protocolo, podemos hacer que lo adopte con una extensi\u00f3n vac\u00eda: struct Hamster { var nombre : String var descripcionTextual : String { return \"Un hamster llamado \\( nombre ) \" } } extension Hamster : RepresentableComoTexto {} Las instancias de Hamster pueden ahora usarse en cualquier sitio que se requiera un tipo RepresentableComoTexto : let simonElHamster = Hamster ( nombre : \"Simon\" ) let algoRepresentableComoTexto : RepresentableComoTexto = simonElHamster print ( algoRepresentableComoTexto . descripcionTextual ) // Un hamster llamado Simon","title":"9.7. Declaraci\u00f3n de la adopci\u00f3n de un protocolo con una extensi\u00f3n"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#98-implementacion-de-metodos-de-un-protocolo","text":"Podemos definir extensiones en los protocolos para proporcionar implementaciones de m\u00e9todos y propiedades a todos los tipos que se ajustan a \u00e9l. Esto permite definir conductas en los propios protocolos, m\u00e1s que en cada tipo individual o en una funci\u00f3n global. Por ejemplo, el protocolo GeneradorNumerosAleatorios puede ser extendido para proporcionar un m\u00e9todo boolAleatorio() , que usa el resultado del random() requerido para devolver un valor Bool aleatorio: extension GeneradorNumerosAleatorios { func randomBool () -> Bool { return random () > 0.5 } } Al crear una extensi\u00f3n en el protocolo, todos los tipos que se ajustan a \u00e9l adquieren autom\u00e1ticamente esta implementaci\u00f3n sin ninguna modificaci\u00f3n adicional. let generator = GeneradorLinealCongruente() print(\"Un n\u00famero aleatorio: \\(generator.random())\") // Imprime \"Un n\u00famero aleatorio: 0.37464991998171\" print(\"Y un booleano aleatorio: \\(generator.randomBool())\") // Imprime \"Un booleano aleatorio: true\" El tipo que se ajusta al protocolo puede proporcionar su propia implementaci\u00f3n, que se usar\u00e1 en lugar de la proporcionada por la extensi\u00f3n.","title":"9.8. Implementaci\u00f3n de m\u00e9todos de un protocolo"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#99-restriccion-en-las-extensiones-de-un-protocolo","text":"En una extensi\u00f3n de un protocolo es posible definir una restricci\u00f3n indicando una condici\u00f3n que se debe cumplir para que la extensi\u00f3n se pueda aplicar. Los m\u00e9todos y propiedades de la extensi\u00f3n s\u00f3lo estar\u00e1n disponibles en aquellos tipos que se ajusten al protocolo y cumplan el requisito. El requisito se definen usando una cl\u00e1usula gen\u00e9rica where en la que se indica una condici\u00f3n sobre alg\u00fan tipo asociado definido en el protocolo. Nota No hemos visto el concepto de tipo asociado en un protocolo. Es una especie de tipo gen\u00e9rico que se define en el protocolo y que se convierte en un tipo concreto en la clase que se ajusta al protocolo. Por ejemplo, podemos definir una extensi\u00f3n al protocolo Collection que se aplique a cualquier colecci\u00f3n cuyos elementos cumplen el protocolo Equatable . De esta forma nos aseguramos de que los operadores == y != est\u00e1n definidos y podemos usarlos en la extensi\u00f3n: extension Collection where Element : Equatable { func allEqual () -> Bool { for element in self { if element != self . first { return false } } return true } } El nombre Element es un nombre definido en el protocolo Collection que se refiere al tipo de los elementos de la colecci\u00f3n. Es un tipo asociado . El m\u00e9todo allEqual() devuelve true si y s\u00f3lo si todos los elementos en la colecci\u00f3n son iguales. Un ejemplo: let numerosIguales = [ 100 , 100 , 100 , 100 , 100 ] let numerosDiferentes = [ 100 , 100 , 200 , 100 , 200 ] Dado que ambos arrays cumplen el protocolo Collection y los enteros cumplen el protocolo Equatable podemos usar el m\u00e9todo allEqual() : print(numerosIguales.allEqual()) // Prints \"true\" print(numerosDiferentes.allEqual()) // Prints \"false\" En una colecci\u00f3n cuyos elementos no cumplen el protocolo Equatable no se puede utilizar el m\u00e9todo de la extensi\u00f3n: let tormenta = Persona ( edad : 32 , nombreCompleto : \"Ororo Munroe\" ) let superHeroes = [ tormenta , peterParker , reedRichards ] print ( superHeroes . allEqual ()) //error: type 'Persona' does not conform to protocol 'Equatable'","title":"9.9. Restricci\u00f3n en las extensiones de un protocolo"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#10-funciones-operadoras","text":"Las clases y las estructuras pueden proporcionar sus propias implementaciones de operadores existentes. Esto se conoce como sobrecarga de los operadores existentes. En el siguiente ejemplo se muestra c\u00f3mo implementar el operador de suma ( + ) para una estructura. El operador suma es un operador binario (tiene dos operandos) e infijo (aparece junto entre los dos operandos). Definimos una estructura Vector2D para un vector de posici\u00f3n de dos dimensiones: struct Vector2D { var x = 0.0 , y = 0.0 static func + ( izquierdo : Vector2D , derecho : Vector2D ) -> Vector2D { return Vector2D ( x : izquierdo . x + derecho . x , y : izquierdo . y + derecho . y ) } } La funci\u00f3n operador se define como una funci\u00f3n est\u00e1tica con un un nombre de funci\u00f3n que empareja con el operador a sobrecargar ( + ). Debido a que la suma aritm\u00e9tica se define como un operador binario, esta funci\u00f3n operador toma dos par\u00e1metros de entrada de tipo Vector2D y devuelve un \u00fanico valor de salida, tambi\u00e9n de tipo Vector2D . En esta implementaci\u00f3n, llamamos a los par\u00e1metros de entrada izquierdo y derecho para representar las instancias de Vector2D que estar\u00e1n a la izquierda y a la derecha del operador + . Son nombres arbitrarios, lo importante es la posici\u00f3n. El primer par\u00e1metro de la funci\u00f3n es el que hace de primer operador. La funci\u00f3n devuelve una nueva instancia de Vector2D , cuyas propiedades x e y se inicializan con la suma de las propiedades x e y de las instancias de Vector2D que se est\u00e1n sumando. La funci\u00f3n se define globalmente, m\u00e1s que como un m\u00e9todo en la estructura Vector2D , para que pueda usarse como un operador infijo entre instancias existentes de Vector2D : let vector = Vector2D ( x : 3.0 , y : 1.0 ) let otroVector = Vector2D ( x : 2.0 , y : 4.0 ) let vectorSuma = vector + otroVector // vectorSuma es una instancia de Vector2D con valores de (5.0, 5.0)","title":"10. Funciones operadoras"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#101-operadores-prefijos-y-postfijos","text":"El ejemplo anterior demuestra una implementaci\u00f3n propia de un operador binario infijo. Las clases y las estructuras pueden tambi\u00e9n proporcionar implementaciones de los operadores unarios est\u00e1ndar. Los operadores unarios operan sobre un \u00fanico objetivo. Son prefijos se preceden el objetivo (como -a ) y postfijos si siguen su objetivo (como en b! ). Para implementar un operador unario prefijo o postfijo se debe escribir el modificador prefix o postfix antes de la palabra clave func en la declaraci\u00f3n de la funci\u00f3n operador: struct Vector2D { ... static prefix func - ( vector : Vector2D ) -> Vector2D { return Vector2D ( x : - vector . x , y : - vector . y ) } } El ejemplo anterior implementa el operador unario negaci\u00f3n ( -a ) para instancias de Vector2D . Por ejemplo: let positivo = Vector2D ( x : 3.0 , y : 4.0 ) let negativo = - positivo // negativo es una instancia de Vector2D con valores de (-3.0, -4.0) let tambienPositivo = - negativo // tambienPositivo es una instancia de Vector2D con valores de (3.0, 4.0)","title":"10.1. Operadores prefijos y postfijos"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#11-genericos","text":"Veamos c\u00f3mo podemos utilizar los gen\u00e9ricos con clases y estructuras. Vamos a utilizar como ejemplo un tipo de dato muy sencillo: una pila ( stack ) en la que se podr\u00e1n a\u00f1adir ( push ) y retirar ( pop ) elementos. La versi\u00f3n no gen\u00e9rica del tipo de dato es la siguiente, en la que se implementa una pila de enteros. struct IntStack { var items = [ Int ]() mutating func push ( _ item : Int ) { items . append ( item ) } mutating func pop () -> Int { return items . removeLast () } } La estructura usa un array para guardar los \u00edtems y los m\u00e9todos push y pop a\u00f1aden y retiran los elementos. El problema de esta estructura es su falta de genericidad; s\u00f3lo puede almacenar enteros. Aqu\u00ed est\u00e1 una versi\u00f3n gen\u00e9rica del mismo c\u00f3digo: struct Stack < Element > { var items = [ Element ]() mutating func push ( _ item : Element ) { items . append ( item ) } mutating func pop () -> Element { return items . removeLast () } } El par\u00e1metro del tipo Element define un tipo gen\u00e9rico que se utiliza como placeholder del tipo real del que se declare la estructura. Podemos ver que se utiliza en la definici\u00f3n de los distintos elementos de la estructura. Por ejemplo, el array de \u00edtems es un array de Element s. Y los \u00edtems a\u00f1adidos y retirados de la pila son tambi\u00e9n objetos de tipo Element . Por ejemplo, podemos crear una pila de cadenas: var stackOfStrings = Stack < String >() stackOfStrings . push ( \"uno\" ) stackOfStrings . push ( \"dos\" ) stackOfStrings . push ( \"tres\" ) stackOfStrings . push ( \"cuatro\" ) // la pila contiene ahora 4 cadenas Y podemos retirar la \u00faltima cadena de la pila: let fromTheTop = stackOfStrings . pop ()","title":"11. Gen\u00e9ricos"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#111-extension-de-un-tipo-generico","text":"Cuando se extiende un tipo gen\u00e9rico, no hace falta a\u00f1adir el par\u00e1metro del tipo entre <> . El tipo gen\u00e9rico est\u00e1 disponible a partir de la definici\u00f3n original y se puede usar tal cual en el cuerpo de la extensi\u00f3n. Por ejemplo, podemos extender el tipo gen\u00e9rico Stack para a\u00f1adir una propiedad computable de s\u00f3lo lectura que devuelva el tope de la pila: extension Stack { var topItem : Element ? { return items . isEmpty ? nil : items [ items . count - 1 ] } } En la extensi\u00f3n se utiliza el nombre gen\u00e9rico Element sin tener que declararlo despu\u00e9s de Stack , porque est\u00e1 definido en la estructura original. Ahora ya se puede acceder al tope de la pila sin retirar el elemento: if let topItem = stackOfStrings . topItem { print ( \"El \u00edtem en el tope de la pila es \\( topItem ) .\" ) } // Imprime \"El \u00edtem en el tope de la pila es tres.\"","title":"11.1. Extensi\u00f3n de un tipo gen\u00e9rico"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#12-bibliografia","text":"Swift Language Guide Classes and Structures Properties Methods Inheritance Initialization Protocolos Casting de tipos Extensiones Funciones operador Gen\u00e9ricos Lenguajes y Paradigmas de Programaci\u00f3n, curso 2021\u201322 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Domingo Gallardo, Cristina Pomares, Antonio Bot\u00eda, Francisco Mart\u00ednez","title":"12. Bibliograf\u00eda"}]}