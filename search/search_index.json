{"config":{"lang":["es"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Home","text":"<p>Sitio web con los apuntes de teor\u00eda, seminarios y pr\u00e1cticas de la asignatura \"Lenguajes y paradigmas de programaci\u00f3n\".</p> <p>Despliega el men\u00fa de la izquierda para consultar los apuntes.</p> <p>Otros enlaces:</p> <ul> <li>Ficha de la asignatura</li> <li>Plataforma docente Moodle</li> </ul>"},{"location":"practicas/buenas-practicas-programacion-funcional.html","title":"Buenas pr\u00e1cticas de programaci\u00f3n funcional","text":"<p>En este documento listamos consejos que te ayudar\u00e1n a escribir programas legibles, concisos y abstractos en el paradigma de programaci\u00f3n funcional usando el lenguaje de programaci\u00f3n Scheme/Racket.</p> <p>Estos consejos se usan en todos los ejemplos de c\u00f3digo de la asignatura, tanto en los ejemplos de teor\u00eda como en las soluciones de las pr\u00e1cticas. Es muy importante que cuando estudies esos ejemplos reflexiones sobre la forma en la que est\u00e1 escrita el c\u00f3digo. Aqu\u00ed extraemos algunas de esas buenas pr\u00e1cticas para hacerlas m\u00e1s expl\u00edcitas.</p>"},{"location":"practicas/buenas-practicas-programacion-funcional.html#nombres-de-funciones-y-variables","title":"Nombres de funciones y variables","text":"<ul> <li> <p>Los nombres de funciones y variables deben ser descriptivos y tener un   significado que ayude a explicar qu\u00e9 hace la funci\u00f3n que estamos   definiendo. Al ser Scheme un lenguaje d\u00e9bilmente tipado, nombres de par\u00e1metros   como <code>car</code>, <code>palabra</code>, <code>lista-numeros</code> nos ayudan a entender cu\u00e1l debe ser el   tipo del par\u00e1metro y c\u00f3mo debemos llamar a la funci\u00f3n.</p> <p>Buenos ejemplos: <code>(entre-dos-puntos? p1 p2 p3)</code>, <code>(distancia punto1 punto2)</code>, <code>(veces car palabra)</code></p> <p>Malos ejemplos: <code>(aux1 x1 x2)</code>, <code>(mi-func x y z)</code></p> </li> <li> <p>Los nombres de las funciones y par\u00e1metros siempre empiezan en   min\u00fascula. Cuando el nombre de una funci\u00f3n o un par\u00e1metro sea compuesto,   usaremos un gui\u00f3n para dividir las palabras.</p> <p>Buenos ejemplos: <code>suma-cuadrados</code>, <code>tiempo-impacto</code>, <code>conduce-vehiculo</code>.</p> <p>Malos ejemplos: <code>sumaCuadrados</code>, <code>Tiempo-Impacto</code>, <code>conduce_vehiculo</code>.</p> </li> <li> <p>Los nombres de los predicados (funciones que devuelven <code>#t</code> o <code>#f</code>) siempre   terminan con el s\u00edmbolo <code>?</code>.</p> <p>Buenos ejemplos: <code>equal?</code>, <code>number?</code>, <code>(entre? p1 p2 p3)</code></p> </li> </ul>"},{"location":"practicas/buenas-practicas-programacion-funcional.html#espacio-indentacion-y-parentesis","title":"Espacio, indentaci\u00f3n y par\u00e9ntesis","text":"<ul> <li> <p>En las expresiones no habr\u00e1 espacio entre el primer par\u00e9ntesis y el operador o   la forma especial. Siempre debe haber un espacio precediendo cada argumento.</p> <p>Buen ejemplo: <code>(+ (* 2 3) (* 10 3))</code></p> <p>Mal ejemplo: <code>(+(* 2 3)(* 10 3))</code></p> </li> <li> <p>El c\u00f3digo tendr\u00e1 una indentaci\u00f3n correcta, que muestre correctamente la estructura de   las formas especiales, expresiones y los par\u00e1metros de las llamadas a   funciones. Se evitar\u00e1n l\u00edneas largas, introduciendo nuevas l\u00edneas y ajustando   la indentaci\u00f3n de las nuevas l\u00edneas para mejorar la legibilidad del c\u00f3digo.</p> <p>Mal ejemplo</p> <pre><code>(if (and (&lt;= x n) (&gt;= y n)) \"n entre x e y\" \"n menor que x o mayor que y\")\n</code></pre> <p>Buen ejemplo</p> <pre><code>(if (and (&lt;= x n)\n         (&gt;= y n))\n    \"n entre x e y\"\n    \"n menor que x o mayor que y\")\n</code></pre> </li> <li> <p>Las par\u00e9ntesis de cierre deben estar todos en la misma l\u00ednea, al final de la   expresi\u00f3n. No deben escribirse como llaves de cierre en l\u00edneas separadas.</p> <p>Buen ejemplo</p> <pre><code>(define (suma-si-positivo x y)\n    (if (&gt; 0 x)\n        (+ x y)\n        y))\n</code></pre> <p>Mal ejemplo</p> <pre><code>(define (suma-si-positivo x y)\n    (if (&gt; 0 x)\n        (+ x y)\n        y\n    )\n)\n</code></pre> </li> </ul>"},{"location":"practicas/buenas-practicas-programacion-funcional.html#estructuras-de-control-y-formas-especiales","title":"Estructuras de control y formas especiales","text":"<ul> <li> <p>Las \u00fanicas estructuras de control, formas especiales y funciones de Scheme que   se deben usar son: <code>define</code>, <code>if</code>, <code>cond</code>, <code>quote</code> (<code>'</code>), <code>and</code>, <code>or</code>, <code>not</code> y   <code>eval</code>.</p> </li> <li> <p>Se usar\u00e1 la sintaxis tradicional de la forma especial <code>cond</code>, y siempre   se incluir\u00e1 una expresi\u00f3n <code>else</code> al final:</p> <p>Buen ejemplo</p> <pre><code>(cond\n    ((&gt; 3 4) \"3 es mayor que 4\")\n    ((&lt; 2 1) \"2 es menor que 1\")\n    ((= 3 1) \"3 es igual que 1\")\n    ((&gt; 3 5) \"3 es mayor que 2\")\n    (else \"ninguna condici\u00f3n es cierta\"))\n</code></pre> </li> </ul>"},{"location":"practicas/buenas-practicas-programacion-funcional.html#no-usar-variables-locales-funciones-locales-ni-pasos-de-ejecucion","title":"No usar variables locales, funciones locales ni pasos de ejecuci\u00f3n","text":"<ul> <li> <p>No se usar\u00e1 <code>define</code> para definir funciones locales. Todas las funciones,   incluyendo las funciones auxiliares, se definir\u00e1n en el \u00e1mbito   global.</p> <p>Mal ejemplo</p> <pre><code>(define (longitud-palabra-entre? a b palabra)\n    (define (entre? a b n)\n        (and (&lt;= a n)\n             (&gt;= b n)))\n    (entre? a b (string-length palabra)))\n</code></pre> <p>Buen ejemplo</p> <pre><code>(define (entre? a b n)\n    (and (&lt;= a n)\n         (&gt;= b n)))\n\n(define (longitud-palabra-entre? a b palabra)\n    (entre? a b (string-length palabra)))\n</code></pre> </li> <li> <p>No se usar\u00e1n variables locales, ni usando  <code>define</code> ni otras formas especiales   de <code>scheme</code>. En lugar de ello, se usar\u00e1n directamente las expresiones que   definen las variables. </p> <p>Mal ejemplo</p> <pre><code>(define (suma-cuadrados x y)\n    (define x-cuadrado (cuadrado x))\n    (define y-cuadrado (cuadrado y))\n\n    (+ x-cuadrado y-cuadrado))\n</code></pre> <p>Buen ejemplo</p> <pre><code>(define (suma-cuadrados x y)\n    (+ (cuadrado x) (cuadrado y)))\n</code></pre> </li> </ul>"},{"location":"practicas/buenas-practicas-programacion-funcional.html#no-usar-numeros-magicos","title":"No usar \"n\u00fameros m\u00e1gicos\"","text":"<ul> <li> <p>Debemos dar un nombre a todos los elementos que aparezcan en nuestro c\u00f3digo,   para aclarar su significado. Por ejemplo, debemos dar nombre a las constantes   num\u00e9ricas, definiendo su significado o, en el caso en que sea una constante   que depende de otros valores,  definir una expresi\u00f3n para calcular su valor.</p> <p>Mal ejemplo</p> <pre><code>(define (encuentra-indice char)\n    (- (char-&gt;integer char) 97))\n</code></pre> <p>Buen ejemplo</p> <pre><code>(define (encuentra-indice char)\n    (- (char-&gt;integer char)\n       (char-&gt;integer #\\a)))\n</code></pre> <p>O tambi\u00e9n:</p> <pre><code>(define indice-char-a (char-&gt;integer #\\a))\n\n(define (encuentra-indice char)\n    (- (char-&gt;integer char) indice-char-a))\n</code></pre> </li> </ul>"},{"location":"practicas/buenas-practicas-programacion-funcional.html#listas","title":"Listas","text":"<ul> <li> <p>Para devolver el primer elemento de la lista y el resto se usar\u00e1n las funciones   <code>first</code> y <code>rest</code>.</p> </li> <li> <p>Las funciones <code>cons</code> y <code>append</code> se usan para a\u00f1adir un elemento a una lista y   para unir dos listas. No usaremos <code>append</code> para a\u00f1adir un elemento en cabeza   de una lista.</p> <p>Mal ejemplo: <code>(append (list 1) '(2 3 4 5))</code></p> <p>Buen ejemplo: <code>(cons 1 '(2 3 4 5))</code></p> </li> <li> <p>Para comprobar si una lista tiene un \u00fanico elemento es preferible, por   motivos de eficiencia, comprobar si su resto es <code>null?</code>, en lugar de usar la funci\u00f3n   <code>length</code>. La funci\u00f3n <code>length</code> tiene un coste lineal mientras que las funciones   <code>rest</code> y <code>null?</code> tienen coste unitario.</p> <p>Buen ejemplo: <code>(null? (rest lista))</code></p> <p>Mal ejemplo: <code>(= 1 (length lista))</code></p> </li> </ul>"},{"location":"practicas/buenas-practicas-programacion-funcional.html#pruebas-unitarias","title":"Pruebas unitarias","text":"<ul> <li> <p>Para comprobar el correcto funcionamiento de las funciones implementadas   usaremos pruebas unitarias con la librer\u00eda <code>rackunit</code>, en lugar de mostrar los   resultados por pantalla con <code>display</code>.</p> <p>Buen ejemplo</p> <pre><code>(require rackunit)\n(define (suma-parejas p1 p2)\n    (cons (+ (car p1) (car p2))\n          (+ (cdr p1) (cdr p2))))\n\n(check-equal? (suma-parejas '(2 . 3) '(1 . 4)) '(3 . 7))\n</code></pre> <p>Mal ejemplo</p> <pre><code>(define (suma-parejas p1 p2)\n    (cons (+ (car p1) (car p2))\n          (+ (cdr p1) (cdr p2))))\n\n(display (suma-parejas '(2 . 3) '(1 . 4))) ;=&gt;  (3 . 7)\n</code></pre> </li> </ul>"},{"location":"practicas/buenas-practicas-programacion-funcional.html#estilo-funcional","title":"Estilo funcional","text":"<ul> <li> <p>Siempre que la expresi\u00f3n resultante sea legible, es preferible construir una   expresi\u00f3n que devuelve un booleano utilizando una composici\u00f3n de operadores   l\u00f3gicos <code>and</code>, <code>or</code>, <code>not</code>, en lugar de utilizar un <code>if</code> que devuelva   directamente un <code>#t</code> o un <code>#f</code>.</p> <p>Buen ejemplo</p> <pre><code>(define (numero-entre? a b n)\n    (and (&lt;= a n)\n         (&gt;= b n)))\n</code></pre> <p>Mal ejemplo</p> <pre><code>(define (numero-entre? a b n)\n    (if (&gt; a n)\n        #f\n        (if (&lt; b n)\n            #f\n            #t)))\n</code></pre> </li> <li> <p>Es recomendable el uso de composici\u00f3n de funciones y la creaci\u00f3n de funciones   de ayuda que proporcionen m\u00e1s abstracci\u00f3n, legibilidad y simplicidad al   c\u00f3digo. Es preferible c\u00f3digo corto y expresivo, evitando la repetici\u00f3n de   llamadas repetidas a la misma funci\u00f3n con los mismos par\u00e1metros.</p> <p>Mal ejemplo</p> <pre><code>(define (longitud-palabra-entre? a b palabra)\n    (and (&lt;= a (string-length palabra))\n         (&gt;= b (string-length palabra))))\n</code></pre> <p>No cumple la recomendaci\u00f3n porque el c\u00f3digo es complicando, con una expresi\u00f3n en donde hay varias llamadas acumuladas. Adem\u00e1s se repiten dos veces la llamada a <code>(string-length palabra)</code>. </p> <p>Es mucho mejor la siguiente versi\u00f3n, en la que simplificamos la expresi\u00f3n obteniendo la longitud de la palabra y comprobando si esa longitud est\u00e1 entre <code>a</code> y <code>b</code>:</p> <p>Buen ejemplo</p> <pre><code>(define (entre? a b n)\n    (and (&lt;= a n)\n         (&gt;= b n)))\n\n(define (longitud-palabra-entre? a b palabra)\n    (entre? a b (string-length palabra)))\n</code></pre> </li> <li> <p>Las funciones auxiliares definidas deben ser lo m\u00e1s flexibles y gen\u00e9ricas   posibles, facilitando la reutilizaci\u00f3n del c\u00f3digo y su uso en la construcci\u00f3n   de otras funciones.</p> <p>Mal ejemplo</p> <pre><code>(define (longitud-aux? a b n)\n    (and (&lt;= a n)\n         (&gt;= b n)))\n\n(define (longitud-palabra-entre? a b palabra)\n    (longitud-aux? a b (string-length palabra)))\n</code></pre> <p>El nombre <code>longitud-aux</code> no es correcto, porque no explica lo que hace la funci\u00f3n y no permite darnos cuenta de que podemos reusarla en otros contexto. Es mucho m\u00e1s adecuado el nombre <code>(entre? a b n)</code> o <code>(numero-entre? a b n)</code>.</p> </li> </ul> <p>Lenguajes y Paradigmas de Programaci\u00f3n, curso 2025-26 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Domingo Gallardo, Cristina Pomares, Antonio Bot\u00eda, Francisco Mart\u00ednez</p>"},{"location":"practicas/practica01/practica01.html","title":"Pr\u00e1ctica 1: Seminario de Scheme","text":""},{"location":"practicas/practica01/practica01.html#realizacion-de-la-practica","title":"Realizaci\u00f3n de la pr\u00e1ctica","text":"<ol> <li>Instala en tu ordenador el DrRacket, tal y como se comenta al    comienzo del seminario de    Scheme    y crea un fichero <code>practica1.rkt</code>. Incluye en el fichero todo el c\u00f3digo que    escribas esta semana. Usa comentarios (l\u00edneas que comienzan con <code>;</code>) para separar secciones y    realizar anotaciones. </li> </ol> <p>Este fichero te servir\u00e1 guardar tu pr\u00e1ctica. Para realizar la entrega deber\u00e1s    copiar las soluciones de cada ejercicio en el cuestionario que habilitaremos en Moodle.</p> <ol> <li> <p>Lee el seminario de Scheme hasta el apartado 2.4. (Tipos de datos    simples) incluido. Puedes ver el v\u00eddeo 1 en la p\u00e1gina con los    v\u00eddeos del seminario (en la semana 1 en Moodle).</p> <p>A la vez que lees el texto o ves el v\u00eddeo debes probar en el int\u00e9rprete de Racket todos los ejemplos que aparecen. Pru\u00e9balos de forma interactiva en el panel de interpretaci\u00f3n del DrRacket y guarda las definiciones en el panel de edici\u00f3n del fichero <code>practica1.rkt</code>.</p> </li> <li> <p>Haz el siguiente ejercicio.</p> <p>Ejercicio 1. Lanza DrRacket y escribe cada una de las siguientes instrucciones en el int\u00e9rprete, intentado adivinar el resultado que va devolver. Est\u00e1n ordenadas por dificultad de arriba abajo y de izquierda a derecha. \u00a1\u00a1Piensa en los resultados!!. Intenta entender c\u00f3mo interpreta Scheme lo que escribes.</p> Instrucci\u00f3n Instrucci\u00f3n <code>3</code> <code>(+ (- 4 (* 3 (/ 4 2) 4)) 3)</code> <code>(+ 1 2 )</code> <code>(* (+ (+ 2 3) 4) (* (* 3 3) 2))</code> <code>(+ 1 2 3 4)</code> <code>(* (+ 2 3 4 5) 3 (- 5 2 1))</code> <code>(+)</code> <code>(+ (- (+ (- (+ 2 3) 5) 1) 2) 3)</code> <code>(sqrt 25)</code> <code>(- (sqrt (* 5 ( + 3 2))) (+ 1 1 1 1))</code> <code>(* (+ 2 3) 5)</code> <code>(&gt; (* 3 (+ 2 (+ 3 1)) (+ 1 1)) (+ (* 2 2) 3))</code> <code>+</code> <code>(= (* 3 2) (+ 1 (+ 2 2) 1))</code> <code>#\\+</code> <code>(not (&gt; (+ 3 2) 5))</code> <code>\"+\"</code> <code>(and (even? 2) (odd? (+ 3 2)))</code> <code>\"hola\"</code> <code>(remainder (+ 6 2) (+ 1 1))</code> </li> <li> <p>Lee el apartado 2.5. (Tipos de datos compuestos) del seminario de    Scheme, en el que se explica c\u00f3mo se trabaja con cadenas, parejas y    listas en Racket. Puedes ver el v\u00eddeo 2 en la p\u00e1gina con los    v\u00eddeos del seminario en Moodle.</p> <p>Prueba en el int\u00e9rprete de Racket todos los ejemplos que aparecen en el seminario.</p> </li> <li> <p>Haz los siguientes ejercicios. </p> <p>Ejercicio 2 sobre parejas. Predice lo que hace Scheme cuando escribas las siguientes expresiones. Est\u00e1n ordenadas por dificultad de arriba abajo y de izquierda a derecha. Despu\u00e9s, pru\u00e9balas y comprueba si tu predicci\u00f3n era correcta. Si no lo era, intenta comprender por qu\u00e9.</p> Instrucci\u00f3n Instrucci\u00f3n <code>(cons 1 2)</code> <code>(car (car (cons (cons 1 2) 3)))</code> <code>(car (cons 1 2))</code> <code>(car (cons (cons 3 4) 2))</code> <code>(cdr (cons 1 2))</code> <code>(cdr (cons (cons 3 4) 2))</code> <code>(cons (* 2 3) (/ 4 2))</code> <code>(cdr (cons 1 (cons 2 3)))</code> <code>(cons (+ 2 1) (if (&gt; 2 3) \"2\" \"3\"))</code> <code>(cdr (car (cons (cons 1 2) 3)))</code> <p>Ejercicio 3 sobre listas. Predice lo que hace Scheme cuando escribas las siguientes expresiones. Despu\u00e9s, pru\u00e9balas y comprueba si tu predicci\u00f3n era correcta. Si no lo era, intenta comprender por qu\u00e9.</p> Instrucci\u00f3n Instrucci\u00f3n <code>(list 1 2 3 4)</code> <code>(cons 3 '(1 2 3))</code> <code>(rest (list 1 2 3 4))</code> <code>(rest (cons #t (cons \"Hola\" (list 1))))</code> <code>(first '(1 2 3 4))</code> <code>(first (list (list 1 2) 1 2 3 4))</code> <code>(first (list #t 1 \"Hola\"))</code> <code>(first (rest '((1 2) 1 2)))</code> <code>(first (rest (list 1 2 3 4)))</code> <code>(cons '(1 2 3) '(4 5 6))</code> <code>(rest (rest '(1 2 3 4)))</code> <code>(first (rest (list 1 2 3 4)))</code> <code>(first (rest (rest (list 1 2 3 4))))</code> <code>(rest (rest (list 1 2 3 4)))</code> <code>(list (* 2 2) (+ 1 2) (/ 4 2))</code> <code>(first (rest (rest (rest '(1 2 3 4)))))</code> <code>(list (+ 2 3) (- 3 4) (string-ref \"hola\" 3))</code> <p>Ejercicio 4 sobre listas. Intenta hacer los siguientes apartados sin utilizar el int\u00e9rprete de Scheme. Despu\u00e9s comprueba si has acertado.</p> <p>a) Dada la siguiente lista, indica la expresi\u00f3n correcta para que Scheme devuelva 3:</p> <pre><code>(list 1 2 3 4 5)\n</code></pre> <p>b) Dada la siguiente lista, indica la expresi\u00f3n correcta para que Scheme devuelva (5).</p> <pre><code>(list 1 2 3 4 5)\n</code></pre> <p>c) Dada la siguiente lista, indica la expresi\u00f3n correcta para que Scheme devuelva 5.</p> <pre><code>(list 1 2 3 4 5)\n</code></pre> <p>d) Dada la siguiente expresi\u00f3n, \u00bfqu\u00e9 devuelve Scheme?</p> <pre><code>(first (rest (rest (list 1 (list 2 3) (list 4 5) 6))))\n</code></pre> <p>e) Dada la siguiente expresi\u00f3n, \u00bfqu\u00e9 devuelve Scheme?</p> <pre><code>(rest (rest '(1 (2 3) 4 5)))\n</code></pre> </li> <li> <p>Lee el apartado 3 (Estructuras de    control) del seminario de Scheme. Puedes ver el    v\u00eddeo 3 hasta el minuto 7:00 en la p\u00e1gina con los v\u00eddeos del    seminario en Moodle.</p> </li> <li> <p>Haz el siguiente ejercicio.</p> <p>Ejercicio 5. Predice lo que devolver\u00e1 Scheme cuando escribas las siguientes expresiones. Est\u00e1n ordenadas por dificultad de arriba abajo y de izquierda a derecha. Despu\u00e9s, pru\u00e9balas y comprueba si tu predicci\u00f3n era correcta. Si no lo era, intenta comprender por qu\u00e9.</p> Instrucci\u00f3n Instrucci\u00f3n <code>(equal? \"hola\" \"hola\")</code> <code>(+ (char-&gt;integer(integer-&gt;char 1200)) (char-&gt;integer #\\A))</code> <code>(string-ref \"pepe\" 1)</code> <code>(string-length (make-string 7 #\\E))</code> <code>(substring \"buenos dias\" 1 4)</code> <code>(define a 3)</code> <code>(define b (+ a 1))</code> <code>(= \"hola\" \"hola\")</code> <code>(+ a b (* a b))</code> <code>(string-ref (substring \"buenos dias\" 2 5) 1)</code> <code>(= a b)</code> <code>(define pi 3.14159)</code> <code>(if (and (&gt; a b) (&lt; b (* a b))) b a)</code> <code>pi</code> <code>(cond ((= a 4) 6)</code><code>((= b 4) (+ 6 7 a))</code><code>(else 25))</code> <code>\"pi\"</code> <code>(+ 2 (if (&gt; b a) b a))</code> <code>(+ pi (+ pi pi))</code> <code>(* (cond ((&gt; a b) a)</code> <code>((&lt; a b) b)</code><code>(else -1))</code><code>(+ a 1))</code> <code>(+ (* pi pi) (- 2 pi pi pi pi))</code> <code>((if (&lt; a b) + -) a b)</code> </li> <li> <p>Lee el resto del seminario, desde el apartado 4 hasta el    final. Puedes ver el v\u00eddeo 3 desde el minuto 7:00 hasta el    final en la p\u00e1gina con los v\u00eddeos del seminario en Moodle.</p> <ul> <li> <p>Prueba las funciones <code>ecuacion</code> y <code>convertir-temperatura</code> y   reflexiona sobre c\u00f3mo se implementan.</p> </li> <li> <p>Prueba las pruebas unitarias de la funci\u00f3n <code>ecuacion</code>. Cambia la   definici\u00f3n de la funci\u00f3n para introducir un error y provocar un   fallo en las pruebas unitarias. Arregla la definici\u00f3n de la   funci\u00f3n para que vuelva a funcionar.</p> </li> </ul> </li> <li> <p>Haz el siguiente ejercicio.</p> <p>Ejercicio 6</p> <p>a) Define una funci\u00f3n que calcule la distancia entre dos puntos, definidos por parejas de n\u00fameros enteros. A\u00f1ade los siguientes tests para comprobar que funciona correctamente:</p> Entrada Salida <code>p1:(0, 0) p2:(0, 10)</code> <code>10</code> <code>p1:(0, 0) p2:(10, 0)</code> <code>10</code> <code>p1:(0, 0) p2:(10, 10)</code> <code>14.142135623730951</code> <p>b) Usando la funci\u00f3n <code>distancia</code> definida anteriormente, implementa la funci\u00f3n <code>isosceles?</code> que recibe las tres coordenadas de los v\u00e9rtices de un tri\u00e1ngulo y debe devolver si la figura es un tri\u00e1ngulo is\u00f3sceles.  Para ello, debes comprobar que los tres lados no son iguales (ser\u00eda equil\u00e1tero) y que sucede alguna de las tres siguientes condiciones: o bien el primer lado es igual que el segundo, o el primer lado es igual que el tercero, o el segundo lado es igual que el tercero.</p> <p>F\u00edjate en que las funciones booleanas <code>and</code>, <code>or</code> y <code>not</code> devuelven ya un valor booleano y que en programaci\u00f3n funcional se usa la composici\u00f3n de funciones.</p> <p>Debes implementar la funci\u00f3n usando una \u00fanica expresi\u00f3n en la que no uses <code>if</code>, sino una composici\u00f3n de expresiones booleanas.</p> <p>Pista</p> <p>Recuerda del seminario que la funci\u00f3n <code>=</code> puede tener m\u00e1s de dos argumentos. </p> <p>A\u00f1ade los tests correspondientes a los siguientes ejemplos:</p> <pre><code>; Ejemplos de tri\u00e1ngulos is\u00f3sceles:\n\n; p1: (0, 0) p2: (3, 3) p3: (6, 0)\n; p1: (2, 2) p2: (4, 0) p3: (0, 0)\n\n; No is\u00f3sceles:\n\n; p1: (0, 0) p2: (0, 0) p3: (0, 0) (igual la distancia entre los tres puntos)\n; p1: (0, 0) p2: (1, 1) p3: (3, 2) (ning\u00fan lado igual)\n\n(isosceles? '(0 . 0) '(3 . 0) '(6 . 0)) ; \u21d2 #t\n(isosceles? '(2 . 2) '(4 . 0) '(0 . 0)) ; \u21d2 #t\n(isosceles? '(0 . 0) '(0 . 0) '(0 . 0)) ; \u21d2 #f\n(isosceles? '(0 . 0) '(1 . 1) '(3 . 2)) ; \u21d2 #f\n</code></pre> </li> </ol>"},{"location":"practicas/practica01/practica01.html#entrega-de-la-practica","title":"Entrega de la pr\u00e1ctica","text":"<p>Copia los ejercicios de la pr\u00e1ctica en el cuestionario Entrega pr\u00e1ctica 1. Tienes de plazo hasta el pr\u00f3ximo domingo a las 21:00h. Una vez finalizado el plazo de entrega podr\u00e1s revisar el cuestionario y visualizar la soluci\u00f3n. En este caso el \u00fanico ejercicio con soluci\u00f3n es el ejercicio 6. </p> <p>Una vez est\u00e9 disponible la soluci\u00f3n debes compararla con la tuya. Puedes consultar cualquier duda con tu profesor de pr\u00e1cticas en la clase de pr\u00e1cticas de la semana que viene.</p> <p>Lenguajes y Paradigmas de Programaci\u00f3n, curso 2025-26 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Domingo Gallardo, Cristina Pomares, Antonio Bot\u00eda, Francisco Mart\u00ednez</p>"},{"location":"practicas/practica02/practica02.html","title":"Pr\u00e1ctica 2: Programaci\u00f3n funcional en Scheme","text":""},{"location":"practicas/practica02/practica02.html#antes-de-la-clase-de-practicas","title":"Antes de la clase de pr\u00e1cticas","text":"<ul> <li> <p>Antes de empezar esta pr\u00e1ctica es importante que revises la soluci\u00f3n   de la pr\u00e1ctica 1. Puedes preguntar las dudas al profesor de pr\u00e1cticas.</p> </li> <li> <p>Los siguientes ejercicios est\u00e1n basados en los conceptos de teor\u00eda vistos la semana pasada. Antes de la clase de pr\u00e1cticas debes repasar todos los conceptos y probar en el DrRacket todos los ejemplos del tema 2 Programaci\u00f3n Funcional hasta el apartado 2.6 Listas incluido.</p> </li> </ul>"},{"location":"practicas/practica02/practica02.html#ejercicios","title":"Ejercicios","text":"<p>Abre el DrRacket y crea el fichero <code>practica2.rkt</code> en el que deber\u00e1s escribir todos los ejemplos y soluciones de los ejercicios que hagas. Escribe en comentarios tu nombre y apellidos. Usa tambi\u00e9n comentarios para separar secciones y realizar anotaciones.  Incluye en el fichero todo el c\u00f3digo, ejemplos y resoluci\u00f3n de ejercicios, que hagas esta semana.</p> <p>Tambi\u00e9n debes a\u00f1adir casos de prueba al c\u00f3digo de todas las funciones que implementes, tal y como vimos al final del seminario de Scheme. Puedes usar algunos de los ejemplos de los enunciados, pero debes tambi\u00e9n construir algunos casos nuevos, con ejemplos creados por ti.</p> <p>Siempre debes incluir casos de prueba</p> <p>Los casos de prueba son un componente importante del c\u00f3digo, ya que permiten guardar en el propio c\u00f3digo una demostraci\u00f3n de que \u00e9ste funciona correctamente, as\u00ed como unos ejemplos de c\u00f3mo llamar a las funciones definidas.</p>"},{"location":"practicas/practica02/practica02.html#ejercicio-1","title":"Ejercicio 1","text":"<p>a) Implementa la funci\u00f3n <code>(binario-a-decimal b3 b2 b1 b0)</code> que reciba 4 bits que representan un n\u00famero en binario y devuelva el n\u00famero decimal equivalente.</p> <pre><code>(binario-a-decimal 1 1 1 1) ; \u21d2 15\n(binario-a-decimal 0 1 1 0) ; \u21d2 6\n(binario-a-decimal 0 0 1 0) ; \u21d2 2\n</code></pre> <p>Nota: recuerda que para realizar esta conversi\u00f3n, se utiliza la siguiente f\u00f3rmula:</p> <pre><code>n = b3 * 2\u02c63 + b2 * 2\u02c62 + b1 * 2\u02c61 + b0 * 2\u02c60\n</code></pre> <p>Para la implementaci\u00f3n de la expresi\u00f3n debes utilizar la funci\u00f3n <code>expt</code>.</p> <p>b) Implementa la funci\u00f3n <code>(binario-a-hexadecimal b3 b2 b1 b0)</code> que reciba 4 bits de un n\u00famero representado en binario y devuelva el car\u00e1cter correspondiente a su representaci\u00f3n en hexadecimal.</p> <pre><code>(binario-a-hexadecimal 1 1 1 1) ; \u21d2 #\\F\n(binario-a-hexadecimal 0 1 1 0) ; \u21d2 #\\6\n(binario-a-hexadecimal 1 0 1 0) ; \u21d2 #\\A\n</code></pre> <p>Nota: para realizar esta conversi\u00f3n, como paso intermedio debes pasar primero el n\u00famero binario a su representaci\u00f3n decimal (utilizando la funci\u00f3n definida en el apartado anterior) y despu\u00e9s a su correspondiente hexadecimal. </p> <p>Recuerda que la representaci\u00f3n hexadecimal de los n\u00fameros decimales del 0 al 9 es el car\u00e1cter correspondiente a ese n\u00famero, y que el n\u00famero decimal 10 se representa con el car\u00e1cter A, el 11 con el B, y as\u00ed sucesivamente hasta el 15 que es el F en hexadecimal.</p> <p>Para la implementaci\u00f3n de esta funci\u00f3n auxiliar que pasa de decimal a hexadecimal debes usar las funciones <code>integer-&gt;char</code> y <code>char-&gt;integer</code>. En la funci\u00f3n <code>char-&gt;integer</code> los caracteres consecutivos est\u00e1n asociados con n\u00fameros consecutivos. Por ejemplo, el entero correspondiente al car\u00e1cter <code>#\\A</code> es uno menos que el correspondiente al car\u00e1cter <code>#\\B</code>. Los caracteres de n\u00fameros y los de letras no son consecutivos.</p>"},{"location":"practicas/practica02/practica02.html#ejercicio-2","title":"Ejercicio 2","text":"<p>El cifrado C\u00e9sar es una t\u00e9cnica cifrado por sustituci\u00f3n en la que cada letra del texto se codifica por la correspondiente desplazada un cierto n\u00famero de lugares. Por ejemplo, si usamos un desplazamiento de 5, el car\u00e1cter <code>#\\c</code> se codificar\u00eda por el car\u00e1cter <code>#\\h</code> (el car\u00e1cter 5 posiciones despu\u00e9s de la <code>#\\c</code> en el alfabeto).</p> <p>Vamos a cifrar y descifrar letras min\u00fasculas y may\u00fasculas del alfabeto ingl\u00e9s (26 caracteres: desde <code>#\\a \u00f3 #\\A)</code> hasta <code>#\\z \u00f3 #\\Z</code>). Vamos a trabajar con un desplazamiento variable, positivo o negativo, dependiendo en que sentido rotemos el alfabeto.</p> <p>Define las funciones <code>(cifra-caracter char desplazamiento)</code> y <code>(descifra-caracter char desplazamiento)</code> que implementen el cifrado anterior.</p> <p>Para la implementaci\u00f3n de las funciones anteriores debes definir y usar las siguientes funciones auxiliares:</p> <ul> <li><code>(encuentra-indice char)</code></li> <li><code>(encuentra-caracter indice)</code></li> <li><code>(entre-az? char)</code></li> <li><code>(rota-indice indice desplazamiento)</code></li> </ul> <p>La funci\u00f3n <code>(rota-indice indice desplazamiento)</code> recibe el \u00edndice del car\u00e1cter original y calcula el \u00edndice del car\u00e1cter cifrado.</p> <p>Consejo: puedes usar la funci\u00f3n <code>modulo</code> ver documentaci\u00f3n.</p> <p>Analiza los siguientes ejemplos para entender mejor el funcionamiento de las funciones auxiliares y las funciones principales:</p> <pre><code>(encuentra-indice #\\a) ; \u21d2 0\n(encuentra-indice #\\b) ; \u21d2 1\n(encuentra-indice #\\m) ; \u21d2 12\n(encuentra-indice #\\z) ; \u21d2 25\n\n(encuentra-caracter 0) ; \u21d2 #\\a\n(encuentra-caracter 1) ; \u21d2 #\\b\n(encuentra-caracter 12) ; \u21d2 #\\m\n(encuentra-caracter 25) ; \u21d2 #\\z\n\n(entre-az? #\\a) ; \u21d2 #t\n(entre-az? #\\m) ; \u21d2 #t\n(entre-az? #\\z) ; \u21d2 #t\n(entre-az? #\\`) ; \u21d2 #f\n(entre-az? #\\{) ; \u21d2 #f\n\n(rota-indice 4 12) ; \u21d2 16)\n(rota-indice 4 24) ; \u21d2 2)\n(rota-indice 4 -5) ; \u21d2 25)\n\n(cifra-caracter #\\c 5) ; \u21d2 #\\h)\n(cifra-caracter #\\z -1) ; \u21d2 #\\y)\n(cifra-caracter #\\j 40) ; \u21d2 #\\x)\n(cifra-caracter #\\D 3) ; \u21d2 #\\G)\n(cifra-caracter #\\\u00f1 3) ; \u21d2 #\\\u00f1)\n\n(descifra-caracter #\\d 3) ; \u21d2 #\\a)\n(descifra-caracter #\\y -1) ; \u21d2 #\\z)\n(descifra-caracter #\\x 40) ; \u21d2 #\\j)\n(descifra-caracter #\\G 3) ; \u21d2 #\\D)\n(descifra-caracter #\\tab 3) ; \u21d2 #\\tab)\n</code></pre>"},{"location":"practicas/practica02/practica02.html#ejercicio-3","title":"Ejercicio 3","text":"<p>Implementa la funci\u00f3n <code>(menor-de-tres n1 n2 n3)</code> que reciba tres n\u00fameros como argumento y devuelva el menor de los tres, intentando que el n\u00famero de condiciones sea m\u00ednima.</p> <p>No debes utilizar la funci\u00f3n <code>min</code>. </p> <p>Implementa dos versiones de la funci\u00f3n: </p> <ul> <li>versi\u00f3n 1: usando la forma especial <code>if</code> </li> <li>versi\u00f3n 2 (ll\u00e1mala <code>menor-de-tres-v2</code>): sin usar la forma especial   <code>if</code>, sino definiendo una funci\u00f3n auxiliar <code>(menor x y)</code> que   devuelva el menor de dos n\u00fameros (en esta s\u00ed que deber\u00edas usar <code>if</code>)   y construyendo la funci\u00f3n <code>menor-de-tres-v2</code> como una composici\u00f3n de   llamadas a esta funci\u00f3n  auxiliar. </li> </ul> <pre><code>(menor-de-tres 2 8 1) ;; \u21d2 1\n(menor-de-tres-v2 3 0 3) ;; \u21d2 0\n</code></pre>"},{"location":"practicas/practica02/practica02.html#ejercicio-4","title":"Ejercicio 4","text":"<p>a) Supongamos las definiciones</p> <pre><code>(define (f x)\n    (cons x 2))\n\n(define (g x y)\n    (cons x y))\n</code></pre> <p>Realiza la evaluaci\u00f3n paso a paso de la siguiente expresi\u00f3n </p> <pre><code>(g (f (+ 2 1)) (+ 1 1))\n</code></pre> <p>mediante el modelo de sustituci\u00f3n, utilizando tanto el orden aplicativo y como el orden normal.</p> <p>Escribe la soluci\u00f3n entre comentarios en el propio fichero <code>.rkt</code> de la pr\u00e1ctica.</p> <p>b) Supongamos las definiciones</p> <pre><code>(define (func-1 x)\n    (/ x 0))\n\n(define (func-2 x y)\n    (if (= x 0)\n        0\n        y))\n</code></pre> <p>Igual que en el apartado anterior, realiza la evaluaci\u00f3n paso a paso de la siguiente expresi\u00f3n</p> <pre><code>(func-2 0 (func-1 10))\n</code></pre> <p>mediante el modelo de sustituci\u00f3n, utilizando tanto el orden aplicativo y como el orden normal. Y escribe la soluci\u00f3n entre comentarios en el propio fichero <code>.rkt</code> de la pr\u00e1ctica.</p>"},{"location":"practicas/practica02/practica02.html#ejercicio-5","title":"Ejercicio 5","text":"<p>Implementa la funci\u00f3n <code>(cadenas-mayores lista1 lista2)</code> que recibe 2 listas con 3 cadenas y devuelve otra lista con las 3 cadenas de mayor longitud, comparando las cadenas de cada posici\u00f3n de la lista. En el caso en que las cadenas tengan la misma longitud, se devuelve la cadena de la primera lista.</p> <p>Pista</p> <p>Puedes utilizar las funciones <code>second</code> y <code>third</code> que devuelven el segundo y el tercer elemento de una lista.</p> <pre><code>(cadenas-mayores '(\"hola\" \"que\" \"tal\") '(\"meme\" \"y\" \"adios\")) ; \u21d2 (\"hola\" \"que\" \"adios\")\n(cadenas-mayores '(\"esto\" \"es\" \"lpp\") '(\"hoy\" \"hay\" \"clase\")) ; \u21d2 (\"esto\" \"hay\" \"clase\")\n</code></pre>"},{"location":"practicas/practica02/practica02.html#ejercicio-6","title":"Ejercicio 6","text":"<p>a) Supongamos que queremos programar un juego de cartas que usa la baraja francesa. Lo primero que debemos hacer es definir una forma de representar las cartas y funciones que trabajen con esa representaci\u00f3n. En este ejercicio vamos a implementar esas funciones.</p> <p>Representaremos una carta por un s\u00edmbolo con dos letras: la primera indicar\u00e1 su n\u00famero o figura y la segunda el palo de la carta, representado con el s\u00edmbolo UTF correspondiente.</p> <p>S\u00edmbolos UTF de los palos de la baraja francesa</p> <p>Puedes copiar los siguientes s\u00edmbolos UTF y pegarlos en el c\u00f3digo fuente de la pr\u00e1ctica: \u2660, \u2663, \u2665 y \u2666 (picas, tr\u00e9boles, corazones y diamantes).</p> <p>Por ejemplo:</p> <pre><code>(define tres-de-picas '3\u2660)\n(define as-de-corazones 'A\u2665)\n(define jota-de-diamantes 'J\u2666)\n</code></pre> <p>Debemos definir la funci\u00f3n <code>carta</code> que devuelve una pareja con el valor correspondiente a su orden en la baraja francesa (un n\u00famero) y el nombre del palo de la carta (como s\u00edmbolo, no como cadena).</p> <pre><code>(carta tres-de-picas) ; \u21d2 (3 . Picas)\n(carta as-de-corazones) ; \u21d2 (1 . Corazones)\n(carta 'K\u2663) ; \u21d2 (12 . Tr\u00e9boles)\n</code></pre> <p>Los valores de las cartas de la baraja francesa son:</p> <pre><code>A (As) \u21d2 1\nJ (Jota) \u21d2 10\nQ (Reina) \u21d2 11\nK (Rey) \u21d2 12\n</code></pre> <p>Para realizar el ejercicio debes definir en primer lugar las funciones <code>(obten-palo char)</code> y <code>(obten-valor char)</code> que devuelven el palo y el valor, dado un car\u00e1cter. Y debes implementar la funci\u00f3n <code>carta</code> usando estas dos funciones.</p> <pre><code>(obten-palo #\\\u2660) ; \u21d2 Picas\n(obten-palo #\\\u2665) ; \u21d2 Corazones\n(obten-valor #\\3) ; \u21d2 3\n(obten-valor #\\J) ; \u21d2 10\n</code></pre> <p>Pista</p> <p>Puedes utilizar las funciones <code>(symbol-&gt;string simbolo)</code> que convierte un s\u00edmbolo en una cadena y <code>(string-ref cadena pos)</code> que devuelve el car\u00e1cter de una cadena situado en una determinada posici\u00f3n.</p> <p>b) Implementa la funci\u00f3n <code>(jugada-mano carta1 carta2 carta3)</code> que recibe 3 cartas de la baraja francesa y devuelve una cadena indicando si la jugada de tres cartas contiene una pareja (dos cartas con el mismo valor), un tr\u00edo (las tres cartas tienen el mismo valor) o nada (las tres cartas son distintas) y tambi\u00e9n el valor de la pareja o del tr\u00edo.</p> <p>Para obtener los valores de las cartas debes implementar la funci\u00f3n <code>(valor-carta carta)</code>.</p> <p>Ejemplos:</p> <pre><code>(jugada-mano '3\u2665 '3\u2663 '3\u2665) ; \u21d2 \"tr\u00edo de 3\"\n(jugada-mano 'K\u2666 '7\u2660 'K\u2665) ; \u21d2 \"pareja de 12\"\n(jugada-mano '5\u2663 '4\u2663 '6\u2663) ; \u21d2 \"nada\"\n</code></pre> <p>N\u00fameros a cadenas</p> <p>Puedes obtener una cadena correspondiente a un n\u00famero usando la funci\u00f3n <code>number-&gt;string</code>. Esta funci\u00f3n solo la debes usar en este ejercicio.</p> <p>Lenguajes y Paradigmas de Programaci\u00f3n, curso 2024-25 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Domingo Gallardo, Cristina Pomares, Antonio Bot\u00eda, Francisco Mart\u00ednez</p>"},{"location":"practicas/practica03/practica03.html","title":"Pr\u00e1ctica 3: Recursi\u00f3n, parejas y diagramas box-and-pointer","text":""},{"location":"practicas/practica03/practica03.html#antes-de-la-clase-de-practicas","title":"Antes de la clase de pr\u00e1cticas","text":"<ul> <li> <p>Antes de empezar esta pr\u00e1ctica es importante que revises la soluci\u00f3n   de la pr\u00e1ctica 2. Puedes preguntar las dudas al profesor de pr\u00e1cticas.</p> </li> <li> <p>Los siguientes ejercicios est\u00e1n basados en los conceptos de teor\u00eda vistos la semana pasada. Antes de la clase de pr\u00e1cticas debes repasar todos los conceptos y probar en el DrRacket todos los ejemplos de los siguientes apartados del tema 2 Programaci\u00f3n Funcional:</p> <ul> <li>2.7 Recursi\u00f3n</li> <li>2.8 Recursi\u00f3n y listas </li> <li>3 Tipos de datos compuestos en Scheme </li> <li>4 Listas en Scheme</li> </ul> </li> </ul>"},{"location":"practicas/practica03/practica03.html#ejercicios","title":"Ejercicios","text":"<p>Abre el DrRacket y crea el fichero <code>practica3.rkt</code> en el que deber\u00e1s escribir todos los ejemplos y soluciones de los ejercicios que hagas.</p>"},{"location":"practicas/practica03/practica03.html#funcion-auxiliar-para-dibujar-diagramas-caja-y-puntero","title":"Funci\u00f3n auxiliar para dibujar diagramas caja y puntero","text":"<p>Descarga el fichero <code>lpp.rkt</code>, pulsando el bot\u00f3n derecho del rat\u00f3n y seleccionando la opci\u00f3n Guardar como <code>lpp.rkt</code>. Gu\u00e1rdalo en la misma carpeta en la que tengas el fichero <code>practica3.rkt</code>. Contiene la definici\u00f3n de una funci\u00f3n auxiliar <code>(caja-puntero dato)</code> que te permite crear diagramas caja y puntero de estructuras de parejas.</p> <p>El siguiente programa muestra un ejemplo del uso de esta funci\u00f3n:</p> <pre><code>#lang racket\n(require rackunit)\n(require \"lpp.rkt\")\n\n(caja-puntero '(1 . 2))\n(caja-puntero (cons 1 (cons 2 (cons 3 4))))\n(caja-puntero (list 1 2 3))\n(caja-puntero '((1 2) . 2))\n(caja-puntero '(1 (2 3) 4))\n</code></pre> <p>La siguiente imagen muestra la ejecuci\u00f3n del programa en el DrRacket.</p> <p></p> <p>Puedes mirar el c\u00f3digo fuente del fichero <code>lpp.rkt</code> para curiosear c\u00f3mo est\u00e1 implementada la funci\u00f3n <code>caja-puntero</code>. Se utiliza la librer\u00eda de im\u00e1genes de Racket <code>2htdp/image</code>.</p> <p>Para usar la librer\u00eda hay que incluir la siguiente l\u00ednea en nuestro programa:</p> <pre><code>#lang racket\n(require 2htdp/image)\n</code></pre> <p>Una cosa muy interesante de esta librer\u00eda es que define las im\u00e1genes como objetos de primera clase del lenguaje, que pueden asignarse a variables o pasarse como par\u00e1metro para construir otras im\u00e1genes. Lo podemos ver en el siguiente ejemplo:</p> <p></p> <p>Incluso podemos incluir im\u00e1genes en listas:</p> <p></p>"},{"location":"practicas/practica03/practica03.html#ejercicio-1","title":"Ejercicio 1","text":"<p>a.1) Implementa la funci\u00f3n recursiva <code>(minimo lista)</code> que recibe una lista con n\u00fameros como argumento y devuelve el menor n\u00famero de la lista. Suponemos listas de 1 o m\u00e1s elementos.</p> <p>Para la implementaci\u00f3n debes usar la funci\u00f3n <code>menor</code> definida en la pr\u00e1ctica anterior.</p> <p>Pista</p> <p>Podemos expresar el caso general de la recursi\u00f3n de la siguiente forma:</p> <p>El m\u00ednimo de los elementos de una lista es el menor entre el primer elemento de la lista y el m\u00ednimo del resto de la lista.</p> <p>Y el caso base:</p> <p>El m\u00ednimo de una lista con un \u00fanico n\u00famero es ese n\u00famero.</p> <p>Ejemplos:</p> <pre><code>(minimo '(2)) ; \u21d2 2\n(minimo '(1 8 6 4 3)) ; \u21d2 1\n(minimo '(1 -1 3 -6 4)) ; \u21d2 -6\n</code></pre> <p>C\u00f3mo comprobar el caso base de <code>minimo</code></p> <p>Para el caso base de la funci\u00f3n <code>minimo</code> debemos comprobar si la lista que recibimos tiene un solo elemento. En ese caso el m\u00ednimo de la lista es el propio elemento. Ser\u00eda un error llamar a la recursi\u00f3n porque no se puede calcular el menor elemento de una lista vac\u00eda.</p> <p>La mejor forma de comprobar en Scheme si una lista tiene un solo elemento es:</p> <pre><code>(null? (rest lista))\n</code></pre> <p>Esta forma es m\u00e1s eficiente que llamar a la funci\u00f3n <code>length</code> que necesita recorrer toda la lista. El coste de la instrucci\u00f3n <code>(null? (rest lista))</code> no depende de la longitud de la lista, es O(1). Sin embargo, la instrucci\u00f3n <code>(length lista)</code> tiene que recorrer toda la lista por lo que tiene una complejidad de O(n).</p> <p>Muchas veces ver\u00e1s tambi\u00e9n una expresi\u00f3n equivalente para comprobar si una lista tiene un \u00fanico elemento: :</p> <pre><code>(null? (cdr lista))\n</code></pre> <p>Es una expresi\u00f3n que suelen usar los programadores de Scheme, algo que se conoce como una expresi\u00f3n idiom\u00e1tica del lenguaje.</p> <p>a.2) Vamos a investigar el funcionamiento de la recursi\u00f3n en la funci\u00f3n <code>minimo</code>. Supongamos la siguiente llamada:</p> <pre><code>(minimo '(1 8 6 4 3)) ; \u21d2 1\n</code></pre> <ul> <li>\u00bfQu\u00e9 lista se pasa como par\u00e1metro a la primera llamada recursiva a   la funci\u00f3n?</li> <li>\u00bfQu\u00e9 devuelve esa llamada recursiva?</li> <li>\u00bfCon qu\u00e9 argumentos se llama a la funci\u00f3n <code>menor</code> que devuelve el   resultado final?</li> </ul> <p>b) Implementa la funci\u00f3n recursiva <code>(concatena lista-chars)</code> que recibe una lista de caracteres y devuelve la cadena resultante de concatenarlos.</p> <p>Ejemplos:</p> <pre><code>(concatena '()) ; \u21d2 \"\"\n(concatena '(#\\H #\\o #\\l #\\a)) ; \u21d2 \"Hola\"\n(concatena '(#\\S #\\c #\\h #\\e #\\m #\\e #\\space #\\m #\\o #\\l #\\a))  \n; \u21d2 \"Scheme mola\"\n</code></pre> <p>c) Implementa la funci\u00f3n recursiva <code>(cifra-cadena cad desplazamiento)</code> que, usando la funci\u00f3n <code>cifra-caracter</code> de la pr\u00e1ctica anterior, cifre una cadena completa usando el cifrado de C\u00e9sar. </p> <p>Implementa despu\u00e9s la funci\u00f3n <code>(descifra-cadena cad desplazamiento)</code> que descifra una cadena completa. </p> <p>Ejemplos:</p> <pre><code>(cifra-cadena \"En un lugar de la Mancha, de cuyo nombre no quiero acordarme\" 10) ; \u21d2\n\"Ox ex veqkb no vk Wkxmrk, no meiy xywlbo xy aesoby kmybnkbwo\"\n\n(descifra-cadena \"Ox ex veqkb no vk Wkxmrk, no meiy xywlbo xy aesoby kmybnkbwo\" 10) ; \u21d2\n\"En un lugar de la Mancha, de cuyo nombre no quiero acordarme\"\n</code></pre> <p>d) Implementa el predicado recursivo <code>(contiene? lista elemento)</code> que comprueba si una lista tiene un elemento determinado. Despu\u00e9s \u00fasala para implementar la funci\u00f3n <code>(str-contiene? cadena char)</code> que comprueba si una cadena contiene un car\u00e1cter. Recuerda que la funci\u00f3n <code>string-&gt;list</code> que convierte una cadena en una lista de caracteres.</p> <p>Ejemplos:</p> <pre><code>(contiene? '(algo 3 #\\A) 3) ; \u21d2 #t\n(contiene? '(algo 3 #\\A) \"algo\") ; \u21d2 #f\n(contiene? '(algo 3 #\\A) 'algo) ; \u21d2 #t\n(str-contiene? \"Hola\" #\\o) ; \u21d2 #t\n(str-contiene? \"Esto es una frase\" #\\space) ; \u21d2 #t\n(str-contiene? \"Hola\" #\\h) ; \u21d2 #f\n</code></pre>"},{"location":"practicas/practica03/practica03.html#ejercicio-2","title":"Ejercicio 2","text":"<p>a) Implementa el predicado recursivo <code>(todos-iguales? lista)</code> que comprueba si todos los elementos de una lista son iguales.</p> <pre><code>(todos-iguales? '()) ; \u21d2 #t\n(todos-iguales? '(a)) ; \u21d2 #t\n(todos-iguales? '(a a a a a a a)) ; \u21d2 #t\n(todos-iguales? '((a b) (a b) (a b))) ; \u21d2 #t\n(todos-iguales? '(a a a a a b)) ; \u21d2 #f\n</code></pre> <p>b) Implementa el predicado recursivo <code>(todos-distintos? lista)</code> que comprueba si todos los elementos de una lista son distintos. Para su implementaci\u00f3n debes usar el predicado del ejercicio 1 <code>contiene?</code>.</p> <pre><code>(todos-distintos? '()) ; \u21d2 #t\n(todos-distintos? '(a)) ; \u21d2 #t\n(todos-distintos? '(a b c)) ; \u21d2 #t\n(todos-distintos? '(a b c a)) ; \u21d2 #f\n</code></pre> <p>c) Implementa el predicado recursivo <code>(solo-dos-iguales? lista)</code>que comprueba que solo hay dos elementos iguales en una lista (los \u00fanicos elementos repetidos que hay en la lista se repiten dos veces). Para su implementaci\u00f3n puedes usar los predicados anteriores.</p> <pre><code>(solo-dos-iguales? '()) ; \u21d2 #f\n(solo-dos-iguales? '(a)) ; \u21d2 #f\n(solo-dos-iguales? '(a b c a)) ; \u21d2 #t\n(solo-dos-iguales? '(a b c b a a)) ; \u21d2 #f\n(solo-dos-iguales? '(a b c a a)) ; \u21d2 #f\n(solo-dos-iguales? '(a b c a b)) ; \u21d2 #f\n</code></pre>"},{"location":"practicas/practica03/practica03.html#ejercicio-3","title":"Ejercicio 3","text":"<p>a.1) Dado el siguiente box &amp; pointer, escribe la expresi\u00f3n en Scheme que define <code>p1</code> usando el m\u00ednimo n\u00famero de llamadas a <code>list</code> y <code>cons</code>. No debes utilizar expresiones con <code>quote</code> para construir las listas ni las parejas. Puedes usar la funci\u00f3n gr\u00e1fica <code>caja-puntero</code> para comprobar si tu soluci\u00f3n es correcta. </p> <p></p> <p>a.2) Escribe las expresiones que devuelven <code>b</code> y <code>d</code> a partir de <code>p1</code>. Debes usar las funciones sobre listas <code>first</code>, <code>second</code>, etc. si el argumento es una lista y <code>car</code> y <code>cdr</code> si es una pareja que no forma parte de una lista.</p> <p>b.1) Dado el siguiente diagrama caja y puntero, escribe la expresi\u00f3n en Scheme que define <code>p2</code> usando el m\u00ednimo n\u00famero de llamadas a <code>list</code> y <code>cons</code>.</p> <p></p> <p>b.2) Escribe las expresiones que devuelven <code>c</code> y <code>e</code> a partir de <code>p2</code>. Debes usar las funciones sobre listas <code>first</code>, <code>second</code>, etc. si el argumento es una lista y <code>car</code> y <code>cdr</code> si es una pareja que no forma parte de una lista.</p>"},{"location":"practicas/practica03/practica03.html#ejercicio-4","title":"Ejercicio 4","text":"<p>Implementa la funci\u00f3n recursiva <code>(contar-datos-iguales lista-parejas)</code> que recibe una lista de parejas y devuelve el n\u00famero de parejas que tienen sus dos datos iguales.</p> <pre><code>(contar-datos-iguales '((2 . 3) (\"hola\" . \"hola\") (\\#a . \\#a) (true . false))) ; \u21d2 2\n(contar-datos-iguales '((2 . \"hola\") (\"hola\" . 3) (\\#a . true) (\\#b . false))) ; \u21d2 0\n</code></pre>"},{"location":"practicas/practica03/practica03.html#ejercicio-5","title":"Ejercicio 5","text":"<p>Vamos a seguir jugando al poker. Esta vez vamos a definir funciones sobre manos de cartas, definidas como listas de 5 s\u00edmbolos que representan cartas.</p> <p>Por ejemplo, las siguientes manos:</p> <pre><code>(define mano1 '(A\u2666 2\u2666 3\u2663 4\u2666 5\u2665))\n(define mano2 '(J\u2666 J\u2663 J\u2660 J\u2665 K\u2663))\n</code></pre> <p>Copia de la pr\u00e1ctica anterior la soluci\u00f3n de la funci\u00f3n <code>(valor-carta carta)</code> que devuelve el valor num\u00e9rico de una carta:</p> <pre><code>(valor-carta '5\u2663) ; \u21d2 5\n(valor-carta 'K\u2666) ; \u21d2 12\n</code></pre> <p>a) Implementa la funci\u00f3n <code>(palo-carta carta)</code> de forma similar a la funci\u00f3n <code>valor-carta</code> para que devuelva el s\u00edmbolo con la descripci\u00f3n del palo de la carta.</p> <pre><code>(palo-carta 'A\u2660) ; \u21d2 Picas\n(palo-carta '2\u2663) ; \u21d2 Tr\u00e9boles\n(palo-carta '3\u2665) ; \u21d2 Corazones\n(palo-carta '4\u2666) ; \u21d2 Diamantes\n</code></pre> <p>Tendr\u00e1s que usar las funciones <code>valor-carta</code> y <code>palo-carta</code> para implementar las siguientes funciones del ejercicio.</p> <p>b) Implementa la funci\u00f3n recursiva <code>(veces-palo lista palo)</code> que devuelve el n\u00famero de veces que aparece un palo en una lista de cartas.</p> <pre><code>(veces-palo '(5\u2660 6\u2663 7\u2665 8\u2666 9\u2660) 'Picas) ; \u21d2 2\n(veces-palo '(J\u2660 Q\u2663 K\u2665) 'Diamantes) ; \u21d2 0\n(veces-palo '(A\u2663 2\u2665 3\u2660) 'Corazones) ; \u21d2 1\n(veces-palo '() 'Tr\u00e9boles) ; \u21d2 0\n</code></pre> <p>Usando la funci\u00f3n anterior, implementa el predicado <code>color?</code> que comprueba si en una mano tenemos todas las cartas del mismo palo:</p> <pre><code>(color? '(5\u2663 J\u2666 J\u2663 Q\u2660 Q\u2665)) ; \u21d2 #f\n(color? '(2\u2666 5\u2666 6\u2666 J\u2666 K\u2666)) ; \u21d2 #t\n</code></pre> <p>c) Implementa el predicado recursivo <code>escalera?</code> que recibe una lista de cartas y comprueba si todas ellas tienen valores consecutivos, ordenados de menor a mayor.</p> <pre><code>(escalera? '(5\u2663 4\u2666 3\u2663)) ; \u21d2 #f\n(escalera? '(8\u2663 9\u2666 J\u2663 Q\u2666)) ; \u21d2 #t\n(escalera? '(8\u2663 2\u2663)) ; \u21d2 #f\n(escalera? '(A\u2663 2\u2666 3\u2663)) ; \u21d2 #t\n</code></pre> <p>Usando las funciones anteriores implementa la funci\u00f3n <code>(escalera-color? mano)</code> que comprueba si una mano de cartas es una escalera de color. Suponemos que las cartas que forman la mano est\u00e1n ordenadas de menor a mayor.</p> <pre><code>(escalera-color? '(5\u2663 6\u2666 7\u2663 8\u2660 9\u2665)) ; \u21d2 #f\n(escalera-color? '(A\u2666 2\u2666 3\u2666 4\u2666 5\u2666)) ; \u21d2 #t\n</code></pre>"},{"location":"practicas/practica03/practica03.html#ejercicio-6","title":"Ejercicio 6","text":"<p>a) Implementa las funciones <code>(suma-izq pareja n)</code> y <code>(suma-der pareja n)</code> definidas de la siguiente forma:</p> <ul> <li><code>(suma-izq pareja n)</code>: devuelve una nueva pareja con la parte izquierda   incrementada en <code>n</code>.</li> <li><code>(suma-der pareja n)</code>: devuelve una nueva pareja con la parte derecha   incrementada en <code>n</code>.</li> </ul> <p>Ejemplos:</p> <pre><code>(suma-izq (cons 10 20) 3)  ; \u21d2 (13 . 20)\n(suma-der (cons 10 20) 5)  ; \u21d2 (10 . 25)\n</code></pre> <p>b.1) Implementa la funci\u00f3n recursiva <code>(suma-impares-pares lista-num)</code> que devuelva una pareja cuya parte izquierda sea la suma de los n\u00fameros impares de la lista y la parte derecha la suma de los n\u00fameros pares. Debes utilizar las funciones auxiliares definidas en el apartado anterior. Tambi\u00e9n puedes utilizar las funciones predefinidas <code>even?</code> y <code>odd?</code>.</p> <p>Ejemplos:</p> <p><pre><code>(suma-impares-pares '(3 2 1 4 8 7 6 5)) ; \u21d2 (16 . 20)\n(suma-impares-pares '(3 1 5))           ; \u21d2 (9 . 0)\n</code></pre> b.2) Dada la siguiente llamada, indica qu\u00e9 devuelve la primera llamada recursiva:</p> <pre><code>(suma-impares-pares '(2 1 2 1 4))\n</code></pre> <p>c) Implementa la funci\u00f3n recursiva <code>(cadena-mayor lista)</code> que recibe un lista de cadenas y devuelve una pareja con la cadena de mayor longitud y dicha longitud.  En el caso de que haya m\u00e1s de una cadena con la m\u00e1xima longitud, se devolver\u00e1 la \u00faltima de ellas que aparezca en la lista.</p> <p>En el caso en que la lista sea vac\u00eda se devolver\u00e1 la pareja con la cadena vac\u00eda y un 0 (la longitud de la cadena vac\u00eda).</p> <p>Pista: puedes utilizar la funci\u00f3n <code>string-length</code></p> <pre><code>(cadena-mayor '(\"vamos\" \"a\" \"obtener\" \"la\" \"cadena\" \"mayor\")) ; \u21d2  (\"obtener\" . 7)\n(cadena-mayor '(\"prueba\" \"con\" \"maximo\" \"igual\")) ; \u21d2 (\"maximo\" . 6)\n(cadena-mayor '()) ; \u21d2 (\"\" . 0)\n</code></pre> <p>Lenguajes y Paradigmas de Programaci\u00f3n, curso 2024-25 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Domingo Gallardo, Cristina Pomares, Antonio Bot\u00eda, Francisco Mart\u00ednez</p>"},{"location":"practicas/practica04/practica04.html","title":"Pr\u00e1ctica 4: Funciones recursivas que devuelven listas","text":""},{"location":"practicas/practica04/practica04.html#antes-de-la-clase-de-practicas","title":"Antes de la clase de pr\u00e1cticas","text":"<ul> <li> <p>Antes de empezar esta pr\u00e1ctica es importante que revises la soluci\u00f3n   de la pr\u00e1ctica 3. Puedes preguntar las dudas al profesor de pr\u00e1cticas.</p> </li> <li> <p>Los siguientes ejercicios est\u00e1n basados en los conceptos de teor\u00eda vistos la semana pasada. Antes de la clase de pr\u00e1cticas debes repasar todos los conceptos y probar en el DrRacket todos los ejemplos de los siguientes apartados del tema 2 Programaci\u00f3n Funcional:</p> <ul> <li>4.3. Funciones recursivas que construyen listas</li> <li>4.4. Funciones con n\u00famero variable de argumentos</li> <li>5 Funciones como tipos de datos de primera clase (incluido hasta el   apartado 5.3. Funci\u00f3n apply)</li> </ul> </li> </ul>"},{"location":"practicas/practica04/practica04.html#ejercicios","title":"Ejercicios","text":""},{"location":"practicas/practica04/practica04.html#ejercicio-1","title":"Ejercicio 1","text":"<p>a) Implementa la funci\u00f3n recursiva <code>(contiene-prefijo prefijo lista-pal)</code> que recibe una cadena y una lista de palabras. Devuelve una lista con los booleanos resultantes de comprobar si la cadena es prefijo de cada una de las palabras de la lista.</p> <p>Debes definir una funci\u00f3n auxiliar <code>(es-prefijo? pal1 pal2)</code> que compruebe si la palabra 1 es prefijo de la palabra 2.</p> <p>Pista</p> <p>Puedes usar la funci\u00f3n <code>(substring palabra inicio final)</code> que devuelve la subcadena de la <code>palabra</code> que va desde la posici\u00f3n <code>inicio</code> hasta la posici\u00f3n <code>final</code> (sin incluir).</p> <p>Ejemplos:</p> <pre><code>(es-prefijo? \"ante\" \"anterior\") ; \u21d2 #t\n(contiene-prefijo \"ante\" '(\"anterior\" \"ant\u00edgona\" \"antena\" \"anatema\")) \n; \u21d2 (#t #f #t #f)\n</code></pre> <p>b) Vamos a generalizar la soluci\u00f3n del ejercicio 5 de la pr\u00e1ctica 2 e implementar la funci\u00f3n recursiva <code>(cadenas-mayores lista1 lista2)</code> teniendo en cuenta que las listas que recibe tienen un n\u00famero indeterminado de cadenas. En el caso en que una de las listas sea mayor que la otra, se deber\u00e1n a\u00f1adir todas sus cadenas a la lista resultante.</p> <p>Ejemplos:</p> <pre><code>(cadenas-mayores '(\"hola\" \"que\" \"tal\") '(\"adios\")) \n; \u21d2 (\"adios\" \"que\" \"tal\")\n(cadenas-mayores '(\"hola\" \"que\" \"tal\") '(\"meme\" \"y\" \"adios\"))\n; \u21d2 (\"hola\" \"que\" \"adios\")\n(cadenas-mayores '(\"la\" \"primera\" \"pr\u00e1ctica\" \"de\" \"recursi\u00f3n\")\n                 '(\"confiar\" \"en\" \"la\" \"recursi\u00f3n\" \"facilita\" \"su\" \"resoluci\u00f3n\"))\n; \u21d2 (\"confiar\" \"primera\" \"pr\u00e1ctica\" \"recursi\u00f3n\" \"recursi\u00f3n\" \"su\" \"resoluci\u00f3n\")\n</code></pre>"},{"location":"practicas/practica04/practica04.html#ejercicio-2","title":"Ejercicio 2","text":"<p>a) Implementa la funci\u00f3n recursiva <code>(inserta-pos dato pos lista)</code> que recibe un dato, una posici\u00f3n y una lista y devuelve la lista resultante de insertar el dato en la posici\u00f3n indicada de la lista. Si la posici\u00f3n es 0, el dato se inserta en cabeza. Suponemos que la posici\u00f3n siempre ser\u00e1 positiva y menor o igual que la longitud de la lista.</p> <p>Ejemplos:</p> <pre><code>(inserta-pos 'b 2 '(a a a a)) ; \u21d2 '(a a b a a)\n(inserta-pos 'b 0 '(a a a a)) ; \u21d2 '(b a a a a)\n</code></pre> <p>b) Implementa la funci\u00f3n recursiva <code>(inserta-ordenada n lista-ordenada)</code> que recibe un n\u00famero y una lista de n\u00fameros ordenados de menor a mayor y devuelve la lista resultante de insertar el n\u00famero <code>n</code> en la posici\u00f3n correcta para que la lista siga estando ordenada.</p> <p>Ejemplo:</p> <pre><code>(inserta-ordenada 10 '(-8 2 3 11 20)) ; \u21d2 (-8 2 3 10 11 20)\n</code></pre> <p>c) Usando la funci\u00f3n anterior <code>inserta-ordenada</code> implementa la funci\u00f3n recursiva <code>(ordena lista)</code> que recibe una lista de n\u00fameros y devuelve una lista ordenada.</p> <p>Ejemplo:</p> <pre><code>(ordena '(2 -1 100 4 -6)) ; \u21d2 (-6 -1 2 4 100)\n</code></pre>"},{"location":"practicas/practica04/practica04.html#ejercicio-3","title":"Ejercicio 3","text":"<p>a) Implementa la funci\u00f3n recursiva <code>(mueve-al-principio lista dato)</code> que recibe una lista y un  dato que est\u00e1 contenido en la lista. La funci\u00f3n debe devolver la lista resultante de mover la primera aparici\u00f3n del dato al comienzo de la lista, dejando el resto de la lista sin modificar. Suponemos que el dato que se pasa como par\u00e1metro est\u00e1 contenido en la lista.</p> <p>Ejemplo:</p> <pre><code>(mueve-al-principio '(a b e c d e f) 'e) ; \u21d2 (e a b c d e f)\n(mueve-al-principio '(a b c d e f g) 'a) ; \u21d2 (a b c d e f g)\n</code></pre> <p>b) Implementa una funci\u00f3n recursiva <code>(comprueba-simbolos lista-simbolos lista-num)</code> que recibe una lista de s\u00edmbolos y una lista de n\u00fameros enteros (ambas de la misma longitud) y devuelve una lista de parejas. Cada pareja est\u00e1 formada por el s\u00edmbolo de la i-\u00e9sima posici\u00f3n de <code>lista-simbolos</code> y el n\u00famero entero situado esa posici\u00f3n de <code>lista-num</code>, siempre y cuando dicho n\u00famero se corresponda con la longitud de la cadena correspondiente al s\u00edmbolo. Puedes utilizar las funciones predefinidas <code>string-length</code> y <code>symbol-&gt;string</code>.</p> <p>Ejemplo:</p> <pre><code>(comprueba-simbolos '(este es un ejercicio de examen) '(2 1 2 9 1 6))\n; \u21d2 ((un . 2) (ejercicio . 9) (examen . 6))\n</code></pre>"},{"location":"practicas/practica04/practica04.html#ejercicio-4","title":"Ejercicio 4","text":"<p>Vamos a implementar distintas versiones de funciones que expanden una lista original. </p> <p>En el primer apartado definiremos una funci\u00f3n auxiliar que se deber\u00e1 usar en todos los dem\u00e1s apartados.</p> <p>a) Escribe la funci\u00f3n recursiva <code>(expande-pareja pareja)</code> que recibe una pareja formada por un dato y un n\u00famero n y devuelve la lista formada por n repeticiones del dato.</p> <p>Ejemplo:</p> <pre><code>(expande-pareja '(hola . 3)) ; \u21d2 (hola hola hola)\n(expande-pareja '(#t . 5)) ; \u21d2 (#t #t #t #t #t)\n</code></pre> <p>b) Vamos a implementar dos versiones de la funci\u00f3n <code>(expande-parejas pareja_1 ... pareja_n)</code> que recibe un n\u00famero variable de argumentos (todos opcionales) y devuelve una lista donde se han \"expandido\" las parejas, creando una lista con tantos elementos como el n\u00famero que indique cada pareja. Todos los argumentos son opcionales; si no hay argumentos se devolver\u00e1 la lista vac\u00eda.</p> <p>Ejemplo:</p> <pre><code>(expande-parejas '(#t . 3) '(\"LPP\" . 2) '(b . 4)) \n; \u21d2 (#t #t #t \"LPP\" \"LPP\" b b b b)\n</code></pre> <p>b.1) Escribe una soluci\u00f3n en la que la funci\u00f3n <code>expande-parejas</code> llame a una funci\u00f3n recursiva <code>(expande-lista lista-parejas)</code> que trabaje sobre una lista de parejas.</p> <p>b.2) Escribe una soluci\u00f3n en la que la propia funci\u00f3n <code>expande-parejas</code> sea recursiva. Ll\u00e1mala <code>expande-parejas-2</code> y ten cuidado de que la llamada recursiva sea tambi\u00e9n a la propia <code>expande-parejas-2</code>.</p> <p>Pista</p> <p>Repasa el apartado 5.3.1 de teor\u00eda, en el que se explica c\u00f3mo usar <code>apply</code> para implementar funciones recursivas con n\u00famero variable de argumentos.</p> <p>c) Implementa la funci\u00f3n recursiva <code>(expande lista)</code>. Recibe una lista en la que hay intercalados algunos n\u00fameros enteros positivos. Devuelve la lista original en la que se han expandido los elementos siguientes a los n\u00fameros, tantas veces como indica el n\u00famero. La lista nunca va a contener dos n\u00fameros consecutivos y siempre va a haber un elemento despu\u00e9s de un n\u00famero.</p> <p>Debes usar tambi\u00e9n para su implementaci\u00f3n la funci\u00f3n <code>(expande-pareja pareja)</code> definida en el apartado a).</p> <p>Ejemplo:</p> <pre><code>(expande '(4 clase ua 3 lpp aulario)) \n; \u21d2 (clase clase clase clase ua lpp lpp lpp aulario)\n</code></pre> <p>En el ejemplo, el 4 indica que el siguiente elemento (<code>clase</code>) se debe repetir 4 veces en la lista expandida y el 3 indica que el siguiente elemento (<code>lpp</code>) se va a repetir 3 veces.</p>"},{"location":"practicas/practica04/practica04.html#ejercicio-5","title":"Ejercicio 5","text":"<p>a) Indica qu\u00e9 devuelven las siguientes expresiones en Scheme. Puede ser que alguna expresi\u00f3n contenga alg\u00fan error. Ind\u00edcalo tambi\u00e9n en ese caso y explica qu\u00e9 tipo de error. Hazlo sin el int\u00e9rprete, y despu\u00e9s comprueba con el int\u00e9rprete si tu respuesta era correcta.</p> <pre><code>((lambda (x) (* x x)) 3) ; \u21d2 ?\n((lambda () (+ 6 4))) ; \u21d2 ?\n((lambda (x y) (* x (+ 2 y))) (+ 2 3) 4) ; \u21d2 ?\n((lambda (x y) (* x (+ 2 x))) 5) ; \u21d2 ?\n\n\n(define f (lambda (a b) (string-append \"***\" a b \"***\")))\n(define g f)\n(procedure? g) ; \u21d2 ?\n(g \"Hola\" \"Adios\") ; \u21d2 ?\n</code></pre> <p>b) Hemos visto en teor\u00eda que la forma especial <code>define</code> para construir funciones es azucar sint\u00e1ctico y que el int\u00e9rprete de Scheme la convierte en una expresi\u00f3n equivalente usando la forma especial <code>lambda</code>.</p> <p>Escribe cu\u00e1l ser\u00eda las expresiones equivalentes, usando la forma especial <code>lambda</code> a las siguientes definiciones de funciones:</p> <pre><code>(define (suma-3 x)\n   (+ x 3))\n\n(define (factorial x)\n   (if (= x 0)\n      1\n      (* x (factorial (- x 1)))))\n</code></pre> <p>c) Suponiendo las siguientes definiciones de funciones indica qu\u00e9 devolver\u00edan las invocaciones. Puede ser que alguna expresi\u00f3n contenga alg\u00fan error. Ind\u00edcalo tambi\u00e9n en ese caso y explica qu\u00e9 tipo de error.</p> <p>Hazlo sin el int\u00e9rprete, y despu\u00e9s comprueba con el int\u00e9rprete si tu respuesta era correcta.</p> <pre><code>(define (doble x)\n   (* 2 x))\n\n(define (foo f g x y)\n   (f (g x) y))\n\n(define (bar f p x y)\n   (if (and (p x) (p y))\n       (f x y)\n       'error))\n\n(foo + 10 doble 15) ; \u21d2 ?\n(foo doble + 10 15) ; \u21d2 ?\n(foo + doble 10 15) ; \u21d2 ?\n(foo string-append (lambda (x) (string-append \"***\" x)) \"Hola\" \"Adios\") ; \u21d2 ?\n\n(bar doble number? 10 15) ; \u21d2 ?\n(bar string-append string? \"Hola\" \"Adios\") ; \u21d2 ?\n(bar + number? \"Hola\" 5) ; \u21d2 ?\n</code></pre>"},{"location":"practicas/practica04/practica04.html#ejercicio-6","title":"Ejercicio 6","text":"<p>Vamos a seguir jugando a las cartas con Scheme. Vas a tener que implementar una serie de funciones auxiliares con las que vas a poder hacer un truco de cartas al final del ejercicio.</p> <p>Comienza por volver a descargar el fichero <code>lpp.rkt</code>. En \u00e9l hemos incluido una nueva funci\u00f3n <code>(cartas n)</code> con las que puedes generar una lista de n cartas aleatorias de una baraja de hasta 48 cartas. Por ejemplo:</p> <pre><code>(cartas 10) ; \u21d2 (9\u2663 7\u2660 Q\u2660 4\u2665 8\u2660 3\u2660 7\u2666 A\u2660 A\u2665 K\u2660)\n(cartas 5) ; \u21d2 (7\u2663 3\u2663 6\u2663 7\u2660 5\u2663)\n</code></pre> <p>Como m\u00e1ximo puedes poner como par\u00e1metro 48 para generar aleatoriamente las 48 cartas de una baraja francesa sin dieces.</p> <p>La funci\u00f3n <code>cartas</code> no cumple el paradigma funcional</p> <p>La funci\u00f3n <code>cartas</code> es una funci\u00f3n que devuelve una lista aleatoria de cartas. No cumple el paradigma funcional porque devuelve valores distintos cuando se llama con los mismos par\u00e1metros.</p> <p>a) Define una funci\u00f3n <code>(coloca tres-listas un dos tres)</code> que recibe una listas con tres listas y tres elementos y devuelva el resultado de colocar los elementos en la cabeza de las tres listas.</p> <p>Ejemplo:</p> <pre><code>(coloca '(() () ()) 'a 'b 'c) ; \u21d2 '((a) (b) (c))\n(coloca '((a) (a) (a)) 'b 'b 'b) ; \u21d2 '((b a) (b a) (b a))\n(coloca '((a) (b c) (d e f)) 'g 'h 'i) ; \u21d2 '((g a) (h b c) (i d e f)))\n</code></pre> <p>b) Usando la funci\u00f3n anterior como funci\u00f3n auxiliar implementa una funci\u00f3n recursiva <code>(reparte-tres lista-cartas)</code> que recibe una lista de cartas con un n\u00famero de cartas m\u00faltiplo de 3 y devuelve el resultado de repartir esas cartas una a una en tres montones. Las cartas en las posiciones 0, 3, 6, etc. ir\u00e1n en un mont\u00f3n. Las cartas en las posiciones 1, 4, 7, etc. ir\u00e1n en el segundo mont\u00f3n. Y las cartas en las posiciones 2, 5, 8, etc. ir\u00e1n en el tercero.</p> <p>El resultado ser\u00e1 una lista con tres listas representando esos tres montones de cartas.</p> <p>Ejemplo:</p> <pre><code>(define doce-cartas '(A\u2663 2\u2663 3\u2663 4\u2663 5\u2663 6\u2663 7\u2663 8\u2663 9\u2663 J\u2663 Q\u2663 K\u2663))\n(reparte-tres doce-cartas) ; \u21d2 '((A\u2663 4\u2663 7\u2663 J\u2663) (2\u2663 5\u2663 8\u2663 Q\u2663) (3\u2663 6\u2663 9\u2663 K\u2663))\n</code></pre> <p>c) Implementa una funci\u00f3n recursiva <code>(elemento-central lista)</code> que reciba una lista con un n\u00famero impar de elementos (mayor o igual que uno) y devuelva su elemento central.</p> <p>Pista</p> <p>Supongamos que defines una funci\u00f3n recursiva auxiliar <code>(quita-ultimo lista)</code> que devuelve una lista sin el \u00faltimo elemento.</p> <p>\u00bfPodr\u00edas usar esta funci\u00f3n para pasarle un caso m\u00e1s sencillo a la llamada recursiva y que sea la llamada recursiva la que devuelva el elemento central? </p> <p>Ejemplo:</p> <pre><code>(elemento-central '(a b c d e f g)) ; \u21d2 d\n</code></pre> <p>d) Una vez que has implementado las funciones anteriores ya solo te queda copiar las siguientes definiciones para poder hacer el truco de cartas. Son funciones que recomponen la baraja a partir de los tres montones dependiendo de si la carta elegida est\u00e1 en el mont\u00f3n de la izquierda, del centro o de la derecha.</p> <p>Y la funci\u00f3n <code>adivina</code> es la que devuelve la carta elegida en el truco.</p> <pre><code>(define (izquierda tres-listas)\n  (append (third tres-listas)\n          (first tres-listas)\n          (second tres-listas)))\n\n(define (centro tres-listas)\n  (append (third tres-listas)\n          (second tres-listas)\n          (first tres-listas)))\n\n(define (derecha tres-listas)\n  (append (second tres-listas)\n          (third tres-listas)\n          (first tres-listas)))\n\n(define (adivina lista)\n  (elemento-central lista))\n</code></pre> <p>Por \u00faltimo, antes de empezar el truco, un par de consideraciones sobre los programas con n\u00fameros aleatorios.</p> <p>La siguiente funci\u00f3n, con la constante 90 como argumento, genera siempre la secuencia aleatoria que permite seguir el ejemplo. Si se cambia por otra constante, la secuencia tambi\u00e9n se reperir\u00e1 siempre aunque ser\u00e1 otra. Tener siempre la misma secuencia aleatoria permite poder depurar la programaci\u00f3n trabajando siempre con el mismo ejemplo aleatorio.</p> <p><pre><code>(random-seed 90)\n</code></pre> Si en lugar de una constante se usa un valor variable, se obtiene una secuencia aleatoria distinta cada vez que se ejecute el programa. </p> <p>Ejemplo:</p> <pre><code>(random-seed (modulo (current-milliseconds) (expt 2 31)))\n</code></pre> <p>Y ahora ya podemos empezar el truco de cartas.</p> <ol> <li> <p>Repartimos una lista de cartas y las guardamos en la variable <code>t1</code>. Podr\u00edamos jugar con 3, 9, 15, 21 o 27 cartas. Vamos a hacerlo con 27:</p> <pre><code>(define t1 (reparte-tres (cartas 27)))\n</code></pre> </li> <li> <p>Visualizamos los montones y pedimos al espectador que piense en una carta sin decirla. Por ejemplo el as de tr\u00e9boles.</p> <pre><code>t1 ; \u21d2 ((J\u2663 8\u2666 K\u2665 J\u2660 2\u2660 8\u2665 Q\u2663 4\u2666 A\u2665) (5\u2665 9\u2663 5\u2666 Q\u2660 A\u2666 9\u2665 5\u2660 9\u2666 Q\u2666) (7\u2663 3\u2660 6\u2665 6\u2663 7\u2665 3\u2663 4\u2663 A\u2663 J\u2665))\n</code></pre> </li> <li> <p>Preguntamos al espectador en qu\u00e9 mont\u00f3n est\u00e1 la carta    pensada. Juntamos los montones usando la funci\u00f3n correspondiente a    lugar del mont\u00f3n (<code>izquierda</code>, <code>derecha</code> o <code>centro</code>). En este caso    el as de tr\u00e9boles est\u00e1 en el mont\u00f3n derecho, por lo que usamos la    funci\u00f3n <code>derecha</code>. Y volvemos a repartir en tres montones el mazo    resultante. Los guardamos en la variable <code>t2</code>:</p> <pre><code>(define t2 (reparte-tres (derecha t1)))\n</code></pre> </li> <li> <p>Visualizamos de nuevo los montones y preguntamos d\u00f3nde est\u00e1 la    carta. En este caso se encuentra en el centro.</p> <pre><code>t2 ; \u21d2  ((5\u2665 Q\u2660 5\u2660 7\u2663 6\u2663 4\u2663 J\u2663 J\u2660 Q\u2663) (9\u2663 A\u2666 9\u2666 3\u2660 7\u2665 A\u2663 8\u2666 2\u2660 4\u2666) (5\u2666 9\u2665 Q\u2666 6\u2665 3\u2663 J\u2665 K\u2665 8\u2665 A\u2665))\n</code></pre> <p>Juntamos usando la funci\u00f3n <code>centro</code> y volvemos a repartir, guardando el resultado en la variable <code>t3</code>:</p> <pre><code>(define t3 (reparte-tres (centro t2)))\n</code></pre> </li> <li> <p>Visualizamos los montones:</p> <pre><code>t3 ; \u21d2  ((5\u2666 6\u2665 K\u2665 9\u2663 3\u2660 8\u2666 5\u2665 7\u2663 J\u2663) (9\u2665 3\u2663 8\u2665 A\u2666 7\u2665 2\u2660 Q\u2660 6\u2663 J\u2660) (Q\u2666 J\u2665 A\u2665 9\u2666 A\u2663 4\u2666 5\u2660 4\u2663 Q\u2663))\n</code></pre> <p>Y preguntamos d\u00f3nde se encuentra la carta. En este caso el as de tr\u00e9bol se encuentra en el mont\u00f3n de la derecha. Volvemos a juntar los montones usando entonces la funci\u00f3n <code>derecha</code> y ya podemos llamar a la funci\u00f3n <code>adivina</code> con la baraja resultante. Esta funci\u00f3n devolver\u00e1 m\u00e1gicamente la carta escogida:</p> <pre><code>(adivina (derecha t3)) ; \u21d2 A\u2663\n</code></pre> </li> </ol> <p>Lenguajes y Paradigmas de Programaci\u00f3n, curso 2024-25 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Domingo Gallardo, Cristina Pomares, Antonio Bot\u00eda, Francisco Mart\u00ednez</p>"},{"location":"practicas/practica05/practica05.html","title":"Pr\u00e1ctica 5: Funciones como datos de primera clase y funciones de orden superior","text":""},{"location":"practicas/practica05/practica05.html#antes-de-la-clase-de-practicas","title":"Antes de la clase de pr\u00e1cticas","text":"<ul> <li> <p>Antes de empezar esta pr\u00e1ctica es importante que revises la soluci\u00f3n   de la pr\u00e1ctica 4. Puedes preguntar las dudas al profesor de pr\u00e1cticas.</p> </li> <li> <p>Los siguientes ejercicios est\u00e1n basados en los conceptos de teor\u00eda vistos la semana pasada. Antes de la clase de pr\u00e1cticas debes repasar todos los conceptos y probar en el DrRacket todos los ejemplos de los siguientes apartados del tema 2 Programaci\u00f3n Funcional:</p> <ul> <li>5.4. Generalizaci\u00f3n. </li> <li>5.5. Funciones que devuelven otras funciones. </li> <li>5.6. Funciones en estructuras de datos. </li> <li>5.7. Funciones de orden superior.</li> </ul> </li> </ul>"},{"location":"practicas/practica05/practica05.html#ejercicios","title":"Ejercicios","text":"<p>Descarga el fichero <code>lpp.rkt</code>, pulsando el bot\u00f3n derecho del rat\u00f3n y seleccionando la opci\u00f3n Guardar como <code>lpp.rkt</code>. Gu\u00e1rdalo en la misma carpeta en la que tengas el fichero <code>practica5.rkt</code>.</p> <p>El fichero contiene la definici\u00f3n de las funciones de orden superior <code>exists?</code> y <code>for-all?</code>.</p>"},{"location":"practicas/practica05/practica05.html#ejercicio-1","title":"Ejercicio 1","text":"<p>a) Define la funci\u00f3n recursiva <code>(aplica-veces f1 f2 n x)</code> que aplica <code>n</code> veces las funciones <code>f2</code> y <code>f1</code> al n\u00famero <code>x</code>. </p> <p>Por ejemplo, <code>(aplica-veces doble suma-2 3 5)</code> deber\u00e1 devolver el resultado de sumarle 2 a 5 (7), despu\u00e9s calcular el doble (14), despu\u00e9s sumarle otra vez 2 al resultado (16), volver a calcular su doble (32) y, por \u00faltimo, sumarle 2 al resultado (34) y calcular su doble. Esto es, aplica 3 veces las funciones <code>suma-2</code> y <code>doble</code> tomando como n\u00famero inicial el 5. El resultado ser\u00e1 68.</p> <p>Ejemplos:</p> <pre><code>(aplica-veces (lambda (x) (+ x 1)) (lambda (x) (+ x 2)) 2 10) ; \u21d2 16\n(aplica-veces (lambda (x) (* x x)) (lambda (x) (+ x 1)) 4 3) ; \u21d2 7072978201\n</code></pre> <p>b) Implementa la funci\u00f3n recursiva <code>(mueve-al-principio-condicion pred lista)</code> que recibe un predicado y una lista. La funci\u00f3n es una generalizaci\u00f3n de la funci\u00f3n de la pr\u00e1ctica anterior y debe devolver la lista resultante de mover la primera aparici\u00f3n del dato que cumpla el predicado al comienzo de la lista, dejando el resto de la lista sin modificar.</p> <p>A diferencia de la pr\u00e1ctica anterior, en la lista puede no haber ning\u00fan elemento que cumpla el predicado. En ese caso se devolver\u00e1 la lista original.</p> <p>Ejemplos:</p> <pre><code>(mueve-al-principio-condicion number? '(a b c 1 d 1 e) ; \u21d2 (1 a b c d 1 e)\n(mueve-al-principio-condicion number? '(1 a b 1 c)) ; \u21d2 (1 a b 1 c)\n(mueve-al-principio-condicion number? '(a b c d)) ; \u21d2 (a b c d)\n</code></pre> <p>Pista</p> <p>El hecho de que se permita que no haya ning\u00fan elemento que cumpla el predicado obliga a cambiar bastante la soluci\u00f3n de la pr\u00e1ctica anterior. </p> <p>F\u00edjate por ejemplo en la funci\u00f3n <code>(inserta-en-segunda-posicion dato lista)</code> de la soluci\u00f3n. En el caso en que no haya en la lista ning\u00fan elemento que cumpla la condici\u00f3n esta funci\u00f3n deber\u00e1 a\u00f1adir en cabeza el dato, en lugar de insertarlo en segunda posici\u00f3n. De hecho, podr\u00edamos cambiar el nombre de la funci\u00f3n auxiliar y llamarla <code>inserta-segundo-cond</code> o algo as\u00ed.</p> <p>c) Vamos a generalizar la funci\u00f3n de la pr\u00e1ctica anterior <code>(comprueba-simbolos)</code> llam\u00e1ndola <code>(comprueba pred lista1 lista2)</code> y pas\u00e1ndole como par\u00e1metro un predicado de comparaci\u00f3n. La funci\u00f3n ahora podr\u00e1 procesar cualquier tipo de listas (de s\u00edmbolos, de cadenas, de listas, etc.). La funci\u00f3n pasada como par\u00e1metro se encarga de comparar si el elemento de la primera lista cumple la condici\u00f3n con el elemento de la segunda.</p> <p>Implementa la funci\u00f3n <code>(comprueba pred lista1 lista2)</code>.</p> <p>Ejemplo:</p> <pre><code>(comprueba (lambda (x y)\n             (= (string-length (symbol-&gt;string x)) y))\n           '(este es un ejercicio de examen) \n           '(2 1 2 9 1 6))\n; \u21d2 ((un . 2) (ejercicio . 9) (examen . 6))\n\n(comprueba (lambda (x y)\n              (= (string-length x) (string-length y)))\n             '(\"aui\" \"a\" \"ae\" \"c\" \"aeiou\")\n             '(\"hola\" \"b\" \"es\" \"que\" \"cinco\"))\n; \u21d2 ((\"a\" . \"b\") (\"ae\" . \"es\") (\"aeiou\" . \"cinco\"))\n</code></pre>"},{"location":"practicas/practica05/practica05.html#ejercicio-2","title":"Ejercicio 2","text":"<p>Queremos ordenar de menor a mayor una lista que contenga cualquier tipo de elemento, no solo n\u00fameros. Para ello vamos a generalizar el ejercicio 2 de la pr\u00e1ctica anterior, a\u00f1adiendo un par\u00e1metro adicional (un predicado), al que llamaremos <code>menor-igual?</code>.</p> <p>a) Generaliza las funciones <code>inserta-ordenada</code> y <code>ordena</code> a\u00f1adi\u00e9ndoles este par\u00e1metro adicional que es un predicado que comprueba si un dato de los que componen la lista es menor o igual que otro. Llama a las funciones resultantes <code>inserta-ordenada-gen\u00e9rica</code> y <code>ordena-gen\u00e9rica</code>.</p> <pre><code>(ordena-generica '(3 5 1) &lt;=) ;=&gt; (1 3 5)\n</code></pre> <p>b) Completa las siguientes tres pruebas. En la primera deber\u00e1s ordenar una lista de cadenas por su longitud, en la segunda la lista de cadenas por su orden lexicogr\u00e1fico y en la tercera deber\u00e1s ordenar una lista de parejas de n\u00fameros por la suma de su parte izquierda y su parte derecha:</p> <pre><code>(check-equal? (ordena-generica '(\"Hola\" \"me\" \"llamo\" \"I\u00f1igo\" \"Montoya\") ________ ) '(\"me\" \"Hola\" \"llamo\" \"I\u00f1igo\" \"Montoya\"))\n(check-equal? (ordena-generica '(\"Hola\" \"me\" \"llamo\" \"I\u00f1igo\" \"Montoya\") ________ ) '(\"Hola\" \"I\u00f1igo\" \"Montoya\" \"llamo\" \"me\"))\n(check-equal? (ordena-generica '((2 . 2) (1 . 1) (3 . 0) (5 . 1)) ________ ) '((1 . 1) (3 . 0) (2 . 2) (5 . 1)))\n</code></pre> <p>c) Define la funci\u00f3n <code>(ordena-cartas lista-cartas)</code> que ordene una lista de cartas de menor a mayor valor usando la funci\u00f3n anterior <code>ordena-generica</code>. Deber\u00e1s incluir la funci\u00f3n <code>valor-carta</code> y sus funciones auxiliares definidas en pr\u00e1cticas anteriores.</p> <p>Ejemplo:</p> <pre><code>(ordena-cartas '(Q\u2660 J\u2663 5\u2663 Q\u2665 J\u2666)) ; \u21d2 (5\u2663 J\u2663 J\u2666 Q\u2660 Q\u2665)\n</code></pre>"},{"location":"practicas/practica05/practica05.html#ejercicio-3","title":"Ejercicio 3","text":"<p>a) Indica qu\u00e9 devuelven las siguientes expresiones, sin utilizar el int\u00e9rprete. Comprueba despu\u00e9s si has acertado.</p> <pre><code>(map (lambda (x)\n         (cond \n            ((symbol? x) (symbol-&gt;string x))\n            ((number? x) (number-&gt;string x))\n            ((boolean? x) (if x \"#t\" \"#f\"))\n            (else \"desconocido\"))) '(1 #t hola #f (1 . 2))) ; \u21d2 ?\n\n(filter (lambda (x) \n            (equal? (string-ref (symbol-&gt;string x) 1) #\\a)) \n    '(alicante barcelona madrid almer\u00eda)) ; \u21d2 ?\n\n(foldr (lambda (dato resultado)\n          (string-append dato \"*\" resultado)) \"\" \n          '(\"Hola\" \"que\" \"tal\")) ; \u21d2 ?\n\n(foldr append '() '((1 2) (3 4 5) (6 7) (8))) ; \u21d2 ?\n\n(foldl (lambda (dato resultado)\n         (string-append\n          (symbol-&gt;string (car dato))\n          (symbol-&gt;string (cdr dato))\n          resultado)) \"\" '((a . b) (hola . adios) (una . pareja))) ; \u21d2 ?\n\n(foldr (lambda (dato resultado)\n           (cons (+ (car resultado) dato)\n                 (+ (cdr resultado) 1))) '(0 . 0) '(1 1 2 2 3 3)) ; \u21d2 ?\n\n(apply + (map cdr '((1 . 3) (2 . 8) (2 . 4)))) ; \u21d2 ?\n\n(apply min (map car (filter (lambda (p)\n                                  (&gt; (car p) (cdr p))) \n                                  '((3 . 1) (1 . 20) (5 . 2))))) ; \u21d2 ?\n</code></pre> <p>b) Sin utilizar el int\u00e9rprete DrRacket, rellena los siguientes huecos para obtener el resultado esperado. Despu\u00e9s usa el int\u00e9rprete para comprobar si has acertado.</p> <pre><code>; Los siguientes ejercicios utilizan esta definici\u00f3n de lista\n\n(define lista '((2 . 7) (3 . 5) (10 . 4) (5 . 5)))\n\n\n; Queremos obtener una lista donde cada n\u00famero es la suma de las\n; parejas que son pares\n\n(filter ________\n        (________ (lambda (x) (+ (car x)\n                                 (cdr x)))\n               lista))\n; \u21d2 (8 14 10)\n\n; Queremos obtener una lista de parejas invertidas donde la \"nueva\"\n; parte izquierda es mayor que la derecha.\n\n(filter ___________\n        (map ____________ lista))\n; \u21d2 ((7 . 2) (5 . 3))\n\n; Queremos obtener una lista cuyos elementos son las partes izquierda\n; de aquellas parejas cuya suma sea par.\n\n(foldr __________ '()\n        (_________ (lambda (x) (even? (+ (car x) (cdr x)))) lista))\n; \u21d2 (3 10 5)\n</code></pre> <p>c) Rellena los siguientes huecos con una \u00fanica expresi\u00f3n en la que se utilice alguna funci\u00f3n previamente definida (<code>f</code> o <code>g</code>). Comprueba con el int\u00e9rprete si lo has hecho correctamente.</p> <pre><code>(define (f1 x) (lambda (y z) (string-append y z x)))\n(define g1 (f1 \"a\"))\n(check-equal? ____________________ \"claselppa\")\n\n\n\n(define (f2 x) (lambda (y z) (list y x z)))\n_____________\n(check-equal? (g2 \"hola\" \"clase\") (list \"hola\" \"lpp\" \"clase\"))\n\n\n(define (f3 g3) (lambda(z x) (g3 z x)))\n(check-equal? _____________________  '(3 . 4))\n</code></pre>"},{"location":"practicas/practica05/practica05.html#ejercicio-4","title":"Ejercicio 4","text":"<p>a) Implementa utilizando funciones de orden superior la funci\u00f3n <code>(contar-datos-iguales-fos lista-parejas)</code> que recibe una lista de parejas y devuelve el n\u00famero de parejas que tienen sus dos datos iguales.</p> <pre><code>(contar-datos-iguales-fos \n   '((2 . 3) (\"hola\" . \"hola\") (\\#a . \\#a) (true . false))) \n; \u21d2 2\n(contar-datos-iguales-fos \n   '((2 . \"hola\") (\"hola\" . 3) (\\#a . true) (\\#b . false))) \n; \u21d2 0\n</code></pre> <p>b) Implementa, utilizando funciones de orden superior, la funci\u00f3n <code>(expande-lista-fos lista-parejas)</code>, que hace lo mismo que la funci\u00f3n <code>(expande-lista lista-parejas)</code> de la pr\u00e1ctica anterior. Igual que en la pr\u00e1ctica anterior debes usar la funci\u00f3n <code>expande-pareja</code>.</p> <pre><code>(expande-lista-fos '((#t . 3) (\"LPP\" . 2) (b . 4))) \n; \u21d2 (#t #t #t \"LPP\" \"LPP\" b b b b))\n</code></pre> <p>c) Implementa, utilizando funciones de orden superior, la funci\u00f3n <code>(comprueba-simbolos-fos lista-simbolos lista-num)</code> que hace lo mismo que la funci\u00f3n <code>comprueba-simbolos</code> del ejercicio 3b) de la pr\u00e1ctica pasada.</p> <p>Ejemplo:</p> <pre><code>(comprueba-simbolos-fos '(este es un ejercicio de examen) '(2 1 2 9 1 6))\n; \u21d2 ((un . 2) (ejercicio . 9) (examen . 6))\n</code></pre>"},{"location":"practicas/practica05/practica05.html#ejercicio-5","title":"Ejercicio 5","text":"<p>a) Implementa usando funciones de orden superior la funci\u00f3n <code>(suma-n-izq n lista-parejas)</code> que recibe una lista de parejas y devuelve otra lista a la que hemos sumado <code>n</code> a todas las partes izquierdas.</p> <p>Ejemplo</p> <pre><code>(suma-n-izq 10 '((1 . 3) (0 . 9) (5 . 8) (4 . 1)))\n; \u21d2 ((11 . 3) (10 . 9) (15 . 8) (14 . 1))\n</code></pre> <p>b) Completa la definici\u00f3n de la siguiente funci\u00f3n de orden superior <code>(busca-mayor mayor? lista)</code> que busca el mayor elemento de una lista. Recibe un predicado <code>mayor?</code> que compara dos elementos de la lista y devuelve <code>#t</code> o <code>#f</code> dependiendo de si el primero es mayor que el segundo. </p> <p>Al usar un predicado como argumento, estamos definiendo una funci\u00f3n gen\u00e9rica que podemos usar para obtener el mayor elemento de listas de n\u00fameros, de cadenas, de parejas, etc. En cada caso deberemos pasar como par\u00e1metro <code>mayor?</code> la funci\u00f3n de comparaci\u00f3n apropiada.</p> <pre><code>(define (busca-mayor mayor? lista)\n  (foldl __________ (first lista) (rest lista)))\n</code></pre> <p>Pista</p> <p>F\u00edjate que como elemento base de <code>foldl</code> estamos usando el primer elemento de la lista y que el plegado lo hacemos sobre el resto de la lista.</p> <p>Escribe algunos <code>check-equal?</code> en los que compruebes el funcionamiento de <code>busca-mayor</code>, utilizando funciones <code>mayor?</code> distintas.</p> <p>c) Implementa, usando el predicado de orden superior <code>for-all?</code> dos versiones de la funci\u00f3n <code>(todos-menores? lista n)</code> que recibe una lista con sublistas de n\u00fameros y un n\u00famero <code>n</code> y comprueba si todos los n\u00fameros en las sublistas son menores que <code>n</code>.</p> <p>La primera versi\u00f3n la debes implementar usando <code>for-all?</code> y la funci\u00f3n <code>busca-mayor</code> definida en el apartado anterior y la segunda usando <code>for-all?</code> y la funci\u00f3n de orden superior <code>exists?</code>.</p> <p>Ejemplo:</p> <pre><code>(todos-menores? '((10 30 20) (1 50 30) (30 40 90)) 100) ; \u21d2 #t\n(todos-menores? '((10 30 20) (1 50 30) (30 40 90)) 90) ; \u21d2 #f\n(todos-menores? '((10 30 20) (1 50 30) (30 40 90)) 55) ; \u21d2 #f\n</code></pre>"},{"location":"practicas/practica05/practica05.html#ejercicio-6","title":"Ejercicio 6","text":"<p>Vamos a mejorar el juego de cartas de la semana anterior, usando la baraja completa y dando m\u00e1s libertad al reparto de cartas en montones, haciendo m\u00e1s inveros\u00edmil todav\u00eda la adivinaci\u00f3n de la carta elegida.</p> <p>Usamos la funci\u00f3n <code>(cartas num-cartas)</code> del fichero <code>lpp.rkt</code> y la funci\u00f3n <code>(reparte-tres lista-cartas)</code> definida en la pr\u00e1ctica anterior.</p> <p>Usa funciones de orden superior</p> <p>Para la implementaci\u00f3n de las siguientes funciones deber\u00e1s usar, siempre que sea posible, funciones de orden superior en lugar de funciones recursivas.</p> <p>a) Define una nueva versi\u00f3n de la funci\u00f3n <code>coloca</code> usando n\u00famero variable de argumentos. La nueva versi\u00f3n de la funci\u00f3n <code>(coloca ...)</code> solo tiene como obligatorio el primer argumento, la lista de n listas. El resto de argumentos es opcional y puede ir de 0 a n elementos.</p> <p>Se asume que la lista de n listas debe tener tantas listas como elementos se pasen como argumentos, y si no se pasa ning\u00fan argumento se devuelve por convenio la lista de n listas tal cual, sin variar.</p> <p>Ejemplo:</p> <pre><code>(coloca '(() () ()) 'a 'b 'c)) ; \u21d2 ((a) (b) (c))\n(coloca '((a) (a)) 'b 'b)) ; \u21d2 ((b a) (b a))\n(coloca '((a b c d)) 'e) ; \u21d2 ((e a b c d))\n(coloca '()) ; \u21d2 '()\n(coloca '((a) (b c) (d e f) (g h i j)) 'k 'l 'm 'n)) ; \u21d2 ((k a) (l b c) (m d e f) (n g h i j))\n</code></pre> <p>Implementa una funci\u00f3n <code>reparte-cuatro</code> inspirada en <code>reparte-tres</code> y con id\u00e9ntica estructura.</p> <pre><code>(reparte-cuatro '(A\u2663 2\u2663 3\u2663 4\u2663 5\u2663 6\u2663 7\u2663 8\u2663 9\u2663 J\u2663 Q\u2663 K\u2663)) ; \u21d2 '((A\u2663 5\u2663 9\u2663) (2\u2663 6\u2663 J\u2663) (3\u2663 7\u2663 Q\u2663) (4\u2663 8\u2663 K\u2663))\n</code></pre> <p>b) Implementa la funci\u00f3n <code>(escoge-en-orden lista funcion_ordinal_1 ... funci\u00f3n_ordinal_n)</code> que aplica a un primer argumento obligatorio <code>lista</code> la serie de funciones \"ordinales\" (<code>first</code>, <code>second</code>, <code>third</code> ... <code>tenth</code>) pasadas a continuaci\u00f3n de la lista como un n\u00famero variable de argumentos, devolviendo la lista de resultados de aplicar esas funciones en el orden en que se han proporcionado.</p> <pre><code>(escoge-en-orden '(1 2 3 4 5)) ; \u21d2  '()\n(escoge-en-orden '(1 2 3 4 5) fourth second) ; \u21d2 (4 2)\n(escoge-en-orden '(a b c d) third second fourth first) ; \u21d2 (c b d a)\n(escoge-en-orden '(dos tres un) third first second) ; \u21d2 (un dos tres)\n</code></pre> <p>Usando las funciones definidas anteriormente, implementa las funciones <code>(reordena-tres-montones baraja f-ordinal1 f-ordinal2 f-ordinal3)</code> y <code>(reordena-cuatro-montones baraja f-ordinal1 f-ordinal2 f-ordinal3 f-ordinal4)</code> que reparten las cartas de una supuesta baraja (lista de cartas) en tres o cuatro montones (lista de sublistas de cartas) y despu\u00e9s reordena los montones, o sublistas, seg\u00fan el orden establecido por las funciones \"ordinales\" pasadas como argumentos a continuaci\u00f3n de la baraja.</p> <pre><code>(reordena-tres-montones  '(A\u2663 2\u2663 3\u2663 4\u2663 5\u2663 6\u2663 7\u2663 8\u2663 9\u2663 J\u2663 Q\u2663 K\u2663) second first third)\n; \u21d2\n; ((2\u2663 5\u2663 8\u2663 Q\u2663) (A\u2663 4\u2663 7\u2663 J\u2663) (3\u2663 6\u2663 9\u2663 K\u2663))\n\n(reordena-cuatro-montones  '(A\u2663 2\u2663 3\u2663 4\u2663 5\u2663 6\u2663 7\u2663 8\u2663 9\u2663 J\u2663 Q\u2663 K\u2663) fourth second first third)\n; \u21d2\n; ((4\u2663 8\u2663 K\u2663) (2\u2663 6\u2663 J\u2663) (A\u2663 5\u2663 9\u2663) (3\u2663 7\u2663 Q\u2663))\n</code></pre> <p>c) Implementa la funci\u00f3n <code>(junta-montones montones)</code> concatena la lista de sublistas de cartas (montones) en una sola lista de cartas.</p> <pre><code>(junta-montones '((4\u2663 8\u2663 K\u2663) (2\u2663 6\u2663 J\u2663) (A\u2663 5\u2663 9\u2663) (3\u2663 7\u2663 Q\u2663)))\n; \u21d2\n; (4\u2663 8\u2663 K\u2663 2\u2663 6\u2663 J\u2663 A\u2663 5\u2663 9\u2663 3\u2663 7\u2663 Q\u2663)\n</code></pre> <p>d) Una vez que has implementado las funciones anteriores ya solo te queda copiar la siguiente definici\u00f3n para poder hacer el truco de cartas. </p> <p>La funci\u00f3n <code>(adivina lista-cartas par1 par2 par3)</code> es la que hace toda la magia y calcula la posici\u00f3n de la carta escogida a partir de las posiciones de los montones en los que \u00e9sta ha aparecido en tres reparticiones de la baraja.</p> <pre><code>(define (adivina baraja par1 par2 par3)\n  (list-ref baraja\n            (+ (* (- (car par3) 1) (cdr par2) (cdr par1))\n               (* (- (car par2) 1) (cdr par1))\n               (- (car par1) 1))))\n</code></pre> <p>Cada pareja codifica en su parte derecha el n\u00famero de montones en los que se ha repartido la baraja y en su parte izquierda el mont\u00f3n en el que el espectador ha visto la carta. Por ejemplo, la pareja <code>(2 . 4)</code> representa que la baraja se ha repartido en 4 montones y que la carta escogida est\u00e1 en el segundo mont\u00f3n.</p> <p>Lo curioso de la funci\u00f3n de adivinaci\u00f3n es que funciona correctamente siempre que se haya repartido la baraja dos veces en cuatro montones y una en tres (las partes derechas de las tres parejas deben sumar 11).</p> <p>Veamos un ejemplo de realizaci\u00f3n del juego, tal y como ya hicimos en la pr\u00e1ctica pasada.</p> <p>La siguiente funci\u00f3n, con la constante 90 como argumento, genera siempre la secuencia aleatoria que permite seguir el ejemplo. Si se cambia por otra constante, la secuencia tambi\u00e9n se reperir\u00e1 siempre aunque ser\u00e1 otra. Tener siempre la misma secuencia aleatoria permite poder depurar la programaci\u00f3n trabajando siempre con el mismo ejemplo aleatorio.</p> <p><pre><code>(random-seed 90)\n</code></pre> Si en lugar de una constante se usa un valor variable, se obtiene una secuencia aleatoria distinta cada vez que se ejecute el programa. </p> <p>Ejemplo:</p> <pre><code>(random-seed (modulo (current-milliseconds) (expt 2 31)))\n</code></pre> <ol> <li> <p>Repartimos una lista de 48 cartas en cuatro montones. Pedimos a un espectador    que nos diga en qu\u00e9 orden colocamos los montones, poniendo, por ejemplo,    primero el primero, despu\u00e9s el cuarto, despu\u00e9s el segundo y despu\u00e9s el tercero:</p> <pre><code>(define t1 (reordena-cuatro-montones (cartas 48) first fourth second third))\n</code></pre> </li> <li> <p>Visualizamos los montones y pedimos al espectador que piense en una carta sin decirla. Por ejemplo el as de tr\u00e9boles. </p> <pre><code>t1 ; \u21d2 ((K\u2666 3\u2666 6\u2660 6\u2666 3\u2665 K\u2663 8\u2666 5\u2666 6\u2663 8\u2665 5\u2660 A\u2663)\n   ;   (8\u2660 8\u2663 9\u2660 7\u2660 2\u2663 7\u2663 K\u2665 Q\u2660 7\u2665 Q\u2663 9\u2666 J\u2665)\n   ;   (4\u2660 2\u2665 K\u2660 Q\u2665 7\u2666 J\u2663 9\u2663 6\u2665 2\u2660 9\u2665 4\u2663 A\u2665)\n   ;   (5\u2663 2\u2666 J\u2666 4\u2665 A\u2660 5\u2665 3\u2660 J\u2660 A\u2666 3\u2663 4\u2666 Q\u2666))\n</code></pre> </li> <li> <p>Preguntamos al espectador en qu\u00e9 mont\u00f3n se encuentra la carta. Anotamos en la parte izquierda de <code>p1</code> el mont\u00f3n en el que est\u00e1 (mont\u00f3n 1), y la parte derecha el n\u00famero de montones (4).</p> <pre><code>(define p1 '(1 . 4))\np1\n</code></pre> </li> <li> <p>Repetimos la operaci\u00f3n con <code>t2</code>, pero ahora repartiendo en tres montones nada m\u00e1s. Podemos pedir a otro espectador que nos diga el orden en el que se colocan los montones. Por ejemplo, primero el segundo, despu\u00e9s el tercero y despu\u00e9s el primero.</p> <pre><code>(define t2 (reordena-tres-montones (junta-montones t1) second third first))\n</code></pre> </li> <li> <p>Visualizamos <code>t2</code> y determinamos la pareja seg\u00fan donde est\u00e1 el as de tr\u00e9bol:</p> <pre><code>t2 ; \u21d2 ((3\u2666 3\u2665 5\u2666 5\u2660 8\u2663 2\u2663 Q\u2660 9\u2666 2\u2665 7\u2666 6\u2665 4\u2663 2\u2666 A\u2660 J\u2660 4\u2666)\n   ;    (6\u2660 K\u2663 6\u2663 A\u2663 9\u2660 7\u2663 7\u2665 J\u2665 K\u2660 J\u2663 2\u2660 A\u2665 J\u2666 5\u2665 A\u2666 Q\u2666)\n   ;    (K\u2666 6\u2666 8\u2666 8\u2665 8\u2660 7\u2660 K\u2665 Q\u2663 4\u2660 Q\u2665 9\u2663 9\u2665 5\u2663 4\u2665 3\u2660 3\u2663))\n   ;En este caso (2 . 3) (el mont\u00f3n 2 de 3)\n(define p2 '(2 . 3))\np2\n</code></pre> </li> <li> <p>Repetimos una \u00faltima vez el reparto y ordenaci\u00f3n de montones, pero con 4. Hay que hacer tres repartos, uno de 3 montones y los otros dos de 4, pero no necesariamente en el orden en el que se ha hecho (4-3-4). Se pod\u00eda haber hecho primero el reparto en tres montones, o haberlo dejado para el final. </p> <pre><code>(define t3 (reordena-cuatro-montones (junta-montones t2) fourth second first third))\n</code></pre> </li> <li> <p>Visualizamos <code>t3</code> y definimos la pareja <code>p3</code> seg\u00fan el mont\u00f3n del as de tr\u00e9bol: </p> <pre><code>t3 ; \u21d2 ((5\u2660 9\u2666 4\u2663 4\u2666 A\u2663 J\u2665 A\u2665 Q\u2666 8\u2665 Q\u2663 9\u2665 3\u2663)\n   ;    (5\u2666 Q\u2660 6\u2665 J\u2660 6\u2663 7\u2665 2\u2660 A\u2666 8\u2666 K\u2665 9\u2663 3\u2660)\n   ;    (3\u2666 8\u2663 2\u2665 2\u2666 6\u2660 9\u2660 K\u2660 J\u2666 K\u2666 8\u2660 4\u2660 5\u2663)\n   ;    (3\u2665 2\u2663 7\u2666 A\u2660 K\u2663 7\u2663 J\u2663 5\u2665 6\u2666 7\u2660 Q\u2665 4\u2665))\n   ;Esta vez es (1 . 4)\n(define p3 '(1 . 4))\np3\n</code></pre> </li> <li> <p>Ya tenemos las tres parejas m\u00e1gicas que nos adivian la carta:</p> <pre><code>(adivina (junta-montones t3) p1 p2 p3) ; \u21d2 A\u2663\n</code></pre> </li> </ol> <p>Lenguajes y Paradigmas de Programaci\u00f3n, curso 2024-25 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Domingo Gallardo, Cristina Pomares, Antonio Bot\u00eda, Francisco Mart\u00ednez</p>"},{"location":"practicas/practica06/practica06.html","title":"Pr\u00e1ctica 6: Procedimientos recursivos e iterativos","text":""},{"location":"practicas/practica06/practica06.html#antes-de-la-clase-de-practicas","title":"Antes de la clase de pr\u00e1cticas","text":"<ul> <li> <p>Los siguientes ejercicios est\u00e1n basados en los conceptos de teor\u00eda vistos la semana pasada. Antes de la clase de pr\u00e1cticas debes repasar todos los conceptos y probar en el DrRacket todos los ejemplos de los siguientes apartados del tema 3 Procedimientos recursivos:</p> <ul> <li>1 El coste de la recursi\u00f3n</li> <li>2 Procesos iterativos</li> <li>3 Memoization</li> <li>4 Figuras recursivas</li> </ul> </li> </ul>"},{"location":"practicas/practica06/practica06.html#ejercicios","title":"Ejercicios","text":"<p>Descarga el fichero <code>lpp.rkt</code>, pulsando el bot\u00f3n derecho del rat\u00f3n y seleccionando la opci\u00f3n Guardar como <code>lpp.rkt</code>. Gu\u00e1rdalo en la misma carpeta en la que tengas el fichero <code>practica6.rkt</code>.</p> <p>El fichero contiene la definici\u00f3n de las funciones <code>(make-dic)</code>, <code>(put key value dic)</code>, <code>(get key dic)</code> y <code>(key-exists? key)</code> necesarias para realizar una implementaci\u00f3n de un algoritmo recursivo con memoization y que necesitar\u00e1s en el ejercicio 4.</p>"},{"location":"practicas/practica06/practica06.html#ejercicio-1","title":"Ejercicio 1","text":"<p>a) Implementa una versi\u00f3n recursiva iterativa de la funci\u00f3n <code>(concat lista)</code> que toma como argumento una lista de cadenas y devuelve una cadena resultante de concatenar todas las palabras de la lista.</p> <p>La funci\u00f3n <code>concat</code> deber\u00e1 llamar a la funci\u00f3n <code>concat-iter</code> que es la que implementa propiamente la versi\u00f3n iterativa usando recursi\u00f3n por la cola.</p> <p>Ejemplo:</p> <pre><code>(concat  '(\"hola\" \"y\" \"adi\u00f3s\")) ; \u21d2 \"holayadi\u00f3s\"\n(concat-iter '(\"hola\" \"y\" \"adi\u00f3s\") \"\") ; \u21d2 \"holayadi\u00f3s\"\n</code></pre> <p>b) Define utilizando recursi\u00f3n por la cola la funci\u00f3n <code>(min-max lista)</code> que recibe una lista num\u00e9rica y devuelve una pareja con el m\u00ednimo y el m\u00e1ximo de sus elementos. La lista recibida como par\u00e1metro tendr\u00e1 como m\u00ednimo un elemento.</p> <p>Ejemplo:</p> <pre><code>(min-max '(2 5 9 12 5 0 4)) ; \u21d2 (0 . 12)\n(min-max '(3 2 -8 4 10 0))  ; \u21d2 (-8 . 10)\n(min-max-iter '(5 9 12 -2 5 0 4) (cons 2 2)) ; \u21d2 (-2 . 12)\n</code></pre>"},{"location":"practicas/practica06/practica06.html#ejercicio-2","title":"Ejercicio 2","text":"<p>a) Implementa utilizando recursi\u00f3n por la cola las funciones <code>expande-pareja</code> y <code>expande-parejas</code> de la pr\u00e1ctica 4.</p> <p>Ejemplo:</p> <pre><code>(expande-pareja (cons 'a 4)) ; \u21d2 (a a a a)\n(expande-parejas '(#t . 3) '(\"LPP\" . 2) '(b . 4))\n; \u21d2 (#t #t #t \"LPP\" \"LPP\" b b b b)\n</code></pre> <p>b) Implementa utilizando recursi\u00f3n por la cola la funci\u00f3n <code>(rotar k lista)</code> que mueve <code>k</code> elementos de la cabeza de la lista al final. No es necesario utilizar una funci\u00f3n iterativa auxiliar, puedes hacer que la propia funci\u00f3n <code>rotar</code> sea iterativa usando el par\u00e1metro <code>lista</code> como el par\u00e1metro donde acumular el resultado.</p> <p>Ejemplo:</p> <pre><code>(rotar 4 '(a b c d e f g)) ; \u21d2 (e f g a b c d)\n</code></pre>"},{"location":"practicas/practica06/practica06.html#ejercicio-3","title":"Ejercicio 3","text":"<p>a) Implementa utilizando recursi\u00f3n por la cola la funci\u00f3n <code>mi-foldl</code> que haga lo mismo que la funci\u00f3n de orden superior <code>foldl</code>.</p> <pre><code>(mi-foldl string-append \"****\" '(\"hola\" \"que\" \"tal\")) ;\u21d2 \"talquehola****\"\n(mi-foldl cons '() '(1 2 3 4)) ; \u21d2 (4 3 2 1)\n</code></pre> <p>b) Existe un algoritmo eficiente para calcular el valor decimal de un n\u00famero binario basado en usar de forma iterativa una multiplicaci\u00f3n por 2. La idea es que si a un n\u00famero binario le a\u00f1adimos un d\u00edgito a su derecha, el valor del n\u00famero resultante es el valor del n\u00famero original multiplicado por 2 m\u00e1s el d\u00edgito que hemos a\u00f1adido.</p> <p>Por ejemplo, si tenemos el n\u00famero <code>101</code>, que es el n\u00famero decimal 5, y le a\u00f1adimos un <code>1</code> a su derecha (obteniendo el <code>1011</code>) el n\u00famero decimal resultante se obtendr\u00eda multiplicando por 2 el n\u00famero original (5*2 = 10) y sum\u00e1ndole el 1 que hemos a\u00f1adido (11).</p> <p>De esta forma, podemos calcular de forma iterativa el valor decimal de un n\u00famero binario haciendo esta operaci\u00f3n con sus d\u00edgitos de izquierda a derecha. Deber\u00edamos ir acumulando en un resultado el valor del n\u00famero procesado y, en cada nuevo paso, multiplicar por 2 ese valor y sumar el valor del nuevo d\u00edgito que estamos procesando.</p> <pre><code>resultado nuevo = resultado anterior * 2 + nuevo bit\n</code></pre> <p>Supongamos el n\u00famero binario anterior, el <code>1011</code>. Veamos una traza de c\u00f3mo se obtendr\u00eda el 11.</p> <pre><code> n\u00famero       nuevo        resultado    resultado\n procesado    bit          anterior      nuevo \n=======================================================\n                 1            0         0*2 + 1 = 1\n    1            0            1         1*2 + 0 = 2\n    10           1            2         2*2 + 1 = 5\n    101          1            5         5*2 + 1 = 11\n    1011                      11\n</code></pre> <p>Implementa, usando el algoritmo anterior iterativo, la funci\u00f3n <code>(binario-a-decimal lista-bits)</code> que reciba una lista de bits que representan un n\u00famero en binario (el primer elemento ser\u00e1 el bit m\u00e1s significativo) y devuelva el n\u00famero decimal equivalente.</p> <pre><code>(binario-a-decimal '(1 1 1 1)) ; \u21d2 15\n(binario-a-decimal '(1 1 0)) ; \u21d2 6\n(binario-a-decimal '(1 0)) ; \u21d2 2\n</code></pre>"},{"location":"practicas/practica06/practica06.html#ejercicio-4","title":"Ejercicio 4","text":"<p>Realiza una implementaci\u00f3n que utilice la t\u00e9cnica de memoization del algoritmo que devuelve la serie de Pascal.</p> <pre><code>(define diccionario (make-dic))\n(pascal-memo 8 4 diccionario) ; \u21d2 70\n(pascal-memo 40 20 diccionario) ; \u21d2 137846528820\n</code></pre>"},{"location":"practicas/practica06/practica06.html#ejercicio-5","title":"Ejercicio 5","text":"<p>a) Usando la librer\u00eda de im\u00e1genes de Racket <code>2htdp/image</code> implementa la figura recursiva conocida como curva de Koch. Debes definir una funci\u00f3n recursiva <code>(koch nivel trazo)</code> que dibuje una curva de Koch de nivel <code>nivel</code> y de longitud <code>trazo</code>.</p> <p>Como pista, f\u00edjate en el dibujo. Para construir una imagen de una curva de Koch de nivel n y longitud l, se deber\u00e1n juntar 4 curvas de Koch de nivel n-1 y longitud l/3. La primera y la \u00faltima imagen son la curva original y la segunda y tercera est\u00e1n rotadas 60 grados. F\u00edjate tambi\u00e9n en la alineaci\u00f3n de las im\u00e1genes.</p> <p>Puedes ver ejemplos de las curvas de nivel 1, 2 y 3 en las siguientes figuras: </p> <p></p> <p>b) Usando la funci\u00f3n anterior, implementa la funci\u00f3n <code>(copo-nieve nivel trazo)</code> que dibuje el copo de nieve de Koch que puedes ver en los siguientes ejemplos. Esta funci\u00f3n no es recursiva, se construye combinando tres veces la curva de Koch anterior.</p> <p></p>"},{"location":"practicas/practica06/practica06.html#ejercicio-6","title":"Ejercicio 6","text":"<p>Define la funci\u00f3n <code>(alfombra-sierpinski tam)</code> que construya la alfombra de Sierpinski (una variante del tri\u00e1ngulo de Sierpinski que hemos visto en teor\u00eda) de lado <code>tam</code> p\u00edxeles.</p> <p>En el caso base, cuando el tama\u00f1o sea menor que un umbral determinado, se debe dibujar un c\u00edrculo sin relleno de ancho <code>tam</code>. F\u00edjate que el par\u00e1metro que se le pasa a la primitiva <code>circle</code> es el del radio (lo puedes consultar aqu\u00ed), por lo que para dibujar un c\u00edrculo de ancho (di\u00e1metro) <code>tam</code> habr\u00e1 que llamar a la primitiva con el par\u00e1metro <code>tam/2</code>.</p> <p>Por ejemplo, la llamada a <code>(alfombra-sierpinski 360)</code>, poniendo como umbral 20 p\u00edxeles, debe dibujar la siguiente figura:</p> <p></p> <p>Lenguajes y Paradigmas de Programaci\u00f3n, curso 2024-25  \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Domingo Gallardo, Cristina Pomares, Antonio Bot\u00eda, Francisco Mart\u00ednez</p>"},{"location":"practicas/practica07/practica07.html","title":"Pr\u00e1ctica 7: Listas estructuradas","text":""},{"location":"practicas/practica07/practica07.html#antes-de-la-clase-de-practicas","title":"Antes de la clase de pr\u00e1cticas","text":"<ul> <li> <p>Los siguientes ejercicios est\u00e1n basados en los conceptos de teor\u00eda vistos la semana pasada. Antes de la clase de pr\u00e1cticas debes repasar todos los conceptos y probar en el DrRacket todos los ejemplos de los siguientes apartados del tema 4 Estructuras de datos recursivas</p> <ul> <li>1 Listas estructuradas</li> </ul> </li> </ul>"},{"location":"practicas/practica07/practica07.html#ejercicios","title":"Ejercicios","text":"<p>Descarga el fichero <code>lpp.rkt</code>, pulsando el bot\u00f3n derecho del rat\u00f3n y seleccionando la opci\u00f3n Guardar como <code>lpp.rkt</code>. Gu\u00e1rdalo en la misma carpeta en la que tengas el fichero <code>practica7.rkt</code>. </p> <p>Puedes encontrar tambi\u00e9n el fichero <code>lpp.rkt</code> en el sitio Moodle de la asignatura.</p> <p>El fichero contiene la definici\u00f3n de la funci\u00f3n <code>(hoja? elem)</code> y la funci\u00f3n <code>(pinta-lista lista)</code> que nos permite dibujar gr\u00e1ficamente una lista estructurada.</p> <p>Por ejemplo, si definimos una lista estructurada como </p> <pre><code>(define lista '(a (b (c d) e) (f g)))\n</code></pre> <p>La llamada a <code>pinta-lista</code> dibujar\u00e1 lo siguiente:</p> <p></p>"},{"location":"practicas/practica07/practica07.html#ejercicio-1","title":"Ejercicio 1","text":"<p>a) Escribe la lista estructurada correspondiente a la siguiente representaci\u00f3n gr\u00e1fica por niveles. Para comprobar si la has definido correctamente puedes intentar obtener algunos de los elementos de la lista, como mostramos en el <code>check-equal?</code> que hay a continuaci\u00f3n.</p> <pre><code>       *\n     / |  \\\n    |  |    \\\n    *  d      *\n   / \\    / /  | \\\n  a  b   c *   *  h\n           |  / \\\n           e f  g\n</code></pre> <pre><code>(define lista-a '(________))\n(check-equal? (fourth (third lista-a)) 'h)\n</code></pre> <p>b) Dibuja la representaci\u00f3n en niveles de las siguientes listas estructurada. Comprueba despu\u00e9s con la funci\u00f3n <code>(pinta-lista lista)</code> que las has dibujado correctamente.</p> <pre><code>(define lista-b1 '((2 (3)) (4 2) ((2) 3)))\n(define lista-b2 '((b) (c (a)) d (a)))\n</code></pre> <p>c) Dada la definici\u00f3n de <code>cuadrado-estruct</code> vista en teor\u00eda:</p> <pre><code>(define (cuadrado-estruct lista)\n  (cond ((null? lista) '())\n        ((hoja? lista) (* lista lista ))\n        (else (cons\n             \u2460\u279c(cuadrado-estruct (first lista))\n             \u2461\u279c(cuadrado-estruct (rest lista))))))\n</code></pre> <ol> <li>Indica qu\u00e9 devuelve la expresi\u00f3n <code>(cuadrado-estruct lista-b1)</code>. La lista <code>lista-b1</code> es la definida en el apartado anterior.</li> <li>En la evaluaci\u00f3n de la expresi\u00f3n anterior, indica cu\u00e1les son los argumentos que se pasan por par\u00e1metro en las llamadas recursivas a <code>cuadrado-estruct</code> marcadas con <code>1</code> y <code>2</code>.</li> <li>En la evaluaci\u00f3n de la expresi\u00f3n anterior, indican qu\u00e9 devuelven las llamadas recursivas marcadas con <code>1</code> y <code>2</code>.</li> </ol> <p>d) Para entender el funcionamiento de las funciones de orden superior que trabajan sobre listas estructuradas es muy importante entender qu\u00e9 devuelve la expresi\u00f3n <code>map</code> que se aplica a la lista.</p> <p>La siguiente funci\u00f3n utiliza la funci\u00f3n <code>(nivel-hoja-fos dato lista)</code> vista en teor\u00eda. Indica qu\u00e9 devuelve la siguiente expresi\u00f3n.  La lista <code>lista-b2</code> es la definida en el apartado anterior. Utiliza el dibujo que has hecho en el ejercicio anterior para entender el funcionamiento de la expresi\u00f3n.</p> <pre><code>(map (lambda (elem)\n         (nivel-hoja-fos 'a elem)) lista-b2)\n</code></pre>"},{"location":"practicas/practica07/practica07.html#ejercicio-2","title":"Ejercicio 2","text":"<p>a) Implementa la funci\u00f3n recursiva <code>(concatena lista)</code> que recibe una lista estructurada con s\u00edmbolos y devuelve la cadena resultante de concatenar todos los s\u00edmbolos de la lista estructurada. Implementa dos versiones de la funci\u00f3n, una con recursi\u00f3n pura y otra con funciones de orden superior.</p> <p>Ejemplos:</p> <pre><code>(concatena '(a b (c) d)) ; \u21d2 \"abcd\"\n(concatena '(a (((b)) (c (d (e f (g))) h)) i)) ; \u21d2 \"abcdefghi\"\n</code></pre> <p>b) Implementa la funci\u00f3n recursiva <code>(todos-positivos? lista)</code> que recibe una lista estructurada con n\u00fameros y comprueba si todos sus elementos son positivos. Implementa dos versiones de la funci\u00f3n, una con recursi\u00f3n pura y otra con funciones de orden superior.</p> <p>Ejemplos:</p> <pre><code>(todos-positivos? '(1 (2 (3 (-3))) 4)) ; \u21d2 #f\n(todos-positivos-fos? '(1 (2 (3 (3))) 4)) ; \u21d2 #t\n</code></pre>"},{"location":"practicas/practica07/practica07.html#ejercicio-3","title":"Ejercicio 3","text":"<p>Implementa la funci\u00f3n <code>(cumplen-predicado pred lista)</code> que devuelva una lista con todos los elementos de lista estructurada que cumplen un predicado. Implementa dos versiones, una recursiva pura y otra usando funciones de orden superior.</p> <p>Ejemplo:</p> <pre><code>(cumplen-predicado even? '(1 (2 (3 (4))) (5 6))) ; \u21d2 (2 4 6)\n(cumplen-predicado pair? '(((1 . 2) 3 (4 . 3) 5) 6)) ; \u21d2 ((1 . 2) (4 . 3))\n</code></pre> <p>Utilizando la funci\u00f3n anterior implementa las siguientes funciones:</p> <ul> <li>Funci\u00f3n <code>(busca-mayores n lista-num)</code> que recibe una lista   estructurada con n\u00fameros y un n\u00famero <code>n</code> y devuelve una lista plana   con los n\u00fameros de la lista original mayores que <code>n</code>.</li> </ul> <pre><code>(busca-mayores 10 '(-1 (20 (10 12) (30 (25 (15)))))) ; \u21d2 (20 12 30 25 15)\n</code></pre> <ul> <li>Funci\u00f3n <code>(empieza-por char lista-pal)</code> que recibe una lista   estructurada con s\u00edmbolos y un car\u00e1cter <code>char</code> y devuelve una lista   plana con los s\u00edmbolos de la lista original que comienzan por el   car\u00e1cter <code>char</code>.</li> </ul> <pre><code>(empieza-por #\\m '((hace (mucho tiempo)) (en) (una galaxia ((muy  muy) lejana))))\n; \u21d2 (mucho muy muy)\n</code></pre>"},{"location":"practicas/practica07/practica07.html#ejercicio-4","title":"Ejercicio 4","text":"<p>Dos funciones sobre niveles:</p> <p>a) Implementa la funci\u00f3n <code>(sustituye-elem elem-old elem-new lista)</code> que recibe como argumentos una lista estructurada y dos elementos, y devuelve otra lista con la misma estructura, pero en la que se ha sustituido las ocurrencias de <code>elem-old</code> por <code>elem-new</code>. Puedes hacerla de forma recursiva pura o con funciones de orden superior.</p> <p>Ejemplo:</p> <pre><code>(sustituye-elem 'c 'h '(a b (c d (e c)) c (f (c) g)))\n; \u21d2 (a b (h d (e h)) h (f (h) g))\n</code></pre> <p>b) Implementa la funci\u00f3n <code>(nivel-mas-profundo lista)</code> que reciba una lista estructurada y devuelva una pareja <code>(elem . nivel)</code>, donde la parte izquierda es el elemento que se encuentra a mayor nivel y la parte derecha el nivel en el que se encuentra. Puedes definir alguna funci\u00f3n auxiliar si lo necesitas. Puedes hacerlo con recursi\u00f3n pura o con funciones de orden superior.</p> <pre><code>(nivel-mas-profundo '(2 (3))) ; \u21d2 (3 . 2)\n(nivel-mas-profundo '((2) (3 (4)((((((5))) 6)) 7)) 8)) ; \u21d2 (5 . 8)\n</code></pre>"},{"location":"practicas/practica07/practica07.html#ejercicio-5","title":"Ejercicio 5","text":"<p>a) Define la funci\u00f3n <code>(mezclar lista1 lista2 n)</code> que reciba dos listas estructuradas con la misma estructura y un n\u00famero que indica un nivel. Devuelve una nueva lista estructurada con la misma estructura que las listas originales, con los elementos de lista1 que tienen un nivel menor o igual que <code>n</code> y los elementos de lista2 que tienen un nivel mayor que <code>n</code>. Puedes hacerlo con recursi\u00f3n pura o con funciones de orden superior.</p> <p></p> <pre><code>(define lista1 '(((a b) ((c))) (d) e))\n(define lista2 '(((1 2) ((3))) (4) 5))\n(mezclar lista1 lista2 2) ; \u21d2 (((1 2) ((3))) (d) e)\n</code></pre> <p>b.1) Implementa la funci\u00f3n recursiva <code>(intersecta lista-1 lista-2)</code> que recibe como par\u00e1metros dos listas estructuradas y devuelve la lista estructurada resultante de recorrer ambas listas y colocar una pareja formada por la hoja de la primera y de la segunda en aquellas posiciones en las que el recorrido de ambas listas terminen al mismo tiempo en una hoja.</p> <p>Por ejemplo, si definimos las dos listas de la siguiente forma:</p> <pre><code>(define lista-1 '(a (b c) (d))) \n;     * \n;   / | \\ \n;  a  *  *\n;    / \\  \\ \n;   b   c  d\n\n(define lista-2 '((e) (f) (g)))\n;     * \n;   / | \\ \n;  *  *  * \n; /  /    \\ \n;e  f      g\n</code></pre> <p>La intersecci\u00f3n de ambas listas ser\u00eda:</p> <pre><code>(intersecta lista-1 lista-2)\n; \u21d2 (((b . f)) ((d . g)))\n;     *\n;     | \\\n;     *  *\n;    /    \\\n;  (b.f)  (d.g)\n</code></pre> <p>La funci\u00f3n recorrer\u00e1 al mismo tiempo la primera y la segunda lista. En la primera lista, en su primer elemento, llegar\u00e1 a la hoja <code>a</code>, mientras que en la segunda lista llegar\u00e1 a una sublista (la que contiene <code>e</code>). Ah\u00ed no habr\u00e1 intersecci\u00f3n. Despu\u00e9s recorrer\u00e1 el segundo elemento de la primera y la segunda lista y llegar\u00e1 a las hojas <code>b</code> y <code>f</code> al mismo tiempo, por lo que construir\u00e1 la pareja <code>(b . f)</code>. Descartar\u00e1 la sublista de la segunda lista formada por la <code>c</code>, por no existir correspondencia en la primera lista. Y, por \u00faltimo, comprobar\u00e1 que recorriendo el \u00faltimo elemento de ambas listas se llegar\u00e1 al mismo tiempo a las hojas <code>d</code> y <code>g</code>, formando la pareja <code>(d . g)</code>.</p> <p>Debes implementar s\u00f3lo la versi\u00f3n recursivas. </p> <p>Otros ejemplos:</p> <pre><code>(intersecta '(a b) '(c d)) ; \u21d2 '((a . c) (b . d))\n(intersecta '(a (b) (c)) '(d e (f))) ; \u21d2 '((a . d) ((c . f)))\n</code></pre> <p>b.2) Generaliza la funci\u00f3n anterior, haciendo que reciba otra funci\u00f3n con la operaci\u00f3n a realizar con las hojas: <code>(intersecta-gen f lista-1 lista-2)</code>. Escribe tres ejemplos de uso de la funci\u00f3n gen\u00e9rica con distintas funciones a aplicar a las hojas y explica qu\u00e9 devuelve cada caso.</p> <p>Lenguajes y Paradigmas de Programaci\u00f3n, curso 2024-25 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Domingo Gallardo, Cristina Pomares, Antonio Bot\u00eda, Francisco Mart\u00ednez</p>"},{"location":"practicas/practica08/practica08.html","title":"Pr\u00e1ctica 8: \u00c1rboles","text":""},{"location":"practicas/practica08/practica08.html#antes-de-la-clase-de-practicas","title":"Antes de la clase de pr\u00e1cticas","text":"<ul> <li> <p>Los siguientes ejercicios est\u00e1n basados en los conceptos de teor\u00eda vistos la semana pasada. Antes de la clase de pr\u00e1cticas debes repasar todos los conceptos y probar en el DrRacket todos los ejemplos de los siguientes apartados del tema 4 Estructuras de datos recursivas</p> <ul> <li>2 \u00c1rboles</li> <li>3 \u00c1rboles binarios</li> </ul> </li> </ul>"},{"location":"practicas/practica08/practica08.html#ejercicios","title":"Ejercicios","text":"<p>Descarga el fichero <code>lpp.rkt</code>, pulsando el bot\u00f3n derecho del rat\u00f3n y seleccionando la opci\u00f3n Guardar como <code>lpp.rkt</code>. Gu\u00e1rdalo en la misma carpeta en la que tengas el fichero <code>practica8.rkt</code>. </p> <p>El fichero contiene la definici\u00f3n de las funciones de la barrera de abstracci\u00f3n de \u00e1rboles y \u00e1rboles binarios, y las funciones <code>(pinta-arbol arbol)</code> y <code>(pinta-arbolb arbol-binario)</code> que nos permiten dibujar gr\u00e1ficamente \u00e1rboles y \u00e1rboles binarios.</p>"},{"location":"practicas/practica08/practica08.html#ejercicio-1","title":"Ejercicio 1","text":"<p>a.1) Escribe la sentencia en Scheme que define el siguiente \u00e1rbol gen\u00e9rico y escribe utilizando las funciones de la barrera de abstracci\u00f3n de \u00e1rboles una expresi\u00f3n que devuelva el n\u00famero 10.</p> <p></p> <pre><code>(define arbol '(------------))\n(check-equal? ------------------- 10)\n</code></pre> <p>a.2) Las funciones que suman los datos de un \u00e1rbol utilizando recursi\u00f3n mutua y que hemos visto en teor\u00eda son las siguientes:</p> <pre><code>(define (suma-datos-arbol arbol)\n    (+ (dato-arbol arbol)\n       (suma-datos-bosque (hijos-arbol arbol))))\n\n(define (suma-datos-bosque bosque)\n    (if (null? bosque)\n        0\n        (+ (suma-datos-arbol (first bosque)) \n           (suma-datos-bosque (rest bosque)))))\n</code></pre> <p>Si realizamos la siguiente llamada a la funci\u00f3n <code>suma-datos-bosque</code>, siendo <code>arbol</code> el definido en el apartado anterior:</p> <pre><code>(suma-datos-bosque (hijos-arbol arbol))\n</code></pre> <ol> <li>\u00bfQu\u00e9 devuelve la invocaci\u00f3n a <code>(suma-datos-arbol (first bosque))</code> que   se realiza dentro de la funci\u00f3n?</li> <li>\u00bfQu\u00e9 devuelve la primera llamada recursiva a <code>suma-datos-bosque</code>?</li> </ol> <p>Escribe la contestaci\u00f3n a estas preguntas como comentarios en el fichero de la pr\u00e1ctica.</p> <p>a.3) La funci\u00f3n de orden superior que hemos visto en teor\u00eda y que realiza tambi\u00e9n la suma de los datos de un \u00e1rbol es:</p> <pre><code>(define (suma-datos-arbol-fos arbol)\n   (foldr + (dato-arbol arbol) \n       (map suma-datos-arbol-fos (hijos-arbol arbol))))\n</code></pre> <p>Si realizamos la siguiente llamada a la funci\u00f3n, siendo <code>arbol</code> el definido en el apartado anterior:</p> <pre><code>(suma-datos-arbol-fos arbol)\n</code></pre> <ol> <li>\u00bfQu\u00e9 devuelve la invocaci\u00f3n a <code>map</code> dentro de la funci\u00f3n?</li> <li>\u00bfQu\u00e9 invocaciones se realizan a la funci\u00f3n <code>+</code> durante la ejecuci\u00f3n    de <code>foldr</code> sobre la lista devuelta por la invocaci\u00f3n a <code>map</code>?    Enum\u00e9ralas en orden, indicando sus par\u00e1metros y el valor devuelto    en cada una de ellas.</li> </ol> <p>b.1) Escribe la sentencia en Scheme que define el siguiente \u00e1rbol binario y escribe utilizando las funciones de la barrera de abstracci\u00f3n de \u00e1rboles binarios una expresi\u00f3n que devuelva el n\u00famero 29.</p> <p></p> <pre><code>(define arbolb '(------------------))\n(check-equal? ---------------------- 29)\n</code></pre>"},{"location":"practicas/practica08/practica08.html#ejercicio-2","title":"Ejercicio 2","text":"<p>a) Implementa dos versiones de la funci\u00f3n <code>(to-string-arbol arbol)</code> que recibe un \u00e1rbol de s\u00edmbolos y devuelve la cadena resultante de concatenar todos los s\u00edmbolos en recorrido preorden. Debes implementar una versi\u00f3n con recursi\u00f3n mutua y otra (llamada <code>to-string-arbol-fos</code>) con una \u00fanica funci\u00f3n en la que se use funciones de orden superior.</p> <p>Ejemplo:</p> <pre><code>(define arbol2 '(a (b (c (d)) (e)) (f)))\n(to-string-arbol arbol2) ; \u21d2 \"abcdef\"\n</code></pre> <p>b) Implementa dos versiones de la funci\u00f3n <code>(veces-arbol dato arbol)</code> que recibe un \u00e1rbol y un dato y comprueba el n\u00famero de veces que aparece el dato en el \u00e1rbol. Debes implementar una funci\u00f3n con recursi\u00f3n mutua y otra con funciones de orden superior.</p> <pre><code>(veces-arbol 'b '(a (b (c) (d)) (b (b) (f)))) ; \u21d2 3\n(veces-arbol 'g '(a (b (c) (d)) (b (b) (f)))) ; \u21d2 0\n</code></pre>"},{"location":"practicas/practica08/practica08.html#ejercicio-3","title":"Ejercicio 3","text":"<p>a) Implementa dos versiones de la funci\u00f3n <code>(hojas-cumplen pred arbol)</code> que recibe un predicado y un \u00e1rbol y devuelve una lista con todas aquellas hojas del \u00e1rbol que cumplen el predicado. Una funci\u00f3n con recursi\u00f3n mutua y otra con funciones de orden superior. </p> <p></p> <pre><code>(define arbol1 '(10 (2) (12 (4) (2)) (10 (5))))\n(define arbol2 '(10 (2) (12 (4) (2)) (10 (6))))\n(hojas-cumplen even? arbol1) ; \u21d2 '(2 4 2)\n(hojas-cumplen even? arbol2) ; \u21d2 '(2 4 2 6)\n</code></pre> <p>b) Implementa dos versiones del predicado <code>(todas-hojas-cumplen? pred arbol)</code> que comprueba si todas las hojas de un \u00e1rbol cumplen un determinado predicado. Una funci\u00f3n con recursi\u00f3n mutua y otra con funciones de orden superior.</p> <p>No debes usar la funci\u00f3n anterior, tienes que hacer un recorrido por todo el \u00e1rbol. Para la funci\u00f3n de orden superior puedes usar la funci\u00f3n <code>for-all?</code> implementada en el tema 2.</p> <pre><code>(todas-hojas-cumplen? even? arbol1) ; \u21d2 #f\n(todas-hojas-cumplen? even? arbol2) ; \u21d2 #t\n</code></pre>"},{"location":"practicas/practica08/practica08.html#ejercicio-4","title":"Ejercicio 4","text":"<p>a) Implementa, utilizando funciones de orden superior, la funci\u00f3n <code>(suma-raices-hijos arbol)</code> que devuelva la suma de las ra\u00edces de los hijos de un \u00e1rbol gen\u00e9rico.</p> <p>Ejemplo:</p> <p></p> <pre><code>(define arbol3 '(20 (2) (8 (4) (2)) (9 (5))))\n(suma-raices-hijos arbol3) ; \u21d2 19\n(suma-raices-hijos (second (hijos-arbol arbol3))) ; \u21d2 6\n</code></pre> <p>b) Implementa dos versiones, una con recursi\u00f3n mutua y otra con funciones de orden superior, de la funci\u00f3n <code>(raices-mayores-arbol? arbol)</code> que recibe un \u00e1rbol y comprueba que su ra\u00edz sea mayor que la suma de las ra\u00edces de los hijos y que todos los hijos (nos referimos a todos los descendientes) cumplen tambi\u00e9n esta propiedad.</p> <p>Ejemplos:</p> <p></p> <pre><code>(define arbol4 '(20 (2) (8 (4) (5)) (9 (5))))\n(raices-mayores-arbol? arbol3) ; \u21d2 #t\n(raices-mayores-arbol? arbol4) ; \u21d2 #f\n</code></pre> <p>c) Define la funci\u00f3n <code>(comprueba-raices-arbol arbol)</code> que recibe un arbol y que devuelve otro arbol en el que los nodos se han sustituido por 1 o 0 seg\u00fan si son mayores que la suma de las ra\u00edces de sus hijos o no.</p> <p>Ejemplos:</p> <pre><code>(define raices_arbol3 (comprueba-raices-arbol arbol3)) ; \u21d2 (1 (1) (1 (1) (1)) (1 (1)))\n(define raices_arbol4 (comprueba-raices-arbol arbol4)) ; \u21d2 (1 (1) (0 (1) (1)) (1 (1)))\n</code></pre> <p></p>"},{"location":"practicas/practica08/practica08.html#ejercicio-5","title":"Ejercicio 5","text":"<p>a) Define la funci\u00f3n con recursi\u00f3n mutua <code>(es-camino? lista arbol)</code> que debe comprobar si la secuencia de elementos de la lista se corresponde con un camino del \u00e1rbol que empieza en la ra\u00edz y que termina exactamente en una hoja. Suponemos que <code>lista</code> contiene al menos un elemento</p> <p>Por ejemplo, la lista <code>(a b a)</code> s\u00ed que es camino en el siguiente \u00e1rbol, pero la lista <code>(a b)</code> no.</p> <p></p> <p>Ejemplos: suponiendo que <code>arbol</code> es el \u00e1rbol definido por la figura anterior:</p> <pre><code>(es-camino? '(a b a) arbol) ; \u21d2 #t\n(es-camino? '(a b) arbol) ; \u21d2 #f\n(es-camino? '(a b a b) arbol) ; \u21d2 #f\n</code></pre> <p>b) Escribe la funci\u00f3n <code>(nodos-nivel nivel arbol)</code> que reciba un nivel y un \u00e1rbol gen\u00e9rico y devuelva una lista con todos los nodos que se encuentran en ese nivel.</p> <p></p> <p>Ejemplos, suponiendo que <code>arbol</code> es el \u00e1rbol definido por la figura anterior:</p> <pre><code>(nodos-nivel 0 arbol) ; \u21d2 '(1)\n(nodos-nivel 1 arbol) ; \u21d2 '(2 6)\n(nodos-nivel 2 arbol) ; \u21d2 '(3 5 7)\n(nodos-nivel 3 arbol) ; \u21d2 '(4 2)\n</code></pre>"},{"location":"practicas/practica08/practica08.html#ejercicio-6","title":"Ejercicio 6","text":"<p>a) Define la funci\u00f3n <code>(ordenado-entre? arbolb min max)</code> que comprueba si un \u00e1rbol binario est\u00e1 ordenado y sus datos est\u00e1 entre <code>min</code> y <code>max</code>. </p> <p>Un \u00e1rbol binario est\u00e1 ordenado cuando sus hijos izquierdos y derecho est\u00e1n ordenados y cuando la ra\u00edz es mayor o igual que todos los n\u00fameros del hijo izquierdo y menor o igual que todos los n\u00fameros del hijo derecho.</p> <p>Por ejemplo, en la siguiente figura, el \u00e1rbol binario de la izquierda (<code>arbolb1</code>) est\u00e1 ordenado, pero el de la derecha (<code>arbolb2</code>) no lo est\u00e1.</p> <p></p> <p>Ejemplo:</p> <pre><code>(define arbolb1 '(20 (13 (2 () ())\n                         (18 () ()))\n                     (40 (25 () () )\n                         (43 () ()))))\n(define arbolb2 '(20 (13 (2 () ())\n                         (22 () ()))\n                     (40 (25 () () )\n                         (43 () ()))))\n\n(ordenado-entre? arbolb1 0 50) ; \u21d2 #t\n(ordenado-entre? arbolb2 0 50) ; \u21d2 #f\n(ordenado-entre? arbolb1 0 30) ; \u21d2 #f\n</code></pre> <p>b) Utilizando la funci\u00f3n anterior, define las funciones <code>(ordenado-menor? arbolb max)</code> y <code>(ordenado-mayor? arbolb min)</code> que comprueban si un \u00e1rbol binario est\u00e1 ordenado y sus datos son menores o iguales o mayores o iguales que el argumento.</p> <p>Ejemplos:</p> <pre><code>(ordenado-menor? arbolb1 50) ; \u21d2 #t\n(ordenado-menor? arbolb1 40) ; \u21d2 #f\n(ordenado-menor? arbolb2 50) ; \u21d2 #f\n(ordenado-mayor? arbolb1 0)  ; \u21d2 #t\n(ordenado-mayor? arbolb1 20) ; \u21d2 #f\n(ordenado-mayor? arbolb2 0) ; \u21d2 #f\n</code></pre> <p>c) Utilizando las funciones anteriores, define la funci\u00f3n <code>(ordenado? arbolb)</code> que comprueba si un \u00e1rbol binario est\u00e1 ordenado.</p> <pre><code>(ordenado? arbolb1) ; \u21d2 #t\n(ordenado? arbolb2) ; \u21d2 #f\n</code></pre>"},{"location":"practicas/practica08/practica08.html#ejercicio-7","title":"Ejercicio 7","text":"<p>a) Dado un \u00e1rbol binario y un camino definido como una lista de s\u00edmbolos: <code>'(&lt; &gt; = &gt; &gt; =)</code> en el que:</p> <ul> <li><code>&lt;</code>: indica que nos vamos por la rama izquierda</li> <li><code>&gt;</code>: indica que nos vamos por la rama derecha</li> <li><code>=</code>: indica que nos quedamos con el dato de ese nodo.</li> </ul> <p>Implementa la funci\u00f3n <code>(camino-arbolb arbolb camino)</code> que devuelva una lista con los datos recogidos por el camino.</p> <p></p> <pre><code>(camino-arbolb arbolb '(= &lt; &lt; = &gt; =)) ; \u21d2 '(9 3 4)\n(camino-arbolb arbolb '(&gt; = &lt; &lt; =)) ; \u21d2 '(15 10)\n</code></pre> <p>b) Recuerda que un \u00e1rbol binario est\u00e1 ordenado si el dato de la ra\u00edz es mayor que todos los datos del hijo izquierdo y menor o igual que los del hijo derecho, y a su vez ambos hijos tambi\u00e9n est\u00e1n ordenados. </p> <p>Implementa de forma recursiva la funci\u00f3n <code>(inserta-ordenado n a)</code> que recibe un n\u00famero y un \u00e1rbol binario de n\u00fameros que est\u00e1 ordenado, y devuelve un nuevo \u00e1rbol binario ordenado que incluye el n\u00famero. </p> <p>Ejemplo:</p> <pre><code>(define a1 (inserta-ordenado 5 arbolb-vacio)) \n(define a2 (inserta-ordenado 4 a1))\n(define a3 (inserta-ordenado 2 a2))\n(define a4 (inserta-ordenado 6 a3))) \n</code></pre> <p></p> <p>Lenguajes y Paradigmas de Programaci\u00f3n, curso 2024-25 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Domingo Gallardo, Cristina Pomares, Antonio Bot\u00eda, Francisco Mart\u00ednez</p>"},{"location":"practicas/practica09/practica09.html","title":"Pr\u00e1ctica 9: Seminario de Swift y Programaci\u00f3n Funcional en Swift (1)","text":""},{"location":"practicas/practica09/practica09.html#ejercicios","title":"Ejercicios","text":""},{"location":"practicas/practica09/practica09.html#ejercicio-1","title":"Ejercicio 1","text":"<p>Comienza por leer y probar el seminario de Swift, hasta el apartado Funciones y clausuras (incluido).</p> <ol> <li> <p>Para instalar el comando <code>swift</code> en tu ordenador sigue las    instrucciones del seminario. </p> </li> <li> <p>Tal y como se indica en el seminario, puedes ejecutar tambi\u00e9n    programas Swift usando el entorno on-line    http://online.swiftplayground.run.     Pero debes tener en cuenta que esta opci\u00f3n tiene    algunos problemas: se requiere conexi\u00f3n a Internet, el editor es    muy limitado y es posible que en alguna ocasi\u00f3n el servidor est\u00e9    ca\u00eddo.</p> </li> <li> <p>Crea el fichero <code>practica09.swift</code> con una instrucci\u00f3n Hola mundo    que imprima esa cadena. Ejec\u00fatalo en el entorno que hayas instalado    y comprueba que todo funciona correctamente:</p> <p><pre><code>$ swift practica09.swift\nHola, mundo\n</code></pre> 4. Lee el seminario, copiando y modificando (siempre que sea posible) el c\u00f3digo de los ejemplos en el fichero <code>practica09.swift</code>. Lee bien el apartado correspondiente antes de probar cada ejemplo. Es conveniente que copies el c\u00f3digo sin hacer copy-paste, para que te acostumbres a la sintaxis del nuevo lenguaje.</p> <p>Incluye en la pr\u00e1ctica todos los experimentos indicados, hasta el <code>Experimento 9</code>. Antes de cada experimento pon un comentario indicando el experimento.</p> </li> </ol>"},{"location":"practicas/practica09/practica09.html#ejercicio-2","title":"Ejercicio 2","text":"<p>a) Implementa en Swift la funci\u00f3n recursiva <code>prefijos(prefijo:palabras:)</code> que recibe una cadena y un array de palabras. Devuelve un array de <code>Bool</code> con los booleanos resultantes de comprobar si la cadena es prefijo de cada una de las palabras de la lista.</p> <p>Puedes usar el m\u00e9todo <code>hasPrefix()</code> de <code>String</code> para comprobar si una cadena es prefijo de otra:</p> <pre><code>let miCadena = \"Hola\"\nmiCadena.hasPrefix(\"Ho\") // Devuelve true\nmiCadena.hasPrefix(\"la\") // Devuelve false\n</code></pre> <p>Ejemplo:</p> <pre><code>let array = [\"anterior\", \"ant\u00edgona\", \"antena\"]\nlet prefijo = \"ante\"\nprint(\"\\n******\\n2a) Funci\u00f3n prefijos(prefijo:palabras:)\\n******\")\nprint(prefijos(prefijo: prefijo, palabras: array))\n// Imprime: [true, false, true]\n</code></pre> <p>b) Implementa en Swift la funci\u00f3n recursiva <code>parejaMayorParImpar(numeros:)</code> que recibe un array de enteros positivos y devuelve una pareja con dos enteros: el primero es el mayor n\u00famero impar y el segundo el mayor n\u00famero par. Si no hay ning\u00fan n\u00famero par o impar se devolver\u00e1 un 0.</p> <pre><code>let numeros = [10, 201, 12, 103, 204, 2]\nprint(\"\\n******\\n2b) Funci\u00f3n parejaMayorParImpar(numeros:)\\n******\")\nprint(parejaMayorParImpar(numeros: numeros))\n// Imprime: (201, 204)\n</code></pre>"},{"location":"practicas/practica09/practica09.html#ejercicio-3","title":"Ejercicio 3","text":"<p>a) Implementa en Swift la funci\u00f3n recursiva <code>compruebaParejas(_:funcion:)</code> con el siguiente tipo:</p> <pre><code>([Int], (Int) -&gt; Int) -&gt; [(Int, Int)]\n</code></pre> <p>La funci\u00f3n recibe dos par\u00e1metros: un <code>Array</code> de enteros y una funci\u00f3n que recibe un entero y devuelve un entero. La funci\u00f3n devolver\u00e1 un array de tuplas que contiene las tuplas formadas por aquellos n\u00fameros contiguos del primer array que cumplan que el n\u00famero es el resultado de aplicar la funci\u00f3n al n\u00famero situado en la posici\u00f3n anterior.</p> <p>Ejemplo:</p> <pre><code>func cuadrado(x: Int) -&gt; Int {\n   return x * x\n}\nprint(compruebaParejas([2, 4, 16, 5, 10, 100, 105], funcion: cuadrado))\n// Imprime [(2,4), (4,16), (10,100)]\n</code></pre> <p>b) Implementa en Swift la funci\u00f3n recursiva <code>coinciden(parejas: [(Int,Int)], funcion: (Int)-&gt;Int)</code> que devuelve un array de booleanos que indica si el resultado de aplicar la funci\u00f3n al primer n\u00famero de cada pareja coincide con el segundo.</p> <pre><code>let array = [(2,4), (4,14), (4,16), (5,25), (10,100)]\nprint(coinciden(parejas: array, funcion: cuadrado))\n// Imprime: [true, false, true, true, true]\n</code></pre>"},{"location":"practicas/practica09/practica09.html#ejercicio-4","title":"Ejercicio 4","text":"<p>Supongamos que estamos escribiendo un programa que debe tratar movimientos de cuentas bancarias. Define un enumerado <code>Movimiento</code> con valores asociados con el que podamos representar:</p> <ul> <li>Dep\u00f3sito (valor asociado: <code>(Double)</code>)</li> <li>Cargo de un recibo (valor asociado: <code>(String, Double)</code>)</li> <li>Cajero (valor asociado: <code>(Double)</code>)</li> </ul> <p>Y define la funci\u00f3n <code>aplica(movimientos:[Movimiento])</code> que reciba un array de movimientos y devuelva una pareja con el dinero resultante de acumular todos los movimientos y un array de Strings con todos los cargos realizados.</p> <p>Ejemplo:</p> <pre><code>let movimientos: [Movimiento] = [.deposito(830.0), .cargoRecibo(\"Gimnasio\", 45.0), .deposito(400.0), .cajero(100.0), .cargoRecibo(\"Fnac\", 38.70)]\nprint(aplica(movimientos: movimientos))\n//Imprime (1046.3, [\"Gimnasio\", \"Fnac\"])\n</code></pre>"},{"location":"practicas/practica09/practica09.html#ejercicio-5","title":"Ejercicio 5","text":"<p>Implementa en Swift un tipo enumerado recursivo que permita construir \u00e1rboles binarios de enteros. El enumerado debe tener </p> <ul> <li>un caso en el que guardar tres valores: un <code>Int</code> y dos \u00e1rboles binarios (el hijo izquierdo y el hijo derecho)</li> <li>otro caso constante: un \u00e1rbol binario vac\u00edo </li> </ul> <p>Llamaremos al tipo <code>ArbolBinario</code> y a los casos <code>nodo</code> y <code>vacio</code>.</p> <p>Implem\u00e9ntalo de forma que el siguiente ejemplo funcione correctamente:</p> <pre><code>let arbol: ArbolBinario = .nodo(8, \n                                .nodo(2, .vacio, .vacio), \n                                .nodo(12, .vacio, .vacio))\n</code></pre> <p>Implementa tambi\u00e9n la funci\u00f3n <code>suma(arbolb:)</code> que reciba una instancia de \u00e1rbol binario y devuelva la suma de todos sus nodos:</p> <pre><code>print(suma(arbolb: arbol))\n// Imprime: 22\n</code></pre>"},{"location":"practicas/practica09/practica09.html#ejercicio-6","title":"Ejercicio 6","text":"<p>Implementa en Swift un tipo enumerado recursivo que permita construir \u00e1rboles de enteros usando el mismo enfoque que en Scheme: un nodo est\u00e1 formado por un dato (un <code>Int</code>) y una colecci\u00f3n de \u00e1rboles hijos. Llamaremos al tipo <code>Arbol</code>.</p> <p>Implem\u00e9ntalo de forma que el siguiente ejemplo funcione correctamente:</p> <pre><code>/*\nDefinimos el \u00e1rbol\n\n    10\n   / | \\\n  3  5  8\n  |\n  1\n\n*/\n\nlet arbol1 = Arbol.nodo(1, [])\nlet arbol3 = Arbol.nodo(3, [arbol1])\nlet arbol5 = Arbol.nodo(5, [])\nlet arbol8 = Arbol.nodo(8, [])\nlet arbol10 = Arbol.nodo(10, [arbol3, arbol5, arbol8])\n</code></pre> <p>Implementa tambi\u00e9n la funci\u00f3n <code>suma(arbol:cumplen:)</code> que reciba una instancia de \u00e1rbol y una funci\u00f3n <code>(Int) -&gt; Bool</code> que comprueba una condici\u00f3n sobre el nodo. La funci\u00f3n debe devolver la suma de todos los nodos del \u00e1rbol que cumplan la condici\u00f3n. </p> <p>Implementa la funci\u00f3n usando la misma estrategia que ya utilizamos en Scheme de definir una funci\u00f3n auxiliar <code>suma(bosque:cumplen:)</code> y una recursi\u00f3n mutua.</p> <pre><code>func esPar(x: Int) -&gt; Bool {\n    return x % 2 == 0\n}\n\nprint(\"La suma del \u00e1rbol es: \\(suma(arbol: arbol10, cumplen: esPar))\")\n// Imprime: La suma del \u00e1rbol gen\u00e9rico es: 18\n</code></pre> <p>Lenguajes y Paradigmas de Programaci\u00f3n, curso 2024-25 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Domingo Gallardo, Cristina Pomares, Antonio Bot\u00eda, Francisco Mart\u00ednez</p>"},{"location":"practicas/practica10/practica10.html","title":"Pr\u00e1ctica 10: Programaci\u00f3n funcional en Swift (2)","text":""},{"location":"practicas/practica10/practica10.html#antes-de-la-clase-de-practicas","title":"Antes de la clase de pr\u00e1cticas","text":"<p>Los siguientes ejercicios est\u00e1n basados en los conceptos de teor\u00eda vistos la semana pasada. Antes de la clase de pr\u00e1cticas debes repasar todos los conceptos y probar en con el compilador de Swift todos los ejemplos de los siguientes apartados del tema 5 Programaci\u00f3n funcional con Swift</p> <ul> <li>Opcionales</li> <li>Clausuras</li> <li>Funciones de orden superior</li> <li>Gen\u00e9ricos</li> </ul>"},{"location":"practicas/practica10/practica10.html#ejercicios","title":"Ejercicios","text":""},{"location":"practicas/practica10/practica10.html#ejercicio-1","title":"Ejercicio 1","text":"<p>a) Define la funci\u00f3n <code>maxOpt(_ x: Int?, _ y: Int?) -&gt; Int?</code> que devuelve el m\u00e1ximo de dos enteros opcionales. En el caso en que ambos sean <code>nil</code> se devolver\u00e1 <code>nil</code>. En el caso en que uno sea <code>nil</code> y el otro no se devolver\u00e1 el entero que no es <code>nil</code>. En el caso en que ning\u00fan par\u00e1metro sea <code>nil</code> se devolver\u00e1 el mayor.</p> <p>Ejemplo:</p> <pre><code>let res1 = maxOpt(nil, nil) \nlet res2 = maxOpt(10, nil)\nlet res3 = maxOpt(-10, 30)\nprint(\"res1 = \\(String(describing: res1))\")\nprint(\"res2 = \\(String(describing: res2))\")\nprint(\"res3 = \\(String(describing: res3))\")\n// Imprime:\n// res1 = nil\n// res2 = Optional(10)\n// res3 = Optional(30)\n</code></pre> <p>b1) Escribe una nueva versi\u00f3n del ejercicio 2b) de la pr\u00e1ctica 9 que permita recibir n\u00fameros negativos y que devuelva una pareja de <code>(Int?, Int?)</code> con <code>nil</code> en la parte izquierda y/o derecha si no hay n\u00famero impares o pares. Debes usar la funci\u00f3n auxiliar definida en el apartado anterior.</p> <p>Ejemplo:</p> <pre><code>let numeros = [-10, 202, 12, 100, 204, 2]\nprint(\"\\n******\\n1b1) Funci\u00f3n parejaMayorParImpar2(numeros:)\\n******\")\nprint(parejaMayorParImpar2(numeros: numeros))\n// Imprime:\n// parejaMayorParImpar2(numeros: [-10, 202, 12, 100, 204, 2])\n// (nil, Optional(204))\n</code></pre> <p>b2) Escribe la funci\u00f3n <code>sumaMaxParesImpares(numeros: [Int]) -&gt; Int</code> que llama a la funci\u00f3n anterior y devuelve la suma del m\u00e1ximo de los pares y el m\u00e1ximo de los impares. En el caso en que se pase un array vac\u00edo deber\u00e1 devolver un 0.</p> <pre><code>print(\"sumaMaxParesImpares(numeros: \\(numeros))\")\nprint(sumaMaxParesImpares(numeros: numeros))\n// Imprime:\n// sumaMaxParesImpares(numeros: [-10, 202, 12, 100, 204, 2])\n// 204\n</code></pre> <p>b3) Escribe una nueva versi\u00f3n de la funci\u00f3n del ejercicio b1) en la que se devuelva <code>nil</code> en el caso en que se le pase como par\u00e1metro un array vac\u00edo. \u00bfC\u00f3mo se deber\u00eda cambiar la declaraci\u00f3n de la funci\u00f3n? Escribe tambi\u00e9n una nueva versi\u00f3n de la funci\u00f3n del ejercicio b2) en la que se llame a la funci\u00f3n anterior.</p>"},{"location":"practicas/practica10/practica10.html#ejercicio-2","title":"Ejercicio 2","text":"<p>a) Indica qu\u00e9 devuelven las siguientes expresiones:</p> <p>a.1) <pre><code>let nums = [1,2,3,4,5,6,7,8,9,10]\nnums.filter{$0 % 3 == 0}.count\n</code></pre></p> <p>a.2) <pre><code>let nums2 = [1,2,3,4,5,6,7,8,9,10]\nnums2.map{$0+100}.filter{$0 % 5 == 0}.reduce(0,+)\n</code></pre></p> <p>a.3) <pre><code>let cadenas = [\"En\", \"un\", \"lugar\", \"de\", \"La\", \"Mancha\"]\ncadenas.sorted{$0.count &lt; $1.count}.map{$0.count}\n</code></pre></p> <p>a.4) <pre><code>let cadenas2 = [\"En\", \"un\", \"lugar\", \"de\", \"La\", \"Mancha\"]\ncadenas2.reduce([]) {\n    (res: [(String, Int)], c: String) -&gt; [(String, Int)] in\n        res + [(c, c.count)]}.sorted(by: {$0.1 &lt; $1.1})\n</code></pre></p> <p>b) Explica qu\u00e9 hacen las siguientes funciones y pon un ejemplo de su funcionamiento:</p> <p>b.1) <pre><code>func f(nums: [Int], n: Int) -&gt; Int {\n    return nums.filter{$0 == n}.count\n}\n</code></pre></p> <p>b.2) <pre><code>func g(nums: [Int]) -&gt; [Int] {\n    return nums.reduce([], {\n        (res: [Int], n: Int) -&gt; [Int] in\n            if !res.contains(n) {\n                return res + [n]\n            } else {\n                return res\n            }\n    })\n}\n</code></pre></p> <p>b.3) <pre><code>func h(nums: [Int], n: Int) -&gt; ([Int], [Int]) {\n   return nums.reduce(([],[]), {\n       (res: ([Int],[Int]), num: Int ) -&gt; ([Int],[Int]) in\n           if (num &gt;= n) {\n               return (res.0, res.1 + [num])\n           } else {\n               return ((res.0 + [num], res.1))\n           }\n   })\n}\n</code></pre></p> <p>c) Implementa las siguientes funciones con funciones de orden superior.</p> <p>c.1) Funci\u00f3n <code>suma(palabras:contienen:)</code>:</p> <pre><code>suma(palabras: [String], contienen: Character) -&gt; Int\n</code></pre> <p>que recibe una array de cadenas y devuelve la suma de las longitudes de las cadenas que contiene el car\u00e1cter que se pasa como par\u00e1metro.</p> <p>c.2) Funci\u00f3n <code>sumaMenoresMayores(nums:pivote:)</code>:</p> <pre><code>sumaMenoresMayores(nums: [Int], pivote: Int) -&gt; (Int, Int)\n</code></pre> <p>que recibe un array de n\u00fameros y un n\u00famero pivote y devuelve una tupla con la suma de los n\u00fameros menores y mayores o iguales que el pivote.</p> <p>d) (Ejercicio sobre variables capturadas por clausuras) Reflexiona sobre el siguiente c\u00f3digo y completa el hueco para obtener el resultado esperado.</p> <pre><code>func bar(f: (Int) -&gt; Int) {\n  print(f(__________))\n}\n\nfunc foo() -&gt; (Int) -&gt; Int {\n  var x = 3\n  return {\n    x += $0 + 2\n    return x\n  }\n}\n\nvar x = 5\nlet g = foo()\nbar(f: g)   // =&gt; 9\nbar(f: g)   // =&gt; 15\n</code></pre>"},{"location":"practicas/practica10/practica10.html#ejercicio-3","title":"Ejercicio 3","text":"<p>Define un tipo enumerado con un \u00e1rbol gen\u00e9rico, tal y como hicimos en el \u00faltimo ejercicio de la pr\u00e1ctica anterior, que tenga como gen\u00e9rico el tipo de dato que contiene.</p> <p>En el siguiente ejemplo vemos c\u00f3mo deber\u00eda poderse definir con el mismo tipo gen\u00e9rico un \u00e1rbol de enteros y un \u00e1rbol de cadenas:</p> <pre><code>let arbolInt: Arbol = .nodo(53, \n                            [.nodo(13, []), \n                             .nodo(32, []), \n                             .nodo(41, \n                                   [.nodo(36, []), \n                                    .nodo(39, [])\n                                   ])\n                            ])\nlet arbolString: Arbol = .nodo(\"Zamora\", \n                               [.nodo(\"Buend\u00eda\", \n                                      [.nodo(\"Albeza\", []), \n                                       .nodo(\"Berenguer\", []), \n                                       .nodo(\"Bolardo\", [])\n                                      ]), \n                                .nodo(\"Galv\u00e1n\", [])\n                               ])\n</code></pre> <p>Define las funciones gen\u00e9ricas <code>toArray</code> y <code>toArrayFOS</code> que devuelvan un array con todos los componentes del \u00e1rbol usando un recorrido preorden (primero la ra\u00edz y despu\u00e9s los hijos). La primera la debes implementar con recursi\u00f3n mutua y la segunda usando funciones de orden superior.</p> <p>Ejemplo:</p> <pre><code>print(toArray(arbol: arbolInt))\n// Imprime: [53, 13, 32, 41, 36, 39]\nprint(toArrayFOS(arbol: arbolString))\n// Imprime: [\"Zamora\", \"Buend\u00eda\", \"Albeza\", \"Berenguer\", \"Bolardo\", \"Galv\u00e1n\"]\n</code></pre>"},{"location":"practicas/practica10/practica10.html#ejercicio-4","title":"Ejercicio 4","text":"<p>Implementa en Swift la funci\u00f3n <code>imprimirListadosNotas(alumnos:)</code> que recibe un array de tuplas, en donde cada tupla contiene informaci\u00f3n de la evaluaci\u00f3n de un alumno de LPP (nombreAlumno, notaParcial1, notaParcial2, notaParcial3, a\u00f1osMatriculacion) y que debe imprimir por pantalla los siguientes listados: </p> <ul> <li>listado 1: array ordenado por nombre del alumno (orden alfab\u00e9tico creciente) </li> <li>listado 2: array ordenado por la nota del parcial 1 (orden decreciente de nota) </li> <li>listado 3: array ordenado por la nota del parcial 2 (orden creciente de nota) </li> <li>listado 4: array ordenado por a\u00f1o de matriculaci\u00f3n y nota del   parcial 3 (orden decreciente de a\u00f1o y nota) </li> <li>listado 5: array ordenado por nota final (media de los tres parciales, ponderados en: 0,35, 0,3, 0,35) (orden decreciente de nota final)</li> </ul> <p>Las ordenaciones hay que realizarlas usando la funci\u00f3n <code>sorted</code>.</p> <p>Nota</p> <p>Para que los listados se muestren formateados con espacios, puedes usar la siguiente funci\u00f3n (para ello tambi\u00e9n debes incluir el import que se indica)</p> <pre><code>import Foundation\n\nfunc imprimirListadoAlumnos(_ alumnos: [(String, Double, Double, Double, Int)]) {\n    print(\"Alumno   Parcial1   Parcial2   Parcial3  A\u00f1os\")\n    for alu in alumnos {\n        alu.0.withCString {\n            print(String(format:\"%-10s %5.2f      %5.2f    %5.2f  %3d\", $0, alu.1,alu.2,alu.3,alu.4))\n        }\n    }\n}\n</code></pre> <p>Ejemplo:</p> <pre><code>let listaAlumnos = [(\"Pepe\", 8.45, 3.75, 6.05, 1), \n                    (\"Maria\", 9.1, 7.5, 8.18, 1), \n                    (\"Jose\", 8.0, 6.65, 7.96, 1),\n                    (\"Carmen\", 6.25, 1.2, 5.41, 2), \n                    (\"Felipe\", 5.65, 0.25, 3.16, 3), \n                    (\"Carla\", 6.25, 1.25, 4.23, 2), \n                    (\"Luis\", 6.75, 0.25, 4.63, 2), \n                    (\"Loli\", 3.0, 1.25, 2.19, 3)]\nimprimirListadosNotas(listaAlumnos)\n</code></pre> <p>Algunos de los listados que se deben mostrar ser\u00edan los siguientes:</p> <pre><code>LISTADO ORIGINAL\nAlumno   Parcial1   Parcial2   Parcial3  A\u00f1os\nPepe        8.45       3.75     6.05    1\nMaria       9.10       7.50     8.18    1\nJose        8.00       6.65     7.96    1\nCarmen      6.25       1.20     5.41    2\nFelipe      5.65       0.25     3.16    3\nCarla       6.25       1.25     4.23    2\nLuis        6.75       0.25     4.63    2\nLoli        3.00       1.25     2.19    3\n\nLISTADO ORDENADO por Parcial1 (decreciente)\nAlumno   Parcial1   Parcial2   Parcial3  A\u00f1os\nLoli        3.00       1.25     2.19    3\nFelipe      5.65       0.25     3.16    3\nCarmen      6.25       1.20     5.41    2\nCarla       6.25       1.25     4.23    2\nLuis        6.75       0.25     4.63    2\nJose        8.00       6.65     7.96    1\nPepe        8.45       3.75     6.05    1\nMaria       9.10       7.50     8.18    1\n</code></pre>"},{"location":"practicas/practica10/practica10.html#ejercicio-5","title":"Ejercicio 5","text":"<p>Dado el array <code>listaAlumnos</code> del ejercicio anterior, utiliza funciones de orden superior para obtener los datos requeridos en cada caso.</p> <p>A) N\u00famero de alumnos que han aprobado primer parcial y suspendido el segundo</p> <pre><code>print(listaAlumnos. ________________________________ )\n// Resultado: 5\n</code></pre> <p>B) Alumnos que han aprobado la asignatura (tienen una nota final &gt;= 5)</p> <pre><code>print(listaAlumnos._______________________________ )\n\n// Resultado: [\"Pepe\", \"Maria\", \"Jose\"]\n</code></pre> <p>C) Nota media de todos los alumnos en forma de tupla <code>(media_p1, media_p2, media_p3)</code></p> <pre><code>var tupla = listaAlumnos._____________________________________ )\ntupla = (tupla.0 / Double(listaAlumnos.count), tupla.1 / Double(listaAlumnos.count), tupla.2 / Double(listaAlumnos.count))\nprint(tupla)\n// Resultado: (6.6812499999999995, 2.7624999999999997, 5.22625)\n</code></pre>"},{"location":"practicas/practica10/practica10.html#ejercicio-6","title":"Ejercicio 6","text":"<p>Implementa la funci\u00f3n <code>construye</code> con el siguiente tipo:</p> <pre><code>func construye(operador: Character) -&gt; (Int, Int) -&gt; Int\n</code></pre> <p>La funci\u00f3n recibe un operador que puede ser uno de los siguientes caracteres: <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code> y debe devolver una clausura que reciba dos argumentos y realice la operaci\u00f3n indicada sobre ellos.</p> <p>Ejemplo:</p> <pre><code>var f = construye(operador: \"+\")\nprint(f(2,3))\n// Imprime 5\nf = construye(operador: \"-\")\nprint(f(2,3))\n// Imprime -1\n</code></pre> <p>Lenguajes y Paradigmas de Programaci\u00f3n, curso 2024-25 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Domingo Gallardo, Cristina Pomares, Antonio Bot\u00eda, Francisco Mart\u00ednez</p>"},{"location":"practicas/practica11/practica11.html","title":"Pr\u00e1ctica 11: Programaci\u00f3n Orientada a Objetos en Swift (1)","text":""},{"location":"practicas/practica11/practica11.html#antes-de-la-clase-de-practicas","title":"Antes de la clase de pr\u00e1cticas","text":"<p>Los siguientes ejercicios est\u00e1n basados en los conceptos de teor\u00eda vistos la semana pasada. Antes de la clase de pr\u00e1cticas debes repasar todos los conceptos y probar en con el compilador de Swift todos los ejemplos de los siguientes apartados del tema 6 Programaci\u00f3n OO con Swift</p> <ul> <li>Clases y estructuras</li> <li>Propiedades</li> <li>M\u00e9todos</li> <li>Inicializaci\u00f3n</li> <li>Herencia</li> </ul>"},{"location":"practicas/practica11/practica11.html#seminario-de-swift","title":"Seminario de Swift","text":"<p>Continua tambi\u00e9n leyendo y probando el tour del seminario de Swift, en concreto los apartados Objetos y clases y Enumeraciones y estructuras. Este \u00faltimo apartado te servir\u00e1 tambi\u00e9n para repasar el concepto de enumeraci\u00f3n y enumeraci\u00f3n con valor asociado.</p>"},{"location":"practicas/practica11/practica11.html#ejercicio-1","title":"Ejercicio 1","text":"<p>Contesta los siguientes apartados sin usar el compilador de Swift. Una vez los hayas terminado, comprueba si la soluci\u00f3n que hab\u00edas indicado era correcta.</p> <p>a) Examina el siguiente c\u00f3digo. \u00bfQu\u00e9 error o errores tiene? Arregla los errores con el m\u00ednimo n\u00famero de cambios posibles e indica qu\u00e9 se va a imprimir por pantalla.</p> <pre><code>struct MiEstructura {\n    var x = 0\n}\n\nclass MiClase {\n    var x = 0\n}\n\nfunc foo(_ c: MiClase, _ x: Int) {\n    c.x = x\n}\n\nlet s1 = MiEstructura()\nvar s2 = s1\nlet c1 = MiClase()\nvar c2 = c1\n\ns1.x = 10\nc1.x = 10\nprint (\"s2.x: \\(s2.x), c2.x: \\(c2.x)\")\n\nfoo(c1, 20)\nprint(\"c1.x, despu\u00e9s de llamar a la funci\u00f3n: \\(c1.x)\")\n</code></pre> <p>b) Examina el c\u00f3digo a continuaci\u00f3n y a\u00f1ade en la estructura <code>Cuadrado</code> dos versiones de un m\u00e9todo <code>movido</code> que reciba un incremento x y un incremento y y devuelva un nuevo cuadrado resultante de haber movido su esquina. Llama a la primera versi\u00f3n del m\u00e9todo <code>movido1</code> y usa en ella el m\u00e9todo <code>movida</code> de la estructura <code>Coord</code>. Llama a la segunda versi\u00f3n del m\u00e9todo <code>movido2</code> y usa en ella el m\u00e9todo <code>mueve</code> de la estructura <code>Coord</code>. A\u00f1ade tambi\u00e9n un m\u00e9todo mutador <code>mueve</code> que haga lo mismo que los anteriores, pero mutando la posici\u00f3n del cuadrado.</p> <pre><code>struct Coord {\n    var x: Double\n    var y: Double\n\n    func movida(incX: Double, incY: Double) -&gt; Coord {\n        return Coord(x: x+incX, y: y+incY)\n    }\n\n    mutating func mueve(incX: Double, incY: Double) {\n        x = x + incX\n        y = y + incY\n    }\n}\n\nstruct Cuadrado {\n    var esquina = Coord(x: 0.0, y: 0.0)\n    var lado: Double\n\n    func movido1 ... {\n        ...\n    }\n\n    func movido2 ... {\n        ...\n    }\n\n    // A\u00f1ade un m\u00e9todo mutador mueve\n}\n</code></pre> <p>c) Indica qu\u00e9 muestra por pantalla la funci\u00f3n print:</p> <pre><code>func foo(palabra: String, longitud: Int) -&gt; Bool {\n    if palabra.count &gt;= longitud {\n        return true\n    }\n    else {\n        return false\n    } \n}\n\nclass MisPalabras {\n    var guardadas: [String] = []\n    func guarda(_ palabra: String) {\n        guardadas.append(palabra)\n    }\n    var x : [Bool] {\n        get {\n            return guardadas.map {foo(palabra: $0,longitud: 4)}\n        }\n    } \n}\n\nlet palabras = MisPalabras()\npalabras.guarda(\"Ana\")\npalabras.guarda(\"Pascual\")\npalabras.guarda(\"Mar\u00eda\")\nprint(palabras.x)\n</code></pre>"},{"location":"practicas/practica11/practica11.html#ejercicio-2","title":"Ejercicio 2","text":"<p>a) El siguiente c\u00f3digo usa propiedades calculadas y observadores de propiedades. \u00bfQu\u00e9 se imprime al final de su ejecuci\u00f3n? Reflexiona sobre el funcionamiento del c\u00f3digo, compru\u00e9balo con el compilador y experimenta haciendo cambios y comprobando el resultado.</p> <pre><code>var x = 10  {\n   didSet {\n      if (x &gt; 100) {\n          x = oldValue\n      }\n   }\n}\n\nvar y: Int {\n    get {\n        return x / 3\n    }\n    set {\n        x = 3 * newValue\n    }\n}\n\nvar z : Int {\n   get {\n      return x + y\n   }\n   set {\n      x = newValue / 2\n      y = newValue / 2\n   }\n}\nz = 60\nprint(\"y: \\(y)\")\nprint(\"x: \\(x)\")\nz = 600\nprint(\"y: \\(y)\")\nprint(\"x: \\(x)\")\n</code></pre> <p>b) El siguiente c\u00f3digo usa observadores de propiedades y una variable del tipo (est\u00e1tica). </p> <p>\u00bfQu\u00e9 se imprime al final de su ejecuci\u00f3n? Reflexiona sobre el funcionamiento del c\u00f3digo, compru\u00e9balo con el compilador y experimenta haciendo cambios y comprobando el resultado.</p> <pre><code>struct Valor {\n    var valor: Int = 0 {\n        willSet {\n            Valor.z += newValue\n        }        \n        didSet {\n            if valor &gt; 10 {\n                valor = 10\n            }\n        }\n    }\n    static var z = 0\n}\n\nvar c1 = Valor()\nvar c2 = Valor()\nc1.valor = 20\nc2.valor = 8\nprint(c1.valor + c2.valor + Valor.z)\n</code></pre>"},{"location":"practicas/practica11/practica11.html#ejercicio-3","title":"Ejercicio 3","text":"<p>Escribe un ejemplo de c\u00f3digo en el que definas una relaci\u00f3n de herencia entre una clase base y una clase derivada. Comprueba en el c\u00f3digo que un objeto de la clase derivada hereda las propiedades y m\u00e9todos de la clase base.</p> <p>Investiga sobre el funcionamiento de la herencia en Swift. Escribe ejemplos en donde compruebes este funcionamiento. Algunos ejemplos de preguntas que puedes investigar (puedes a\u00f1adir t\u00fa m\u00e1s preguntas):</p> <ul> <li>\u00bfSe puede sobreescribir el valor de una propiedad almacenada? \u00bfY calculada? </li> <li>\u00bfSe puede a\u00f1adir un observador a una propiedad de la clase base en   una clase derivada?</li> <li>\u00bfHereda la clase derivada propiedades y m\u00e9todos est\u00e1ticos de la clase base?</li> <li>\u00bfC\u00f3mo se puede llamar a la implementaci\u00f3n de un m\u00e9todo de la clase   base en una sobreescritura de ese mismo m\u00e9todo en la clase derivada?</li> </ul>"},{"location":"practicas/practica11/practica11.html#ejercicio-4","title":"Ejercicio 4","text":"<p>En este ejercicio vamos a trabajar con figuras geom\u00e9tricas usando estructuras y clases.</p> <p>En el ejercicio deber\u00e1s usar la funci\u00f3n para calcular la ra\u00edz cuadrada y el valor de la constante matem\u00e1tica pi.</p> <ul> <li>Para usar la funci\u00f3n <code>sqrt</code> debes importar la librer\u00eda <code>Foundation</code>:</li> </ul> <pre><code>import Foundation\n</code></pre> <ul> <li>El valor de la constante matem\u00e1tica pi lo puedes obtener con la   propiedad <code>Double.pi</code>.</li> </ul> <p>Suponemos que estamos trabajando con coordenadas de pantalla, en las que la coordenada (0,0) representa la coordenada de la esquina superior izquierda de la pantalla. La coordenada Y crece hacia abajo y la coordenada X crece hacia la derecha. Las coordenadas se definir\u00e1n con n\u00fameros decimales (<code>Double</code>).</p> <p>Vamos a definir las siguientes estructuras y clases:</p> <ul> <li>Estructuras: <code>Punto</code>, <code>Tama\u00f1o</code></li> <li>Clases: <code>Figura</code> (superclase), <code>Cuadril\u00e1tero</code> y <code>Circulo</code> (clases derivadas). </li> </ul> <p></p> <p>Vamos a definir propiedades almacenadas y propiedades calculadas para todas las figuras geom\u00e9tricas.</p> <p>Estructuras <code>Punto</code> y <code>Tama\u00f1o</code></p> <p>Las debes declarar tal y como aparecen en los apuntes.</p> <p>Clase <code>Figura</code>:</p> <ul> <li>Inicializador:<ul> <li><code>Figura(origen: Punto, tama\u00f1o: Tama\u00f1o)</code></li> </ul> </li> <li>Propiedades de instancia almacenadas:<ul> <li><code>origen</code> (<code>Punto</code>) que define las coordenadas de la esquina   superior izquierda del rect\u00e1ngulo que define la figura</li> <li><code>tama\u00f1o</code> (<code>Tama\u00f1o</code>) que define el alto y el ancho del rect\u00e1ngulo   que define la figura.</li> </ul> </li> <li>Propiedades de instancia calculadas:<ul> <li><code>area</code> (<code>Double</code>, solo lectura) que devuelve el \u00e1rea del   rect\u00e1ngulo que engloba la figura.</li> <li><code>centro</code> (<code>Punto</code>, propiedad de lectura y escritura). Es el   centro del rect\u00e1ngulo que define la figura. Si modificamos el   centro se modifica la posici\u00f3n del origen de la figura.</li> </ul> </li> </ul> <p>Clase derivada <code>Cuadrilatero</code></p> <p>Un cuadril\u00e1tero se define por cuatro puntos. La figura representa el rect\u00e1ngulo que engloba los cuatro puntos del cuadril\u00e1tero (ver imagen arriba).</p> <ul> <li>Inicializador:<ul> <li><code>Cuadrilatero(p1: Punto, p2: Punto, p3: Punto, p4: Punto)</code>. Los   puntos se dan en el orden definido por el sentido de las agujas   del reloj, aunque no siempre se empezar\u00e1 por el punto que est\u00e1   situado m\u00e1s a la derecha. Al crear el cuadril\u00e1tero deberemos   actualizar las propiedades <code>origen</code> y <code>tama\u00f1o</code> de la   figura. Para calcular estas propiedades deber\u00e1s obtener las   coordenadas x e y m\u00ednimas y m\u00e1ximas de todos los puntos.</li> </ul> </li> <li>Propiedades de instancia almacenadas propias:<ul> <li>Los puntos del cuadril\u00e1tero <code>p1</code>, <code>p2</code>, <code>p3</code> y <code>p4</code>.</li> </ul> </li> <li> <p>Propiedades de instancia calculadas:</p> <ul> <li><code>centro</code> (<code>Punto</code>, de lectura y escritura), heredada de la superclase    El <code>setter</code> modifica la posici\u00f3n de los   puntos del cuadril\u00e1tero y del origen de la figura,   desplaz\u00e1ndolos los mismos incrementos en los que ha sido   desplazado el centro de la figura.</li> <li><code>area</code> (<code>Double</code>, s\u00f3lo lectura ) que devuelve el \u00e1rea del   cuadrilatero. Se puede calcular esta \u00e1rea sumando las \u00e1reas de   dos tri\u00e1ngulos que forman el cuadrilatero.</li> </ul> <p>Se puede utilizar la siguiente funci\u00f3n auxiliar para calcular el   \u00e1rea de un tri\u00e1ngulo en funci\u00f3n de los puntos de sus v\u00e9rtices:</p> <pre><code>func areaTriangulo(_ p1: Punto, _ p2: Punto, _ p3: Punto) -&gt; Double {\n    let det = p1.x * (p2.y - p3.y) + p2.x * (p3.y - p1.y) + p3.x * (p1.y - p2.y)\n    return abs(det)/2\n}\n</code></pre> </li> </ul> <p>Clase derivada <code>Circulo</code></p> <p>Un c\u00edrculo se define por un centro y un radio. La superclase figura representa el cuadrado m\u00e1s peque\u00f1o en el que est\u00e1 inscrito el c\u00edrculo (ver imagen arriba).</p> <ul> <li>Inicializador:<ul> <li><code>Circulo(centro: Punto, radio: Double)</code>. Al crear el c\u00edrculo   deberemos actualizar las propiedades <code>origen</code> y <code>tama\u00f1o</code> de la   figura.</li> </ul> </li> <li>Propiedades de instancia almacenadas:<ul> <li><code>radio</code> (<code>Double</code>) que contiene la longitud del radio.</li> </ul> </li> <li>Propiedades de instancia calculadas:<ul> <li><code>centro</code> (<code>Punto</code>, de lectura y escritura), heredada de la superclase.</li> <li><code>area</code> (<code>Double</code>, de lectura y escritura) que devuelve el \u00e1rea   del c\u00edrculo. El <code>setter</code> modifica el tama\u00f1o del c\u00edrculo (su   radio), manteniendo el centro en la misma posici\u00f3n.</li> </ul> </li> </ul> <p>Estructura <code>AlmacenFiguras</code></p> <ul> <li>Propiedades almacenadas:<ul> <li><code>figuras</code>: array de figuras.</li> </ul> </li> <li>Propiedades calculadas:<ul> <li><code>numFiguras</code> (<code>Int</code>) que devuelve el n\u00famero total de figuras a\u00f1adidas.</li> <li><code>areaTotal</code> (<code>Double</code>) que devuelve la suma total de las \u00e1reas   de todas las figuras a\u00f1adidas.</li> </ul> </li> <li>M\u00e9todos:<ul> <li><code>a\u00f1ade(figura:)</code> que a\u00f1ade una figura al array.</li> <li><code>desplaza(incX: Double, incY: Double)</code>: desplaza todas las   figuras las dimensiones especificadas <code>incX</code> (incremento en la   coordenada X) e <code>incY</code> (incremento en la coordenada Y). Se   deber\u00e1n mover los centros de todas las figuras en estas magnitudes.</li> </ul> </li> </ul> <p>Implementa las estructuras anteriores y escribe alg\u00fan ejemplo de c\u00f3digo en el que se creen al menos un cuadril\u00e1tero y un c\u00edrculo, se prueben sus propiedades, se a\u00f1adan al almac\u00e9n de figuras y se prueben sus m\u00e9todos.</p> <p>Lenguajes y Paradigmas de Programaci\u00f3n, curso 2024-25 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Domingo Gallardo, Cristina Pomares, Antonio Bot\u00eda, Francisco Mart\u00ednez</p>"},{"location":"practicas/practica12/practica12.html","title":"Pr\u00e1ctica 12: Programaci\u00f3n Orientada a Objetos en Swift (2)","text":""},{"location":"practicas/practica12/practica12.html#antes-de-la-clase-de-practicas","title":"Antes de la clase de pr\u00e1cticas","text":"<p>Los siguientes ejercicios est\u00e1n basados en los conceptos de teor\u00eda vistos la semana pasada. Antes de la clase de pr\u00e1cticas debes repasar todos los conceptos y probar en con el compilador de Swift todos los ejemplos de los siguientes apartados del tema 6 Programaci\u00f3n OO con Swift</p> <ul> <li>Funciones operadoras</li> <li>Protocolos</li> <li>Casting de tipos</li> <li>Gen\u00e9ricos</li> <li>Extensiones</li> </ul>"},{"location":"practicas/practica12/practica12.html#ejercicios","title":"Ejercicios","text":""},{"location":"practicas/practica12/practica12.html#ejercicio-1","title":"Ejercicio 1","text":"<p>a) Completa el c\u00f3digo de la estructura \u200b<code>MiStruct</code>\u200b para que compile correctamente. Hazlo primero en papel y despu\u00e9s pru\u00e9balo en el compilador.</p> <pre><code>protocol A {\n    var a: String {get}\n    func foo(a: String) -&gt; String?\n}\nprotocol B {\n    mutating func bar()\n}\nstruct MiStruct: A, B {\n    // Completa el c\u00f3digo\n}\n</code></pre> <p>b) El siguiente c\u00f3digo tiene errores. Intenta descubrir cu\u00e1les son sin utilizar el compilador. Prueba distintas formas de arreglar el c\u00f3digo cambiando lo m\u00ednimo posible de lo ya definido (por ejemplo, no debes a\u00f1adir nuevas propiedades en <code>MiStruct</code>). Compru\u00e9balo con el compilador.</p> <pre><code>protocol A {\n    var a: String {get set}\n    func foo(a: Int, b: Int) -&gt; Int?\n}\n\nprotocol B {\n    mutating func bar()\n}\n\nstruct MiStruct: A, B {\n    let a = 10\n    func foo(valor1 a: Int, valor2 b: Int) -&gt; Int {\n        let res = a &gt; 10 ? a: b\n        return res\n    }\n}\n</code></pre> <p>c) Supongamos la estructura <code>Equipo</code> que aparece a continuaci\u00f3n que representa un equipo en una competici\u00f3n deportiva: </p> <pre><code>struct Equipo {\n    let puntos: Int\n    let nombre: String\n}\n</code></pre> <p>Modifica la definici\u00f3n para poder comprobar la igualdad de dos equipos y que el siguiente c\u00f3digo funcione correctamente:</p> <pre><code>let equipo1 = Equipo(puntos: 10, nombre: \"H\u00e9rcules\")\nlet equipo2 = Equipo(puntos: 8, nombre: \"Villareal\")\nprint(equipo1 == equipo2) // imprime false\n</code></pre> <p>Despu\u00e9s, modifica el c\u00f3digo otra vez para que la estructura se ajuste tambi\u00e9n al protocolo <code>Comparable</code> para poder comparar dos equipos . Consulta el protocolo en documentaci\u00f3n de Swift. Un equipo ser\u00e1 menor que otro cuando tenga menos puntos. En el caso en que ambos tengan los mismos puntos, ser\u00e1 menor el que tenga menor nombre en orden alfab\u00e9tico.</p> <pre><code>print(equipo1 &gt; equipo2) // imprime true\n</code></pre> <p>Una vez definidos los operadores necesarios comprueba que funcionan correctamente creando varios equipos, insert\u00e1ndolos en un array y llamando al m\u00e9todo <code>sorted</code>.</p>"},{"location":"practicas/practica12/practica12.html#ejercicio-2","title":"Ejercicio 2","text":"<p>a) Completa el siguiente c\u00f3digo para que compile correctamente e imprima lo indicado:</p> <pre><code>struct Cuadrado {\n    var lado: Double\n}\n\n// Completa el c\u00f3digo justo a continuaci\u00f3n,\n// no puedes modificar el c\u00f3digo anterior\n\nvar cuadrado = Cuadrado(lado: 4.0)\nprint(cuadrado.area) // Imprime: 16.0\ncuadrado.lado = 10.0\nprint(cuadrado.area) // Imprime: 100.0\n</code></pre> <p>b) Rellena el siguiente c\u00f3digo para que funcione correctamente:</p> <pre><code>protocol Persona {\n    var nombre: String {get}\n    func encantada() -&gt; Persona \n    func refrescada() -&gt; Persona \n}\n\nenum Pocion {\n    case magica, refrescante, venenosa\n\n    func esBebida(por persona: Persona) -&gt; __________ {\n        ______________ {\n            case _________:\n                return persona.encantada()\n            case _________:\n                return persona.refrescada()\n            default:\n                return nil\n        }\n    }\n}\n</code></pre> <p>c) Completa el c\u00f3digo de la estructura \u200b<code>MiStruct</code> para que compile correctamente:</p> <pre><code>protocol A {\n    var valor: Int {get set}\n    func foo(a: Int) -&gt; Int\n}\nprotocol B {\n    mutating func bar()\n}\nstruct MiStruct: A, B {\n    // Completa el c\u00f3digo\n\n}\n</code></pre> <p>d) Completa el siguiente c\u00f3digo para que compile correctamente e imprima lo indicado:</p> <pre><code>struct Circulo {\n    var radio: Double\n    // Completa el c\u00f3digo\n\n}\n\nlet c1 = Circulo(radio: 5.0)\nlet c2 = Circulo(radio: 10.0)\nlet c3 = c1 + c2\nprint(\"El radio de la suma es: \\(c3.radio)\")\n// Imprime: El radio de la suma es: 15.0\n</code></pre>"},{"location":"practicas/practica12/practica12.html#ejercicio-3","title":"Ejercicio 3","text":"<p>a) Completa el bucle con el c\u00f3digo que comprueba el tipo de la variable <code>i</code> e imprime su propiedad <code>p</code> y su propiedad <code>a1</code> o <code>a2</code>, dependiendo de su tipo.</p> <pre><code>protocol P {\n   var p: Int { get }\n}\nclass A1: P {\n   var p = 0\n   var a1 = 0\n}\nclass A2: P {\n   var p = 1\n   var a2 = 0\n}\n\nvar array: [P] = [A1(), A2()]\nfor i in array {\n\n   // C\u00f3digo a completar\n   //\n}\n\n// debe imprimir:\n// debe imprimir:\n// p: 0, a1: 0\n// p: 1, a2: 0\n</code></pre> <p>b) Completa el c\u00f3digo que hay a continuaci\u00f3n para que compile correctamente y aparezca en pantalla el resultado que se muestra.</p> <pre><code>protocol TieneVelocidad {\n    func velocidadActual () -&gt; Double\n}\n\nclass Vehiculo {\n    var velocidad = 0.0\n    func velocidadActual() -&gt; Double {\n        return velocidad\n    }\n}\n\nclass Tren {\n    static let velocidadEnMarcha = 300.0\n    var pasajeros = 0\n    var enMarcha = false\n}\n\n//\n// C\u00f3digo a completar\n//\n\nvar vehiculo1 = Vehiculo()\nvar tren1 = Tren()\ntren1.enMarcha = true\n\nlet transportes: [TieneVelocidad] = [vehiculo1, tren1]\n\nfor i in transportes {\n    print(i.velocidadActual())\n}\n// 0.0\n// 300.0\n</code></pre>"},{"location":"practicas/practica12/practica12.html#ejercicio-4","title":"Ejercicio 4","text":"<p>Define una estructura <code>Timer</code> con la que podamos ejecutar el siguiente c\u00f3digo sin errores. El temporizador se inicializa con un n\u00famero determinado de segundos y define un m\u00e9todo de instancia <code>paso()</code> que descuenta un segundo. F\u00edjate en el c\u00f3digo y ver\u00e1s que es posible sumar temporizadores. Por \u00faltimo, el atributo del tipo <code>pasosTotales</code> guarda el n\u00famero de pasos que se han realizado en todas las instancias.</p> <pre><code>var t1 = Timer(segundos: 10)\nvar t2 = Timer(segundos: 5)\nfor _ in 0...4 {\n    t1.paso()\n}\nfor _ in 0...2 {\n    t2.paso()\n}\nvar t3 = t1 + t2\nt3.paso()\nprint(\"Segundos del temporizador 1: \\(t1.segundos)\")\nprint(\"Segundos del temporizador 2: \\(t2.segundos)\")\nprint(\"Segundos del temporizador 3: \\(t3.segundos)\")\nprint(\"Pasos totales: \\(Timer.pasosTotales)\")\n// Imprime:\n// Segundos del temporizador 1: 5\n// Segundos del temporizador 2: 2\n// Segundos del temporizador 3: 6\n// Pasos totales: 9\n</code></pre>"},{"location":"practicas/practica12/practica12.html#ejercicio-5","title":"Ejercicio 5","text":"<p>Vamos, por \u00faltimo, con un ejercicio en el que veremos otra forma de trabajar con figuras geom\u00e9tricas.</p>"},{"location":"practicas/practica12/practica12.html#1-completa-el-codigo-inicial","title":"1. Completa el c\u00f3digo inicial","text":"<p>Comienza incluyendo en la pr\u00e1ctica el c\u00f3digo de las definiciones de las estructuras geom\u00e9tricas: <code>Punto</code>, <code>Tama\u00f1o</code>, <code>Rectangulo</code> y <code>Circulo</code>. Debes completar el c\u00f3digo para que haga lo indicado en los comentarios.</p> <pre><code>struct Punto {\n    var x = 0.0, y = 0.0\n}\n\nstruct Tama\u00f1o {\n    var ancho = 0.0, alto = 0.0\n}\n\nstruct Circulo {\n    var centro = Punto()\n    var radio = 0.0\n\n    var area: Double {\n        // Propiedad calculada que devuelve el \n        // \u00e1rea del c\u00edrculo y modifica el radio\n        // cuando se actualiza\n    }\n}\n\nstruct Rectangulo {\n    var origen = Punto()\n    var tama\u00f1o = Tama\u00f1o()\n\n    var centro: Punto {\n        // Propiedad calculada que devuelve el \n        // centro del rect\u00e1ngulo y traslada su\n        // origen cuando se modifica\n    }\n\n    var area: Double {\n        // Propiedad calculada que devuelve el\n        // \u00e1rea del rect\u00e1ngulo\n    }\n}\n</code></pre> <p>Prueba las estructuras escribiendo alg\u00fan c\u00f3digo en el que se creen algunas instancias y se actualicen sus propiedades.</p>"},{"location":"practicas/practica12/practica12.html#2-define-el-protocolo-figura","title":"2. Define el protocolo figura","text":"<p>Define el protocolo <code>Figura</code> que contiene:</p> <ul> <li>Propiedad de lectura y escritura <code>centro</code> (<code>Punto</code>), que define el   centro de la figura.</li> <li>Propiedades de s\u00f3lo lectura <code>area</code> (<code>Double</code>) y <code>tama\u00f1o</code> (<code>Tama\u00f1o</code>)   que devuelven el tama\u00f1o (alto y ancho) de la figura.</li> <li>M\u00e9todo <code>descripcion()</code> que devuelva un <code>String</code> con el centro y el   \u00e1rea de la figura.</li> </ul>"},{"location":"practicas/practica12/practica12.html#3-define-extensiones","title":"3. Define extensiones","text":"<ul> <li> <p>Modifica las estructuras <code>Rectangulo</code> y <code>Circulo</code> para que se ajusten al   protocolo <code>Figura</code>, a\u00f1adiendo el c\u00f3digo de implementaci\u00f3n necesario.</p> </li> <li> <p>Prueba el c\u00f3digo escrito hasta ahora, creando un array del tipo   <code>Figura</code> (el protocolo) y a\u00f1adiendo en \u00e9l c\u00edrculos y rect\u00e1ngulos.</p> </li> </ul>"},{"location":"practicas/practica12/practica12.html#4-estructura-almacenfiguras","title":"4. Estructura <code>AlmacenFiguras</code>","text":"<p>Por \u00faltimo, implementa una estructura <code>AlmacenFiguras</code>.</p> <ul> <li> <p>Debe tener una \u00fanica propiedad <code>figuras</code> que contenga un array de figuras. Como en la pr\u00e1ctica anterior, define en ella el m\u00e9todo <code>a\u00f1ade(figura:)</code> y las propiedades calculadas <code>numFiguras</code> (<code>Int</code>) y <code>areaTotal</code> (<code>Double</code>).</p> </li> <li> <p>Escribe el m\u00e9todo <code>cuentaTipos() -&gt; (Int, Int)</code> que recorra el array de figuras y devuelva una tupla con dos enteros: n\u00famero de rect\u00e1ngulos y n\u00famero de c\u00edrculos. La funci\u00f3n debe imprimir por cada figura del array el tipo de figura, su descripci\u00f3n y, en el caso en que la figura sea un rect\u00e1ngulo, su tama\u00f1o.</p> </li> </ul> <p>Por ejemplo:</p> <pre><code>** Un rect\u00e1ngulo con tama\u00f1o Tama\u00f1o(ancho: 10.0, alto: 5.0) y descripci\u00f3n:\nCentro: Punto(x: 8.0, y: 6.5) y \u00e1rea: 50.0\n** Un c\u00edrculo con descripci\u00f3n:\nCentro: Punto(x: 5.0, y: 0.0) y \u00e1rea: 314.1592653589793\n</code></pre> <ul> <li>Escribe un ejemplo de c\u00f3digo en el que se guarden varias figuras en un almac\u00e9n de figuras y se llame a sus m\u00e9todos.</li> </ul> <p>Lenguajes y Paradigmas de Programaci\u00f3n, curso 2024-25 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Domingo Gallardo, Cristina Pomares, Antonio Bot\u00eda, Francisco Mart\u00ednez</p>"},{"location":"seminarios/seminario1-scheme/seminario1-scheme.html","title":"Seminario 1: Seminario de Scheme","text":""},{"location":"seminarios/seminario1-scheme/seminario1-scheme.html#1-el-lenguaje-de-programacion-scheme","title":"1. El lenguaje de programaci\u00f3n Scheme","text":"<p>Scheme es un lenguaje de programaci\u00f3n que surgi\u00f3 en los laboratorios del MIT en 1975, cuando Guy L. Steele y Gerarld J. Sussman buscaban un lenguaje con una sem\u00e1ntica muy clara y sencilla. </p> <p>Scheme es un dialecto de Lisp, es un lenguaje interpretado, muy expresivo y soporta varios paradigmas. Estuvo influenciado por el c\u00e1lculo lambda. El desarrollo de Scheme ha sido lento, ya que la gente que estandariz\u00f3 Scheme es muy conservadora en cuanto a a\u00f1adirle nuevas caracter\u00edsticas,porque la calidad ha sido siempre m\u00e1s importante que la utilidad empresarial. Por eso Scheme es considerado como uno de los lenguajes mejor dise\u00f1ados de prop\u00f3sito general. Aprender Scheme har\u00e1 que se\u00e1is mejores programadores cuando utilic\u00e9is otros lenguajes de programaci\u00f3n.</p>"},{"location":"seminarios/seminario1-scheme/seminario1-scheme.html#11-el-lenguaje-de-programacion-racket","title":"1.1. El lenguaje de programaci\u00f3n Racket","text":"<p>\u00bfQu\u00e9 vamos a aprender? \u00bfRacket o Scheme? La respuesta es: Scheme trabajando en Racket. </p> <p>Racket se dise\u00f1\u00f3 en 1995 bas\u00e1ndose en Scheme y ampli\u00e1ndolo con nuevas funcionalidades, como la posibilidad de extenderlo con librer\u00edas. El lenguaje contiene librer\u00edas muy \u00fatiles (librer\u00edas gr\u00e1ficas, de conexi\u00f3n a servidores HTTP, de conexi\u00f3n a bases de datos, etc.) con las que se moderniza el lenguaje original y se convierte en un lenguaje pr\u00e1ctico para desarrollar todo tipo de aplicaciones, desde videojuegos a servidores web. Sin embargo, nosotros s\u00f3lo vamos a usar Racket para aprender la parte que corresponde al n\u00facleo original de Scheme.</p>"},{"location":"seminarios/seminario1-scheme/seminario1-scheme.html#12-el-entorno-de-programacion-drracket","title":"1.2. El entorno de programaci\u00f3n DrRacket","text":"<p>Veamos una peque\u00f1a introducci\u00f3n al entorno de programaci\u00f3n que proporciona DrRacket. Puedes encontrar m\u00e1s informaci\u00f3n en la documentaci\u00f3n original.</p>"},{"location":"seminarios/seminario1-scheme/seminario1-scheme.html#121-descarga-de-drracket","title":"1.2.1. Descarga de DrRacket","text":"<p>DrRacket es multiplataforma y puede ejecutarse en Linux, MacOS o Windows. Puedes descargarte la \u00faltima versi\u00f3n en el siguiente enlace:</p> <p>Descarga de DrRacket</p>"},{"location":"seminarios/seminario1-scheme/seminario1-scheme.html#122-configuracion-de-drracket","title":"1.2.2. Configuraci\u00f3n de DrRacket","text":"<p>Para poder trabajar correctamente con DrRacket debemos asegurarnos que el lenguaje activo es <code>The Racket Language</code> y que la sintaxis de la salida tiene activada la opci\u00f3n <code>write</code>, como aparece en la siguiente imagen:</p> <p></p> <p>Podemos modificar esa opci\u00f3n con los siguientes men\u00fas:</p> <p>Language &gt; Choose Language (seleccionamos The Racket Language) &gt; Show details &gt; Output Syntax &gt; write</p> <p>Esta opci\u00f3n determina la sintaxis de la salida del int\u00e9rprete del lenguaje, que va a ser uno de los elementos fundamentales para aprender Scheme.</p> <p>Aviso</p> <p>Una vez seleccionadas estas opciones, la configuraci\u00f3n se guarda en las preferencias del usuario. En los laboratorios de la EPS hay que realizar la configuraci\u00f3n al comienzo de cada sesi\u00f3n.</p> <p>Cuando lanzamos DrRacket, vemos que tiene tres partes: una fila de botones arriba, dos paneles de edici\u00f3n en el medio y una barra de estado abajo.</p> <p></p> <p>El panel de edici\u00f3n superior es la ventana de definiciones. Se utiliza para implementar funciones, como la funci\u00f3n <code>cuadrado</code> en el ejemplo. El panel inferior, llamado ventana de interacci\u00f3n, se utiliza para evaluar expresiones interactivamente, usando el int\u00e9rprete de Racket. Pulsando el bot\u00f3n Run, se eval\u00faa el programa de la ventana de definiciones, haciendo que esas definiciones est\u00e9n disponibles en la ventana de interacci\u00f3n. As\u00ed, dada la definici\u00f3n de <code>cuadrado</code>, despu\u00e9s de pulsar Run, podemos teclear la expresi\u00f3n <code>(cuadrado 2)</code> en el int\u00e9rprete, se evaluar\u00e1 y mostrar\u00e1 el resultado, en este caso 4.</p> <p>DrRacket soporta muchos lenguajes y dialectos de Scheme. Nosotros vamos a utilizar el lenguaje por defecto, el lenguaje Racket. Para ello no es necesario realizar nada, s\u00f3lo asegurarnos de lo siguiente:</p> <ol> <li> <p>En la parte inferior de la ventana aparece    \"Determine language from source\"</p> </li> <li> <p>El fichero que se est\u00e1 editando en el panel de edici\u00f3n comienza con la l\u00ednea:</p> <pre><code>#lang racket\n</code></pre> </li> <li> <p>Finalmente, si pulsamos el bot\u00f3n Run (Ejecutar) comprobaremos que    se carga ese lenguaje en el int\u00e9rprete.</p> </li> </ol> <p></p>"},{"location":"seminarios/seminario1-scheme/seminario1-scheme.html#123-como-escribir-en-el-interprete","title":"1.2.3. C\u00f3mo escribir en el int\u00e9rprete","text":"<p>En la ventana inferior se encuentra el int\u00e9rprete de Racket. El int\u00e9rprete realiza un bucle en el que se lee una expresi\u00f3n, se eval\u00faa su resultado y se imprime. A este tipo de bucle se denomina en ingl\u00e9s REPL (Read-Evaluate-Print Loop).</p> <p>Las expresiones que escribimos en el int\u00e9rprete se guardan en un hist\u00f3rico. Podemos recuperar las expresiones anteriores y movernos por ese hist\u00f3rico usando las siguientes combinaciones de teclas:</p> <ul> <li><code>CTRL</code> + flecha arriba/abajo</li> </ul> <p>Puede ser que esa combinaci\u00f3n de teclas est\u00e9 asignada a otras funciones en tu configuraci\u00f3n de sistema operativo. Puedes cambiar esa configuraci\u00f3n o usar la combinaci\u00f3n alternativa de DrRacket:</p> <ul> <li><code>ESC</code> + <code>p</code> (previous) / <code>n</code> (next)</li> </ul> <p>Tambi\u00e9n podemos seleccionar con el cursor una expresi\u00f3n y al pulsar <code>RETURN</code> se copia autom\u00e1ticamente en el prompt.</p>"},{"location":"seminarios/seminario1-scheme/seminario1-scheme.html#2-el-lenguaje-scheme","title":"2. El lenguaje Scheme","text":""},{"location":"seminarios/seminario1-scheme/seminario1-scheme.html#21-vamos-a-empezar-probando-algunos-ejemplos","title":"2.1. Vamos a empezar probando algunos ejemplos","text":"<p>Scheme es un lenguaje interpretado. Vamos a lanzar DrRacket y teclear en la ventana de interacci\u00f3n algunas expresiones. El int\u00e9rprete analizar\u00e1 la expresi\u00f3n y mostrar\u00e1 el valor resultante de evaluarla.</p> <pre><code>2 ; \u21d2 2\n(+ 2 3) ; \u21d2 5\n(+ (* 2 3) (- 3 1)) ; \u21d2 8\n</code></pre> <p>Las expresiones en Scheme tienen una forma denominada notaci\u00f3n prefija de Cambridge (el nombre de Cambridge es por la localidad Cambridge, Massachusets, donde reside el MIT, lugar en el que se ide\u00f3 el Lisp), en la que la expresi\u00f3n est\u00e1 delimitada por par\u00e9ntesis y el operador va seguido de los operandos. La sintaxis es la siguiente:</p> <pre><code>(&lt;funci\u00f3n&gt; &lt;arg1&gt; ... &lt;argn&gt;)\n</code></pre> <p>En Scheme podemos interpretar los par\u00e9ntesis abiertos \u2018(\u2019 como evaluadores o lanzadores de la funci\u00f3n que hay a continuaci\u00f3n. La forma que tiene Scheme de evaluar una expresi\u00f3n es muy sencilla:</p> <ol> <li>Eval\u00faa cada uno de los argumentos</li> <li>Aplica la funci\u00f3n nombrada tras el par\u00e9ntesis a los valores    resultantes de la evaluaci\u00f3n anterior</li> </ol> <pre><code>(+ (* 2 3) (- 3 (/ 12 3)))\n\u21d2 (+ 6 (- 3 (/ 12 3)))\n\u21d2 (+ 6 (- 3 4))\n\u21d2 (+ 6 -1)\n\u21d2 5\n</code></pre> <p>Existen funciones que admiten un n\u00famero variable de argumentos, como la suma o la resta:</p> <pre><code>(+) ; \u21d2 0\n(+ 2 4 5 6) ; \u21d2 17\n(- 10 2 3) ; \u21d2 5\n</code></pre> <p>En el caso de la resta, los argumentos se van restando de izquierda a derecha (al primer argumento se le resta el segundo, al resultado se le resta el tercero, y as\u00ed sucesivamente):</p> <pre><code>(- 4 5 4 8) ; \u21d2 -13\n(- 4 (+ 5 4) 8) ; \u21d2 -13\n(- 4 (+ 5 4 8)) ; \u21d2 -13\n</code></pre> <p>En Scheme los t\u00e9rminos funci\u00f3n y procedimiento significan lo mismo y se usan de forma intercambiable. Son ejemplos de funciones o procedimientos: +, -, \\, *. En Scheme la evaluaci\u00f3n de una funci\u00f3n siempre devuelve un valor, a no ser que se produzca un error que detiene la evaluaci\u00f3n:</p> <pre><code>(* (+ 3 4) (/ 3 0))\n; Error /: division by zero\n</code></pre>"},{"location":"seminarios/seminario1-scheme/seminario1-scheme.html#22-definiendo-variables-y-funciones","title":"2.2. Definiendo variables y funciones","text":"<p>Scheme es un lenguaje multiparadigma pero principalmente funcional, y una de sus caracter\u00edsticas principales es que los programas se construyen mediante la definici\u00f3n de funciones.</p> <p>Podemos utilizar en el int\u00e9rprete la forma especial <code>define</code> para definir variables y funciones. En clase de teor\u00eda se explica c\u00f3mo es el funcionamiento del <code>define</code>, pero por el momento lo utilizaremos para definir variables asociadas a valores, y para implementar funciones.</p> <p>Podemos definir variables en la ventana de interacci\u00f3n para facilitar la escritura de expresiones:</p> <pre><code>(define a (+ 2 (* 3 4)))\na ; \u21d2 14\n(+ a (* 2 3)) ; \u21d2 20\n</code></pre> <p>Existen identificadores (en Scheme los llamamos s\u00edmbolos) que ya est\u00e1n definidos en el int\u00e9rprete de Racket, por ejemplo <code>pi</code>:</p> <pre><code>pi ; \u21d2 3.141592653589793\n(sin (/ pi 2)) ; \u21d2 1.0\n</code></pre> <p>Para implementar una funci\u00f3n tambi\u00e9n se utiliza define, con la siguiente sintaxis:</p> <pre><code>(define (&lt;nombre-funcion&gt; &lt;args&gt;)\n    &lt;cuerpo-funcion&gt;\n)\n</code></pre> <p>Por ejemplo, vamos a implementar una funci\u00f3n que toma dos n\u00fameros como par\u00e1metros y devuelve la suma de sus cuadrados:</p> <pre><code>(define (suma-cuadrados x y)\n    (+ (* x x) (* y y)))\n</code></pre> <p>Si llamamos a la funci\u00f3n pasando el 2 y el 3 como par\u00e1metros, la funci\u00f3n devuelve el n\u00famero 13:</p> <pre><code>(suma-cuadrados 2 3)  ; \u21d2 13\n</code></pre> <p>Nota</p> <p>A diferencia de la mayor\u00eda de lenguajes de programaci\u00f3n, en Scheme no se utiliza la palabra <code>return</code> para indicar que una funci\u00f3n devuelve un valor. Las funciones se definen con una \u00fanica expresi\u00f3n y el resultado calculado en esa expresi\u00f3n es el que siempre se devuelve.</p>"},{"location":"seminarios/seminario1-scheme/seminario1-scheme.html#23-lenguaje-debilmente-tipado","title":"2.3. Lenguaje d\u00e9bilmente tipado","text":"<p>Vamos a comprobar una caracter\u00edstica muy importante de Scheme: ser un lenguaje d\u00e9bilmente tipado. Por esto entendemos, entre otras cosas, que las variables, funciones y argumentos no tienen un tipo declarado. Es posible usar valores de distintos tipos de datos para asignar sucesivamente a una misma variable (en el caso de un lenguaje imperativo) o para pasar como par\u00e1metro a una misma funci\u00f3n (en el caso de un lenguaje funcional). Por ejemplo, JavaScript o PHP son tambi\u00e9n lenguajes d\u00e9bilmente tipados imperativos.</p> <p>Veamos c\u00f3mo funciona esto en Scheme usando la funci\u00f3n anterior como ejemplo.</p> <pre><code>(define (suma-cuadrados x y)\n   (+ (* x x) (* y y)))\n</code></pre> <p>Vemos que los argumentos <code>x</code> e <code>y</code> no tienen ning\u00fan tipo.  Si se invoca a la funci\u00f3n pasando alg\u00fan dato que no sea un n\u00famero, el int\u00e9rprete no detectar\u00e1 ning\u00fan error y permitir\u00e1 asignar a los argumentos <code>x</code> e <code>y</code> esos datos. El error se produce en el momento en que se intenta evaluar la multiplicaci\u00f3n.</p> <p>Lo podemos comprobar con el siguiente ejemplo, en el que se muestra el mensaje de error resultante:</p> <pre><code>&gt; (suma-cuadrados 10 \"hola\")\n*: contract violation\n  expected: number?\n  given: \"hola\"\n  argument position: 1st\n  other arguments...:\n</code></pre> <p>Veremos m\u00e1s adelante que hay distintos tipos de n\u00fameros que podemos operar usando la divisi\u00f3n, la suma y la multiplicaci\u00f3n. La funci\u00f3n definida va a funcionar bien para todos ello. </p> <p>Podemos pasar a la funci\u00f3n n\u00fameros enteros, n\u00fameros reales o incluso fracciones:</p> <pre><code>(suma-cuadrados 2 5) ; \u21d2 29\n(suma-cuadrados 2.4 5.8)  ; \u21d2 39.4\n(suma-cuadrados (/ 2 3) (/ 3 5))  ; \u21d2 181/225\n</code></pre> <p>En la \u00faltima expresi\u00f3n tambi\u00e9n pueden pasarse directamente los n\u00fameros fracionales, el int\u00e9rprete de Scheme entiende esa notaci\u00f3n:</p> <pre><code>(suma-cuadrados 2/3 3/5) ; \u21d2 181/225\n</code></pre>"},{"location":"seminarios/seminario1-scheme/seminario1-scheme.html#24-tipos-de-datos-simples","title":"2.4. Tipos de datos simples","text":"<p>Las primitivas de Scheme consisten en un conjunto de tipos de datos, formas especiales y funciones incluidas en el lenguaje. A lo largo del curso iremos introduciendo estas primitivas. </p> <p>Vamos a revisar algunos tipos de datos simples de Scheme, as\u00ed como algunas funciones primitivas para trabajar con valores de esos tipos.</p> <ul> <li>Booleanos</li> <li>N\u00fameros</li> <li>Caracteres</li> </ul>"},{"location":"seminarios/seminario1-scheme/seminario1-scheme.html#241-booleanos","title":"2.4.1. Booleanos","text":"<p>Un booleano es un valor de verdad, que puede ser verdadero o falso. En Scheme, tenemos los s\u00edmbolos <code>#t</code> y <code>#f</code> para expresar verdadero y falso respectivamente, pero en muchas operaciones se considera que cualquier valor distinto de <code>#f</code> es verdadero. Ejemplos:</p> <pre><code>#t ; verdadero\n#f ; falso\n(&gt; 3 1.5) ; \u21d2 #t\n(= 3 3.0) ; \u21d2 #t (igualdad matem\u00e1tica)\n(equal? 3 3.0) ; \u21d2 #f (igualdad de tipo)\n(or (&lt; 3 1.5) #t) ; \u21d2 #t\n(and #t #t #f) ; \u21d2 #f\n(not #f) ; \u21d2 #t\n(not 3) ; \u21d2 #f (permite cualquier argumento; \n        ;       s\u00f3lo devuelve #t cuando el argumento es #f)\n</code></pre>"},{"location":"seminarios/seminario1-scheme/seminario1-scheme.html#242-numeros","title":"2.4.2. N\u00fameros","text":"<p>La cantidad de tipos num\u00e9ricos que soporta Scheme es grande, incluyendo enteros de diferente precisi\u00f3n, n\u00fameros racionales, complejos e inexactos. Por ejemplo:</p> <pre><code>(/ 1 3) ; \u21d2 Devuelve la fracci\u00f3n 1/3\n(+ 1/3 1/3) ; \u21d2 2/3\n(+ 2 3 4 2) ; \u21d2 11 (la funci\u00f3n + admite un n\u00famero variable de argumentos)\n(+ 1/3 0.0) ; n\u00famero real con infinita precisi\u00f3n \u21d2 0.3333333333333333 \n(* (+ 1/3 0.0) 3) ; \u21d2 1\n(sqrt -1) ; \u21d2 0+1i (n\u00famero imaginario)\n(+ 3+2i 2-i) ; \u21d2 5+1i (operaciones con n\u00fameros imaginarios)\n</code></pre>"},{"location":"seminarios/seminario1-scheme/seminario1-scheme.html#2421-algunas-primitivas-sobre-numeros","title":"2.4.2.1. Algunas primitivas sobre n\u00fameros","text":"<pre><code>(&lt;= 2 3 3 4 5) ; \u21d2 #t (los argumentos est\u00e1n en orden creciente)\n(max 3 5 10 1000) ; \u21d2 #1000\n(/ 22 4)  ; Devuelve una fracci\u00f3n\n(quotient 22 4) ; \u21d2 5 (cociente de la divisi\u00f3n entera)\n(remainder 22 4) ; \u21d2 2 (resto de la divisi\u00f3n entera)\n(equal? 0.5 (/ 1 2)) ; \u21d2 #f (distintos tipos de datos)\n(= 0.5 (/ 1 2)) ; \u21d2 #t (igualdad matem\u00e1tica)\n(abs (* 3 -2)) ; \u21d2 6 (valor absoluto)\n(sin 2.2) ; relacionados: cos, tan, asin, acos, ata\n(expt 4 2) ; \u21d2 16 (exponente: 4 elevado a 2)\n</code></pre>"},{"location":"seminarios/seminario1-scheme/seminario1-scheme.html#2422-funciones-de-redondeo","title":"2.4.2.2. Funciones de redondeo","text":"<pre><code>; (floor x) devuelve el entero m\u00e1s grande no mayor que x\n; (ceiling x) devuelve el entero m\u00e1s peque\u00f1o no menor que x\n; (truncate x) devuelve el entero m\u00e1s cercano a x cuyo valor absoluto \n;              no es mayor que el valor absoluto de x\n; (round x) devuelve el entero m\u00e1s cercano a x, redondeado\n(floor -4.3)    ; \u21d2 -5.0\n(floor 3.5)     ; \u21d2 3.0\n(ceiling -4.3)  ; \u21d2 -4.0\n(ceiling 3.5)   ; \u21d2 4.0\n(truncate -4.3) ; \u21d2 -4.0\n(truncate 3.5)  ; \u21d2 3.0\n(round -4.3)    ; \u21d2 -4.0\n(round 3.5)     ; \u21d2 4.0\n</code></pre>"},{"location":"seminarios/seminario1-scheme/seminario1-scheme.html#2423-predicados-sobre-numeros","title":"2.4.2.3. Predicados sobre n\u00fameros","text":"<p>Se denominan predicados a funciones que devuelven un booleano. </p> <pre><code>(positive? -4) ; \u21d2 #f (-4 no es positivo)\n(negative? -4) ; \u21d2 #t (-4 es negativo)\n(zero? 0.2) ; \u21d2 #f (comprueba si el resultado es cero)\n(even? 2) ; \u21d2 #t (comprueba si es par)\n(odd? 3) ; \u21d2 #t (comprueba si es impar)\n</code></pre> <p>En Scheme tenemos predicados que nos permiten comprobar el tipo de un par\u00e1metro. En el caso de los n\u00fameros, el tipo de n\u00famero:</p> <pre><code>(number? 1) ; \u21d2 #t (el argumento 1 es un n\u00famero)\n(integer? 2.3) ; \u21d2 #f (el argumento 2.3 no es un entero)\n(integer? 4.0) ; \u21d2 #t (el n\u00famero 4.0 matem\u00e1ticamente es id\u00e9ntico \n               ;        al n\u00famero 4)\n(real? 1) ; \u21d2 #t\n</code></pre>"},{"location":"seminarios/seminario1-scheme/seminario1-scheme.html#243-caracteres","title":"2.4.3. Caracteres","text":"<p>Se soportan caracteres internacionales y se codifican en UTF-8.</p> <pre><code>#\\a\n#\\A\n#\\space\n#\\\u00f1\n#\\\u00e1\n</code></pre>"},{"location":"seminarios/seminario1-scheme/seminario1-scheme.html#2431-operaciones-sobre-caracteres","title":"2.4.3.1. Operaciones sobre caracteres","text":"<pre><code>(char&lt;? #\\a #\\b) ; \u21d2 #t (el car\u00e1cter #\\a es anterior al #\\b)\n(char-numeric? #\\1) ; \u21d2 #t (el car\u00e1cter #\\1 es un n\u00famero)\n(char-alphabetic? #\\3) ; \u21d2 #f (el car\u00e1cter #\\3 es un n\u00famero)\n(char-whitespace? #\\tab) ; \u21d2 #t (el car\u00e1cter tabulador es un espacio\n                         ;        en blanco) \n(char-upper-case? #\\A) ; \u21d2 #t (el car\u00e1cter #\\A es una letra may\u00fascula)\n(char-lower-case? #\\a) ; \u21d2 #t (el car\u00e1cter #\\a es una letra min\u00fascula)\n(char-upcase #\\\u00f1) ; \u21d2 #\\\u00d1 (transforma la letra a may\u00fasculas)\n(char-downcase #\\A) ; \u21d2 #\\a (transforma la letra a min\u00fasculas)\n(char-&gt;integer #\\space) ; \u21d2 32 (el car\u00e1cter espacio ocupa la posici\u00f3n\n                        ;        32 en la lista de caracteres)\n(integer-&gt;char 32) ; \u21d2 #\\space (igual que antes pero a la inversa)\n(char-&gt;integer (integer-&gt;char 5000)) ; \u21d2 5000 \n</code></pre>"},{"location":"seminarios/seminario1-scheme/seminario1-scheme.html#25-tipos-de-datos-compuestos","title":"2.5. Tipos de datos compuestos","text":"<p>Scheme tiene tambi\u00e9n un conjunto de tipos de datos compuestos, que permiten aglutinar elementos simples de los tipos de datos vistos anteriormente.</p> <ul> <li>Cadenas</li> <li>Parejas</li> <li>Listas</li> </ul> <p>Estos dos \u00faltimos los veremos en detalle en futuras clases de teor\u00eda.</p>"},{"location":"seminarios/seminario1-scheme/seminario1-scheme.html#251-cadenas","title":"2.5.1. Cadenas","text":"<p>Las cadenas son secuencias finitas de caracteres.</p> <pre><code>\"hola\"\n\"La palabra \\\"hola\\\" tiene 4 letras\"\n</code></pre>"},{"location":"seminarios/seminario1-scheme/seminario1-scheme.html#constructores-de-cadenas","title":"Constructores de cadenas","text":"<pre><code>(make-string 5 #\\o) ; \u21d2 \"ooooo\" (funci\u00f3n constructora que recibe un\n                    ;            entero y un car\u00e1cter) \n(string #\\h #\\o #\\l #\\a) ; \u21d2 \"hola\" (funci\u00f3n constructora que recibe\n                         ;           un n\u00famero variable de caracteres) \n</code></pre>"},{"location":"seminarios/seminario1-scheme/seminario1-scheme.html#operaciones-con-cadenas","title":"Operaciones con cadenas","text":"<pre><code>(substring \"Hola que tal\" 2 4) ; \u21d2 \"la\" (subcadena que va de la\n                               ;      posici\u00f3n 2 a la 4, sin llegar a ella) \n(string? \"hola\") ; \u21d2 #t (predicado que comprueba que el argumento es\n                 ;       una cadena) \n(string-&gt;list \"hola\") ; \u21d2  (#\\h #\\o #\\l #\\a) (devuelve una lista de\n                      ;     caracteres) \n(string-length \"hola\") ; \u21d2 4 (longitud de la cadena)\n(string-ref \"hola\" 0) ; \u21d2 #\\h (car\u00e1cter en la posici\u00f3n 0)\n(string-append \"hola\" \"adios\") ; \u21d2 \"holaadios\" (concatenaci\u00f3n de cadenas) \n</code></pre>"},{"location":"seminarios/seminario1-scheme/seminario1-scheme.html#comparadores-de-cadenas","title":"Comparadores de cadenas","text":"<pre><code>(string=? \"Hola\" \"hola\") ; \u21d2 #f \n(string=? \"hola\" \"hola\") ; \u21d2 #t \n(string&lt;? \"aab\" \"cde\") ; \u21d2 #t (se compara usando el orden lexicogr\u00e1fico)\n(string&gt;=? \"www\" \"qqq\") ; \u21d2 #t\n</code></pre>"},{"location":"seminarios/seminario1-scheme/seminario1-scheme.html#252-parejas","title":"2.5.2. Parejas","text":"<p>Elemento fundamental de Scheme. Es un tipo compuesto formado por dos elementos (no necesariamente del mismo tipo).</p> <pre><code>(cons 1 2) ; \u21d2 (1 . 2) (cons crea una pareja)\n(cons #t 3) ; \u21d2 (#t . 3) (elementos de tipos diferentes)\n(car (cons \"hola\" 2)) ; \u21d2 \"hola\" (elemento izquierdo de la pareja)\n(cdr (cons \"bye\" 5)) ; \u21d2 5 (elemento derecho de la pareja)\n</code></pre> <p>Cuando evaluamos las expresiones anteriores en el int\u00e9rprete, Scheme muestra el resultado de construir la pareja con la sintaxis:</p> <pre><code>(elemento izquierdo . elemento derecho)\n</code></pre> <p>Por ejemplo:</p> <pre><code>(cons 1 2) ; \u21d2 (1 . 2)\n</code></pre> <p>La caracter\u00edstica de Scheme de que las expresiones se eval\u00faan de dentro a afuera se aplica a todas las funciones, incluyendo esta funci\u00f3n <code>cons</code> que construye parejas:</p> <pre><code>(cons (+ 2 3) (string-append \"hola\" \"adios\")) ; \u21d2 (5 . \"holaadios\")\n(cons (= 2 2.0) (* 2 (+ 1 3))) ; \u21d2 (#t . 8)\n</code></pre> <p>Las parejas pueden contener tambi\u00e9n otras parejas. Veremos que esta es la forma de definir estructuras de datos en Scheme:</p> <pre><code>(define p1 (cons 1 2)) ; definimos una pareja formada por 1 y 2\n(cons p1 3)            ; definimos una pareja formada por la pareja (1 . 2) y 3\n                       ; \u21d2 ((1 . 2) . 3)\n(cons (cons 1 2) 3)    ; igual que la expresi\u00f3n anterior\n                       ; \u21d2 ((1 . 2) . 3)\n</code></pre> <p>Hay veces que el trabajo de imprimir una pareja no es tan sencillo para Scheme. Si la pareja est\u00e1 en la parte derecha de la pareja principal el int\u00e9rprete imprime esto, que no se corresponde con lo que esperamos:</p> <pre><code>(cons 1 (cons 2 3)) ; \u21d2 (1 2 . 3)\n</code></pre> <p>M\u00e1s adelante explicaremos por qu\u00e9.</p>"},{"location":"seminarios/seminario1-scheme/seminario1-scheme.html#253-listas","title":"2.5.3. Listas","text":"<p>Uno de los elementos fundamentales de Scheme, y de Lisp, son las listas. Es un tipo compuesto formado por un conjunto finito de elementos (no necesariamente del mismo tipo). Vamos a ver c\u00f3mo definir, crear, recorrer y concatenar listas:</p> <p>Podemos crear una lista con la funci\u00f3n <code>list</code>:</p> <pre><code>(list 1 2 3 4)     ;list crea una lista\n</code></pre> <p>Las listas se representan entre par\u00e9ntesis:</p> <pre><code>(list 1 2 3 4) ;  \u21d2 (1 2 3 4)\n</code></pre> <p>La forma m\u00e1s sencilla de trabajar con una lista es usando las funciones <code>first</code> para obtener su primer elemento y <code>rest</code> para obtener el resto de la lista.</p> <pre><code>(define l1 (list 1 2 3 4)) ; se crea la lista (1 2 3 4) y se guarda en l1\n(first l1)  ; \u21d2 1 (primer elemento de l1)\n(rest l1)  ; \u21d2 (2 3 4) (resto de la lista, resultado de quitar a la\n          ;           lista su primer elemento)\n</code></pre> <p>Las operaciones sobre listas construyen listas nuevas y no modifican la lista que se pasa como argumento. En el ejemplo anterior, la lista <code>l1</code> sigue conteniendo la lista original <code>(1 2 3 4)</code>.</p> <p>El <code>rest</code> de una lista siempre devuelve otra lista. El <code>rest</code> de una lista de un elemento es la lista vac\u00eda, que en Scheme se representa con <code>()</code>. </p> <pre><code>(define l2 (list 1 2 3))\n(rest l2) ; \u21d2 (2 3) \n(rest (rest l2)) ; \u21d2 (3) \n(rest (rest (rest l2))) ; \u21d2 () lista vac\u00eda\nnull ; \u21d2 () lista vac\u00eda\n</code></pre> <p>En Racket se define tambi\u00e9n el identificador <code>null</code> que tiene como valor la lista vac\u00eda:</p> <pre><code>null ; \u21d2 () lista vac\u00eda\n</code></pre> <p>En Scheme las listas se implementan con parejas. Una lista es, o bien una lista vac\u00eda <code>()</code> o bien una pareja cuyo primer elemento es el primer elemento de la lista y su segundo elemento es el resto de la lista. Veremos esto con m\u00e1s detalle m\u00e1s adelante.</p> <p>Dado que una lista se implementa con una pareja, las funciones <code>car</code> y <code>cdr</code> tambi\u00e9n se pueden usar con listas. La funci\u00f3n <code>car</code> nos devuelve el primer elemento de la lista y la funci\u00f3n <code>cdr</code> el resto:</p> <pre><code>(define l3 (list 10 20 30 40)) ; \n(car l3)  ; \u21d2 10\n(cdr l3)  ; \u21d2 (20 30 40)\n</code></pre> <p>Otra forma de definir una lista es usando el <code>quote</code>, una comilla colocada al comienzo de la lista. Veremos en teor\u00eda una explicaci\u00f3n m\u00e1s detallada de c\u00f3mo funciona este <code>quote</code>.</p> <p>Por ejemplo, podemos definir listas usando las las siguientes expresiones:</p> <pre><code>'(1 2 3) ; \u21d2 Construye la lista (1 2 3)\n(rest '(1 2 3)) ; \u21d2 (2 3)\n(define l3 '(1 2 3)) ; Construye la lista (1 2 3) y la guarda en l3\n</code></pre> <p>Durante el seminario usaremos tanto la funci\u00f3n <code>list</code> como el <code>quote</code> para construir listas.</p> <p>La funci\u00f3n <code>list</code> sin argumentos devuelve una lista vac\u00eda y la funci\u00f3n <code>null?</code> comprueba si una lista es vac\u00eda. La lista vac\u00eda tambi\u00e9n se puede definir usando <code>quote</code>: <code>'()</code>. </p> <p>Veremos m\u00e1s adelante que la lista vac\u00eda es el caso base de gran parte de funciones recursivas que recorren listas.</p> <pre><code>(list) ; \u21d2 () \n(null? (list)) ; \u21d2 #t\n(null? '())    ; \u21d2 #t\n(null? (list 1 2 3)) ; \u21d2 #f\n</code></pre> <p>Tambi\u00e9n podemos construir una nueva lista a\u00f1adiendo un elemento a la cabeza de una lista existente, usando la funci\u00f3n <code>cons</code> (la misma funci\u00f3n sobre pareja) usando como par\u00e1metro un elemento y una lista:</p> <pre><code>(cons elemento lista) \n</code></pre> <p>Por ejemplo:</p> <pre><code>(cons 1 '(2 3 4 5))  ; \u21d2 (1 2 3 4 5) (se a\u00f1ade 1 a la cabeza de \n                         ;   la lista (2 3 4 5)\n(cons 1 '())  ; \u21d2 (1) (se a\u00f1ade 1 a la lista vac\u00eda\n(cons 1 (cons 2 (list))) ; \u21d2 (1 2) \n(cons 1 (cons 2 (cons 3 '()))) ; \u21d2 (1 2 3)\n</code></pre> <p>Importante</p> <p>Cuando queramos a\u00f1adir un dato a la cabeza de una lista la lista siempre debe ser el segundo par\u00e1metro de la llamada a la funci\u00f3n. Si nos equivocamos y pasamos la lista como primer par\u00e1metro y el dato a a\u00f1adir como segundo, Scheme no da un error sino que construye una pareja cuyo primer elemento es una lista y su segundo elemento es el dato.</p> <p>Por ejemplo:</p> <pre><code>(cons '(1 2 3) 4) ; \u21d2 ((1 2 3) . 4)\n</code></pre> <p>Tambi\u00e9n podemos usar la funci\u00f3n <code>append</code> para concatenar dos o m\u00e1s listas</p> <pre><code>(define l3 (list 1))\n(define l4 (list 2 3 4))\n(define l5 (list 5 6))\n(append l3 l4 l5) ; \u21d2 (1 2 3 4 5 6)\n(append l3 '()) ; \u21d2 (1)\n(append (list 1 2 3) (list 4)) ; \u21d2 (1 2 3 4)\n</code></pre> <p>Nota</p> <p>Si queremos a\u00f1adir un dato al final de una lista podemos hacerlo convirti\u00e9ndolo en una lista y usando <code>append</code> para concatenar la lista resultante al final de la primera:</p> <pre><code>;;; Definimos la funci\u00f3n cons-al-final\n(define (a\u00f1ade-al-final x lista)\n   (append lista (list x)))\n\n;;; La probamos\n(a\u00f1ade-al-final 10 (list 1 2 3)) ; \u21d2 (1 2 3 10)\n</code></pre> <p>Igual que las parejas, las listas pueden contener distintos tipos de datos:</p> <pre><code>(list \"hola\" \"que\" \"tal\") ; \u21d2 (\"hola\" \"que\" \"tal\") (lista de cadenas)\n(cons \"hola\" (list #t #\\a 3 4))  ; \u21d2 (\"hola\" #t #\\a 3 4) lista de distintos\n                              ;   tipos de datos)\n</code></pre> <p>Una lista puede incluso contener otras listas:</p> <pre><code>(list (list 1 2) 3 4 (list 5 6)) ; \u21d2 ((1 2) 3 4 (5 6)) (lista que contiene listas)\n'((1 2) 3 4 (5 6))               ; \u21d2 La misma lista, definida con quote\n(cons (list 1 2) (list 3 4 5))   ; \u21d2 ((1 2) 3 4 5)) (se a\u00f1ade una\n                                 ;    lista como primer elemento)\n(cons '(1 2) '(3 4 5))           ; \u21d2 La misma expresi\u00f3n anterior, con quote\n</code></pre> <p>La caracter\u00edstica de Scheme de que las expresiones se eval\u00faan de dentro a afuera se aplica a todas las funciones, incluyendo est\u00e1 funci\u00f3n <code>list</code> que construye listas:</p> <pre><code>(list (+ 1 2) (string-append \"hola\" \"adios\") (* 2 3)) ; \u21d2 (3 \"holaadios\" 6)\n(list (cons 1 2) (cons 3 4)) ; \u21d2 ((1 . 2) (3 . 4)) (lista que contiene parejas)\n</code></pre> <p>En clase de teor\u00eda estudiaremos con m\u00e1s profundidad las listas en Scheme, c\u00f3mo est\u00e1n implementadas y c\u00f3mo se utilizan para crear otras estructuras de datos m\u00e1s complejas como \u00e1rboles. Para este seminario de introducci\u00f3n es suficiente con estas funciones b\u00e1sicas que nos permiten crear, combinar y obtener elementos de listas.</p>"},{"location":"seminarios/seminario1-scheme/seminario1-scheme.html#3-estructuras-de-control","title":"3. Estructuras de control","text":"<p>Como en cualquier lenguaje de programaci\u00f3n, las estructuras de control en Scheme nos permiten seleccionar qu\u00e9 parte de una expresi\u00f3n evaluamos en funci\u00f3n de la evaluaci\u00f3n de una expresi\u00f3n condicional. Las estructuras de control las veremos con m\u00e1s detenimiento en las clases de teor\u00eda, ahora por el momento vamos a ver ejemplos de funcionamiento.</p> <p>En Scheme tenemos dos tipos de estructuras de control: <code>if</code> y <code>cond</code>.</p>"},{"location":"seminarios/seminario1-scheme/seminario1-scheme.html#31-if","title":"3.1. if","text":"<p>Realiza una evaluaci\u00f3n condicional de las expresiones que la siguen, seg\u00fan el resultado de una condici\u00f3n. Una expresi\u00f3n <code>if</code> tiene siempre cuatro elementos: el propio <code>if</code>, la condici\u00f3n, la expresi\u00f3n que se eval\u00faa si la condici\u00f3n es verdadera y la expresi\u00f3n que se eval\u00faa si la expresi\u00f3n es falsa:</p> <pre><code>(if (&gt; 2 3) \"2 es mayor que 3\" \"2 es menor o igual que 3\")\n</code></pre> <p>Al escribir c\u00f3digo en Scheme es habitual colocar el <code>if</code> y la condici\u00f3n en una l\u00ednea y las otras dos expresiones en las siguientes l\u00edneas:</p> <pre><code>(if (&gt; 2 3)\n    \"2 es mayor que 3\"\n    \"2 es menor o igual que 3\")\n</code></pre> <p>En las expresiones que devuelven el valor cuando la condici\u00f3n es cierta o falsa se puede escribir cualquier expresi\u00f3n de Scheme, incluido otro <code>if</code>:</p> <pre><code>(if (&gt; 2 3)\n    (if (&lt; 10 5)\n        \"2 es mayor que 3 y 10 es menor que 5\"\n        \"2 es mayor que 3 y 10 es mayor o igual que 5\")\n    \"2 es menor o igual que 3\")\n</code></pre> <p>Un ejemplo en el que vemos una funci\u00f3n que contiene un <code>if</code>. La siguiente funci\u00f3n de tres argumentos devuelve la suma de los \u00faltimos si el primero es positivo o la resta en caso contrario:</p> <pre><code>(define (suma-si-x-positivo x y z)\n    (if (&gt;= x 0)\n        (+ y z)\n        (- y z)))\n\n(suma-si-x-positivo 2 3 5) ; \u21d2 8\n(suma-si-x-positivo -3 3 5) ; \u21d2 -2\n</code></pre>"},{"location":"seminarios/seminario1-scheme/seminario1-scheme.html#32-cond","title":"3.2. cond","text":"<p>Cuando tenemos un conjunto de alternativas o para evitar usar ifs anidados.  <code>cond</code> eval\u00faa una serie de condiciones y devuelve el valor de la expresi\u00f3n asociada a la primera condici\u00f3n verdadera.</p> <pre><code>(cond\n    ((&gt; 3 4) \"3 es mayor que 4\")\n    ((&lt; 2 1) \"2 es menor que 1\")\n    ((&gt; 3 2) \"3 es mayor que 2\")\n    (else \"ninguna condicion es cierta\"))\n</code></pre>"},{"location":"seminarios/seminario1-scheme/seminario1-scheme.html#4-comentarios","title":"4. Comentarios","text":"<p>Para comentar una l\u00ednea de c\u00f3digo en la ventana de definiciones, se escribe el s\u00edmbolo punto y coma <code>;</code> al comienzo de la l\u00ednea.  Si queremos comentar m\u00e1s de una l\u00ednea, podemos utilizar el men\u00fa de DrRacket: seleccionamos las l\u00edneas a comentar y pinchamos en la opci\u00f3n Racket -&gt; comentar con punto y coma.</p>"},{"location":"seminarios/seminario1-scheme/seminario1-scheme.html#5-ejemplos-completos","title":"5. Ejemplos completos","text":""},{"location":"seminarios/seminario1-scheme/seminario1-scheme.html#51-raiz-de-segundo-grado","title":"5.1. Ra\u00edz de segundo grado","text":"<p>Vamos a resolver la ecuaci\u00f3n de segundo grado en Scheme. Vamos a implementar el procedimiento <code>(ecuacion a b c)</code> que devuelva una pareja con las dos ra\u00edces de la soluci\u00f3n. Nos vamos a ayudar de funciones auxiliares.</p> <p>Recordamos la f\u00f3rmula:</p> x = {-b \\pm \\sqrt{b^2-4ac} \\over 2a} <p>Nota</p> <p>En lugar de definir una funci\u00f3n con una expresi\u00f3n muy larga compuesta de muchas expresiones anidadas, vamos a implementar la soluci\u00f3n de forma modular, definiendo funciones auxiliares.</p> <p>Primer definimos la funci\u00f3n que define el discriminante:</p> <pre><code>(define (discriminante a b c)\n    (- (* b b) (* 4 a c)))\n</code></pre> <p>Despu\u00e9s definimos las funciones que devuelven la ra\u00edz positiva y la ra\u00edz negativa, usando la funci\u00f3n <code>discriminante</code> anterior:</p> <pre><code>(define (raiz-pos a b c)\n    (/ (+ (* b -1) (sqrt (discriminante a b c))) (* 2 a)))\n\n(define (raiz-neg a b c)\n    (/ (- (* b -1) (sqrt (discriminante a b c))) (* 2 a)))\n</code></pre> <p>Por \u00faltimo, definimos la funci\u00f3n <code>ecuacion</code> que invoca a las funciones anteriores y devuelve una pareja con los valores resultantes:</p> <pre><code>(define (ecuacion a b c)\n    (cons (raiz-pos a b c) (raiz-neg a b c)))\n</code></pre> <p>Lo probamos:</p> <pre><code>(ecuacion 1 -5 6)\n; \u21d2 (3 . 2)\n(ecuacion 2 -7 3)\n; \u21d2 (3 . 1/2)\n(ecuacion -1 7 -10)\n; \u21d2 (2 . 5)\n</code></pre>"},{"location":"seminarios/seminario1-scheme/seminario1-scheme.html#52-conversion-de-grados-celsius-a-farenheit","title":"5.2. Conversi\u00f3n de grados Celsius a Farenheit","text":"<p>Vamos a definir una funci\u00f3n llamada <code>convertir-temperatura</code> que permite realizar una conversi\u00f3n de grados Fahrenheit a Cent\u00edgrados o vicerversa.</p> <p>La funci\u00f3n toma dos argumentos, el primero ser\u00e1 un n\u00famero que representa los grados y el segundo ser\u00e1 un car\u00e1cter (<code>F</code> o <code>C</code>) que indica la unidad de medida en la que est\u00e1n expresados los grados.</p> <p>Las f\u00f3rmulas de conversi\u00f3n son las siguientes:</p> C = (F - 32) * 5/9 F = (C * 9/5) + 32 <p>Primero definimos unas funciones auxiliares que calculan las expresiones anteriores:</p> <pre><code>(define (a-grados-fahrenheit grados-centigrados)\n  (+ (* (/ 9 5) grados-centigrados) 32))\n\n(define (a-grados-centigrados grados-fahrenheit)\n  (* (/ 5 9) (- grados-fahrenheit 32)))\n</code></pre> <p>Y ahora ya podemos definir la funci\u00f3n principal:</p> <pre><code>(define (convertir-temperatura grados tipo)\n  (cond ((equal? tipo #\\F) \n         (list (a-grados-centigrados grados) \"grados centigrados\"))\n        ((equal? tipo #\\C) \n         (list (a-grados-fahrenheit grados) \"grados fahrenheit\"))\n        (else \"tipo de cambio incorrecto\")))\n</code></pre> <p>Por ejemplo:</p> <pre><code>(convertir-temperatura 50 #\\F) ; \u21d2 (10 \"grados centigrados\")\n(convertir-temperatura 50 #\\C) ; \u21d2 (122 \"grados fahrenheit\")\n</code></pre>"},{"location":"seminarios/seminario1-scheme/seminario1-scheme.html#6-pruebas-unitarias-en-scheme","title":"6. Pruebas unitarias en Scheme","text":"<p>Para verificar que las funciones que definimos tienen un funcionamiento correcto, es decir, \"hacen lo que tienen que hacer\", podemos dise\u00f1ar distintos casos de prueba. Cada caso de prueba se caracteriza por unos datos de entrada de la funci\u00f3n y por el resultado que esperamos que devuelva dicha funci\u00f3n con esos valores de entrada.</p> <p>Por ejemplo, en las pruebas de la funci\u00f3n convertir-temperatura, hemos dise\u00f1ado dos casos de prueba:</p> Datos de Entrada Resultado Esperado 50 ,     #\\F (10 \"grados centigrados\") 50 ,     #\\C (122 \"grados fahrenheit\") <p>El resultado esperado a partir de unos valores concretos de entrada, se determina entendiendo qu\u00e9 debe hacer la funci\u00f3n. Es decir, se obtiene a partir de la especificaci\u00f3n del problema, antes de plantearnos c\u00f3mo solucionarlo.</p> <p>Os aconsejamos tener siempre presente la siguiente idea aunque resulte obvia:</p> <p>Para implementar una funci\u00f3n, primero es imprescindible entender qu\u00e9 debe hacer la funci\u00f3n. Despu\u00e9s, seremos capaces de dise\u00f1ar casos de prueba y ocuparnos de c\u00f3mo implementarla.</p> <p>En las pr\u00e1cticas de la asignatura, para realizar pruebas usaremos la librer\u00eda RackUnit. </p> <p>Para ello, lo primero que tendremos que hacer es importar esta nueva librer\u00eda. Por tanto, debemos a\u00f1adir en nuestros ficheros de pr\u00e1cticas lo siguiente:</p> <pre><code>#lang racket\n(require rackunit)\n</code></pre> <p>Una vez importada la librer\u00eda, ya podemos hacer uso de algunas de sus funciones. En concreto, utilizaremos las siguientes:</p> <ul> <li>check-true</li> </ul> <pre><code>(check-true expr)   \n;; Comprueba si su argumento es #t.\n;; En caso contrario, se imprime un mensaje de error.\n</code></pre> <ul> <li>check-false</li> </ul> <pre><code>(check-false expr)   \n;; Comprueba si su argumento es #f.\n;; En caso contrario, se imprime un mensaje de error.\n</code></pre> <ul> <li>check-equal?</li> </ul> <pre><code>(check-equal? resultado-real resultado-esperado)   \n;; Comprueba si sus dos argumentos son iguales.\n;; En caso contrario, se imprime un mensaje de error.\n</code></pre> <p>Con las funciones check-true y check-false validaremos predicados (recuerda que en Scheme son funciones que devuelven un valor booleano) que hayamos implementado, comprobando si el resultado esperado es true o false, respectivamente.</p> <p>Con la funci\u00f3n check-equal? podremos validar si el resultado de la invocaci\u00f3n a la funci\u00f3n con unos determinados valores de entrada, representado por el argumento resultado-real, es igual al resultado que esperamos, dado por el argumento resultado-esperado.</p>"},{"location":"seminarios/seminario1-scheme/seminario1-scheme.html#61-ejemplo-de-pruebas-de-la-funcion-ecuacion-definida-anteriormente","title":"6.1. Ejemplo de pruebas de la funci\u00f3n <code>ecuacion</code> definida anteriormente","text":"<p>Supongamos la funci\u00f3n completa <code>ecuacion</code>, con pruebas incluidas:</p> <pre><code>#lang racket\n(require rackunit)\n\n(define (discriminante a b c)\n    (- (* b b) (* 4 a c)))\n\n(define (raiz-pos a b c)\n    (/ (+ (* b -1) (sqrt (discriminante a b c))) (* 2 a)))\n\n(define (raiz-neg a b c)\n    (/ (- (* b -1) (sqrt (discriminante a b c))) (* 2 a)))\n\n(define (ecuacion a b c)\n    (cons (raiz-pos a b c) (raiz-neg a b c)))\n\n(check-equal? (ecuacion 1 -5 6) '(3 . 2))\n(check-equal? (ecuacion 2 -7 3) '(3 . 1/2))\n(check-equal? (ecuacion -1 7 -10) '(2 . 5))\n</code></pre> <p>Las pruebas anteriores no mostrar\u00e1n ning\u00fan mensaje de error, lo que significa que nuestra funci\u00f3n ecuacion es 'CORRECTA' para estas pruebas, es decir, que con los valores de entrada utilizados, su resultado se corresponde con el esperado.</p> <p>Ahora vamos a suponer que nos hemos equivocado en la definici\u00f3n de la funci\u00f3n ecuacion, por ejemplo en el orden de los argumentos al invocar a la funci\u00f3n auxiliar raiz-pos, en la llamada que se hace en la parte izquierda de la pareja resultante.</p> <pre><code>(define (ecuacion a b c)\n    (cons (raiz-pos b a c) (raiz-neg a b c)))\n</code></pre> <p>Con esta nueva definici\u00f3n, cuando ejecutemos el programa (pulsando el bot\u00f3n Run) aparecer\u00e1 el siguiente mensaje:</p> <pre><code>--------------------\nFAILURE\nactual:     (-1 . 2)\nexpected:   (3 . 2)\nname:       check-equal?\nlocation:   (#&lt;path:/.../filename.rkt&gt;)\nexpression: (check-equal? (ecuacion 1 -5 6) (cons 3 2))\n--------------------\n</code></pre> <p>Esta prueba muestra un mensaje de error, lo que significa que la nueva definici\u00f3n de ecuacion 'FALLA', es decir, que el resultado que devuelve (-1 . 2) no coincide con el resultado esperado (3 . 2).</p>"},{"location":"seminarios/seminario1-scheme/seminario1-scheme.html#7-bibliografia","title":"7. Bibliograf\u00eda","text":"<p>Este seminario est\u00e1 basado en los siguientes materiales. Os recomendamos que les ech\u00e9is un vistazo y, si os interesa y os queda tiempo, que explor\u00e9is tambi\u00e9n en los enlaces que hemos dejado en los apuntes para ampliar informaci\u00f3n.</p> <ul> <li>The Racket Guide</li> <li>The Racket Reference</li> <li>Simply Scheme</li> </ul> <p>Lenguajes y Paradigmas de Programaci\u00f3n, curso 2025-26 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Domingo Gallardo, Cristina Pomares, Antonio Bot\u00eda, Francisco Mart\u00ednez</p>"},{"location":"seminarios/seminario2-swift/seminario2-swift.html","title":"Seminario 2: Seminario de Swift","text":""},{"location":"seminarios/seminario2-swift/seminario2-swift.html#el-lenguaje-de-programacion-swift","title":"El lenguaje de programaci\u00f3n Swift","text":"<p>Swift es un lenguaje de programaci\u00f3n compilado, de prop\u00f3sito general y multi-paradigma desarrollado por Apple. Swift se present\u00f3 en la Conferencia de Desarrolladores de Apple (WWDC) de 2014. Durante el a\u00f1o 2014 se desarroll\u00f3 la versi\u00f3n 1.2 y en la WWDC 2015 se present\u00f3 Swift 2, una actualizaci\u00f3n importante del lenguaje. Inicialmente fue un lenguaje propietario, pero el 3 de diciembre de 2015 se hizo open source bajo la licencia Apache 2.0, para las plataformas Apple y Linux. Los cambios en el lenguaje son propuestos y discutidos por la comunidad en un proceso denominado Swift evolution. </p> <p>La siguiente descripci\u00f3n se ha extra\u00eddo del repositorio GitHub de Swift:</p> <p>Swift es un lenguaje de programaci\u00f3n de sistemas de alta eficiencia. Tiene una sintaxis limpia y moderna, ofrece acceso transparente a c\u00f3digo y librer\u00edas existentes en C y Objective-C, y es seguro en el uso de memoria (memory safe).</p> <p>Aunque est\u00e1 inspirado en Objective-C y en muchos otros lenguajes, Swift no es en si mismo un lenguaje derivado de C. Como lenguaje completo e independiente, Swift proporciona caracter\u00edsticas fundamentales como control de flujo, estructuras de datos y funciones, junto con construcciones de alto nivel como objetos, protocolos, clausuras y gen\u00e9ricos. Swift se apoya en m\u00f3dulos, eliminando la necesidad de cabeceras y la duplicaci\u00f3n de c\u00f3digo que \u00e9stas inducen.</p> <p>En los primeros a\u00f1os de vida del lenguaje se introdujeron cambios muy fuertes, increment\u00e1ndose en a\u00f1os consecutivos el n\u00famero de versi\u00f3n mayor y rompiendo la compatibilidad del c\u00f3digo fuente con las versiones anteriores. Sin embargo, en los \u00faltimos a\u00f1os el lenguaje ha madurado y llevamos varios a\u00f1os con incrementos s\u00f3lo de versiones menores de la versi\u00f3n mayor 5. En la actualidad se ha lanzado la versi\u00f3n 5.8, pero puedes seguir perfectamente la asignatura y las pr\u00e1cticas con cualquier versi\u00f3n 5.x.</p>"},{"location":"seminarios/seminario2-swift/seminario2-swift.html#ejecucion-de-programas-swift","title":"Ejecuci\u00f3n de programas Swift","text":"<p>Es posible descargar el compilador de Swift en los sistemas operativos Mac (utilizando el entorno de desarrollo Xcode) o Linux.</p> <p>A continuaci\u00f3n explicamos las distintas formas de ejecutar programas Swift.</p>"},{"location":"seminarios/seminario2-swift/seminario2-swift.html#ejecucion-on-line","title":"Ejecuci\u00f3n on-line","text":"<p>Existen varios sitios on-line en los que es posible ejecutar c\u00f3digo Swift. Recomendamos:</p> <ul> <li>Swift My Compiler.</li> </ul> <p></p> <ul> <li>Swift Playground Online IDE Pro.</li> </ul> <p></p> <ul> <li>Online Swift Playground. </li> </ul> <p></p>"},{"location":"seminarios/seminario2-swift/seminario2-swift.html#instalacion-en-linux-ubuntu","title":"Instalaci\u00f3n en Linux Ubuntu","text":"<p>Existen distribuciones oficiales de Swift para Linux 22.04 y 24.04.</p> <p>Brevemente, los pasos para su instalaci\u00f3n son los siguientes:</p> <ol> <li> <p>Confirmar que los paquetes de la instalaci\u00f3n de Linux est\u00e1n actualizados:</p> <pre><code>$ sudo apt-get update\n$ sudo apt-get upgrade\n</code></pre> </li> <li> <p>Instalar las dependencias que encontrar\u00e1s en la p\u00e1gina web oficial de Apple usando <code>apt-get install</code>. Necesitar\u00e1s tener permisos de super usuario para hacerlo: <code>sudo apt-get install</code>.</p> <p>Cuidado</p> <p>Dependiendo de tu versi\u00f3n de Linux deber\u00e1s descargarte unas dependencias distintas. Mira bien en la p\u00e1gina de Apple el comando <code>apt-get install</code> concreto que debes ejecutar seg\u00fan tu versi\u00f3n.  Mira las dependencias para tu versi\u00f3n en la p\u00e1gina Swift oficial.</p> </li> <li> <p>Descargar la versi\u00f3n y plataforma deseada (fichero <code>swift-&lt;VERSION&gt;-&lt;PLATFORM&gt;.tar.gz</code>). Por ejemplo, los siguientes comandos se descargan la versi\u00f3n 6.0.3 de Swift de las distintas distribuciones de Ubuntu. </p> <ul> <li> <p>Ubuntu 22.04:</p> <p><pre><code>$ wget https://download.swift.org/swift-6.0.3-release/ubuntu2204/swift-6.0.3-RELEASE/swift-6.0.3-RELEASE-ubuntu22.04.tar.gz\n</code></pre>     - Ubuntu 24.04:        </p> <pre><code>$ wget https://download.swift.org/swift-6.0.3-release/ubuntu2404/swift-6.0.3-RELEASE/swift-6.0.3-RELEASE-ubuntu24.04.tar.gz\n</code></pre> </li> </ul> </li> <li> <p>Extaer el archivo:</p> <pre><code>$ tar xzf swift-&lt;VERSION&gt;-&lt;PLATFORM&gt;.tar.gz\n</code></pre> <p>Esto crea el directorio <code>usr/</code> en la localizaci\u00f3n del archivo. Puedes probar si funciona el comando <code>swift</code> movi\u00e9ndote al directorio <code>bin</code> y ejecutando:</p> <pre><code>$ ./swift repl\nWelcome to Swift version 5.8 \nType :help for assistance.\n1&gt; print(\"Hola mundo\")\nHola mundo\n2&gt; :quit\n$ \n</code></pre> </li> <li> <p>Para poder ejecutar <code>swift</code> desde cualquier directorio debes actualizar el PATH o mover <code>usr/bin/swift</code> al directorio <code>/usr/bin</code>.</p> <pre><code>$ export PATH=/path/to/usr/bin:\"${PATH}\"\n</code></pre> </li> </ol>"},{"location":"seminarios/seminario2-swift/seminario2-swift.html#instalacion-en-windows","title":"Instalaci\u00f3n en Windows","text":"<p>Puedes instalar nuestra distribuci\u00f3n WSL descarg\u00e1ndola desde este enlace.</p> <p>Se trata de una copia exportada en formato tar de una una distribuci\u00f3n WSL Ubuntu 24.04 preparada con Swift 6.0.3 instalada para ejecutar directamente Swift. Antes de proceder, verifica que tienes WSL instalado y habilitado en tu sistema con el siguiente comando en la terminal de Windows (PowerShell o CMD): </p> <pre><code>wsl --list --verbose\n</code></pre> <p>Este comando te mostrar\u00e1 las distribuciones de Linux instaladas y su estado. </p> <p>Si no tienes WSL instalado</p> <p>Si no tienes WSL puedes habilitarlo mediante PowerShell ejecutando el siguiente comando como administrador: </p> <pre><code>wsl --install\n</code></pre> <p>Este comando instalar\u00e1 la versi\u00f3n m\u00e1s reciente de WSL. Si WSL ya est\u00e1 habilitado, el comando actualizar\u00e1 a WSL 2 si es necesario y disponible.</p> <p>Alternativamente, puedes habilitar WSL a trav\u00e9s del panel de control de Windows:</p> <ul> <li>Abre el Panel de Control.</li> <li>Ve a \"Programas\".</li> <li>Haz clic en \"Activar o desactivar las caracter\u00edsticas de Windows\".</li> <li>Busca \"Subsistema de Windows para Linux\", m\u00e1rcalo y haz clic en OK.</li> </ul> <p>Despu\u00e9s de habilitar WSL, se te pedir\u00e1 que reinicies tu ordenador.</p> <p>Pasos para importar nuestra distribuci\u00f3n: </p> <ol> <li>Crea una carpeta <code>UbuntuLPP</code> en un disco con al menos 8GB de capacidad.</li> <li>Descarga la copia (<code>UbuntuLPP.tgz</code>) en esa carpeta.</li> <li>Abre un ventana de s\u00edmbolo de sistema (<code>cmd.exe</code>) y posici\u00f3nate en esa carpeta (<code>cd [ruta]\\UbuntuLPP</code>).</li> <li> <p>Ejecuta el siguiente comando para importar la distribuci\u00f3n a tu WSL 2:</p> <pre><code>wsl --import UbuntuLPP . UbuntuLPP.tgz\n</code></pre> <p>Al importar la distribuci\u00f3n con el comando anterior, el nombre que se le ha dado a la distribuci\u00f3n es <code>UbuntuLPP</code> (se pod\u00eda haber puesto otro nombre), y el lugar donde se ha desempaquetado el disco virtual (<code>ext4.vhdx</code>) es el directorio donde se ejecuta el comando (se pod\u00eda haber sustituido el <code>.</code> por otra ubicaci\u00f3n distinta). Una vez importada la distribuci\u00f3n, se puede eliminar el archivo tar (<code>UbuntuLPP.tgz</code>).</p> <p>Evita guardar el disco WSL en la nube</p> <p>Almacenar los archivos de disco virtual de WSL en servicios de sincronizaci\u00f3n como OneDrive, Drive o Dropbox, puede provocar conflictos de acceso y errores. Para asegurar un funcionamiento adecuado, gu\u00e1rdalos directamente en el disco duro de tu ordenador, en una ruta local.</p> </li> </ol> <p>La distribuci\u00f3n se cre\u00f3 con el usuario <code>swiftuser</code> como usuario por defecto y administrador con la contrase\u00f1a <code>su-LPP-UA</code> (por si te es necesario, por ejemplo, para hacer <code>sudo</code>).</p> <p>Evidentemente, tambi\u00e9n puedes descargar WSL Ubuntu desde la Microsoft Store (o usar alguna distribuci\u00f3n que ya tengas instalada) y despu\u00e9s realizar la instalaci\u00f3n de Swift en Ubuntu tal y como se explica en el apartado anterior.</p>"},{"location":"seminarios/seminario2-swift/seminario2-swift.html#visual-studio-code","title":"Visual Studio Code","text":"<p>Para editar c\u00f3digo Swift puedes usar cualquier editor orientado a programaci\u00f3n como Visual Studio Code (VSC) o Atom. Aconsejamos Visual Studio Code. </p> <p>Las \u00faltimas versiones de Visual Studio Code traen incorporado el plugin oficial de Swift que permite un coloreado de sintaxis y completa autom\u00e1ticamente el c\u00f3digo.</p> <p>Para trabajar de forma m\u00e1s c\u00f3moda podemos abrir el terminal integrado Ver &gt; Terminal integrado. Podemos comprobar que VSC permite abrir un terminal de WSL en el que podemos ejecutar el Swift instalado previamente.</p> <p></p> <p>Puedes consultar los conceptos b\u00e1sicos de Visual Studio Code y el manual completo en este enlace.</p>"},{"location":"seminarios/seminario2-swift/seminario2-swift.html#ejecucion-con-macos","title":"Ejecuci\u00f3n con MacOS","text":"<p>Podemos trabajar de dos formas: ejecutando los programas Swift desde la terminal o desde Xcode.</p> <p>Si tienes Mac, puedes probar las dos formas y elegir la que te parezca m\u00e1s c\u00f3moda.</p>"},{"location":"seminarios/seminario2-swift/seminario2-swift.html#ejecucion-desde-la-terminal","title":"Ejecuci\u00f3n desde la terminal","text":"<p>Debemos instalar las Xcode Command Line Tools con el siguiente comando:</p> <pre><code>$ xcode-select --install\n</code></pre> <p>Una vez instaladas las herramientas podemos ejecutar programas Swift desde la terminal, de forma interactiva:</p> <p>Abre la terminar y escribe:</p> <pre><code>$ swift repl\n</code></pre> <p>Ver\u00e1s que se ejecuta el int\u00e9rprete de Swift y que puedes escribir y ejecutar c\u00f3digo Swift:</p> <p></p> <p>Para editar un programa Swift puedes utilizar un editor como Visual Studio Code, tal y como hemos comentado anteriormente y despu\u00e9s ejecutarlo desde la terminal.</p> <pre><code>$ swift prueba.swift\nHola mundo\n</code></pre> <p></p>"},{"location":"seminarios/seminario2-swift/seminario2-swift.html#ejecucion-desde-xcode","title":"Ejecuci\u00f3n desde Xcode","text":"<p>Primero debes instalar Xcode desde la Mac App Store.</p> <p>Una vez instalado Xcode puedes ejecutar un programa Swift de dos formas: compilando desde la terminal o compilando en Xcode.</p>"},{"location":"seminarios/seminario2-swift/seminario2-swift.html#compilacion-desde-la-terminal","title":"Compilaci\u00f3n desde la terminal","text":"<p>En Xcode puedes crear un fichero nuevo con la opci\u00f3n File &gt; New File... y seleccionar la plantilla macOS &gt; Swift File.</p> <p></p> <p>Selecciona la carpeta y el nombre del fichero y ya puedes escribir c\u00f3digo Swift:</p> <p></p> <p>Una vez grabado el programa, puedes ejecutarlo desde el terminal:</p> <pre><code>$ swift prueba.swift\nHola mundo\n</code></pre> <p></p> <p>Si hay alg\u00fan error de compilaci\u00f3n se detectar\u00e1 al lanzar el comando desde el terminal.</p> <p></p> <p></p>"},{"location":"seminarios/seminario2-swift/seminario2-swift.html#compilacion-con-xcode","title":"Compilaci\u00f3n con Xcode","text":"<p>La otra forma de trabajar es crear desde Xcode un proyecto Swift. Es un poco m\u00e1s complicado (hay que conocer algunos comandos m\u00e1s de Xcode), pero tiene la ventaja de que Xcode muestra los errores en la propia ventana de edici\u00f3n.</p> <p>Desde Xcode pulsa la opci\u00f3n File &gt; New Project... y selecciona la plantilla macOS &gt; Command Line Tool.</p> <p></p> <p>Puedes escribir el nombre que quieras, por ejemplo <code>prueba-swift</code></p> <p></p> <p>Selecciona el lugar en el disco donde se graba el proyecto y ya puedes trabajar con \u00e9l. El fichero principal se llama <code>main.swift</code>. Pulsando la opci\u00f3n de Run se compila el proyecto y se abre un panel con la salida:</p> <p></p> <p>Si hay alg\u00fan error de compilaci\u00f3n se detecta cuando se escribe el c\u00f3digo y se muestra en el propio editor:</p> <p></p>"},{"location":"seminarios/seminario2-swift/seminario2-swift.html#un-tour-de-swift","title":"Un tour de Swift","text":"<p>Nota</p> <p>El texto de este seminario es una traducci\u00f3n del documento de Apple A Swift Tour en el que se presenta una introducci\u00f3n r\u00e1pida a los conceptos fundamentales del lenguaje. En los temas siguientes de la asignatura profundizaremos en aspectos como funciones, gen\u00e9ricos, clases o protocolos.</p> <p>La tradici\u00f3n sugiere que el primer programa en un nuevo lenguaje deber\u00eda imprimir las palabras \"Hola, mundo!\" en la pantalla. En Swift, esto puede hacerse con una \u00fanica l\u00ednea:</p> <pre><code>print(\"Hola, mundo!\")\n</code></pre> <p>Si has escrito c\u00f3digo en C o en Objective-C, esta sintaxis te parecer\u00e1 familiar. En Swift, esta l\u00ednea de c\u00f3digo es un programa completo. No necesitas importar una biblioteca separada para funcionaliades como entrada/salida o manejo de cadenas. El c\u00f3digo escrito en el \u00e1mbito global se usa como el punto de entrada del programa, por lo que no necesitas una funci\u00f3n <code>main()</code>. Tampoco tienes que escribir puntos y comas al final de cada sentencia. Puedes comentar l\u00edneas de c\u00f3digo de la misma forma que en C.</p> <pre><code>//\n// Esto es un comentario\n//\n\n/*\n   Y esto tambi\u00e9n es un comentario\n*/\n</code></pre> <p>Este tour te da informaci\u00f3n suficiente para empezar a escribir c\u00f3digo in Swift ense\u00f1\u00e1ndote c\u00f3mo conseguir una variedad de tareas de programaci\u00f3n. La informaci\u00f3n completa sobre todos los elementos del lenguaje de programaci\u00f3n Swift se encuentra en la Gu\u00eda de Swift.</p>"},{"location":"seminarios/seminario2-swift/seminario2-swift.html#valores-simples","title":"Valores simples","text":"<p>Usa <code>let</code> para crear una constante y <code>var</code> para crear una variable. No es necesario que se conozca en tiempo de compilaci\u00f3n el valor de una constante, pero debes asignarle un valor exactamente una vez. Esto significa que puedes usar constantes para nombrar un valor que determinas una vez pero que usas en muchos lugares.</p> <pre><code>var miVariable = 42\nmiVariable = 50\nlet miConstante = 42\n</code></pre> <p>Una constante o variable debe tener el mismo tipo que el valor que quieres asignarle. Sin embargo, no siempre tienes que escribir el tipo expl\u00edcitamente. Cuando se proporciona un valor al crear una constante o una variable el compilador infiere su tipo. En el ejemplo anterior, el compilador infiere que <code>myVariable</code> es un entero porque su valor inicial es un entero.</p> <p>Si el valor inicial no proporciona informaci\u00f3n suficiente (o si no hay valor inicial), especifica el tipo escribi\u00e9ndolo despu\u00e9s de la variable, separ\u00e1ndolo por dos puntos.</p> <pre><code>let implicitoInteger = 70\nlet implicitoDouble = 70.0\nlet explicitoDouble: Double = 70\n</code></pre> <p>Nota</p> <p>A lo largo del seminario se plantean peque\u00f1os ejercicios que  debes hacer tu mismo, para practicar un poco m\u00e1s con el lenguaje. Los ver\u00e1s en los bloques encabezados con \"Experimento\".</p> <p>Experimento 1</p> <p>Crea una constante con el tipo expl\u00edcito de <code>Float</code> y un valor de 4.</p> <p>Los valores nunca se convierten impl\u00edcitamente a otro tipo. Si necesitas convertir un valor a un tipo diferente, construye expl\u00edcitamente una instancia del tipo deseado.</p> <pre><code>let etiqueta = \"El ancho es \"\nlet ancho = 94\nlet anchoEtiqueta = etiqueta + String(ancho)\n</code></pre> <p>Experimento 2</p> <p>Intenta eliminar la conversi\u00f3n a <code>String</code> en la \u00faltima l\u00ednea. \u00bfQu\u00e9 error obtienes? Incl\u00fayelo traducido en el c\u00f3digo usando un comentario.</p> <p>Hay una forma a\u00fan m\u00e1s sencilla de incluir valores en cadenas: escribe el valor entre par\u00e9ntesis, y escribe una barra invertida (<code>\\</code>) antes de los par\u00e9ntesis. Por ejemplo:</p> <pre><code>let manzanas = 3\nlet naranjas = 5\nlet resumenManzanas = \"Tengo \\(manzanas) manzanas.\"\nlet resumenFrutas = \"Tengo \\(manzanas + naranjas) frutas.\"\n</code></pre> <p>Experimento 3</p> <p>Usa <code>\\()</code> para imprimir una cadena con un c\u00e1lculo con punto flotante y, en otra sentencia, para imprimir una cadena que incluya el nombre de alguien en un saludo.</p> <p>Crea arrays y diccionarios utilizando corchetes (<code>[]</code>), y accede a sus elementos escribiendo el \u00edndice o la clave en los corchetes. Se permite una coma despu\u00e9s del \u00faltimo elemento.</p> <pre><code>var listaCompra = [\"huevos\", \"agua\", \"tomates\", \"pan\"]\nlistaCompra[1] = \"botella de agua\"\n\nvar trabajos = [\n    \"Malcolm\": \"Capit\u00e1n\",\n    \"Kaylee\": \"Mec\u00e1nico\",\n]\ntrabajos[\"Jayne\"] = \"Relaciones p\u00fablicas\"\n</code></pre> <p>Para crear un array o diccionario vac\u00edo, usa la sintaxis de inicializaci\u00f3n.</p> <pre><code>let arrayVacio = [String]()\nlet diccionarioVacio = [String: Float]()\n</code></pre> <p>Si el tipo de informaci\u00f3n puede ser inferido, puedes escribir un array vac\u00edo como <code>[]</code> y un diccionario vac\u00edo como <code>[:]</code>; por ejemplo, cuando estableces un nuevo valor para una variable o pasas un argumento a una funci\u00f3n.</p> <pre><code>listaCompra = []\ntrabajos = [:]\n</code></pre> <p>Puedes encontrar m\u00e1s informaci\u00f3n sobre c\u00f3mo trabajar con arrays en el apartado correspondiente de la Gu\u00eda de Swift.</p>"},{"location":"seminarios/seminario2-swift/seminario2-swift.html#tuplas","title":"Tuplas","text":"<p>Una tupla agrupa varios valores en un \u00fanico valor compuesto.</p> <pre><code>let http404Error = (404, \"Not Found\")\n</code></pre> <p>El tipo de la tupla es <code>(Int, String)</code>.</p> <p>Para obtener los valores de la tupla podemos descomponerla. Si queremos ignorar una parte podemos utilizar un subrrayado (<code>_</code>).</p> <pre><code>let (statusCode, statusMensaje) = http404Error\nlet (soloStatusCode, _) = http404Error\n</code></pre> <p>Tambi\u00e9n podemos acceder por posici\u00f3n:</p> <pre><code>print(\"El c\u00f3digo de estado es \\(http404Error.0)\")\n</code></pre>"},{"location":"seminarios/seminario2-swift/seminario2-swift.html#control-de-flujo","title":"Control de flujo","text":"<p>Usa <code>if</code> y <code>switch</code> para hacer condicionales y usa <code>for-in</code>, <code>for</code>, <code>while</code> y <code>repeat-while</code> para hacer bucles. Los par\u00e9ntesis alrededor de las condiciones o de la variable del bucle son opcionales. Se requieren llaves alrededor del cuerpo.</p> <pre><code>let puntuacionesIndividuales = [75, 43, 103, 87, 12]\nvar puntuacionEquipo = 0\nfor puntuacion in puntuacionesIndividuales {\n    if puntuacion &gt; 50 {\n        puntuacionEquipo += 3\n    } else {\n        puntuacionEquipo += 1\n    }\n}\nprint(puntuacionEquipo)\n</code></pre> <p>En una sentencia <code>if</code>, el condicional debe ser una expresi\u00f3n booleana; esto significa que c\u00f3digo como <code>if puntuacion { ... }</code> es un error, no una comparaci\u00f3n impl\u00edcita con cero (como se permite en C).</p> <p>Puedes usar <code>if</code> y <code>let</code> juntos para trabajar con valores que pueden faltar. Estos valores se representan como opcionales. Un valor opcional o bien contiene un valor o contiene <code>nil</code> para indicar que el valor falta. Escribe una interrogaci\u00f3n (<code>?</code>) despu\u00e9s del tipo de un valor para marcar el valor como opcional.</p> <pre><code>var cadenaOpcional: String? = \"Hola\"\nprint(cadenaOpcional == nil)\n\nvar nombreOpcional: String? = \"John Appleseed\"\nvar saludo = \"Hola!\"\nif let nombre = nombreOpcional {\n    saludo = \"Hola, \\(nombre)\"\n}\nprint(saludo)\n</code></pre> <p>Experimento 4</p> <p>Cambia <code>nombreOpcional</code> a <code>nil</code>. \u00bfQu\u00e9 saludo obtienes? A\u00f1ade una cl\u00e1usula <code>else</code> que establezca un saludo diferente si <code>nombreOpcional</code> es <code>nil</code>.</p> <p>Si el valor opcional es <code>nil</code>, el condicional es <code>false</code> y el c\u00f3digo en las llaves se salta. En otro caso, el valor opcional se desenvuelve y se asigna a la constante despu\u00e9s del <code>let</code>, lo que hace que el valor desenvuelto est\u00e9 disponible dentro del bloque de c\u00f3digo.</p> <p>Otra forma de manejar valores opcionales es proporcionar un valor por defecto usando el operador <code>??</code>. Si falta el valor valor opcional, se usa el valor por defecto en su lugar.</p> <pre><code>let nombrePila: String? = nil\nlet nombreCompleto: String = \"John Appleseed\"\nlet saludoInformal = \"\u00bfQu\u00e9 tal, \\(nombrePila ?? nombreCompleto)?\"\n</code></pre> <p>Las sentencias <code>switch</code> permiten cualquier tipo de datos y una amplia variedad de operaciones de comparaci\u00f3n; no est\u00e1n limitados a enteros y pruebas de igualdad.</p> <pre><code>let verdura = \"pimiento rojo\"\nswitch verdura {\n    case \"zanahoria\":\n        print(\"Buena para la vista.\")\n    case \"lechuga\", \"tomates\":\n        print(\"Podr\u00edas hacer una buena ensalada.\")\n    default:\n        print(\"Siempre puedes hacer una buena sopa.\")\n}\n</code></pre> <p>Experimento 5</p> <p>Intenta eliminar el caso por defecto. \u00bfQu\u00e9 error obtienes?</p> <p>Despu\u00e9s de ejecutar el c\u00f3digo dentro del caso que se empareja, el programa sale de la sentencia <code>switch</code>. La ejecuci\u00f3n no continua con el siguiente caso, por lo que no hay necesidad de romper el <code>switch</code> al final del c\u00f3digo de cada caso.</p> <p>Usa <code>for-in</code> para iterar sobre elementos en un diccionario proporcionando una pareja de nombres para usar en cada pareja clave-valor. Los diccionarios son colecciones desordenadas, por lo que sus claves y valores se iteran en un orden arbitrario.</p> <pre><code>let numerosInteresantes = [\n    \"Primos\": [2, 3, 5, 7, 11, 13],\n    \"Fibonacci\": [1, 1, 2, 3, 5, 8],\n    \"Cuadrados\": [1, 4, 9, 16, 25],\n]\nvar mayor = 0\nfor (clase, numeros) in numerosInteresantes {\n    for num in numeros {\n        if num &gt; mayor {\n            mayor = num\n        }\n    }\n}\nprint(mayor)\n</code></pre> <p>Experimento 6</p> <p>A\u00f1ade otra variable para seguir qu\u00e9 clase de n\u00famero es el mayor.</p> <p>Usa <code>while</code> para repetir un bloque de c\u00f3digo hasta que una condici\u00f3n cambie. La condici\u00f3n de un bucle puede estar tambi\u00e9n al final, asegurando que el bucle se ejecuta al menos una vez.</p> <pre><code>var n = 2\nwhile n &lt; 100 {\n    n *= 2\n}\nprint(n)\n\nvar m = 2\nrepeat {\n    m *=  2\n} while m &lt; 100\nprint(m)\n</code></pre> <p>Puedes definir un \u00edndice en un bucle usando <code>..&lt;</code> para construir un rango de \u00edndices.</p> <pre><code>var total = 0\nfor i in 0..&lt;4 {\n    total += i\n}\nprint(total)\n</code></pre> <p>Usa <code>..&lt;</code> para construir un rango que omita su valor superior, y usa <code>...</code> para construir un rango que incluya ambos valores.</p>"},{"location":"seminarios/seminario2-swift/seminario2-swift.html#funciones-y-clausuras","title":"Funciones y clausuras","text":"<p>Usa <code>func</code> para declarar una funci\u00f3n. Usa <code>-&gt;</code> para separar los nombres de los par\u00e1metros y sus tipos del tipo devuelto de la funci\u00f3n.</p> <pre><code>func saluda(nombre: String, dia: String) -&gt; String {\n    return \"Hola \\(nombre), hoy es \\(dia).\"\n}\nprint(saluda(nombre: \"Bob\", dia: \"Martes\"))\n</code></pre> <p>Experimento 7</p> <p>Elimina el par\u00e1metro d\u00eda. A\u00f1ade un par\u00e1metro para incluir la comida de hoy en el saludo.</p> <p>Por defecto, las funciones usan los nombres de los par\u00e1metros como etiquetas de los argumentos. Es posible definir una etiqueta escribi\u00e9ndola antes del nombre del par\u00e1metro, o no usar etiqueta escribiendo <code>_</code>:</p> <pre><code>func saluda(_ nombre: String, el dia: String) -&gt; String {\n    return \"Hola \\(nombre), hoy es \\(dia).\"\n}\nprint(saluda(\"Bob\", el: \"Martes\"))\n</code></pre> <p>Las funciones pueden devolver cualquier tipo de dato, como tuplas.</p> <pre><code>func calculaEstadisticas(puntuaciones: [Int]) -&gt; \n                        (min: Int, max: Int, sum: Int) {\n    var min = puntuaciones[0]\n    var max = puntuaciones[0]\n    var sum = 0\n\n    for puntuacion in puntuaciones {\n        if puntuacion &gt; max {\n            max = puntuacion\n        } else if puntuacion &lt; min {\n            min = puntuacion\n        }\n        sum += puntuacion\n    }\n\n    return (min, max, sum)\n}\nlet estadisticas = calculaEstadisticas(puntuaciones: [5, 3, 100, 3, 9])\nprint(estadisticas.sum)\nprint(estadisticas.2)\n</code></pre> <p>Las funciones tambi\u00e9n pueden tener un n\u00famero variable de argumentos, agrup\u00e1ndose todos ellos en un array.</p> <pre><code>func suma(numeros: Int...) -&gt; Int {\n    var suma = 0\n    for num in numeros {\n        suma += num\n    }\n    return suma\n}\nprint(suma())\nprint(suma(numeros: 42, 597, 12))\n</code></pre> <p>Experimento 8</p> <p>Escribe una funci\u00f3n que calcule la media de sus argumentos.</p> <p>Las funciones pueden anidarse. Las funciones pueden acceder variables declaradas en la funci\u00f3n exterior. Puedes usar funciones anidadas para organizar el c\u00f3digo en una funci\u00f3n que es larga o complicada.</p> <pre><code>func devuelveQuince() -&gt; Int {\n    var y = 10\n    func suma() {\n        y += 5\n    }\n    suma()\n    return y\n}\nprint(devuelveQuince())\n</code></pre> <p>Las funciones son un tipo de primera clase. Esto significa que una funci\u00f3n puede devolver otra funci\u00f3n como resultado.</p> <pre><code>func construyeIncrementador() -&gt; ((Int) -&gt; Int) {\n    func sumaUno(numero: Int) -&gt; Int {\n        return 1 + numero\n    }\n    return sumaUno\n}\nvar incrementa = construyeIncrementador()\nprint(incrementa(7))\n</code></pre> <p>Podemos modificar el ejemplo <code>devuelveQuince</code> para que se devuelva una versi\u00f3n modificada de la funci\u00f3n <code>suma</code>. Llamamos a la funci\u00f3n <code>devuelveSuma</code>.</p> <pre><code>func devuelveSuma() -&gt; (() -&gt; Int) {\n    var y = 10\n    func suma() -&gt; Int {\n        y += 5\n        return y\n    }\n    return suma\n}\n\nlet f = devuelveSuma()\nprint(f())\nprint(f())\n</code></pre> <p>Una funci\u00f3n puede tomar otra funci\u00f3n como uno de sus argumentos.</p> <pre><code>func cumpleCondicion(lista: [Int], condicion: (Int) -&gt; Bool) -&gt; Bool {\n    for item in lista {\n        if condicion(item) {\n            return true\n        }\n    }\n    return false\n}\nfunc menorQueDiez(numero: Int) -&gt; Bool {\n    return numero &lt; 10\n}\nvar numeros = [20, 19, 7, 12]\nprint(cumpleCondicion(lista: numeros, condicion: menorQueDiez))\n</code></pre> <p>Las funciones son en la realidad un caso especial de clausuras: bloques de c\u00f3digo que pueden ser llamados despu\u00e9s.  El c\u00f3digo en la clausura tiene acceso a cosas como variables y funciones que estaban disponibles en el \u00e1mbito (scope) en el que se cre\u00f3 la clausura, incluso si la clausura est\u00e1 en un \u00e1mbito distinto cuando se ejecuta; ya viste un ejemplo de esto con las funciones anidadas. Puedes escribir una clausura rodeando el c\u00f3digo con llaves (<code>{}</code>). Usa <code>in</code> para separar los argumentos del cuerpo.</p> <pre><code>numeros.map({\n    (numero: Int) -&gt; Int in\n    let resultado = 3 * numero\n    return resultado\n})\n</code></pre> <p>Experimento 9</p> <p>Reescribe la clausura para que devuelva cero para todos los n\u00fameros impares.</p> <p>Tienes bastantes opciones para escribir clausuras de forma m\u00e1s concisa. Cuando ya se conoce el tipo de una clausura puedes omitir el tipo de sus par\u00e1metros, el tipo devuelto o ambos. Las clausuras escritas en una sentencia devuelven impl\u00edcitamente el valor de esa \u00fanica sentencia.</p> <pre><code>let numerosMapeados = numeros.map({ numero in 3 * numero })\nprint(numerosMapeados)\n</code></pre> <p>Puedes referirte a los par\u00e1metros por n\u00famero en lugar de por nombre; este enfoque es especialmente \u00fatil en clausuras muy cortas. Una clausura pasada como \u00faltimo argumento puede aparecer inmediatamente despu\u00e9s de los par\u00e9ntesis. Cuando una clausura es el \u00fanico argumento de una funci\u00f3n, puedes omitir los par\u00e9ntesis por completo.</p> <pre><code>let numerosOrdenados = numeros.sorted { $0 &gt; $1 }\nprint(numerosOrdenados)\n</code></pre>"},{"location":"seminarios/seminario2-swift/seminario2-swift.html#objetos-y-clases","title":"Objetos y clases","text":"<p>Usa <code>class</code> seguido por el nombre de la clase para crear una clase. Una declaraci\u00f3n de una propiedad en una clase se escribe de la misma forma que la declaraci\u00f3n de una constante o una variable, excepto que est\u00e1 en el contexto de una clase. De la misma forma, las declaraciones de los m\u00e9todos se escriben de la misma forma que las funciones.</p> <pre><code>class Figura {\n    var numeroDeLados = 0\n    func descripcionSencilla() -&gt; String {\n        return \"Una figura con \\(numeroDeLados) lados.\"\n    }\n}\n</code></pre> <p>Experimento 10</p> <p>A\u00f1ade una propiedad constante con <code>let</code>, y a\u00f1ade otro m\u00e9todo que tome un argumento.</p> <p>Crea una instancia de una clase poniendo par\u00e9ntesis despu\u00e9s del nombre de la clase. Usa la sintaxis de punto para acceder a las propiedades y los m\u00e9todos de la instancia.</p> <pre><code>var figura = Figura()\nfigura.numeroDeLados = 7\nvar descripcionFigura = figura.descripcionSencilla()\n</code></pre> <p>A esta versi\u00f3n de la clase <code>Figura</code> le falta algo importante: un inicializador para preparar la clase cuando se crea una instancia. Usa <code>init</code> para crear uno.</p> <pre><code>class FiguraConNombre {\n    var numeroDeLados: Int = 0\n    var nombre: String\n\n    init(nombre: String) {\n        self.nombre = nombre\n    }\n\n    func descripcionSencilla() -&gt; String {\n        return \"Una figura con \\(numeroDeLados) lados.\"\n    }\n}\n</code></pre> <p>F\u00edjate en c\u00f3mo se utiliza <code>self</code> para distinguir la propiedad <code>nombre</code> del argumento <code>nombre</code> al inicializador. Los argumentos al inicializador se pasan como una llamada a una funci\u00f3n cuando creas una instancia de la clase. Cada propiedad necesita un valor asignado; ya sea en su declaraci\u00f3n (como <code>numeroDeLados</code>) o en el inicializador (como <code>nombre</code>).</p> <p>Las subclases incluyen el nombre de su subclase despu\u00e9s del nombre de la clase, separado por dos puntos. No hay ning\u00fan requisito de que las clases deban ser subclases de alguna clase ra\u00edz, por lo que puedes omitir una superclase si as\u00ed lo necesitas.</p> <p>Los m\u00e9todos en una subclase que sobreescriben la implementaci\u00f3n de la superclase se marcan con <code>override</code>; la sobreescritura de un m\u00e9todo por accidente, sin <code>override</code>, se detecta por el compilador como un error. El compilador tambi\u00e9n detecta m\u00e9todos con <code>override</code> que realmente no sobreescriben ning\u00fan m\u00e9todo de la superclase.</p> <pre><code>class Cuadrado: FiguraConNombre {\n    var longitudLado: Double\n\n    init(longitudLado: Double, nombre: String) {\n        self.longitudLado = longitudLado\n        super.init(nombre: nombre)\n        numeroDeLados = 4\n    }\n\n    func area() -&gt;  Double {\n        return longitudLado * longitudLado\n    }\n\n    override func descripcionSencilla() -&gt; String {\n        return \"Un cuadrado con lados de longitud \\(longitudLado).\"\n    }\n}\nlet test = Cuadrado(longitudLado: 5.2, nombre: \"Mi cuadrado de prueba\")\nprint(test.area())\nprint(test.descripcionSencilla())\n</code></pre> <p>Experimento 11</p> <p>Construye otra subclase de <code>FiguraConNombre</code> llamada <code>Circulo</code> que tome un radio y un nombre como argumentos de su inicializador. Implementa un m\u00e9todo <code>area()</code> y <code>descripcionSencilla()</code> en la clase <code>Circulo</code>.</p> <p>Adem\u00e1s de propiedades simples que se almacenan, las propiedades pueden tener un getter y un setter.</p> <pre><code>class TrianguloEquilatero: FiguraConNombre {\n    var longitudLado: Double = 0.0\n\n    init(longitudLado: Double, nombre: String) {\n        self.longitudLado = longitudLado\n        super.init(nombre: nombre)\n        numeroDeLados = 3\n    }\n\n    var perimetro: Double {\n        get {\n            return 3.0 * longitudLado\n        }\n        set {\n            longitudLado = newValue / 3.0\n        }\n    }\n\n    override func descripcionSencilla() -&gt; String {\n        return \"Un triangulo equil\u00e1tero con lados de longitud \\(longitudLado).\"\n    }\n}\nvar triangulo = TrianguloEquilatero(longitudLado: 3.1, nombre: \"un tri\u00e1ngulo\")\nprint(triangulo.perimetro)\ntriangulo.perimetro = 9.9\nprint(triangulo.longitudLado)\n</code></pre> <p>En el setter de <code>perimetro</code>, el nuevo valor tiene el nombre impl\u00edcito <code>newValue</code>. Puedes proporcionar un nombre expl\u00edcito en el par\u00e9ntesis despu\u00e9s de <code>set</code>.</p> <p>Date cuenta de que el inicializador de la clase <code>TrianguloEquilatero</code> tiene tres pasos diferentes:</p> <ol> <li>Establecer el valor de las propiedades que declara la subclase.</li> <li>Llamar al inicializador de la superclase.</li> <li>Cambiar el valor de las propiedades definidas por la    superclase. Cualquier trabajo adicional que use m\u00e9todos, getters    o setters puede hacerse tambi\u00e9n en este punto.</li> </ol>"},{"location":"seminarios/seminario2-swift/seminario2-swift.html#enumeraciones-y-estructuras","title":"Enumeraciones y estructuras","text":"<p>Usa <code>enum</code> para crear una enumeraci\u00f3n. Como las clases y otros tipos con nombre, las enumeraciones pueden tener m\u00e9todos asociados.</p> <pre><code>enum Valor: Int {\n    case uno = 1\n    case dos, tres, cuatro, cinco, seis, siete, ocho, nueve, diez\n    case sota, caballo, rey\n    func descripcionSencilla() -&gt; String {\n        switch self {\n        case .uno:\n            return \"as\"\n        case .sota:\n            return \"sota\"\n        case .caballo:\n            return \"caballo\"\n        case .rey:\n            return \"rey\"\n        default:\n            return String(self.rawValue)\n        }\n    }\n}\nlet carta = Valor.uno\nlet valorBrutoCarta = carta.rawValue\n</code></pre> <p>Experimento 12</p> <p>Escribe una funci\u00f3n que compare dos valores <code>Valor</code> a trav\u00e9s de una comparaci\u00f3n de sus valores brutos.</p> <p>Por defecto, Swift asigna los valores brutos comenzando en cero e increment\u00e1ndolos por uno cada vez, pero puedes cambiar esta conducta especificando expl\u00edcitamente los valores. En el ejemplo anterior, a <code>As</code> se le da un valor bruto de <code>1</code> y el resto de los valores brutos se asignan en orden. Puedes tambi\u00e9n usar cadenas o n\u00fameros en punto flotante como valores brutos de una enumeraci\u00f3n. Utiliza la propiedad <code>rawValue</code> para acceder al valor bruto de una enumeraci\u00f3n.</p> <p>Usa el inicializador para construir un valor de una enumeraci\u00f3n a trav\u00e9s de un valor bruto. Si el valor bruto no existe, el inicializador devolver\u00e1 <code>nil</code>.</p> <pre><code>if let valorConvertido = Valor(rawValue: 3) {\n    let descripcionTres = valorConvertido.descripcionSencilla()\n    print(descripcionTres)\n}\n</code></pre> <p>Los valores case de una enumeraci\u00f3n son valores reales, no una forma nueva de escribir sus valores brutos. De hecho, en los casos en los que no hay un valor bruto que tenga sentido, no tienes que proporcionar uno.</p> <pre><code>enum Palo {\n    case oros, bastos, copas, espadas\n    func descripcionSencilla() -&gt; String {\n        switch self {\n        case .oros:\n            return \"oros\"\n        case .bastos:\n            return \"bastos\"\n        case .copas:\n            return \"copas\"\n        case .espadas:\n            return \"espadas\"\n        }\n    }\n}\nlet copas = Palo.copas\nlet descripcionCopas = copas.descripcionSencilla()\n</code></pre> <p>Experimento 13</p> <p>A\u00f1ade un m\u00e9todo <code>color()</code> a <code>Palo</code> que devuelva \"agresivo\" para bastos y espadas y devuelva \"reflexivo\" para oros y copas.</p> <p>Date cuenta de las dos formas en las que nos referimos al caso <code>copas</code> de la enumeraci\u00f3n anterior: cuando se asigna un valor a la constante <code>copas</code>, nos referimos al caso de la enumeraci\u00f3n <code>Palo.copas</code> usando su nombre completo porque la constante no tiene un tipo expl\u00edcito especificado. Dentro del <code>switch</code>, nos referimos al caso de la enumeraci\u00f3n con la forma abreviada <code>.copas</code> porque ya se sabe que el valor de <code>self</code> es un <code>Palo</code>. Puedes usar la forma abreviada en cualquier momento en que el tipo del valor ya se conozca.</p> <p>Una instancia de un caso de enumeraci\u00f3n puede tener valores asociados con la instancia. Instancias del mismo caso de enumeraci\u00f3n pueden tener asociados valores diferentes. Proporcionas los valores asociados cuando creas la instancia. Los valores asociados y los valores brutos son distintos: el valor bruto de un caso de enumeraci\u00f3n es el mismo para todas las instancias, mientras que proporcionas el valor asociado cuando defines la enumeraci\u00f3n.</p> <p>Por ejemplo, considera el caso de realizar una petici\u00f3n a un servidor de la hora de salir el sol y de la hora de ponerse el sol. El servidor responde con la informaci\u00f3n o responde con alguna informaci\u00f3n de error.</p> <pre><code>enum RespuestaServidor {\n    case resultado(String, String)\n    case error(String)\n}\n\nlet exito = RespuestaServidor.resultado(\"6:00 am\", \"8:09 pm\")\nlet fallo = RespuestaServidor.error(\"Sin queso.\")\n\nswitch exito {\n    case let .resultado(salidaSol, puestaSol):\n        print(\"La salida del sol es a las \\(salidaSol) y la puesta es a \\(puestaSol).\")\n    case let .error(error):\n        print(\"Fallo...  \\(error)\")\n}\n</code></pre> <p>Experimento 14</p> <p>A\u00f1ade un tercer caso a <code>RespuestaServidor</code> y al switch.</p> <p>Date cuenta de c\u00f3mo la hora de salir el sol y de ponerse el sol se extraen del enumerado <code>RespuestaServidor</code> como parte del emparejamiento entre el valor y los casos switch.</p> <p>Usa <code>struct</code> para crear una estructura. Las estructuras comparten muchas caracter\u00edsticas de las clases, incluyendo m\u00e9todos e inicializadores. Una de las diferencias m\u00e1s importantes entre estructuras y clases es que las estructuras siempre se copian cuando las pasas en tu c\u00f3digo, mientras que las clases se pasan por referencia.</p> <pre><code>struct Carta {\n    var valor: Valor\n    var palo: Palo\n    func descripcionSencilla() -&gt; String {\n        return \"El \\(valor.descripcionSencilla()) de \\(palo.descripcionSencilla())\"\n    }\n}\nlet tresDeEspadas = Carta(valor: .tres, palo: .espadas)\nlet descripcionTresDeEspadas = tresDeEspadas.descripcionSencilla()\n</code></pre> <p>Experimento 15</p> <p>A\u00f1ade un m\u00e9todo a <code>Carta</code> que cree un mazo completo de cartas, con una carta de cada combinaci\u00f3n de valor y palo.</p>"},{"location":"seminarios/seminario2-swift/seminario2-swift.html#bibliografia-y-referencias","title":"Bibliograf\u00eda y referencias","text":"<ul> <li>Documentaci\u00f3n sobre Swift<ul> <li>The Swift Programming Language (html)</li> <li>Recursos Swift en Apple</li> <li>swift.org</li> </ul> </li> <li>Swift Open Source<ul> <li>Repositorio <code>swift</code> en GitHub: repositorio principal de Swift, que contiene el c\u00f3digo fuente del compilador Swift, la biblioteca est\u00e1ndar y SourceKit.</li> <li>Repositorio <code>swift-evolution</code> en GitHub: documentos relacionados con la evoluci\u00f3n continua de Swift, incluyendo objetivos de las pr\u00f3ximas versiones y propuestas de cambios y extensiones de Swift.</li> </ul> </li> </ul> <p>Lenguajes y Paradigmas de Programaci\u00f3n, curso 2024-25 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Domingo Gallardo, Cristina Pomares, Antonio Bot\u00eda, Francisco Mart\u00ednez</p>"},{"location":"teoria/tema00-descripcion-asignatura/tema00-descripcion-asignatura.html","title":"Lenguajes y Paradigmas de Programaci\u00f3n","text":""},{"location":"teoria/tema00-descripcion-asignatura/tema00-descripcion-asignatura.html#1-datos-academicos-de-la-asignatura","title":"1. Datos acad\u00e9micos de la asignatura","text":"<p>Departamento de Ciencia de la Computaci\u00f3n e Inteligencia Artificial 6 cr\u00e9ditos ECTS: 1 clase de teor\u00eda de 2 h. y 1 clase de  pr\u00e1cticas de 2 h. a la semana Profesores:  </p> <ul> <li>Antonio Bot\u00eda</li> <li>Carlos Cano</li> <li>Ricard Gasa</li> <li>Adri\u00e1n Gonz\u00e1lez</li> <li>Francisco Mart\u00ednez</li> <li>Mois\u00e9s Moreno</li> <li>Cristina Pomares (Coordinadora)</li> </ul>"},{"location":"teoria/tema00-descripcion-asignatura/tema00-descripcion-asignatura.html#2-recursos-de-la-asignatura","title":"2. Recursos de la asignatura","text":"<ul> <li>Ficha de la asignatura</li> <li>Apuntes de la asignatura (teor\u00eda, seminarios y pr\u00e1cticas)</li> <li>Sitio Moodle   abierto y accesible a toda la comunidad educativa, contiene los apuntes,   transparencias, pr\u00e1cticas y otros materiales docentes.</li> <li>Foro de consultas y anuncios en el sitio Moodle.</li> </ul>"},{"location":"teoria/tema00-descripcion-asignatura/tema00-descripcion-asignatura.html#3-objetivos-y-competencias","title":"3. Objetivos y competencias","text":"<p>Objetivos:</p> <ul> <li>\u00bfQu\u00e9 elementos son comunes a los lenguajes de programaci\u00f3n? </li> <li>\u00bfQu\u00e9 familias o paradigmas de lenguajes podemos identificar? </li> <li>\u00bfQu\u00e9 es la programaci\u00f3n funcional?</li> <li>\u00bfC\u00f3mo es un lenguaje multi-paradigma que combina la programaci\u00f3n   funcional y la programaci\u00f3n orientada a objetos?</li> </ul> <p>Dominando estos contenidos ser\u00e1 mucho m\u00e1s f\u00e1cil aprender nuevos lenguajes de programaci\u00f3n, identificar sus aspectos esenciales e incluso ser capaz de dise\u00f1ar lenguajes espec\u00edficos orientados a dominios concretos.</p> <p>Competencias:</p> <ul> <li>Conocer y diferenciar las caracter\u00edsticas de los distintos   paradigmas de programaci\u00f3n (programaci\u00f3n funcional, procedural y   orientada a objetos) e identificarlas en lenguajes de programaci\u00f3n   concretos.</li> <li>Diferenciar entre tiempo de ejecuci\u00f3n y tiempo de compilaci\u00f3n en   distintos \u00e1mbitos: detecci\u00f3n de errores o definici\u00f3n, creaci\u00f3n o   \u00e1mbito de vida de variables.</li> <li>Conocer los principios b\u00e1sicos de la programaci\u00f3n funcional:   recursi\u00f3n, inmutabilidad, funciones como objetos de primera clase,   funciones de orden superior, expresiones lambda (clausuras).</li> <li>Conocer los problemas derivados del uso de la mutaci\u00f3n en los   lenguajes de programaci\u00f3n imperativos y la forma de trabajar con   estructuras inmutables en lenguajes declarativos y funcionales.</li> <li>Utilizar la abstracci\u00f3n y la recursi\u00f3n para dise\u00f1ar correctamente   procedimientos y estructuras de datos (listas y \u00e1rboles).</li> <li>Ser capaz de dise\u00f1ar, implementar y corregir programas funcionales,   en concreto utilizando el lenguaje de programaci\u00f3n Scheme.</li> <li>Ser capaz de dise\u00f1ar, implementar y corregir programas funcionales,   en concreto utilizando el lenguaje de programaci\u00f3n Swift.</li> <li>Conocer las caracter\u00edsticas de programaci\u00f3n orientada a   objetos y de comprobaci\u00f3n est\u00e1tica de tipos del lenguaje de   programaci\u00f3n Swift. Conocer el uso de gen\u00e9ricos y protocolos que   proporciona el lenguaje.</li> <li>Ser capaz de implementar programas en Swift en los que se   utilicen sus caracter\u00edsticas de programaci\u00f3n orientada a objetos,   gen\u00e9ricos y protocolos.</li> </ul>"},{"location":"teoria/tema00-descripcion-asignatura/tema00-descripcion-asignatura.html#4-temario","title":"4. Temario","text":""},{"location":"teoria/tema00-descripcion-asignatura/tema00-descripcion-asignatura.html#41-bloques-tematicos","title":"4.1. Bloques tem\u00e1ticos","text":"<p>La asignatura se divide en 3 bloques tem\u00e1ticos, todos ellos de igual duraci\u00f3n, en los que se utilizar\u00e1 el lenguaje de programaci\u00f3n que aparece entre par\u00e9ntesis:</p> <ol> <li>Programaci\u00f3n funcional (Scheme): temas 1 y 2</li> <li>Procesos y estructuras recursivas (Scheme): temas 3 y 4</li> <li>Programaci\u00f3n funcional en Swift y programaci\u00f3n orientada a objetos    (Swift): temas 5 y 6</li> </ol> <p>Los lenguajes de programaci\u00f3n se introducir\u00e1n mediante seminarios impartidos en las clases de pr\u00e1cticas.</p> <ul> <li>Seminario 1. El lenguaje de programaci\u00f3n Scheme:   Primitivas. Tipos de datos   b\u00e1sicos. S\u00edmbolos. Cadenas. Listas. Definici\u00f3n de funciones. </li> <li>Seminario 2. El lenguaje de programaci\u00f3n Swift. Int\u00e9rprete y   scripts. Tipos de datos b\u00e1sicos. Operadores. Estructuras de   control. \u00c1mbito de variables. Tipos de datos compuestos: tuplas,   arrays y colecciones. Recorriendo colecciones. Valores mutables e   inmutables. Inicializaci\u00f3n. Tipos de referencia y valor en Swift.</li> </ul>"},{"location":"teoria/tema00-descripcion-asignatura/tema00-descripcion-asignatura.html#42-temas","title":"4.2. Temas","text":"<ul> <li>Tema 1. Lenguajes de programaci\u00f3n: Historia de los lenguajes de   programaci\u00f3n. Elementos de los lenguajes de   programaci\u00f3n. Abstracci\u00f3n. Paradigmas de programaci\u00f3n. Compiladores   e int\u00e9rpretes.</li> <li>Tema 2. Programaci\u00f3n Funcional: Caracter\u00edsticas e historia del   paradigma de Programaci\u00f3n Funcional. Diferencias con el paradigma   imperativo. Caracter\u00edsticas declarativas   del paradigma funcional. Definici\u00f3n de funciones. Funciones como   datos de primer orden. La forma especial lambda. \u00c1mbito de variables   y clausuras. Datos compuestos en Scheme: parejas. Construcci\u00f3n,   recorrido y operaciones sobre listas. Listas con elementos   compuestos. Listas de listas.</li> <li>Tema 3. Procedimientos recursivos:  Dise\u00f1o de   funciones recursivas. Recursi\u00f3n mutua. Procesos recursivos e   iterativos. Memoization. Recursi\u00f3n y gr\u00e1ficos de tortuga. </li> <li>Tema 4. Estructuras recursivas: Estructuras de datos recursivas:   listas estructuradas y \u00e1rboles.</li> <li>Tema 5. Programaci\u00f3n funcional en Swift: Lenguajes   multiparadigma. Programaci\u00f3n funcional en Swift. Valores   opcionales. Listas. Recursi\u00f3n pura y recursi\u00f3n por la   cola. Funciones como datos de primer orden. Clausuras y funciones   an\u00f3nimas. Funciones de orden superior: mappings y filtros de   colecciones.</li> <li>Tema 6. Programaci\u00f3n Orientada a Objetos en Swift: Caracter\u00edsticas e   historia del paradigma de Programaci\u00f3n Orientada a   Objetos. Estructuras y clases en Swift. Herencia. Conceptos   avanzados de POO en Swift: Extensiones, Protocolos y   Gen\u00e9ricos.</li> </ul> <p>El calendario de temas, pr\u00e1cticas y ex\u00e1menes se puede ver en la siguiente figura.</p> <p></p>"},{"location":"teoria/tema00-descripcion-asignatura/tema00-descripcion-asignatura.html#5-practicas","title":"5. Pr\u00e1cticas","text":"<p>Las pr\u00e1cticas son fundamentales en la asignatura y sirven para comprender, trabajar y profundizar los conceptos y competencias estudiados en las clases de teor\u00eda.</p> <p>Para el desarrollo de las pr\u00e1cticas utilizaremos los siguientes lenguajes de programaci\u00f3n y entornos de desarrollo:</p> <ul> <li>Racket (versi\u00f3n de Scheme, lenguaje de   programaci\u00f3n funcional)</li> <li>Swift (lenguaje multiparadigma creado por   Apple, con conceptos modernos de programaci\u00f3n funcional y   programaci\u00f3n orientada a objetos)</li> </ul> <p>Cada semana tendr\u00e1s que realizar una hoja de ejercicios en la que se incluir\u00e1n 5 o 6 peque\u00f1os problemas de programaci\u00f3n relacionados con la teor\u00eda de la semana anterior.</p> <p>La hoja de ejercicios estar\u00e1 disponible al comienzo de la semana y tendr\u00e1s toda la semana para su realizaci\u00f3n. Una vez entregada la pr\u00e1ctica podr\u00e1s acceder a su soluci\u00f3n. </p> <p>Revisa la soluci\u00f3n de la pr\u00e1ctica</p> <p>Es muy importante que revises la soluci\u00f3n de la pr\u00e1ctica y la compares con la soluci\u00f3n que has obtenido. Pregunta a tu profesor de pr\u00e1cticas en caso de que tengas dudas sobre si tu soluci\u00f3n es correcta.</p> <p>En la clase de pr\u00e1cticas se resolver\u00e1n dudas sobre la soluci\u00f3n de la pr\u00e1ctica anterior y se trabajar\u00e1 en la hoja de ejercicios publicada esa semana. Durante la sesi\u00f3n de pr\u00e1cticas el profesor estar\u00e1 disponible para resolver dudas y dar pistas sobre c\u00f3mo atacar los problemas.</p> <p>Tambi\u00e9n durante la semana se podr\u00e1n consultar las dudas que puedan surgir en el foro de la asignatura (en Moodle) y con tutor\u00edas a los profesores. Es preferible el foro, porque de esta forma las contestaciones y aclaraciones ser\u00e1n compartidas con el resto de compa\u00f1eros.</p>"},{"location":"teoria/tema00-descripcion-asignatura/tema00-descripcion-asignatura.html#6-horarios","title":"6. Horarios","text":"<p>La distribuci\u00f3n de grupos del curso 2025-26 es la siguiente:</p> <p></p> <p>En los turnos de teor\u00eda es posible, de forma excepcional, asistir a un grupo distinto del asignado.</p> <p>En los turnos de pr\u00e1cticas se debe asistir al grupo al que se ha asignado. El cambio de turno deber\u00e1 solicitarse en la Secretar\u00eda de la EPS.</p>"},{"location":"teoria/tema00-descripcion-asignatura/tema00-descripcion-asignatura.html#7-evaluacion","title":"7. Evaluaci\u00f3n","text":""},{"location":"teoria/tema00-descripcion-asignatura/tema00-descripcion-asignatura.html#71-convocatoria-ordinaria-c3-evaluacion-continua","title":"7.1. Convocatoria ordinaria C3 (evaluaci\u00f3n continua)","text":"<p>La asignatura se divide en 3 bloques tem\u00e1ticos, todos ellos de igual duraci\u00f3n, en los que se utilizar\u00e1 el lenguaje de programaci\u00f3n que aparece entre par\u00e9ntesis: </p> <ul> <li>Programaci\u00f3n funcional (temas 1 y 2, Scheme)</li> <li>Recursi\u00f3n y estructuras de datos recursivas (temas 3 y 4, Scheme)</li> <li>Programaci\u00f3n funcional en Swift y programaci\u00f3n orientada a objetos (temas 5 y 6, Swift)</li> </ul> <p>Se realizar\u00e1n tres ex\u00e1menes parciales escritos sobre los conceptos de cada uno de los bloques tem\u00e1ticos (teor\u00eda y pr\u00e1ctica). Los parciales tendr\u00e1n la siguiente ponderaci\u00f3n en la nota final: </p> <ul> <li>Parcial 1: 35%</li> <li>Parcial 2: 30%</li> <li>Parcial 3: 35%</li> </ul> <p>No se exige nota m\u00ednima en ninguno de los parciales. Los parciales 1 y 2 se realizar\u00e1n durante el curso. El parcial 3 se realizar\u00e1 en la fecha del examen oficial de la convocatoria ordinaria de la asignatura. </p> <p>Sobre los dispositivos m\u00f3viles</p> <p>Durante la realizaci\u00f3n de los ex\u00e1menes no est\u00e1 permitido que llev\u00e9is encima ning\u00fan dispositivo con conexi\u00f3n a internet (smartphones, smart watches, tablets, etc). Antes de empezar la prueba, se deber\u00e1n dejar dentro de las mochilas, y \u00e9stas en el suelo. En caso de no cumplir esta norma, la prueba queda invalidada con calificaci\u00f3n de 0. </p>"},{"location":"teoria/tema00-descripcion-asignatura/tema00-descripcion-asignatura.html#72-convocatoria-extraordinaria-c4","title":"7.2. Convocatoria extraordinaria C4","text":"<p>En la convocatoria extraordinaria se realizar\u00e1 un examen final sobre todos los bloques tem\u00e1ticos cuya calificaci\u00f3n representar\u00e1 el 100% de la nota de la asignatura.</p>"},{"location":"teoria/tema00-descripcion-asignatura/tema00-descripcion-asignatura.html#8-consejos-para-aprender-con-exito-los-contenidos-de-la-asignatura","title":"8. Consejos para aprender con \u00e9xito los contenidos de la asignatura","text":"<p>El consejo fundamental para aprobar la asignatura es trabajar todas las semanas e intentar seguir el ritmo de la asignatura. Los conceptos de la asignatura se van construyendo de forma progresiva y lo visto en una semana depende muchas veces de lo aprendido en semanas anteriores.</p> <p>\u00bfC\u00f3mo estudiar estos conceptos? Con la excepci\u00f3n de algunos temas y apartados concretos (como la historia de los lenguajes de programaci\u00f3n o las caracter\u00edsticas de los distintos paradigmas) la asignatura es fundamentalmente pr\u00e1ctica. Cuando hablamos de estudiar los ejemplos de c\u00f3digo queremos decir entenderlos, no aprenderlos de memoria. No tiene sentido aprender de memoria los ejercicios y los ejemplos vistos en clase. Hay que trabajarlos. Eso significa que, primero, hay que entenderlos sobre el papel y muy importante hay que probar todos los ejemplos en el int\u00e9rprete. Y probar significa escribir los ejemplos y jugar con ellos, proponiendo peque\u00f1as variantes, pregunt\u00e1ndose \u00bfqu\u00e9 pasar\u00eda si...? y prob\u00e1ndolo.</p> <p>En cuanto a las pr\u00e1cticas y a los ejercicios propuestos es fundamental pelearse con ellos e intentar hacerlos por uno mismo sin ver ninguna soluci\u00f3n. Es la \u00fanica forma de aprender: probando, equivoc\u00e1ndose y encontrando la soluci\u00f3n por uno mismo.</p> <p>A la hora de enfrentarse con un problema es fundamental tambi\u00e9n usar l\u00e1piz y papel para probar enfoques y encontrar la soluci\u00f3n m\u00e1s sencilla sobre el papel antes de probarla en el int\u00e9rprete. Los ejercicios que proponemos no son excesivamente complicados. Todos se resuelven con muy pocas l\u00edneas de c\u00f3digo y su codificaci\u00f3n en el ordenador no tiene dificultad, una vez que se ha encontrado la soluci\u00f3n que lo resuelve. Al usar el l\u00e1piz y papel tambi\u00e9n estar\u00e1s practicando una situaci\u00f3n similar a la que te vas a encontrar en los ex\u00e1menes de la asignatura.</p> <p>Resumiendo: trabajar todas las semanas, hacer uno mismo todos los ejercicios y no desanimarse ni descolgarse.</p> <p>Son muy interesantes algunos comentarios de antiguos estudiantes que han aprobado la asignatura.</p> <p>C\u00f3mo dominar los conceptos</p> <p>Para superar la asignatura lo que hice fue estudiar mucho. Hay que practicar y sobre todo entender los ejercicios y no sabe\u0301rselos de memoria. Una vez dominados los ejercicios yo mismo me propuse variantes de los mismos. Asi\u0301 es como se domina.</p> <p>El problema del cambio de paradigma</p> <p>El problema principal de la asignatura es enfrentarse a un cambio  del paradigma de programacio\u0301n.\"</p> <p>Trabajar d\u00eda a d\u00eda</p> <p>Lo que hice fue tratar de llevar al di\u0301a toda la asignatura, adema\u0301s de trabajar con material adicional para poder ampliar y profundizar conocimientos. LPP es una asignatura de fondo en la que tienes que mantener el ritmo de trabajo de principio a fin de cuatrimestre.\"</p> <p>No copiar las pr\u00e1cticas</p> <p>El mayor problema que creo que existe es que muchas personas se relajan y se copian las pra\u0301cticas en cuanto les resultan un poco difi\u0301ciles o les lleva algo mas del tiempo que les gustari\u0301a. Esta asignatura si no haces tu los ejercicios y te peleas con ellos es pra\u0301cticamente imposible de sacar.</p> <p>No memorizar</p> <p>Otra de las cosas es que tienes que cambiar la forma de estudiar, no vale memorizar, ni hacer muchos ejercicios sin ma\u0301s. Tienes que entender bien el funcionamiento de la recursio\u0301n para luego poder practicar con ejercicios, sino no sirve. [...] En mi opinio\u0301n el problema de LPP para mucha gente es que para los exa\u0301menes se memorizan los ejercicios de pra\u0301cticas de las soluciones que se dan en clase.</p> <p>Plantearse uno mismo problemas</p> <p>Los problemas que me encontre\u0301 a la hora de cursar LPP fue que eran dos lenguajes completamente nuevos, otro tipo de programacio\u0301n que nunca habi\u0301a visto, otra forma de estudiar distinta. Para poder superarla simplemente tienes que hacer ejercicios y tambie\u0301n plantearte tu\u0301 mismo nuevos ejercicios.</p>"},{"location":"teoria/tema00-descripcion-asignatura/tema00-descripcion-asignatura.html#9-bibliografia","title":"9. Bibliograf\u00eda","text":"<p>En Moodle se publican los apuntes de la asignatura, con ejercicios, explicaciones y ejemplos de todos los conceptos estudiados, tanto en teor\u00eda como en pr\u00e1ctica.</p> <p>Para ampliar algunos conceptos se recomiendan las siguientes referencias:</p> <ul> <li>Harold Abelson y Gerald Jay Sussman, Structure and Interpretation of Computer Programs, MIT Press, 1996<ul> <li>Enlace a la edici\u00f3n on-line</li> <li>Signatura en la Biblioteca Polit\u00e9cnica: I.06/ABE/STR</li> </ul> </li> <li>Apple, The Swift Programming Language</li> <li>The Racket Guide</li> </ul> <p>Lenguajes y Paradigmas de Programaci\u00f3n, curso 2025-26 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Domingo Gallardo, Cristina Pomares, Antonio Bot\u00eda, Francisco Mart\u00ednez</p>"},{"location":"teoria/tema01-historia-lenguajes-programacion/tema01-historia-lenguajes-programacion.html","title":"Tema 1: Historia y conceptos de los lenguajes de programaci\u00f3n","text":""},{"location":"teoria/tema01-historia-lenguajes-programacion/tema01-historia-lenguajes-programacion.html#1-historia-de-los-lenguajes-de-programacion","title":"1. Historia de los lenguajes de programaci\u00f3n","text":""},{"location":"teoria/tema01-historia-lenguajes-programacion/tema01-historia-lenguajes-programacion.html#11-de-las-maquinas-de-calcular-a-los-computadores-programables","title":"1.1. De las m\u00e1quinas de calcular a los computadores programables","text":"M\u00e1quina de Schickard (1623) Calculadora de Pascal (1650) <p>Desde las primeras calculadoras mec\u00e1nicas dise\u00f1adas en el siglo XVII hasta los a\u00f1os 40 del siglo pasado se han inventado multitud de m\u00e1quinas y computadores mec\u00e1nicos, anal\u00f3gicos o electr\u00f3nicos que han intentado acelerar y mejorar la precisi\u00f3n de los c\u00e1lculos.</p> <p>El punto culminante de todos los enfoques mec\u00e1nicos para realizar c\u00e1lculos fue el famoso Motor Anal\u00edtico dise\u00f1ado por Charles Babbage en 1840. La diferencia fundamental con todos los artefactos anteriores es que se trataba de una m\u00e1quina de calcular programable mediante tarjetas perforadas (Babbage se inspir\u00f3 en el telar de Jackquard en el que el dise\u00f1o de los dibujos de las telas se pod\u00edan configurar usando tarjetas perforadas). La m\u00e1quina estaba dise\u00f1ada para trabajar en base 10 y se pod\u00eda conseguir que sus c\u00e1lculos realizaran saltos condicionales y bucles.</p> <p>Babbage trabaj\u00f3 durante m\u00e1s de 30 a\u00f1os para intentar construir la m\u00e1quina. Ten\u00eda una enorme complejidad para la \u00e9poca y necesitaba much\u00edsima financiaci\u00f3n. En 1871 muri\u00f3 habiendo podido construir s\u00f3lo una parte. </p> <p></p> <p>La matem\u00e1tica Ada Lovelace tuvo un papel fundamental en la divulgaci\u00f3n de la m\u00e1quina, de su sistema de programaci\u00f3n y fue la primera que entendi\u00f3 sus posibilidades m\u00e1s all\u00e1 del c\u00e1lculo de f\u00f3rmulas.</p> <p>De forma poco habitual para la \u00e9poca, Ada fue educada en el campo de las ciencias y de las matem\u00e1ticas. A principios de 1840, con veinticico a\u00f1os, conoci\u00f3 el trabajo de Babbage y colabor\u00f3 con \u00e9l, dedic\u00e1ndose durante varios a\u00f1os a conocer y estudiar el dise\u00f1o y el funcionamiento del motor anal\u00edtico.</p> <p>En 1843 public\u00f3 el trabajo \"Sketch of the analytical engine invented by Charles Babbage\" en el que describe el Motor Anal\u00edtico, a\u00f1ade reflexiones propias sobre el alcance del invento y construye un ejemplo completo, con tablas y diagramas, de c\u00f3mo hacer que la m\u00e1quina produzca la secuencia de los n\u00fameros de Bernoulli. Se puede considerar estas tablas y diagramas como el primer programa de un computador.</p> <p></p> <p>Antes de que existiera ning\u00fan computador real, en 1936, el matem\u00e1tico ingl\u00e9s Alan Turing formaliz\u00f3 la idea abstracta de computador, utilizando un modelo muy sencillo de procesamiento: una m\u00e1quina abstracta con un scanner que lee y escribe 0s y 1s de una cinta infinita (memoria) y se mueve y los escribe en funci\u00f3n de una tabla definida en la m\u00e1quina (programa). Con esta m\u00e1quina abstracta (M\u00e1quina de Turing) Turing explora la idea de lo computable y lo no computable. \u00bfExisten problemas no computables para los que no es posible inventar un algoritmo que los resuelva? Turing demuestra que s\u00ed y establece con su trabajo los l\u00edmites de la computaci\u00f3n.</p> <p>En el mismo trabajo Turing define el concepto de m\u00e1quina universal que es capaz de leer de la cinta un programa cualquiera y simular su comportamiento en otra parte de la cinta. Esta idea tuvo un profundo impacto en el desarrollo de los computadores, porque mostraba que es posible escribir programas que tomen como datos otros programas. Esto abre la puerta a la idea de los programas almacenados en memoria (ya que son otros datos m\u00e1s) y a la creaci\u00f3n de compiladores e int\u00e9rpretes.</p> <p>En la d\u00e9cada de 1940 hubo una explosi\u00f3n de m\u00e1quinas de computaci\u00f3n electr\u00f3nicas y electromec\u00e1nicas. Fue una d\u00e9cada prodigiosa en la que se desarrollaron tecnolog\u00edas cada vez m\u00e1s r\u00e1pidas y resistentes, y se consiguieron enormes avances en la velocidad y precisi\u00f3n de los c\u00e1lculos.</p> <p></p> <p>A mitad de esa d\u00e9cada, en 1945, John Von Neumann, que trabajaba en la construcci\u00f3n del ENIAC, introdujo un avance fundamental. Propuso su famosa arquitectura en la que por primera vez se proponen las dos ideas claves de los computadores de prop\u00f3sito general: el programa almacenado en memoria y un conjunto de instrucciones de procesamiento que incluye el direccionamiento indirecto.</p> <p>Y en 1948, tres a\u00f1os despu\u00e9s, se construy\u00f3 en la universidad de Manchester el primer computador electr\u00f3nico digital de prop\u00f3sito general que utilizaba esta arquitectura (llamado Baby). Fue dise\u00f1ado por Max Newmann usando la tecnolog\u00eda proporcionada por los ingenieros F.C. Williams y Tom Kilburn. Williams hab\u00eda inventado un dispositivo de memoria electr\u00f3nico (la v\u00e1lvula de Williams) capaz de sustituir las lentas l\u00edneas de retardo de mercurio utilizadas hasta ese momento.</p> <p></p> <p>La m\u00e1quina de Manchester fue el primer computador con un conjunto de instrucciones completo, capaz de realizar saltos, condicionales y direccionamiento indirecto. La primera ejecuci\u00f3n de un programa fue el 21 de junio de 1948. En ese a\u00f1o Alan Turing se incorpor\u00f3 a la universidad de Manchester, como director del Laboratorio de Computaci\u00f3n. Tres a\u00f1os despu\u00e9s, con un dise\u00f1o ampliado en el que tambi\u00e9n influy\u00f3 Turing, una versi\u00f3n mucho mayor de la m\u00e1quina se convirti\u00f3 en el primer computador disponible comercialmente, el Ferranti Mark I. El primero se instal\u00f3 en la universidad de Manchester en febrero de 1951, un mes antes que el UNIVAC I fuera entregado al Departamento de Censo de los EEUU. Se vendieron otras 10 m\u00e1quinas a Gran Breta\u00f1a, Canad\u00e1, Holanda e Italia.</p> <p>El primer programa complejo de Inteligencia Artificial, un jugador de damas escrito por Christopher Strachey, se ejecut\u00f3 en el verano de 1952 en el Ferranti Mark I en el Laboratorio de Computaci\u00f3n de Manchester. Strachey escribi\u00f3 el programa animado por Turing y usando el manual de programaci\u00f3n del Ferranti que Turing acababa de escribir. Turing particip\u00f3 tambi\u00e9n en el desarrollo de otros programas de IA, como un jugador de ajedrez basado en heur\u00edsticas.</p>"},{"location":"teoria/tema01-historia-lenguajes-programacion/tema01-historia-lenguajes-programacion.html#12-los-primeros-lenguajes-de-programacion","title":"1.2. Los primeros lenguajes de programaci\u00f3n","text":"<p>Los primeros computadores electr\u00f3nicos se programaban directamente usando el conjunto de instrucciones del procesador, en c\u00f3digo m\u00e1quina, c\u00f3digo hexadecimal</p> <p>El primer lenguaje de un nivel algo m\u00e1s elevado que el c\u00f3digo m\u00e1quina es el ensamblador. Comienzan a crearse los primeros programas que procesan lenguajes de programaci\u00f3n, aunque se trata de programas muy sencillos, ya que hay una relaci\u00f3n casi directa entre la notaci\u00f3n en ensamblador y el c\u00f3digo hexadecimal que produce el ensamblador.</p> <p>A finales de la d\u00e9cada de los 40 se empiezan a intentar resolver con los primeros computadores los primeros problemas matem\u00e1ticos distintos de operaciones num\u00e9ricas: codificaci\u00f3n y descodificaci\u00f3n, problemas combinatorios como el coloreado del mapa o problemas de ordenaci\u00f3n.</p> <p>Uno de los primeros algoritmos de von Neumann realiza una ordenaci\u00f3n de un conjunto de n\u00fameros. Von Neumann lo describe en una carta fechada en 1945. Utiliza el conjunto de instrucciones del EDSAC cuando todav\u00eda no se hab\u00eda construido. El programa fue estudiado por Donald Knuth en el art\u00edculo Von Neumann's first Computer Program, en donde documenta que hab\u00eda un bug en las primeras instrucciones. Es el primer bug escrito del que se tiene historia. Si Von Neumann hubiera podido ejecutar el programa en el EDSAC se hubiera dado cuenta del error y hubiera sido la primera depuraci\u00f3n de un programa.</p> <p></p> <p>Primer programa de Von Neumann</p> <p>(Donald Knuth, \"Von Neumann's first Computer Program\", Journal of the ACM Computing Surveys (CSUR) Surveys, Volume 2 Issue 4, Dec. 1970, Pages 247-260)</p>"},{"location":"teoria/tema01-historia-lenguajes-programacion/tema01-historia-lenguajes-programacion.html#13-el-nacimiento-de-los-computadores-comerciales","title":"1.3. El nacimiento de los computadores comerciales","text":"<p>UNIVAC</p> <p>El UNIVAC fue el primer computador comercial (1951). Con este computadora aparece por primera vez la figura del programador: manuales, cursos de formaci\u00f3n, ofertas de empleo, etc.</p> <p></p> <p>UNIVAC</p> <p></p> <p>Instalaciones comerciales del UNIVAC</p> <p>IBM 704</p> <p>El IBM 704 fue el otro gran ordenador comercial de la d\u00e9cada de los 50.</p> <p>Tuvo una difusi\u00f3n mucho mayor que el UNIVAC: centros gubernamentales, universidades.</p> <p>Los primeros lenguajes de programaci\u00f3n de alto nivel se desarrollan para este computador.</p> <p></p> <p>Foto IBM 704</p>"},{"location":"teoria/tema01-historia-lenguajes-programacion/tema01-historia-lenguajes-programacion.html#131-programando-los-primeros-computadores","title":"1.3.1. Programando los primeros computadores","text":"<p>El UNIVAC I era una m\u00e1quina interesante para programar, con su almacenamiento basado en l\u00edneas de retardo de mercurio y su propensi\u00f3n a fallar. Los programas se introduc\u00edan en el computador tecle\u00e1ndolos en cintas magn\u00e9ticas, una innovaci\u00f3n importante en ese tiempo.</p> <p>El trabajo con el IBM 704 en la Universidad de NY fue una experiencia radicalmente distinta de la del UNIVAC I. Fue construido para ejecutar aplicaciones cient\u00edficas, y su principal innovaci\u00f3n era una memoria de n\u00facleo magn\u00e9tico, reemplazando la memoria de tubos Williams del IBM 701. Tambi\u00e9n ten\u00eda una unidad aritm\u00e9tica en punto flotante. La m\u00e1quina ten\u00eda el equivalente a 128 KB de memoria principal, 32 KB de memoria secundaria y cintas magn\u00e9ticas que pod\u00eda almacenar 5 MB de datos. Operaba a 0.04 MIPS y cost\u00f3 3 millones de d\u00f3lares en 1957.</p> <p>George Sadowsky, My Second Computer was a UNIVAC I</p>"},{"location":"teoria/tema01-historia-lenguajes-programacion/tema01-historia-lenguajes-programacion.html#14-los-primeros-lenguajes-de-alto-nivel","title":"1.4. Los primeros lenguajes de alto nivel","text":"<p>Los primeros lenguajes de alto nivel se desarrollaron a finales de la d\u00e9cada de los 50:</p> <ul> <li>FORTRAN en 1956</li> <li>Lisp en 1958</li> </ul> <p>Ambos lenguajes planteaban dos enfoques muy distintos desde el principio:</p> <ul> <li>FORTRAN<ul> <li>Primer lenguaje comercial, equipo de IBM dirigido por John   W. Backus</li> <li>Lenguaje imperativo: estado, estructuras de control, contador de   programa, celdas de memoria</li> <li>Lenguaje compilado</li> </ul> </li> <li>Lisp<ul> <li>Lenguaje dise\u00f1ado en un departamento de investigaci\u00f3n, un equipo   del MIT dirigido por John McCarthy</li> <li>Lenguaje funcional: funciones, recursi\u00f3n, listas, s\u00edmbolos</li> <li>Lenguaje interpretado</li> </ul> </li> </ul>"},{"location":"teoria/tema01-historia-lenguajes-programacion/tema01-historia-lenguajes-programacion.html#141-fortran","title":"1.4.1. FORTRAN","text":"<p>Desarrollado por IBM para programar el IBM 704. Algunos datos:</p> <ul> <li>Su nombre proviene de FORmula TRANslating system.</li> <li>El primer manual de FORTRAN se imprime en octubre de 1956 para el IBM 704.</li> <li>El primer compilador se comercializa en abril de 1956.</li> </ul> <p>Cita de John Backus (Wikipedia sobre FORTRAN):</p> <p>Una gran parte de mi trabajo viene del hecho de que soy perezoso. No me gustaba escribir programas, y cuando estaba trabajando en el IBM 701, escribiendo programas para calcular la trayectoria de misiles, comenc\u00e9 a trabajar en un sistema de programaci\u00f3n que hiciera m\u00e1s f\u00e1cil escribir programas.</p> <p></p> <p>John Backus</p> <p></p> <p>Ejemplo FORTRAN</p> <p>Tomado del manual de FORTRAN del IBM 704</p>"},{"location":"teoria/tema01-historia-lenguajes-programacion/tema01-historia-lenguajes-programacion.html#142-lisp","title":"1.4.2. Lisp","text":"<p>El otro lenguaje de alto nivel desarrollado en esa \u00e9poca es el Lisp. Desarrollado a finales de los 50 en el MIT por John McCarthy.</p> <p>Aunque hist\u00f3ricamente el nombre del lenguaje se sol\u00eda escribir con letras may\u00fasculas (LISP), posteriormente se ha popularizado el uso de la may\u00fascula s\u00f3lo para la primera letra (Lisp). Esta forma es m\u00e1s fiel al origen del nombre del lenguaje. Lisp no es un acr\u00f3nimo, sino la contracci\u00f3n de la expresi\u00f3n List Processing. El procesamiento de listas es una de las caracter\u00edsticas principales del Lisp.</p> <p>McCarthy explica en un art\u00edculo de 1979 la historia inicial del Lisp:</p> <p>[...] En el verano de 1956 durante el Dartmouth Summer Research Project on Artificial Intelligence, el primer estudio organizado de Inteligencia Artificial, tuve la idea de desarrollar un lenguaje algebraico para el procesamiento de listas. Quer\u00eda usarlo para el desarrollo de trabajo en inteligencia artificial en el IBM 704. [...]  John McCarthy, History of LISP</p> <p></p> <p>John McCarthy</p> <p>Uno de los primeros manuales de Lisp publicados es el manual de LISP de 1960 para el IBM 704 escrito por Phyllis A. Fox. del grupo de investigaci\u00f3n del MIT dirigido por McCarthy.</p> <p>Un ejemplo de c\u00f3digo Lisp:</p> <p></p> <p>Ejemplo LISP</p> <p>Tomado de \"The Programming Language LISP\", MIT Press, 1964</p>"},{"location":"teoria/tema01-historia-lenguajes-programacion/tema01-historia-lenguajes-programacion.html#15-la-explosion-de-los-lenguajes-de-programacion","title":"1.5. La explosi\u00f3n de los lenguajes de programaci\u00f3n","text":"<p>Desde 1954 hasta la actualidad se han documentado m\u00e1s de 2.500 (consultar en The Language List).  Entre 1952 y 1972 alrededor de 200 lenguajes. Una decena fueron realmente significativos y tuvieron influencia en el desarrollo de lenguajes posteriores.</p>"},{"location":"teoria/tema01-historia-lenguajes-programacion/tema01-historia-lenguajes-programacion.html#151-genealogia-de-los-lenguajes-de-programacion","title":"1.5.1. Genealog\u00eda de los lenguajes de programaci\u00f3n","text":"<p>Genealog\u00eda de los LP</p> <p>Algunas notas sobre la genealog\u00eda:</p> <ul> <li> <p>APL es un lenguaje algebraico declarativo de especificaci\u00f3n de   funciones y circuitos l\u00f3gicos. Su car\u00e1cter declarativo ha tenido   influencia en lenguajes como Prolog o Haskell.</p> </li> <li> <p>Lisp no s\u00f3lo es un lenguaje funcional, sino que tambi\u00e9n es el primer   lenguaje interpretado, con muchas caracter\u00edsticas de tiempo de   ejecuci\u00f3n y poco chequeo est\u00e1tico. En esos aspectos ha influido en   lenguajes din\u00e1micos no funcionales como Python o   Smalltalk. Lenguajes como Smalltalk o Objective-C tambi\u00e9n heredan de   Lisp algunas caracter\u00edsticas funcionales como la posibilidad de usar   un bloque de c\u00f3digo como un objeto primitivo que se crea en tiempo   de ejecuci\u00f3n y que se puede asignar o pasar como par\u00e1metro. Es lo   que se denomina clausura en el paradigma de programaci\u00f3n   funcional.</p> </li> <li> <p>SIMULA es el primer lenguaje que define conceptos como clase u   objeto. Es el origen de la programaci\u00f3n orientada a objetos est\u00e1tica   y fuertemente tipeada. Lenguajes como C++, Eiffel, o Java toman esta   idea. Frente a esta tendencia se encuentra otra visi\u00f3n de la   programaci\u00f3n orientada a objetos de lenguajes como Smalltalk u   Objective-C en la que se enfatiza m\u00e1s aspectos din\u00e1micos como el   paso de mensajes o la modificaci\u00f3n de clases en tiempo de ejecuci\u00f3n.</p> </li> </ul>"},{"location":"teoria/tema01-historia-lenguajes-programacion/tema01-historia-lenguajes-programacion.html#152-algunos-lenguajes-importantes-y-su-fecha-de-creacion","title":"1.5.2. Algunos lenguajes importantes y su fecha de creaci\u00f3n","text":"1950-1960 1970 1980 1990 2000 1957 FORTRAN 1970 Pascal 1980 Smalltalk-80 1990 Haskell 2000 C# 1958 ALGOL 1972 Prolog 1983 Objective-C 1991 Python 2003 Scala 1960 Lisp 1972 C 1983 Ada 1993 Ruby 2003 Groovy 1960 COBOL 1975 Scheme 1986 C++ 1995 Java 2009 Go 1962 APL 1975 Modula 1986 Eiffel 1995 Racket 2014 Swift 1964 BASIC 1987 Perl 1967 SIMULA"},{"location":"teoria/tema01-historia-lenguajes-programacion/tema01-historia-lenguajes-programacion.html#153-los-creadores-de-los-lps","title":"1.5.3. Los creadores de los LPs","text":"<p>Si comprobamos la historia de los lenguajes de programaci\u00f3n, podemos clasificar a sus creadores en tres grandes categor\u00edas:</p> <ul> <li>Investigadores trabajando en empresas (Backus/IBM-FORTRAN, Gosling/Sun-Java)</li> <li>Investigadores en universidades y departamentos de Inform\u00e1tica   (McCarthy/MIT-Lisp,   Wirth/ETH-Pascal,   Odersky/EHT-Scala)</li> <li>Desarrolladores open source que distribuyen su trabajo a la   comunidad (Wall/Perl,   Matsumoto/Ruby)</li> </ul>"},{"location":"teoria/tema01-historia-lenguajes-programacion/tema01-historia-lenguajes-programacion.html#16-lenguajes-de-programacion-en-la-actualidad","title":"1.6. Lenguajes de programaci\u00f3n en la actualidad","text":"<p>El \u00edndice TIOBE es un indicador de la popularidad de los lenguajes de programaci\u00f3n. El \u00edndice se actualiza una vez al mes. Las puntaciones se basan en estad\u00edsticas no reveladas que incluyen el n\u00famero de ingenieros en todo el mundo, cursos y aplicaciones desarrolladas. Tambi\u00e9n se utilizan resultados obtenidos en los motores de b\u00fasqueda m\u00e1s usados.</p> <p>El \u00edndice TIOBE no trata de medir el n\u00famero de l\u00edneas escritas en los lenguajes de programaci\u00f3n sino su popularidad e importancia en la comunidad.</p> <p></p> <p>Lista TIOBE</p> <p>Tambi\u00e9n es muy interesante comprobar la evoluci\u00f3n de los 10 lenguajes m\u00e1s populares en los \u00faltimos 10 a\u00f1os.</p> <p></p> <p>Evoluci\u00f3n TIOBE</p>"},{"location":"teoria/tema01-historia-lenguajes-programacion/tema01-historia-lenguajes-programacion.html#161-la-evolucion-no-se-detiene","title":"1.6.1. La evoluci\u00f3n no se detiene","text":"<p>Es interesante comprobar que cada vez es m\u00e1s f\u00e1cil desarrollar nuevos lenguajes de programaci\u00f3n. Las t\u00e9cnicas y herramientas de procesamiento de lenguajes se han popularizado cada vez m\u00e1s y son accesibles a mayor n\u00famero de personas. Los lenguajes ya no s\u00f3lo se crean en departamentos con un gran n\u00famero de investigadores, sino tambi\u00e9n en comunidades open source formadas por voluntarios interesados y motivados</p> <p>Ejemplos de nuevos lenguajes y sus creadores:</p> <p>Ruby</p> <p></p> <p>Yukihiro Matsumoto</p> <ul> <li>Ruby   (Wikipedia),   un lenguaje de programaci\u00f3n ideado en 1993 por el desarrollador   japon\u00e9s Yukihiro Matsumoto</li> <li>Lenguaje multi-paradigma interpretado y muy expresivo que   actualmente se utiliza tanto para desarrollar aplicaciones web como   videojuegos.</li> <li>Proyecto vivo, cada a\u00f1o aparecen nuevas versiones</li> </ul> <p>Scala</p> <p></p> <p>Martin Odersky</p> <ul> <li>Scala   (Wikipedia),   dise\u00f1ado en 2003 por el profesor alem\u00e1n Martin Odersky</li> <li>Respuesta a los problemas de los lenguajes tradicionales imperativos   para manejar la concurrencia</li> <li>Est\u00e1 implementado sobre Java y corre en la M\u00e1quina Virtual Java</li> </ul> <p>Go</p> <p></p> <p>Ken Thompson</p> <ul> <li>Go   (Wikipedia),   el nuevo lenguaje de programaci\u00f3n de Google lanzado en 2009</li> <li>Desarrollado, entre otros, por Ken Thompson, uno de los padres del   UNIX</li> <li>Una mezcla de C y Python que intenta conseguir un lenguaje de programaci\u00f3n de sistemas muy eficiente, expresivo y tambi\u00e9n multiparadigma.</li> </ul> <p>Swift</p> <p></p> <p>Chris Lattner</p> <ul> <li>Swift   (Wikipedia),   el nuevo lenguaje de programaci\u00f3n de Apple lanzado en 2014</li> <li>Proyecto open source en el que se puede   observar su   evoluci\u00f3n y roadmap futuro</li> <li>Desarrollado, entre otros, por   Chris Lattner, autor del sistema   LLVM Compiler Infrastructure, conjunto de compilador, depurador,   optimizador, etc. de c\u00f3digo C, C++ y Objective-C.</li> <li>Lenguaje moderno, multiparadigma (programaci\u00f3n orientada a objetos y   funcional) fuertemente tipeado y compilado.</li> </ul>"},{"location":"teoria/tema01-historia-lenguajes-programacion/tema01-historia-lenguajes-programacion.html#2-elementos-de-los-lenguajes-de-programacion","title":"2. Elementos de los lenguajes de programaci\u00f3n","text":""},{"location":"teoria/tema01-historia-lenguajes-programacion/tema01-historia-lenguajes-programacion.html#21-definicion-de-la-encyclopedia-of-computer-science","title":"2.1. Definici\u00f3n de la Encyclopedia of Computer Science","text":"<p>Un lenguaje de programaci\u00f3n es un conjunto de caracteres, reglas para combinarlos y reglas para especificar sus efectos cuando sean ejecutados por un computador, que tienen las siguientes cuatro caracter\u00edsticas:</p> <ol> <li>No requiere ning\u00fan conocimiento de c\u00f3digo m\u00e1quina por parte del    usuario.</li> <li>Tiene independencia de la m\u00e1quina.</li> <li>Se traduce a lenguaje m\u00e1guina.</li> <li>Utiliza una notaci\u00f3n que es m\u00e1s cercana al problema espec\u00edfico que    se est\u00e1 resolviendo que al c\u00f3digo m\u00e1quina.</li> </ol>"},{"location":"teoria/tema01-historia-lenguajes-programacion/tema01-historia-lenguajes-programacion.html#22-definicion-de-abelson-y-sussman","title":"2.2. Definici\u00f3n de Abelson y Sussman","text":"<p>Vamos a estudiar la idea de un proceso computacional. Los procesos computacionales son seres abstractos que habitan los computadores. Cuando est\u00e1n en marcha, los procesos manipulan otras cosas abstractas denominadas datos. La evoluci\u00f3n de un proceso est\u00e1 dirigida por un patr\u00f3n de reglas denominado un programa. [...] </p> <p>Y otra idea fundamental</p> <p>Un lenguaje de programaci\u00f3n potente es m\u00e1s que s\u00f3lo una forma de pedir a un computador que realice tareas. El lenguaje tambi\u00e9n sirve como un marco dentro del que organizamos nuestras ideas acerca de los procesos. As\u00ed, cuando describimos un lenguaje, deber\u00edamos prestar atenci\u00f3n particular a los medios que proporciona el lenguaje para combinar ideas simples para formar ideas m\u00e1s complejas.</p>"},{"location":"teoria/tema01-historia-lenguajes-programacion/tema01-historia-lenguajes-programacion.html#23-caracteristicas-de-un-lp","title":"2.3. Caracter\u00edsticas de un LP","text":"<ol> <li>Define un proceso que se ejecuta en un computador</li> <li>Es de alto nivel, cercano a los problemas que se quieren resolver    (abstracci\u00f3n)</li> <li>Permite construir nuevas abstracciones que se adapten al dominio    que se programa</li> </ol>"},{"location":"teoria/tema01-historia-lenguajes-programacion/tema01-historia-lenguajes-programacion.html#24-elementos-de-un-lp","title":"2.4. Elementos de un LP","text":"<p>Para Abelson y Sussman, todos los lenguajes de progamaci\u00f3n permiten combinar ideas simples en ideas m\u00e1s complejas mediante los siguientes tres mecanismos</p> <ul> <li>Expresiones primitivas que representan las entidades m\u00e1s simples   del lenguaje</li> <li>Mecanismos de combinaci\u00f3n con los que se construyen elementos   compuestos a partir de elementos m\u00e1s simples</li> <li>Mecanismos de abstracci\u00f3n con los que dar nombre a los elementos   compuestos y manipularlos como unidades</li> </ul>"},{"location":"teoria/tema01-historia-lenguajes-programacion/tema01-historia-lenguajes-programacion.html#25-sintaxis-y-semantica","title":"2.5. Sintaxis y sem\u00e1ntica","text":"<p>Sintaxis: conjunto de reglas que definen qu\u00e9 expresiones de texto  son correctas. Por ejemplo, en C todas las sentencias deben terminar  en ';'.</p> <p>Sem\u00e1ntica: conjunto de reglas que define cu\u00e1l ser\u00e1 el resultado de la ejecuci\u00f3n de un programa en el computador.</p>"},{"location":"teoria/tema01-historia-lenguajes-programacion/tema01-historia-lenguajes-programacion.html#26-los-lenguajes-son-para-las-personas","title":"2.6. Los lenguajes son para las personas","text":"<p>Los lenguajes de programaci\u00f3n deben ser precisos, deben poder traducirse sin ambig\u00fcedad en lenguaje m\u00e1quina para que sean ejecutados por computadores. Pero deben ser utilizados (le\u00eddos, comentados, probados, etc.) por personas.</p> <p>La programaci\u00f3n es una actividad colaborativa y debe basarse en la comunicaci\u00f3n.</p>"},{"location":"teoria/tema01-historia-lenguajes-programacion/tema01-historia-lenguajes-programacion.html#27-importancia-del-aprendizaje-de-tecnicas-de-lps","title":"2.7. Importancia del aprendizaje de t\u00e9cnicas de LPs","text":"<p>Es importante conocer c\u00f3mo funciona \"por dentro\" un lenguaje de programaci\u00f3n y sus caracter\u00edsticas comparadas.</p> <ul> <li>Mejora el uso del lenguaje de programaci\u00f3n</li> <li>Incrementa el vocabulario de los elementos de programaci\u00f3n</li> <li>Permite una mejor elecci\u00f3n del lenguaje de programaci\u00f3n</li> <li>Mejora la habilidad para desarrollar programas efectivos y eficientes</li> <li>Facilita el aprendizaje de un nuevo lenguaje de programaci\u00f3n</li> <li>Facilita el dise\u00f1o de nuevos lenguajes de programaci\u00f3n</li> </ul>"},{"location":"teoria/tema01-historia-lenguajes-programacion/tema01-historia-lenguajes-programacion.html#3-abstraccion","title":"3. Abstracci\u00f3n","text":"<p>Una misi\u00f3n fundamental de los lenguajes de programaci\u00f3n es proporcionar herramientas que sirvan para construir abstracciones. Por ejemplo, estamos construyendo una abstracci\u00f3n cuando damos un nombre a una entidad del lenguaje (una variable, una funci\u00f3n, una clase, etc.).</p> <p>Escoger un buen nombre para los elementos que vamos construyendo en nuestro programas es fundamental para conseguir un c\u00f3digo legible y reutilizable.</p>"},{"location":"teoria/tema01-historia-lenguajes-programacion/tema01-historia-lenguajes-programacion.html#31-modelar-como-una-actividad-fundamental","title":"3.1. Modelar como una actividad fundamental","text":"<ul> <li>Para escribir un programa que preste unos servicios es fundamental   modelar el dominio sobre el que va a trabajar</li> <li>Es necesario definir distintas abstracciones (tanto APIs, como   datos) que nos permitan tratar sus elementos y comunicarnos   correctamente con los usuarios que van a utilizar el programa.</li> <li>Las abstracciones que vamos construyendo van apoy\u00e1ndose unas en   otras y permiten hacer compresible y comunicable un problema   complejo</li> <li>Ejemplo: el modelado del funcionamiento de una biblioteca contiene   abstracciones como \"libros\", \"pr\u00e9stamo\", \"reserva\", o \"libros   disponibles\" que representan conceptos del dominio que deben ser   implementados en nuestra soluci\u00f3n</li> </ul> <p>Casos de uso biblioteca</p>"},{"location":"teoria/tema01-historia-lenguajes-programacion/tema01-historia-lenguajes-programacion.html#32-abstracciones-computacionales","title":"3.2. Abstracciones computacionales","text":"<p>Existen abstracciones propias de la inform\u00e1tica (computer science), que se utilizan en m\u00faltiples dominios. Por ejemplo, abstracciones de datos como:</p> <ul> <li>Listas</li> <li>\u00c1rboles</li> <li>Grafos</li> <li>Tablas hash</li> </ul> <p>Tambi\u00e9n existen abstracciones que nos permiten tratar con dispositivos y ordenadores externos:</p> <ul> <li>Fichero</li> <li>Raster gr\u00e1fico</li> <li>Protocolo TCP/IP</li> </ul>"},{"location":"teoria/tema01-historia-lenguajes-programacion/tema01-historia-lenguajes-programacion.html#33-construccion-de-abstracciones","title":"3.3. Construcci\u00f3n de abstracciones","text":"<p>Uno de los trabajos principales de un inform\u00e1tico es la construcci\u00f3n de abstracciones que permitan ahorrar tiempo y esfuerzo a la hora de tratar con la complejidad del mundo real.</p> <p>Cita de Joel Spolsky en su blog Joel on Software</p> <p>TCP es lo que los cient\u00edficos de computaci\u00f3n llaman una abstracci\u00f3n: una simplificaci\u00f3n de algo mucho m\u00e1s complicado que va por debajo de la cubierta. Resulta que una gran parte de la programaci\u00f3n de computadores consiste en construir abstracciones. \u00bfQu\u00e9 es una librer\u00eda de cadenas? Es una forma de hacer creer que los computadores pueden manipular cadenas tan f\u00e1cilmente como manipulan los n\u00fameros. \u00bfQu\u00e9 es un sistema de ficheros? Es una forma de hacer creer que un disco duro no es en realidad un mont\u00f3n de platos magn\u00e9ticos en rotaci\u00f3n que pueden almacenar bits en ciertas posiciones, sino en su lugar, un sistema jer\u00e1rquico de carpetas-dentro-de-carpetas que contiene ficheros individuales.</p>"},{"location":"teoria/tema01-historia-lenguajes-programacion/tema01-historia-lenguajes-programacion.html#34-distintos-aspectos-de-los-lenguajes-de-programacion","title":"3.4. Distintos aspectos de los lenguajes de programaci\u00f3n","text":"<p>La programaci\u00f3n es una disciplina compleja, que tiene que tener en cuenta m\u00faltiples aspectos de los lenguajes de programaci\u00f3n y las API:</p> <ol> <li> <p>Programas como procesos runtime que se ejecutan en un    computador. Tenemos que entender qu\u00e9 pasa cuando se crea un objeto,    cu\u00e1nto tiempo permanece en memoria, cu\u00e1l es el \u00e1mbito de una    variable, etc.</p> <p>Herramientas: depuradores, analizadores de rendimiento.</p> </li> <li> <p>Programas como declaraciones est\u00e1ticas. Hay que considerar un    programa desde el punto de vista de una declaraci\u00f3n de nuevos    tipos, nuevos m\u00e9todos, tipos gen\u00e9ricos, herencia entre clases, etc.</p> <p>Herramientas: entornos de programaci\u00f3n con autocompletado de c\u00f3digo, detecci\u00f3n de errores sint\u00e1cticos.</p> </li> <li> <p>Programas como comunicaci\u00f3n y actividad social. Tenemos que tener    en cuenta que un programa va a ser usado por otras personas, le\u00eddo,    extendido, mantenido, modificado. Los programas siempre se van a    modificar.</p> <p>Herramientas: sistemas de control de versiones (Git, Mercurial, Github, Bitbucket), de gesti\u00f3n incidencias (Jira) , tests que evitan errores de regresi\u00f3n, ...</p> </li> </ol>"},{"location":"teoria/tema01-historia-lenguajes-programacion/tema01-historia-lenguajes-programacion.html#4-paradigmas-de-programacion","title":"4. Paradigmas de programaci\u00f3n","text":""},{"location":"teoria/tema01-historia-lenguajes-programacion/tema01-historia-lenguajes-programacion.html#41-que-es-un-paradigma-de-programacion","title":"4.1. \u00bfQu\u00e9 es un paradigma de programaci\u00f3n?","text":"<p>Un paradigma define un conjunto de caracter\u00edsticas, patrones y estilos de programaci\u00f3n basados en alguna idea fundamental. Por ejemplo el paradigma funcional se basa en la idea que una computaci\u00f3n se puede especificar como un conjunto de funciones que transforman valores de entrada en valores de salida.</p> <p>Es conveniente ver un paradigma como un estilo de programaci\u00f3n que puede usarse en distintos lenguajes de programaci\u00f3n y expresarse con distintas sintaxis. Por ejemplo, se puede escribir c\u00f3digo que use programaci\u00f3n l\u00f3gica en Prolog (ser\u00eda lo m\u00e1s natural), pero tambi\u00e9n en Java, usando alg\u00fan API espec\u00edfica.</p> <p>Normalmente todos los lenguajes tienen caracter\u00edsticas de m\u00e1s de un paradigma. Por motivos pr\u00e1cticos los lenguajes m\u00e1s populares no se limitan de forma estricta o pura a un \u00fanico paradigma de programaci\u00f3n.</p> <p>Por ejemplo, el Prolog es un lenguaje en su mayor parte l\u00f3gico y declarativo, pero tiene operadores imperativos como el corte. A pesar de ello, es normal adscribir un lenguaje al paradigma en el que es m\u00e1s sencillo o natural escribir c\u00f3digo usando sus construcciones.</p> <p>Existen lenguajes que refuerzan y promueven la expresi\u00f3n de c\u00f3digo en m\u00e1s de un paradigma de programaci\u00f3n. Y lo hacen no por necesidad o accidente, sino con el intento expl\u00edcito de fusionar m\u00e1s de un paradigma en una forma \u00fanica de programar. Estos lenguajes se denominan lenguajes multi-paradigma.</p> <p>Por ejemplo, Scala es lenguaje multi-paradigma en el que Martin Odersky, su creador, mezcla caracter\u00edsticas de programaci\u00f3n orientada a objetos con programaci\u00f3n funcional.</p> <p>Prolog o Lisp, aunque tienen caracter\u00edsticas no l\u00f3gicas o no funcionales, no pueden ser considerados multi-paradigma porque no fueron creados con la idea de integrar paradigmas variados en una forma coherente de expresi\u00f3n.</p> <p>Los paradigmas m\u00e1s importantes son:</p> <ul> <li>Paradigma funcional</li> <li>Paradigma l\u00f3gico</li> <li>Paradigma imperativo o procedural</li> <li>Paradigma orientado a objetos</li> </ul>"},{"location":"teoria/tema01-historia-lenguajes-programacion/tema01-historia-lenguajes-programacion.html#42-paradigma-funcional","title":"4.2. Paradigma funcional","text":"<p>Resumen de las caracter\u00edsticas principales:</p> <ul> <li>La computaci\u00f3n se realiza mediante la evaluaci\u00f3n de expresiones</li> <li>Definici\u00f3n de funciones</li> <li>Funciones como datos primitivos</li> <li>Valores sin efectos laterales, no existen referencias a celdas de   memoria en las que se guarda un estado modificable</li> <li>Programaci\u00f3n declarativa (en la programaci\u00f3n funcional pura)</li> </ul> <p>Lenguajes: Lisp, Scheme, Haskell, Scala, Clojure.</p> <p>Ejemplo de c\u00f3digo (Lisp):</p> <pre><code>(define (factorial x)\n   (if (= x 0)\n      1\n      (* x (factorial (- x 1)))))\n\n&gt;(factorial 8)\n40320\n&gt;(factorial 30)\n265252859812191058636308480000000\n</code></pre>"},{"location":"teoria/tema01-historia-lenguajes-programacion/tema01-historia-lenguajes-programacion.html#43-paradigma-logico","title":"4.3. Paradigma l\u00f3gico","text":"<p>Caracter\u00edsticas:</p> <ul> <li>Definici\u00f3n de reglas</li> <li>Unificaci\u00f3n como elemento de computaci\u00f3n</li> <li>Programaci\u00f3n declarativa</li> </ul> <p>Lenguajes: Prolog, Mercury, Oz.</p> <p>Ejemplo de c\u00f3digo (Prolog):</p> <pre><code>padrede('juan', 'maria'). % juan es padre de maria\npadrede('pablo', 'juan'). % pablo es padre de juan\npadrede('pablo', 'marcela').\npadrede('carlos', 'debora').\n\nhijode(A,B) :- padrede(B,A).\nabuelode(A,B) :-  padrede(A,C), padrede(C,B).\nhermanode(A,B) :- padrede(C,A) , padrede(C,B), A \\== B.        \n\nfamiliarde(A,B) :- padrede(A,B).\nfamiliarde(A,B) :- hijode(A,B).\nfamiliarde(A,B) :- hermanode(A,B).\n\n?- hermanode('juan', 'marcela').\nyes\n?- hermanode('carlos', 'juan').\nno\n?- abuelode('pablo', 'maria').\nyes\n?- abuelode('maria', 'pablo').\nno\n</code></pre>"},{"location":"teoria/tema01-historia-lenguajes-programacion/tema01-historia-lenguajes-programacion.html#44-paradigma-imperativo","title":"4.4. Paradigma imperativo","text":"<p>Los lenguajes de programaci\u00f3n que cumplen el paradigma imperativo se caracterizan por tener un estado impl\u00edcito que es modificado mediante instrucciones o comandos del lenguaje. Como resultado, estos lenguajes tienen una noci\u00f3n de secuenciaci\u00f3n de los comandos para permitir un control preciso y determinista del estado.</p> <p>Caracter\u00edsticas:</p> <ul> <li>Definici\u00f3n de procedimientos</li> <li>Definici\u00f3n de tipos de datos</li> <li>Chequeo de tipos en tiempo de compilaci\u00f3n</li> <li>Cambio de estado de variables</li> <li>Pasos de ejecuci\u00f3n de un proceso</li> </ul> <p>Ejemplo (Pascal):</p> <pre><code>type\n   tDimension = 1..100;\n   eMatriz(f,c: tDimension) = array [1..f,1..c] of real;\n\n   tRango = record\n      f,c: tDimension value 1;\n   end;\n\n   tpMatriz = ^eMatriz;\n\nprocedure EscribirMatriz(var m: tpMatriz);\nvar filas,col : integer;\nbegin\n   for filas := 1 to m^.f do begin\n      for col := 1 to m^.c do\n         write(m^[filas,col]:7:2);\n      writeln(resultado);\n      writeln(resultado)\n     end;    \nend;\n</code></pre>"},{"location":"teoria/tema01-historia-lenguajes-programacion/tema01-historia-lenguajes-programacion.html#45-paradigma-orientado-a-objetos","title":"4.5. Paradigma orientado a objetos","text":"<p>Caracter\u00edsticas:</p> <ul> <li>Definici\u00f3n de clases y herencia</li> <li>Objetos como abstracci\u00f3n de datos y procedimientos</li> <li>Polimorfismo y chequeo de tipos en tiempo de ejecuci\u00f3n</li> </ul> <p>Ejemplo (Java):</p> <pre><code>public class Bicicleta {\n    public int marcha;\n    public int velocidad;\n\n    public Bicicleta(int velocidadInicial, int marchaInicial) {\n        marcha = marchaInicial;\n        velocidad = velocidadInicial;\n    }\n\n    public void setMarcha(int nuevoValor) {\n        marcha = nuevoValor;\n    }\n\n    public void frenar(int decremento) {\n        velocidad -= decremento;\n    }\n\n    public void acelerar(int incremento) {\n        velocidad += incremento;\n    }\n}\n\npublic class MountainBike extends Bicicleta {\n    public int alturaSillin;\n\n    public MountainBike(int alturaInicial,\n                        int velocidadInicial,\n                        int marchaInicial) {\n        super(velocidadInicial, marchaInicial);\n        alturaSillin = alturaInicial;\n    }   \n\n    public void setAltura(int nuevoValor) {\n        alturaSillin = nuevoValor;\n    }   \n}\n\npublic class Excursion {\n    public static void main(String[] args) {\n        MountainBike miBicicleta = new MoutainBike(10,10,3);\n        miBicicleta.acelerar(10);\n        miBicicleta.setMarcha(4);\n        miBicicleta.frenar(10);\n    }\n}\n</code></pre>"},{"location":"teoria/tema01-historia-lenguajes-programacion/tema01-historia-lenguajes-programacion.html#5-compiladores-e-interpretes","title":"5. Compiladores e int\u00e9rpretes","text":"<p>En el nivel de abstracci\u00f3n m\u00e1s bajo, la ejecuci\u00f3n de un programa en un computador consiste en la ejecuci\u00f3n de un conjunto de instrucciones del c\u00f3digo m\u00e1quina del procesador. Por ejemplo, la siguiente figura muestra un ejemplo de un programa en ensamblador para un antiguo procesador (el Z80, procesador de 8 bits del m\u00edtico ZX Spectrum, uno de los primeros ordenadores personales en Europa):</p> <p></p> <p>Ensamblador Z80</p> <p>Dependiendo del tipo de lenguaje de programaci\u00f3n en el que est\u00e9 escrito este programa, el c\u00f3digo m\u00e1quina que se estar\u00e1 ejecutando ser\u00e1:</p> <ul> <li>el resultado de la compilaci\u00f3n del programa original (en el caso de   un lenguaje compilado)</li> <li>el c\u00f3digo de un programa (int\u00e9rprete) que realiza la interpretaci\u00f3n   del programa original (en el caso de un lenguaje interpretado)</li> </ul>"},{"location":"teoria/tema01-historia-lenguajes-programacion/tema01-historia-lenguajes-programacion.html#51-compilacion","title":"5.1. Compilaci\u00f3n","text":"<p>La siguiente figura (tomada, como las dem\u00e1s de este apartado del Programming Language Pragmatics) muestra el proceso de generaci\u00f3n y ejecuci\u00f3n de un programa compilado.</p> <p></p> <p>Compilaci\u00f3n</p> <p>El proceso de compilaci\u00f3n de un programa consiste en la traducci\u00f3n del c\u00f3digo fuente original en el lenguaje de alto nivel al c\u00f3digo m\u00e1quina espec\u00edfico del procesador en el que va a ejecutarse el programa. El c\u00f3digo m\u00e1quina resultante s\u00f3lo corre en el procesador para el que se ha generado. Por ejemplo, un programa C compilado para un procesador Intel no puede ejecutarse en un procesador ARM, como los Ax de Apple.</p> <ul> <li>Ejemplos: C, C++</li> <li>Diferentes momentos en la vida de un programa: tiempo de compilaci\u00f3n   y tiempo de ejecuci\u00f3n</li> <li>Mayor eficiencia</li> </ul>"},{"location":"teoria/tema01-historia-lenguajes-programacion/tema01-historia-lenguajes-programacion.html#52-interpretacion","title":"5.2. Interpretaci\u00f3n","text":"<p>Interpretaci\u00f3n</p> <ul> <li>Ejemplos: BASIC, Lisp, Scheme, Python, Ruby</li> <li>No hay diferencia entre el tiempo de compilaci\u00f3n y el tiempo de ejecuci\u00f3n</li> <li>Mayor flexibilidad: el c\u00f3digo se puede construir y ejecutar \"on the   fly\" (funciones lambda o clousures)</li> </ul> <p>Los lenguajes interpretados suelen proporcionar un shell o int\u00e9rprete. Se trata de un entorno interactivo en el que podemos definir y evaluar expresiones. Este entorno se denomina en los c\u00edrculos de programaci\u00f3n funcional un REPL (Read, Eval, Print, Loop) y ya se utiliz\u00f3 en los primeros a\u00f1os de implementaci\u00f3n del Lisp. El uso del REPL promueve una programaci\u00f3n interactiva en la que continuamente evaluamos y comprobamos el c\u00f3digo que desarrollamos.</p>"},{"location":"teoria/tema01-historia-lenguajes-programacion/tema01-historia-lenguajes-programacion.html#53-enfoques-mixtos","title":"5.3. Enfoques mixtos","text":"<p>Existen tambi\u00e9n enfoques mixtos, como el usado por el lenguaje de programaci\u00f3n Java, en el que se realizan ambos procesos.</p> <p>En una primera fase el compilador de Java (<code>javac</code>) realiza una traducci\u00f3n del c\u00f3digo fuente original a un c\u00f3digo intermedio binario independiente del procesado, denominado bytecode. Este c\u00f3digo binario es multiplataforma.</p> <p>El c\u00f3digo intermedio es interpretado despu\u00e9s por un el int\u00e9rprete (<code>java</code>) que ya s\u00ed que es dependiente de la plataforma. En la figura el int\u00e9rprete se denomina Virtual machine (no confundir con el concepto de m\u00e1quina virtual que permite emular un sistema operativo, por ejemplo VirtualBox).</p> <p></p> <p>Enfoque mixto (Java)</p> <ul> <li>Ejemplos: Java, Scala</li> </ul>"},{"location":"teoria/tema01-historia-lenguajes-programacion/tema01-historia-lenguajes-programacion.html#6-bibliografia","title":"6. Bibliograf\u00eda","text":"<ul> <li>Introducci\u00f3n y cap\u00edtulo 1 del Structure and Interpretation of Computer Programs: Building Abstractions with   Procedures</li> <li>Cap\u00edtulo 1.2 Programming Language Pragmatics: The Programming Language Spectrum</li> <li>Cap\u00edtulo 1.3 Programming Language Pragmatics, Why Study Programming Languages</li> <li>Cap\u00edtulo 1.4 Programming Language Pragmatics, Compilation and Interpretation</li> <li>Raul Rojas, \"Konrad Zuse's legacy the architecture of the Z1 and   Z3\", IEEE Annals of the History of Computing, Vol. 19, No. 2, 1997</li> <li>Charles Petzold, \"Code\", Microsoft Press, 2000 (Cap\u00edtulo 18: \"From   Abaci to Chips\")</li> <li>Jack Copeland, \"The Modern History of Computing\", The Stanford   Encyclopedia of Philosophy (Fall 2008 Edition), URL =   http://plato.stanford.edu/archives/fall2008/entries/computing-history/</li> <li>Georgi Dalakov, \"History of Computers\", URL =   http://history-computer.com</li> </ul> <p>Lenguajes y Paradigmas de Programaci\u00f3n, curso 2025-26 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Domingo Gallardo, Cristina Pomares, Antonio Bot\u00eda, Francisco Mart\u00ednez</p>"},{"location":"teoria/tema02-programacion-funcional/tema02-programacion-funcional.html","title":"Tema 2: Programaci\u00f3n funcional","text":""},{"location":"teoria/tema02-programacion-funcional/tema02-programacion-funcional.html#1-el-paradigma-de-programacion-funcional","title":"1. El paradigma de Programaci\u00f3n Funcional","text":""},{"location":"teoria/tema02-programacion-funcional/tema02-programacion-funcional.html#11-pasado-y-presente-del-paradigma-funcional","title":"1.1. Pasado y presente del paradigma funcional","text":""},{"location":"teoria/tema02-programacion-funcional/tema02-programacion-funcional.html#111-definicion-y-caracteristicas","title":"1.1.1. Definici\u00f3n y caracter\u00edsticas","text":"<p>En una definici\u00f3n muy breve y concisa la programaci\u00f3n funcional define un programa de la siguiente forma:</p> <p>Definici\u00f3n de programa funcional</p> <p>En programaci\u00f3n funcional un programa es un conjunto de funciones matem\u00e1ticas que convierten unas entradas en unas salidas, sin ning\u00fan estado interno y ning\u00fan efecto lateral.</p> <p>Hablaremos m\u00e1s adelante de la no existencia de estado interno (variables en las que se guardan y se modifican valores) y de la ausencia de efectos laterales. Avancemos que estas son tambi\u00e9n caracter\u00edsticas de la programaci\u00f3n declarativa (frente a la programaci\u00f3n tradicional imperativa que es la que se utiliza en lenguajes como C o Java). En este sentido, la programaci\u00f3n funcional es un tipo concreto de programaci\u00f3n declarativa.</p> <p>Las caracter\u00edsticas principales del paradigma funcional son:</p> <ul> <li>Definiciones de funciones matem\u00e1ticas puras, sin estado interno ni   efectos laterales</li> <li>Valores inmutables</li> <li>Uso profuso de la recursi\u00f3n en la definici\u00f3n de las funciones</li> <li>Uso de listas como estructuras de datos fundamentales</li> <li>Funciones como tipos de datos primitivos: expresiones lambda y   funciones de orden superior</li> </ul> <p>Explicaremos estas propiedades a continuaci\u00f3n.</p>"},{"location":"teoria/tema02-programacion-funcional/tema02-programacion-funcional.html#112-origenes-historicos","title":"1.1.2. Or\u00edgenes hist\u00f3ricos","text":"<p>En los a\u00f1os 30, junto con la m\u00e1quina de Turing, se propusieron distintos modelos computacionales equivalentes que formalizaban el concepto de algoritmo. Uno de estos modelos fue el denominado C\u00e1lculo lambda propuesto por Alonzo Church en los a\u00f1os 30 y basado en la evaluaci\u00f3n de expresiones matem\u00e1ticas. En este formalismo los algoritmos se expresan mediante funciones matem\u00e1ticas en las que puede ser usada la recursi\u00f3n. Una funci\u00f3n matem\u00e1tica recibe par\u00e1metros de entrada y devuelve un valor. La evaluaci\u00f3n de la funci\u00f3n se realiza evaluando sus expresiones matem\u00e1ticas mediante la sustituci\u00f3n de los par\u00e1metros formales por los valores reales que se utilizan en la invocaci\u00f3n (el denominado modelo de sustituci\u00f3n que veremos m\u00e1s adelante).</p> <p>El c\u00e1lculo lambda es un formalismo matem\u00e1tico, basado en operaciones abstractas. Dos d\u00e9cadas despu\u00e9s, cuando los primeros computadores electr\u00f3nicos estaban empezando a utilizarse en grandes empresas y en universidades, este formalismo dio origen a algo mucho m\u00e1s tangible y pr\u00e1ctico: un lenguaje de alto nivel, mucho m\u00e1s expresivo que el ensamblador, con el que expresar operaciones y funciones que pueden ser definidas y evaluadas en el computador, el lenguaje de programaci\u00f3n Lisp.</p>"},{"location":"teoria/tema02-programacion-funcional/tema02-programacion-funcional.html#113-historia-y-caracteristicas-del-lisp","title":"1.1.3. Historia y caracter\u00edsticas del Lisp","text":"<ul> <li>Lisp es   el primer lenguaje de programaci\u00f3n de alto nivel basado en el   paradigma funcional.</li> <li>Creado en 1958 por John McCarthy.</li> <li>Lisp fue en su \u00e9poca un lenguaje revolucionario que introdujo nuevos   conceptos de programaci\u00f3n no existentes entonces: funciones como   objetos primitivos, funciones de orden superior, polimorfismo,   listas, recursi\u00f3n, s\u00edmbolos, homogeneidad de datos y programas,   bucle REPL (Read-Eval-Print Loop)</li> <li>La herencia del Lisp llega a lenguajes derivados de \u00e9l (Scheme,   Golden Common Lisp) y a nuevos lenguajes de paradigmas no   estrictamente funcionales, como C#, Python, Ruby, Objective-C o   Scala.</li> </ul> <p>Lisp fue el primer lenguaje de programaci\u00f3n interpretado, con muchas caracter\u00edsticas din\u00e1micas que se ejecutan en tiempo de ejecuci\u00f3n (run-time). Entre estas caracter\u00edsticas podemos destacar la gesti\u00f3n de la memoria (creaci\u00f3n y destrucci\u00f3n autom\u00e1tica de memoria reservada para datos), la detecci\u00f3n de excepciones y errores en tiempo de ejecuci\u00f3n o la creaci\u00f3n en tiempo de ejecuci\u00f3n de funciones an\u00f3nimas (expresiones lambda). Todas estas caracter\u00edsticas se ejecutan mediante un sistema de tiempo de ejecuci\u00f3n (runtime system) presente en la ejecuci\u00f3n de los programas. A partir del Lisp muchos otros lenguajes han usado estas caracter\u00edsticas de interpretaci\u00f3n o de sistemas de tiempo de ejecuci\u00f3n. Por ejemplo, lenguajes como BASIC, Python, Ruby o JavaScript son lenguajes interpretados. Y lenguajes como Java o C# tienen una avanzada plataforma de tiempo de ejecuci\u00f3n con soporte para la gesti\u00f3n de la memoria din\u00e1mica (recolecci\u00f3n de basura, garbage collection) o la compilaci\u00f3n just in time.</p> <p>Lisp no es un lenguaje exclusivamente funcional. Lisp se dise\u00f1\u00f3 con el objetivo de ser un lenguaje de alto nivel capaz de resolver problemas pr\u00e1cticos de Inteligencia Artificial, no con la idea de ser un lenguaje formal basado un \u00fanico modelo de computaci\u00f3n. Por ello en Lisp (y en Scheme) existen primitivas que se salen del paradigma funcional puro y permiten programar de formar imperativa (no declarativa), usando mutaci\u00f3n de estado y pasos de ejecuci\u00f3n. </p> <p>Sin embargo, durante la primera parte de la asignatura en la que estudiaremos la programaci\u00f3n funcional, no utilizaremos las instrucciones imperativas de Scheme sino que escribiremos c\u00f3digo exclusivamente funcional.</p>"},{"location":"teoria/tema02-programacion-funcional/tema02-programacion-funcional.html#114-lenguajes-de-programacion-funcional","title":"1.1.4. Lenguajes de programaci\u00f3n funcional","text":"<p>En los a\u00f1os 60 la programaci\u00f3n funcional definida por el Lisp fue dominante en departamentos de investigaci\u00f3n en Inteligencia Artificial (MIT por ejemplo). En los a\u00f1os 70, 80 y 90 se fue relegando cada vez m\u00e1s a los nichos acad\u00e9micos y de investigaci\u00f3n; en la empresa se impusieron los lenguajes imperativos y orientados a objetos.</p> <p>En la primera d\u00e9cada del 2000 han aparecido lenguajes que evolucionan de Lisp y que resaltan sus aspectos funcionales, aunque actualizando su sintaxis. Destacamos entre ellos:</p> <ul> <li>Clojure</li> <li>Erlang</li> </ul> <p>Tambi\u00e9n hay una tendencia desde mediados de la d\u00e9cada de 2000 de incluir aspectos funcionales como las expresiones lambda o las funciones de orden superior en lenguajes imperativos orientados a objetos, dando lugar a lenguajes multi-paradigma:</p> <ul> <li>Ruby</li> <li>Python</li> <li>Groovy</li> <li>Scala</li> <li>Swift</li> </ul> <p>Por \u00faltimo, en la d\u00e9cada del 2010 tambi\u00e9n se ha hecho popular un lenguaje exclusivamente funcional como Haskell. Este lenguaje, a diferencia de Scheme y de otros lenguajes multi-paradigma, no tienen ning\u00fan elemento imperativo y consigue que todas sus expresiones sean puramente funcionales.</p>"},{"location":"teoria/tema02-programacion-funcional/tema02-programacion-funcional.html#115-aplicaciones-practicas-de-la-programacion-funcional","title":"1.1.5. Aplicaciones pr\u00e1cticas de la programaci\u00f3n funcional","text":"<p>En la actualidad el paradigma funcional es un paradigma de moda, como se puede comprobar observando la cantidad de art\u00edculos, charlas y blogs en los que se habla de \u00e9l, as\u00ed como la cantidad de lenguajes que est\u00e1n aplicando sus conceptos. Por ejemplo, solo como muestra, a continuaci\u00f3n puedes encontrar algunos enlaces a charlas y art\u00edculos interesantes publicados recientemente sobre programaci\u00f3n funcional:</p> <ul> <li>Lupo Montero - Introducci\u00f3n a la programaci\u00f3n funcional en   JavaScript (Blog)</li> <li>Andr\u00e9s Marzal - Por qu\u00e9 deber\u00edas aprender programaci\u00f3n funcional ya   mismo (Charla en YouTube)</li> <li>Mary Rose Cook - A practical introduction to functional programming (Blog)</li> <li>Ben Christensen - Functional Reactive Programming in the Netflix   API   (Charla en InfoQ)</li> </ul> <p>El auge reciente de estos lenguajes y del paradigma funcional se debe a varios factores, entre ellos que es un paradigma que facilita:</p> <ul> <li>la programaci\u00f3n de sistemas concurrentes, con m\u00faltiples hilos de   ejecuci\u00f3n o con m\u00faltiples computadores ejecutando procesos   conectados concurrentes.</li> <li>la definici\u00f3n y composici\u00f3n de m\u00faltiples operaciones sobre streams   de forma muy concisa y compacta, aplicable a la programaci\u00f3n de   sistemas distribuidos en Internet.</li> <li>la programaci\u00f3n interactiva y evolutiva.</li> </ul>"},{"location":"teoria/tema02-programacion-funcional/tema02-programacion-funcional.html#1151-programacion-de-sistemas-concurrentes","title":"1.1.5.1. Programaci\u00f3n de sistemas concurrentes","text":"<p>Veremos m\u00e1s adelante que una de las caracter\u00edsticas principales de la programaci\u00f3n funcional es que no se usa la mutaci\u00f3n (no se modifican los valores asignados a variables ni par\u00e1metros). Esta propiedad lo hace un paradigma excelente para implementar programas concurrentes, en los que existen m\u00faltiples hilos de ejecuci\u00f3n. La programaci\u00f3n de sistemas concurrentes es muy complicada con el paradigma imperativo tradicional, en el que la modificaci\u00f3n del estado de una variable compartida por m\u00e1s de un hilo puede provocar condiciones de carrera y errores dif\u00edcilmente localizables y reproducibles.</p> <p>Como dice Bartosz Milewski, investigador y te\u00f3rico de ciencia de computaci\u00f3n, en su respuesta en Quora a la pregunta \u00bfpor qu\u00e9 a los ingenieros de software les gusta la programaci\u00f3n funcional?:</p> <p>Bartosz Milewski: \u00bfPor qu\u00e9 es popular la programaci\u00f3n funcional?</p> <p>Porque es la \u00fanica forma pr\u00e1ctica de escribir programas concurrentes. Intentar escribir programas concurrentes en lenguajes imperativos, no s\u00f3lo es dif\u00edcil, sino que lleva a bugs que son muy dif\u00edciles de descubrir, reproducir y arreglar. En los lenguajes imperativos y, en particular, en los lenguajes orientados a objetos se ocultan las mutaciones y se comparten datos sin darse cuenta, por lo que son extremadamente propensos a los errores de concurrencia producidos por las condiciones de carrera.</p>"},{"location":"teoria/tema02-programacion-funcional/tema02-programacion-funcional.html#1152-definicion-y-composicion-de-operaciones-sobre-streams","title":"1.1.5.2. Definici\u00f3n y composici\u00f3n de operaciones sobre streams","text":"<p>El paradigma funcional ha originado un estilo de programaci\u00f3n sobre streams de datos, en el que se concatenan operaciones como <code>filter</code> o <code>map</code> para definir de forma sencilla procesos y transformaciones as\u00edncronas aplicables a los elementos del stream. Este estilo de programaci\u00f3n ha hecho posible nuevas ideas de programaci\u00f3n, como la programaci\u00f3n reactiva, basada en eventos, o los futuros o promesas muy utilizados en lenguajes muy populares como JavaScript para realizar peticiones as\u00edncronas a servicios web.</p> <p>Por ejemplo, en el art\u00edculo Exploring the virtues of microservices with Play and Akka se explica con detalle las ventajas del uso de lenguajes y primitivas para trabajar con sistemas as\u00edncronos basados en eventos en servicios como Tumblr o Netflix.</p> <p>Otro ejemplo es el uso de Scala en Tumblr con el que se consigue crear c\u00f3digo que no tiene estado compartido y que es f\u00e1cilmente paralelizable entre los m\u00e1s de 800 servidores necesarios para atender picos de m\u00e1s de 40.000 peticiones por segundo:</p> <p>Uso de Scala en Tumblr</p> <p>Scala promueve que no haya estado compartido. El estado mutable se evita usando sentencias en Scala. No se usan m\u00e1quinas de estado de larga duraci\u00f3n. El estado se saca de la base de datos, se usa, y se escribe de nuevo en la base de datos. La ventaja principal es que los desarrolladores no tienen que preocuparse sobre hilos o bloqueos.</p>"},{"location":"teoria/tema02-programacion-funcional/tema02-programacion-funcional.html#1153-programacion-evolutiva","title":"1.1.5.3. Programaci\u00f3n evolutiva","text":"<p>En la metodolog\u00eda de programaci\u00f3n denominada programaci\u00f3n evolutiva o iterativa los programas complejos se construyen a base de ir definiendo y probando elementos computacionales cada vez m\u00e1s complicados. Los lenguajes de programaci\u00f3n funcional encajan perfectamente en esta forma de construir programas.</p> <p>Como Abelson y Sussman comentan en el libro Structure and Implementation of Computer Programs (SICP):</p> <p>Abelson y Sussman sobre la programaci\u00f3n incremental</p> <p>En general, los objetos computacionales pueden tener estructuras muy complejas, y ser\u00eda extremadamente inconveniente tener que recordar y repetir sus detalles cada vez que queremos usarlas. En lugar de ello, se construyen programas complejos componiendo, paso a paso, objetos computacionales de creciente complejidad.</p> <p>El int\u00e9rprete hace esta construcci\u00f3n paso-a-paso de los programas particularmente conveniente porque las asociaciones nombre-objeto se pueden crear de forma incremental en interacciones sucesivas. Esta caracter\u00edstica favorece el desarrollo y prueba incremental de programas, y es en gran medida responsable del hecho de que un programa Lisp consiste normalmente de un gran n\u00famero de procedimientos relativamente simples.</p> <p>No hay que confundir una metodolog\u00eda de programaci\u00f3n con un paradigma de programaci\u00f3n. Una metodolog\u00eda de programaci\u00f3n proporciona sugerencias sobre c\u00f3mo debemos dise\u00f1ar, desarrollar y mantener una aplicaci\u00f3n que va a ser usada por usuarios finales. La programaci\u00f3n funcional se puede usar con m\u00faltiples metodolog\u00edas de programaci\u00f3n, debido a que los programas resultantes son muy claros, expresivos y f\u00e1ciles de probar.</p>"},{"location":"teoria/tema02-programacion-funcional/tema02-programacion-funcional.html#12-evaluacion-de-expresiones-y-definicion-de-funciones","title":"1.2. Evaluaci\u00f3n de expresiones y definici\u00f3n de funciones","text":"<p>En la asignatura usaremos Scheme como primer lenguaje en el que exploraremos la programaci\u00f3n funcional.</p> <p>En el seminario de Scheme que se imparte en pr\u00e1cticas se estudian en m\u00e1s profundidad los conceptos m\u00e1s importantes del lenguaje: tipos de datos, operadores, estructuras de control, int\u00e9rprete, etc.</p>"},{"location":"teoria/tema02-programacion-funcional/tema02-programacion-funcional.html#121-evaluacion-de-expresiones","title":"1.2.1 Evaluaci\u00f3n de expresiones","text":"<p>Empezamos este apartado viendo c\u00f3mo se definen y eval\u00faan expresiones Scheme. Y despu\u00e9s veremos c\u00f3mo construir nuevas funciones.</p> <p>Scheme es un lenguaje que viene del Lisp. Una de sus caracter\u00edsticas principales es que las expresiones se construyen utilizando par\u00e9ntesis.</p> <p>Ejemplos de expresiones en Scheme, junto con el resultado de su ejecuci\u00f3n:</p> <pre><code>2 ; \u21d2 2\n(+ 2 3) ; \u21d2 5\n(+) ; \u21d2 0\n(+ 2 4 5 6) ; \u21d2 17\n(+ (* 2 3) (- 3 1)) ; \u21d2 8\n</code></pre> <p>En programaci\u00f3n funcional en lugar de decir \"ejecutar una expresi\u00f3n\" se dice \"evaluar una expresi\u00f3n\", para reforzar la idea de que se tratan de expresiones matem\u00e1ticas que siempre devuelven uno y s\u00f3lo un resultado.</p> <p>Las expresiones se definen con una notaci\u00f3n prefija: el primer elemento despu\u00e9s del par\u00e9ntesis de apertura es el operador de la expresi\u00f3n y el resto de elementos (hasta el par\u00e9ntesis de cierre) son sus operandos.</p> <ul> <li> <p>Por ejemplo, en la expresi\u00f3n <code>(+ 2 4 5 6)</code> el operador es el s\u00edmbolo <code>+</code> que representa funci\u00f3n suma y los operandos son los n\u00fameros 2, 4, 5 y 6.</p> </li> <li> <p>Puede haber expresiones que no tengan operandos, como el ejemplo <code>(+)</code>, cuya evaluaci\u00f3n devuelve 0.</p> </li> </ul> <p>Una idea fundamental de Lisp y Scheme es que los par\u00e9ntesis se eval\u00faan de dentro a fuera. Por ejemplo, la expresi\u00f3n </p> <pre><code>(+ (* 2 3) (- 3 (/ 12 3)))\n</code></pre> <p>que devuelve 5, se eval\u00faa as\u00ed:</p> <pre><code>(+ (* 2 3) (- 3 (/ 12 3))) \u21d2\n(+ 6 (- 3 (/ 12 3))) \u21d2\n(+ 6 (- 3 4)) \u21d2\n(+ 6 -1) \u21d2\n5\n</code></pre> <p>La evaluaci\u00f3n de cada expresi\u00f3n devuelve un valor que se utiliza para continuar calculando la expresi\u00f3n exterior. En el caso anterior</p> <ul> <li>primero se eval\u00faa la expresi\u00f3n <code>(* 2 3)</code> que devuelve 6,</li> <li>despu\u00e9s se eval\u00faa <code>(/ 12 3)</code> que devuelve 4,</li> <li>despu\u00e9s se eval\u00faa <code>(- 3 4)</code> que devuelve -1</li> <li>y por \u00faltimo se eval\u00faa <code>(+ 6 -1)</code> que devuelve 5</li> </ul> <p>Cuando se eval\u00faa una expresi\u00f3n en el int\u00e9rprete de Scheme el  resultado aparece en la siguiente l\u00ednea. </p>"},{"location":"teoria/tema02-programacion-funcional/tema02-programacion-funcional.html#122-definicion-de-funciones","title":"1.2.2. Definici\u00f3n de funciones","text":"<p>En programaci\u00f3n funcional las funciones son similares a las funciones matem\u00e1ticas: reciben par\u00e1metros y devuelven siempre un \u00fanico resultado de operar con esos par\u00e1metros.</p> <p>Por ejemplo, podemos definir la funci\u00f3n <code>(cuadrado x)</code> que devuelve el cuadrado de un n\u00famero que pasamos como par\u00e1metro:</p> <pre><code>(define (cuadrado x)\n   (* x x))\n</code></pre> <p>Despu\u00e9s del nombre de la funci\u00f3n se declaran sus argumentos. El n\u00famero de argumentos de una funci\u00f3n se denomina aridad de la funci\u00f3n. Por ejemplo, la funci\u00f3n <code>cuadrado</code> es una funci\u00f3n de aridad 1, o unaria.</p> <p>Despu\u00e9s de declarar los par\u00e1metros, se define el cuerpo de la funci\u00f3n. Es una expresi\u00f3n que se evaluar\u00e1 con el valor que se pase como par\u00e1metro. En el caso anterior la expresi\u00f3n es <code>(* x x)</code> y multiplicar\u00e1 el par\u00e1metro por si mismo.</p> <p>Hay que hacer notar que en Scheme no existe la palabra clave <code>return</code>, sino que las funciones siempre se definen con una \u00fanica expresi\u00f3n cuya evaluaci\u00f3n es el resultado que se devuelve.</p> <p>Una vez definida la funci\u00f3n <code>cuadrado</code> podemos usarla de la misma forma que las funciones primitivas de Scheme:</p> <pre><code>(cuadrado 10) ; \u21d2 100\n(cuadrado (+ 10 (cuadrado (+ 2 4)))) ; \u21d2 2116\n</code></pre> <p>La evaluaci\u00f3n de la \u00faltima expresi\u00f3n se hace de la siguiente forma:</p> <pre><code>(cuadrado (+ 10 (cuadrado (+ 2 4)))) \u21d2\n(cuadrado (+ 10 (cuadrado 6))) \u21d2\n(cuadrado (+ 10 36)) \u21d2\n(cuadrado 46) \u21d2\n2116\n</code></pre>"},{"location":"teoria/tema02-programacion-funcional/tema02-programacion-funcional.html#123-definicion-de-funciones-auxiliares","title":"1.2.3. Definici\u00f3n de funciones auxiliares","text":"<p>Las funciones definidas se pueden utilizar a su vez para construir otras funciones.</p> <p>Lo habitual en programaci\u00f3n funcional es definir funciones muy peque\u00f1as e ir construyendo funciones cada vez de mayor nivel usando las anteriores.</p>"},{"location":"teoria/tema02-programacion-funcional/tema02-programacion-funcional.html#1231-ejemplo-suma-de-cuadrados","title":"1.2.3.1. Ejemplo: suma de cuadrados","text":"<p>Por ejemplo, supongamos que tenemos que definir una funci\u00f3n que devuelva la suma del cuadrado de dos n\u00fameros. Podr\u00edamos definirla escribiendo la expresi\u00f3n completa, pero queda una definici\u00f3n poco legible.</p> <pre><code>; Definici\u00f3n poco legible de la suma de cuadrados\n\n(define (suma-cuadrados x y)\n    (+ (* x x)\n       (* y y)))\n</code></pre> <p>Podemos hacer una definici\u00f3n mucho m\u00e1s legible si usamos la funci\u00f3n <code>cuadrado</code> definida anteriormente:</p> <pre><code>; Definici\u00f3n de suma de cuadrados m\u00e1s legible.\n; Usamos la funci\u00f3n auxiliar 'cuadrado'\n\n(define (cuadrado x)\n    (* x x))\n\n(define (suma-cuadrados x y)\n    (+ (cuadrado x) \n       (cuadrado y)))\n</code></pre> <p>Esta segunda definici\u00f3n es mucho m\u00e1s expresiva. Leyendo el c\u00f3digo queda muy claro qu\u00e9 es lo que queremos hacer.</p>"},{"location":"teoria/tema02-programacion-funcional/tema02-programacion-funcional.html#1232-ejemplo-tiempo-de-impacto","title":"1.2.3.2. Ejemplo: tiempo de impacto","text":"<p>Veamos otro ejemplo de uso de funciones auxiliares. Supongamos que estamos programando un juego de guerra de barcos y submarinos, en el que utilizamos las coordenadas del plano para situar todos los elementos de nuestra flota.</p> <p>Supongamos que necesitamos calcular el tiempo que tarda un torpedo en llegar desde una posici\u00f3n <code>(x1, y1)</code> a otra <code>(x2, y2)</code>. Suponemos que la velocidad del torpedo es otro par\u00e1metro <code>v</code>. </p> <p>\u00bfC\u00f3mo calcular\u00edamos este tiempo de impacto?</p> <p>La forma menos correcta de hacerlo es definir todo el c\u00e1lculo en una \u00fanica expresi\u00f3n. Como en programaci\u00f3n funcional las funciones deben definirse con una \u00fanica expresi\u00f3n debemos realizar todo el c\u00e1lculo en forma de expresiones anidadas, unas dentro de otras. Esto construye una funci\u00f3n que calcula bien el resultado. El problema que tiene es que es muy dif\u00edcil de leer y entender para un compa\u00f1ero (o para nosotros mismos, cuando pasen unos meses):</p> <pre><code>;\n; Definici\u00f3n incorrecta: muy poco legible\n;\n; La funci\u00f3n tiempo-impacto devuelve el tiempo que tarda\n; en llegar un torpedo a la velocidad v desde la posici\u00f3n\n; (x1, y1) a la posici\u00f3n (x2, y2)\n;\n\n(define (tiempo-impacto x1 y1 x2 y2 v)\n   (/ (sqrt (+ (* (- x2 x1) (- x2 x1))\n               (* (- y2 y1) (- y2 y1))))\n    v))\n</code></pre> <p>La funci\u00f3n anterior hace bien el c\u00e1lculo pero es muy complicada de modificar y de entender.</p> <p>La forma m\u00e1s correcta de definir la funci\u00f3n ser\u00eda usando varias funciones auxiliares. F\u00edjate que es muy importante tambi\u00e9n poner los nombres correctos a cada funci\u00f3n, para entender qu\u00e9 hace. Scheme es un lenguaje d\u00e9bilmente tipado y no tenemos la ayuda de los tipos que nos dan m\u00e1s contexto de qu\u00e9 es cada par\u00e1metro y qu\u00e9 devuelve la funci\u00f3n.</p> <pre><code>; Definici\u00f3n correcta, modular y legible de la funci\u00f3n tiempo-impacto\n\n;\n; La funci\u00f3n 'cuadrado' devuelve el cuadrado de un n\u00famero\n;\n\n(define (cuadrado x)\n    (* x x))\n\n;\n; La funci\u00f3n 'distancia' devuelve la distancia entre dos\n; coordenadas (x1, y1) y (x2, y2)\n;\n\n(define (distancia x1 y1 x2 y2)\n    (sqrt (+ (cuadrado (- x2 x1))\n             (cuadrado (- y2 y1)))))\n\n;\n; La funci\u00f3n 'tiempo' devuelve el tiempo que \n; tarda en recorrer un m\u00f3vil una distancia d a un velocidad v\n;\n\n(define (tiempo distancia velocidad)\n    (/ distancia velocidad))\n\n;\n; La funci\u00f3n 'tiempo-impacto' devuelve el tiempo que tarda\n; en llegar un torpedo a la velocidad v desde la posici\u00f3n\n; (x1, y1) a la posici\u00f3n (x2, y2)\n;\n\n(define (tiempo-impacto x1 y1 x2 y2 velocidad)\n    (tiempo (distancia x1 y1 x2 y2) velocidad))\n</code></pre> <p>En esta segunda versi\u00f3n definimos m\u00e1s funciones, pero cada una es mucho m\u00e1s legible. Adem\u00e1s las funciones como <code>cuadrado</code>, <code>distancia</code> o <code>tiempo</code> las vamos a poder reutilizar para otros c\u00e1lculos.</p>"},{"location":"teoria/tema02-programacion-funcional/tema02-programacion-funcional.html#124-funciones-puras","title":"1.2.4. Funciones puras","text":"<p>A diferencia de lo que hemos visto en programaci\u00f3n imperativa, en programaci\u00f3n funcional no es posible definir funciones con estado local. Las funciones que se definen son funciones matem\u00e1ticas puras, que cumplen las siguientes condiciones:</p> <ul> <li>No modifican los par\u00e1metros que se les pasa</li> <li>Devuelven un \u00fanico resultado</li> <li>No tienen estado local ni el resultado depende de un estado exterior mutable</li> </ul> <p>Esta \u00faltima propiedad es muy importante y quiere decir que la funci\u00f3n siempre devuelve el mismo valor cuando se le pasan los mismos par\u00e1metros.</p> <p>Las funciones puras son muy f\u00e1ciles de entender porque no es necesario tener en cuenta ning\u00fan contexto a la hora de describir su funcionamiento. El valor devuelto \u00fanicamente depende de los par\u00e1metros de entrada.</p> <p>Por ejemplo, funciones matem\u00e1ticas como suma, resta, cuadrado, sin, cos, etc. cumplen esta propiedad.</p>"},{"location":"teoria/tema02-programacion-funcional/tema02-programacion-funcional.html#125-composicion-de-funciones","title":"1.2.5. Composici\u00f3n de funciones","text":"<p>Una idea fundamental de la programaci\u00f3n funcional es la composici\u00f3n de funciones que transforman unos datos de entrada en otros de salida. Es una idea muy actual, porque es la forma en la que est\u00e1n planteados muchos algoritmos de procesamiento de datos en inteligencia artificial.</p> <p>Por ejemplo, podemos representar de la siguiente forma el algoritmo que maneja un veh\u00edculo aut\u00f3nomo:</p> <p></p> <p>Las cajas representa funciones que transforman los datos de entrada (im\u00e1genes tomadas por las c\u00e1maras del veh\u00edculo) en los datos de salida (acciones a realizar sobre la direcci\u00f3n y el motor del veh\u00edculo). Las funciones intermedias representan transformaciones que se realizan sobre los datos de entrada y obtienen los datos de salida.</p> <p>En un lenguaje de programaci\u00f3n funcional como Scheme el diagrama anterior se escribir\u00eda con el siguiente c\u00f3digo:</p> <pre><code>(define (conduce-vehiculo imagenes)\n    (obten-acciones \n        (reconoce \n            (filtra \n                (obten-caracteristicas imagenes)))))\n</code></pre> <p>Veremos m\u00e1s adelante que las expresiones en Scheme se eval\u00faan de dentro a fuera y que tienen notaci\u00f3n prefija. El resultado de cada funci\u00f3n constituye la entrada de la siguiente. </p> <p>En el caso de la funci\u00f3n <code>conduce-vehiculo</code> primero se obtienen las caracter\u00edsticas de las im\u00e1genes, despu\u00e9s se filtran, despu\u00e9s se reconoce la escena y, por \u00faltimo, se obtienen las acciones para conducir el veh\u00edculo.</p>"},{"location":"teoria/tema02-programacion-funcional/tema02-programacion-funcional.html#13-programacion-declarativa-vs-imperativa","title":"1.3. Programaci\u00f3n declarativa vs. imperativa","text":"<p>Hemos dicho que la programaci\u00f3n funcional es un estilo de programaci\u00f3n declarativa, frente a la programaci\u00f3n tradicional de los lenguajes denominados imperativos. Vamos a explicar esto un poco m\u00e1s.</p>"},{"location":"teoria/tema02-programacion-funcional/tema02-programacion-funcional.html#131-programacion-declarativa","title":"1.3.1. Programaci\u00f3n declarativa","text":"<p>Empecemos con lo que conocemos todos: un programa imperativo. Se trata de un conjunto de instrucciones que se ejecutan una tras otra (pasos de ejecuci\u00f3n) de forma secuencial. En la ejecuci\u00f3n de estas instrucciones se van cambiando los valores de las variables y, dependiendo de estos valores, se modifica el flujo de control de la ejecuci\u00f3n del programa. </p> <p>Para entender el funcionamiento de un programa imperativo debemos imaginar toda la evoluci\u00f3n del programa, los pasos que se ejecutan y cu\u00e1l es el flujo de control en funci\u00f3n de los cambios de los valores en las variables.</p> <p>En la programaci\u00f3n declarativa, sin embargo, utilizamos un paradigma totalmente distinto. Hablamos de programaci\u00f3n declarativa para referirnos a lenguajes de programaci\u00f3n (o sentencias de c\u00f3digo) en los que se declaran los valores, objetivos o caracter\u00edsticas de los elementos del programa y en cuya ejecuci\u00f3n no existe mutaci\u00f3n (modificaci\u00f3n de valores de variables) ni secuencias de pasos de ejecuci\u00f3n.</p> <p>De esta forma, la ejecuci\u00f3n de un programa declarativo tiene que ver m\u00e1s con alg\u00fan modelo formal o matem\u00e1tico que con un programa tradicional imperativo.  Define un conjunto de reglas y definiciones de estilo matem\u00e1tico. </p> <p>La programaci\u00f3n declarativa no es exclusiva de los lenguajes funcionales. Existen muchos lenguajes no funcionales con caracter\u00edsticas declarativas. Por ejemplo Prolog, en el que un programa se define como un conjunto de reglas l\u00f3gicas y su ejecuci\u00f3n realiza una deducci\u00f3n l\u00f3gica matem\u00e1tica que devuelve un resultado. En dicha ejecuci\u00f3n no son relevantes los pasos internos que realiza el sistema sino las relaciones l\u00f3gicas entre los datos y los resultados finales.</p> <p>Un ejemplo claro de programaci\u00f3n declarativa es una hoja de c\u00e1lculo. Las celdas contiene valores o expresiones matem\u00e1ticas que se actualizan autom\u00e1ticamente cuando cambiamos los valores de entrada. La relaci\u00f3n entre valores y resultados es totalmente matem\u00e1tica y para su c\u00e1lculo no tenemos que tener en cuenta pasos de ejecuci\u00f3n. Evidente, por debajo de la hoja de c\u00e1lculo existe un programa que realiza el su c\u00e1lculo de la hoja, pero cuando estamos us\u00e1ndola no nos preocupa esa implementaci\u00f3n. Podemos no preocuparnos de ella y usar \u00fanicamente el modelo matem\u00e1tico definido en la hoja.</p> <p>Otro ejemplo muy actual de programaci\u00f3n declarativa es SwiftUI, el nuevo API creado por Apple para definir las interfaces de usuario de las aplicaciones iOS.</p> <p></p> <p>En el c\u00f3digo de la imagen vemos una descripci\u00f3n de c\u00f3mo est\u00e1 definida la aplicaci\u00f3n: una lista de lugares (landmarks) apilada verticalmente. Para cada lugar se define su imagen, su texto, y una estrella si el lugar es favorito.</p> <p>El c\u00f3digo es declarativo porque no hay pasos de ejecuci\u00f3n para definir la interfaz. No existe un bucle que va a\u00f1adiendo elementos a la interfaz. Vemos una declaraci\u00f3n de c\u00f3mo la interfaz va estar definida. El compilador del lenguaje y el API son los responsables de construir esa declaraci\u00f3n y mostrar la interfaz tal y como nosotros queremos.</p>"},{"location":"teoria/tema02-programacion-funcional/tema02-programacion-funcional.html#1311-declaracion-de-funciones","title":"1.3.1.1. Declaraci\u00f3n de funciones","text":"<p>La programaci\u00f3n funcional utiliza un estilo de programaci\u00f3n declarativo. Declaramos funciones en las que se transforman unos datos de entrada en unos datos de salida. Veremos que esta transformaci\u00f3n se realiza mediante la evaluaci\u00f3n de expresiones, sin definir valores intermedios, ni variables auxiliares, ni pasos de ejecuci\u00f3n. \u00danicamente se van componiendo llamadas a funciones auxiliares que construyen el valor resultante.</p> <p>Tal y como ya hemos visto, el siguiente ejemplo es una declaraci\u00f3n en Scheme de una funci\u00f3n que toma como entrada un n\u00famero y devuelve su cuadrado:</p> <pre><code>(define (cuadrado x)\n   (* x x))\n</code></pre> <p>En el cuerpo de la funci\u00f3n <code>cuadrado</code> vemos que no se utiliza ninguna variable auxiliar, sino que \u00fanicamente se llama a la funci\u00f3n <code>*</code> (multiplicaci\u00f3n) pasando el valor de <code>x</code>. El valor resultante es el que se devuelve.</p> <p>Por ejemplo, si llamamos a la funci\u00f3n pas\u00e1ndole el par\u00e1metro <code>4</code> devuelve el resultado de multiplicar 4 por si mismo, 16.</p> <pre><code>(cuadrado 4) ; \u21d2 16\n</code></pre>"},{"location":"teoria/tema02-programacion-funcional/tema02-programacion-funcional.html#132-programacion-imperativa","title":"1.3.2. Programaci\u00f3n imperativa","text":"<p>Repasemos un algunas caracter\u00edsticas propias de la programaci\u00f3n imperativa que no existen en la programaci\u00f3n funcional. Son caracter\u00edsticas a las que estamos muy habituados porque son propias de los lenguajes m\u00e1s populares y con los que hemos aprendido a programar (C, C++, Java, python, etc.)</p> <ul> <li>Pasos de ejecuci\u00f3n</li> <li>Mutaci\u00f3n</li> <li>Efectos laterales</li> <li>Estado local mutable en las funciones</li> </ul> <p>Veremos que, aunque parece imposible, es posible programar sin utilizar estas caracter\u00edsticas. Lo demuestran lenguajes de programaci\u00f3n funcional como Haskell, Clojure o el propio Scheme.</p>"},{"location":"teoria/tema02-programacion-funcional/tema02-programacion-funcional.html#1321-pasos-de-ejecucion","title":"1.3.2.1. Pasos de ejecuci\u00f3n","text":"<p>Una de las caracter\u00edsticas b\u00e1sicas de la programaci\u00f3n imperativa es la utilizaci\u00f3n de pasos de ejecuci\u00f3n. Por ejemplo, en C podemos realizar los siguientes pasos de ejecuci\u00f3n:</p> <pre><code>int a = cuadrado(8);\nint b = doble(a);\nint c = cuadrado(b);\nreturn c\n</code></pre> <p>O, por ejemplo, si queremos filtrar y procesar una lista de pedidos en Swift podemos hacerlo en dos sentencias:</p> <pre><code>filtrados = filtra(pedidos);\nprocesados = procesa(filtrados);\nreturn procesados;\n</code></pre> <p>Sin embargo, en programaci\u00f3n funcional (por ejemplo, Scheme) no existen pasos de ejecuci\u00f3n separados por sentencias. Como hemos visto antes, la forma t\u00edpica de expresar las instrucciones anteriores es componer todas las operaciones en una \u00fanica instrucci\u00f3n:</p> <pre><code>(cuadrado (doble (cuadrado 8))) ; \u21d2 16384\n</code></pre> <p>El segundo ejemplo lo podemos componer de la misma forma:</p> <pre><code>(procesa (filtra pedidos))\n</code></pre>"},{"location":"teoria/tema02-programacion-funcional/tema02-programacion-funcional.html#1322-mutacion","title":"1.3.2.2. Mutaci\u00f3n","text":"<p>En los lenguajes imperativos es com\u00fan modificar el valor de las variables en los pasos de ejecuci\u00f3n:</p> <pre><code>int x = 10;\nint x = x + 1;\n</code></pre> <p>La expresi\u00f3n <code>x = x + 1</code> es una expresi\u00f3n de asignaci\u00f3n que modifica el valor anterior de una variable por un nuevo valor. El estado de las variables (su valor) cambia con la ejecuci\u00f3n de los pasos del programa.</p> <p>A esta asignaci\u00f3n que modifica un valor ya existente se le denomina asignaci\u00f3n destructiva o mutaci\u00f3n.</p> <p>En programaci\u00f3n imperativa tambi\u00e9n se puede modificar (mutar) el valor de componentes de estructuras de datos, como posiciones de un array, de una lista o de un diccionario.</p> <p>En programaci\u00f3n funcional, por contra, las definiciones son inmutables, y una vez asignado un valor a un identificador no se puede modificar \u00e9ste. En programaci\u00f3n funcional no existe sentencia de asignaci\u00f3n que pueda modificar un valor ya definido. Se entienden las variables como variables matem\u00e1ticas, no como referencias a una posiciones de memoria que puede ser modificada.</p> <p>Por ejemplo, la forma especial <code>define</code> en Scheme crea un nuevo identificador y le da el valor definido de forma permanente. Si escribimos el siguiente c\u00f3digo en un programa en Scheme:</p> <pre><code>#lang racket\n\n(define a 12)\n(define a 200)\n</code></pre> <p>tendremos el siguiente error:</p> <pre><code>module: identifier already defined in: a\n</code></pre> <p>Nota</p> <p>En el int\u00e9rprete REPL del DrRacket s\u00ed que podemos definir m\u00e1s de una vez la misma funci\u00f3n o identificador. Se ha dise\u00f1ado as\u00ed para facilitar el uso del int\u00e9rprete para la prueba de expresiones en Scheme.</p> <p>En los lenguajes de programaci\u00f3n imperativos es habitual introducir tambi\u00e9n sentencias declarativas. Por ejemplo, en el siguiente c\u00f3digo Java las l\u00edneas 1 y 3 las podr\u00edamos considerar declarativas y las 2 y 4 imperativas:</p> <pre><code>1. int x = 1;\n2. x = x+1;\n3. int y = x+1;\n4. y = x;\n</code></pre>"},{"location":"teoria/tema02-programacion-funcional/tema02-programacion-funcional.html#1323-mutacion-y-efectos-laterales","title":"1.3.2.3. Mutaci\u00f3n y efectos laterales","text":"<p>En programaci\u00f3n imperativa es habitual tambi\u00e9n trabajar con referencias y hacer que m\u00e1s de un identificador referencie el mismo valor. Esto produce la posibilidad de que la mutaci\u00f3n del valor a trav\u00e9s de uno de los identificadores produzca un efecto lateral (side effect en ingl\u00e9s) en el que el valor de un identificador cambia sin ejecutar ninguna expresi\u00f3n en la que se utilice expl\u00edcitamente el propio identificador.</p> <p>Por ejemplo, en la mayor\u00eda de lenguajes orientados a objetos los identificadores guardan referencias a objetos. De forma que si asignamos un objeto a m\u00e1s de un identificador, todos los identificadores est\u00e1n accediendo al mismo objeto. Si mutamos alg\u00fan valor del objeto a trav\u00e9s de un identificador provocamos un efecto lateral en los otros identificadores.</p> <p>Por ejemplo, lo siguiente es un ejemplo de una mutaci\u00f3n en programaci\u00f3n imperativa, en la que se modifican los atributos de un objeto en Java:</p> <pre><code>Point2D p1 = new Point2D(3.0, 2.0); // creamos un punto 2D con coordX=3.0 y coordY=2.0\np1.getCoordX(); // la coord x de p2 es 3.0\np1.setCoordX(10.0);\np1.getCoordX(); // la coord x de p1 es 10.0\n</code></pre> <p>Si el objeto est\u00e1 asignado a m\u00e1s de una variable tendremos el efecto lateral (side effect) en el que el dato guardado en una variable cambia despu\u00e9s de una sentencia en la que no se ha usado esa variable:</p> <pre><code>Point2D p1 = new Point2D(3.0, 2.0); // la coord x de p1 es 3.0\np1.getCoordX(); // la coord x de p1 es 3.0\nPoint2D p2 = p1;\np2.setCoordX(10.0);\np1.getCoordX(); // la coord x de p1 es 10.0, sin que ninguna sentencia haya modificado directamente p1\n</code></pre> <p>El mismo ejemplo anterior, en C:</p> <pre><code>typedef struct {\n  float x;\n  float y;\n}TPunto; \n\nTPunto p1 = {3.0, 2.0};\nprintf(\"Coordenada x: %f\", p1.x);  // 3.0\nTPunto *p2 = &amp;p1;\np2-&gt;x = 10.0;\nprintf(\"Coordenada x: %f\", p1.x);  // 10.0 Efecto lateral\n</code></pre> <p>Los efectos laterales son los responsables de muchos bugs y hay que ser muy consciente de su uso. Son especialmente complicados de depurar los bugs debidos a efectos laterales en programas concurrentes con m\u00faltiples hilos de ejecuci\u00f3n, en los que varios hilos pueden acceder a las mismas referencias y provocar condiciones de carrera.</p> <p>Por otro lado, tambi\u00e9n existen situaciones en las que su utilizaci\u00f3n permite ganar mucha eficiencia porque podemos definir estructuras de datos en el que los valores son compartidos por varias referencias y modificando un \u00fanico valor se actualizan de forma instant\u00e1nea esas referencias.</p> <p>En los lenguajes en los que no existe la mutaci\u00f3n no se producen efectos laterales, ya que no es posible modificar el valor de una variable una vez establecido. Los programas que escribamos en estos lenguajes van a estar libres de este tipo de bugs y van a poder ser ejecutado sin problemas en hilos de ejecuci\u00f3n concurrente.</p> <p>Por otro lado, la ausencia de mutaci\u00f3n hace que sean algo m\u00e1s costosas ciertas operaciones, como la construcci\u00f3n de estructuras de datos nuevas a partir de estructuras ya existentes. Veremos, por ejemplo, que la \u00fanica forma de a\u00f1adir un elemento al final de una lista ser\u00e1 construir una lista nueva con todos los elementos de la lista original y el nuevo elemento. Esta operaci\u00f3n tiene un coste lineal con el n\u00famero de elementos de la lista. Sin embargo, en una lista en la que pudi\u00e9ramos utilizar la mutaci\u00f3n podr\u00edamos implementar esta operaci\u00f3n con coste constante.</p>"},{"location":"teoria/tema02-programacion-funcional/tema02-programacion-funcional.html#1324-estado-local-mutable","title":"1.3.2.4. Estado local mutable","text":"<p>Otra caracter\u00edstica de la programaci\u00f3n imperativa es lo que se denomina estado local mutable en funciones, procedimientos o m\u00e9todos. Se trata la posibilidad de que una invocaci\u00f3n a un m\u00e9todo o una funci\u00f3n modifique un cierto estado, de forma que la siguiente invocaci\u00f3n devuelva un valor distinto. Es una caracter\u00edstica b\u00e1sica de la programaci\u00f3n orientada a objetos, donde los objetos guardan valores que se modifican con la invocaciones a sus m\u00e9todos.</p> <p>Por ejemplo, en Java, podemos definir un contador que incrementa su valor: </p> <pre><code>public class Contador {\n    int c;\n\n    public Contador(int valorInicial) {\n        c = valorInicial;\n    }\n\n    public int valor() {\n        c++;\n        return c;\n    }\n}\n</code></pre> <p>Cada llamada al m\u00e9todo <code>valor()</code> devolver\u00e1 un valor distinto:</p> <pre><code>Contador cont = new Contador(10);\ncont.valor(); // 11\ncont.valor(); // 12\ncont.valor(); // 13\n</code></pre> <p>Tambi\u00e9n se pueden definir funciones con estado local mutable en C:</p> <pre><code>int function contador () {\n    static int c = 0;\n\n    c++;\n    return c;\n}\n</code></pre> <p>Cada llamada a la funci\u00f3n <code>contador()</code> devolver\u00e1 un valor distinto:</p> <pre><code>contador(); // 1\ncontador(); // 2\ncontador(); // 3\n</code></pre> <p>Por el contrario, los lenguajes funcionales tienen la propiedad de transparencia referencial: es posible sustituir cualquier aparici\u00f3n de una expresi\u00f3n por su resultado sin que cambie el resultado final del programa. Dicho de otra forma, en programaci\u00f3n funcional, una funci\u00f3n siempre devuelve el mismo valor cuando se le llama con los mismos par\u00e1metros. Las funciones no modifican ning\u00fan estado, no acceden a ninguna variable ni objeto global y modifican su valor.</p>"},{"location":"teoria/tema02-programacion-funcional/tema02-programacion-funcional.html#1325-resumen","title":"1.3.2.5. Resumen","text":"<p>Un resumen de las caracter\u00edsticas fundamentales de la programaci\u00f3n declarativa frente a la programaci\u00f3n imperativa. En los siguientes apartados explicaremos m\u00e1s estas caracter\u00edsticas.</p> <p>Caracter\u00edsticas de la programaci\u00f3n declarativa</p> <ul> <li>Variable = nombre dado a un valor (declaraci\u00f3n)</li> <li>En lugar de pasos de ejecuci\u00f3n se utiliza la composici\u00f3n de funciones</li> <li>No existe asignaci\u00f3n ni cambio de estado</li> <li>No existe mutaci\u00f3n, se cumple la transferencia referencial: dentro   de un mismo \u00e1mbito todas las ocurrencias de una variable y las   llamadas a funciones devuelven el mismo valor</li> </ul> <p>Caracter\u00edsticas de la programaci\u00f3n imperativa</p> <ul> <li>Variable = nombre de una zona de memoria</li> <li>Asignaci\u00f3n</li> <li>Referencias</li> <li>Pasos de ejecuci\u00f3n</li> </ul>"},{"location":"teoria/tema02-programacion-funcional/tema02-programacion-funcional.html#14-modelo-de-computacion-de-sustitucion","title":"1.4. Modelo de computaci\u00f3n de sustituci\u00f3n","text":"<p>Un modelo computacional es un formalismo (conjunto de reglas) que definen el funcionamiento de un programa. En el caso de los lenguajes funcionales basados en la evaluaci\u00f3n de expresiones, el modelo computacional define cu\u00e1l ser\u00e1 el resultado de evaluar una expresi\u00f3n.</p> <p>El modelo de sustituci\u00f3n es un modelo muy sencillo que permite definir la sem\u00e1ntica de la evaluaci\u00f3n de expresiones en lenguajes funcionales como Scheme. Se basa en una versi\u00f3n simplificada de la regla de reducci\u00f3n del c\u00e1lculo lambda.</p> <p>Es un modelo basado en la reescritura de unos t\u00e9rminos por otros. Aunque se trata de un modelo abstracto, ser\u00eda posible escribir un int\u00e9rprete que, bas\u00e1ndose en este modelo, eval\u00fae expresiones funcionales.</p> <p>Supongamos un conjunto de definiciones en Scheme:</p> <pre><code>(define (doble x) \n    (+ x x))\n\n(define (cuadrado y) \n    (* y y))\n\n(define (f z) \n    (+ (cuadrado (doble z)) 1))\n\n(define a 2)\n</code></pre> <p>Supongamos que, una vez realizadas esas definiciones, se eval\u00faa la siguiente expresi\u00f3n:</p> <pre><code>(f (+ a 1))\n</code></pre> <p>\u00bfCu\u00e1l ser\u00e1 su resultado? Si lo hacemos de forma intuitiva podemos pensar que <code>37</code>. Si lo comprobamos en el int\u00e9rprete de Scheme veremos que devuelve 37. \u00bfHemos seguido algunas reglas espec\u00edficas? \u00bfQu\u00e9 reglas son las que sigue el int\u00e9rprete? \u00bfPodr\u00edamos implementar nosotros un int\u00e9rprete similar? S\u00ed, usando las reglas del modelo de sustituci\u00f3n.</p> <p>El modelo de sustituci\u00f3n define cuatro reglas sencillas para evaluar una expresi\u00f3n. Llamemos a la expresi\u00f3n e. Las reglas son las siguientes:</p> <ol> <li>Si e es un valor primitivo (por ejemplo, un n\u00famero), devolvemos ese    mismo valor.</li> <li>Si e es un identificador, devolvemos su valor asociado con un    <code>define</code> (se lanzar\u00e1 un error si no existe ese valor).</li> <li>Si e es una expresi\u00f3n del tipo (f arg1 ... argn), donde f es    el nombre de una funci\u00f3n primitiva (<code>+</code>, <code>-</code>, ...), evaluamos uno a    uno los argumentos arg1 ... argn (con estas mismas reglas) y    evaluamos la funci\u00f3n primitiva con los resultados.</li> </ol> <p>La regla 4 tiene dos variantes, dependiendo del orden de evaluaci\u00f3n que utilizamos.</p> <p>Orden aplicativo</p> <ol> <li>Si e es una expresi\u00f3n del tipo (f arg1 ... argn), donde f es    el nombre de una funci\u00f3n definida con un <code>define</code>, tenemos que    evaluar primero los argumentos arg1 ... argn y despu\u00e9s    sustituir f por su cuerpo, reemplazando cada par\u00e1metro formal    de la funci\u00f3n por el correspondiente argumento evaluado. Despu\u00e9s    evaluaremos la expresi\u00f3n resultante usando estas mismas reglas.</li> </ol> <p>Orden normal</p> <ol> <li>Si e es una expresi\u00f3n del tipo (f arg1 ... argn), donde f es    el nombre de una funci\u00f3n definida con un <code>define</code>, tenemos que    sustituir f por su cuerpo, reemplazando cada par\u00e1metro formal    de la funci\u00f3n por el correspondiente argumento sin evaluar. Despu\u00e9s    evaluar la expresi\u00f3n resultante usando estas mismas reglas.</li> </ol> <p>En el orden aplicativo se realizan las evaluaciones antes de realizar las sustituciones, lo que define una evaluaci\u00f3n de dentro a fuera de los par\u00e9ntesis. Cuando se llega a una expresi\u00f3n primitiva se eval\u00faa.</p> <p>En el orden normal se realizan todas las sustituciones hasta que se tiene una larga expresi\u00f3n formada por expresiones primitivas; se eval\u00faa entonces.</p> <p>Ambas formas de evaluaci\u00f3n dar\u00e1n el mismo resultado en programaci\u00f3n funcional. Scheme utiliza el orden aplicativo.</p>"},{"location":"teoria/tema02-programacion-funcional/tema02-programacion-funcional.html#141-ejemplo-1","title":"1.4.1. Ejemplo 1","text":"<p>Vamos a empezar con un ejemplo sencillo para comprobar c\u00f3mo se eval\u00faa una misma expresi\u00f3n utilizando ambos modelos de sustituci\u00f3n. Supongamos las siguientes definiciones:</p> <pre><code>(define (doble x) \n    (+ x x))\n\n(define (cuadrado y) \n    (* y y))\n\n(define a 2)\n</code></pre> <p>Queremos evaluar la siguiente expresi\u00f3n:</p> <pre><code>(doble (cuadrado a))\n</code></pre> <p>La evaluaci\u00f3n utilizando el modelo de sustituci\u00f3n aplicativo, usando paso a paso las reglas anteriores, es la siguiente (en cada l\u00ednea se indica entre par\u00e9ntesis la regla usada):</p> <pre><code>(doble (cuadrado a)) \u21d2       ; Sustituimos a por su valor (R2)\n(doble (cuadrado 2)) \u21d2       ; Sustitumos cuadrado por su cuerpo (R4)\n(doble (* 2 2)) \u21d2            ; Evaluamos (* 2 2) (R3)\n(doble 4) \u21d2                  ; Sustituimos doble por su cuerpo (R4)\n(+ 4 4) \u21d2                    ; Evaluamos (+ 4 4) (R3)\n8\n</code></pre> <p>Podemos comprobar que en el modelo aplicativo se intercalan las sustituciones de una funci\u00f3n por su cuerpo (regla 4) y las evaluaciones de expresiones (regla 3). </p> <p>Por el contrario, la evaluaci\u00f3n usando el modelo de sustituci\u00f3n normal es:</p> <pre><code>(doble (cuadrado a)) \u21d2            ; Sustituimos doble por su cuerpo (R4)\n(+ (cuadrado a) (cuadrado a) \u21d2    ; Sustituimos cuadrado por su cuerpo (R4)\n(+ (* a a) (* a a)  \u21d2             ; Sustitumos a por su valor (R2)\n(+ (* 2 2) (* 2 2)  \u21d2             ; Evaluamos (* 2 2) (R3)\n(+ 4 (* 2 2))  \u21d2                  ; Evaluamos (* 2 2) (R3)\n(+ 4 4)  \u21d2                        ; Evaluamos (+ 4 4) (R3)\n8\n</code></pre> <p>Al usar este modelo de evaluaci\u00f3n primero se realizan todas las sustituciones (regla 4) y despu\u00e9s todas las evaluaciones (regla 3). </p> <p>Las sustituciones se hacen de izquierda a derecha (de fuera a dentro de los par\u00e9ntesis). Primero se sustituye <code>doble</code> por su cuerpo y despu\u00e9s <code>cuadrado</code>.</p>"},{"location":"teoria/tema02-programacion-funcional/tema02-programacion-funcional.html#142-ejemplo-2","title":"1.4.2. Ejemplo 2","text":"<p>Veamos la evaluaci\u00f3n del ejemplo algo m\u00e1s complicado que hemos planteado al comienzo:</p> <pre><code>(define (doble x) \n    (+ x x))\n\n(define (cuadrado y) \n    (* y y))\n\n(define (f z) \n    (+ (cuadrado (doble z)) 1))\n\n(define a 2)\n</code></pre> <p>Expresi\u00f3n a evaluar:</p> <pre><code>(f (+ a 1))\n</code></pre> <p>Resultado de la evaluaci\u00f3n usando el modelo de sustituci\u00f3n aplicativo:</p> <pre><code>(f (+ a 1)) \u21d2                ; Para evaluar f, evaluamos primero su argumento (+ a 1) (R4)\n                             ; y sustituimos a por 2 (R2) \n(f (+ 2 1)) \u21d2                ; Evaluamos (+ 2 1) (R3)\n(f 3) \u21d2                      ; (R4)\n(+ (cuadrado (doble 3)) 1) \u21d2 ; Sustituimos (doble 3) (R4)\n(+ (cuadrado (+ 3 3)) 1) \u21d2   ; Evaluamos (+ 3 3) (R3)\n(+ (cuadrado 6) 1) \u21d2         ; Sustitumos (cuadrado 6) (R4)\n(+ (* 6 6) 1) \u21d2              ; Evaluamos (* 6 6) (R3)\n(+ 36 1) \u21d2                   ; Evaluamos (+ 36 1) (R3)\n37\n</code></pre> <p>Y veamos el resultado de usar el modelo de sustituci\u00f3n normal:</p> <pre><code>(f (+ a 1)) \u21d2                      ; Sustituimos (f (+ a 1)) \n                                   ; por su definici\u00f3n, con z = (+ a 1) (R4)\n(+ (cuadrado (doble (+ a 1))) 1) \u21d2 ; Sustituimos (cuadrado ...) (R4)\n(+ (* (doble (+ a 1))\n      (doble (+ a 1))) 1)          ; Sustituimos (doble  ...) (R4)\n(+ (* (+ (+ a 1) (+ a 1))\n      (+ (+ a 1) (+ a 1))) 1) \u21d2    ; Evaluamos a (R2)\n(+ (* (+ (+ 2 1) (+ 2 1))\n      (+ (+ 2 1) (+ 2 1))) 1) \u21d2    ; Evaluamos (+ 2 1) (R3)\n(+ (* (+ 3 3)\n      (+ 3 3)) 1) \u21d2                ; Evaluamos (+ 3 3) (R3)\n(+ (* 6 6) 1) \u21d2                    ; Evaluamos (* 6 6) (R3)\n(+ 36 1) \u21d2                         ; Evaluamos (+ 36 1) (R3)\n37\n</code></pre> <p>En programaci\u00f3n funcional el resultado de evaluar una expresi\u00f3n es el mismo independientemente del tipo de orden. Pero si estamos fuera del paradigma funcional y las funciones tienen estado y cambian de valor entre distintas invocaciones s\u00ed que importan si escogemos un orden.</p> <p>Por ejemplo, supongamos una funci\u00f3n <code>(random x)</code> que devuelve un entero aleatorio entre 0 y x. Esta funci\u00f3n no cumplir\u00eda el paradigma funcional, porque devuelve un valor distinto con el mismo par\u00e1metro de entrada.</p> <p>Evaluamos las siguientes expresiones con orden aplicativo y normal, para comprobar que el resultado es distinto.</p> <pre><code>(define (zero x) (- x x))\n(zero (random 10))\n</code></pre> <p>Si evaluamos la \u00faltima expresi\u00f3n en orden aplicativo:</p> <pre><code>(zero (random 10)) \u21d2 ; Evaluamos (random 10) (R3)\n(zero 3) \u21d2           ; Sustituimos (zero ...) (R4)\n(- 3 3) \u21d2            ; Evaluamos - (R3)\n0\n</code></pre> <p>Si lo evaluamos en orden normal:</p> <pre><code>(zero (random 10)) \u21d2            ; Sustituimos (zero ...) (R4)\n(- (random 10) (random 10)) \u21d2   ; Evaluamos (random 10) (R3)\n(- 5 3) \u21d2                       ; Evaluamos - (R3)\n2\n</code></pre>"},{"location":"teoria/tema02-programacion-funcional/tema02-programacion-funcional.html#2-scheme-como-lenguaje-de-programacion-funcional","title":"2. Scheme como lenguaje de programaci\u00f3n funcional","text":"<p>Ya hemos visto c\u00f3mo definir funciones y evaluar expresiones en Scheme. Vamos continuar con ejemplos concretos de otras caracter\u00edsticas funcionales caracter\u00edsticas funcionales de Scheme.</p> <p>En concreto, veremos:</p> <ul> <li>S\u00edmbolos y primitiva <code>quote</code></li> <li>Uso de listas</li> <li>Definici\u00f3n de funciones recursivas en Scheme</li> </ul>"},{"location":"teoria/tema02-programacion-funcional/tema02-programacion-funcional.html#21-funciones-y-formas-especiales","title":"2.1. Funciones y formas especiales","text":"<p>En el seminario de Scheme hemos visto un conjunto de primitivas que podemos utilizar en Scheme.</p> <p>Podemos clasificar las primitivas en funciones y formas especiales. Las funciones se eval\u00faan usando el modelo de sustituci\u00f3n aplicativo ya visto:</p> <ul> <li>Primero se eval\u00faan los argumentos y despu\u00e9s se sustituye la llamada   a la funci\u00f3n por su cuerpo y se vuelve a evaluar la expresi\u00f3n   resultante.</li> <li>Las expresiones siempre se eval\u00faan desde los par\u00e9ntesis interiores a   los exteriores.</li> </ul> <p>Las formas especiales son expresiones primitivas de Scheme que tienen una forma de evaluarse propia, distinta de las funciones. </p>"},{"location":"teoria/tema02-programacion-funcional/tema02-programacion-funcional.html#22-formas-especiales-en-scheme","title":"2.2. Formas especiales en Scheme","text":"<p>Veamos la forma de evaluar las distintas formas especiales en Scheme. En estas formas especiales no se aplica el modelo de sustituci\u00f3n, al no ser invocaciones de funciones, sino que cada una se eval\u00faa de una forma diferente.</p>"},{"location":"teoria/tema02-programacion-funcional/tema02-programacion-funcional.html#221-forma-especial-define","title":"2.2.1. Forma especial <code>define</code>","text":"<p>Sintaxis</p> <pre><code>(define &lt;identificador&gt; &lt;expresi\u00f3n&gt;)\n</code></pre> <p>Evaluaci\u00f3n</p> <ol> <li>Evaluar expresi\u00f3n</li> <li>Asociar el valor resultante con el identificador</li> </ol> <p>Ejemplo</p> <pre><code>(define base 10)   ; Asociamos a 'base' el valor 10\n(define altura 12) ; Asociamos a 'altura' el valor 12\n(define area (/ (* base altura) 2)) ; Asociamos a 'area' el valor 60\n</code></pre>"},{"location":"teoria/tema02-programacion-funcional/tema02-programacion-funcional.html#222-forma-especial-define-para-definir-funciones","title":"2.2.2. Forma especial <code>define</code> para definir funciones","text":"<p>Sintaxis</p> <pre><code>(define (&lt;nombre-funcion&gt; &lt;argumentos&gt;)\n    &lt;cuerpo&gt;)\n</code></pre> <p>Evaluaci\u00f3n</p> <p>La semana que viene veremos con m\u00e1s detalle la sem\u00e1ntica, y explicaremos la forma especial <code>lambda</code> que es la que realmente crea la funci\u00f3n. Hoy nos quedamos en la siguiente descripci\u00f3n de alto nivel de la sem\u00e1ntica:</p> <ol> <li>Crear la funci\u00f3n con el cuerpo</li> <li>Dar a la funci\u00f3n el nombre nombre-funci\u00f3n</li> </ol> <p>Ejemplo</p> <pre><code>(define (factorial x)\n    (if (= x 0)\n        1\n        (* x (factorial (- x 1)))))\n</code></pre>"},{"location":"teoria/tema02-programacion-funcional/tema02-programacion-funcional.html#223-forma-especial-if","title":"2.2.3. Forma especial <code>if</code>","text":"<p>Sintaxis</p> <pre><code>(if &lt;condici\u00f3n&gt; &lt;expresi\u00f3n-true&gt; &lt;expresi\u00f3n-false&gt;)\n</code></pre> <p>Evaluaci\u00f3n</p> <ol> <li>Evaluar condici\u00f3n</li> <li>Si el resultado es <code>#t</code> evaluar la expresi\u00f3n-true, en otro    caso, evaluar la expresi\u00f3n-false</li> </ol> <p>Ejemplo</p> <pre><code>(if (&gt; 10 5) (substring \"Hola qu\u00e9 tal\" (+ 1 1) 4) (/ 12 0))\n\n;; Evaluamos (&gt; 10 5). Como el resultado es #t, evaluamos \n;; (substring \"Hola qu\u00e9 tal\" (+ 1 1) 4), que devuelve \"la\"\n</code></pre> <p>Nota</p> <p>Al ser <code>if</code> una forma especial, no se eval\u00faa utilizando el modelo de sustituci\u00f3n, sino usando las reglas propias de la forma especial. </p> <p>Por ejemplo, veamos la siguiente expresi\u00f3n:</p> <pre><code>(if (&gt; 3 0) (+ 2 3) (/ 1 0)) ; \u21d2 5\n</code></pre> <p>Si se evaluara con el modelo de sustituci\u00f3n se lanzar\u00eda un error de divisi\u00f3n por  cero al intentar evaluar <code>(/ 1 0)</code>. Sin embargo, esa expresi\u00f3n no llega a evaluarse, porque la condici\u00f3n <code>(&gt; 3 0)</code> es cierta y s\u00f3lo se eval\u00faa la suma <code>(+ 2 3)</code>.</p>"},{"location":"teoria/tema02-programacion-funcional/tema02-programacion-funcional.html#224-forma-especial-cond","title":"2.2.4. Forma especial <code>cond</code>","text":"<p>Sintaxis</p> <pre><code>(cond\u00a0\n    (&lt;exp-cond-1&gt; &lt;exp-consec-1&gt;)\n    (&lt;exp-cond-2&gt; &lt;exp-consec-2&gt;)\n    ...\n    (else &lt;exp-consec-else&gt;))\n</code></pre> <p>Evaluaci\u00f3n</p> <ol> <li>Se eval\u00faan de forma ordenada todas las exp-cond-i hasta que una de    ellas devuelva <code>#t</code></li> <li>Si alguna exp-cond-i devuelve <code>#t</code>, se devuelve el valor de la    exp-consec-i.</li> <li>Si ninguna exp-cond-i es cierta, se devuelve el valor resultante de    evaluar exp-consec-else.</li> </ol> <p>Ejemplo</p> <pre><code>(cond\n\u00a0\u00a0 ((&gt; 3 4) \"3 es mayor que 4\")\n\u00a0\u00a0 ((&lt; 2 1) \"2 es menor que 1\")\n\u00a0\u00a0 ((= 3 1) \"3 es igual que 1\")\n\u00a0\u00a0 ((&gt; 3 5) \"3 es mayor que 2\")\n\u00a0\u00a0 (else \"ninguna condici\u00f3n es cierta\"))\n\n;; Se eval\u00faan una a una las expresiones (&gt; 3 4),\n;; (&lt; 2 1), (= 3 1) y (&gt; 3 5). Como ninguna de ella\n;; es cierta se devuelve la cadena \"ninguna condici\u00f3n es cierta\".\n</code></pre>"},{"location":"teoria/tema02-programacion-funcional/tema02-programacion-funcional.html#2241-formas-especiales-and-y-or","title":"2.2.4.1. Formas especiales <code>and</code> y <code>or</code>","text":"<p>Las expresiones l\u00f3gicas <code>and</code> y <code>or</code> no son funciones, sino formas especiales. Lo podemos comprobar con el siguiente ejemplo:</p> <pre><code>(and #f (/ 3 0)) ; \u21d2 #f\n(or #t (/ 3 0))  ; \u21d2 #t\n</code></pre> <p>Si <code>and</code> y <code>or</code> fueran funciones, seguir\u00edan la regla que hemos visto de evaluar primero los argumentos y despu\u00e9s invocar a la funci\u00f3n con los resultados. Esto producir\u00eda un error al evaluar la expresi\u00f3n <code>(/ 3 0)</code>, al ser una divisi\u00f3n por 0.</p> <p>Sin embargo, vemos que las expresiones no dan error y devuelven un valor booleano. \u00bfPor qu\u00e9? Porque <code>and</code> y <code>or</code> no son funciones, sino formas especiales que se eval\u00faan de forma diferente a las funciones.</p> <p>En concreto, <code>and</code> y <code>or</code> van evaluando los argumentos hasta que encuentran un valor que hace que ya no sea necesario evaluar el resto.</p> <p>Sintaxis</p> <pre><code>(and exp1 ... expn)\n(or exp1 ... expn)\n</code></pre> <p>Evaluaci\u00f3n <code>and</code></p> <ul> <li>Se eval\u00faa la expresi\u00f3n 1. Si el resultado es <code>#f</code>, se devuelve <code>#f</code>, en otro caso, se eval\u00faa la siguiente expresi\u00f3n.</li> <li>Se repite hasta la \u00faltima expresi\u00f3n, cuyo resultado se devuelve.</li> </ul> <p>Ejemplos <code>and</code></p> <pre><code>(and #f (/ 3 0)) ; \u21d2 #f\n(and #t (&gt; 2 1) (&lt; 5 10)) ; \u21d2 #t\n(and #t (&gt; 2 1) (&lt; 5 10) (+ 2 3)) ; \u21d2 5\n</code></pre> <p>La regla de evaluaci\u00f3n de <code>and</code> hace que sea posible que devuelva resultados no booleanos, como el \u00faltimo ejemplo. Sin embargo, no es recomendable usarlo de esta forma y en la asignatura no lo vamos a hacer nunca.</p> <p>Evaluaci\u00f3n <code>or</code></p> <ul> <li>Se eval\u00faa la expresi\u00f3n 1. Si el resultado es distinto de <code>#f</code> se   devuelve ese resultado. Si el resultado es <code>#f</code> se eval\u00faa la   siguiente expresi\u00f3n.</li> <li>Se repite hasta la \u00faltima expresi\u00f3n, cuyo resultado se devuelve.</li> </ul> <p>Ejemplos <code>or</code></p> <pre><code>(or #t (/ 3 0)) ; \u21d2 #t\n(or #f (&lt; 2 10) (&gt; 5 10)) ; \u21d2 #t\n(or (+ 2 3) (&gt; 5 10)) ; \u21d2 5\n</code></pre> <p>Al igual que <code>and</code>, la regla de evaluaci\u00f3n de <code>or</code> hace que sea posible que devuelva resultados no booleanos, como el \u00faltimo ejemplo. Tampoco es recomendable usarlo de esta forma.</p>"},{"location":"teoria/tema02-programacion-funcional/tema02-programacion-funcional.html#23-forma-especial-quote-y-simbolos","title":"2.3. Forma especial <code>quote</code> y s\u00edmbolos","text":"<p>Sintaxis</p> <pre><code>(quote &lt;identificador&gt;)\n</code></pre> <p>Evaluaci\u00f3n</p> <ul> <li>Se devuelve el identificador sin evaluar (un s\u00edmbolo).</li> <li>Se abrevia en con el car\u00e1cter <code>'</code>.</li> </ul> <p>Ejemplos</p> <pre><code>(quote x) ; el s\u00edmbolo x\n'hola ; el s\u00edmbolo hola\n</code></pre> <p>A diferencia de los lenguajes imperativos, Scheme trata a los identificadores (nombres que se les da a las variables) como datos del lenguaje de tipo symbol. En el paradigma funcional a los identificadores se les denomina s\u00edmbolos.</p> <p>Los s\u00edmbolos son distintos de las cadenas. Una cadena es un tipo de dato compuesto y se guardan en memoria todos y cada uno de los caracteres que la forman. Sin embargo, los s\u00edmbolos son tipos at\u00f3micos, que se representan en memoria con un \u00fanico valor determinado por el c\u00f3digo hash del identificador.</p> <p>Ejemplos de funciones Scheme con s\u00edmbolos:</p> <pre><code>(define x 12)\n(symbol? 'x) ; \u21d2 #t\n(symbol? x) ; \u21d2 #f \u00bfPor qu\u00e9?\n(symbol? 'hola-que&lt;&gt;)\n(symbol-&gt;string 'hola-que&lt;&gt;)\n'ma\u00f1ana\n'l\u00e1piz ; aunque sea posible, no vamos a usar acentos en los s\u00edmbolos\n; pero s\u00ed en los comentarios\n(symbol? \"hola\") ; #f\n(symbol?  #f) ; #f\n(symbol? (first '(hola c\u00f3mo est\u00e1s))) ; #t\n(equal? 'hola 'hola)\n(equal? 'hola \"hola\")\n</code></pre> <p>Como hemos visto anteriormente, un s\u00edmbolo puede asociarse o ligarse (bind) a un valor (cualquier dato de primera clase) con la forma especial <code>define</code>.</p> <pre><code>(define pi 3.14159)\n</code></pre> <p>Nota</p> <p>No es correcto escribir <code>(define 'pi 3.14156)</code> porque la forma especial <code>define</code> debe recibir un identificador sin quote.</p> <p>Cuando escribimos un s\u00edmbolo en el prompt de Scheme el int\u00e9rprete lo eval\u00faa y devuelve su valor:</p> <pre><code>&gt; pi \n3.14159\n</code></pre> <p>Los nombres de las funciones (<code>equal?</code>, <code>sin</code>, <code>+</code>, ...) son tambi\u00e9n s\u00edmbolos y Scheme tambi\u00e9n los eval\u00faa (en un par de semanas hablaremos de las funciones como objetos primitivos en Scheme):</p> <pre><code>&gt; sin\n#&lt;procedure:sin&gt;\n&gt; +\n#&lt;procedure:+&gt;\n&gt; (define (cuadrado x) (* x x)) \n&gt; cuadrado\n#&lt;procedure:cuadrado&gt;\n</code></pre> <p>Los s\u00edmbolos son tipos primitivos del lenguaje: pueden pasarse como par\u00e1metros o ligarse a variables.</p> <pre><code>&gt; (define x 'hola)\n&gt; x\nhola\n</code></pre>"},{"location":"teoria/tema02-programacion-funcional/tema02-programacion-funcional.html#24-forma-expecial-quote-con-expresiones","title":"2.4. Forma expecial <code>quote</code> con expresiones","text":"<p>Sintaxis</p> <pre><code>(quote &lt;expresi\u00f3n&gt;)\n</code></pre> <p>Evaluaci\u00f3n</p> <p>Si <code>quote</code> recibe una expresi\u00f3n correcta de Scheme (una expresi\u00f3n entre par\u00e9ntesis) se devuelve la lista o pareja definida por la expresi\u00f3n (sin evaluar sus elementos).</p> <p>Ejemplos</p> <pre><code>'(1 2 3) ; \u21d2 (1 2 3) Una lista\n'(+ 1 2 3 4) ; La lista formada por el s\u00edmbolo + y los n\u00fameros 1 2 3 4\n(quote (1 2 3 4)) ; La lista formada por los n\u00fameros 1 2 3 4\n'(a b c) ; \u21d2 La lista con los s\u00edmbolos a, b, y c\n'(* (+ 1 (+ 2 3)) 5) ; Una lista con 3 elementos, el segundo de ellos otra lista\n'(1 . 2) ; \u21d2 La pareja (1 . 2)\n'((1 . 2) (2 . 3)) ; \u21d2 Una lista con las parejas (1 . 2) y (2 . 3)\n</code></pre>"},{"location":"teoria/tema02-programacion-funcional/tema02-programacion-funcional.html#25-funcion-eval","title":"2.5. Funci\u00f3n <code>eval</code>","text":"<p>Curiosidad del lenguaje: <code>eval</code></p> <p>Racket dispone de la funci\u00f3n <code>eval</code>, que permite evaluar expresiones construidas din\u00e1micamente en tiempo de ejecuci\u00f3n.</p> <p>Sintaxis</p> <pre><code>(eval &lt;expresi\u00f3n&gt;)\n</code></pre> <p>Evaluaci\u00f3n</p> <p>La funci\u00f3n <code>eval</code> invoca al int\u00e9rprete para realizar la evaluaci\u00f3n de la expresi\u00f3n que se le pasa como par\u00e1metro y devuelve el resultado de dicha evaluaci\u00f3n.</p> <p>Ejemplos</p> <pre><code>(define a 10)\n(eval 'a) ; \u21d2 10\n\n(eval '(+ 1 2 3)) ; \u21d2 6\n\n(define lista (list '+ 1 2 3))\n(eval lista) ; \u21d2 6\n</code></pre>"},{"location":"teoria/tema02-programacion-funcional/tema02-programacion-funcional.html#26-listas","title":"2.6. Listas","text":"<p>Otra de las caracter\u00edsticas fundamentales del paradigma funcional es la utilizaci\u00f3n de listas. Ya hemos visto en el seminario de Scheme las funciones m\u00e1s importantes para trabajar con ellas. Vamos a repasarlas de nuevo en este apartado, antes de ver alg\u00fan ejemplo de c\u00f3mo usar la recursi\u00f3n con listas.</p> <p>Ya hemos visto en dicho seminario que Scheme es un lenguaje d\u00e9bilmente tipado. Una variable o par\u00e1metro no se declara de un tipo y puede contener cualquier valor. Sucede igual con las listas: una lista en Scheme puede contener cualquier valor, incluyendo otras listas.</p>"},{"location":"teoria/tema02-programacion-funcional/tema02-programacion-funcional.html#261-diferencia-entre-la-funcion-list-y-la-forma-especial-quote","title":"2.6.1. Diferencia entre la funci\u00f3n <code>list</code> y la forma especial <code>quote</code>","text":"<p>En el seminario de Scheme explicamos que podemos crear listas de forma din\u00e1mica, llamando a la funci\u00f3n <code>list</code> y pas\u00e1ndole un n\u00famero variable de par\u00e1metros que son los elementos que se incluir\u00e1n en la lista:</p> <p><pre><code>(list 1 2 3 4 5) ; \u21d2 (1 2 3 4)\n(list 'a 'b 'c) ; \u21d2 (a b c)\n(list 1 'a 2 'b 3 'c #t) ; \u21d2 (1 a 2 b 3 c #t)\n(list 1 (+ 1 1) (* 2 (+ 1 2))) ; \u21d2 (1 2 6)\n</code></pre> Las expresiones interiores se eval\u00faan y se llama a la funci\u00f3n <code>list</code> con los valores resultantes.</p> <p>Otro ejemplo:</p> <pre><code>(define a 1)\n(define b 2)\n(define c 3)\n(list a b c) ; \u21d2 (1 2 3)\n</code></pre> <p>Como hemos visto cuando hemos hablado de <code>quote</code>, esta forma especial tambi\u00e9n puede construir una lista. Pero lo hace sin evaluar sus elementos.</p> <p>Por ejemplo:</p> <pre><code>'(1 2 3 4) ; \u21d2 (1 2 3 4)\n(define a 1)\n(define b 2)\n(define c 3)\n'(a b c) ; \u21d2 (a b c)\n'(1 (+ 1 1) (* 2 (+ 1 2))) ; \u21d2 (1 (+ 1 1) (* 2 (+ 1 2)))\n</code></pre> <p>La \u00faltima lista tiene 3 elementos:</p> <ul> <li>El n\u00famero 1</li> <li>La lista <code>(+ 1 1)</code></li> <li>La lista <code>(* 2 (+ 1 2))</code></li> </ul> <p>Es posible definir una lista vac\u00eda (sin elementos) realizando una llamada sin argumentos a la funci\u00f3n <code>list</code> o utilizando el s\u00edmbolo `():</p> <pre><code>(list) ; \u21d2 ()\n`() ; \u21d2 ()\n</code></pre> <p>La diferencia entre creaci\u00f3n de listas con la funci\u00f3n <code>list</code> y con la forma especial <code>quote</code> se puede comprobar en los ejemplos.</p> <p>La evaluaci\u00f3n de la funci\u00f3n <code>list</code> funciona como cualquier funci\u00f3n, primero se eval\u00faan los argumentos y despu\u00e9s se invoca a la funci\u00f3n con los argumentos evaluados. Por ejemplo, en la siguiente invocaci\u00f3n se obtiene una lista con cuatro elementos resultantes de las invocaciones de las funciones dentro del par\u00e9ntesis:</p> <pre><code>(list 1 (/ 2 3) (+ 2 3)) ; \u21d2 (1 2/3 5)\n</code></pre> <p>Sin embargo, usamos <code>quote</code> obtenemos una lista con sublistas con s\u00edmbolos en sus primeras posiciones:</p> <pre><code>'(1 (/ 2 3) (+ 2 3)) ; \u21d2 (1 (/ 2 3) (+ 2 3))\n</code></pre>"},{"location":"teoria/tema02-programacion-funcional/tema02-programacion-funcional.html#262-seleccion-de-elementos-de-una-lista-first-y-rest","title":"2.6.2. Selecci\u00f3n de elementos de una lista: <code>first</code> y <code>rest</code>","text":"<p>En el seminario vimos tambi\u00e9n c\u00f3mo obtener los elementos de una lista.</p> <ul> <li>Primer elemento: funci\u00f3n <code>first</code></li> <li>Resto de elementos: funci\u00f3n <code>rest</code> (los devuelve en forma de lista)</li> </ul> <p>Ejemplos:</p> <pre><code>(define lista1 '(1 2 3 4))\n(first lista1) ; \u21d2 1\n(rest lista1) ; \u21d2 (2 3 4)\n(define lista2 '((1 2) 3 4))\n(first lista2) \u21d2 (1 2)\n(rest lista2) \u21d2 (3 4)\n</code></pre>"},{"location":"teoria/tema02-programacion-funcional/tema02-programacion-funcional.html#263-funciones-cons-y-append","title":"2.6.3. Funciones <code>cons</code> y <code>append</code>","text":"<p>Por \u00faltimo, en el seminario vimos tambi\u00e9n c\u00f3mo construir nuevas listas a partir de ya existentes con las funciones <code>cons</code> y <code>append</code>.</p> <p>La funci\u00f3n <code>cons</code> crea una lista nueva resultante de a\u00f1adir un elemento al comienzo de la lista. Esta funci\u00f3n es la forma habitual de construir nuevas listas a partir de una lista ya existente y un nuevo elemento.</p> <pre><code>(cons 1 '(1 2 3 4)) ; \u21d2 (1 1 2 3 4)\n(cons 'hola '(como est\u00e1s)) ; \u21d2 (hola como est\u00e1s)\n(cons '(1 2) '(1 2 3 4))  ; \u21d2 ((1 2) 1 2 3 4)\n</code></pre> <p>La funci\u00f3n <code>append</code> se usa para crear una lista nueva resultado de concatenar dos o m\u00e1s listas</p> <pre><code>(define list1 '(1 2 3 4))\n(define list2 '(hola como est\u00e1s))\n(append list1 list2) ; \u21d2 (1 2 3 4 hola como est\u00e1s)\n</code></pre> <p>Diferencias entre <code>cons</code> y <code>append</code></p> <p>Es muy importante diferenciar <code>cons</code> y <code>append</code>. En ambos casos el resultado es una lista y ambas funciones tienen dos par\u00e1metros, siendo el segundo la lista en la que se a\u00f1ade el primero. La diferencia entre ambas funciones es el tipo del primer par\u00e1metro. En <code>cons</code> es un elemento que se a\u00f1ade a la lista, mientras que en <code>append</code> es otra lista que se concatena con la segunda.</p>"},{"location":"teoria/tema02-programacion-funcional/tema02-programacion-funcional.html#6-bibliografia","title":"6. Bibliograf\u00eda","text":"<p>Cap\u00edtulos del libro Structure and Intepretation of Computer Programs:</p> <ul> <li>1.1  The Elements of Programming</li> <li>1.3  Formulating Abstractions with Higher-Order Procedures</li> <li>2.2.1  Representing Sequences</li> </ul> <p>Lenguajes y Paradigmas de Programaci\u00f3n, curso 2025-26 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Domingo Gallardo, Cristina Pomares, Antonio Bot\u00eda, Francisco Mart\u00ednez</p>"},{"location":"teoria/tema03-procedimientos-recursivos/tema03-procedimientos-recursivos.html","title":"Tema 3: Procedimientos recursivos","text":"<p>Ya hemos visto muchos ejemplos de funciones recursivas. Una funci\u00f3n es recursiva cuando se llama a si misma. Una vez que uno se acostumbra a su uso, se comprueba que la recursi\u00f3n es una forma mucho m\u00e1s natural que la iteraci\u00f3n de expresar un gran n\u00famero de funciones y procedimientos.</p> <p>La formulaci\u00f3n matem\u00e1tica de la recursi\u00f3n es sencilla de entender, pero su implementaci\u00f3n en un lenguaje de programaci\u00f3n no lo es tanto. El primer lenguaje de programaci\u00f3n que permiti\u00f3 el uso de expresiones recursivas fue el Lisp. En el momento de su creaci\u00f3n exist\u00eda ya el Fortran, que no permit\u00eda que una funci\u00f3n se llamase a si misma.</p> <p>Ya hemos visto la utilidad de la recursi\u00f3n en muchos ejemplos para recorrer listas, para filtrarlas, etc. En este tema veremos algunos aspectos negativos de la recursi\u00f3n: su coste espacial y temporal. Veremos que hay soluciones a estos problemas, cambiando el estilo de la recursi\u00f3n y generando procesos iterativos o usando un enfoque autom\u00e1tico llamado memoization en el que se guardan los resultados de cada llamada recursiva. Por \u00faltimo, veremos un \u00faltimo ejemplo curioso e interesante de la recursi\u00f3n para realizar figuras fractales con la librer\u00eda gr\u00e1fica de Racket.</p>"},{"location":"teoria/tema03-procedimientos-recursivos/tema03-procedimientos-recursivos.html#1-el-coste-de-la-recursion","title":"1. El coste de la recursi\u00f3n","text":"<p>Hasta ahora hemos estudiado el dise\u00f1o de funciones recursivas. Vamos a tratar por primera vez su coste. Veremos que hay casos en los que es prohibitivo utilizar la recursi\u00f3n tal y como la hemos visto. Y veremos tambi\u00e9n que existen soluciones para esos casos.</p>"},{"location":"teoria/tema03-procedimientos-recursivos/tema03-procedimientos-recursivos.html#11-la-pila-de-la-recursion","title":"1.1. La pila de la recursi\u00f3n","text":"<p>Vamos a estudiar el comportamiento de la evaluaci\u00f3n de una llamada a una funci\u00f3n recursiva. Supongamos la funci\u00f3n <code>mi-length</code>:</p> <pre><code>(define (mi-length items)\n   (if (null? items)\n      0\n      (+ 1 (mi-length (rest items)))))\n</code></pre> <p>Examinamos c\u00f3mo se eval\u00faan las llamadas recursivas:</p> <pre><code>(mi-length '(a b c d))\n(+ 1 (mi-length '(b c d)))\n(+ 1 (+ 1 (mi-length '(c d))))\n(+ 1 (+ 1 (+ 1 (mi-length '(d)))))\n(+ 1 (+ 1 (+ 1 (+ 1 (mi-length '())))))\n(+ 1 (+ 1 (+ 1 (+ 1 0))))\n(+ 1 (+ 1 (+ 1 1)))\n(+ 1 (+ 1 2))\n(+ 1 3)\n4\n</code></pre> <p>Cada llamada a la recursi\u00f3n deja una funci\u00f3n en espera de ser evaluada cuando la recursi\u00f3n devuelva un valor (en el caso anterior las funciones suma). Estas llamadas en espera, junto con sus argumentos, se almacenan en la pila de la recursi\u00f3n.</p> <p>Cuando la recursi\u00f3n devuelve un valor, los valores se recuperan de la pila, se realiza la llamada y se devuelve el valor a la anterior llamada en espera. </p> <p>Si la recursi\u00f3n est\u00e1 mal hecha y nunca termina se genera un stack overflow porque la memoria que se almacena en la pila sobrepasa la memoria reservada para el int\u00e9rprete DrRacket.</p>"},{"location":"teoria/tema03-procedimientos-recursivos/tema03-procedimientos-recursivos.html#12-coste-espacial-de-la-recursion","title":"1.2. Coste espacial de la recursi\u00f3n","text":"<p>El coste espacial de un programa es una funci\u00f3n que relaciona la memoria consumida por una llamada para resolver un problema con alguna variable que determina el tama\u00f1o del problema a resolver.</p> <p>En el caso de la funci\u00f3n <code>mi-length</code> el tama\u00f1o del problema viene dado por la longitud de la lista. El coste espacial de <code>mi-lenght</code> es O(n), siendo n la longitud de la lista.</p>"},{"location":"teoria/tema03-procedimientos-recursivos/tema03-procedimientos-recursivos.html#13-el-coste-depende-del-numero-de-llamadas-a-la-recursion","title":"1.3. El coste depende del n\u00famero de llamadas a la recursi\u00f3n","text":"<p>Veamos con un ejemplo que el coste de las llamadas recursivas puede dispararse. Supongamos la famosa secuencia de Fibonacci: 0,1,1,2,3,5,8,13,...</p> <p>Formulaci\u00f3n matem\u00e1tica de la secuencia de Fibonacci:</p> <pre><code>Fibonacci(n) = Fibonacci(n-1) + Fibonacci(n-2)\nFibonacci(0) = 0\nFibonacci(1) = 1\n</code></pre> <p>Formulaci\u00f3n recursiva en Scheme:</p> <pre><code>(define (fib n)\n   (cond ((= n 0) 0)\n      ((= n 1) 1)\n      (else (+ (fib (- n 1))\n               (fib (- n 2))))))\n</code></pre> <p>Evaluaci\u00f3n de una llamada a Fibonacci:</p> <p></p> <p>Cada llamada a la recursi\u00f3n produce otras dos llamadas, por lo que el n\u00famero de llamadas finales es 2^n siendo n el n\u00famero que se pasa a la funci\u00f3n.</p> <p>El coste espacial y temporal es exponencial, O(2^n). Esto hace inviable utilizar esta implementaci\u00f3n para realizar el c\u00e1lculo de la funci\u00f3n. Puedes comprobarlo intentando evaluar en el int\u00e9rprete <code>(fib 35)</code>.</p>"},{"location":"teoria/tema03-procedimientos-recursivos/tema03-procedimientos-recursivos.html#2-soluciones-al-coste-de-la-recursion-procesos-iterativos","title":"2. Soluciones al coste de la recursi\u00f3n: procesos iterativos","text":"<p>Diferenciamos entre procedimientos y procesos: un procedimiento es un algoritmo y un proceso es la ejecuci\u00f3n de ese algoritmo.</p> <p>Es posible definir procedimientos recursivos que generen procesos iterativos (como los bucles en programaci\u00f3n imperativa) en los que no se dejen llamadas recursivas en espera ni se incremente la pila de la recursi\u00f3n. Para ello construimos la recursi\u00f3n de forma que en cada llamada se haga un c\u00e1lculo parcial y en el caso base se pueda devolver directamente el resultado obtenido.</p> <p>Este estilo de recursi\u00f3n se denomina recursi\u00f3n por la cola (tail recursion, en ingl\u00e9s).</p> <p>Se puede realizar una implementaci\u00f3n eficiente de la ejecuci\u00f3n del proceso, eliminando la pila de la recursi\u00f3n.</p>"},{"location":"teoria/tema03-procedimientos-recursivos/tema03-procedimientos-recursivos.html#21-factorial-iterativo","title":"2.1. Factorial iterativo","text":"<p>Empezamos a explicar la recursi\u00f3n por la cola con un ejemplo muy sencillo: la versi\u00f3n iterativa de la t\u00edpica funci\u00f3n <code>factorial</code>. Le pondremos de nombre a la funci\u00f3n <code>factorial-iter</code>:</p> <pre><code>(define (factorial n)\n   (fact-iter n n))\n\n(define (fact-iter n result)\n   (if (= n 1)\n      result\n      (fact-iter (- n 1) (* result (- n 1))  )))\n</code></pre> <p>La funci\u00f3n <code>(fact-iter n result)</code> es la que define el proceso iterativo. Su argumento <code>n</code> es el valor del que hay que calcular el factorial y el argumento <code>result</code> es un par\u00e1metro adicional en el que se van guardando los resultados intermedios.</p> <p>En cada llamada recursiva, <code>n</code> se va haciendo cada vez m\u00e1s peque\u00f1o y en <code>result</code> se va acumulando el c\u00e1lculo del factorial. Al final de la recursi\u00f3n el factorial debe estar calculado en <code>result</code> y se devuelve.</p> <p>Veamos la secuencia de llamadas:</p> <pre><code>(factorial 4)\n(factorial-iter 4 4)\n(factorial-iter 3 4*3=12)\n(factorial-iter 2 12*2=24)\n(factorial-iter 1 24*1=24)\n24\n</code></pre> <p>Antes de realizar cada llamada recursiva se realiza el c\u00e1lculo del resultado parcial, que se guarda en el par\u00e1metro <code>result</code>. Despu\u00e9s se realiza la llamada con el nuevo valor calculado de <code>n</code> y de <code>result</code>.</p> <p>Al final, cuando <code>n</code> vale <code>1</code> se devuelve el valor calculado de <code>result</code>. Este valor es el resultado completo de la recursi\u00f3n, ya que no hay que hacer ninguna operaci\u00f3n m\u00e1s con \u00e9l. A diferencia de los procesos recursivos, en los que se quedan llamadas en espera en la pila de la recursi\u00f3n, en los procesos iterativos no hay ninguna llamada en espera. El resultado devuelto por el caso base es directamente la soluci\u00f3n de la recursi\u00f3n, no queda nada por hacer con este resultado.</p> <p>Es importante el valor inicial de <code>resultado</code>. La funci\u00f3n <code>factorial</code> se encarga de inicializar este par\u00e1metro. En este caso es el mismo valor del n\u00famero <code>n</code> a calcular el factorial. </p> <p>La secuencia de llamadas recursivas acumula en la variable <code>result</code> el valor del factorial:</p> <pre><code>4 * 3 * 2 * 1 = 24\n</code></pre>"},{"location":"teoria/tema03-procedimientos-recursivos/tema03-procedimientos-recursivos.html#22-version-iterativa-de-mi-length","title":"2.2. Versi\u00f3n iterativa de mi-length","text":"<p>Veamos un segundo ejemplo. \u00bfC\u00f3mo ser\u00eda la versi\u00f3n iterativa de <code>mi-length</code>, la funci\u00f3n que calcula la logitud de una lista?.</p> <p>Tenemos que a\u00f1adir un par\u00e1metro adicional en el que iremos acumulando el resultado parcial. En este caso, cada vez que llamemos a la recursi\u00f3n eliminado un elemento de la lista, incrementaremos en 1 el valor del resultado. Para que funcione bien este enfoque, debemos inicializar este resultado a 0.</p> <p>La soluci\u00f3n es la siguiente:</p> <pre><code>(define (mi-length lista)\n   (mi-length-iter lista 0))\n\n(define (mi-length-iter lista result)\n   (if (null? lista)\n      result\n      (mi-length-iter (rest lista) (+ result 1))))\n</code></pre> <p>Fijaros que, al igual que en la versi\u00f3n iterativa de factorial, no hay ninguna llamada a ning\u00fana funci\u00f3n que recoja el resultado de la llamada recursiva y haga algo con \u00e9l. Directamente el resultado de la llamada recursiva es el resultado final de la recursi\u00f3n.</p>"},{"location":"teoria/tema03-procedimientos-recursivos/tema03-procedimientos-recursivos.html#23-funcion-suma-lista-usando-recursion-por-la-cola","title":"2.3. Funci\u00f3n <code>suma-lista</code> usando recursi\u00f3n por la cola","text":"<p>Veamos otro ejemplo. Supongamos que queremos calcular usando recursi\u00f3n por la cola la suma de los n\u00fameros de una lista.</p> <p>Deber\u00edamos a\u00f1adir un par\u00e1metro adicional en el que vamos acumulando esa suma. Inicializaremos a 0 ese par\u00e1metro e iremos en cada llamada recursiva acumulando el primer elemento de la lista:</p> <pre><code>(define (suma-lista lista)\n   (suma-lista-iter lista 0))\n\n(define (suma-lista-iter lista result)\n   (if (null? lista)\n      result\n      (suma-lista-iter (rest lista) (+ result (first lista)))))\n</code></pre>"},{"location":"teoria/tema03-procedimientos-recursivos/tema03-procedimientos-recursivos.html#24-caracteristicas-de-los-procesos-iterativos","title":"2.4. Caracter\u00edsticas de los procesos iterativos","text":"<p>Un resumen de las caracter\u00edsticas de los procesos iterativos resultantes de hacer una recursi\u00f3n por la cola:</p> <ul> <li>La recursi\u00f3n resultante es menos elegante.</li> <li>Se necesita una par\u00e1metro adicional en el que se van acumulando los   resultados parciales.</li> <li>La \u00faltima llamada a la recursi\u00f3n devuelve el valor acumulado.</li> <li>El proceso resultante de la recursi\u00f3n es iterativo en el sentido de   que no deja llamadas en espera ni incurre en coste espacial.</li> </ul>"},{"location":"teoria/tema03-procedimientos-recursivos/tema03-procedimientos-recursivos.html#25-fibonacci-iterativo","title":"2.5. Fibonacci iterativo","text":"<p>Cualquier programa recursivo se puede transformar en otro que genera un proceso iterativo.</p> <p>En general, las versiones iterativas son menos intuitivas y m\u00e1s dif\u00edciles de entender y depurar.</p> <p>Veamos, por ejemplo, la formulaci\u00f3n iterativa de Fibonacci:</p> <pre><code>(define (fib n)\n   (fib-iter 1 0 n))\n\n(define (fib-iter a b count)\n   (if (= count 0)\n      b\n      (fib-iter (+ a b) a (- count 1))))\n</code></pre> <p>La secuencia de llamadas recursivas ser\u00eda la siguiente:</p> <pre><code>(fib 6)\n(fib-iter 1 0 6)\n(fib-iter 1+0=1 1 5)\n(fib-iter 1+1=2 1 4)\n(fib-iter 2+1=3 2 3)\n(fib-iter 3+2=5 3 2)\n(fib-iter 5+3=8 5 1)\n(fib-iter 8+5=13 8 0)\n8\n</code></pre> <p>En la llamada recursiva <code>n</code>, el par\u00e1metro <code>a</code> guarda el valor de fibonacci <code>n+1</code> y el par\u00e1metro <code>b</code> guarda el valor de fibonacci <code>n</code>, que es el que se devuelve. Conseguimos <code>n</code> llamadas inicializando <code>count</code> a n y decrementando el par\u00e1metro en 1 cada vez.</p>"},{"location":"teoria/tema03-procedimientos-recursivos/tema03-procedimientos-recursivos.html#26-triangulo-de-pascal","title":"2.6. Tri\u00e1ngulo de Pascal","text":"<p>El tri\u00e1ngulo de Pascal es el siguiente tri\u00e1ngulo de n\u00fameros.</p> <pre><code>1\n1   1\n1   2   1\n1   3   3   1\n1   4   6   4   1\n1   5  10   10  5   1\n1   6  15  20   15  6   1\n1   7  21  35   35  21  7   1\n          ...\n</code></pre> <p>Si numeramos las filas y columnas empezando a contar por 0, la expresi\u00f3n general del valor en una fila y columna determinada se puede obtener con la siguiente definici\u00f3n recursiva:</p> <pre><code>Pascal (n, 0) = 1\nPascal (n, n) = 1\nPascal (fila, columna) = \n    Pascal (fila-1,columna-1) + Pascal (fila-1, columna)\n</code></pre> <p>La funci\u00f3n s\u00f3lo est\u00e1 definida para valores de <code>columna</code> menores o iguales que <code>fila</code>.</p> <p>En Scheme es f\u00e1cil escribir una funci\u00f3n recursiva que implemente la definici\u00f3n anterior:</p> <pre><code>(define (pascal fila col)\n   (cond ((= col 0) 1)\n         ((= col fila) 1)\n         (else (+ (pascal (- fila 1) (- col 1))\n                  (pascal (- fila 1) col) ))))\n(pascal 4 2)\n; \u21d2 6\n(pascal 8 4)\n; \u21d2 70\n(pascal 27 13)\n; \u21d2 20058300\n</code></pre> <p>Hay que llamar a la funci\u00f3n con un valor de <code>col</code> menor o igual que <code>fila</code>. En el caso en que se pase un valor <code>col</code> mayor que <code>fila</code> la recursi\u00f3n no termina y se entra en un bucle infinito.</p> <p>La funci\u00f3n tiene una formulaci\u00f3n sencilla y funciona correctamente. Sin embargo, el coste de esta recursi\u00f3n es tambi\u00e9n exponencial, igual que pasaba en el caso de la secuencia de fibonacci. Por ejemplo, la \u00faltima expresi\u00f3n <code>(pascal 27 13)</code> tarda un buen rato en devolver el resultado. Ser\u00eda imposible calcular el valor de n\u00fameros de Pascal un poco m\u00e1s grandes, como <code>(pascal 40 20)</code>.</p> <p>Veamos c\u00f3mo se puede conseguir una versi\u00f3n iterativa.</p> <p>La idea es definir una funci\u00f3n iterativa <code>pascal-fila</code> a la que le pasamos el n\u00famero de fila <code>n</code> y nos devuelve la lista de <code>n+1</code> n\u00fameros que constituyen la fila <code>n</code> del tri\u00e1ngulo de Pascal:</p> <pre><code>fila 0 = (1)\nfila 1 = (1 1)\nfila 2 = (1 2 1)\nfila 3 = (1 3 3 1)\nfila 4 = (1 4 6 4 1)\n...\n</code></pre> <p>Esta funci\u00f3n necesitar\u00e1 un par\u00e1metro adicional (<code>lista-fila</code>) que se inicializa con la lista <code>(1)</code> y en el que se va guardando cada fila sucesiva. Esta fila va creciendo hasta que llegamos a la fila que tenemos que devolver. Hay que hacer la iteraci\u00f3n <code>n</code> veces, por lo que vamos decrementando el par\u00e1metro <code>n</code> hasta que se llega a 0.</p> <p>Para implementar esta funci\u00f3n usamos otra llamada <code>(pascal-sig-fila lista-fila)</code> que recibe una fila del tri\u00e1ngulo y devuelve la siguiente. </p> <p>Por ejemplo:</p> <pre><code>(pascal-sig-fila '(1 3 3 1))\n; \u21d2 (1 4 6 4 1)\n</code></pre> <p>Esta funci\u00f3n la implementamos con una funci\u00f3n recursiva auxiliar (esta es recursiva pura) llamada <code>(pascal-suma-dos-a-dos lista-fila)</code> que es la que se encarga de realizar el c\u00e1lculo de la nueva fila. No es necesario convertir esta funci\u00f3n a iterativa porque no genera un coste exponencial.</p> <p>El c\u00f3digo completo es el siguiente:</p> <pre><code>(define (pascal fila col)\n   (list-ref (pascal-fila '(1) fila) col))\n\n(define (pascal-fila lista-fila n)\n   (if (= 0 n)\n      lista-fila\n      (pascal-fila (pascal-sig-fila lista-fila) (- n 1))))\n\n(define (pascal-sig-fila lista-fila)\n   (append '(1)\n           (pascal-suma-dos-a-dos lista-fila)\n           '(1)))\n\n(define (pascal-suma-dos-a-dos lista-fila)\n   (if (null? (rest lista-fila))\n      '()\n      (cons (+ (first lista-fila) (second lista-fila))\n            (pascal-suma-dos-a-dos (rest lista-fila)))))\n</code></pre> <p>Con esta implementaci\u00f3n ya no se tiene un coste exponencial y se puede calcular el valor de n\u00fameros como Pascal(40, 20):</p> <pre><code>(pascal 40 20)\n; \u21d2 137846528820\n</code></pre>"},{"location":"teoria/tema03-procedimientos-recursivos/tema03-procedimientos-recursivos.html#3-soluciones-al-coste-de-la-recursion-memoization","title":"3. Soluciones al coste de la recursi\u00f3n: memoization","text":"<p>Una alternativa que mantiene la elegancia de los procesos recursivos y la eficiencia de los iterativos es la memoization. Si miramos la traza de <code>(fib 4)</code> podemos ver que el coste est\u00e1 producido por la repetici\u00f3n de llamadas; por ejemplo <code>(fib 3)</code> se eval\u00faa 2 veces.</p> <p>En programaci\u00f3n funcional la llamada a <code>(fib 3)</code> siempre va a devolver el mismo valor.</p> <p>La idea de la memoization es guardar el valor devuelto por la cada llamada en alguna estructura (una lista de asociaci\u00f3n, por ejemplo) y no volver a realizar la llamada a la recursi\u00f3n las siguientes veces.</p>"},{"location":"teoria/tema03-procedimientos-recursivos/tema03-procedimientos-recursivos.html#31-fibonacci-con-memoization","title":"3.1. Fibonacci con memoization","text":"<p>Para implementar la memoization necesitamos usar un diccionario con los m\u00e9todos <code>put</code> y <code>get</code> que actualizan su informaci\u00f3n con mutaci\u00f3n.</p> <ul> <li>La funci\u00f3n <code>(make-dic)</code> devuelve un diccionario vac\u00edo.</li> <li>La funci\u00f3n <code>(put key value dic)</code> asocia un valor a una clave, la guarda en el diccionario (con mutaci\u00f3n) y devuelve el valor.</li> <li>La funci\u00f3n <code>(get key dic)</code> devuelve el valor del diccionario asociado a una clave (si no existe devuelve <code>#f</code>). </li> <li>El predicado <code>(key-exists? key dic)</code> devuelve <code>#f</code> en que no exista la clave y <code>#t</code> si existe.</li> </ul> <p>Ejemplos:</p> <pre><code>(define mi-dic (make-dic))\n(put 1 10 mi-dic) ; \u21d2 10\n(get 1 mi-dic) ; \u21d2 10\n(key-exists? 2 dic) ; \u21d2 #f\n</code></pre> <p>Estos m\u00e9todos son imperativos porque modifican (mutan) la estructura de datos que pasamos como par\u00e1metro (no pertenecen al paradigma funcional). La implementaci\u00f3n de estas funciones est\u00e1 incluidas en el fichero <code>lpp.rkt</code>.</p> <p>La funci\u00f3n <code>fib-memo</code> realiza el c\u00e1lculo de la serie de Fibonacci utilizando exactamente la misma definici\u00f3n recursiva original, pero a\u00f1adiendo la t\u00e9cnica de memoization: lo primero que hacemos para calcular el n\u00famero de fibonacci <code>n</code>, antes de llamar a la recursi\u00f3n, es comprobar si est\u00e1 ya guardado en la lista de asociaci\u00f3n. En el caso en que est\u00e9, lo devolvemos. S\u00f3lo cuando el n\u00famero no est\u00e1 calculado llamamos a la recursi\u00f3n para calcularlo.</p> <p>La implementaci\u00f3n se muestra a continuaci\u00f3n. Vemos que para devolver el n\u00famero de fibonacci <code>n</code> se comprueba si ya est\u00e1 guardado en la lista. S\u00f3lo en el caso en que no est\u00e9 guardado se llama a la recursi\u00f3n para calcularlo y guardarlo. La funci\u00f3n <code>put</code> que guarda el nuevo valor calculado tambi\u00e9n lo devuelve.</p> <pre><code>(define (fib-memo n dic)\n  (cond ((= n 0) 0)\n        ((= n 1) 1)\n        ((key-exists? n dic) (get n dic))\n        (else (put n (+ (fib-memo (- n 1) dic)\n                        (fib-memo (- n 2) dic)) dic))))\n</code></pre> <p>Podemos comprobar la diferencia de tiempos de ejecuci\u00f3n entre esta versi\u00f3n y la anterior. El coste de la funci\u00f3n memoizada es O(n). Frente al coste O(2^n) de la versi\u00f3n inicial que la hac\u00eda imposible de utilizar.</p> <pre><code>(fib-memo 200 lista)\n\u21d2 280571172992510140037611932413038677189525\n</code></pre>"},{"location":"teoria/tema03-procedimientos-recursivos/tema03-procedimientos-recursivos.html#4-figuras-recursivas","title":"4. Figuras recursivas","text":"<p>Vamos a terminar el apartado sobre procedimientos recursivos con un \u00faltimo ejemplo algo distinto de los vistos hasta ahora. Usaremos la recursi\u00f3n para dibujar figuras fractales usando la librer\u00eda de im\u00e1genes de Racket <code>2htdp/image</code>.</p>"},{"location":"teoria/tema03-procedimientos-recursivos/tema03-procedimientos-recursivos.html#41-libreria-de-imagenes-de-racket","title":"4.1. Librer\u00eda de im\u00e1genes de Racket","text":"<p>Racket incluye una librer\u00eda de im\u00e1genes en la que se proporcionan funciones para construir im\u00e1genes. Con esta librer\u00eda se pueden crear im\u00e1genes sencillas como rectas, c\u00edrculos, tri\u00e1ngulos u otras figuras geom\u00e9tricas. Tambi\u00e9n se pueden modificar las im\u00e1genes creadas, rot\u00e1ndolas o escal\u00e1ndolas, y formar otras im\u00e1genes mediante la combinaci\u00f3n de imagenes b\u00e1sicas.</p>"},{"location":"teoria/tema03-procedimientos-recursivos/tema03-procedimientos-recursivos.html#construccion-de-imagenes-basicas","title":"Construcci\u00f3n de im\u00e1genes b\u00e1sicas","text":"<p>Veamos algunos ejemplos de las primitivas de la librer\u00eda para construir im\u00e1genes b\u00e1sicas.</p> <p>Podemos obtener un c\u00edrculo, un cuadrado, un rect\u00e1ngulo y un tri\u00e1ngulo equil\u00e1tero de la siguiente forma:</p> <pre><code>#lang racket\n(require 2htdp/image)\n\n(circle 30 \"solid\" \"blue\")\n(square 30 \"outline\" \"black\")\n(rectangle 80 40 \"solid\" \"gray\")\n(triangle 40 \"solid\" \"red\")\n</code></pre> <p>Cada instrucci\u00f3n construye la imagen correspondiente. Si lo ejecutamos en el int\u00e9rprete obtendremos lo siguiente:</p> <p></p> <p>Las im\u00e1genes son mapas de bits y su tama\u00f1o se expresa en p\u00edxeles. En el caso del c\u00edrculo se trata del radio, para el cuadrado indicamos su lado, para el rect\u00e1ngulo la base y la altura y para el tri\u00e1ngulo equil\u00e1tero su lado.</p> <p>Debemos indicar tambi\u00e9n si queremos que la imagen se rellene de forma s\u00f3lida o se dibuje solo el borde. Y tambi\u00e9n su color, mediante una cadena escogida de una lista de colores permitidos.</p> <p>Podemos tambi\u00e9n construir un tri\u00e1ngulo is\u00f3sceles indicando la longitud de sus lados iguales y el \u00e1ngulo entre ellos:</p> <pre><code> (isosceles-triangle 60 30 \"outline\" \"black\") \n</code></pre> <p></p> <p>Por \u00faltimo, otra primitiva que vamos a utilizar m\u00e1s adelante es un trazo de una l\u00ednea:</p> <pre><code>(line 30 30 \"black\")\n</code></pre> <p></p> <p>Esta funci\u00f3n construye una imagen con una l\u00ednea hasta la posici\u00f3n (30,30) (la coordenada x crece hacia la derecha y la y hacia abajo).</p> <p>Prueba a construir algunas im\u00e1genes usando los comandos anteriores y cambiando sus par\u00e1metros.</p>"},{"location":"teoria/tema03-procedimientos-recursivos/tema03-procedimientos-recursivos.html#operaciones-y-combinaciones-de-imagenes","title":"Operaciones y combinaciones de im\u00e1genes","text":"<p>En la librer\u00eda de im\u00e1genes se definen tambi\u00e9n funciones que permiten transformar y combinar im\u00e1genes. Vamos a ver algunos de ellas.</p> <p>Podemos rotar una imagen un \u00e1ngulo, expresado en grados sexagesimales en el sentido contrario de las agujas del reloj.</p> <p>Por ejemplo, podemos rotar el tri\u00e1ngulo is\u00f3sceles anterior:</p> <pre><code>(define triangulo (isosceles-triangle 60 30 \"outline\" \"black\"))\n(rotate 90 triangulo) \n; \u21d2 imagen rotada 90 grados en sentido contrario a las agujas del reloj\n(rotate -90 triangulo)\n; \u21d2 imagen rotada 90 grados en sentido de las agujas del reloj\n</code></pre> <p></p> <p>Podemos tambi\u00e9n combinar im\u00e1genes, agrup\u00e1ndolas con las funciones <code>above</code> y <code>beside</code>. Las dos funciones reciben un n\u00famero variable de argumentos y devuelven una nueva imagen en la que las im\u00e1genes se han colocado unas sobre otras o unas al lado de otras.</p> <p>Por ejemplo:</p> <pre><code>(above (ellipse 70 20 \"solid\" \"gray\")\n       (ellipse 50 20 \"solid\" \"darkgray\")\n       (ellipse 30 20 \"solid\" \"dimgray\")\n       (ellipse 10 20 \"solid\" \"black\"))\n</code></pre> <p>La llamada anterior devuelve la siguiente imagen:</p> <p></p> <p>Otro ejemplo:</p> <pre><code>(beside (ellipse 20 70 \"solid\" \"gray\")\n        (ellipse 20 50 \"solid\" \"darkgray\")\n        (ellipse 20 30 \"solid\" \"dimgray\")\n        (ellipse 20 10 \"solid\" \"black\"))\n</code></pre> <p>Que produce:</p> <p></p> <p>En los dos ejemplos anteriores las im\u00e1genes agrupadas se alinean en el centro. Si queremos otra alineaci\u00f3n podemos especificarla usando las funciones <code>above/align</code> y <code>beside/align</code>. </p> <p>En el caso de <code>above</code>, que acumula las im\u00e1genes unas sobre otras, podremos especificar si queremos alinearlas a la izquierda o a la derecha:</p> <pre><code>(above/align \"left\"\n               (ellipse 70 20 \"solid\" \"yellowgreen\")\n               (ellipse 50 20 \"solid\" \"olivedrab\")\n               (ellipse 30 20 \"solid\" \"darkolivegreen\")\n               (ellipse 10 20 \"solid\" \"darkgreen\"))\n</code></pre> <p></p> <pre><code>(above/align \"right\"\n               (ellipse 70 20 \"solid\" \"gold\")\n               (ellipse 50 20 \"solid\" \"goldenrod\")\n               (ellipse 30 20 \"solid\" \"darkgoldenrod\")\n               (ellipse 10 20 \"solid\" \"sienna\"))\n</code></pre> <p></p> <p>En el caso de <code>beside</code>, que acumula las im\u00e1genes unas junto a otras, podemos especificar si queremos alinearla arriba o abajo:</p> <pre><code>(beside/align \"top\"\n                (ellipse 20 70 \"solid\" \"mediumorchid\")\n                (ellipse 20 50 \"solid\" \"darkorchid\")\n                (ellipse 20 30 \"solid\" \"purple\")\n                (ellipse 20 10 \"solid\" \"indigo\"))\n</code></pre> <p></p> <pre><code>(beside/align \"bottom\"\n                (ellipse 20 70 \"solid\" \"lightsteelblue\")\n                (ellipse 20 50 \"solid\" \"mediumslateblue\")\n                (ellipse 20 30 \"solid\" \"slateblue\")\n                (ellipse 20 10 \"solid\" \"navy\"))\n</code></pre> <p></p> <p>Podemos combinar todas las funciones anteriores para construir figuras complejas. Por ejemplo:</p> <pre><code>(rotate 45\n        (above (triangle 40 \"solid\" \"orange\")\n               (beside (rectangle 40 30 \"solid\" \"black\")\n                       (rectangle 40 30 \"solid\" \"olivedrab\"))))\n</code></pre> <p></p> <p>Prueba a realizar algunas figuras combinando figuras b\u00e1sicas con las funciones anteriores.</p>"},{"location":"teoria/tema03-procedimientos-recursivos/tema03-procedimientos-recursivos.html#42-triangulo-de-sierpinski","title":"4.2. Tri\u00e1ngulo de Sierpinski","text":"<p>Vamos a utilizar las funciones anteriores que construyen im\u00e1genes para construir una figura fractal, el denominado ri\u00e1ngulo de Sierpinski, usando la recursi\u00f3n.</p> <p></p> <p>Tri\u00e1ngulo de Sierpinski</p> <ul> <li>\u00bfVes alguna recursi\u00f3n en la figura?</li> <li>\u00bfCu\u00e1l podr\u00eda ser el par\u00e1metro de la funci\u00f3n que la dibujara? </li> <li>\u00bfSe te ocurre un algoritmo recursivo que la dibuje, usando las   funciones de combinaci\u00f3n de im\u00e1genes vistas?</li> </ul> <p>La figura es autosimilar (una caracter\u00edstica de las figuras fractales). Una parte de la figura es id\u00e9ntica a la figura total, pero reducida de escala. Esto nos da una pista de que es posible dibujar la figura con un algoritmo recursivo.</p> <p>Para intentar encontrar una forma de enfocar el problema, vamos a pensarlo de la siguiente forma: supongamos que tenemos tres tri\u00e1ngulos de Sierpinski de anchura x. \u00bfC\u00f3mo podr\u00edamos construir el tri\u00e1ngulo de Sierpinski de anchura 2*x?</p> <p>Lo podr\u00edamos hacer combinando las tres im\u00e1genes de la siguiente forma:</p> <ol> <li>Juntamos 2 tri\u00e1ngulos uno junto a otro.</li> <li>Sobre la figura resultante colocamos (alineada en el centro) el    tri\u00e1ngulo restante.</li> </ol> <p>En la siguiente figura se muestra el esquema de esta combinaci\u00f3n. Cada rect\u00e1ngulo representa la imagen de sierpinski de anchura x y la combinaci\u00f3n representa la imagen de anchura 2*x.</p> <p></p> <p>El algoritmo recursivo se basa en la misma idea, pero hacia atr\u00e1s. Dibujamos un tri\u00e1ngulo de anchura x bas\u00e1ndonos en 3 llamadas recursivas a tri\u00e1ngulos m\u00e1s peque\u00f1os (de anchura x/2).</p> <p>En el caso base, cuando x sea menor que un umbral h, dibujaremos un tri\u00e1ngulo elemental de base h.</p> <p>Veamos c\u00f3mo hacerlo con la librer\u00eda de im\u00e1genes de Racket.</p>"},{"location":"teoria/tema03-procedimientos-recursivos/tema03-procedimientos-recursivos.html#421-caso-base-de-la-recursion","title":"4.2.1. Caso base de la recursi\u00f3n","text":"<p>Para construir la imagen elemental del tri\u00e1ngulo de Sierpinski necesitamos un tri\u00e1ngulo is\u00f3sceles de \u00e1ngulo 90 y base h. </p> <p>Tal y como muestra la siguiente figura, podemos dividir este tri\u00e1ngulo en dos mitades. Si el \u00e1ngulo superior es 90 grados, su mitad ser\u00e1 de 45 grados, por lo que los dos subtri\u00e1ngulos ser\u00e1n tri\u00e1ngulos rect\u00e1ngulos cuyos catetos medir\u00e1n h/2. La hipotenusa de esos tri\u00e1ngulos son los lados del tri\u00e1ngulo is\u00f3sceles original. La altura del tri\u00e1ngulo is\u00f3sceles original ser\u00e1 tambi\u00e9n h/2.</p> <p></p> <p>La hipotenusa de un tri\u00e1ngulo rect\u00e1ngulo con dos catetos de longitud x se calcula con la siguiente expresi\u00f3n:</p> hipot(x) = \\sqrt{x^2+x^2} = x \\sqrt{2} <p>Lo podemos expresar en Racket:</p> <pre><code>(define (hipotenusa x)\n  (* x (sqrt 2)))\n</code></pre> <p>Una vez definida la funci\u00f3n <code>hipotenusa</code> podemos dibujar el tri\u00e1ngulo de Sierpinski elemental de base <code>h</code>. Ser\u00e1 un tri\u00e1ngulo is\u00f3sceles de \u00e1ngulo 90 grados y de longitud de lado <code>hipotenusa(h/2)</code>:</p> <pre><code>(define (sierpinski-elem base)\n  (isosceles-triangle (hipotenusa (/ base 2)) 90 \"outline\" \"black\"))\n</code></pre> <p>Por ejemplo, la llamada a </p> <pre><code>(sierpinski-elem 40)\n</code></pre> <p>produce la siguiente imagen:</p> <p></p>"},{"location":"teoria/tema03-procedimientos-recursivos/tema03-procedimientos-recursivos.html#422-caso-general-de-la-recursion","title":"4.2.2. Caso general de la recursi\u00f3n","text":"<p>El caso general de la recursi\u00f3n para dibujar el tri\u00e1ngulo de Sierpinski de ancho x se construye llamando a la recursi\u00f3n para que construya el tri\u00e1ngulo de ancho x/2 y componiendo la imagen resultante con el patr\u00f3n visto anteriormente.</p> <p>El c\u00f3digo de la funci\u00f3n completa es el siguiente:</p> <pre><code>(define (sierpinski ancho)\n  (if (&lt; ancho 10)\n      (sierpinski-elem ancho)\n      (above (sierpinski (/ ancho 2))\n             (beside (sierpinski (/ ancho 2))\n                     (sierpinski (/ ancho 2))))))\n</code></pre> <ul> <li>Si el ancho es menor que un umbral (10) se dibuja el tri\u00e1ngulo elemental.</li> <li>Si el ancho es mayor o igual a 10 se hacen tres llamadas recursivas a   <code>sierpienski</code> con el ancho / 2. Cada llamada recursiva devolver\u00e1   la imagen con el tri\u00e1ngulo de sierpinski m\u00e1s peque\u00f1o.</li> <li>La llamada a <code>beside</code> juntar\u00e1 las dos im\u00e1genes inferiores.</li> <li>La llamada a <code>above</code> colocar\u00e1 el tercer tri\u00e1ngulo sobre la composici\u00f3n   anterior, centrado en el centro.</li> </ul> <p>Un ejemplo de la ejecuci\u00f3n:</p> <p></p> <p>El c\u00f3digo anterior no es nada eficiente porque cada llamada recursiva genera a su vez otras 3 llamadas, provocando un coste exponencial como hemos visto al comienzo del tema.</p> <p>En este caso es muy sencillo eliminar las tres llamadas porque las tres son llamadas repetidas que van a devolver exactamente la misma figura. Podemos entonces usar la t\u00e9cnica que ya hemos usado otras veces de llamar a una funci\u00f3n auxiliar con el resultado de la recursi\u00f3n. Esta funci\u00f3n auxiliar recoger\u00e1 en su par\u00e1metro el valor devuelto por la recursi\u00f3n y realizar\u00e1 con ese valor las operaciones necesarias.</p> <p>En este caso, el valor obtenido por la recursi\u00f3n es la figura de Serpienski m\u00e1s peque\u00f1a. La funci\u00f3n auxiliar recibir\u00e1 entonces esa figura y deber\u00e1 combinarla tres veces para formar la figura de Sierpinski mayor.</p> <p>El c\u00f3digo resultante es el siguiente:</p> <pre><code>(define (componer-sierpinski figura)\n    (above figura\n           (beside figura figura)))\n\n(define (sierpinski ancho)\n  (if (&lt; ancho 10)\n      (sierpinski-elem ancho)\n      (componer-sierpinski (sierpinski (/ ancho 2)))))\n</code></pre>"},{"location":"teoria/tema03-procedimientos-recursivos/tema03-procedimientos-recursivos.html#43-curva-de-hilbert","title":"4.3. Curva de Hilbert","text":"<p>La curva de Hilbert es una curva fractal que tiene la propiedad de rellenar completamente el plano.</p> <p></p> <p>Su dibujo tiene una formulaci\u00f3n recursiva:</p> <p></p> <p>La imagen H2 se puede componer a partir de cuatro im\u00e1genes H1 siguiendo un patr\u00f3n. Es el mismo patr\u00f3n con el que se puede componer la imagen H3 a partir de cuatro im\u00e1genes H2.</p> <p>El patr\u00f3n se muestra en la siguiente funci\u00f3n <code>(componer-hilbert imagen)</code>: </p> <pre><code>(define (trazo-horizontal long)\n  (line long 0 \"black\"))\n\n(define (trazo-vertical long)\n  (rotate 90 (trazo-horizontal long)))\n\n(define (componer-hilbert imagen long-trazo)\n  (beside (above/align \"left\"\n                       (beside/align \"bottom\" imagen (trazo-horizontal long-trazo))\n                       (trazo-vertical long-trazo)\n                       (rotate -90 imagen))\n          (above/align \"right\"\n                       imagen\n                       (trazo-vertical long-trazo)\n                       (rotate 90 imagen))))\n</code></pre> <ul> <li>La primera llamada a <code>above/align</code> compone una imagen juntando la   imagen original con un trazo horizontal y apilando (con una   alineaci\u00f3n a la izquierda) esta imagen sobre un trazo vertical   y sobre la imagen original girada 90 grados en el sentido de   las agujas del reloj.</li> <li>La segunda llamada a <code>above/align</code> construye otra imagen apilando   (con una alineaci\u00f3n a la derecha) la imagen original, un trazo   vertical y la imagen rotada 90 grados en sentido contrario a las   agujas del reloj.</li> <li>Por \u00faltimo la llamada a <code>beside</code> junta las dos im\u00e1genes anteriores.</li> </ul> <p>Podemos ver un ejemplo del funcionamiento de esta composici\u00f3n usando una imagen base formada por un cuadrado con un tri\u00e1ngulo dentro.</p> <pre><code>(overlay (triangle 20 \"solid\" \"green\")\n         (rectangle 20 20 \"solid\" \"black\")))\n</code></pre> <p></p> <p>Si llamamos a <code>componer-hilbert</code> con la imagen anterior, usando una longitud de trazo de 16 p\u00edxeles, podemos ver que se construye el patr\u00f3n b\u00e1sico de la curva de Hilbert, el que construye la imagen H2 a partir de H1.</p> <pre><code>(define imagen (overlay (triangle 20 \"solid\" \"green\")\n                        (rectangle 20 20 \"solid\" \"black\")))\nimagen \n(componer-hilbert imagen 16)\n</code></pre> <p></p> <p>Una vez entendido este patr\u00f3n de composici\u00f3n, podemos ya formular el algoritmo recursivo:</p> <pre><code>(define (hilbert nivel long-trazo)\n  (if (= 1 nivel)\n      (beside/align \"top\"\n                    (trazo-vertical long-trazo)\n                    (trazo-horizontal long-trazo)\n                    (trazo-vertical long-trazo))\n      (componer-hilbert (hilbert (- nivel 1) long-trazo) long-trazo)))\n</code></pre> <ul> <li>El caso base es el nivel 1, en el que se construye el trazo b\u00e1sico   de la curva de Hilbert con la longitud de trazo que se pasa como   par\u00e1metro.</li> <li>Para cualquier nivel n  mayor que 1, se llama a la recursi\u00f3n para   formar la curva de Hilbert de nivel n-1 y, con la imagen   resultante, se llama a la funci\u00f3n <code>componer-hilbert</code>.</li> </ul> <p>En la siguiente imagen se muestran distintas llamadas a la funci\u00f3n <code>hilbert</code>:</p> <p></p>"},{"location":"teoria/tema03-procedimientos-recursivos/tema03-procedimientos-recursivos.html#5-bibliografia","title":"5. Bibliograf\u00eda","text":"<p>Cap\u00edtulos del libro Structure and Intepretation of Computer Programs:</p> <ul> <li>1.2 - Procedures and the Processes They Generate</li> <li>1.2.1 - Linear Recursion and Iteration</li> <li>1.2.2 - Tree Recursion</li> </ul> <p>Manual de Racket:</p> <ul> <li>Librer\u00eda   image.rkt</li> <li>Image Guide</li> </ul> <p>Lenguajes y Paradigmas de Programaci\u00f3n, curso 2024-25 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Domingo Gallardo, Cristina Pomares, Antonio Bot\u00eda, Francisco Mart\u00ednez</p>"},{"location":"teoria/tema04-estructuras-recursivas/tema04-estructuras-recursivas.html","title":"Tema 4: Estructuras de datos recursivas","text":""},{"location":"teoria/tema04-estructuras-recursivas/tema04-estructuras-recursivas.html#1-listas-estructuradas","title":"1. Listas estructuradas","text":"<p>Hemos visto que las listas en Scheme se implementan como un estructura de datos recursiva, formada por una pareja que enlaza en su parte derecha el resto de la lista y que termina con una parte derecha en la que hay una lista vac\u00eda.</p> <p>En este apartado vamos a volver a estudiar las listas desde un nivel de abstracci\u00f3n alto, usando las funciones:</p> <ul> <li><code>(first lista)</code> para obtener el primer elemento de una lista</li> <li><code>(rest lista)</code> para obtener el resto de la lista</li> <li><code>(cons dato lista)</code> para construir una nueva lista con el dato como   primer elemento</li> </ul> <p>En la mayor\u00eda de funciones y ejemplos que hemos visto hasta ahora las listas est\u00e1n formadas por datos y el recorrido por la lista es un recorrido lineal, iterando por sus elementos.</p> <p>En este apartado vamos a ampliar este concepto y estudiar c\u00f3mo trabajar con listas que contienen otras listas.</p> <p>Veremos que esto cambia fundamentalmente la estructura de las listas y de las funciones que van a operar con ellas. El cambio fundamental es que la funci\u00f3n <code>first lista</code> puede devolver dos tipos de elementos: </p> <ul> <li>Un elemento de la lista (del tipo de elementos que hay en la lista)</li> <li>Otra lista (formada por el tipo de elementos de la lista)</li> </ul>"},{"location":"teoria/tema04-estructuras-recursivas/tema04-estructuras-recursivas.html#11-definicion-y-ejemplos","title":"1.1. Definici\u00f3n y ejemplos","text":"<p>Las listas en Scheme pueden tener cualquier tipo de elementos, incluido otras listas.</p> <p>Llamaremos lista estructurada a una lista que contiene otras sublistas. Lo contrario de lista estructurada es una lista plana, una lista formada por elementos que no son listas. Llamaremos hojas a los elementos de una lista que no son sublistas.</p> <p>A las listas estructuradas cuyas hojas son s\u00edmbolos se les denomina en el contexto de la programaci\u00f3n funcional expresiones-S (S-expression).</p> <p>Por ejemplo, la lista estructurada:</p> <pre><code>(a b (c d e) (f (g h)))\n</code></pre> <p>es una lista estructurada con 4 elementos:</p> <ul> <li>El elemento <code>'a</code>, una hoja</li> <li>El elemento <code>'b</code>, otra hoja</li> <li>La lista plana <code>(c d e)</code></li> <li>La lista estructurada <code>(f (g h))</code></li> </ul> <p>Se puede construir con cualquiera de las siguientes expresiones:</p> <pre><code>(define lista (list 'a 'b (list 'c 'd 'e) (list 'f (list 'g 'h))))\n(define lista '(a b (c d e) (f (g h))))\n</code></pre> <p>Una lista formada por parejas la consideraremos una lista plana, ya que no contiene ninguna sublista. Por ejemplo, la lista</p> <pre><code>((a . 3) (b . 5) (c . 12))\n</code></pre> <p>es una lista plana de tres elementos (hojas) que son parejas.</p>"},{"location":"teoria/tema04-estructuras-recursivas/tema04-estructuras-recursivas.html#111-definiciones-en-scheme","title":"1.1.1. Definiciones en Scheme","text":"<p>Vamos a escribir las definiciones anteriores de <code>hoja</code>, <code>plana</code> y <code>estructurada</code> usando c\u00f3digo de Scheme.</p>"},{"location":"teoria/tema04-estructuras-recursivas/tema04-estructuras-recursivas.html#1111-funcion-hoja-dato","title":"1.1.1.1. Funci\u00f3n <code>(hoja? dato)</code>","text":"<p>Definimos una hoja como aquellos elementos de una lista estructurada que no son listas:</p> <pre><code>(define (hoja? elem)\n   (not (list? elem)))\n</code></pre> <p>Utilizaremos esta funci\u00f3n para comprobar si un determinado elemento de una lista es o no una hoja. Por ejemplo, supongamos la siguiente lista:</p> <pre><code>((1 2) 3 4 (5 6))\n</code></pre> <p>Es una lista de 4 elementos, siendo el primero y el \u00faltimo otras sublistas y el segundo y el tercero hojas. Podemos comprobar si son o no hojas sus elementos:</p> <pre><code>(define lista '((1 2) 3 4 (5 6)))\n(hoja? (first lista)) ; \u21d2 #f\n(hoja? (second lista)) ; \u21d2 #t\n(hoja? (third lista)) ; \u21d2 #t\n(hoja? (fourth lista)) ; \u21d2 #f\n</code></pre> <p>La lista vac\u00eda no es una hoja</p> <pre><code>(hoja? '()) ; \u21d2 #f\n</code></pre>"},{"location":"teoria/tema04-estructuras-recursivas/tema04-estructuras-recursivas.html#1112-funcion-plana-lista","title":"1.1.1.2. Funci\u00f3n <code>(plana? lista)</code>","text":"<p>Como hemos dicho antes, una lista es plana cuando todos sus elementos son hojas. Queremos implementar la funci\u00f3n <code>(plana? lista)</code> que lo compruebe.</p> <p>Por ejemplo:</p> <pre><code>(plana? '(a b c d e f)) ; \u21d2 #t\n(plana? (list (cons 'a 1) \"Hola\" #f)) ; \u21d2 #t\n(plana? '(a (b c) d)) ; \u21d2 #f\n(plana? '(a () b)) ; \u21d2 #f\n</code></pre> <p>Una definici\u00f3n recursiva de lista plana:</p> <p>Una lista es plana si y solo si el primer elemento es una hoja y el resto es plana.</p> <p>Y el caso base:</p> <p>Una lista vac\u00eda es plana.</p> <p>Usando esta definici\u00f3n recursiva, podemos implementar en Scheme la funci\u00f3n <code>(plana? lista)</code> que comprueba si una lista es plana:</p> <pre><code>(define (plana? lista)\n   (or (null? lista)\n       (and (hoja? (first lista))\n            (plana? (rest lista)))))\n</code></pre> <p>Se podr\u00eda tambi\u00e9n implementar la funci\u00f3n <code>plana?</code> usando la funci\u00f3n de orden superior <code>for-all?</code> que comprueba que todos los elementos de una lista cumplen una propiedad. En esta caso, ser hoja.</p> <pre><code>(define (plana-fos? lista)\n  (for-all? hoja? lista))\n</code></pre> <p>Funci\u00f3n <code>for-all?</code></p> <p>Recordemos que la funci\u00f3n <code>(for-all? predicado lista)</code> se implementa de la siguiente forma:</p> <pre><code>(define (for-all? predicado lista)\n  (or (null? lista)\n      (and (predicado (first lista))\n           (for-all? predicado (rest lista)))))\n</code></pre>"},{"location":"teoria/tema04-estructuras-recursivas/tema04-estructuras-recursivas.html#1113-funcion-estructurada-lista","title":"1.1.1.3. Funci\u00f3n <code>(estructurada? lista)</code>","text":"<p>Una lista es estructurada cuando alguno de sus elementos es otra lista. Como caso base, una lista vac\u00eda no es estructurada.</p> <p>Queremos implementar la funci\u00f3n <code>(estructurada? lista)</code> que compruebe si una lista es estructurada.</p> <pre><code>(estructurada? '(1 2 3 4)) ; \u21d2 #f\n(estructurada? (list (cons 'a 1) (cons 'b 2) (cons 'c 3))) ; \u21d2 #f\n(estructurada? '(a () b)) ; \u21d2 #t\n(estructurada? '(a (b c) d)) ; \u21d2 #t\n</code></pre> <pre><code>(define (estructurada? lista)\n   (and (not (null? lista))\n        (or (list? (first lista))\n            (estructurada? (rest lista)))))\n</code></pre> <p>Se podr\u00eda implementar tambi\u00e9n usando la funci\u00f3n de orden superior <code>exists?</code> para consultar si alg\u00fan elemento de la lista es tambi\u00e9n otra lista.</p> <pre><code>(define (estructurada-fos? lista)\n  (exists? list? lista))\n</code></pre> <p>Funci\u00f3n <code>exists?</code></p> <p>Recordemos que la funci\u00f3n <code>(exists? predicado lista)</code> se implementa de la siguiente forma:</p> <pre><code>(define (exists? predicado lista)\n  (if (null? lista)\n      #f\n      (or (predicado (first lista))\n          (exists? predicado (rest lista)))))\n</code></pre> <p>Realmente bastar\u00eda con haber hecho una de las dos definiciones y escribir la otra como la negaci\u00f3n de la primera:</p> <pre><code>(define (estructurada? lista)\n   (not (plana? lista)))\n</code></pre>"},{"location":"teoria/tema04-estructuras-recursivas/tema04-estructuras-recursivas.html#112-ejemplos-de-listas-estructuradas","title":"1.1.2. Ejemplos de listas estructuradas","text":"<p>Las listas estructuradas son muy \u00fatiles para representar informaci\u00f3n jer\u00e1rquica en donde queremos representar elementos que contienen otros elementos.</p> <p>Por ejemplo, las expresiones de Scheme son listas estructuradas:</p> <pre><code>(= 4 (+ 2 2))\n(if (= x y) (* x y) (+ (/ x y) 45))\n(define (factorial x) (if (= x 0) 1 (* x (factorial (- x 1)))))\n</code></pre> <p>El an\u00e1lisis sint\u00e1ctico de una oraci\u00f3n puede generar una lista estructurada de s\u00edmbolos, en donde se agrupan los distintos elementos de la oraci\u00f3n:</p> <pre><code>((Juan) (compr\u00f3) (la entrada (de la pel\u00edcula)) (el viernes por la tarde))\n</code></pre> <p>Una p\u00e1gina HTML, con sus distintos elementos, unos dentro de otros, tambi\u00e9n se puede representar con una lista estructurada:</p> <pre><code>((&lt;h1&gt; Mi lista de la compra &lt;/h1&gt;)\n (&lt;ul&gt; (&lt;li&gt; naranjas &lt;/li&gt;)\n       (&lt;li&gt; tomates &lt;/li&gt;)\n       (&lt;li&gt; huevos &lt;/li&gt;) &lt;/ul&gt;))\n</code></pre>"},{"location":"teoria/tema04-estructuras-recursivas/tema04-estructuras-recursivas.html#113-pseudo-arboles-con-niveles","title":"1.1.3. Pseudo \u00e1rboles con niveles","text":"<p>Las listas estructuradas definen una estructura de niveles, donde la lista inicial representa el primer nivel, y cada sublista representa un nivel inferior. Los datos de las listas representan las hojas.</p> <p>Por ejemplo, la representaci\u00f3n en forma de niveles de la lista <code>((a b c) d e)</code> es la siguiente:</p> <p></p> <p>Cada asterisco <code>*</code> representa una lista. Las ramas que salen del asterisco representan los elementos de la lista. En el ejemplo tenemos en un primer nivel una lista con 3 elementos: la lista <code>(a b c)</code>, <code>d</code> y <code>e</code>. Y en el segundo nivel se encuentra la lista <code>(a b c)</code> cuyos 3 elementos son hojas.</p> <p>Las hojas <code>d</code> y <code>e</code> est\u00e1n en el nivel 1 y en las posiciones 2 y 3 de la lista y las hojas <code>a</code>, <code>b</code> y <code>c</code> en el nivel 2.</p> <p>Una lista estructurada no es un \u00e1rbol</p> <p>Una lista estructurada no es un \u00e1rbol propiamente dicho, porque un \u00e1rbol tiene datos en todos los nodos, mientras que en la lista  estructurada los datos est\u00e1n s\u00f3lo en las hojas.</p> <p>Las listas estructuradas sirven para agrupar de forma jer\u00e1rquica un conjunto de datos en distintos niveles. </p> <p>A pesar de ser distintas de los \u00e1rboles, ambas son estructuras de datos jer\u00e1rquicas (con niveles) que se pueden definir de forma recursiva y sobre las que se pueden definir algoritmos recursivos. Veremos m\u00e1s adelante c\u00f3mo definir y trabajar con \u00e1rboles en Scheme.</p> <p>Otro ejemplo. \u00bfCu\u00e1l ser\u00eda la representaci\u00f3n en niveles de la siguiente lista estructurada?:</p> <pre><code>(map (lambda (x) (+ x 10)) (quote (1 2 3 4)))\n</code></pre> <p></p>"},{"location":"teoria/tema04-estructuras-recursivas/tema04-estructuras-recursivas.html#12-funciones-recursivas-sobre-listas-estructuradas","title":"1.2. Funciones recursivas sobre listas estructuradas","text":""},{"location":"teoria/tema04-estructuras-recursivas/tema04-estructuras-recursivas.html#121-numero-de-hojas","title":"1.2.1. N\u00famero de hojas","text":"<p>Veamos como primer ejemplo la funci\u00f3n <code>(num-hojas lista)</code> que cuenta el n\u00famero de hojas de una lista estructurada.</p> <p>Por ejemplo:</p> <pre><code>(num-hojas '((1 2) (3 4 (5) 6) (7))) ; \u21d2 7\n</code></pre> <p>Como hemos comentado antes, una cuesti\u00f3n clave en las funciones que vamos a construir sobre listas estructuradas es que el <code>first</code> de una lista estructurada puede ser a su vez otra lista.</p> <p>Para calcular el n\u00famero de hojas de una lista podemos obtener el primer elemento y el resto de la lista, y contar recursivamente el n\u00famero de hojas del primer elemento y del resto. Al ser una lista estructurada, el primer elemento puede ser a su vez otra lista, por lo que llamamos a la recursi\u00f3n para contar sus hojas.</p> <p>La definici\u00f3n de este caso general usando pseudoc\u00f3digo es:</p> <p>El n\u00famero de hojas de una lista estructurada es la suma del n\u00famero de hojas de su primer elemento (que puede ser otra lista) y del n\u00famero de hojas del resto.</p> <p></p> <p>La recursi\u00f3n tiene dos llamadas recursivas. Una que recibe el elemento de la cabeza de la lista y otra que recibe el resto de la lista. </p> <pre><code>;Caso general num-hojas\n(define (num-hojas lisdat)\n  ; Falta caso base\n  (+ (num-hojas (first lisdat))\n     (num-hojas (rest lisdat))))\n</code></pre> <p>No hay coste exponencial</p> <p>A pesar de haber dos llamadas recursivas, no pasa lo mismo que en Fibonacci o Pascal ya que no se van a repetir llamadas a la recursi\u00f3n con los mismos datos. La recursi\u00f3n recorre la lista estructurada y su coste ser\u00e1 el n\u00famero de elementos de la lista.</p> <p>Para considerar el caso base, veamos c\u00f3mo las llamadas recursivas reciben cada vez un problema m\u00e1s peque\u00f1o. </p> <p>La llamada recursiva sobre el resto de la lista recibe cada vez una lista con 1 elemento menos. Al final se llamar\u00e1 a la funci\u00f3n con una lista vac\u00eda. Ese ser\u00e1 un caso base. El n\u00famero de elementos de una lista vac\u00eda es 0.</p> <p>La llamada recursiva sobre la cabeza de la lista es algo distinta. Recibe una lista en la que se ha descendido un nivel y tiene, por tanto, un nivel menos. Al final se llamar\u00e1 a la funci\u00f3n con una hoja (un dato). Ese ser\u00e1 el otro caso base y habr\u00e1 que devolver 1.</p> <p>La definici\u00f3n completa de la funci\u00f3n queda de la siguiente forma:</p> <pre><code>(define (num-hojas lisdat)\n   (cond\n      ((null? lisdat) 0)\n      ((hoja? lisdat) 1)\n      (else (+ (num-hojas (first lisdat))\n               (num-hojas (rest lisdat))))))\n</code></pre> <p>Importante</p> <p>Hay que hacer notar que el par\u00e1metro <code>lisdat</code> puede ser tanto una lista como un dato at\u00f3mico. En ese caso la funci\u00f3n <code>(hoja? lisdat)</code> devuelve <code>#t</code>.</p> <p>En lenguajes de programaci\u00f3n fuertemente tipados esto no ser\u00eda posible, porque la lista y el dato ser\u00edan de distinto tipo. En ese caso el c\u00f3digo deber\u00eda ser un poco m\u00e1s largo y antes de llamar a la recursi\u00f3n habr\u00eda que comprobar si el elemento es un dato o es otra lista. En el caso de Scheme, podemos aprovecharnos de su caracter\u00edstica de ser d\u00e9bilmente tipado y podemos hacer el c\u00f3digo m\u00e1s conciso, llamando siempre a la recursi\u00f3n con el <code>first</code> de la lista, independientemente de si es un dato u otra lista.</p> <p>El c\u00f3digo de la  versi\u00f3n en la que comprobamos si el elemento es una lista antes de llamar a la recursi\u00f3n ser\u00eda el siguiente:</p> <pre><code>(define (num-hojas lista)\n    (cond\n        ((null? lista) 0)\n        ((hoja? (first lista))\n            (+ 1 (num-hojas (rest lista))))\n        (else (+ (num-hojas (first lista))\n                 (num-hojas (rest lista))))))\n</code></pre>"},{"location":"teoria/tema04-estructuras-recursivas/tema04-estructuras-recursivas.html#1211-version-con-funciones-de-orden-superior","title":"1.2.1.1. Versi\u00f3n con funciones de orden superior","text":"<p>Podemos usar tambi\u00e9n las funciones de orden superior <code>map</code> y <code>foldr</code> para obtener una versi\u00f3n m\u00e1s concisa.</p> <p>Una lista estructurada tiene como elementos en un primer nivel hojas o otras sublistas. Podemos entonces mapear una expresi\u00f3n lambda que se aplica a cada uno de esos elementos. En la expresi\u00f3n lambda comprobamos si el elemento (el par\u00e1metro <code>sublista</code> de la expresi\u00f3n lambda) es una hoja o una lista. En el primero caso devolvemos 1. En el segundo aplicaremos la propia funci\u00f3n que estamos definiendo sobre la sublista, con lo que se devolver\u00e1 el n\u00famero de hojas de esa sublista.</p> <p>El resultado del map ser\u00e1 una lista de n\u00fameros (el n\u00famero de hojas de cada componente), que podemos sumar haciendo un <code>foldr</code> con la funci\u00f3n <code>+</code>:</p> <pre><code>(define (num-hojas-fos ld)\n    (if (hoja? ld)\n        1\n        (foldr + 0 (map num-hojas-fos ld))))\n</code></pre> <p>Una explicaci\u00f3n gr\u00e1fica de c\u00f3mo funciona la funci\u00f3n sobre la lista <code>(1 (2 3) (4) (5 (6 7) 8))</code>:</p> <p></p> <p>Ser\u00eda equivalente hacer un <code>apply</code> de la suma para sumar los n\u00fameros de la lista devuelta por el <code>map</code>:</p> <pre><code>(define (num-hojas-fos ld)\n    (if (hoja? ld)\n        1\n        (apply + (map num-hojas-fos ld))))\n</code></pre> <p>Nota</p> <p>Es interesante conocer ambas expresiones (la del <code>foldr</code> y la del <code>apply</code>) porque hay lenguajes de programaci\u00f3n en los que la funci\u00f3n <code>apply</code> no est\u00e1 definida. Por ejemplo, Swift.</p>"},{"location":"teoria/tema04-estructuras-recursivas/tema04-estructuras-recursivas.html#122-aplanar-lista","title":"1.2.2. Aplanar lista","text":"<p>Veamos otro ejemplo. La funci\u00f3n <code>(aplana lista)</code> que devuelve una lista plana con todas las hojas de la lista. </p> <p>Por ejemplo:</p> <pre><code>(aplana '(1 2 (3 (4 (5))) (((6)))))\n; \u21d2 (1 2 3 4 5 6)\n</code></pre> <p>La soluci\u00f3n recursiva es:</p> <pre><code>(define (aplana ld)\n  (cond\n    ((null? ld) '())\n    ((hoja? ld) (list ld))\n    (else \n     (append (aplana (first ld))\n             (aplana (rest ld))))))\n</code></pre> <p>Con funciones de orden superior:</p> <pre><code>(define (aplana-fos ld)\n  (if (hoja? ld)\n    (list ld)\n    (foldr append '() (map aplana-fos ld))))\n</code></pre> <p>Usando <code>apply</code>:</p> <pre><code>(define (aplana-fos ld)\n  (if (hoja? ld)\n    (list ld)\n    (apply append (map aplana-fos ld))))\n</code></pre>"},{"location":"teoria/tema04-estructuras-recursivas/tema04-estructuras-recursivas.html#123-otras-funciones-recursivas","title":"1.2.3. Otras funciones recursivas","text":"<p>Vamos a dise\u00f1ar otras funciones recursivas que trabajan con la estructura jer\u00e1rquica de las listas estructuradas.</p> <ul> <li><code>(pertenece-estruct? dato lista)</code>: busca una hoja en una lista   estructurada.</li> <li><code>(cuadrado-estruct lista)</code>: eleva todas las hojas al cuadrado   (suponemos que la lista estructurada contiene n\u00fameros).</li> <li><code>(map-estruct f lista)</code>: similar a map, aplica una funci\u00f3n a todas las   hojas de la lista estructurada y devuelve el resultado (otra lista   estructurada).</li> <li><code>(altura lista)</code>: devuelve el n\u00famero de niveles de una lista   estructurada.</li> <li><code>(nivel-hoja dato lista)</code>: devuelve el nivel en el que se encuentra   un dato en una lista.</li> </ul>"},{"location":"teoria/tema04-estructuras-recursivas/tema04-estructuras-recursivas.html#1231-pertenece-estruct-dato-lista","title":"1.2.3.1. <code>(pertenece-estruct? dato lista)</code>","text":"<p>Comprueba si el <code>dato</code> aparece en la lista estructurada. </p> <pre><code>(pertenece-estruct? 'a '(b c (d (a)))) ; \u21d2 #t\n(pertenece-estruct? 'a '(b c (d e (f)) g)) ; \u21d2 #f\n</code></pre> <p>Soluci\u00f3n recursiva:</p> <pre><code>(define (pertenece-estruct? dato ld)\n  (cond \n    ((null? ld) #f)\n    ((hoja? ld) (equal? dato ld))\n    (else (or (pertenece-estruct? dato (first ld))\n              (pertenece-estruct? dato (rest ld))))))\n</code></pre> <p>Con funciones de orden superior:</p> <pre><code>(define (pertenece-fos? dato ld)\n  (if (hoja? ld)\n    (equal? dato ld)\n    (exists? (lambda (elem)\n               (pertenece-fos? dato elem)) ld)))\n</code></pre>"},{"location":"teoria/tema04-estructuras-recursivas/tema04-estructuras-recursivas.html#1232-cuadrado-estruct-lista","title":"1.2.3.2. <code>(cuadrado-estruct lista)</code>","text":"<p>Vamos ahora a ver un tipo de funci\u00f3n distinta. Una que construye una lista estructurada y la devuelve. </p> <p>Queremos implementar la funci\u00f3n <code>(cuadrado-estruct lista)</code> que recibe una lista estructurada y devuelve otra lista estructurada con la misma estructura y sus n\u00fameros elevados al cuadrado.</p> <p>Por ejemplo:</p> <pre><code>(cuadrado-estruct '(2 3 (4 (5)))) ; \u21d2 (4 9 (16 (25))\n</code></pre> <p>La soluci\u00f3n recursiva es:</p> <pre><code>(define (cuadrado-estruct ld)\n  (cond ((null? ld) '())\n        ((hoja? ld) (* ld ld ))\n        (else (cons (cuadrado-estruct (first ld))\n                    (cuadrado-estruct (rest ld))))))\n</code></pre> <p>Se llama a la recursi\u00f3n con el <code>first</code> y con el <code>rest</code> de la lista original. El resultado de ambas llamadas ser\u00e1n las correspondientes listas estructuradas con sus elementos elevados al cuadrado. Y se devuelve la lista resultante de insertar la lista devuelta en la llamada recursiva con el <code>first</code> en la primera posici\u00f3n de la lista devuelta en la llamada recursiva con el <code>rest</code>.</p> <p>Es muy interesante la versi\u00f3n de esta funci\u00f3n con funciones de orden superior:</p> <pre><code>(define (cuadrado-estruct-fos ld)\n  (if (hoja? ld)\n      (* ld ld)\n      (map cuadrado-estruct-fos ld)))\n</code></pre> <p>Como una lista estructurada est\u00e1 compuesta de datos o de otras sublistas podemos aplicar <code>map</code> para que devuelva la lista resultante de transformar la original con la funci\u00f3n que le pasamos como par\u00e1metro.</p>"},{"location":"teoria/tema04-estructuras-recursivas/tema04-estructuras-recursivas.html#1233-map-estruct-f-lista","title":"1.2.3.3. <code>(map-estruct f lista)</code>","text":"<p>Podemos generalizar la funci\u00f3n anterior y definir la funci\u00f3n de orden superior sobre listas estructuradas <code>(map-estructurada f lista)</code> que devuelve una lista estructurada igual que la original con el resultado de aplicar a cada uno de sus hojas la funci\u00f3n f</p> <p>Por ejemplo:</p> <pre><code>(map-estruct (lambda (x) (* x x)) '(2 3 (4 (5)))) ; \u21d2 (4 9 (16 (25))\n</code></pre> <p>La soluci\u00f3n recursiva es una generalizaci\u00f3n de la funci\u00f3n anterior, usando el par\u00e1metro <code>f</code>:</p> <pre><code>(define (map-estruct f ld)\n  (cond ((null? ld) '())\n        ((hoja? ld) (f ld))\n        (else (cons (map-estruct f (first ld))\n                    (map-estruct f (rest ld))))))\n</code></pre> <p>Soluci\u00f3n con <code>map</code>:</p> <pre><code>(define (map-estruct-fos f ld)\n  (if (hoja? ld)\n      (f ld)\n      (map (lambda (elem)\n             (map-estruct-fos f elem)) ld)))\n</code></pre>"},{"location":"teoria/tema04-estructuras-recursivas/tema04-estructuras-recursivas.html#1234-altura-lista","title":"1.2.3.4. <code>(altura lista)</code>","text":"<p>La altura de una lista estructurada viene dada por su n\u00famero de niveles: una lista plana tiene una altura de 1, la lista <code>((1 2 3) 4 5)</code> tiene una altura de 2.</p> <p>Para calcular la altura de una lista estructurada tenemos que obtener (de forma recursiva) la altura de su primer elemento, y la altura del resto de la lista, sumarle 1 a la altura del primer elemento y devolver el m\u00e1ximo de los dos n\u00fameros.</p> <p></p> <p>Como casos base, la altura de una lista vac\u00eda o de una hoja (dato) es 0.</p> <p>En Scheme:</p> <p><pre><code>(define (altura ld)\n   (cond \n      ((null? ld) 0)\n      ((hoja? ld) 0)\n      (else (max (+ 1 (altura (first ld)))\n                 (altura (rest ld))))))\n</code></pre> Por ejemplo:</p> <pre><code>(altura '(1 (2 3) 4)) ; \u21d2 2\n(altura '(1 (2 (3)) 3)) ; \u21d2 3\n</code></pre>"},{"location":"teoria/tema04-estructuras-recursivas/tema04-estructuras-recursivas.html#12321-version-con-funciones-de-orden-superior","title":"1.2.3.2.1. Versi\u00f3n con funciones de orden superior","text":"<p>Y la segunda versi\u00f3n, usando las funciones de orden superior <code>map</code> para obtener la altura de sus elementos del primer nivel (puedes ser hojas o sublistas) y <code>foldr</code> para quedarse con el m\u00e1ximo de la lista de valores que devuelve el map.</p> <pre><code>(define (altura-fos ld)\n   (if (hoja? ld)\n       0\n       (+ 1 (foldr max 0 (map altura-fos ld)))))\n</code></pre> <p>Podr\u00edamos hacerlo tambi\u00e9n sustituyendo el <code>foldr</code> por un <code>apply</code>:</p> <pre><code>(define (altura-fos ld)\n   (if (hoja? ld)\n       0\n       (+ 1 (apply max (map altura-fos ld)))))\n</code></pre>"},{"location":"teoria/tema04-estructuras-recursivas/tema04-estructuras-recursivas.html#1235-nivel-hoja-dato-lista","title":"1.2.3.5. <code>(nivel-hoja dato lista)</code>","text":"<p>Veamos una \u00faltima funci\u00f3n <code>(nivel-hoja dato lista)</code> que recorre una lista estructurada buscando el dato y devuelve el nivel en que se encuentra. Si el dato no se encuentra en la lista, se devolver\u00e1 -1. Si el dato se encuentra en m\u00e1s de un lugar de la lista se devolver\u00e1 el nivel mayor.</p> <p>Ejemplos:</p> <pre><code>(nivel-hoja 'b '(a b (c))) ; \u21d2 1\n(nivel-hoja 'b '(a (b) c)) ; \u21d2 2\n(nivel-hoja 'b '(a (b) d ((b)))) ; \u21d2 3\n(nivel-hoja 'b '(a c d ((e)))) ; \u21d2 -1\n</code></pre> <p>Soluci\u00f3n recursiva:</p> <pre><code>(define (nivel-hoja dato ld)\n  (cond\n    ((null? ld) -1)\n    ((hoja? ld) (if (equal? ld dato) 0 -1))\n    (else (max (suma-1-si-mayor-igual-que-0 \n                    (nivel-hoja dato (first ld)))\n               (nivel-hoja dato (rest ld))))))\n</code></pre> <p>La funci\u00f3n auxiliar se define de la siguiente forma:</p> <pre><code>(define (suma-1-si-mayor-igual-que-0 x)\n  (if (&gt;= x 0)\n      (+ x 1)\n      x))\n</code></pre> <p>Con funciones de orden superior:</p> <pre><code>(define (nivel-hoja-fos dato ld)\n  (if (hoja? ld)\n      (if (equal? ld dato) 0 -1)\n      (suma-1-si-mayor-igual-que-0\n       (foldr max -1 (map (lambda (elem)\n                           (nivel-hoja-fos dato elem)) ld)))))\n</code></pre>"},{"location":"teoria/tema04-estructuras-recursivas/tema04-estructuras-recursivas.html#2-arboles","title":"2. \u00c1rboles","text":""},{"location":"teoria/tema04-estructuras-recursivas/tema04-estructuras-recursivas.html#21-definicion-de-arboles-en-scheme","title":"2.1. Definici\u00f3n de \u00e1rboles en Scheme","text":""},{"location":"teoria/tema04-estructuras-recursivas/tema04-estructuras-recursivas.html#211-definicion-de-arbol","title":"2.1.1. Definici\u00f3n de \u00e1rbol","text":"<p>Un \u00e1rbol es una estructura de datos definida por un valor ra\u00edz, que es el padre de toda la estructura, del que salen otros sub\u00e1rboles hijos (Wikipedia).</p> <p>Un \u00e1rbol se puede definir recursivamente de la siguiente forma:</p> <ul> <li>Una colecci\u00f3n de un dato (el valor de la ra\u00edz del \u00e1rbol) y una   lista de hijos que tambi\u00e9n son \u00e1rboles.</li> <li>Una hoja ser\u00e1 un \u00e1rbol sin hijos (un dato con una lista de hijos   vac\u00eda).</li> </ul> <p>Un ejemplo de \u00e1rbol:</p> <p></p> <p>El \u00e1rbol anterior tiene como dato ra\u00edz el n\u00famero 30 y tiene 3 \u00e1rboles hijos:</p> <ul> <li>El primer hijo es un \u00e1rbol con ra\u00edz 15 y con dos hijos hoja, el 10 y   el 12</li> <li>El segundo hijo es un \u00e1rbol hoja, con valor 18</li> <li>El tercer hijo es un \u00e1rbol con ra\u00edz 25 y con tres hijos hoja, el 19,   21 y 22.</li> </ul>"},{"location":"teoria/tema04-estructuras-recursivas/tema04-estructuras-recursivas.html#212-representacion-de-arboles-con-listas","title":"2.1.2. Representaci\u00f3n de \u00e1rboles con listas","text":"<p>En Scheme la lista es la estructura de datos principal. \u00bfC\u00f3mo podemos construir un \u00e1rbol usando listas?</p> <p>Podemos hacerlo de varias formas, pero escogemos la siguiente: usar una lista de n+1 elementos para representar un \u00e1rbol con n hijos:</p> <p></p> <ul> <li>el primer elemento la lista ser\u00e1 el dato de la ra\u00edz</li> <li>el resto ser\u00e1n los \u00e1rboles hijos</li> </ul> <pre><code>arbol -&gt; (dato hijo-1 hijo-2 ... hijo-n)\n</code></pre> <p>Los nodos hoja (datos al final del \u00e1rbol que no tienen ning\u00fan hijo) son tambi\u00e9n \u00e1rboles. Al no tener hijos, se representan como listas con un \u00fanico elemento, el propio dato.</p> <pre><code>Nodo hoja -&gt; (dato)\n</code></pre> <p>La forma de representar el \u00e1rbol anterior </p> <p></p> <p>ser\u00e1 la siguiente lista:</p> <pre><code>(30 (15 (10) (12)) (18) (25 (19) (21) (22)))\n</code></pre> <p>Los elementos de esta lista son:</p> <p></p> <ul> <li>El primer elemento es el n\u00famero <code>30</code>, el dato valor de la ra\u00edz del   \u00e1rbol</li> <li>El segundo elemento es la lista <code>(15 (10) (12))</code>, que representa el   \u00e1rbol con dato <code>15</code> y dos hijos</li> <li>El tercer elemento es la lista <code>(18)</code> que representa el \u00e1rbol hoja   formado por un 18</li> <li>El tercer elemento es la lista <code>(15 (19) (21) (22))</code>, que representa el   \u00e1rbol con un dato <code>15</code> y tres hijos</li> </ul> <p>Podr\u00edamos definir el \u00e1rbol con la siguiente sentencia:</p> <pre><code>(define arbol1 '(30 (15 (10) (12)) (18) (25 (19) (21) (22))))\n</code></pre> <p>Otro ejemplo m\u00e1s. \u00bfC\u00f3mo se implementa en Scheme el \u00e1rbol de la siguiente figura?</p> <p></p> <p>Se har\u00eda con la lista de la siguiente sentencia:</p> <pre><code>(define arbol2 '(40 (18 (3) (23 (29))) (52 (47))))\n</code></pre>"},{"location":"teoria/tema04-estructuras-recursivas/tema04-estructuras-recursivas.html#213-barrera-de-abstraccion","title":"2.1.3. Barrera de abstracci\u00f3n","text":"<p>Una vez definida la forma de representar \u00e1rboles, vamos a definir las funciones b\u00e1sicas para manejarlos. Veremos las funciones para obtener el dato y los hijos y la funci\u00f3n para construir un \u00e1rbol nuevo. Estas funciones proporcionan lo que se denomina barrera de abstracci\u00f3n del tipo datos \u00e1rbol.</p> <p>En todos los nombres de las funciones de la barrera de abstracci\u00f3n a\u00f1adimos el sufijo <code>-arbol</code>.</p> <p>Definimos dos conjuntos de funciones: constructores para construir un nuevo \u00e1rbol y selectores para obtener los elementos del \u00e1rbol. Vamos a empezar por los selectores.</p> <p>Selectores</p> <p>Funciones que obtienen los elementos de un \u00e1rbol:</p> <pre><code>(define (dato-arbol arbol) \n    (first arbol))\n\n(define (hijos-arbol arbol) \n    (rest arbol))\n\n(define (hoja-arbol? arbol) \n   (null? (hijos-arbol arbol)))\n</code></pre> <p>Es importante tener claro los tipos devueltos por las dos primeras funciones:</p> <ul> <li><code>(dato-arbol arbol)</code>: devuelve el dato de la ra\u00edz del \u00e1rbol.</li> <li><code>(hijos-arbol arbol)</code>: devuelve una lista de \u00e1rboles hijos. En   algunas ocasiones llamaremos bosque a una lista de   \u00e1rboles. Podremos recorrer esa lista usando las funciones <code>first</code> y   <code>rest</code> para obtener los \u00e1rboles hijos.</li> </ul> <p>Volvemos a mostrar el <code>arbol1</code> para comprobar estas funciones.</p> <p></p> <p>Las funciones anteriores devuelven los siguientes valores:</p> <pre><code>(dato-arbol arbol1) ; \u21d2 30\n(hijos-arbol arbol1) ; \u21d2 ((15 (10) (12)) (18) (25 (19) (21) (22)))\n(hoja-arbol? (first (hijos-arbol arbol1))) ; \u21d2 #f\n(hoja-arbol? (second (hijos-arbol arbol1))) ; \u21d2 #t\n</code></pre> <ul> <li>La llamada <code>(dato-arbol arbol1)</code> devuelve el dato que hay en la ra\u00edz   del \u00e1rbol, el n\u00famero <code>30</code>.</li> <li>La invocaci\u00f3n <code>(hijos-arbol arbol1)</code> devuelve una lista de tres   elementos, los \u00e1rboles hijos:<ul> <li>El primer elemento es la lista <code>(15 (10) (12))</code>, que representa el \u00e1rbol   formado por el <code>15</code> en su ra\u00edz y las hojas <code>10</code> y <code>12</code>.</li> <li>El segundo elemento es el \u00e1rbol hoja <code>18</code>, representado por la   lista <code>(18)</code>.</li> <li>El tercero es la lista <code>(25 (19) (21) (22))</code>, que representa el   \u00e1rbol formado por el <code>25</code> en su ra\u00edz y las hojas <code>19</code>, <code>21</code> y <code>22</code>.</li> </ul> </li> </ul> <p>Es muy importante considerar en cada caso con qu\u00e9 tipo de dato estamos trabajando y usar la barrera de abstracci\u00f3n adecuada en cada caso:</p> <ul> <li>La funci\u00f3n <code>hijos-arbol</code> siempre devuelve una lista de \u00e1rboles, que   podemos recorrer usando <code>first</code> y <code>rest</code>.</li> <li>El <code>first</code> de una lista de \u00e1rboles (devuelta por <code>hijos-arbol</code>) siempre   es un \u00e1rbol y debemos de usar las funciones de su barrera de   abstracci\u00f3n: <code>dato-arbol</code> e <code>hijos-arbol</code>.</li> <li>La funci\u00f3n <code>dato-arbol</code> devuelve un dato, del tipo que   guardemos en el \u00e1rbol. En el caso del \u00e1rbol ejemplo es un n\u00famero.</li> </ul> <p>Por ejemplo, para obtener el n\u00famero <code>12</code> en el \u00e1rbol anterior tendr\u00edamos que hacer lo siguiente: acceder al primer elemento de la lista de hijos, despu\u00e9s al segundo hijo de \u00e9ste y por \u00faltimo acceder a su dato. Recordemos que <code>hijos-arbol</code> devuelve la lista de \u00e1rboles hijos, por lo que utilizaremos las funciones <code>first</code> y <code>rest</code> para recorrerlas y obtener los elementos que nos interesen:</p> <pre><code>(dato-arbol (second (hijos-arbol (first (hijos-arbol arbol1)))))\n; \u21d2 12\n</code></pre> <p>Constructor</p> <p>Definimos una funci\u00f3n constructora que abstrae la construcci\u00f3n de un \u00e1rbol y encapsula su implementaci\u00f3n concreta. Para construir un \u00e1rbol necesitamos un dato y una lista de \u00e1rboles hijos. Si la lista de \u00e1rboles hijos es vac\u00eda, tendremos un nodo hoja.</p> <pre><code>(define (construye-arbol dato lista-arboles)\n   (cons dato lista-arboles))\n</code></pre> <p>Llamaremos a la funci\u00f3n <code>construye-arbol</code> pasando su dato (obligatorio) y la lista de arboles hijos. Si se pasa una lista vac\u00eda como par\u00e1metro estaremos definiendo un nodo hoja.</p> <p>Por ejemplo, para definir un nodo hoja con el dato 2:</p> <pre><code>(define arbol3 (construye-arbol 2 '()))\n</code></pre> <p>Y para definir un \u00e1rbol con 3 hijos:</p> <pre><code>(define arbol4 (construye-arbol 10 (list (construye-arbol 2 '())\n                                         (construye-arbol 5 '()) \n                                         (construye-arbol 9 '())))\n</code></pre> <p>El \u00e1rbol 1 anterior se puede construir con las siguientes llamadas al constructor. Guardamos los \u00e1rboles hijos en variables auxiliares para hacer m\u00e1s entendible la expresi\u00f3n:</p> <pre><code>(define arbol-15 (construye-arbol 15 (list (construye-arbol 10 '())\n                                           (construye-arbol 12 '()))))\n(define arbol-18 (construye-arbol 18 '()))                                             \n(define arbol-25 (construye-arbol 25 (list (construye-arbol 19 '())\n                                           (construye-arbol 21 '())\n                                           (construye-arbol 22 '()))))\n(define arbol1b (construye-arbol 30 (list arbol-15 arbol-18 arbol-25)))\narbol1b ; \u21d2 (30 (15 (10) (12)) (18) (25 (19) (21) (22)))\n</code></pre>"},{"location":"teoria/tema04-estructuras-recursivas/tema04-estructuras-recursivas.html#214-barreras-de-abstraccion-de-arboles-y-listas-estructuradas","title":"2.1.4. Barreras de abstracci\u00f3n de \u00e1rboles y listas estructuradas","text":"<p>Es importante diferenciar la barrera de abstracci\u00f3n de los \u00e1rboles de la de las listas estructuradas. Aunque un \u00e1rbol se implementa en Scheme con una lista estructurada, a la hora de definir funciones sobre \u00e1rboles hay que trabajar con las funciones definidas arriba.</p> <p>El siguiente esquema resumen las caracter\u00edsticas de los selectores de la barrera de abstracci\u00f3n de listas y \u00e1rboles:</p> <p></p> <p>Importante</p> <p>Debemos usar la barrera de abstracci\u00f3n al trabajar con \u00e1rboles porque as\u00ed separamos nuestro c\u00f3digo de la implementaci\u00f3n subyacente del tipo de dato. De esta forma es posible cambiar la implementaci\u00f3n del tipo de dato sin afectar a las funciones que hemos definido usando la barrera. Lo \u00fanico que hay que hacer es cambiar la implementaci\u00f3n de la barrera de abstracci\u00f3n.</p> <p>Otras ventajas de utilizar la barrera de abstracci\u00f3n, tan importantes como la anterior, son:</p> <ul> <li> <p>El c\u00f3digo es mucho m\u00e1s legible. Dado que Scheme es un lenguaje d\u00e9bilmente tipado, en una expresi\u00f3n como <code>(dato-arbol elem)</code> sabemos que el el elemento sobre el que se trabaja es un \u00e1rbol (no es un n\u00famero, ni un string, ni un booleano).</p> </li> <li> <p>El c\u00f3digo es trasladable a cualquier lenguaje de programaci\u00f3n. Si queremos trabajar con \u00e1rboles en JavaScript, por ejemplo, s\u00f3lo tendremos que implementar la barrera de abstracci\u00f3n en este lenguaje. Una vez hecho eso todas las funciones que trabajan con \u00e1rboles, como las que veremos a continuaci\u00f3n, funcionar\u00e1n correctamente.</p> </li> </ul>"},{"location":"teoria/tema04-estructuras-recursivas/tema04-estructuras-recursivas.html#22-funciones-recursivas-sobre-arboles","title":"2.2. Funciones recursivas sobre \u00e1rboles","text":"<p>Vamos a dise\u00f1ar las siguientes funciones recursivas:</p> <ul> <li><code>(suma-datos-arbol arbol)</code>: devuelve la suma de todos los nodos</li> <li><code>(to-list-arbol arbol)</code>: devuelve una lista con los datos del \u00e1rbol</li> <li><code>(cuadrado-arbol arbol)</code>: eleva al cuadrado todos los datos de un   \u00e1rbol manteniendo la estructura del \u00e1rbol original</li> <li><code>(map-arbol f arbol)</code>: devuelve un \u00e1rbol con la estructura del \u00e1rbol   original aplicando la funci\u00f3n f a subdatos.</li> <li><code>(altura-arbol arbol)</code>: devuelve la altura de un \u00e1rbol</li> </ul> <p>Todas comparten un patr\u00f3n similar de recursi\u00f3n mutua.</p>"},{"location":"teoria/tema04-estructuras-recursivas/tema04-estructuras-recursivas.html#221-funcion-suma-datos-arbol","title":"2.2.1. Funci\u00f3n suma-datos-arbol","text":"<p>Vamos a implementar una funci\u00f3n recursiva que sume todos los datos de un \u00e1rbol.</p> <p>Un \u00e1rbol siempre va a tener un dato y una lista de hijos (que puede ser vac\u00eda) que obtenemos con las funciones <code>dato-arbol</code> e <code>hijos-arbol</code>. Podemos plantear entonces el problema de sumar los datos de un \u00e1rbol como la suma del dato de su ra\u00edz y lo que devuelva la llamada a una funci\u00f3n auxiliar que sume los datos de su lista de hijos (llamamos bosque a una lista de hijos):</p> <pre><code>(define (suma-datos-arbol arbol)\n    (+ (dato-arbol arbol)\n       (suma-datos-bosque (hijos-arbol arbol))))\n</code></pre> <p>Esta funci\u00f3n suma los datos de un \u00e1rbol. La podemos utilizar entonces para construir la siguiente funci\u00f3n que suma una lista de \u00e1rboles:</p> <pre><code>(define (suma-datos-bosque bosque)\n   (if (null? bosque)\n       0\n       (+ (suma-datos-arbol (first bosque)) (suma-datos-bosque (rest bosque)))))\n</code></pre> <p>Podemos visualizar el funcionamiento de la <code>suma-datos-bosque</code> en la siguiente figura:</p> <p></p> <p>El caso general de la funci\u00f3n obtiene el primer \u00e1rbol de la lista (un \u00e1rbol) y llama a la funci\u00f3n <code>suma-datos-arbol</code> para obtener la suma de sus datos. Tambi\u00e9n obtiene el resto del bosque (otra lista de \u00e1rboles) y llama de forma recursiva a la propia funci\u00f3n para sumar todos sus \u00e1rboles.</p> <p>Tenemos una recursi\u00f3n mutua: para sumar los datos de una lista de \u00e1rboles llamamos a la suma de un \u00e1rbol individual que a su vez llama a la suma de sus hijos, etc. La recursi\u00f3n termina cuando calculamos la suma de un \u00e1rbol hoja. Entonces se pasa a <code>suma-datos-bosque</code> una lista vac\u00eda y \u00e9sta devolver\u00e1 0.</p> <pre><code>(suma-datos-arbol arbol1) ; \u21d2 172\n</code></pre> <p>Versi\u00f3n alternativa con funciones de orden superior</p> <p>Al igual que hac\u00edamos con las listas estructuradas, es posible conseguir una versi\u00f3n m\u00e1s concisa y elegante utilizando funciones de orden superior:</p> <pre><code>(define (suma-datos-arbol-fos arbol)\n   (foldr + \n          (dato-arbol arbol) \n          (map suma-datos-arbol-fos (hijos-arbol arbol))))\n</code></pre> <p>La funci\u00f3n <code>map</code> aplica la propia funci\u00f3n que estamos definiendo (<code>suma-datos-arbol-fos</code>) a cada uno de los \u00e1rboles hijos (obtenidos con la funci\u00f3n <code>(hijos-arbol arbol)</code>). Confiando en que la funci\u00f3n hace su trabajo, devolver\u00e1 para cada arbol hijo la suma de todos sus nodos. De esta forma, el resultado de <code>map</code> ser\u00e1 una lista con la suma de los nodos de todos los \u00e1rboles hijos.</p> <p>La funci\u00f3n <code>foldr</code> suma todos esos n\u00fameros de la lista y el n\u00famero de la ra\u00edz.</p> <p>Nota</p> <p>Puede parecer que a la funci\u00f3n anterior le falta un caso base. \u00bfCu\u00e1ndo termina la recursi\u00f3n? La respuesta est\u00e1 en el funcionamiento de <code>map</code>, que cuando recibe una lista vac\u00eda devuelve tambi\u00e9n una lista vac\u00eda. Para comprobarlo, puedes pensar en qu\u00e9 pasar\u00eda si le pasas a la funci\u00f3n un \u00e1rbol hoja.</p> <p>Un ejemplo de su funcionamiento ser\u00eda el siguiente:</p> <pre><code>(suma-datos-arbol-fos '(1 (2 (3) (4)) (5) (6 (7)))) \u21d2\n   (foldr + \n          1 \n          (map suma-datos-arbol-fos '((2 (3) (4)) \n                                      (5)\n                                      (6 (7))))) \u21d2\n(foldr + 1 '(9 5 13)) \u21d2\n28\n</code></pre> <ul> <li>El \u00e1rbol que queremos sumar tiene un 1 en la ra\u00edz y tres hijos: <code>(2 (3) (4))</code>, <code>(5)</code> y <code>(6 (7))</code>. </li> <li>La aplicaci\u00f3n de <code>map suma-datos-arbol-fos</code> sobre la lista de hijos devuelve una lista con la suma de los nodos de cada hijo: <code>(9 5 13)</code>.</li> <li>La funci\u00f3n <code>foldr</code> suma esa lista y el valor del nodo ra\u00edz (<code>1</code>).</li> </ul> <p>Podemos visualizar gr\u00e1ficamente el funcionamiento del <code>map</code> con la siguiente figura:</p> <p></p>"},{"location":"teoria/tema04-estructuras-recursivas/tema04-estructuras-recursivas.html#222-funcion-to-list-arbol","title":"2.2.2. Funci\u00f3n to-list-arbol","text":"<p>Queremos dise\u00f1ar una funci\u00f3n <code>(to-list-arbol arbol)</code> que devuelva una lista con los datos del \u00e1rbol en un recorrido preorden (primero el dato de la ra\u00edz y despu\u00e9s el dato de sus hijos de izquierda a derecha).</p> <p>La soluci\u00f3n, siguiendo el patr\u00f3n visto en <code>suma-datos</code>, es la siguiente.</p> <pre><code>(define (to-list-arbol arbol)\n   (cons (dato-arbol arbol)\n         (to-list-bosque (hijos-arbol arbol))))\n\n(define (to-list-bosque bosque)\n   (if (null? bosque)\n       '()\n       (append (to-list-arbol (first bosque))\n               (to-list-bosque (rest bosque)))))\n</code></pre> <p>Igual que antes, la funci\u00f3n utiliza una recursi\u00f3n mutua: para listar todos los nodos, a\u00f1adimos el dato a la lista de nodos que nos devuelve la funci\u00f3n <code>to-list-bosque</code>. Esta funci\u00f3n coge una lista de \u00e1rboles (un bosque) y devuelve la lista preorden de sus nodos. Para ello, concatena la lista de los nodos de su primer elemento (el primer \u00e1rbol) a la lista de nodos del resto de \u00e1rboles (que devuelve la llamada recursiva).</p> <p>Ejemplo:</p> <pre><code>(to-list-arbol '(* (+ (5) (* (2) (3)) (10)) (- (12)))) \n; \u21d2 (* + 5 * 2 3 10 - 12)\n</code></pre> <p>Una definici\u00f3n alternativa usando funciones de orden superior:</p> <pre><code>(define (to-list-arbol-fos arbol)\n    (cons (dato-arbol arbol)\n          (foldr append '() (map to-list-arbol-fos (hijos-arbol arbol)))))\n</code></pre> <p>Esta versi\u00f3n es muy elegante y concisa. Usa la funci\u00f3n <code>map</code> que aplica una funci\u00f3n a los elementos de una lista y devuelve la lista resultante. Como lo que devuelve <code>(hijos-arbol arbol)</code> es precisamente una lista de \u00e1rboles podemos aplicar a sus elementos cualquier funci\u00f3n definida sobre \u00e1rboles. Incluso la propia funci\u00f3n que estamos definiendo (\u00a1conf\u00eda en la recursi\u00f3n!).</p>"},{"location":"teoria/tema04-estructuras-recursivas/tema04-estructuras-recursivas.html#223-funcion-cuadrado-arbol","title":"2.2.3. Funci\u00f3n cuadrado-arbol","text":"<p>Veamos ahora la funci\u00f3n <code>(cuadrado-arbol arbol)</code> que toma un \u00e1rbol de n\u00fameros y devuelve un \u00e1rbol con la misma estructura y sus datos elevados al cuadrado:</p> <pre><code>(define (cuadrado-arbol arbol)\n   (construye-arbol (cuadrado (dato-arbol arbol))\n                    (cuadrado-bosque (hijos-arbol arbol))))\n\n(define (cuadrado-bosque bosque)\n   (if (null? bosque)\n       '()\n       (cons (cuadrado-arbol (first bosque))\n               (cuadrado-bosque (rest bosque)))))\n</code></pre> <p>Ejemplo:</p> <pre><code>(cuadrado-arbol '(2 (3 (4) (5)) (6))) \n; \u21d2 (4 (9 (16) (25)) (36))\n</code></pre> <p>Versi\u00f3n 2, con la funci\u00f3n de orden superior <code>map</code>:</p> <pre><code>(define (cuadrado-arbol-fos arbol)\n    (construye-arbol (cuadrado (dato-arbol arbol))\n                     (map cuadrado-arbol-fos (hijos-arbol arbol))))\n</code></pre>"},{"location":"teoria/tema04-estructuras-recursivas/tema04-estructuras-recursivas.html#224-funcion-map-arbol","title":"2.2.4. Funci\u00f3n <code>map-arbol</code>","text":"<p>La funci\u00f3n <code>map-arbol</code> es una funci\u00f3n de orden superior que generaliza la funci\u00f3n anterior. Definimos un par\u00e1metro adicional en el que se pasa la funci\u00f3n a aplicar a los elementos del \u00e1rbol.</p> <pre><code>(define (map-arbol f arbol)\n   (construye-arbol (f (dato-arbol arbol))\n                    (map-bosque f (hijos-arbol arbol))))  \n\n(define (map-bosque f bosque)\n   (if (null? bosque)\n       '()\n       (cons (map-arbol f (first bosque))\n             (map-bosque f (rest bosque)))))\n</code></pre> <p>Ejemplos:</p> <pre><code>(map-arbol cuadrado '(2 (3 (4) (5)) (6)))\n; \u21d2 (4 (9 (16) (25)) (36))\n(map-arbol (lambda (x) (+ x 1)) '(2 (3 (4) (5)) (6)))\n; \u21d2 (3 (4 (5) (6)) (7))\n</code></pre> <p>Con <code>map</code>:</p> <pre><code>(define (map-arbol-fos f arbol)\n  (construye-arbol (f (dato-arbol arbol))\n               (map (lambda (x)\n                       (map-arbol-fos f x)) (hijos-arbol arbol))))\n</code></pre>"},{"location":"teoria/tema04-estructuras-recursivas/tema04-estructuras-recursivas.html#225-funcion-altura-arbol","title":"2.2.5. Funci\u00f3n <code>altura-arbol</code>","text":"<p>Vamos por \u00faltimo a definir una funci\u00f3n que devuelve la altura de un \u00e1rbol. </p> <p>Recordemos las siguientes definiciones relacionadas con los \u00e1rboles:</p> <ul> <li>Longitud de un camino entre dos nodos: n\u00famero de aristas.</li> <li>Altura de un nodo: longitud del camino m\u00e1s largo del nodo a una hoja.</li> <li>Profundidad de un nodo: longitud del camino de la ra\u00edz al nodo.</li> <li>Profundidad de un \u00e1rbol: profundidad del nodo m\u00e1s profundo.</li> <li>Nivel de un nodo: n\u00famero de predecesores.</li> <li>Altura de \u00e1rbol: altura de la ra\u00edz.</li> </ul> <p>Podemos implementar la altura de una forma similar a como hicimos con las listas estructuradas: calculamos la altura de los \u00e1rboles hijos, nos quedamos con la mayor, y sumamos 1 para a\u00f1adir la arista del camino de la ra\u00edz al hijo.</p> <p>La mayor altura de los hijos la calculamos con la funci\u00f3n <code>altura-bosque</code>.</p> <pre><code>(define (altura-arbol arbol)\n   (if (hoja-arbol? arbol)\n       0\n       (+ 1 (altura-bosque (hijos-arbol arbol)))))\n\n(define (altura-bosque bosque)\n    (if (null? bosque)\n        0\n        (max (altura-arbol (first bosque))\n             (altura-bosque (rest bosque)))))\n</code></pre> <p>Ejemplos:</p> <pre><code>(altura-arbol '(2)) ;  \u21d2 0\n(altura-arbol '(4 (9 (16) (25)) (36))) ; \u21d2 2\n</code></pre> <p>La soluci\u00f3n con funciones de orden superior es similar a la que vimos con listas estructuradas:</p> <pre><code>(define (altura-arbol-fos arbol)\n  (if (hoja-arbol? arbol)\n      0\n      (+ 1 (foldr max 0\n                  (map altura-arbol-fos (hijos-arbol arbol))))))\n</code></pre> <p>La funci\u00f3n <code>map</code> mapea sobre los \u00e1rboles hijos la propia funci\u00f3n, que calcula la altura de cada hijo (ser\u00e1 uno menos que la altura del padre, 0 si se trata de una hoja).</p> <p>La funci\u00f3n <code>map</code> devuelve entonces una lista altura de los hijos, de la que obtenemos el m\u00e1ximo plegando la lista con la funci\u00f3n <code>max</code>. </p> <p>Por \u00faltimo sumamos 1 para devolver la altura del \u00e1rbol completo (un nivel m\u00e1s que el nivel m\u00e1ximo de los hijos).</p>"},{"location":"teoria/tema04-estructuras-recursivas/tema04-estructuras-recursivas.html#3-arboles-binarios","title":"3. Arboles binarios","text":""},{"location":"teoria/tema04-estructuras-recursivas/tema04-estructuras-recursivas.html#31-definicion-de-arboles-binarios-en-scheme","title":"3.1. Definici\u00f3n de \u00e1rboles binarios en Scheme","text":"<p>Los \u00e1rboles binarios son \u00e1rboles cuyos nodos tienen 0, 1 o 2 hijos. Por ejemplo, el \u00e1rbol mostrado en la siguiente figura es un \u00e1rbol binario.</p> <p></p> <p>A diferencia de los \u00e1rboles gen\u00e9ricos vistos anteriormente un \u00e1rbol binario no puede tener m\u00e1s de dos hijos.</p> <p>Los representaremos en Scheme utilizando una lista de tres elementos:</p> <ul> <li>Dato</li> <li>Hijo izquierdo (otro \u00e1rbol binario)</li> <li>Hijo derecho (otro \u00e1rbol binario)</li> </ul> <p>En el caso en que no exista el hijo izquierdo o el derecho (o ambos) utilizaremos una lista vac\u00eda para indicar un nodo vac\u00edo.</p> <p>De esta manera, un nodo hoja con el dato 10 se representar\u00e1 en Scheme con la lista:</p> <pre><code>(10 () ())\n</code></pre> <p>Por ejemplo, representamos el \u00e1rbol de la figura anterior con la siguiente lista:</p> <pre><code>(40 (18 (3 () ())\n        (23 ()\n            (29 () ())))\n    (52 (47 () ())\n        ()))\n</code></pre> <p>Visualmente lo podemos representar de la siguiente forma. La no existencia de un hijo izquierdo o un hijo derecho se representa por una lista vac\u00eda.</p> <p></p>"},{"location":"teoria/tema04-estructuras-recursivas/tema04-estructuras-recursivas.html#311-barrera-de-abstraccion","title":"3.1.1. Barrera de abstracci\u00f3n","text":"<p>Definimos la siguiente barrera de abstracci\u00f3n para los \u00e1rboles binarios. Terminamos todos los nombres de las funciones con el sufijo <code>-arbolb</code> (\u00e1rbol binario).</p> <p>Selectores</p> <p>Los selectores de la barrera de abstracci\u00f3n del \u00e1rbol binario son los siguientes.</p> <pre><code>(define (dato-arbolb arbol)\n   (first arbol))\n\n(define (hijo-izq-arbolb arbol)\n   (second arbol))\n\n(define (hijo-der-arbolb arbol)\n   (third arbol))\n\n(define arbolb-vacio '())\n\n(define (vacio-arbolb? arbol)\n   (equal? arbol arbolb-vacio))\n\n(define (hoja-arbolb? arbol)\n   (and (vacio-arbolb? (hijo-izq-arbolb arbol))\n        (vacio-arbolb? (hijo-der-arbolb arbol))))\n</code></pre> <p>Como parte de la barrera de abstracci\u00f3n definimos la constante <code>arbolb-vacio</code>, que toma el valor de una lista vac\u00eda.</p> <p>Constructor</p> <pre><code>(define (construye-arbolb dato hijo-izq hijo-der)\n    (list dato hijo-izq hijo-der))\n</code></pre> <p>Por ejemplo, para construir un \u00e1rbol con 10 en la ra\u00edz y 8 en su hijo izquierdo y 15 en su derecho utilizando el constructor de la barrera de abstracci\u00f3n:</p> <pre><code>(define arbolb1\n   (construye-arbolb 10 (construye-arbolb 8 arbolb-vacio arbolb-vacio)\n                        (construye-arbolb 15 arbolb-vacio arbolb-vacio)))\n</code></pre> <p>Otro ejemplo, el \u00e1rbol binario de la figura anterior utilizando el constructor de la barrera de abstracci\u00f3n:</p> <pre><code>(define arbolb2\n   (construye-arbolb 40 \n                 (construye-arbolb 18\n                               (construye-arbolb 3 arbolb-vacio arbolb-vacio)\n                               (construye-arbolb 23 \n                                             arbolb-vacio\n                                             (construye-arbolb 29 \n                                                           arbolb-vacio\n                                                           arbolb-vacio)))\n                 (construye-arbolb 52\n                               (construye-arbolb 47 arbolb-vacio arbolb-vacio)\n                               arbolb-vacio)))\n</code></pre>"},{"location":"teoria/tema04-estructuras-recursivas/tema04-estructuras-recursivas.html#32-funciones-recursivas-sobre-arboles-binarios","title":"3.2. Funciones recursivas sobre \u00e1rboles binarios","text":"<p>Veamos las siguientes funciones recursivas sobre \u00e1rboles binarios:</p> <ul> <li><code>(suma-datos-arbolb arbol)</code>: devuelve la suma de todos los nodos</li> <li><code>(to-list-arbolb arbol)</code>: devuelve una lista con los datos del \u00e1rbol</li> <li><code>(cuadrado-arbolb arbol)</code>: eleva al cuadrado todos los datos de un   \u00e1rbol manteniendo la estructura del \u00e1rbol original</li> </ul> <p>Estas funciones utilizan una mezcla de los patrones usados en la recursi\u00f3n para trabajar con \u00e1rboles gen\u00e9ricos y la recursi\u00f3n para trabajar con listas estructuradas. Tenemos un dato en la ra\u00edz, que tenemos que combinar con lo que devuelve la recursi\u00f3n aplicada sobre el hijo izquierdo y lo que devuelve la recursi\u00f3n aplicada sobre el hijo derecho.</p> <p>suma-datos-arbolb</p> <pre><code>(define (suma-datos-arbolb arbol)\n   (if (vacio-arbolb? arbol)\n      0\n      (+ (dato-arbolb arbol)\n         (suma-datos-arbolb (hijo-izq-arbolb arbol))\n         (suma-datos-arbolb (hijo-der-arbolb arbol)))))\n\n(suma-datos-arbolb arbolb2) ; \u21d2 212\n</code></pre> <p>Como el hijo izquierdo y el hijo derecho son tambi\u00e9n \u00e1rboles binarios, podemos llamar a la recursi\u00f3n con esos \u00e1rboles. Esas llamadas recursivas nos devolver\u00e1n la suma de los datos en cada sub\u00e1rbol. Y sumamos el dato de la ra\u00edz.</p> <p>Para definir el caso base, podemos ver que en cada llamada recursiva vamos obteniendo el hijo izquierdo y el hijo derecho. Al final llegaremos a un \u00e1rbol vac\u00edo, en cuyo caso devolvemos 0. </p> <p>La siguiente figura representa el funcionamiento del caso general.</p> <p></p> <p>to-list-arbolb</p> <p>La funci\u00f3n <code>to-list-arbolb</code> es similar a la vista con los \u00e1rboles gen\u00e9ricos. Recibe un \u00e1rbol binario y devuelve una lista con los datos en un recorrido preorden.</p> <pre><code>(define (to-list-arbolb arbol)\n   (if (vacio-arbolb? arbol)\n      '()\n      (cons (dato-arbolb arbol)\n            (append (to-list-arbolb (hijo-izq-arbolb arbol))\n                    (to-list-arbolb (hijo-der-arbolb arbol))))))\n\n(to-list-arbolb arbolb2) ; \u21d2 (40 18 3 23 29 52 47)\n</code></pre> <p>El funcionamiento es similar a la suma: llamamos a la recursi\u00f3n por la izquierda y por la derecha. El resultado de las llamadas recursivas ser\u00e1n dos listas que tenemos que concatenar con <code>append</code>. Y por \u00faltimos a\u00f1adimos en cabeza el dato de la ra\u00edz con <code>cons</code>.</p> <p>cuadrado-arbolb</p> <p>Por \u00faltimo, la funci\u00f3n <code>cuadrado-arbolb</code> construye un nuevo \u00e1rbol binario elevando al cuadrado el dato de la ra\u00edz, su hijo izquierdo y su hijo derecho. Para construir el \u00e1rbol binario llamamos al constructor <code>construye-arbolb</code>.</p> <pre><code>(define (cuadrado-arbolb arbol)\n   (if (vacio-arbolb? arbol)\n      arbolb-vacio\n      (construye-arbolb (cuadrado (dato-arbolb arbol))\n                        (cuadrado-arbolb (hijo-izq-arbolb arbol))\n                        (cuadrado-arbolb (hijo-der-arbolb arbol)))))\n\n(cuadrado-arbolb arbolb1) ; \u21d2 (100 (64 () ()) (225 () ()))\n</code></pre>"},{"location":"teoria/tema04-estructuras-recursivas/tema04-estructuras-recursivas.html#4-bibliografia-sicp","title":"4. Bibliograf\u00eda - SICP","text":"<p>En este tema explicamos conceptos de los siguientes cap\u00edtulos del libro Structure and Intepretation of Computer Programs:</p> <ul> <li>2.2.2 - Hierarchical Structures</li> </ul> <p>Lenguajes y Paradigmas de Programaci\u00f3n, curso 2024-25 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Domingo Gallardo, Cristina Pomares, Antonio Bot\u00eda, Francisco Mart\u00ednez</p>"},{"location":"teoria/tema05-bis-programacion-imperativa/ambitos-let-clousures.html","title":"Ambitos let clousures","text":""},{"location":"teoria/tema05-bis-programacion-imperativa/ambitos-let-clousures.html#6-ambitos-de-variables-let-y-closures","title":"6. \u00c1mbitos de variables, let y closures","text":"<p>Ahora que hemos introducido la forma especial <code>lambda</code> y la idea de que una funci\u00f3n es un objeto de primera clase, podemos revisar el concepto de \u00e1mbito de variables en Scheme e introducir un importante concepto: clausura (closure en ingl\u00e9s).</p>"},{"location":"teoria/tema05-bis-programacion-imperativa/ambitos-let-clousures.html#61-ambitos-de-variables","title":"6.1. \u00c1mbitos de variables","text":"<p>El concepto del \u00e1mbito de vida de las variables es un concepto fundamental en los lenguajes de programaci\u00f3n. En ingl\u00e9s se utiliza el t\u00e9rmino scope.</p> <p>Cuando se define una variable, asoci\u00e1ndole un valor, esta asociaci\u00f3n tiene una extensi\u00f3n determinada, ya sea en t\u00e9rminos de tiempo de compilaci\u00f3n (\u00e1mbito l\u00e9xico) como en t\u00e9rminos de tiempo de ejecuci\u00f3n (\u00e1mbito din\u00e1mico). El \u00e1mbito de una variable determina cu\u00e1ndo podemos referirnos a ella para recuperar el valor asociado.</p> <p>Al conjunto de variables disponibles en una parte del programa o en una parte de su ejecuci\u00f3n se denomina contexto o entorno (context o environment).</p>"},{"location":"teoria/tema05-bis-programacion-imperativa/ambitos-let-clousures.html#variables-de-ambito-global","title":"Variables de \u00e1mbito global","text":"<p>Una variable definida en el programa con la instrucci\u00f3n <code>define</code> tiene un \u00e1mbito global.</p> <pre><code>(define a \"hola\")\n(define b (string-append \"adios\" a))\n(define cuadrado (lambda (x) (* x x)))\n</code></pre> <p>Todas las variables definidas fuera de funciones forman parte del entorno global del programa.</p>"},{"location":"teoria/tema05-bis-programacion-imperativa/ambitos-let-clousures.html#variables-de-ambito-local","title":"Variables de \u00e1mbito local","text":"<p>Como en la mayor\u00eda de lenguajes de programaci\u00f3n, en Scheme se crea un entorno local cada vez que se invoca a una funci\u00f3n. En este entorno local los argumentos de la funci\u00f3n toman los valores de los par\u00e1metros usados en la llamada a la funci\u00f3n. Consideramos, por tanto, estos par\u00e1metros como variables de \u00e1mbito local de la funci\u00f3n.</p> <p>Podemos usar en un entorno local una variable con el mismo nombre que en el entorno global. Cuando se ejecute el c\u00f3digo de la funci\u00f3n se evaluar\u00e1 la variable de \u00e1mbito local.</p> <p>Por ejemplo, supongamos las expresiones:</p> <pre><code>(define x 5)\n(define (suma-3 x)\n   (+ x 3))\n\n(suma-3 12)\n\u21d2 15\n</code></pre> <p>Cuando se ejecuta la expresi\u00f3n <code>(+ x 3)</code> en la invocaci\u00f3n a <code>(suma-3 12)</code> el valor de <code>x</code> es 12, no es 5, devolvi\u00e9ndose 15.</p> <p>Una vez realizada la invocaci\u00f3n, desparece el entorno local y las variables locales definidas en \u00e9l, recuper\u00e1ndose el contexto global. Por ejemplo, en la siguiente expresi\u00f3n, una vez realizada la invocaci\u00f3n a <code>(suma-3 12)</code> se devuelve el n\u00famero 15 y se eval\u00faa en el entorno global la expresi\u00f3n <code>(+ 15 x)</code>. En este contexto la variable <code>x</code> vale 5 por lo que la expresi\u00f3n devuelve 20.</p> <pre><code>(define x 5)\n(define (suma-3 x)\n   (+ x 3))\n\n(+ (suma-3 12) x)\n\u21d2 20\n</code></pre> <p>En el entorno local tambi\u00e9n se pueden utilizar variables definidas en el entorno global. Por ejemplo:</p> <pre><code>(define y 12)\n(define (suma-3-bis x)\n   (+ x y 3))\n\n(suma-3-bis 5) \n\u21d2 20\n</code></pre> <p>La expresi\u00f3n <code>(+ x 3 y)</code> se eval\u00faa en el entorno local en el que <code>x</code> vale 5. Al no estar definida la variable <code>y</code> en este entorno local, se usa su definici\u00f3n de \u00e1mbito global.</p>"},{"location":"teoria/tema05-bis-programacion-imperativa/ambitos-let-clousures.html#62-forma-especial-let","title":"6.2 Forma especial let","text":""},{"location":"teoria/tema05-bis-programacion-imperativa/ambitos-let-clousures.html#forma-especial-let","title":"Forma especial let","text":"<p>En Scheme se define la forma especial let que permite crear un entorno local en el que se da valor a variables y se eval\u00faa una expresi\u00f3n.</p> <p>Sintaxis:</p> <pre><code>(let ((&lt;var1&gt; &lt;exp-1&gt;)\n        ...\n      (&lt;varn&gt; &lt;exp-n&gt;))\n    &lt;cuerpo&gt;)\n</code></pre> <p>Las variables <code>var1</code>, \u2026 <code>varn</code> toman los valores devueltos por las expresiones <code>exp1</code>, \u2026 <code>expn</code> y el cuerpo se eval\u00faa con esos valores.</p> <p>Por ejemplo:</p> <pre><code>(define x 10)\n(define y 20)\n(let ((x 1)\n      (y 2)\n      (z 3))\n    (+ x y z))\n\u21d2 6\n</code></pre>"},{"location":"teoria/tema05-bis-programacion-imperativa/ambitos-let-clousures.html#el-ambito-de-las-variables-definidas-en-el-let-es-local","title":"El \u00e1mbito de las variables definidas en el let es local","text":"<p>Las variables definidas en el <code>let</code> s\u00f3lo tienen valores en el entorno creado por la forma especial.</p> <pre><code>(define x 10)\n(define y 20)\n(let ((x 1)\n      (y 2)\n      (z 3))\n    (+ x y z))\n\u21d2 6\n</code></pre> <p>Cuando ha terminado la evaluaci\u00f3n del <code>let</code> el \u00e1mbito local desaparece y quedan los valores definidos en el \u00e1mbito global.</p> <pre><code>x \u21d2 5\ny \u21d2 error, no definida\n</code></pre>"},{"location":"teoria/tema05-bis-programacion-imperativa/ambitos-let-clousures.html#let-permite-usar-variables-definidas-en-un-ambito-en-el-que-se-ejecuta-el-let","title":"<code>Let</code> permite usar variables definidas en un \u00e1mbito en el que se ejecuta el <code>let</code>","text":"<p>Al igual que en la invocaci\u00f3n a funciones, desde el \u00e1mbito definido por el <code>let</code> se puede usar las variables del entorno en el que se est\u00e1 ejecutando el <code>let</code>. Por ejemplo, en el siguiente c\u00f3digo se usa la variable z definida en el \u00e1mbito global.</p> <pre><code>(define z 8)\n(let ((x 1)\n      (y 2))\n   (+ x y z))\n\u21d2 11\n</code></pre>"},{"location":"teoria/tema05-bis-programacion-imperativa/ambitos-let-clousures.html#variables-en-las-definiciones-del-let","title":"Variables en las definiciones del <code>let</code>","text":"<p>Las expresiones que dan valor a las variables del <code>let</code> se eval\u00faan todas en el entorno en el que se ejecuta el <code>let</code>, antes de crear las variables locales.  No se realiza una asignaci\u00f3n secuencial:</p> <pre><code>(define x 1)\n(let ((w (+ x 3))\n      (z (+ w 2))) ;; Error: w no est\u00e1 definida\n    (+ w z))\n</code></pre>"},{"location":"teoria/tema05-bis-programacion-imperativa/ambitos-let-clousures.html#semantica-del-let","title":"Sem\u00e1ntica del <code>let</code>","text":"<p>Para evaluar una expresi\u00f3n <code>let</code> debemos seguir las siguientes reglas:</p> <ol> <li>Evaluar todas las expresiones de la derecha de las variables y    guardar sus valores en variables auxiliares locales.</li> <li>Definir un \u00e1mbito local en el que se ligan las variables del let    con los valores de las variables auxiliares.</li> <li>Evaluar el cuerpo del let en el \u00e1mbito local</li> </ol>"},{"location":"teoria/tema05-bis-programacion-imperativa/ambitos-let-clousures.html#let-se-define-utilizando-lambda","title":"Let se define utilizando lambda","text":"<p>La sem\u00e1ntica anterior queda clara cuando comprobamos que let se puede definir en funci\u00f3n de lambda. En general, la expresi\u00f3n:</p> <pre><code>(let ((&lt;var1&gt; &lt;exp1&gt;) ... (&lt;varn&gt; &lt;expn&gt;)) &lt;cuerpo&gt;)\n</code></pre> <p>se puede implementar con la siguiente llamada a lambda:</p> <pre><code>((lambda (&lt;var1&gt; ... &lt;varn&gt;) &lt;cuerpo&gt;) &lt;exp1&gt; ... &lt;expn&gt;)\n</code></pre> <p>Para ejecutar un <code>let</code> con un <code>lambda</code> se debe crear un procedimiento en tiempo de ejecuci\u00f3n con tantas variables como las variables del <code>let</code>, con el cuerpo del <code>let</code>, y se debe invocar a dicho procedimiento con las expresiones de las variables del <code>let</code>. Esas expresiones se eval\u00faan antes de invocar al procedimiento y la invocaci\u00f3n se realiza con los resultados. La invocaci\u00f3n crea un entorno local con los par\u00e1metros del procedimiento (las variables del <code>let</code>) asociados a los valores, y en este \u00e1mbito local se ejecuta el cuerpo del procedimiento (el cuerpo del <code>let</code>).</p> <p>Por ejemplo:</p> <pre><code>(let ((x (+ 2 3))\n      (y (+ x 3)))\n    (+ x y))\n</code></pre> <p>Equivale a:</p> <pre><code>((lambda (x y) (+ x y)) (+ 2 3) (+ x 3))\n</code></pre>"},{"location":"teoria/tema05-bis-programacion-imperativa/ambitos-let-clousures.html#let-dentro-de-funciones","title":"Let dentro de funciones","text":"<p>Podemos usar <code>let</code> en el cuerpo de funciones para crear nuevas variables locales, adem\u00e1s de los par\u00e1metros de la funci\u00f3n</p> <pre><code>(define (suma-cuadrados x y)\n    (let ((cuadrado-x (cuadrado x))\n          (cuadrado-y (cuadrado y)))\n        (+ cuadrado-x cuadrado-y)))\n(suma-cuadrados 4 10)\n\u21d2 116\n</code></pre> <p>Cuando se invoca <code>(suma-cuadrados 4 10)</code> se crea un entorno local en el que las variables <code>x</code> e <code>y</code> toman el valor <code>4</code> y <code>10</code> y en el que se ejecuta la forma especial <code>let</code>. Esta forma especial crea a su vez un entorno local en el que se definen las variables <code>cuadrado-x</code> y <code>cuadrado-y</code> que toman los valores devueltos por las expresiones <code>(cuadrado x)</code> y <code>(cuadrado y)</code>: <code>16</code> y <code>100</code>. En este entorno local se eval\u00faa la expresi\u00f3n <code>(+ cuadrado-x cuadrado-y)</code>.</p> <p>El uso de <code>let</code> permite aumentar la legibilidad de los programas, dando nombre a expresiones:</p> <p>Por ejemplo:</p> <pre><code>(define (distancia x1 y1 x2 y2)\n   (let ((distancia-x (- x2 x1))\n         (distancia-y (- y2 y1)))\n      (sqrt (+ (cuadrado distancia-x)\n               (cuadrado distancia-y)))))\n</code></pre> <p>Otro ejemplo:</p> <pre><code>(define (intersecta-intervalo a1 a2 b1 b2)\n    (let ((dentro-b1 (and (&gt;= b1 a1)\n                          (&lt;= b1 a2)))\n          (dentro-b2 (and (&gt;= b2 a1)\n                          (&lt;= b2 a2))))\n        (or dentro-b1 dentro-b2)))\n</code></pre>"},{"location":"teoria/tema05-bis-programacion-imperativa/ambitos-let-clousures.html#63-clausuras","title":"6.3. Clausuras","text":"<p>Vamos a terminar explicando el concepto de clausura. Hemos visto que las funciones son objetos de primera clase de Scheme y que es posible crear funciones en tiempo de ejecuci\u00f3n con la forma especial <code>lambda</code>.</p> <p>Una clausura es una funci\u00f3n devuelta por otra funci\u00f3n. La clausura captura las variables locales de la funci\u00f3n principal y puede usarlas en su propio c\u00f3digo cuando este se invoque posteriormente.</p> <p>Veamos un ejemplo. Supongamos que definimos la siguiente funci\u00f3n <code>(make-sumador k)</code> que devuelve otra funci\u00f3n.</p> <pre><code>(define (make-sumador k)\n    (lambda (x) (+ x k)))\n\n(define f (make-sumador 10))\n(f 2)\n\u21d2 12\n</code></pre> <p>En la funci\u00f3n <code>(make-sumador k)</code> se llama a la forma especial lambda para crear un procedimiento. El procedimiento devuelto es lo que se denomina clausura. En este caso la clausura captura la variable local <code>k</code> (el par\u00e1metro de <code>make-sumador</code>) y usa su valor cuando posteriormente se invoca. Cuando se invoca a <code>(f 2)</code> se ejecuta la clausura y se crea un nuevo entorno local en el que <code>x</code> (el par\u00e1metro de la clausura) vale <code>2</code> y en el que se usa la variable <code>k</code> capturada.</p> <p>En la invocaci\u00f3n anterior <code>(f 2)</code>, cuando se ejecuta la expresi\u00f3n <code>(+ x k)</code> las variables tienen los siguientes valores:</p> <pre><code>x: 2 (variable local de la clausura)\nk: 10 (valor capturado del entorno local en el que se cre\u00f3 la clausura\n</code></pre>"},{"location":"teoria/tema05-bis-programacion-imperativa/ambitos-let-clousures.html#las-variables-locales-creadas-en-un-let-tambien-se-capturan-en-las-clausuras","title":"Las variables locales creadas en un <code>let</code> tambi\u00e9n se capturan en las clausuras","text":"<p>Veamos el siguiente ejemplo, en el que creamos una funci\u00f3n en un entorno local creado por un <code>let</code>:</p> <pre><code>(define x 10)\n(define y 12)\n(define (prueba x)\n    (let ((y 3))\n        (lambda (z) \n            (+ x y z))))\n(define h (prueba 5))\n(h 2)\n\u21d2 8\n</code></pre> <p>Sucede lo siguiente:</p> <ol> <li>Se invoca la expresi\u00f3n <code>(prueba 5)</code>. Esto crea un entorno local en    el que se le da a la variable <code>x</code> (el par\u00e1metro de <code>prueba</code>) el    valor <code>5</code>. En este contexto se ejecuta el <code>let</code>, que crea otro    entorno local en el que <code>y</code> vale 3. En el contexto del <code>let</code> se    crea una clausura con la invocaci\u00f3n de la expresi\u00f3n lambda <code>(lambda    (z) (+ x y z))</code>.</li> <li>La clausura captura las variables locales <code>x</code> e <code>y</code> con sus valores    5 y 3 y la funci\u00f3n <code>prueba</code> la devuelve como resultado de la    invocaci\u00f3n.</li> <li>La clausura se guarda en la variable <code>h</code>.</li> <li> <p>Con la invocaci\u00f3n <code>(h 2)</code> se invoca a la clausura, lo que crea un    entorno local en el que se encuentran las siguientes variables:</p> <pre><code>z: 2 (par\u00e1metro de la clausura)\nx: 5 (variable local de la funci\u00f3n prueba capturada en el momento de creaci\u00f3n de la clausura))\ny: 3 (variable local del let capturada en el momento de creaci\u00f3n de la clausura)\n</code></pre> </li> <li> <p>En este contexto se ejecuta la expresi\u00f3n <code>(+ x y z)</code>, que devuelve 10.</p> </li> </ol> <p>Lenguajes y Paradigmas de Programaci\u00f3n, curso 2015-16 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Domingo Gallardo, Cristina Pomares</p>"},{"location":"teoria/tema05-bis-programacion-imperativa/tema05-programacion-imperativa.html","title":"Tema 5: Programaci\u00f3n imperativa","text":""},{"location":"teoria/tema05-bis-programacion-imperativa/tema05-programacion-imperativa.html#contenidos","title":"Contenidos","text":"<ul> <li>1. Historia y caracter\u00edsticas de la programaci\u00f3n imperativa<ul> <li>1.1. Historia de la programaci\u00f3n imperativa</li> <li>1.2. Caracter\u00edsticas principales de la programaci\u00f3n imperativa</li> </ul> </li> <li>2. Programaci\u00f3n imperativa en Scheme<ul> <li>2.1. Pasos de ejecuci\u00f3n</li> <li>2.2. Mutaci\u00f3n con formas especiales set!</li> <li>2.3. Igualdad de referencia y de valor</li> </ul> </li> <li>3. Estructuras de datos mutables<ul> <li>3.1. Mutaci\u00f3n de elementos</li> <li>3.2. Funciones mutadoras: <code>make-ciclo!</code>, <code>append!</code> y <code>intercambia!</code></li> <li>3.3. Lista ordenada mutable</li> <li>3.4. Diccionario mutable</li> <li>3.5. Ejemplo de mutaci\u00f3n con listas de asociaci\u00f3n</li> </ul> </li> <li>4. \u00c1mbitos de variables y clausuras<ul> <li>4.1. Variables de \u00e1mbito global</li> <li>4.2. Variables de \u00e1mbito local</li> <li>4.3. Clausuras y estado local</li> </ul> </li> <li>5. Clausuras con mutaci\u00f3n = estado local mutable<ul> <li>5.1. Estado local mutable</li> <li>5.2. Paso de mensajes</li> </ul> </li> </ul>"},{"location":"teoria/tema05-bis-programacion-imperativa/tema05-programacion-imperativa.html#bibliografia","title":"Bibliograf\u00eda","text":"<p>En este tema explicamos conceptos de los siguientes cap\u00edtulos del libro Structure and Intepretation of Computer Programs:</p> <ul> <li>3.3.1 Mutable List Structure</li> <li>3.3.2 Representing Queues</li> <li>3.3.3 Representing tables</li> <li>3.1.1 Local State Variables</li> <li>3.1.3 The Cost of Introducing Assignment</li> </ul>"},{"location":"teoria/tema05-bis-programacion-imperativa/tema05-programacion-imperativa.html#1-historia-y-caracteristicas-de-la-programacion-imperativa","title":"1. Historia y caracter\u00edsticas de la programaci\u00f3n imperativa","text":""},{"location":"teoria/tema05-bis-programacion-imperativa/tema05-programacion-imperativa.html#11-historia-de-la-programacion-imperativa","title":"1.1. Historia de la programaci\u00f3n imperativa","text":""},{"location":"teoria/tema05-bis-programacion-imperativa/tema05-programacion-imperativa.html#111-origenes-de-la-programacion-imperativa","title":"1.1.1. Or\u00edgenes de la programaci\u00f3n imperativa","text":"<ul> <li>La programaci\u00f3n imperativa es la forma natural de programar un   computador, es el estilo de programaci\u00f3n que se utiliza en el   ensamblador, el estilo m\u00e1s cercano a la arquitectura del computador</li> <li>Caracter\u00edsticas de la arquitectura   arquitectura cl\u00e1sica de Von Newmann:<ul> <li>memoria donde se almacenan los datos (referenciables por su   direcci\u00f3n de memoria) y el programa</li> <li>unidad de control que ejecuta las instrucciones del programa   (contador del programa)</li> <li>Los primeros lenguajes de programaci\u00f3n (como el Fortran) son   abstracciones del ensamblador y de esta arquitectura. Lenguajes   m\u00e1s modernos como el BASIC o el C han continuado con esta idea.</li> </ul> </li> </ul>"},{"location":"teoria/tema05-bis-programacion-imperativa/tema05-programacion-imperativa.html#112-programacion-procedural","title":"1.1.2. Programaci\u00f3n procedural","text":"<ul> <li>Uso de procedimientos y subrutinas</li> <li>Los cambios de estado se localizan en estos procedimientos</li> <li>Los procedimientos especifican par\u00e1metros y valores devueltos (un   primer paso hacia la abstracci\u00f3n y los modelos funcionales y   declarativos)</li> <li>Primer lenguaje con estas ideas: ALGOL</li> </ul>"},{"location":"teoria/tema05-bis-programacion-imperativa/tema05-programacion-imperativa.html#113-programacion-estructurada","title":"1.1.3. Programaci\u00f3n estructurada","text":"<ul> <li>Art\u00edculo a finales de los 60 de Edsger W. Dijkstra:   GOTO statement considered harmful   en el que se arremete contra la sentencia GOTO de muchos lenguajes   de programaci\u00f3n de la \u00e9poca</li> <li>La programaci\u00f3n estructurada mantiene la programaci\u00f3n imperativa,   pero haciendo \u00e9nfasis en la necesidad de que los programas sean   correctos (debe ser posible de comprobar formalmente los programas),   modulares y mantenibles.</li> <li>Lenguajes: Pascal, ALGOL 68, Ada</li> </ul>"},{"location":"teoria/tema05-bis-programacion-imperativa/tema05-programacion-imperativa.html#114-programacion-orientada-a-objetos","title":"1.1.4. Programaci\u00f3n Orientada a Objetos","text":"<ul> <li>La POO tambi\u00e9n utiliza la programaci\u00f3n imperativa, aunque extiende   los conceptos de modularidad, mantenibilidad y estado local</li> <li>Se populariza a finales de los 70 y principios de los 80</li> </ul>"},{"location":"teoria/tema05-bis-programacion-imperativa/tema05-programacion-imperativa.html#12-caracteristicas-principales-de-la-programacion-imperativa","title":"1.2. Caracter\u00edsticas principales de la programaci\u00f3n imperativa","text":"<ul> <li>Idea principal de la programaci\u00f3n imperativa: la computaci\u00f3n se   realiza cambiando el estado del programa por medio de sentencias que   definen pasos de ejecuci\u00f3n del computador</li> <li>Estado del programa modificable</li> <li>Sentencias de control que definen pasos de ejecuci\u00f3n</li> </ul> <p>Vamos a ver unos ejemplos de estas caracter\u00edsticas usando el lenguaje de programaci\u00f3n Java.</p>"},{"location":"teoria/tema05-bis-programacion-imperativa/tema05-programacion-imperativa.html#121-modificacion-de-datos","title":"1.2.1. Modificaci\u00f3n de datos","text":"<ul> <li>Uno de los elementos de la arquitectura de Von Newmann es la   existencia de celdas de memoria referenciables y modificables</li> </ul> <pre><code>int x = 0;\nx = x + 1;\n</code></pre> <ul> <li>Otro ejemplo t\u00edpico de este concepto en los lenguajes de   programaci\u00f3n es el array: una estructura de datos que se almacena   directamente en memoria y que puede ser accedido y modificado.</li> <li>En Java los arrays son tipeados, mutables y de tama\u00f1o fijo</li> </ul> <pre><code>String[] unoDosTres = {\"uno\",\"dos\",\"tres\"};\nunoDosTres[0] = unoDosTres[2];\n</code></pre> <ul> <li>Un ejemplo de un m\u00e9todo que recibe un par\u00e1metro de tipo array en   Java. El par\u00e1metro se pasa por referencia:</li> </ul> <pre><code>public void llenaCadenas(String[] cadenas, String cadena) {\n    for (int i = 0; i &lt; cadenas.length; i++) {\n        cadenas[i] = cadena;\n    }\n}\n</code></pre> <ul> <li>Todos los ejemplos anteriores en un programa <code>main</code> Java:</li> </ul> <pre><code>public class Main {\n\n    public static void main(String[] args) {\n        int x = 0;\n        x = x + 1;\n        System.out.println(\"x: \" + x);\n        String[] unoDosTres = {\"uno\",\"dos\",\"tres\"};\n        unoDosTres[0] = unoDosTres[2];\n        for (String valor : unoDosTres) {\n            System.out.println(valor);\n        }\n        llenaCadenas(unoDosTres, \"uno\");\n        for (String valor : unoDosTres) {\n            System.out.println(valor);\n        }\n    }\n\n    public static void llenaCadenas(String[] cadenas, String cadena) {\n        for (int i = 0; i &lt; cadenas.length; i++) {\n            cadenas[i] = cadena;\n        }\n    }\n}\n</code></pre>"},{"location":"teoria/tema05-bis-programacion-imperativa/tema05-programacion-imperativa.html#122-almacenamiento-de-datos-en-variables","title":"1.2.2. Almacenamiento de datos en variables","text":"<ul> <li>Todos los lenguajes de programaci\u00f3n definen variables que contienen   datos</li> <li>Las variables pueden mantener valores (tipos de valor o value types)   o referencias (tipos de referencia o reference types)</li> <li>En C, C++ o Java, los datos primitivos como int o char son de tipo   valor y los objetos y datos compuestos son de tipo referencia</li> <li>La asignaci\u00f3n de un valor a una variable tiene implicaciones   distintas si el tipo es de valor (se copia el valor) o de referencia   (se copia la referencia)</li> </ul> <p>Copia de valor (datos primitivos en Java):</p> <pre><code>int x = 10;\nint y = x;\nx = 20;\nSystem.out.println(y); // Sigue siendo 10\n</code></pre> <p>Copia de referencia (objetos en Java):</p> <pre><code>// import java.awt.geom.Point2D;\nPoint2D p1 = new Point2D.Double(2.0, 3.0);\nPoint2D p2 = p1;\np1.setLocation(12.0, 13.0);\nSystem.out.println(\"p2.x = \" + p2.getX()); // 12.0\nSystem.out.println(\"p2.y = \" + p2.getY()); // 13.0\n</code></pre> <ul> <li>El uso de las referencias para los objetos de clases y para los   tipos compuestos est\u00e1 generalizado en la mayor\u00eda de lenguajes de   programaci\u00f3n</li> <li>Tiene efectos laterales pero permite obtener estructuras de datos   eficientes</li> </ul>"},{"location":"teoria/tema05-bis-programacion-imperativa/tema05-programacion-imperativa.html#123-igualdad-de-valor-y-de-referencia","title":"1.2.3. Igualdad de valor y de referencia","text":"<ul> <li>Todos los lenguajes de programaci\u00f3n imperativos que permite la   distinci\u00f3n entre valores y referencias implementan dos tipos de   igualdad entre variables</li> <li>Igualdad de valor (el contenido de los datos de las variables es el   mismo)</li> <li>Igualdad de referencia (las variables tienen la misma referencia)</li> <li> <p>Igualdad de referencia =&gt; Igualdad de valor (pero al rev\u00e9s no)</p> </li> <li> <p>En Java la igualdad de referencia se define con <code>==</code> y la de valor   con el m\u00e9todo <code>equals</code>:</p> </li> </ul> <pre><code>Point2D p1 = new Point2D.Double(2.0, 3.0);\nPoint2D p2 = p1;\nPoint2D p3 = new Point2D.Double(2.0, 3.0);\nSystem.out.println(p1==p2);           // true\nSystem.out.println(p1==p3);           // false\nSystem.out.println(p1.equals(p3));    // true\n</code></pre>"},{"location":"teoria/tema05-bis-programacion-imperativa/tema05-programacion-imperativa.html#124-sentencias-de-control","title":"1.2.4. Sentencias de control","text":"<ul> <li>Tambi\u00e9n tiene su origen en la arquitectura de Von Newmann</li> <li>Sentencia que modifica el contador de programa y determina cu\u00e1l ser\u00e1   la siguiente instrucci\u00f3n a ejecutar</li> <li>Tipos de sentencias de control en programaci\u00f3n estructurada:<ul> <li>Las sentencias de secuencia definen instrucciones que son ejecutados una detr\u00e1s de otra de  forma s\u00edncrona. Una instrucci\u00f3n no comienza hasta que la anterior ha terminado.</li> <li>Las sentencias de selecci\u00f3n definen una o m\u00e1s condiciones que determinan las instrucciones  que se deber\u00e1n ejecutar.</li> <li>Las sentencias de iteraci\u00f3n definen instrucciones que se ejecutan de forma repetitiva hasta  que se cumple una determinada condici\u00f3n.</li> </ul> </li> </ul> <p>Bucles y variables</p> <p>Ejemplo imperativo que imprime en Java una tabla con los productos de los n\u00fameros del 1 al 9:</p> <pre><code>for (int i = 1; i &lt;= 9 ; i++) {\n    System.out.println(\"Tabla del \" + i);\n    System.out.println(\"-----------\");\n    for (int j = 1; j &lt;= 9; j++) {\n        System.out.println(i + \" * \" + j + \" = \" + i * j);\n    }\n    System.out.println();\n}\n</code></pre>"},{"location":"teoria/tema05-bis-programacion-imperativa/tema05-programacion-imperativa.html#2-programacion-imperativa-en-scheme","title":"2. Programaci\u00f3n imperativa en Scheme","text":"<ul> <li>Al igual que LISP, Scheme tiene caracter\u00edsticas imperativas</li> <li>Vamos a ver algunas de ellas<ul> <li>Pasos de ejecuci\u00f3n</li> <li>Asignaci\u00f3n con la forma especial <code>set!</code></li> <li>Datos mutables con las formas especiales <code>set-car!</code> y <code>set-cdr!</code></li> </ul> </li> <li>Una nota importante: todos los ejemplos que hay a continuaci\u00f3n   necesitan importar la librer\u00eda <code>mutable-pairs</code>:</li> </ul> <pre><code>#lang r6rs\n(import (rnrs)\n      (rnrs mutable-pairs))\n</code></pre>"},{"location":"teoria/tema05-bis-programacion-imperativa/tema05-programacion-imperativa.html#21-pasos-de-ejecucion","title":"2.1. Pasos de ejecuci\u00f3n","text":"<ul> <li>Es posible definir pasos de ejecuci\u00f3n con la forma especial <code>begin</code></li> <li>Todas las sentencias de la forma especial se ejecutan de forma   secuencial, una tras otra</li> <li>Tanto en la definici\u00f3n de funciones como en <code>lambda</code> es   posible definir cuerpos de funci\u00f3n con m\u00faltiples sentencias que se   ejecutan tambi\u00e9n de forma secuencial. Hasta ahora no hemos usado   esta caracter\u00edstica porque hemos utilizado Scheme de forma   funcional.</li> </ul> <p>Ejemplo <code>begin</code>:</p> <pre><code>(begin\n    (display \"Escribe un n\u00famero: \")\n    (define x (read))\n    (display \"Escribe otro: \")\n    (define y (read))\n    (define maximo (max x y))\n    (display (string-append \"El m\u00e1ximo de \"\n                        (number-&gt;string x)\n                        \" y \"\n                        (number-&gt;string y)\n                        \" es \"\n                       (number-&gt;string maximo))))\n</code></pre> <p>Ejemplo de pasos de ejecuci\u00f3n en la definici\u00f3n de una funci\u00f3n:</p> <pre><code>(define (display-tres-valores a b c)\n    (display a)\n    (newline)\n    (display b)\n    (newline)\n    (display c)\n    (newline))\n</code></pre>"},{"location":"teoria/tema05-bis-programacion-imperativa/tema05-programacion-imperativa.html#22-mutacion-con-formas-especiales-set","title":"2.2. Mutaci\u00f3n con formas especiales set!","text":""},{"location":"teoria/tema05-bis-programacion-imperativa/tema05-programacion-imperativa.html#221-forma-especial-set","title":"2.2.1. Forma especial <code>set!</code>","text":"<ul> <li>La forma especial <code>set!</code> permite asignar un nuevo valor a una   variable</li> <li>La variable debe haber sido previamente creada con <code>define</code></li> <li>La forma especial no devuelve ning\u00fan valor, modifica el valor de la   variable usada</li> </ul> <p>Sintaxis:</p> <pre><code>(set! &lt;variable&gt; &lt;nuevo-valor&gt;)\n</code></pre> <p>Por ejemplo, la t\u00edpica asignaci\u00f3n de los lenguajes imperativos se puede realizar de esta forma en Scheme:</p> <pre><code>(define a 10)\n(set! a (+ a 1))\na  ; \u21d2 11\n</code></pre> <p>La forma especial <code>set!</code> funciona con cualquier tipo de datos. Por ejemplo, utilizando la caracter\u00edstica de que Scheme es d\u00e9bilmente tipeado, puede incluso asignar un nuevo tipo de valor a una variable:</p> <pre><code>(define a \"Hola\")\na ; \u21d2 \"Hola\"\n(set! a (cons 1 2))\na ; \u21d2 {1 . 2}\n</code></pre>"},{"location":"teoria/tema05-bis-programacion-imperativa/tema05-programacion-imperativa.html#222-datos-mutables","title":"2.2.2. Datos mutables","text":"<ul> <li>En Scheme se definen las formas especiales <code>set-car!</code> y <code>set-cdr!</code>   que permite modificar (mutar) la parte izquierda o derecha de una   pareja una vez creada</li> <li>Al igual que <code>set!</code>, no devuelven ning\u00fan valor</li> </ul> <p>Sintaxis:</p> <pre><code>(set-car! &lt;pareja&gt; &lt;nuevo-valor&gt;)\n(set-cdr! &lt;pareja&gt; &lt;nuevo-valor&gt;)\n</code></pre> <p>Ejemplo</p> <pre><code>(define p (cons 1 2))\n(set-car! p 10)\n(set-cdr! p 20)\np   ; \u21d2 (10 . 20)\n</code></pre>"},{"location":"teoria/tema05-bis-programacion-imperativa/tema05-programacion-imperativa.html#223-efectos-laterales","title":"2.2.3. Efectos laterales","text":"<ul> <li>La introducci\u00f3n de la asignaci\u00f3n y los datos mutables hace posible   que Scheme se comporte como un lenguaje imperativo en el que m\u00e1s de   una variable apunta a un mismo valor y se producen efectos laterales</li> <li>Un efecto lateral se produce cuando el valor de una variable cambia   debido a una sentencia en la que no aparece la variable</li> <li>Podemos comprobar ahora que las parejas son datos que se copian por   referencia</li> </ul> <p>Ejemplo:</p> <pre><code>(define p1 (cons 1 2))\n(define p2 p1)\np1 ; \u21d2 (1 . 2)\np2 ; \u21d2 (1 . 2)\n(set-car! p1 20)\np1 ; \u21d2 (20 . 2)\np2 ; \u21d2 (20 . 2)\n</code></pre>"},{"location":"teoria/tema05-bis-programacion-imperativa/tema05-programacion-imperativa.html#23-igualdad-de-referencia-y-de-valor","title":"2.3. Igualdad de referencia y de valor","text":"<ul> <li>La utilizaci\u00f3n de referencias, la mutaci\u00f3n y los efectos laterales   hace tambi\u00e9n necesario definir dos tipos de igualdades: igualdad de   referencia e igualdad de valor.</li> <li>Igualdad de referencia: dos variables son iguales cuando apuntan al   mismo valor</li> <li>Igualdad de valor: dos variables son iguales cuando contienen el   mismo valor</li> <li>En Scheme la funci\u00f3n <code>eq?</code> comprueba la igualdad de referencia y   <code>equal?</code> la igualdad de valor</li> <li>Igualdad de referencia implica igualdad de valor, pero no al rev\u00e9s</li> </ul> <p>Ejemplo:</p> <pre><code>(define p1 (cons 10 20))\n(define p2 p1)\n(define p3 (cons 10 20))\n(equal? p3 p1)  ; \u21d2 #t\n(eq? p3 p1) ; \u21d2 #f\n(eq? p2 p1) ; \u21d2 #t\n(set! p3 p1) ;; La asignaci\u00f3n copia referencias\n(eq? p3 p1) ; \u21d2 #t\n</code></pre>"},{"location":"teoria/tema05-bis-programacion-imperativa/tema05-programacion-imperativa.html#3-estructuras-de-datos-mutables","title":"3. Estructuras de datos mutables","text":"<ul> <li>La utilizaci\u00f3n de las formas especiales <code>set-car!</code> y <code>set-cdr!</code>   permite un estilo nuevo de manejo de las estructuras de datos ya   vistas (listas o \u00e1rboles)</li> <li>Es posible implementar funciones m\u00e1s eficientes que actualizan la   estructura modificando directamente las referencias de unas celdas a   otras</li> <li>Las operaciones no construyen estructuras nuevas, sino que modifican   la ya existente</li> </ul>"},{"location":"teoria/tema05-bis-programacion-imperativa/tema05-programacion-imperativa.html#31-mutacion-de-elementos","title":"3.1. Mutaci\u00f3n de elementos","text":"<p>Ejemplo 1</p> <p>Vamos a empezar con un ejemplo sencillo en el que vamos a mutar un elemento de una estructura de datos formada por parejas. Supongamos la siguiente estructura:</p> <pre><code>(define datos (cons 2\n                    (cons (cons 5\n                                (cons 8 9))\n                          (cons 3 4))))\n</code></pre> <p>El diagrama box-and-pointer es el siguiente. F\u00edjate que hay elementos de las parejas que son datos at\u00f3micos y otros que son referencias a otras parejas.</p> <p></p> <p>Vamos ahora a mutar la estructura utilizando las sentencias <code>set-car!</code> y <code>set-cdr!</code>. Para mutar una pareja acceder a la pareja y modificar su parte derecha o su parte izquierda con las sentencias anteriores.</p> <p>Por ejemplo, \u00bfc\u00f3mo cambiar\u00edamos el <code>8</code> por un <code>18</code>? Deber\u00edamos obtener la pareja <code>(8 . 9)</code> que est\u00e1 al final de la estructura y modificar su parte izquierda:</p> <pre><code>(set-car! (cdr (car (cdr datos))) 18)\n</code></pre> <p>La expresi\u00f3n <code>(cdr (car (cdr datos)))</code> devuelve la pareja que queremos modificar y la sentencia <code>set-car!</code> modifica su parte izquierda.</p> <p>Si ahora vemos qu\u00e9 hay en <code>datos</code> veremos que se ha modificado la estructura:</p> <pre><code>(print-pareja datos)\n; \u21d2 (2 . ((5 . (18 . 9)) . (3 . 4)))\n</code></pre> <p>Recuerda que <code>print-pareja</code> es una funci\u00f3n que vimos anteriormente.</p> <p>Hemos mutado un dato por otro. Tambi\u00e9n podemos mutar las referencias a las parejas. Por ejemplo, podr\u00edamos modificar la parte derecha de la pareja que contiene el 5 para que apunte a la pareja <code>(3 . 4)</code>:</p> <p></p> <p>Para ello habr\u00eda que obtener la pareja que contiene el 5 con la expresi\u00f3n <code>(car (cdr datos))</code> y mutar su parte derecha (<code>set-cdr!</code>) con la referencia a la pareja <code>(3 . 4)</code> que se obtiene con la expresi\u00f3n <code>(cdr (cdr datos))</code>:</p> <pre><code>(set-cdr! (car (cdr datos)) (cdr (cdr datos)))\n</code></pre> <p>Ejemplo 2</p> <p>Veamos un segundo ejemplo. </p> <p>Supongamos las siguientes sentencias. \u00bfCu\u00e1l ser\u00eda el box-and-pointer resultante? </p> <pre><code>(define x '((a b) c d))\n(define y '(e f))\n(set-car! x y)\n(define z (cons y (cdr x)))\n(set-cdr! x y)\n(set-car! z (caar x))\n</code></pre> <p>Debemos ir paso a paso ejecutando cada instrucci\u00f3n y dibujando c\u00f3mo cambia el diagrama. El diagrama representa el estado del programa, y es un conjunto de parejas que contienen valores y referencias entre ellas. </p> <p>Es muy importante considerar cu\u00e1ndo la sentencia copia un valor y cuando copia una referencia. Las parejas siempre tienen sem\u00e1ntica de referencia.</p> <p>El diagrama resultante despu\u00e9s de las dos primeras sentencias es:</p> <p></p> <p>Y el diagrama despu\u00e9s de todas las sentencias es:</p> <p></p> <p>Los valores de las variables despu\u00e9s de todas las sentencias son los siguientes:</p> <pre><code>x ; \u21d2 {{e f} e f}\ny ; \u21d2 {e f}\nz ; \u21d2 {e c d}\n</code></pre> <p>Ejemplo 3</p> <p>En este ejemplo vamos a usar una nueva forma especial de Scheme que permite crear variables locales y ejecutar expresiones en las que se utilicen esas variables. </p> <p>Se trata de la forma especial <code>let</code>. Veremos algo m\u00e1s de esta forma especial m\u00e1s adelante, cuando hablemos de \u00e1mbitos de variables. Por ahora es suficiente saber que permite crear variables locales y ejecutar un cuerpo (que puede tener m\u00e1s de una sentencia) con esas variables.</p> <pre><code>(let ((x (+ 2 3))\n      (y (* 2 10))\n    (+ x y))\n; \u21d2 25\n</code></pre> <p>En este caso <code>let</code> permite crear dos variables locales <code>x</code> e <code>y</code> y asignarles los valores <code>5</code> y <code>20</code> respectivamente. Las sentencias del cuerpo del <code>let</code> (en este caso la sentencia <code>(+ x y)</code>) se eval\u00faan con estos valores reci\u00e9n creados.</p> <p>Vamos a usar esta forma especial en ocasiones para guardar valores o referencias que despu\u00e9s necesitamos asignar.</p> <p>Por ejemplo, \u00bfc\u00f3mo podr\u00edamos definir una funci\u00f3n que mute las referencias de una lista para intercambiar sus posiciones segunda y tercera (sin crear nuevas parejas)?</p> <p>Si llamamos a la funci\u00f3n <code>intercambia!</code> deber\u00eda hacer lo siguiente:</p> <pre><code>(define lista '(1 2 3 4 5 6))\n(intercambia! lista)\nlista ; \u21d2 {1 3 2 4 5 6}\n</code></pre> <p>Dibujando el diagrama box-and-pointer podemos ver las mutaciones que tenemos que hacer:</p> <p></p> <p>La funci\u00f3n es la siguiente:</p> <pre><code>(define (intercambia! lista)\n    (let ((segundo (cdr lista))\n          (tercero (cddr lista)))\n        (set-cdr! lista tercero)\n        (set-cdr! segundo (cdr tercero))\n        (set-cdr! tercero segundo)))\n</code></pre>"},{"location":"teoria/tema05-bis-programacion-imperativa/tema05-programacion-imperativa.html#32-funciones-mutadoras-make-ciclo-append-e-intercambia-lista","title":"3.2. Funciones mutadoras: <code>make-ciclo!</code>, <code>append!</code> e <code>intercambia-lista!</code>","text":"<p>Veamos ahora varios ejemplos de funciones recursivas que recorren listas y realizan mutaciones en ellas.</p> <p>Normalmente las funciones mutadoras no devuelven una estructura, sino que modifican la que se pasa como par\u00e1metro.</p> <p>Por convenio, indicaremos que una funci\u00f3n es mutadora terminando su nombre con un signo de admiraci\u00f3n.</p> <p>make-ciclo!</p> <p>Empecemos con una funci\u00f3n muta una lista, haciendo que la parte derecha de la \u00faltima pareja apunte a la pareja inicial de la misma.</p> <p></p> <p>Para conseguirlo, necesitamos guardar la referencia a la pareja inicial de la lista en el primer par\u00e1metro de la funci\u00f3n. Y el segundo par\u00e1metro ir\u00e1 avanzando hasta encontrar el final de la lista:</p> <pre><code>(define (make-ciclo! lista ref)\n    (if (null? (cdr ref))\n        (set-cdr! ref lista)\n        (make-ciclo! lista (cdr ref))))\n</code></pre> <p>Si probamos la funci\u00f3n con una lista, podemos comprobar que DrRacket detecta el ciclo que se produce al final de la misma:</p> <pre><code>(define lista '(1 2 3 4 5 6))\n(make-ciclo! lista lista)\nlista ; \u21d2 #0={1 2 3 4 5 6 . #0#}\n</code></pre> <p>Una forma alternativa de implementar esta funci\u00f3n es mediante una funci\u00f3n que devuelva la referencia de la \u00faltima pareja de la lista:</p> <pre><code>(define (ultima-pareja lista)\n    (if (null? (cdr lista))\n        lista\n        (ultima-pareja (cdr lista))))\n\n(define (make-ciclo2! lista)\n    (let ((ultima-pareja (ultima-pareja lista)))\n        (set-cdr! ultima-pareja lista)))\n</code></pre> <p>append!</p> <p>Y vemos a continuaci\u00f3n una versi\u00f3n mutadora de <code>append</code> que llamamos <code>append!</code> y que mejora la eficiencia de la original, copiando al final de la primera lista una referencia a la segunda:</p> <p></p> <p>La implementaci\u00f3n es la siguiente:</p> <pre><code>(define (append! l1 l2)\n    (if (null? (cdr l1))\n        (set-cdr! l1 l2)\n        (append! (cdr l1) l2)))\n</code></pre> <p>Ejemplo:</p> <pre><code>(define a '(1 2 3 4))\n(define b '(5 6 7))\n(append! a b)\na ; \u21d2 {1 2 3 4 5 6 7}\n</code></pre> <p>Algunas puntualizaciones:</p> <ul> <li>Al igual que <code>set!</code>, <code>set-car!</code> o <code>set-cdr!</code>, la funci\u00f3n <code>append!</code>   no devuelve ning\u00fan valor, sino que modifica directamente la lista   que se pasa como primer par\u00e1metro.</li> <li>Al modificarse la lista, todas las referencias que apuntan a ellas   quedan tambi\u00e9n modificadas.</li> <li>La funci\u00f3n dar\u00eda un error en el caso en que la llam\u00e1ramos con una   lista vac\u00eda como primer argumento.</li> </ul> <p>intercambia-lista!</p> <p>Un \u00faltimo ejemplo de funci\u00f3n recursiva que muta una lista. Queremos definir una funci\u00f3n que intercambie todas las parejas excepto la primera de una lista con un n\u00famero de datos impar, pero sin usar set-car!.</p> <p>Llamamos a la funci\u00f3n <code>(intercambia-lista! lista)</code> y deber\u00eda hacer lo siguiente:</p> <pre><code>(define lista '(1 2 3 4 5 6 7))\n(intercambia-lista! lista)\nlista ; \u21d2 {1 3 2 5 4 7 6}\n</code></pre> <p>La forma de implementar esta funci\u00f3n va a ser llamando a la funci\u00f3n <code>intercambia!</code> (la que hemos definido anteriormente que intercambia el segundo y el tercer elemento) hasta que lleguemos al final de la lista. Lo hacemos con una recursi\u00f3n:</p> <pre><code>(define (intercambia-lista! lista)\n  (if (not (null? (cdr lista)))\n           (begin\n             (intercambia! lista)\n             (intercambia-lista! (cddr lista)))))\n</code></pre> <p>La funci\u00f3n termina cuando llegamos a la pareja final de la lista, la que tiene la lista vac\u00eda en su parte derecha. </p> <p>Si no estamos en el final de la lista llamamos a la funci\u00f3n <code>intercambia!</code> para intercambiar la siguiente pareja con su siguiente y llamamos a la recursi\u00f3n con la variable <code>lista</code> apuntando a la tercera pareja de la lista.</p>"},{"location":"teoria/tema05-bis-programacion-imperativa/tema05-programacion-imperativa.html#33-lista-ordenada-mutable","title":"3.3. Lista ordenada mutable","text":"<p>Veamos ahora una lista ordenada mutable de n\u00fameros, en la que insertaremos elementos de forma ordenada.</p> <p>Definiremos las siguientes funciones:</p> <ul> <li><code>(make-olist)</code>: construye una lista ordenada vac\u00eda</li> <li><code>(borra-primero-olist! olist)</code>: funci\u00f3n mutadora que elimina (con   mutaci\u00f3n) el primer elemento de la lista</li> <li><code>(inserta-olist! olist n)</code>: funci\u00f3n mutadora que inserta (con   mutaci\u00f3n) de forma ordenada un n\u00famero en la lista</li> </ul> <p>Implementamos el tipo de datos con una lista normal con una pareja adicional en cabeza. Esta pareja adicional funcionar\u00e1 de cabecera de la lista y ser\u00e1 la referencia inmutable a la que apuntar\u00e1 cualquier variable que apunte a la lista. De esta forma podremos insertar elementos en primera posici\u00f3n de la lista. En la cabecera usaremos por convenio el s\u00edmbolo <code>'*olist*'</code>.</p> <p><pre><code>(define lista '(*olist* 10 20 30))\n</code></pre> </p> <p>Constructor</p> <p>El constructor <code>(make-olist)</code> devuelve una lista s\u00f3lo con la cabecera.</p> <pre><code>(define (make-olist)\n    (list '*olist*))\n</code></pre> <p>Mutadores</p> <p>Las funciones mutadoras modifican la estructura de datos.</p> <p>Comenzamos con la funci\u00f3n <code>(borra-primero-olist! olist)</code> que elimina con mutaci\u00f3n el primer elemento de la lista ordenada:</p> <p></p> <pre><code>(define (borra-primero-olist! olist)\n    (set-cdr! olist (cddr olist)))\n</code></pre> <p>Definimos la funci\u00f3n mutadora <code>inserta-olist!</code> que modifica la lista ordenada a\u00f1adiendo una nueva pareja, insert\u00e1ndola en la posici\u00f3n correcta modificando las referencias.</p> <p>La funci\u00f3n <code>(add-item! item ref)</code> es la funci\u00f3n clave que crea una nueva pareja con el <code>item</code> y la a\u00f1ade en el <code>cdr</code> de la pareja a la que apunta <code>ref</code>.</p> <pre><code>(define (add-item! ref item)\n    (set-cdr! ref (cons item (cdr ref))))\n\n(define (inserta-olist! olist n)\n    (cond \n        ((null? (cdr olist)) (add-item! olist n))\n        ((&lt; n (cadr olist)) (add-item! olist n))\n        ((= n (cadr olist)) #f)   ; el valor devuelto no importa\n        (else (inserta-olist! (cdr olist) n))))\n</code></pre> <p></p> <p>Ejemplo de uso:</p> <pre><code>(define c (make-olist))\n(inserta-olist! c 5)\n(inserta-olist! c 10)\n(inserta-olist! c -10)\nc ; \u21d2 {*olist* -10 5 10}\n</code></pre>"},{"location":"teoria/tema05-bis-programacion-imperativa/tema05-programacion-imperativa.html#34-diccionario-mutable","title":"3.4. Diccionario mutable","text":"<ul> <li>Veamos ahora un ejemplo m\u00e1s: un diccionario mutable definido   mediante una lista de asociaci\u00f3n formada por parejas de clave y   valor</li> </ul> <pre><code>(define l-assoc (list (cons 'a 1) (cons 'b 2) (cons 'c 3)))\n</code></pre> <ul> <li>La funci\u00f3n de Scheme <code>assq</code> recorre la lista de asociaci\u00f3n y   devuelve la tupla que contiene el dato que se pasa como par\u00e1metro   como clave</li> </ul> <pre><code>(assq 'a l-assoc) ; \u21d2 (a.1)\n(assq 'b l-assoc) ; \u21d2 (b.2)\n(assq 'c l-assoc) ; \u21d2 (c.3)\n(assq 'd l-assoc) ; \u21d2  #f\n(cdr (assq 'c l-assoc)) ; \u21d2 3\n</code></pre> <ul> <li>La funci\u00f3n <code>assq</code> busca en la lista de asociaci\u00f3n usando la igualdad   de referencia <code>eq?</code></li> </ul> <pre><code>(define p (cons 1 2))\n(define l-assoc (list (cons 'a 1) (cons p 2) (cons 'c 3)))\n(assq (cons 1 2) l-assoc) ; \u21d2 #f\n(assq p l-assoc) ; \u21d2 {{1 . 2} . 2}\n</code></pre> <p>Las funciones que vamos a implementar del diccionario son las siguientes:</p> <ul> <li><code>(make-dic)</code>: construye un diccionario vac\u00edo</li> <li><code>(put-dic! dic clave valor)</code>: inserta en el diccionario un nuevo   valor asociado a una clave</li> <li><code>(get-dic dic clave)</code>: devuelve el valor asociado a una clave en un   diccionario</li> </ul> <p>Al igual que la lista ordenada mutable, el diccionario necesita una cabecera:</p> <pre><code>(define (make-dic)\n  (list '*dic*))\n</code></pre> <p>La funci\u00f3n <code>(get-dic dic clave)</code> usa la funci\u00f3n <code>assq</code> para buscar la pareja que contiene una clave determinada en la lista de asociaci\u00f3n (el <code>cdr</code> de dic). Y despu\u00e9s devuelve el <code>cdr</code> de esa pareja (el valor guardado junto con la clave:</p> <pre><code>(define (get-dic dic clave)\n    (let (pareja (assq clave (cdr dic)))\n        (if (not pareja)\n            #f\n            (cdr pareja))))\n</code></pre> <p>La funci\u00f3n <code>(put-dic! dic clave valor)</code> usa igual que antes la funci\u00f3n <code>assq</code> para comprobar si la clave ya est\u00e1 en la lista de asociaci\u00f3n. Si existe, sustituye el valor por el nuevo. Si no existe, crea una pareja con la clave y el valor y la inserta al comienzo del diccionario (despu\u00e9s de la cabecera):</p> <pre><code>(define (put-dic! dic clave valor)\n    (let (pareja (assq clave (cdr dic)))\n        (if (not pareja)\n            (set-cdr! dic\n                  (cons (cons clave valor)\n                        (cdr dic)))\n        (set-cdr! pareja valor)))\n    'ok)\n</code></pre> <p>En las funciones anteriores volvemos a usar la forma especial <code>let</code>.</p> <p>Ejemplos de uso:</p> <pre><code>(define dic (make-dic))\n(put-dic! dic 'a 10) ; \u21d2 ok\n(get-dic dic 'a) ; \u21d2 10\n(put-dic! dic 'b '(a b c)) ; \u21d2 ok\n(get-dic dic 'b) ; \u21d2 {a b c}\n(put-dic! dic 'a 'ardilla) ; \u21d2 ok\n(get-dic dic 'a) ; \u21d2 ardilla\n</code></pre>"},{"location":"teoria/tema05-bis-programacion-imperativa/tema05-programacion-imperativa.html#35-ejemplo-de-mutacion-con-listas-de-asociacion","title":"3.5. Ejemplo de mutaci\u00f3n con listas de asociaci\u00f3n","text":"<p>Una vez introducidos distintas estructuras de datos mutables, incluyendo listas de asociaci\u00f3n, vamos a terminar estos ejemplos con un ejemplo pr\u00e1ctico en el que intervienen las listas y las listas de asociaci\u00f3n. Se trata de escribir un procedimiento <code>regular-&gt;assoc!</code> que transforme una lista regular en una lista de asociaci\u00f3n sin crear nuevas parejas. La lista regular <code>(k1 v1 k2 v2 k3 v3 ...)</code> deber\u00e1 convertirse en la lista de asociaci\u00f3n <code>((k1 . v1) (k2 . v2) (k3 . v3) ...)</code>.</p> <p>Ejemplo:</p> <pre><code>(define my-list (list 'a 1 'b 2 'c 3))\nlista ; \u21d2 (a 1 b 2 c 3)\n(regular-&gt;assoc! my-list)\nlista ; \u21d2 ((a . 1) (b . 2) (c . 3))\n</code></pre> <p>Una posible soluci\u00f3n a este problema ser\u00eda la siguiente (no es la \u00fanica soluci\u00f3n):</p> <p>Cuando trabajamos con este tipo de problemas, es muy \u00fatil ayudarse con los diagramas caja y puntero. Vamos a crear los diagramas caja y puntero para el ejemplo anterior:</p> <p>Antes de llamar a regular-&gt;assoc!:</p> <p></p> <p>Despu\u00e9s de llamar a regular-&gt;assoc!:</p> <p></p> <p>Queremos hacer la transformaci\u00f3n sin crear nuevas parejas, por lo que cada pareja en el primer diagrama corresponde a una pareja particular en el segundo diagrama. No podemos modificar la primera pareja de la lista (porque perder\u00edamos la ligadura de la variable <code>lista</code>), por lo que es primera pareja tiene que permanecer en el primer lugar. Por otra parte, <code>a</code> y <code>1</code> van a formar parte del mismo par en la lista de asociaci\u00f3n, por lo que vamos a considerar el siguiente cambio de las dos primeras parejas.</p> <p>Diagrama inicial:</p> <p></p> <p>Despu\u00e9s del cambio de las dos primeras parejas:</p> <p></p> <p>La siguiente funci\u00f3n <code>manejar-dos-parejas!</code> es la encargada de hacer esta mutaci\u00f3n:</p> <pre><code>(define (manejar-dos-parejas! p)\n    (let ((key (car p)))            ;; 1\n        (set-car! p (cdr p))        ;; 2\n        (set-cdr! p (cdar p))       ;; 3\n        (set-cdr! (car p) (caar p)) ;; 4\n        (set-car! (car p) key)))    ;; 5\n</code></pre> <p>Se han numerado las l\u00edneas para una mejor explicaci\u00f3n. En la l\u00ednea 1, <code>(define key (car p))</code>, creamos una variable local <code>key</code> que guarda el valor actual del <code>(car p)</code>, ese valor ser\u00e1 la clave de la primera pareja de la lista de asociaci\u00f3n; necesitamos almacenarlo para no perderlo.</p> <p>En la l\u00ednea 2, <code>(set-car! p (cdr p))</code>, cambiamos el <code>car</code> de <code>p</code> para que apunte a la siguiente pareja (la azul):</p> <p></p> <p>En la l\u00ednea 3, <code>(set-cdr! p (cdar p))</code>, copiamos en el <code>cdr</code> de <code>p</code> el <code>cdr</code> de la pareja en azul para que ambos apunten a la siguiente pareja:</p> <p></p> <p>En la l\u00ednea 4, <code>(set-cdr! (car p) (caar p))</code>, cambiamos el <code>cdr</code> de la pareja en azul al <code>car</code> de la misma pareja. Hacemos \u00e9sto porque en una lista de asociaci\u00f3n, los valores se guardan en los <code>cdrs</code> y las claves en los <code>cars</code>:</p> <p></p> <p>Por \u00faltimo, en la l\u00ednea 5 <code>(set-car! (car p) key)</code>, completamos el problema poniendo la clave que hab\u00edamos guardado, en el <code>car</code> de la pareja azul:</p> <p></p> <p>Reordenamos el diagrama para verlo m\u00e1s claro:</p> <p></p> <p>Hemos definido un procedimiento que maneja un subproblema (dos parejas) del problema. Ahora s\u00f3lo nos queda definir la funci\u00f3n que maneja toda la lista:</p> <pre><code>(define (regular-&gt;assoc! lista)\n  (if (null? lista) \n     'ok\n     (begin (manejar-dos-parejas! lista)\n            (regular-&gt;assoc! (cdr lista)))))\n</code></pre>"},{"location":"teoria/tema05-bis-programacion-imperativa/tema05-programacion-imperativa.html#4-ambitos-de-variables-y-clausuras","title":"4. \u00c1mbitos de variables y clausuras","text":"<p>El concepto del \u00e1mbito de vida de las variables es un concepto fundamental en los lenguajes de programaci\u00f3n. Utilizaremos las palabras \u00e1mbito y entorno como sin\u00f3nimos. En ingl\u00e9s se utiliza el t\u00e9rmino scope.</p> <p>Cuando se define una variable, asoci\u00e1ndole un valor, esta asociaci\u00f3n tiene una extensi\u00f3n determinada, ya sea en t\u00e9rminos de tiempo de compilaci\u00f3n (\u00e1mbito l\u00e9xico) como en t\u00e9rminos de tiempo de ejecuci\u00f3n (\u00e1mbito din\u00e1mico). El \u00e1mbito de una variable determina cu\u00e1ndo podemos referirnos a ella para recuperar el valor asociado.</p> <p>Al conjunto de variables disponibles en una parte del programa o en una parte de su ejecuci\u00f3n se denomina contexto o entorno (context o environment).</p>"},{"location":"teoria/tema05-bis-programacion-imperativa/tema05-programacion-imperativa.html#41-variables-de-ambito-global","title":"4.1. Variables de \u00e1mbito global","text":"<p>Una variable definida en el programa con la instrucci\u00f3n <code>define</code> tiene un \u00e1mbito global.</p> <pre><code>(define a \"hola\")\n(define b (string-append \"adios\" a))\n(define cuadrado (lambda (x) (* x x)))\n</code></pre> <p>Todas las variables definidas fuera de funciones forman parte del entorno global del programa.</p>"},{"location":"teoria/tema05-bis-programacion-imperativa/tema05-programacion-imperativa.html#42-variables-de-ambito-local","title":"4.2. Variables de \u00e1mbito local","text":"<p>En Scheme existen dos formas de definir variables de \u00e1mbito local: la forma especial <code>define</code> dentro de una funci\u00f3n y la forma especial <code>let</code>.</p>"},{"location":"teoria/tema05-bis-programacion-imperativa/tema05-programacion-imperativa.html#421-variables-locales-con-define","title":"4.2.1 Variables locales con <code>define</code>","text":"<p>Como en la mayor\u00eda de lenguajes de programaci\u00f3n, en Scheme se crea un entorno o \u00e1mbito local (memoria local de la invocaci\u00f3n de la funci\u00f3n) cada vez que se invoca a una funci\u00f3n.</p> <p>En este entorno local toman valor los par\u00e1metros y las variables locales de la funci\u00f3n. Es posible definir variables locales en una funci\u00f3n utilizando la forma especial <code>define</code> dentro de la propia funci\u00f3n. Esto no lo hac\u00edamos dentro del paradigma funcional, para evitar realizar pasos de ejecuci\u00f3n. Pero ahora que estamos en el paradigma imperativo podemos utilizarlo.</p> <pre><code>(define (distancia x1 y1 x2 y2)\n   (define distancia-x (- x2 x1))\n   (define distancia-y (- y2 y1))\n   (sqrt (+ (cuadrado distancia-x)\n            (cuadrado distancia-y))))\n</code></pre> <p>Podemos usar en un entorno local una variable con el mismo nombre que en el entorno global. Cuando se ejecute el c\u00f3digo de la funci\u00f3n se utilizar\u00e1 el valor local.</p> <p>Por ejemplo, supongamos las siguientes expresiones:</p> <pre><code>(define x 5)\n(define (suma-10 y)\n  (define x 10)\n  (+ x y))\n\n(suma-10 3) ; \u21d2 13\n</code></pre> <p>La primera sentencia de la funci\u00f3n <code>(suma y)</code> define una variable local <code>x</code> a la que se asigna un valor inicial de 10. </p> <p>Cuando se ejecuta la expresi\u00f3n <code>(+ x y)</code>, en la invocaci\u00f3n a <code>(suma 3)</code> el valor de <code>x</code> es entonces 10 (el valor local que hemos definido en la sentencia anterior), no es 5, devolvi\u00e9ndose 15.</p> <p>Sucede igual si un par\u00e1metro tiene el mismo nombre que una variable global:</p> <pre><code>(define x 5)\n(define (suma-3 x)\n   (+ x 3))\n\n(suma-3 12) ; \u21d2 15\n</code></pre> <p>Cuando se ejecuta la expresi\u00f3n <code>(+ x 3)</code> en la invocaci\u00f3n a <code>(suma-3 12)</code> el valor de <code>x</code> es 12, no es 5, devolvi\u00e9ndose 15.</p> <p>En el entorno local tambi\u00e9n se pueden utilizar variables definidas en el entorno global. Por ejemplo:</p> <pre><code>(define z 12)\n(define (foo y)\n   (define x 10)\n   (+ x y z))\n\n(foo 5) ; \u21d2 27\n</code></pre> <p>La expresi\u00f3n <code>(+ x y z)</code> se eval\u00faa en el entorno local en el que <code>x</code> vale 10 e <code>y</code> vale 5. Al no estar definida la variable <code>z</code> en este entorno local, se usa su definici\u00f3n de \u00e1mbito global.</p> <p>Una vez realizada la invocaci\u00f3n, desparece el entorno local junto con las variables locales definidas en \u00e9l, y se recupera el contexto global. Por ejemplo, en la siguiente expresi\u00f3n, una vez realizada la invocaci\u00f3n a <code>(suma-10 2)</code> se devuelve el n\u00famero 12 y se eval\u00faa en el entorno global la expresi\u00f3n <code>(+ 12 x)</code>. En este contexto la variable <code>x</code> vale 5 por lo que la expresi\u00f3n devuelve 17.</p> <pre><code>(define x 5)\n(define (suma-10 y)\n   (define x 10)\n   (+ x y))\n\n(+ (suma-10 2) x) ; \u21d2 17\n</code></pre> <p>Otro ejemplo:</p> <pre><code>(define x 10)\n(define (foo2 y)\n   (define z 5)\n   (+ x y z))\n\n(foo2 2) ; \u21d2 17\nx ; \u21d2 10\nz ; \u21d2 error, no definida\ny ; \u21d2 error, no definida\n</code></pre> <p>Define en el cuerpo de una funci\u00f3n</p> <p>La forma especial <code>define</code> para crear variables locales s\u00f3lo puede utilizarse al comienzo de la definici\u00f3n de una funci\u00f3n. Si intentamos utilizarla a mitad del c\u00f3digo de la funci\u00f3n tendremos un error:</p> <pre><code>(define (suma-10-si-mayor-que-0 x)\n   (if (&gt; x 0)\n      (begin \n         ;; ERROR:\n         ;; no es posible usar define a mitad del c\u00f3digo\n         ;; de una funci\u00f3n\n         (define y 10)\n         (+ x y))\n     x))\n</code></pre>"},{"location":"teoria/tema05-bis-programacion-imperativa/tema05-programacion-imperativa.html#421-variables-locales-con-let","title":"4.2.1 Variables locales con <code>let</code>","text":"<p>La otra forma de definir variables locales en Scheme es con la forma especial <code>let</code>.</p> <p>La forma especial <code>let</code> permite crear un \u00e1mbito local en el que se da valor a variables y se eval\u00faan expresiones.</p> <p>Sintaxis:</p> <pre><code>(let ((&lt;var1&gt; &lt;exp-1&gt;)\n        ...\n      (&lt;varn&gt; &lt;exp-n&gt;))\n    &lt;cuerpo&gt;)\n</code></pre> <p>Las variables <code>var1</code>, \u2026 <code>varn</code> toman los valores devueltos por las expresiones <code>exp1</code>, \u2026 <code>expn</code> y el cuerpo se eval\u00faa con esos valores. Esas variables s\u00f3lo tienen valor en el \u00e1mbito de la forma especial.</p> <p>Por ejemplo:</p> <pre><code>(define x 10)\n(let ((x (+ 1 2))\n      (y (* 10 2))\n    (+ x y)) ; \u21d2 23\nx ; \u21d2 10\ny ; \u21d2 error, no definida\n</code></pre> <p>Cuando ha terminado la evaluaci\u00f3n del <code>let</code> el \u00e1mbito local desaparece y quedan los valores definidos en el \u00e1mbito anterior.</p> <p>Las expresiones que dan valor a las variables del let se eval\u00faan antes de crear el \u00e1mbito local. Por ejemplo, en el siguiente c\u00f3digo, las expresiones <code>(+ x 3)</code> y <code>(+ y 2)</code> devuelven 4 y 7 respectivamente:</p> <pre><code>(define x 1)\n(define y 5)\n(let ((w (+ x 3))\n      (z (+ y 2)))\n    (+ w z)) ; \u21d2 11\n</code></pre> <p>En el cuerpo del <code>let</code> puede haber m\u00e1s de una expresi\u00f3n:</p> <pre><code>(let ((x 10)\n      (y 20))\n    (display \"x: \")\n    (display x)\n    (display \"\\ny: \")\n    (display y))\n</code></pre> <p>Let en el cuerpo de una funci\u00f3n</p> <p>A diferencia de <code>define</code> s\u00ed que es posible usar <code>let</code> en cualquier expresi\u00f3n de Scheme, por ejemplo, en un <code>if</code>:</p> <pre><code>(define (suma-10-si-mayor-que-0 x)\n   (if (&gt; x 0)\n      (let ((y 10))\n         (+ x y))\n      x))\n</code></pre>"},{"location":"teoria/tema05-bis-programacion-imperativa/tema05-programacion-imperativa.html#43-clausuras-y-estado-local","title":"4.3. Clausuras y estado local","text":"<p>Recordemos que la forma especial <code>lambda</code> permite crear funciones an\u00f3nimas en tiempo de ejecuci\u00f3n. Si ejecutamos una forma especial lambda como \u00faltimo paso de una funci\u00f3n, se devolver\u00e1 la funci\u00f3n reci\u00e9n creada.</p> <p>\u00bfQu\u00e9 sucede si utilizamos en el cuerpo de esta funci\u00f3n an\u00f3nima una variable local definida en la funci\u00f3n principal?</p> <p>Vamos a verlo:</p> <pre><code>(define (make-sumador)\n   (define z 10)\n   (lambda (x) (+ x z)))\n</code></pre> <p>La funci\u00f3n <code>make-sumador</code> define una variable local <code>z</code> con el valor de 10. Y despu\u00e9s construye una funci\u00f3n con la expresi\u00f3n <code>lambda</code>. Al ser la \u00faltima expresi\u00f3n de la funci\u00f3n <code>make-sumador</code>, esta funci\u00f3n construida en tiempo de ejecuci\u00f3n es lo que se devuelve. </p> <p>Si invocamos a <code>make-sumador</code> vemos que devuelve un procedimiento:</p> <p><pre><code>(make-sumador) ; \u21d2 #&lt;procedure&gt;\n</code></pre> Si guardamos el procedimiento en una variable y despu\u00e9s lo invocamos, tendremos que pasarle un par\u00e1metro (correspondiente al argumento <code>x</code> de la expresi\u00f3n <code>lambda</code>). \u00bfQu\u00e9 devolver\u00e1 esa invocaci\u00f3n?</p> <pre><code>(define f (make-sumador))\n(f 5) ; \u21d2 ???\n</code></pre> <p>Al invocar a <code>f</code> se ejecutar\u00e1 el cuerpo del procedimiento, esto es, la expresi\u00f3n <code>(+ x z)</code>. La variable <code>x</code> valdr\u00e1 5 (el valor del par\u00e1metro). Pero, \u00bfcu\u00e1l es el valor de la variable z?. Podemos comprobar que es 10, porque la invocaci\u00f3n devuelve devuelve 15:</p> <pre><code>(f 5) ; \u21d2 15\n</code></pre> <p>\u00bfPor qu\u00e9? Lo que est\u00e1 pasando es que la funci\u00f3n an\u00f3nima que crea la expresi\u00f3n lambda captura las variables locales definidas en el \u00e1mbito en el que se crea. Por eso recibe el nombre de clausura, porque encierra los valores que tienen esas variables en el momento de su creaci\u00f3n y esos valores son los que usa en las variables libres cuando posteriormente la invoquemos.</p> <p>En el ejemplo anterior se est\u00e1 capturando la variable <code>z</code> con su valor 10. Cuando despu\u00e9s invocamos a <code>(f 5)</code> se eval\u00faa el cuerpo <code>(+ x z)</code> con <code>x</code> valiendo <code>5</code> y <code>z</code> valiendo el valor capturado (10).</p> <p>Tambi\u00e9n podemos utilizar como estado local el valor de un par\u00e1metro. Por ejemplo:</p> <pre><code>(define (make-sumador k)\n    (lambda (x) (+ x k)))\n\n(define f (make-sumador 10))\n(f 2)\n; \u21d2 12\n</code></pre> <p>En la funci\u00f3n <code>(make-sumador k)</code> se llama a la forma especial lambda para crear una clausura. La clausura captura la variable local <code>k</code> (el par\u00e1metro de <code>make-sumador</code>) y usar\u00e1 su valor cuando posteriormente se eval\u00fae. En este caso, la clausura se ha creado con <code>k</code> valiendo 10, y captura este valor. </p> <p>Cuando despu\u00e9s se invoca a <code>(f 2)</code> se ejecuta la clausura en un nuevo \u00e1mbito local con las siguientes variables y valores:</p> <pre><code>x: 2 (variable local de la clausura)\nk: 10 (valor capturado del entorno local en el que se cre\u00f3 la clausura\n</code></pre> <p>En este \u00e1mbito se ejecuta la expresi\u00f3n <code>(+ x k)</code>, devolvi\u00e9ndose el valor 12.</p> <p>Por \u00faltimo, tambi\u00e9n es posible crear la clausura dentro de un estado local definido con un <code>let</code> y usar en el cuerpo del <code>lambda</code> variables locales definidas en el <code>let</code>:</p> <pre><code>(define (make-sumador-cuadrado k)\n    (if (&gt; k 0)\n        (let ((y (cuadrado k)))\n          (lambda (x)\n            (+ x y)))\n        (lambda (x)\n          x)))\n</code></pre> <p>La funci\u00f3n anterior tiene un condicional en el que se comprueba si <code>k</code> es mayor que 0. Si lo es, se devuelve una clausura creada en el \u00e1mbito del <code>let</code> con la variable <code>y</code> capturada con el valor del cuadrado de <code>k</code>. Esta clausura suma a su entrada el valor de <code>y</code>.</p> <p>Por ejemplo:</p> <pre><code>(define f (make-sumador-cuadrado 4))\n(f 3) ; \u21d2 19\n</code></pre> <p>En el caso en que <code>k</code> menor o igual que 0, se devuelve una clausura que devuelve siempre el valor que recibe:</p> <pre><code>(define f (make-sumador-cuadrado -8))\n(f 3) ; \u21d2 3\n</code></pre> <p>La definici\u00f3n de clausuras con un estado local inicializado a un valor creado en tiempo de ejecuci\u00f3n es una caracter\u00edstica muy potente. Permite no s\u00f3lo crear funciones en tiempo de ejecuci\u00f3n para utilizarlas posteriormente, sino configurarlas con el estado local que nos interese.</p> <p>Veremos en el apartado siguiente que la combinaci\u00f3n de clausuras y mutaci\u00f3n permite crear funciones con estado local mutable, algo equivalente a objetos que encapsulan c\u00f3digo y estado.</p>"},{"location":"teoria/tema05-bis-programacion-imperativa/tema05-programacion-imperativa.html#5-clausuras-con-mutacion-estado-local-mutable","title":"5. Clausuras con mutaci\u00f3n = estado local mutable","text":""},{"location":"teoria/tema05-bis-programacion-imperativa/tema05-programacion-imperativa.html#51-estado-local-mutable","title":"5.1. Estado local mutable","text":"<p>Si combinamos una clausura con la posibilidad de mutar las variables capturadas por la clausura obtenemos un estado local mutable asociado a funciones creadas en tiempo de ejecuci\u00f3n.</p> <p>Veamos, por ejemplo, la siguiente funci\u00f3n <code>(make-contador i)</code>:</p> <pre><code>(define (make-contador i)\n  (define x i)\n  (lambda ()\n     (set! x (+ x 1))\n     x)))\n</code></pre> <p>La funci\u00f3n <code>make-contador</code> define una clausura que captura la variable local <code>x</code> inicializada a <code>i</code>. En cada invocaci\u00f3n a la clausura se ejecuta una sentencia <code>set</code> que modifica el valor de la variable capturada. Y despu\u00e9s se devuelve el nuevo valor de la variable. Estamos implementando un contador asociado a la clausura.</p> <pre><code>(define f (make-contador 10))\n(f) \u21d2 11\n(f) \u21d2 12\n</code></pre> <p>El estado (el valor del contador) se mantiene y se modifica entre distintas invocaciones a <code>f</code>. A diferencia del paradigma funcional podemos comprobar que distintas invocaciones a la misma funci\u00f3n devuelven valores distintos (dependiente del estado de la clausura).</p> <p>Podemos crear distintas clausuras, cada una con su variable capturada, en distintas invocaciones a <code>make-contador</code>:</p> <pre><code>(define h (make-contador 10))\n(define g (make-contador 100))\n(h) \u21d2 11\n(h) \u21d2 12\n(g) \u21d2 101\n(g) \u21d2 102\n</code></pre> <p>Una forma alternativa de crear la clausura, sin usar la forma especial <code>lambda</code> es defini\u00e9ndola con un <code>define</code> en el cuerpo de <code>make-contador</code>. Despu\u00e9s de los dos <code>define</code> la \u00faltima sentencia devuelve la funci\u00f3n <code>incrementa</code> (la clausura).</p> <pre><code>(define (make-contador i)\n  (define x i)\n  (define (incrementa)\n    (set! x (+ x 1))\n    x)\n  incrementa)\n</code></pre>"},{"location":"teoria/tema05-bis-programacion-imperativa/tema05-programacion-imperativa.html#52-paso-de-mensajes","title":"5.2. Paso de mensajes","text":"<p>En el ejemplo anterior creamos una clausura que siempre incrementa el valor del contador. \u00bfC\u00f3mo podr\u00edamos crear una clausura que permitiera hacer distintas cosas con el valor capturado?</p> <p>Una forma de hacerlo es definir en la clausura un par\u00e1metro adicional (un s\u00edmbolo que llamamos mensaje) y devolver distintas clausuras en funci\u00f3n del valor de ese par\u00e1metro adicional:</p> <pre><code>(define (make-contador i)\n  (define x i)\n  (define (get)\n    x)\n  (define (inc-1)\n    (set! x (+ x 1))\n    x)\n  (define (inc y)\n    (set! x (+ x y))\n    x)\n\n  (define (dispatcher mensaje)\n    (cond\n      ((equal? mensaje 'get) get)\n      ((equal? mensaje 'inc-1) inc-1)\n      ((equal? mensaje 'inc) inc)\n      (else \"Error: mensaje desconocido\")))\n  dispatcher)\n</code></pre> <p>La funci\u00f3n <code>make-contador</code> devuelve la clausura <code>dispatcher</code> que se encarga de procesar el mensaje y devolver la clausura asociada a ese mensaje. Cuando invoquemos al dispatcher con un s\u00edmbolo, devuelve otro procedimiento que hay que volver a invocar con los par\u00e1metros adecuados (sin par\u00e1metros en los dos primeros casos y con el valor a incrementar en el \u00faltimo caso):</p> <ul> <li>Si recibe el s\u00edmbolo <code>'get</code> devuelve la clausura que devuelve el valor del contador</li> <li>Si recibe el s\u00edmbolo <code>'inc-1</code> devuelve la clausura que incrementa el valor del contador en 1</li> <li>Si recibe el s\u00edmbolo <code>'inc</code> devuelve la clausura que incrementa el valor del contador una cantidad determinada</li> </ul> <p>Por ejemplo:</p> <pre><code>(define c (make-contador 100))\n((c 'get)) \u21d2 100\n((c 'inc-1)) \u21d2 101\n((c 'inc) 10) \u21d2 111\n</code></pre> <p>Lenguajes y Paradigmas de Programaci\u00f3n, curso 2016-17 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Domingo Gallardo, Cristina Pomares</p>"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html","title":"Tema 5: Programaci\u00f3n Funcional con Swift","text":""},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#1-introduccion","title":"1. Introducci\u00f3n","text":"<p>Te recomendamos que leas el seminario de Swift en el que se introduce el lenguaje y se explica c\u00f3mo ejecutar programas en este lenguaje:</p> <ul> <li>Seminario de Swift</li> </ul>"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#12-conceptos-fundamentales-de-programacion-funcional","title":"1.2. Conceptos fundamentales de Programaci\u00f3n Funcional","text":"<p>Vamos a repasar en este tema c\u00f3mo se implementan en Swift conceptos principalmente funcionales como:</p> <ul> <li>Valores inmutables</li> <li>Tipos de datos recursivos</li> <li>Funciones como objetos de primera clase y clasuras</li> <li>Funciones de orden superior</li> </ul> <p>Repasamos r\u00e1pidamente algunos conceptos b\u00e1sicos de programaci\u00f3n funcional, vistos en los primeros temas de la asignatura.</p> <p>Programaci\u00f3n Funcional:</p> <p>La Programaci\u00f3n Funcional es un paradigma de programaci\u00f3n que trata la computaci\u00f3n como la evaluaci\u00f3n de funciones matem\u00e1ticas y que evita cambios de estado y datos mutables.</p> <p>Funciones matem\u00e1ticas o puras:</p> <p>Las funciones matem\u00e1ticas tienen la caracter\u00edstica de que cuando las invocas con el mismo argumento siempre te devolver\u00e1n el mismo resultado.</p> <p>Funciones como objetos de primera clase:</p> <p>En programaci\u00f3n funcional, las funciones son objetos de primera clase del lenguaje, similares a enteros o strings. Podemos pasar funciones como argumentos en las denominadas funciones de orden superior o devolver funciones creadas en tiempo de ejecuci\u00f3n (clausuras).</p>"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#13-caracteristicas-basicas-de-swift","title":"1.3. Caracter\u00edsticas b\u00e1sicas de Swift","text":"<p>Swift es un lenguaje principalmente imperativo, pero en su dise\u00f1o se han introducido conceptos modernos de programaci\u00f3n funcional, extra\u00eddos de lenguajes como Rust o Haskell. Por ello se puede considerar un lenguaje multi-paradigma, en el que se puede definir c\u00f3digo funcional que se puede ejecutar junto con c\u00f3digo imperativo.</p> <p>Como dice su creador Chris Lattner:</p> <p>El lenguaje Swift es el resultado de un esfuerzo incansable de un equipo de expertos en lenguajes, gur\u00fas de documentaci\u00f3n, ninjas de optimizaci\u00f3n de compiladores [..]. Por supuesto, tambi\u00e9n se benefici\u00f3 enormemente de las experiencias ganadas en muchos otros lenguajes, tomando ideas de Objective-C, Rust, Haskell, Ruby, Python, C#, CLU, y demasiados otros para ser enumerados.</p>"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#131-lenguaje-fuertemente-tipado","title":"1.3.1. Lenguaje fuertemente tipado","text":"<p>A diferencia de Scheme, Swift es un lenguaje fuertemente tipado en el que hay que definir los tipos de variables, par\u00e1metros y funciones.</p> <p>Por ejemplo, en las siguientes declaraciones definimos variables de distintos tipos:</p> <pre><code>let n: Int = 10\nlet str: String = \"Hola\"\nlet array: [Int] = [1,2,3,4,5]\n</code></pre> <p>El compilador de Swift permite identificar los tipos de las variables cuando se realiza una asignaci\u00f3n. La t\u00e9cnica se denomina inferencia de tipos y permite declarar variables sin escribir su tipo. Por ejemplo, las variables anteriores se pueden declarar tambi\u00e9n asi:</p> <pre><code>let n = 10\nlet str = \"Hola\"\nlet array = [1,2,3,4,5]\n</code></pre> <p>Aunque no hayamos declarado expl\u00edcitamente el tipo de las variables, el compilador les ha asignado el tipo correspondiente. Por ejemplo, no podemos asignarles un valor de distinto tipo:</p> <pre><code>var x = 5\nx = 4 // correcto\nx = 6.0 // error\n// error: cannot assign value of type 'Double' to type 'Int'\n// x = 5.0\n//     ^~~\n//    Int( )\n</code></pre> <p>El compilador indica el error e incluso sugiere una posible soluci\u00f3n del mismo. En este caso llamar al constructor <code>Int()</code> pas\u00e1ndole un <code>Double</code> como par\u00e1metro.</p>"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#132-lenguaje-multi-paradigma","title":"1.3.2. Lenguaje multi-paradigma","text":"<p>Swift permite combinar caracter\u00edsticas funcionales con caracter\u00edsticas imperativas y de programaci\u00f3n orientada a objetos. Veremos en este tema muchas caracter\u00edsticas funcionales que podremos utilizar en cualquier programa Swift que desarrollemos.</p> <p>Por ejemplo, cuando declaramos una variable podemos declararla como mutable, usando la declaraci\u00f3n <code>var</code>, o como inmutable, usando la declaraci\u00f3n <code>let</code>. Si queremos utilizar un enfoque funcional preferiremos siempre declarar las variables con <code>let</code>. </p> <pre><code>var x = 10\nx = 20 // x es mutable\nlet y = 10\ny = 20 // error: y es inmutable\n</code></pre> <p>Una ventaja de la inmutabilidad es que permite que el compilador de Swift optimice el c\u00f3digo de forma muy eficiente. De hecho, el propio compilador nos indica que es preferible definir una variable como <code>let</code> si no la vamos a modificar:</p> <pre><code>func saluda(nombre: String) -&gt; String {\n    var saludo = \"Hola \" + nombre + \"!\"\n    return saludo\n}\n//warning: variable 'saludo' was never mutated; consider changing to 'let' constant\n//    var saludo = \"Hola \" + nombre\n//    ~~~ ^\n//    let\n</code></pre>"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#2-inmutabilidad","title":"2. Inmutabilidad","text":"<p>Una de las caracter\u00edsticas funcionales importantes de Swift es el \u00e9nfasis en la inmutabilidad para reforzar la seguridad del lenguaje. </p> <p>Hemos visto que la palabra clave <code>let</code> permite definir constantes y que Swift recomienda su uso si el valor que definimos es un valor que no va a ser modificado.</p> <p>El valor asignado a una constante <code>let</code> puede no conocerse en tiempo de compilaci\u00f3n, sino que puede ser obtenido en tiempo de ejecuci\u00f3n como un valor devuelto por una funci\u00f3n:</p> <pre><code>let respuesta: String = respuestaUsuario.respuesta()\n</code></pre> <p>Al declarar una variable como <code>let</code> se bloquea su contenido y no se permite su modificaci\u00f3n. Una de las ventajas del paradigma funcional y de la inmutabilidad es que garantiza que el c\u00f3digo que escribimos no tiene efectos laterales y puede ser ejecutado sin problemas en entornos multi-procesador o multi-hilo.</p>"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#21-creacion-de-nuevas-estructuras-y-mutacion","title":"2.1. Creaci\u00f3n de nuevas estructuras y mutaci\u00f3n","text":"<p>En la biblioteca est\u00e1ndar de Swift existen una gran cantidad de estructuras (como <code>Int</code>, <code>Double</code>, <code>Bool</code>, <code>String</code>, <code>Array</code>, <code>Dictionary</code>, etc.) que tienen dos tipos de m\u00e9todos: m\u00e9todos que mutan la estructura y m\u00e9todos que devuelven una nueva estructura. Cuando estemos escribiendo c\u00f3digo con estilo funcional deberemos utilizar siempre estos \u00faltimos m\u00e9todos, los que construyen estructuras nuevas.</p> <p>Por ejemplo, en el struct <code>Array</code> se define el m\u00e9todo <code>sort</code> y el m\u00e9todo <code>sorted</code>. El primero ordena el array con mutaci\u00f3n y el segundo devuelve una copia ordenada, sin modificar el array original. En el siguiente c\u00f3digo no se modifica el array original, sino que se construye un array nuevo ordenado:</p> <pre><code>// C\u00f3digo recomendable en programaci\u00f3n funcional\n// porque utiliza el m\u00e9todo sorted que devuelve una\n// copia del array original\nlet miArray = [10, -1, 3, 80]\nlet arrayOrdenado = miArray.sorted()\nprint(miArray)\nprint(arrayOrdenado)\n// Imprime:\n// [10, -1, 3, 80]\n// [-1, 3, 10, 80]\n</code></pre> <p>Este c\u00f3digo es el recomendable cuando estemos escribiendo c\u00f3digo con un estilo de programaci\u00f3n funcional.</p> <p>Sin embargo, el siguiente c\u00f3digo es imperativo y utiliza la mutaci\u00f3n del array original:</p> <pre><code>// C\u00f3digo no recomendable en programaci\u00f3n funcional\n// porque utiliza el m\u00e9todo sort que muta el array original\nvar miArray = [10, -1, 3, 80]\nmiArray.sort()\nprint(miArray)\n// Imprime:\n// [-1, 3, 10, 80]\n</code></pre> <p>Otro ejemplo es en la forma de a\u00f1adir elementos a un array. Podemos hacerlo con un enfoque funcional, usando el operador <code>+</code> que construye un array nuevo:</p> <pre><code>// C\u00f3digo recomendable en programaci\u00f3n funcional\nlet miArray = [10, -1, 3, 80]\nlet array2 = miArray + [100]\nprint(array2)\n// Imprime:\n// [10, -1, 3, 80, 100]\n</code></pre> <p>Y podemos hacerlo usando un enfoque imperativo, con el m\u00e9todo <code>append</code>:</p> <pre><code>// C\u00f3digo no recomendable en programaci\u00f3n funcional\nvar miArray = [10, -1, 3, 80]\nmiArray.append(100)\nprint(miArray)\n// Imprime:\n// [10, -1, 3, 80, 100]\n</code></pre> <p>Importante</p> <p>En programaci\u00f3n funcional debemos usar siempre los m\u00e9todos que no modifican las estructuras. As\u00ed evitaremos los efectos laterales y nuestro c\u00f3digo funcionar\u00e1 correctamente en entornos multi-hilo.</p> <p>Cuando definimos una variable de tipo <code>let</code> el valor que se asigne a esa variable se convierte en inmutable. Si se trata de una estructura o una clase con m\u00e9todos mutables el compilador dar\u00e1 un error. Por ejemplo:</p> <pre><code>let miArray = [10, -1, 3, 80]\nmiArray.append(100)\n// error: cannot use mutating member on immutable value: 'miArray' is a 'let' constant\n</code></pre> <p>Otro ejemplo. El m\u00e9todo <code>append(_:)</code> de un <code>String</code> es un m\u00e9todo mutable. Si definimos una cadena con <code>let</code> no podremos modificarla y dar\u00eda error el siguiente c\u00f3digo:</p> <pre><code>var cadenaMutable = \"Hola\"\nlet cadenaInmutable = \"Adios\"\ncadenaMutable.append(cadenaInmutable) // cadenaMutable es \"HolaAdios\"\ncadenaInmutable.append(\"Adios\")\n// error: cannot use mutating member on immutable value: 'cadenaInmutable' is a 'let' constant\n</code></pre>"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#3-funciones","title":"3. Funciones","text":""},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#31-definicion-de-una-funcion-en-swift","title":"3.1. Definici\u00f3n de una funci\u00f3n en Swift","text":"<p>Para definir una funci\u00f3n en Swift se debe usar la palabra <code>func</code>, definir el nombre de la funci\u00f3n, sus par\u00e1metros y el tipo de vuelto. El valor devuelto por la funci\u00f3n se debe devolver usando la palabra <code>return</code>.</p> <p>C\u00f3digo de la funci\u00f3n <code>saluda(nombre:)</code>:</p> <pre><code>func saluda(nombre: String) -&gt; String {\n    let saludo = \"Hola, \" + nombre + \"!\"\n    return saludo\n}\n</code></pre> <p>Una caracter\u00edstica de Swift es que para invocar a la funci\u00f3n es necesario preceder al argumento con la etiqueta definida por el nombre del par\u00e1metro.</p> <p>Por ejemplo, ser\u00eda un error llamar a la funci\u00f3n anterior de la siguiente forma:</p> <pre><code>// Error: hay que especificar la etiqueta `nombre:`\nprint(saluda(\"Ana\"))\n</code></pre> <p>La forma correcta de llamar a la funci\u00f3n es la siguiente:</p> <pre><code>print(saluda(nombre:\"Ana\"))\nprint(saluda(nombre:\"Pedro\"))\n// Imprime \"Hola, Ana!\"\n// Imprime \"Hola, Pedro!\"\n</code></pre> <p>Esta caracter\u00edstica de Swift hace que el c\u00f3digo sea m\u00e1s legible y f\u00e1cil de entender, ya que podemos ver claramente cu\u00e1l es el prop\u00f3sito de cada argumento al llamar a la funci\u00f3n. </p> <p>Por ejemplo, podemos tener tambi\u00e9n otra funci\u00f3n similar que devuelve un saludo recibiendo el nombre y la edad de una persona:</p> <pre><code>func crearSaludo(nombre: String, edad: Int) -&gt; String {\n    return \"Hola, \\(nombre)! Tienes \\(edad) a\u00f1os.\"\n}\n\nlet saludo = crearSaludo(nombre: \"Carlos\", edad: 25)\nprint(saludo)\n</code></pre> <p>Al llamar a la funci\u00f3n <code>crearSaludo</code> queda claro que estamos pasando el nombre y la edad de la persona a la que queremos saludar.</p>"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#32-etiquetas-de-argumentos-y-nombres-de-parametros","title":"3.2. Etiquetas de argumentos y nombres de par\u00e1metros","text":"<p>Es posible hacer distintos la etiqueta del argumento (nombre externo con el que hay que llamar a la funci\u00f3n) del nombre del par\u00e1metro (nombre interno que se usa en el cuerpo de la funci\u00f3n):</p> <pre><code>func saluda(nombre: String, de ciudad: String) -&gt; String {\n    return \"Hola \\(nombre)! Me alegro de que hayas podido visitarnos desde \\(ciudad).\"\n}\nprint(saluda(nombre: \"Bill\", de: \"Cupertino\"))\n// Imprime \"Hola Bill! Me alegro de que hayas podido visitarnos desde Cupertino.\"\n</code></pre> <p>En este caso el nombre externo del par\u00e1metro, el que usamos al invocar la funci\u00f3n, es <code>de</code> y el nombre interno, el que se usa en el cuerpo de la funci\u00f3n, es <code>ciudad</code>.</p> <p>Otro ejemplo, la siguiente funci\u00f3n <code>concatena(palabra:con:)</code>: </p> <pre><code>func concatena(palabra str1: String, con str2: String) -&gt; String {\n    return str1+str2\n}\n\nprint(concatena(palabra:\"Hola\", con:\"adios\"))\n</code></pre> <p>Si no se quiere una etiqueta del argumento para un par\u00e1metro, se puede escribir un subrayado (<code>_</code>) en lugar de una etiqueta del argumento expl\u00edcita para ese par\u00e1metro. Esto nos permite llamar a la funci\u00f3n sin usar un nombre de par\u00e1metro. Por ejemplo, la funci\u00f3n <code>max(_:_:)</code> y la funci\u00f3n <code>divide(_:entre:)</code>:</p> <pre><code>func max(_ x: Int, _ y: Int) -&gt; Int {\n   if x &gt; y {\n      return x\n   } else {\n      return y\n   }\n}\n\nprint(max(10,3))\n\nfunc divide(_ x: Double, entre y: Double) -&gt; Double {\n   return x / y\n}\n\nprint(divide(30, entre:4))\n</code></pre> <p>La firma de la funci\u00f3n (\"function signature\" en ingl\u00e9s, tambi\u00e9n llamada \"perfil\" de la funci\u00f3n) est\u00e1 formada por el nombre de la funci\u00f3n, las etiquetas de los argumentos y sus tipos y el tipo devuelto por la funci\u00f3n.</p> <p>Por ejemplo, en el caso anterior, la firma de la funci\u00f3n <code>max</code> ser\u00eda:</p> <ul> <li>Nombre: <code>max</code></li> <li>Lista de par\u00e1metros: <code>(_ x: Int, _ y: Int)</code></li> <li>Tipo de retorno: <code>Int</code></li> </ul> <p>Y la firma de la funci\u00f3n <code>divide</code> ser\u00eda:</p> <ul> <li>Nombre: <code>divide</code></li> <li>Lista de par\u00e1metros: <code>(_ x: Double, entre y: Double)</code></li> <li>Tipo de retorno: <code>Double</code></li> </ul> <p>Esta firma permite al compilador y al programador identificar y diferenciar funciones con el mismo nombre pero con diferentes listas de par\u00e1metros o tipos de retorno.</p> <p>En la documentaci\u00f3n de las funciones en Swift se suele usar para nombrarlas su nombre completo: el nombre de la propia funci\u00f3n m\u00e1s el nombre de los par\u00e1metros. Por ejemplo, las funciones anteriores se nombran como <code>max(_:_:)</code> y <code>divide(_:entre:)</code>.</p> <p>Como hemos dicho, los nombres de los par\u00e1metros son parte del nombre completo de la funci\u00f3n. Es posible definir funciones distintas con s\u00f3lo distintos nombres de par\u00e1metros, como las siguientes funciones <code>mitad(par:)</code> y <code>mitad(impar:)</code>:</p> <pre><code>func mitad(par: Int) -&gt; Int{\n    return par/2\n}\n\nfunc mitad(impar: Int) -&gt; Int{\n    return (impar+1)/2\n}\n\nprint(mitad(par: 8))\n// Imprime 4\nprint(mitad(impar: 9))\n// Imprime 5\n</code></pre>"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#33-parametros-y-valores-devueltos","title":"3.3. Par\u00e1metros y valores devueltos","text":"<p>Es posible definir funciones sin par\u00e1metros:</p> <pre><code>func diHolaMundo() -&gt; String {\n    return \"hola, mundo\"\n}\nprint(diHolaMundo())\n// Imprime \"hola, mundo\"\n</code></pre> <p>Podemos definir funciones sin valor devuelto. Por ejemplo, la siguiente funci\u00f3n <code>diAdios(nombre:)</code>. No hay que escribir flecha con el tipo devuelto. Cuidado, no ser\u00eda propiamente programaci\u00f3n funcional.</p> <pre><code>func diAdios(nombre: String) {\n    print(\"Adi\u00f3s, \\(nombre)!\")\n}\ndiAdios(nombre:\"Dave\")\n// Imprime \"Adi\u00f3s, Dave!\"\n</code></pre> <p>Es posible devolver m\u00faltiples valores, construyendo una tupla. Por ejemplo, la siguiente funci\u00f3n <code>ecuacion(a:b:c:)</code> calcula las dos soluciones de una ecuaci\u00f3n de segundo grado:</p> <pre><code>func ecuacion(a: Double, b: Double, c: Double) -&gt; (pos: Double, neg: Double) {\n    let discriminante = b*b-4*a*c\n    let raizPositiva = (-b + discriminante.squareRoot()) / 2*a\n    let raizNegativa = (-b - discriminante.squareRoot()) / 2*a\n    return (raizPositiva, raizNegativa)\n}\n</code></pre> <p>Recordemos (consultar el seminario de Swift) que podemos acceder a los valores de la tupla por posici\u00f3n:</p> <pre><code>let resultado = ecuacion(a: 1, b: -5, c: 6)\nprint(\"Las ra\u00edces de la ecuaci\u00f3n son \\(resultado.0) y \\(resultado.1)\")\n//Imprime \"Las ra\u00edces de la ecuaci\u00f3n son 3.0 y 2.0\"\n</code></pre> <p>En este caso en la definici\u00f3n del tipo devuelto por la funci\u00f3n estamos etiquetando esos valores con las etiquetas <code>pos</code> y <code>neg</code>. De esta forma podemos acceder a los componentes de la tupla usando esas etiquetas definidas:</p> <pre><code>let resultado = ecuacion(a: 1, b: -5, c: 6)\nprint(\"Las ra\u00edces de la ecuaci\u00f3n son \\(resultado.pos) y \\(resultado.neg)\")\n//Imprime \"Las ra\u00edces de la ecuaci\u00f3n son 3.0 y 2.0\"\n</code></pre>"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#4-recursion","title":"4. Recursi\u00f3n","text":"<p>Veamos algunos ejemplos de funciones recursivas en Swift.</p> <p>Primero una funci\u00f3n <code>suma(hasta:)</code> que devuelve la suma desde 0 hasta el n\u00famero que le pasamos como par\u00e1metro.</p> <pre><code>func suma(hasta x: Int) -&gt; Int {\n  if x == 0 {\n    return 0\n  } else {\n    return x + suma(hasta: x - 1)\n  }\n}\n\nprint(suma(hasta: 5))\n// Imprime \"15\"\n</code></pre> <p>Tambi\u00e9n es posible definir recursiones que recorran arrays de una forma similar a c\u00f3mo trabaj\u00e1bamos en Scheme. Los arrays en Swift no funcionan exactamente como las listas de Scheme (no son listas de parejas), pero podemos obtener el primer elemento y el resto de la siguiente forma.</p> <pre><code>let a = [10, 20, 30, 40, 50, 60]\nlet primero = a[0]\nlet resto = Array(a.dropFirst())\n</code></pre> <p>En <code>primero</code> se guarda el n\u00famero 10. En <code>resto</code> se guarda el <code>Array</code> del 20 al 60. El m\u00e9todo <code>dropFirst</code> devuelve una <code>ArraySlice</code>, que es una vista de un rango de elementos del array, en este caso el que va desde la posici\u00f3n 1 hasta la 5 (la posici\u00f3n inicial de un array es la 0). Es necesario el constructor <code>Array</code> para convertir ese <code>ArraySlice</code> en un <code>Array</code>.</p> <p>Usando las instrucciones anteriores podemos definir la funci\u00f3n recursiva que suma los valores de un Array de la siguiente forma similar a c\u00f3mo lo hac\u00edamos en Scheme:</p> <pre><code>func sumaValores(_ valores: [Int]) -&gt; Int {\n    if (valores.isEmpty) {\n        return 0\n    } else {\n        let primero = valores[0]\n        let resto = Array(valores.dropFirst())\n        return primero + sumaValores(resto)\n    }\n}\n\nprint(sumaValores([1,2,3,4,5,6,7,8])) \n// Imprime \"36\"\n</code></pre> <p>Un \u00faltimo ejemplo es la siguiente funci\u00f3n <code>minMax(array:)</code> que devuelve el n\u00famero m\u00e1s peque\u00f1o y m\u00e1s grande de un array de enteros:</p> <pre><code>func minMax(array: [Int]) -&gt; (min: Int, max: Int) {\n    if (array.count == 1) {\n        return (array[0], array[0])\n    } else {\n        let primero = array[0]\n        let resto = Array(array.dropFirst())\n\n        // Llamada recursiva que devuelve el m\u00ednimo y el m\u00e1ximo del\n        // resto del array\n        let minMaxResto = minMax(array: resto)\n\n        let minimo = min(primero, minMaxResto.min)\n        let maximo = max(primero, minMaxResto.max)\n        return (minimo, maximo)\n    }\n}\n\nlet limites = minMax(array: [8, -6, 2, 100, 3, 71])\nprint(\"El m\u00ednimo es \\(limites.min) y el m\u00e1ximo es \\(limites.max)\")\n// Imprime \"El m\u00edmimo es -6 y el m\u00e1ximo es 100\"\n</code></pre> <p>En este ejemplo nos apartamos un poco de la soluci\u00f3n vista en Scheme porque permitimos pasos de ejecuci\u00f3n que inicializan variables. Pero no nos salimos del paradigma funcional, porque todas son variables inmutables definidas con <code>let</code>.</p>"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#5-tipos-funcion","title":"5. Tipos funci\u00f3n","text":"<p>En Swift las funciones son objetos de primera clase y podemos asignarlas a variables, pasarlas como par\u00e1metro o devolverlas como resultado de otra funci\u00f3n. </p> <p>El siguiente ejemplo muestra todos los posibles usos de una funci\u00f3n como objeto de primera clase en Swift. M\u00e1s adelante veremos con m\u00e1s detalle cada uno de los casos.</p> <pre><code>// Definimos una funci\u00f3n simple que suma dos n\u00fameros\nfunc suma(a: Int, b: Int) -&gt; Int {\n    return a + b\n}\n\n// Asignamos la funci\u00f3n suma a una variable\nlet miSuma = suma\n\n// Llamamos a la funci\u00f3n suma usando la variable\nlet resultado = miSuma(3, 4)\nprint(\"La suma de 3 y 4 es: \\(resultado)\") \n// Salida: La suma de 3 y 4 es: 7\n\n// Definimos una funci\u00f3n que toma otra funci\u00f3n como par\u00e1metro y la aplica a dos n\u00fameros\nfunc aplicarOperacion(_ operacion: (Int, Int) -&gt; Int, a: Int, b: Int) -&gt; Int {\n    return operacion(a, b)\n}\n\nlet resultadoAplicarOperacion = aplicarOperacion(suma, a: 5, b: 6)\nprint(\"La suma de 5 y 6 es: \\(resultadoAplicarOperacion)\") \n// Salida: La suma de 5 y 6 es: 11\n\n// Definimos una funci\u00f3n que devuelve otra funci\u00f3n como resultado\nfunc obtenerOperacion() -&gt; ((Int, Int) -&gt; Int) {\n    return suma\n}\n\nlet funcionObtenida = obtenerOperacion()\nlet resultadoFuncionObtenida = funcionObtenida(7, 8)\nprint(\"La suma de 7 y 8 es: \\(resultadoFuncionObtenida)\") \n// Salida: La suma de 7 y 8 es: 15\n</code></pre> <p>Como vemos en el ejemplo anterior, el funcionamiento de los objetos funci\u00f3n es similar al que ya hemos visto en Scheme. Pero con una diferencia importante: al ser Swift un lenguaje fuertemente tipado, debemos especificar el tipo de los par\u00e1metros o resultados de tipo funci\u00f3n.</p> <p>El tipo espec\u00edfico de la funci\u00f3n est\u00e1 definido por el tipo de sus par\u00e1metros y el tipo del valor devuelto.</p> <pre><code>func sumaDosInts(a: Int, b: Int) -&gt; Int {\n    return a + b\n}\nfunc multiplicaDosInts(a: Int, b: Int) -&gt; Int {\n    return a * b\n}\n</code></pre> <p>El tipo de estas funciones es <code>(Int, Int) -&gt; Int</code>, que se puede leer como:</p> <p>\"Un tipo funci\u00f3n que tiene dos par\u00e1metros, ambos de tipo <code>Int</code> y que devuelve un valor de tipo <code>Int</code>\".</p> <p>Como hemos visto en el primer ejemplo, podemos asignar estas funciones a una variable de tipo funci\u00f3n:</p> <pre><code>var f = sumaDosInts\nprint(f(2,3))\n// Imprime \"5\"\nf = multiplicaDosInts\nprint(f(2,3))\n// Imprime \"6\"\n</code></pre> <p>La variable <code>f</code> es una variable de tipo <code>(Int, Int) -&gt; Int</code>, o sea, una variable que contiene funciones de dos argumentos <code>Int</code> que devuelven un <code>Int</code>.</p> <p>Nota</p> <p>Habr\u00e1s notado que al invocar a <code>f</code> no se ponen etiquetas en los argumentos. De hecho, si las pusi\u00e9ramos el compilador de Swift se quejar\u00eda:</p> <pre><code>print(f(a:2, b:3))\n//error: extraneous argument labels 'a:b:' in call\n</code></pre> <p>Esto es debido a que al ser <code>f</code> una variable se le puede asignar cualquier funci\u00f3n que tenga el tipo <code>(Int, Int) -&gt; Int</code> sin tener en cuenta las etiquetas de los argumentos.</p>"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#51-funciones-que-reciben-otras-funciones","title":"5.1. Funciones que reciben otras funciones","text":"<p>Tal y como vimos en el ejemplo inicial, podemos usar un tipo funci\u00f3n en par\u00e1metros de otras funciones:</p> <pre><code>func printResultado(funcion: (Int, Int) -&gt; Int, _ a: Int, _ b: Int) {\n    print(\"Resultado: \\(funcion(a, b))\")\n}\nprintResultado(funcion: sumaDosInts, 3, 5)\n// Prints \"Resultado: 8\"\n</code></pre> <p>La funci\u00f3n <code>printResultado(funcion:_:_:)</code> toma como primer par\u00e1metro otra funci\u00f3n que recibe dos <code>Int</code> y devuelve un <code>Int</code>, y como segundo y tercer par\u00e1metro dos <code>Int</code>. Y en el cuerpo llama a la funci\u00f3n que se pasa como par\u00e1metro con los argumentos <code>a</code> y <code>b</code>.</p> <p>Veamos otro ejemplo, que ya vimos en Scheme. Supongamos que queremos calcular el sumatorio desde <code>a</code> hasta <code>b</code> en el que aplicamos una funci\u00f3n <code>f</code> a cada n\u00famero que sumamos:</p> <pre><code>sumatorio(a, b, f) = f(a) + f(a+1) + f(a+2) + ... + f(b)\n</code></pre> <p>Recordamos que se resuelve con la siguiente recursi\u00f3n:</p> <pre><code>sumatorio(a, b, f) = f(a) + sumatorio(a+1, b, f)\nsumatorio(a, b, f) = 0 si a &gt; b\n</code></pre> <p>Veamos c\u00f3mo se implementa en Swift: </p> <pre><code>func sumatorio(desde a: Int, hasta b: Int, func f: (Int) -&gt; Int) -&gt; Int {\n   if a &gt; b { \n      return 0 \n   } else {\n      return f(a) + sumatorio(desde: a + 1, hasta: b, func: f)\n   }\n}\n\nfunc identidad(_ x: Int) -&gt; Int {\n   return x\n}\n\nfunc doble(_ x: Int) -&gt; Int {\n   return x + x\n}\n\nfunc cuadrado(_ x: Int) -&gt; Int {\n    return x * x\n}\n\nprint(sumatorio(desde: 0, hasta: 10, func: identidad)) // Imprime 55\nprint(sumatorio(desde: 0, hasta: 10, func: doble)) // Imprime 110\nprint(sumatorio(desde: 0, hasta: 10, func: cuadrado)) // Imprime 385\n</code></pre>"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#52-funciones-en-estructuras","title":"5.2. Funciones en estructuras","text":"<p>Como cualquier otro tipo Las funciones pueden tambi\u00e9n incluirse en   estructuras de datos compuestas, como arrays:</p> <pre><code>let funciones = [identidad, doble, cuadrado]\nprint(funciones[0](10)) // 10\nprint(funciones[1](10)) // 20 \nprint(funciones[2](10)) // 100\n</code></pre> <p>El tipo de la variable <code>funciones</code> ser\u00eda <code>[(Int) -&gt; Int]</code>. </p> <p>Al ser Swift fuertemente tipado, no podr\u00edamos hacer un array con distintos tipos de funciones. Por ejemplo el siguiente c\u00f3digo dar\u00eda un error:</p> <pre><code>func suma(_ x: Int, _ y: Int) -&gt; Int {\n   return x + y\n}\n// La siguiente l\u00ednea genera un error\nlet misFunciones = [doble, cuadrado, suma]\n// error: heterogenous collection literal could only be inferred to\n// '[Any]'; add explicit type annotation if this is intentional\n</code></pre>"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#53-funciones-que-devuelven-otras-funciones","title":"5.3 Funciones que devuelven otras funciones","text":"<p>Por \u00faltimo, veamos un ejemplo de funciones que devuelven otras funciones. </p> <p>Es un ejemplo sencillo, una funci\u00f3n que devuelve otra que suma 10:</p> <pre><code>func construyeSumador10() -&gt; (Int) -&gt; Int {\n  func suma10(x: Int) -&gt; Int {return x+10}\n  return suma10\n}\n\nlet g = construyeSumador10()\nprint(g(20))\n// Imprime 30\n</code></pre> <p>La funci\u00f3n devuelta por <code>construyeSumador10()</code> es una funci\u00f3n con el tipo <code>(Int) -&gt; Int</code> (recibe un par\u00e1metro entero y devuelve un entero). En la llamada a <code>construyeSumador10()</code> se crea esa funci\u00f3n y se asigna a la variable <code>g</code>.</p> <p>Estas funciones devueltas se denominan clausuras. M\u00e1s adelante hablaremos algo m\u00e1s de ellas. Veremos tambi\u00e9n m\u00e1s adelante que es posible usar expresiones de clausura que construyen clausuras an\u00f3nimas. </p> <p>Podemos modificar el ejemplo anterior, haciendo que la funci\u00f3n <code>construyeSumador</code> reciba el n\u00famero a sumar como par\u00e1metro:</p> <pre><code>func construyeSumador(inc: Int) -&gt; (Int) -&gt; Int {\n  func suma(x: Int) -&gt; Int {return x+inc}\n  return suma\n}\n\nlet f2 = construyeSumador(inc: 10)\nlet f3 = construyeSumador(inc: 100)\nprint(f2(20))\n// Imprime \"30\"\nprint(f3(20))\n// Imprime \"120\"\n</code></pre> <p>Invocamos dos veces a <code>construyeSumador(inc:)</code> y guardamos las clausuras construidas en las variables <code>f2</code> y <code>f3</code>. En <code>f2</code> se guarda una funci\u00f3n que suma <code>10</code> a su argumento y en <code>f3</code> otra que suma <code>100</code>.</p>"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#6-tipos","title":"6. Tipos","text":"<p>Entre las ventajas del uso de tipos est\u00e1 la detecci\u00f3n de errores en los programas en tiempo de compilaci\u00f3n o las ayudas del entorno de desarrollo para autocompletar c\u00f3digo. Entre los inconvenientes se encuentra la necesidad de ser m\u00e1s estrictos a la hora de definir los par\u00e1metros y los valores devueltos por las funciones, lo que impide la flexibilidad de Scheme.</p> <p>Se utilizan tipos para definir los posibles valores de:</p> <ul> <li>variables</li> <li>par\u00e1metros de funciones</li> <li>valores devueltos por funciones</li> </ul> <p>Tal y como hemos visto cuando hemos comentado que Swift es fuertemente tipado las definiciones de tipos van precedidas de dos puntos en las variables y par\u00e1metros, o de una flecha (<code>-&gt;</code>) en la definici\u00f3n de los tipos de los valores devueltos por una funci\u00f3n:</p> <pre><code>let valorDouble : Double = 3.0\nlet unaCadena: String = \"Hola\"\n\nfunc calculaEstadisticas(valores: Array&lt;Int&gt;) -&gt; (min: Int, max: Int, media: Int) {\n   ...\n}\n</code></pre> <p>En Swift existen dos clases de tipos: tipos con nombre y tipos compuestos. </p>"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#61-tipos-con-nombre","title":"6.1. Tipos con nombre","text":"<p>Un tipo con nombre es un tipo al que podemos dar un nombre determinado cuando se define. Por ejemplo, al definir un nombre de una clase o de un enumerado estamos tambi\u00e9n definiendo un nombre de un tipo.</p> <p>En Swift es posible definir los siguientes tipos con nombre:</p> <ul> <li>nombres de clases</li> <li>nombres de estructuras</li> <li>nombres de enumeraciones</li> <li>nombres de protocolos </li> </ul> <p>Por ejemplo, instancias de una clase definida por el usuario llamada <code>MiClase</code> tienen el tipo <code>MiClase</code>. </p> <p>Adem\u00e1s de los tipos definidos por el usuario, la biblioteca est\u00e1ndar de Swift tiene un gran n\u00famero de tipos predefinidos. A diferencia de otros lenguajes, estos tipos no son parte del propio lenguaje sino que se definen en su mayor\u00eda como estructuras implementadas en esta biblioteca est\u00e1ndar. Por ejemplo, arrays, diccionarios o incluso los tipos m\u00e1s b\u00e1sicos como <code>String</code> o <code>Int</code> est\u00e1n construidos en esa biblioteca. La implementaci\u00f3n de estos elementos est\u00e1 disponible en abierto en el sitio GitHub de Swift. </p>"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#62-tipos-compuestos","title":"6.2. Tipos compuestos","text":"<p>Los tipos compuestos son tipos sin nombre. En Swift se definen dos: tuplas y tipos funci\u00f3n. Un tipo compuesto puede tener tipos con nombre y otros tipos compuestos. Por ejemplo la tupla <code>(Int, (Int, Int))</code> contiene dos elementos: el primero es el tipo con nombre <code>Int</code> y el segundo el tipo compuesto que define la tupla <code>(Int, Int)</code>. Los tipos funci\u00f3n los hemos visto previamente.</p> <pre><code>let tupla: (Int, Int, String) = (2, 3, \"Hola\")\nlet otraTupla: (Int, Int, String) = (5, 8, \"Adios\")\n\nfunc sumaTupla(tupla t1: (Int, Int), con t2: (Int, Int)) -&gt; (Int, Int) {\n  return (t1.0 + t2.0, t1.1 + t2.1)\n}\n\nprint(sumaTupla(tupla: (tupla.0, tupla.1),\n                con: (otraTupla.0, otraTupla.1)))\n\n// Imprime (7, 11)\n</code></pre>"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#621-typealias","title":"6.2.1. Typealias","text":"<p>En Swift se define la palabra clave <code>typealias</code> para darle un nombre asignado a cualquier otro tipo. Ambos tipos son iguales a todos los efectos (es \u00fanicamente az\u00facar sint\u00e1ctico).</p> <p>Por ejemplo, en el siguiente c\u00f3digo definimos un <code>typealias</code> llamado <code>Resultado</code> que corresponde a una tupla con dos <code>Int</code> correspondientes al resultado de un partido de futbol. Una vez definido, podemos usarlo como un tipo. La funci\u00f3n <code>quiniela(partido:)</code> devuelve un <code>String</code> correspondiente al resultado de la quiniela de un partido:</p> <pre><code>typealias Resultado = (Int, Int)\n\nfunc quiniela(partido: Resultado) -&gt; String {\n  switch partido {\n    case let (goles1, goles2) where goles1 &lt; goles2:\n      return \"Dos\"\n    case let (goles1, goles2) where goles1 &gt; goles2:\n      return \"Uno\"\n    default:\n      return \"Equis\"\n  }\n}\n\nprint(quiniela(partido: (1,3)))\n// Imprime \"Dos\"\nprint(quiniela(partido: (2,2)))\n// Imprime \"Equis\"\n</code></pre> <p>En el ejemplo se usa una sentencia <code>switch</code> que recibe el resultado del partido. Este resultado es una tupla de dos enteros. En el <code>case let</code> se instancia los valores de esa tupla en las variables <code>goles1</code> y <code>goles2</code> y despu\u00e9s se define una condici\u00f3n para entrar en el caso. En el primer caso, que <code>goles1</code> sea menor que <code>goles2</code> y en el segundo que <code>goles1</code> sea mayor que <code>goles2</code>.</p>"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#63-tipos-valor-y-tipos-referencia","title":"6.3. Tipos valor y tipos referencia","text":"<p>En Swift existen dos tipos de construcciones que forman la base de la programaci\u00f3n orientada a objetos: las estructuras (structs) y las clases. En el tema siguiente hablaremos sobre ello.</p> <p>En la biblioteca est\u00e1ndar de Swift la mayor parte de los tipos definidos (como <code>Int</code>, <code>Double</code>, <code>Bool</code>, <code>String</code>, <code>Array</code>, <code>Dictionary</code>, etc.) son estructuras, no clases.</p> <p>Una de las diferencias m\u00e1s importantes entre estructuras y clases es su comportamiento en una asignaci\u00f3n: las estructuras tienen una sem\u00e1ntica de copia (son tipos valor) y las clases tienen una sem\u00e1ntica de referencia (son tipos referencia).</p> <p>Un tipo valor es un tipo que tiene sem\u00e1ntica de copia en las asignaciones y cuando se pasan como par\u00e1metro en llamadas a funciones.</p> <p>Los tipos valor son muy \u00fatiles porque evitan los efectos laterales en los programas y simplifican el comportamiento del compilador en la gesti\u00f3n de memoria. Al no existir referencias, se simplifica enormemente la gesti\u00f3n de memoria de estas estructuras. No es necesario llevar la cuenta de qu\u00e9 referencias apuntan a un determinado valor, sino que se puede liberar la memoria en cuanto se elimina el \u00e1mbito actual.</p> <p>Frente a un tipo valor, un tipo de referencia es aquel en los que los valores se asignan a variables con una sem\u00e1ntica de referencia. Cuando se realizan varias asignaciones de una misma instancia a distintas variables todas ellas guardan una referencia a la misma instancia. Si la instancia se modifica, todas las variables reflejar\u00e1n el nuevo valor. Cuando veamos las clases en el pr\u00f3ximo tema veremos algunos ejemplos.</p> <p>Veamos ahora algunos ejemplos de copia por valor en estructuras.</p> <p>Por ejemplo, si asignamos una cadena a otra, se realiza una copia:</p> <pre><code>var str1 = \"Hola\"\nvar str2 = str1\nstr1.append(\"Adios\")\nprint(str1) // Imprime \"HolaAdios\"\nprint(str2) // Imprime \"Hola\"\n</code></pre> <p>Los arrays tambi\u00e9n son estructuras y, por tanto, tambi\u00e9n tienen sem\u00e1ntica de copia:</p> <pre><code>var array1 = [1, 2, 3, 4]\nvar array2 = array1\narray1[0] = 10\nprint(array1) // [10, 2, 3, 4]\nprint(array2) // [1, 2, 3, 4]\n</code></pre> <p>A diferencia de otros lenguajes como Java, los par\u00e1metros de una funci\u00f3n siempre son inmutables y se pasan por copia, para reforzar el car\u00e1cter funcional de las funciones. Por ejemplo, es incorrecto escribir lo siguiente:</p> <pre><code>func ponCero(array: [Int], pos: Int) {\n    array[pos] = 0\n// error: cannot assign through subscript: 'array' is a 'let' constant\n}\n</code></pre> <p>Se podr\u00eda pensar que es muy costoso copiar un array entero. Por ejemplo, si asignamos o pasamos como par\u00e1metro un array de 1000 elementos. Pero no es as\u00ed. El compilador de Swift optimiza estas sentencias y s\u00f3lo realiza la copia en el momento en que hay una modificaci\u00f3n de una de las variables que comparten el array. Es lo que se llama copy on write.</p>"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#7-enumeraciones","title":"7. Enumeraciones","text":"<p>Las enumeraciones definen un tipo con un valor restringido de posibles valores:</p> <pre><code>enum Direccion {\n    case norte\n    case sur\n    case este\n    case oeste\n}\n</code></pre> <p>Cualquier variable del tipo <code>Direccion</code> solo puede tener uno de los cuatro valores definidos. Se obtiene el valor escribiendo el nombre de la enumeraci\u00f3n, un punto y el valor definido. Si el tipo de enumeraci\u00f3n se puede inferir no es necesario escribirlo.</p> <pre><code>let hemosGirado = true\nvar direccionActual = Direccion.norte\nif hemosGirado {\n   direccionActual = .sur\n}\n</code></pre> <p>En sentencias switch:</p> <pre><code>let direccionAIr = Direccion.sur\nswitch direccionAIr {\ncase .norte:\n   print(\"Nos vamos al norte\")\ncase .sur:\n   print(\"Cuidado con los pinguinos\")\ncase .este:\n    print(\"Donde nace el sol\")\ncase .oeste:\n    print(\"Donde el cielo es azul\")\n}\n// Imprime \"Cuidado con los pinguinos\"\n</code></pre> <p>Otro ejemplo:</p> <pre><code>enum Planeta {\n    case mercurio, venus, tierra, marte, jupiter, saturno, urano, neptuno\n}\n</code></pre> <p>Y, por \u00faltimo, es m\u00e1s correcto definir el resultado de una quiniela con un enumerado en lugar de con un <code>String</code>:</p> <pre><code>enum Quiniela {\n    case uno, equis, dos\n}\n</code></pre>"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#71-valores-brutos-de-enumeraciones","title":"7.1. Valores brutos de enumeraciones","text":"<p>Es posible asignar a las constantes del enumerado un valor concreto de un tipo subyacente, por ejemplo enteros:</p> <pre><code>enum Quiniela: Int {\n    case uno=1, equis=0, dos=2\n}\n</code></pre> <p>Se puede obtener el valor bruto a partir del propio tipo o de una variable del tipo, usando <code>rawValue</code>:</p> <pre><code>// Obtenemos el valor bruto a partir del tipo\nlet valorEquis: Int = Quiniela.equis.rawValue\n\n// Obtenemos el valor bruto a partir de una variable\nlet res = Quiniela.equis\nlet valorEquis = res.rawValue\n</code></pre> <p>Tambi\u00e9n se puede asignar los valores de forma impl\u00edcita, dando un valor a la primera constante. Las siguientes tienen el valor consecutivo:</p> <pre><code>enum Planeta: Int {\n    case mercurio=1, venus, tierra, marte, jupiter, saturno, urano, neptuno\n}\nlet posicionTierra = Planeta.tierra.rawValue\n// posicionTierra es 3\n</code></pre> <p>Podemos escoger cualquier tipo subyacente. Por ejemplo el tipo <code>Character</code>:</p> <pre><code>enum CaracterControlASCII: Character {\n    case tab = \"\\t\"\n    case lineFeed = \"\\n\"\n    case carriageReturn = \"\\r\"\n}\n</code></pre> <p>El car\u00e1cter nueva l\u00ednea (lineFeed) se puede obtener de la siguiente forma:</p> <pre><code>let nuevaLinea = CaracterControlASCII.LineFeed.rawValue\n</code></pre> <p>Y por \u00faltimo, se puede definir como tipo subyacente <code>String</code> y los valores brutos de las constantes ser\u00e1n sus nombres convertidos a cadenas:</p> <pre><code>enum Direccion: String {\n    case norte, sur, este, oeste\n}\nlet direccionAtardecer = Direccion.oeste.rawValue\n// direccionAtardecer es \"oeste\"\n</code></pre> <p>En este caso, tambi\u00e9n se puede inicializar el valor bruto con una asignaci\u00f3n expl\u00edcita y no usar el propio nombre:</p> <pre><code>enum Direccion: String {\n    case norte = \"north\"\n    case sur = \"south\"\n    case este = \"east\"\n    case oeste = \"west\"\n}\nlet direccionAtardecer = Direccion.oeste.rawValue\n// direccionAtardecer es \"west\"\n</code></pre> <p>Cuando se definen valores brutos es posible inicializar el enumerado de una forma similar a una estructura o una clase pasando el valor bruto. Devuelve el valor enumerado correspondiente o <code>nil</code> (un opcional):</p> <pre><code>let posiblePlaneta = Planeta(rawValue: 7)\n// posiblePlaneta es de tipo Planeta? y es igual a Planeta.urano\n</code></pre>"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#8-enumeraciones-instanciables","title":"8. Enumeraciones instanciables","text":"<p>Una caracter\u00edstica singular de las enumeraciones en Swift es que permiten definir valores variables asociados a cada caso de la enumeraci\u00f3n, creando algo muy parecido a una instancia de la enumeraci\u00f3n.</p>"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#81-valores-asociados-a-instancias-de-enumeraciones","title":"8.1. Valores asociados a instancias de enumeraciones","text":"<p>Un enumerado instanciable permite asociar valores a la instancia del enumerado. Para crear una instancia del enumerado debemos proporcionar el valor asociado.</p> <p>Al igual que un enumerado normal, el enumerado puede especificar distintos casos. Cada caso puede determinar un tipo de valor asociado.</p> <p>En otros lenguajes de programaci\u00f3n se llaman uniones etiquetadas o variantes.</p> <p>Por ejemplo, podemos definir un enumerado que permita guardar un <code>Int</code> o un <code>String</code>:</p> <pre><code>enum Multiple {\n    case num(Int)\n    case str(String)\n}\n</code></pre> <p>De esta forma, podemos crear valores de tipo <code>Multiple</code> que contienen un <code>Int</code> (instanciando el caso <code>num</code>) o un <code>String</code> (instanciando el caso <code>str</code>):</p> <pre><code>let valor3 = Multiple.num(10)\nlet valor4 = Multiple.str(\"Hola\")\n</code></pre> <p>Para obtener el valor asociado debemos usar una expresi\u00f3n <code>case let</code> en una sentencia <code>switch</code> con una variable a la que se asigna el valor. Por ejemplo, la siguiente funci\u00f3n reciba instancias de tipo <code>Multiple</code> e imprime el valor asociado al enumerado que se pasa como par\u00e1metro.</p> <pre><code>func imprime(multiple: Multiple) {\n    switch multiple {\n    case let .num(x):\n        print(\"Multiple tiene un Int: \\(x)\")\n    case let .str(s):\n        print(\"Multiple tiene un String: \\(s)\")\n    }\n}\nimprime(multiple: valor3)\n// Imprime \"Multiple tiene un Int: 10\"\nimprime(multiple: valor4)\n// Imprime \"Multiple tiene un String: Hola\n</code></pre> <p>Nota</p> <p>No hay que confundir un valor asociado a un caso y un valor bruto: el valor bruto de un caso de enumeraci\u00f3n es el mismo para todas las instancias, mientras que el valor asociado es distinto y se proporciona cuando se define el valor concreto de la enumeraci\u00f3n.</p> <p>El tipo del caso tambi\u00e9n puede ser un tipo compuesto, como una tupla. Usamos un enum para definir posibles valores de un c\u00f3digo de barras, en el que incluimos dos posibles tipos de c\u00f3digo de barras: el c\u00f3digo de barras lineal (denominado UPC) y el c\u00f3digo QR:</p> <pre><code>enum CodigoBarras {\n    case upc(Int, Int, Int, Int)\n    case qrCode(String)\n}\n</code></pre> <p>Se lee de la siguiente forma: \u201cDefinimos un tipo enumerado llamado <code>CodigoBarras</code>, que puede tomar como valor un <code>upc</code> (c\u00f3digo de barras lineal) con un valor asociado de tipo <code>(Int, Int, Int, Int)</code> (una tupla de 4 enteros que representan los 4 n\u00fameros que hay en los c\u00f3digos de barras lineales) o un valor <code>qrCode</code> con valor asociado de tipo <code>String</code>\". </p> <p>Veamos un ejemplo de uso, en el que creamos un c\u00f3digo de barras de producto de tipo UPC, despu\u00e9s lo modificamos a otro de tipo c\u00f3digo QR y por \u00faltimo lo imprimimos:</p> <pre><code>var codigoBarrasProducto = CodigoBarras.upc(8, 85909, 51226, 3)\ncodigoBarrasProducto = .qrCode(\"ABCDEFGHIJKLMNOP\")\n\nswitch codigoBarrasProducto {\ncase let .upc(sistemaNumeracion, fabricante, producto, control):\n   print(\"UPC: \\(sistemaNumeracion), \\(fabricante), \\(producto), \\(control).\")\ncase let .qrCode(codigoProducto):\n   print(\"C\u00f3digo QR: \\(codigoProducto).\")\n}\n// Imprime  \"C\u00f3digo QR : ABCDEFGHIJKLMNOP.\"\n</code></pre>"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#82-enumeraciones-recursivas","title":"8.2. Enumeraciones recursivas","text":"<p>Es posible combinar las caracter\u00edsticas de las enumeraciones con valor con la recursi\u00f3n para crear enumeraciones recursivas. Hay que preceder la palabra clave <code>enum</code> con <code>indirect</code>:</p> <pre><code>indirect enum ExpresionAritmetica {\n    case numero(Int)\n    case suma(ExpresionAritmetica, ExpresionAritmetica)\n    case multiplicacion(ExpresionAritmetica, ExpresionAritmetica)\n}\n\nlet cinco = ExpresionAritmetica.numero(5)\nlet cuatro = ExpresionAritmetica.numero(4)\nlet suma = ExpresionAritmetica.suma(cinco, cuatro)\nlet producto = ExpresionAritmetica.multiplicacion(suma, ExpresionAritmetica.numero(2))\n</code></pre> <p>Es muy c\u00f3modo manejar enumeraciones recursivas de forma recursiva:</p> <pre><code>func evalua(expresion: ExpresionAritmetica) -&gt; Int {\n    switch expresion {\n    case let .numero(valor):\n        return valor\n    case let .suma(izquierda, derecha):\n        return evalua(expresion: izquierda) + evalua(expresion: derecha)\n    case let .multiplicacion(izquierda, derecha):\n        return evalua(expresion: izquierda) * evalua(expresion: derecha)\n    }\n}\n\nprint(evalua(expresion: producto))\n// Imprime 18\n</code></pre> <p>Otro ejemplo de enums recursivos, para definir un tipo de datos <code>Lista</code> similar al que vimos en Scheme. La lista puede ser una lista vac\u00eda o puede contener dos elementos: un valor <code>Int</code> y otra lista:</p> <pre><code>indirect enum Lista {\n    case vacia\n    case nodo(Int, Lista)\n}\n</code></pre> <p>Para crear una lista de tipo <code>nodo</code> deberemos dar un valor entero (el valor de la cabeza de la lista) y otra lista (el resto de la lista). Tambi\u00e9n podemos crear una lista vac\u00eda.</p> <p>Por ejemplo, podemos crear la lista <code>(10, 20, 30)</code> de la siguiente manera:</p> <pre><code>let lista1 = Lista.nodo(30, Lista.vacia)\nlet lista2 = Lista.nodo(20, lista1)\nlet lista3 = Lista.nodo(10, lista2)\n</code></pre> <p>Podr\u00edamos crear esta misma lista de una forma m\u00e1s abreviada:</p> <pre><code>let lista: Lista = .nodo(10, .nodo(20, .nodo(30, .vacia)))\n</code></pre> <p>Una vez definido el tipo enumerado, podemos definir funciones que trabajen con \u00e9l. La siguiente funci\u00f3n, por ejemplo, es una funci\u00f3n recursiva que recibe una lista y devuelve la suma de sus elementos. Funciona de una forma muy similar a la definici\u00f3n que hicimos en Scheme:</p> <pre><code>func suma(lista: Lista) -&gt; Int {\n    switch lista {\n    case  .vacia:\n        return 0\n    case let .nodo(first, rest):\n        return first + suma(lista: rest)\n    }\n}\n\nlet z: Lista = .nodo(20, .nodo(10, .vacia))\n\nprint(suma(lista: z))\n// Imprime 30\n</code></pre> <p>Podemos tambi\u00e9n definir una funci\u00f3n recursiva <code>construye(lista:[Int])</code> que devuelve una lista a partir de una array de enteros:</p> <pre><code>func construye(lista: [Int]) -&gt; Lista {\n    if (lista.isEmpty) {\n        return Lista.vacia\n    } else {\n        let primero = lista[0]\n        let resto = Array(lista.dropFirst())\n        return Lista.nodo(primero, construye(lista: resto))\n    } \n}\n\nlet lista2 = construye(lista: [1,2,3,4,5])\n\nprint(suma(lista: lista2))\n// Imprime 15\n</code></pre>"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#9-opcionales","title":"9. Opcionales","text":"<p>Una de las caracter\u00edsticas principales que Swift intenta promover es la seguridad y la robustez. Debe ser dif\u00edcil que el desarrollador escriba c\u00f3digo con errores y que rompa la aplicaci\u00f3n. Por ejemplo, la comprobaci\u00f3n est\u00e1tica de los tipos de datos o el manejo autom\u00e1tico de la gesti\u00f3n de memoria son dos caracter\u00edsticas del lenguaje que van en esta direcci\u00f3n.</p> <p>Otro de los elementos m\u00e1s importantes del lenguaje para promover la seguridad son los opcionales. Vamos a estudiar su uso y utilidad.</p> <p>En muchos lenguajes existe el concepto de valor vac\u00edo. Por ejemplo, en Java se usa null o en Python None. </p> <p>Nota</p> <p>Tony Hoare introdujo el concepto de Null en ALGOL, en 1965. En una conferencia en 2009 habla sobre esta idea y la considera un costoso error: Null References: The Billion Dollar Mistake. </p> <p>El concepto de null es un concepto peligroso, como lo saben bien los desarrolladores Java. En Java, si intentamos usar una variable que contiene null se produce la t\u00edpica excepci\u00f3n null pointer exception y la aplicaci\u00f3n se rompe. Todos hemos ca\u00eddo en este error, y con m\u00e1s frecuencia de la que ser\u00eda deseable.</p> <p>En Swift tambi\u00e9n existe el valor nulo. La forma de representarlo es el identificador <code>nil</code>. </p> <p>La caracter\u00edstica de seguridad que introduce Swift con respecto a Java y a otros lenguajes es que no es posible asignar <code>nil</code> a una variable de un tipo normal.</p> <p>Por ejemplo, la siguiente l\u00ednea dar\u00eda un error de compilaci\u00f3n:</p> <pre><code>let cadena: String = nil\n// error: 'nil' cannot initialize specified type 'String'\n</code></pre> <p>Si queremos utilizar <code>nil</code> debemos declarar la variable usando lo que se denomina tipo opcional:</p> <pre><code>var cadena: String? = \"Hola\"\ncadena = nil\n</code></pre> <p>El tipo <code>String?</code> indica que podemos tener un valor <code>nil</code> o un valor del tipo original. Primero estamos definiendo la variable <code>cadena</code> del tipo <code>String?</code> (<code>String</code> opcional) y le estamos asignando un valor determinado (de tipo <code>String</code>). Y despu\u00e9s le asignamos <code>nil</code>.</p> <p>El uso de opcionales es necesario en situaciones en las que podemos obtener un valor desconocido. Por ejemplo, en alguna funci\u00f3n en la que pedimos un valor al usuario y el usuario puede no introducir ninguno. O en estructuras de datos en las que hacemos b\u00fasquedas que pueden no devolver ning\u00fan valor, como en un diccionario:</p> <pre><code>var edades = [\n    \"Raquel\": 30,\n    \"Pedro\": 22,\n]\nlet edad1 = edades[\"Raquel\"]\nlet edad2 = edades[\"Ana\"] // devuelve nil\n</code></pre> <p>En el c\u00f3digo anterior definimos un diccionario <code>edades</code> con claves de tipo <code>String</code> y valores <code>Int</code>. Despu\u00e9s buscamos en el diccionario por la clave <code>\"Raquel\"</code> y se devuelve el valor <code>30</code>, que se guarda en la variable <code>edad1</code>. Cuando se busca por la clave <code>\"Ana\"</code> se devuelve un <code>nil</code> porque no est\u00e1 definida. </p> <p>Por ello, la variable <code>edad2</code> ser\u00e1 de tipo <code>Int?</code> (<code>Int</code> opcional) y contendr\u00e1 un <code>nil</code>.</p> <p>Un valor opcional no puede ser usado directamente. Primero debemos comprobar si el valor es distinto de <code>nil</code> y s\u00f3lo despu\u00e9s podremos usarlo. </p> <p>Para reforzar esto, Swift esconde o envuelve (wrap) el valor real del opcional y obliga a llamar al operador <code>!</code> para desenvolverlo (unwrap) y usarlo. Este operador se denomina de desenvoltura forzosa (forced unwrapping).</p> <p>Por ejemplo, el siguiente c\u00f3digo produce un error de compilaci\u00f3n porque intentamos usar un opcional sin desenvolverlo:</p> <pre><code>var x: Int? = 10\nlet y = x + 10 \n// error: value of optional type 'Int?' must be unwrapped to a value of type 'Int'\n</code></pre> <p>Para usar el valor asignado a <code>x</code> debemos desenvolverlo con el operador <code>!</code>:</p> <pre><code>var x: Int? = 10\nlet y = x! + 10 \nprint(y)\n// Imprime \"20\"\n</code></pre> <p>Si se aplica el operador <code>!</code> a un valor <code>nil</code> se produce un error en tiempo de ejecuci\u00f3n y la aplicaci\u00f3n se rompe:</p> <pre><code>var respuestaEncuesta: String?\nprint(respuestaEncuesta!)\n// Fatal error: Unexpectedly found nil while unwrapping an Optional value\n</code></pre> <p>Podemos definir como opcional variables, par\u00e1metros o valores devueltos por funciones de cualquier tipo, a\u00f1adi\u00e9ndoles la interrogaci\u00f3n al final.</p> <p>Por ejemplo, la siguiente funci\u00f3n <code>max</code> es una funci\u00f3n que devuelve un <code>Int?</code>, un entero opcional en el caso de que se le pase un array vac\u00edo. Al devolver un opcional, debemos desenvolver el valor devuelto cuando queramos usarlo como <code>Int</code> (por ejemplo, en la llamada recursiva).</p> <pre><code>func max(array:[Int]) -&gt; Int? {\n    if (array.isEmpty) {\n        return nil\n    } else if (array.count == 1) {\n        return array[0]\n    } else {\n        let primero = array[0]\n        let resto = Array(array.dropFirst())\n        return max(primero, max(array:resto)!)\n    }\n}\n\nlet maximo = max(array:[10,200,-100,2])\nprint(maximo!)\n// Imprime \"200\"\n</code></pre> <p>Una variable opcional sin asignar ning\u00fan valor se inicializa autom\u00e1ticamente a <code>nil</code>:</p> <pre><code>var respuestaEncuesta: String?\n// respuestaEncuesta es inicializado autom\u00e1ticamente a nil\n</code></pre>"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#91-ligado-opcional","title":"9.1 Ligado opcional","text":"<p>Para comprobar si un valor opcional es <code>nil</code> podemos usar un <code>if</code>. Es obligado hacerlo si desconocemos el valor que nos llega. Por ejemplo, supongamos que la funci\u00f3n <code>leerRespuesta()</code> lee una respuesta del usuario y devuelve un <code>String?</code>. Para usar esta funci\u00f3n deber\u00edamos comprobar si el valor devuelto es distinto de <code>nil</code>:</p> <pre><code>let respuestaEncuesta = leerRespuesta()\nif respuestaEncuesta != nil {\n    let respuesta = respuestaEncuesta!\n    print(\"Respuesta: \" + respuesta)\n}\n</code></pre> <p>Como es muy habitual hacer lo anterior, en Swift es posible comprobar si un opcional tiene valor y asignar su valor a otra variable al mismo tiempo con una construcci\u00f3n llamada ligado opcional (optional binding):</p> <pre><code>let respuestaEncuesta = leerRespuesta()\nif let respuesta = respuestaEncuesta {\n    print (\"Respuesta: \" + respuesta)\n}\n</code></pre> <p>Podemos leer el c\u00f3digo anterior de la siguiente forma: \"Si el opcional <code>respuestaEncuesta</code> contiene un valor, define la constante <code>respuesta</code> con el valor contenido en el opcional\".</p> <p>Una forma a\u00fan mejor de escribir el c\u00f3digo anterior ser\u00eda la siguiente, en la que s\u00f3lo usamos una variable:</p> <pre><code>// Mejor este c\u00f3digo que el anterior\nif let respuesta = leerRespuesta() {\n    print (\"Respuesta: \" + respuesta)\n}\n</code></pre> <p>Nota</p> <p>Para no tener que buscar un nuevo nombre de variable, Swift permite  usar el mismo nombre de variable en la sentencia <code>if let</code>:</p> <p><pre><code>var x: Int? = 0\nif let x = x {\n    print(x)\n}\n</code></pre> La variable <code>x</code> creada por el <code>if let</code> es de tipo no opcional y s\u00f3lo tiene valor  en el \u00e1mbito del <code>if</code>.</p> <p>Otro ejemplo, el m\u00e9todo <code>first</code> de un array devuelve un opcional que contiene <code>nil</code> si el array est\u00e1 vac\u00edo o el primer elemento del array en el caso en que exista. El siguiente c\u00f3digo utiliza un ligado opcional para implementar otra versi\u00f3n de la funci\u00f3n que suma los valores de un array:</p> <pre><code>func sumaValores(_ valores: [Int]) -&gt; Int {\n    if let primero = valores.first {\n        let resto = Array(valores.dropFirst())\n        return primero + sumaValores(resto)\n    } else {\n        return 0\n    }\n}\n\nprint(sumaValores([1,2,3,4,5,6,7,8])) \n// Imprime \"36\"\n</code></pre> <p>Si tenemos varios opcionales es posible comprobar que todos ellos son distintos de <code>nil</code> usando varios <code>let</code> en el mismo <code>if</code>:</p> <pre><code>var x1: Int? = pedirNumUsuario()\nvar x2: Int? = pedirNumUsuario()\nvar x3: Int? = pedirNumUsuario()\nif let dato1 = x1, let dato2 = x2, let dato3 = x3 {\n   let suma = dato1+dato2+dato3\n   print(\"Ning\u00fan nil y la suma de todos los datos es: \\(suma)\")\n} else {\n   print(\"Alg\u00fan dato del usuario es nil\")\n}\n</code></pre>"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#92-comparacion-con-opcionales","title":"9.2 Comparaci\u00f3n con opcionales","text":"<p>No es necesario desenvolver un opcional para compararlo con otro valor usando los operadores <code>==</code> o <code>!=</code>.</p> <p>Por ejemplo, el siguiente c\u00f3digo es correcto:</p> <pre><code>var x: Int? = 10\nx == 10 // devuelve true\nx != nil // devuelve true\nx == 0 // devuelve false\n</code></pre> <p>Si en el opcional hay <code>nil</code> solo devolver\u00e1 <code>true</code> cuando se compare con <code>nil</code>:</p> <pre><code>x = nil\nx == nil // devuelve true\nx == 10 // devuelve false\n</code></pre>"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#93-operador-nil-coalescing","title":"9.3. Operador nil-coalescing","text":"<p>El operador nil-coalescing (<code>??</code>) permite definir un valor por defecto en una asignaci\u00f3n si un opcional es nil.</p> <pre><code>let a: Int? = nil\nlet b: Int? = 10\nlet x = a ?? -1\nlet y = b ?? -1\nprint(\"Resultado: \\(x), \\(y)\")\n// Imprime Resultado: -1, 10\n</code></pre> <p>En el ejemplo anterior, en la variable <code>x</code> se guardar\u00e1 el valor <code>-1</code> y en la variable <code>y</code> el valor <code>10</code>.</p>"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#94-encadenamiento-de-opcionales","title":"9.4. Encadenamiento de opcionales","text":"<p>El encadenamiento de opcionales (optional chaining) permite llamar a un m\u00e9todo de una variable que contiene un opcional. Si la variable no es <code>nil</code>, se ejecuta el m\u00e9todo y se devuelve su valor como un opcional. Si la variable es <code>nil</code> se devuelve <code>nil</code>.</p> <pre><code>let nombre1: String? = \"Pedro\"\nlet nombre2: String? = nil\n\n// Error: let str1 = nombre1.lowercased()\n// No podemos llamar al m\u00e9todo lowercased() del String\n// porque nombre es opcional y puede tener nil\n\nlet str1 = nombre1?.lowercased()\nlet str2 = nombre2?.lowercased()\n// str1: String? = \"pedro\"\n// str2: String? = nil\n</code></pre>"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#95-definicion-de-lista-con-opcionales","title":"9.5. Definici\u00f3n de <code>Lista</code> con opcionales","text":"<p>Veamos como \u00faltimo ejemplo una segunda versi\u00f3n del enum <code>Lista</code>, en el que utilizamos un \u00fanico <code>case</code>, pero dando la posibilidad de que el resto de la lista sea <code>nil</code> haci\u00e9ndolo opcional.</p> <p>Definimos el enumerado y tambi\u00e9n la funci\u00f3n <code>suma(lista:)</code>:</p> <pre><code>indirect enum Lista{\n    case nodo(Int, Lista?)\n}\n\nfunc suma(lista: Lista?) -&gt; Int {\n    switch lista {\n        case nil:\n            return 0\n        case let .nodo(first, rest):\n            return first + suma(lista: rest)\n    }\n}\n\nlet z: Lista = .nodo(20, .nodo(10, nil))\nprint(suma(lista: z))\n/// Devuelve 30\n</code></pre>"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#10-clausuras","title":"10. Clausuras","text":"<p>Ya hemos visto previamente que en Swift las funciones son objetos de primera clase del lenguaje y que es posible definir funciones y pasarlas como par\u00e1metro de otras funciones. </p> <p>Tambi\u00e9n es posible construir clausuras, funciones definidas en el \u00e1mbito de otras funciones y devueltas como resultados.</p> <p>Veremos primero c\u00f3mo definir de forma compacta funciones que se pasan como par\u00e1metro de otras, utilizando expresiones de clausuras. Y despu\u00e9s veremos c\u00f3mo las clausuras definidas en el interior de otras funciones capturan las variables definidas en el \u00e1mbito de la funci\u00f3n principal.</p>"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#101-expresiones-de-clausuras","title":"10.1. Expresiones de clausuras","text":"<p>Swift permite definir expresiones compactas con las que construir estas funciones que se pasan como par\u00e1metro de otras funciones. Se denominan expresiones de clausuras (closure expressions). Estas expresiones proporcionan optimizaciones de sintaxis para escribir clausuras de forma concisa y clara. Vamos a ver las distintas optimizaciones utilizando como ejemplo el m\u00e9todo <code>sorted(by:)</code>.</p>"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#102-el-metodo-sortedby","title":"10.2. El m\u00e9todo <code>sorted(by:)</code>","text":"<p>Tal y como hemos visto anteriormente la biblioteca st\u00e1ndar de Swift define un m\u00e9todo <code>sorted()</code> que devuelve los elementos ordenados de un Array. El array original no se modifica. La comparaci\u00f3n entre los elementos se realiza usando el comparador <code>&lt;</code>.</p> <p>Veamos un ejemplo con un array de cadenas:</p> <pre><code>let estudiantes = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nlet ordenados = estudiantes.sorted()\nprint(ordenados)\n// Imprime \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\n</code></pre> <p>Esta funci\u00f3n es similar a las que hay en muchos lenguajes. El \u00fanico aspecto funcional es que el array original no se modifica, sino que la ordenaci\u00f3n construye un nuevo array (existe una funci\u00f3n alternativa mutable que se denomina <code>sort()</code>). </p> <p>Lo interesante relacionado con las clausuras est\u00e1 en la funci\u00f3n <code>sorted(by:)</code>. En esta funci\u00f3n se utiliza una clausura como par\u00e1metro para modificar la comparaci\u00f3n entre elementos y resultar en una ordenaci\u00f3n distinta. Es una de las distintas funciones de orden superior que se definen en las colecciones (m\u00e1s adelante veremos otras).</p> <p>El perfil de la funci\u00f3n <code>sorted(by:)</code> es:</p> <pre><code>func sorted(by areInIncreasingOrder: (Element, Element) -&gt; Bool)\n</code></pre> <p>El par\u00e1metro es una funci\u00f3n de dos par\u00e1metros (del tipo de los elementos del array) que devuelve un booleano indicando si el primer par\u00e1metro va antes que el segundo en el array ordenado. La clausura de ordenaci\u00f3n devuelve <code>true</code> si el primer valor deber\u00eda aparecer antes del segundo valor y <code>false</code> en otro caso.</p> <p>Por ejemplo, podr\u00edamos ordenar un array de cadenas en orden alfab\u00e9tico inverso. </p> <pre><code>func primeroMayor(s1: String, s2: String) -&gt; Bool {\n    return s1 &gt; s2\n}\nlet estudiantes = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nlet alreves = estudiantes.sorted(by: primeroMayor)\nprint(alreves)\n// Imprime [\"Peter\", \"Kweku\", \"Kofi\", \"Akosua\", \"Abena\"]\n</code></pre> <p>Si la primera cadena (<code>s1</code>) es mayor que la segunda cadena (<code>s2</code>), la funci\u00f3n <code>primeroMayor(s1:s2:)</code> devolver\u00e1 <code>true</code>, indicando que <code>s1</code> deber\u00eda aparecer antes que <code>s2</code> en el array ordenado. La ordenaci\u00f3n mayor o menor se refiere a la ordenaci\u00f3n alfab\u00e9tica, al estar tratando con caracteres.</p> <p>La versi\u00f3n anterior es una forma bastante complicada de escribir lo que b\u00e1sicamente es una funci\u00f3n de una \u00fanica expresi\u00f3n (<code>a &gt; b</code>). En este ejemplo, ser\u00eda preferible escribir la clausura de ordenaci\u00f3n inline, utilizando la sintaxis de expresiones de clausuras.</p>"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#103-sintaxis-de-las-expresiones-de-clausura","title":"10.3. Sintaxis de las expresiones de clausura","text":"<p>La sintaxis de las expresiones de clausura tiene la siguiente forma general:</p> <pre><code>{ ( &lt;parametros&gt;) -&gt; &lt;tipo devuelto&gt; in\n   &lt;sentencias&gt;\n}\n</code></pre> <p>Si aplicamos esta sintaxis al ejemplo anterior:</p> <pre><code>let alreves = estudiantes.sorted(by: { (s1: String, s2: String) -&gt; Bool in\n    return s1 &gt; s2\n})\n</code></pre> <p>Hay que hacer notar que la declaraci\u00f3n de los par\u00e1metros y el tipo devuelto por esta clausura inline es id\u00e9ntica a la declaraci\u00f3n de la funci\u00f3n <code>primeroMayor(s1:s2:)</code>. En ambos casos, se escribe como <code>(s1: String, s2: String) -&gt; Bool</code>. Sin embargo, en la expresi\u00f3n de clausura los par\u00e1metros y el tipo devuelto se escribe dentro de las llaves, no fuera.</p> <p>El comienzo del cuerpo de la clausura se introduce por la palabra clave <code>in</code>. Esta palabra clave indica que la definici\u00f3n de los par\u00e1metros y del tipo devuelto por la clausura ha terminado, y que el cuerpo de la clausura va a comenzar.</p> <p>Como el cuerpo de la clausura es corto, podemos incluso escribirlo en una \u00fanica l\u00ednea:</p> <pre><code>let alreves = estudiantes.sorted(by: { (s1: String, s2: String) -&gt; Bool in return s1 &gt; s2 } )\n</code></pre>"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#104-inferencia-del-tipo-por-el-contexto","title":"10.4. Inferencia del tipo por el contexto","text":"<p>Como la clausura de ordenaci\u00f3n se pasa como argumento de un m\u00e9todo, Swift puede inferir los tipos de sus par\u00e1metros y el tipo del valor que devuelve. El m\u00e9todo <code>sorted(by:)</code> se llama sobre un array de cadenas, por lo que su argumento debe ser una funci\u00f3n del tipo <code>(String, String) -&gt; Bool</code>. Esto significa que los tipos <code>(String, String)</code> y <code>Bool</code> no necesitan escribirse como parte de la definici\u00f3n de la expresi\u00f3n de la clausura. Debido a que todos los tipos pueden ser inferidos, la flecha del tipo devuelto y los par\u00e9ntesis alrededor de los nombres de los par\u00e1metros tambi\u00e9n pueden omitirse:</p> <pre><code>let alreves = estudiantes.sorted(by: { s1, s2 in return s1 &gt; s2 } )\n</code></pre>"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#105-devoluciones-implicitas-en-clausuras-con-una-unica-expresion","title":"10.5. Devoluciones impl\u00edcitas en clausuras con una \u00fanica expresi\u00f3n","text":"<p>En clausuras con una \u00fanica expresi\u00f3n podemos omitir tambi\u00e9n la palabra clave <code>return</code>:</p> <pre><code>let alreves = estudiantes.sorted(by: { s1, s2 in s1 &gt; s2 } )\n</code></pre>"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#106-abreviaturas-en-los-nombres-de-los-argumentos","title":"10.6. Abreviaturas en los nombres de los argumentos","text":"<p>Swift proporciona autom\u00e1ticamente abreviaturas para los nombres de argumentos de las clausuras inline que pueden usarse para referirse a los valores de los argumentos de la clausura usando los nombres <code>$0</code>, <code>$1</code>, <code>$2</code>, etc.</p> <p>Si se usa estos argumentos abreviados, se puede omitir la definici\u00f3n de la lista de los argumentos:</p> <pre><code>let alreves = estudiantes.sorted(by: { $0 &gt; $1 } )\n</code></pre>"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#107-funciones-operadoras","title":"10.7. Funciones operadoras","text":"<p>Incluso hay una forma aun m\u00e1s corta de escribir la expresi\u00f3n de clausura anterior.  Swift define una implementaci\u00f3n espec\u00edfica de cadenas del operador mayor-que (<code>&gt;</code>) como una funci\u00f3n que tiene dos par\u00e1metros de tipo <code>String</code> y devuelve un <code>Bool</code>. Esto es exactamente lo que necesita el m\u00e9todo <code>sorted(by:)</code>. Podemos, por tanto, pasar simplemente este operador mayor-que, y Swift inferir\u00e1 que queremos usar el espec\u00edfico de cadenas:</p> <pre><code>let alreves = estudiantes.sorted(by: &gt;)\n</code></pre>"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#108-clausuras-al-final","title":"10.8. Clausuras al final","text":"<p>Si necesitamos pasar una expresi\u00f3n de clausura a una funci\u00f3n como el argumento final de la clausura y la expresi\u00f3n es larga, puede ser \u00fatil escribirla en su lugar como una clausura al final (trailing closure). Una clausura al final es una expresi\u00f3n de clausura que se escribe fuera de (y despu\u00e9s de) los par\u00e9ntesis de la funci\u00f3n a la que se le pasa como par\u00e1metro:</p> <pre><code>let alreves = estudiantes.sorted() { $0 &gt; $1 }\n</code></pre> <p>Cuando se proporciona una expresi\u00f3n de clausura como \u00fanico argumento de una funci\u00f3n o m\u00e9todo y se pasa como una clausura al final, no es necesario escribir los par\u00e9ntesis tras el nombre de la funci\u00f3n:</p> <pre><code>let alreves = estudiantes.sorted { $0 &gt; $1 }\n</code></pre>"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#109-variables-capturadas","title":"10.9. Variables capturadas","text":"<p>Cuidado</p> <p>Los ejemplos que vamos a ver a continuaci\u00f3n no usan programaci\u00f3n funcional, porque la variable capturada por la clausura es una variable mutable (se ha definido con <code>var</code> y no con <code>let</code>). Por eso las funciones resultantes no son funciones puras, sino que devuelven un valor distinto cada vez que son invocadas. Son  funciones con estado local mutable.</p> <p>Una clausura puede capturar constantes y variables del contexto en el que se define. La clausura puede referirse y modificar esos valores dentro de su cuerpo, incluso si ya no existe el \u00e1mbito (scope) original en el que se definieron estas constantes y variables.</p> <p>En Swift, la forma m\u00e1s sencilla de una clausura que captura variables es una funci\u00f3n anidada (nested function) escrita en el cuerpo de otra funci\u00f3n. Una funci\u00f3n anidada puede capturar cualquiera de los argumentos de su funci\u00f3n exterior y tambi\u00e9n puede capturar cualquier constante y variable definida dentro de la funci\u00f3n exterior.</p> <p>Veamos un ejemplo similar al que vimos en Scheme. La funci\u00f3n <code>construyeIncrementador</code> contiene una funci\u00f3n anidada llamada <code>incrementador</code>. Esta funci\u00f3n captura dos variables de su contexto: <code>totalAcumulado</code> y <code>cantidad</code>. Despu\u00e9s de capturar estas variables, <code>incrementador</code> es devuelto por <code>construyeIncrementador</code> como una clausura que incrementa <code>totalAcumulado</code> en <code>cantidad</code> cada vez que se llama.</p> <pre><code>func construyeIncrementador(incremento cantidad: Int) -&gt; () -&gt; Int {\n    var totalAcumulado = 0\n    func incrementador() -&gt; Int {\n        totalAcumulado += cantidad\n        return totalAcumulado\n    }\n    return incrementador\n}\n</code></pre> <p>El tipo devuelto de <code>construyeIncrementador</code> es <code>() -&gt; Int</code>. Esto significa que devuelve una funci\u00f3n que no tiene par\u00e1metros y que devuelve un <code>Int</code> cada vez que es llamada.</p> <p>La funci\u00f3n <code>construyeIncrementador(incremento:)</code> tiene un \u00fanico par\u00e1metro <code>Int</code> con nombre externo <code>incremento</code> y nombre local <code>cantidad</code>. El argumento pasado a este par\u00e1metro especifica cu\u00e1nto ser\u00e1 incrementado <code>totalAcumulado</code> cada vez que se llama a la funci\u00f3n <code>incrementador</code> devuelta. La funci\u00f3n <code>construyeIncrementador</code> define una funci\u00f3n anidada llamada <code>incrementador</code>, que realiza el incremento real. Esta funci\u00f3n simplemente a\u00f1ade <code>cantidad</code> a <code>totalAcumulado</code>, y devuelve el resultado.</p> <p>Si la consideramos aislada, la funci\u00f3n anidada <code>incrementador()</code> podr\u00eda parecer extra\u00f1a:</p> <pre><code>func incrementador() -&gt; Int {\n    totalAcumulado += cantidad\n    return totalAcumulado\n}\n</code></pre> <p>La funci\u00f3n no tiene ning\u00fan par\u00e1metro, y sin embargo se refiere a <code>totalAcumulado</code> y a <code>cantidad</code> en su cuerpo. Lo puede hacer porque ha capturado una referencia a estas variables de la funci\u00f3n de alrededor y las usa en su propio cuerpo. Al capturar estas referencias las variables <code>totalAcumulado</code> y <code>cantidad</code> no desaparecen cuando termina la llamada a <code>construyeIncrementador</code>. Estas variables tambi\u00e9n estar\u00e1n disponibles la pr\u00f3xima vez que se llame la funci\u00f3n <code>incrementador</code>.</p> <p>Aqu\u00ed hay un ejemplo de <code>construyeIncrementador</code> en acci\u00f3n:</p> <pre><code>let incrementaDiez = construyeIncrementador(incremento: 10)\n</code></pre> <p>Este ejemplo define una constante llamada <code>incrementaDiez</code> para referenciar la funci\u00f3n <code>incrementador</code> que devuelve <code>construyeIncrementador</code>. Esta funci\u00f3n a\u00f1ade 10 a la variable <code>totalAcumulado</code> cada vez que se es llamada. Si llamamos a la funci\u00f3n m\u00e1s de una vez podemos comprobar su conducta en acci\u00f3n:</p> <pre><code>incrementaDiez()\n// devuelve 10\nincrementaDiez()\n// devuelve 20\nincrementaDiez()\n// devuelve 30\n</code></pre> <p>Si creamos un segundo incrementador, tendr\u00e1 sus propias referencias a un variable <code>totalAcumulado</code> nueva, distinta de la anterior:</p> <pre><code>let incrementaSiete = construyeIncrementador(incremento: 7)\nincrementaSiete()\n// devuelve 7\n</code></pre> <p>Si llamamos a la funci\u00f3n <code>incrementador</code> original (<code>incrementaDiez</code>) vemos que sigue incrementando su propia variable <code>totalAcumulado</code> y que no se ve afectada por la variable capturada por <code>incrementaSiete</code>:</p> <pre><code>incrementaDiez()\n// devuelve 40\n</code></pre>"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#1010-clausuras-con-expresiones-de-clausura","title":"10.10. Clausuras con expresiones de clausura","text":"<p>En el ejemplo anterior hemos usado una definici\u00f3n interna de una funci\u00f3n para definir la clausura que se devuelve. Lo hemos hecho por claridad, pero no es necesario. Es posible escribir un c\u00f3digo m\u00e1s compacto usando expresiones de clausura.</p> <p>Por ejemplo, la funci\u00f3n <code>construyeSumador()</code> vista en el apartado \"Funciones que devuelven otras funciones\":</p> <pre><code>func construyeSumador10() -&gt; (Int) -&gt; Int {\n  func suma10(x: Int) -&gt; Int {return x+10}\n  return suma10\n}\n</code></pre> <p>Una versi\u00f3n de esta misma funci\u00f3n usando una expresi\u00f3n de clausura es la siguiente:</p> <pre><code>func construyeSumador10() -&gt; (Int) -&gt; Int {\n    return {$0 + 10}\n}\n\nlet f = construyeSumador10()\nprint(f(20))\n// Imprime \"30\"\n</code></pre> <p>Y lo mismo con la funci\u00f3n <code>constryeIncrementador(incremento:)</code> vista en el apartado anterior:</p> <pre><code>func construyeIncrementador(incremento cantidad: Int) -&gt; () -&gt; Int {\n    var totalAcumulado = 0\n    func incrementador() -&gt; Int {\n        totalAcumulado += cantidad\n        return totalAcumulado\n    }\n    return incrementador\n}\n</code></pre> <p>La versi\u00f3n con una expresi\u00f3n de clausura:</p> <pre><code>func construyeIncrementador(incremento cantidad: Int) -&gt; () -&gt; Int {\n    var totalAcumulado = 0\n    return {totalAcumulado += cantidad\n            return totalAcumulado}\n}\n\nlet incrementaDiez = construyeIncrementador(incremento: 10)\nprint(incrementaDiez())\n// Imprime \"10\"\nprint(incrementaDiez())\n// Imprime \"20\"\n</code></pre>"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#1011-variables-capturadas-por-clausuras-y-variables-del-ambito-de-invocacion","title":"10.11. Variables capturadas por clausuras y variables del \u00e1mbito de invocaci\u00f3n","text":"<p>Las clasuras usan las variables capturadas y no las variables declaradas en el \u00e1mbito en el que se invoca a la clausura. Vamos a explicarlo con un ejemplo.</p> <pre><code>func construyeFunc() -&gt; () -&gt; Int {\n   var x = 0\n   return {\n      x = x + 1\n      return x\n   }\n}\n\nlet f = construyeFunc()\nprint(f()) // -&gt; 1\nprint(f()) // -&gt; 2\n\nfunc usaFunc(_ f: () -&gt; Int) -&gt; Int {\n     var x = 10\n     return f()\n}\n\nprint(usaFunc(f)) // -&gt; 3\n\nvar x = 100\nprint(usaFunc {return x + 10}) // -&gt; 110\n</code></pre> <p>En el c\u00f3digo anterior se resaltan las tres declaraciones de variables <code>x</code>. Es muy importante comprobar el \u00e1mbito en el que se realizan esas declaraciones. La primera declaraci\u00f3n se realiza dentro de la funci\u00f3n <code>construyeFunc()</code>, la segunda dentro de la funci\u00f3n <code>usaFunc()</code> y la tercera en el \u00e1mbito global. En cada caso, la variable se inicializar\u00e1 cuando se ejecute esa l\u00ednea de c\u00f3digo. </p> <p>La funci\u00f3n <code>usaFunc</code> definida en la l\u00ednea 13 recibe una funci\u00f3n <code>f</code> sin par\u00e1metros que devuelve un entero. En el \u00e1mbito local de <code>usaFunc</code> se define la variable local <code>x</code> que tiene el valor <code>10</code> antes de invocar a la funci\u00f3n <code>f</code> recibida.</p> <p>\u00bfQu\u00e9 pasa si la funci\u00f3n recibida es una clausura que ha capturado una variable que tambi\u00e9n se llama <code>x</code>? En el caso de la invocaci\u00f3n a <code>usaFunc</code> que hay en la l\u00ednea 18, la funci\u00f3n <code>f</code> que se pasa como par\u00e1metro es la clausura obtenida en la l\u00ednea 9. Esta clausura ha capturado la variable <code>x</code> definida en la l\u00ednea 2. Y en ese momento esa variable tiene el valor 2. El c\u00f3digo de la clausura es el definido en las l\u00edneas 3 a 6:</p> <pre><code>{\nx = x + 1\nreturn x\n}\n</code></pre> <p>\u00bfA qu\u00e9 variable <code>x</code> se refiere ese c\u00f3digo? \u00bfA la variable capturada que tiene un valor de 2? \u00bfO a la variable en el \u00e1mbito de ejecuci\u00f3n (l\u00ednea 14) que tiene un valor de 10?</p> <p>Si ejecutamos el c\u00f3digo veremos que la expresi\u00f3n devuelve 3. O sea que las clausuras usan siempre las variables capturadas.</p> <p>Podemos comprobarlo tambi\u00e9n en la invocaci\u00f3n de la l\u00ednea 21. Ah\u00ed la clausura que se pasa es una expresi\u00f3n de clausura que captura la variable <code>x</code> definida en la l\u00ednea anterior. Por eso cuando se ejecuta la sentencia se imprime el valor <code>110</code> y no el valor <code>20</code>.</p>"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#1012-las-clausuras-son-tipos-de-referencia","title":"10.12. Las clausuras son tipos de referencia","text":"<p>En el ejemplo anterior, <code>incrementaSiete</code> e <code>incrementaDiez</code> son constantes, pero las clausuras a las que estas constantes se refieren pueden incrementar la variable <code>totalAcumulado</code> que han capturado. Esto es porque funciones y clausuras son tipos referencia.</p> <p>Siempre que asignamos una funci\u00f3n o una clausura a una constante o una variable, estamos realmente estableciendo que la constante o variable es una referencia a la funci\u00f3n o la clausura. En el ejemplo anterior, es la elecci\u00f3n de la clausura a la que referencia <code>incrementaDiez</code> la que es constante, no los contenidos propios de la clausura.</p> <p>Esto tambi\u00e9n significa que si asignamos una clausura a dos constantes o variables distintas, ambas constantes o variables se referir\u00e1n a la misma clausura:</p> <pre><code>let tambienIncrementaDiez = incrementaDiez\ntambienIncrementaDiez()\n// devuelve 50\n</code></pre>"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#11-funciones-de-orden-superior","title":"11. Funciones de orden superior","text":"<p>Una de las caracter\u00edsticas funcionales que m\u00e1s hemos usado para trabajar con listas en Scheme son las funciones de orden superior como <code>map</code>, <code>filter</code> o <code>foldl</code>. Swift tiene definidas funciones equivalentes para trabajar con colecciones. Se denominan <code>map</code>, <code>filter</code> y <code>reduce</code>. Todas ellas aceptan expresiones de clausura como argumento.</p>"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#111-map","title":"11.1 Map","text":"<p>El m\u00e9todo <code>map</code> se define en el protocolo <code>CollectionType</code> y es adoptado por m\u00faltiples estructuras como <code>Array</code>, <code>Dictionary</code>, <code>Set</code>.</p> <p>La firma del m\u00e9todo <code>map</code> es el siguiente:</p> <pre><code>func map&lt;T&gt;(_ transform: (Element) -&gt; T) -&gt; [T]\n</code></pre> <p>Se trata de un m\u00e9todo gen\u00e9rico (lo veremos m\u00e1s adelante) que recibe como par\u00e1metro una funci\u00f3n unaria (funci\u00f3n de transformaci\u00f3n)  del tipo de los elementos de la colecci\u00f3n y que devuelve otro elemento (puede ser del mismo o de distinto tipo que los elementos de la colecci\u00f3n). Devuelve un array que contiene el resultado de aplicar la funci\u00f3n de transformaci\u00f3n a cada elemento del array original.</p> <p>Por ejemplo:</p> <pre><code>let numeros = [Int](0...5)\nnumeros.map {$0 * $0}\n// devuelve [0, 1, 4, 9, 16, 25]\n</code></pre> <p>Otro ejemplo, en el que usamos <code>map</code> para implementar la funci\u00f3n <code>sumaParejas(parejas: [(Int, Int)]) -&gt; [Int]</code> que devuelve recibe el array <code>parejas</code> de tuplas de dos enteros y devuelve un array con el resultado de sumar los dos elementos de cada pareja:</p> <pre><code>func suma(parejas: [(Int, Int)]) -&gt; [Int] {\n   return parejas.map({(pareja: (Int, Int)) -&gt; Int in\n                        return pareja.0 + pareja.1})\n}\nsuma(parejas:[(1, 1), (2, 2), (3, 3), (4, 4)])\n// devuelve [2, 4, 6, 8]\n</code></pre> <p>Podemos usar en el cuerpo de la expresi\u00f3n de clausura de <code>map</code> una variable capturada. Por ejemplo en la siguiente funci\u00f3n <code>incrementaValores(_:con:)</code> que suma <code>con</code> a todos los n\u00fameros de un array que se le pasa por par\u00e1metro:</p> <p><pre><code>func incrementa(valores: [Int], con: Int) -&gt; [Int] {\n   return valores.map({(x: Int) -&gt; Int in\n                        return x + con})\n}\nincrementa(valores:[10, 20, 30], con: 5)\n// devuelve [15, 25, 35]\n</code></pre> La versi\u00f3n abreviada de la expresi\u00f3n de clausura es:</p> <pre><code>func incrementa(valores: [Int], con inc: Int) -&gt; [Int] {\n   return valores.map {$0 + inc}\n}\nincrementa(valores: [10, 20, 30], con: 5)\n// devuelve [15, 25, 35]\n</code></pre>"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#112-filter","title":"11.2. Filter","text":"<p>La funci\u00f3n <code>filter</code> es tambi\u00e9n igual que la definida en Scheme. Su perfil es:</p> <pre><code>func filter(_ isIncluded: (Element) -&gt; Bool) -&gt; [Element]\n</code></pre> <p>Recibe una clausura de un argumento que devuelve un booleano. La funci\u00f3n devuelve un array con los elementos de la colecci\u00f3n para los que la clausura devuelve true. </p> <p>Ejemplo:</p> <pre><code>let numeros = [Int](0...10)\nnumeros.filter {$0 % 2 == 0}\n// devuelve [0, 2, 4, 6, 8, 10]\n</code></pre>"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#113-reduce","title":"11.3. Reduce","text":"<p>Similar al foldl de Scheme. Su firma es el siguiente:</p> <pre><code>func reduce&lt;Result&gt;(_ initialResult: Result, \n                    _ nextPartialResult: (Result, Element) -&gt; Result) -&gt; Result\n</code></pre> <p>Es una funci\u00f3n gen\u00e9rica que devuelve un valor de un tipo gen\u00e9rico (el tipo del resultado que se construye en la funci\u00f3n). Recibe como par\u00e1metro un valor inicial y una funci\u00f3n de plegado que se aplica al resultado anterior y al elemento de la colecci\u00f3n, devolviendo un resultado. El resultado final es el resultado de aplicar la funci\u00f3n de plegado a todos los elementos de la colecci\u00f3n, empezando por el valor inicial.</p> <p>Por ejemplo, podemos usar <code>reduce</code> para sumar todos los n\u00fameros de un array:</p> <pre><code>let numeros = [Int](0...10)\nnumeros.reduce(0, +)\n</code></pre> <p>La funci\u00f3n combina los elementos de la colecci\u00f3n usando la funci\u00f3n de combinaci\u00f3n que se pasa como par\u00e1metro. La funci\u00f3n que se pasa como par\u00e1metro recibe dos par\u00e1metros: el primero es el resultado de la combinaci\u00f3n y el segundo se coge de la colecci\u00f3n. </p> <p>Por ejemplo, el siguiente c\u00f3digo usa <code>reduce</code> para sumar la longitud de todas las cadenas de un array:</p> <pre><code>let cadenas = [\"Patatas\", \"Arroz\", \"Huevos\"]\ncadenas.reduce(0, {(i: Int, c: String) -&gt; Int in\n                      c.count + i })\n// devuelve 18\n</code></pre> <p>Es posible simplificar la notaci\u00f3n anterior:</p> <pre><code>cadenas.reduce(0, {$1.count + $0})\n</code></pre> <p>Tambi\u00e9n se puede utilizar la notaci\u00f3n de clausura al final:</p> <pre><code>cadenas.reduce(0) {$1.count + $0}\n</code></pre> <p>La combinaci\u00f3n se hace de izquierda a derecha:</p> <pre><code>let cadenas = [\"Patatas\", \"Arroz\", \"Huevos\"]\nprint(cadenas.reduce(\"*\", {$0 + \"-\" + $1}))\n// Imprime \"*-Patatas-Arroz-Huevos\"\n</code></pre> <p>El primer argumento de la funci\u00f3n de plegado (<code>$0</code>) es el resultado anterior (empieza por <code>\"*\"</code>) y el segundo argumento (<code>$1</code>) se coge del array de cadenas.</p>"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#114-combinacion-de-funciones-de-orden-superior","title":"11.4. Combinaci\u00f3n de funciones de orden superior","text":"<p>Cuando el resultado de aplicar una funci\u00f3n de orden superior a una colecci\u00f3n es otra colecci\u00f3n es posible aplicar otra funci\u00f3n de orden superior a este resultado.</p> <p>Por ejemplo, la siguiente sentencia devuelve todos los n\u00fameros pares del array inicial elevados al cuadrado:</p> <pre><code>let numeros = [1,2,3,4,5,6,7,8,9,10]\nnumeros.filter{$0 % 2 == 0}.map{$0*$0}\n// Devuelve el array [4,16,36,64,100]\n</code></pre> <p>Y la siguiente devuelve la suma n\u00fameros mayores de 100:</p> <pre><code>let numeros = [103, 2, 330, 42, 532, 6, 125]\nnumeros.filter{$0 &gt;= 100}.reduce(0,+)\n// Devuelve 1090\n</code></pre>"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#12-genericos","title":"12. Gen\u00e9ricos","text":"<p>Empecemos con un ejemplo sencillo. Supongamos la siguiente funci\u00f3n <code>intercambia(_:)</code> que recibe una tupla <code>(Int, String)</code> y devuelve una tupla <code>(String, Int)</code> con los valores intercambiados.</p> <pre><code>func intercambia(_ tupla: (Int, String)) -&gt; (String, Int) {\n   let tuplaNueva = (tupla.1, tupla.0)\n   return tuplaNueva\n}\n\nlet tupla = (10, \"Hola\")\nintercambia(tupla)\n// devuelve (\"Hola\", 10)\n</code></pre> <p>La funci\u00f3n es interesante, pero s\u00f3lo recibe tuplas cuya primera componente es un <code>Int</code> y su segunda componente es un <code>String</code>. Supongamos que queremos hacer la misma funci\u00f3n para intercambiar elementos de una tupla <code>(Int, Int)</code>. Tendr\u00edamos que usar el mismo c\u00f3digo, pero cambiando los tipos:</p> <pre><code>func intercambia(_ tupla: (Int, Int)) -&gt; (Int, Int) {\n   let tuplaNueva = (tupla.1, tupla.0)\n   return tuplaNueva\n}\n\nlet tupla = (10, 20)\nintercambia(tupla)\n// devuelve (20, 10)\n</code></pre> <p>El c\u00f3digo es el mismo, lo \u00fanico distinto son los tipos. \u00bfPodr\u00edamos generalizar las funciones anteriores para hacer que el c\u00f3digo pueda trabajar con cualquier tipo? La respuesta es s\u00ed, usando funci\u00f3n gen\u00e9rica:</p> <pre><code>func intercambia&lt;A,B&gt;(_ tupla: (A, B)) -&gt; (B, A) {\n   let tuplaNueva = (tupla.1, tupla.0)\n   return tuplaNueva\n}\n</code></pre> <p>El cuerpo de la funci\u00f3n es id\u00e9ntico a la funci\u00f3n anterior. La diferencia es que en la versi\u00f3n gen\u00e9rica se usan placeholders (los s\u00edmbolos <code>A</code> y <code>B</code>) en lugar de tipos concretos. Son tipos gen\u00e9ricos, que se definen usando un identificador entre s\u00edmbolos de <code>&lt;</code> y <code>&gt;</code>. Los tipos reales que se van a usar en la funci\u00f3n se determinan en cada invocaci\u00f3n a la funci\u00f3n, dependiendo del tipo del par\u00e1metro que se utiliza en la llamada:</p> <pre><code>let tupla = (10, \"Hola\")\nintercambia(tupla)\n// devuelve (\"Hola\", 10)\nlet tupla2 = (10, 20)\nintercambia(tupla2)\n// devuelve (20, 10)\nlet tupla3 = (true, 10.5)\nintercambia(tupla3)\n// devuelve (10.5, true)\n</code></pre> <p>En el primer ejemplo, los tipos <code>A</code> y <code>B</code> se infieren como <code>Int</code> y <code>String</code>. En el segundo ejemplo como <code>Int</code> e <code>Int</code>. Y en el tercero como <code>Bool</code> y <code>Double</code>.</p> <p>Los tipos gen\u00e9ricos se pueden usar en la definici\u00f3n de todos los elementos de Swift: funciones, enums, estructuras, clases, protocolos o extensiones. Terminamos con un ejemplo en el que incluimos muchos conceptos vistos en este tema. Se trata de la implementaci\u00f3n en Swift de listas al estilo Scheme, con las funciones <code>first</code>, <code>resty</code>vacia` usando un enum recursivo con un tipo gen\u00e9rico que permite generalizar el tipo de elementos de la lista.</p> <pre><code>indirect enum Lista&lt;T&gt; {\n     case vacia\n     case nodo(T, Lista&lt;T&gt;)\n}\n\nfunc first&lt;T&gt;(_ lista: Lista&lt;T&gt;) -&gt; T? {\n   switch lista {\n      case let .nodo(primero, _):\n         return primero\n      case .vacia:\n         return nil\n   }\n}\n\nfunc rest&lt;T&gt;(_ lista: Lista&lt;T&gt;) -&gt; Lista&lt;T&gt;? {\n   switch lista {\n      case let .nodo(_, resto):\n         return resto\n      case .vacia:\n         return nil\n   }\n}\n\nfunc vacia&lt;T&gt;(_ lista: Lista&lt;T&gt;) -&gt; Bool {\n   switch lista {\n      case .vacia:\n         return true\n      default:\n         return false\n   }\n}\n\nlet lista : Lista = .nodo(20, .nodo(30, .nodo(40, .vacia)))\nlet lista2 : Lista = .nodo(\"A\", .nodo(\"B\", .nodo(\"C\", .vacia)))\n\nprint(first(rest(lista)!)!) // Imprime 30\nprint(first(rest(lista2)!)!) // Imprime \"B\"\n</code></pre>"},{"location":"teoria/tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html#13-bibliografia","title":"13. Bibliograf\u00eda","text":"<ul> <li>Swift Language Guide<ul> <li>The Basics</li> <li>Collection Types</li> <li>Functions</li> <li>Closures</li> <li>Enumerations</li> <li>Generics</li> </ul> </li> <li>Biblioteca est\u00e1ndar de Swift</li> </ul> <p>Lenguajes y Paradigmas de Programaci\u00f3n, curso 2024\u201325 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Domingo Gallardo, Cristina Pomares, Antonio Bot\u00eda, Francisco Mart\u00ednez</p>"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html","title":"Tema 6: Programaci\u00f3n Orientada a Objetos con Swift","text":""},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#1-introduccion-a-la-programacion-orientada-a-objetos","title":"1. Introducci\u00f3n a la Programaci\u00f3n Orientada a Objetos","text":"<p>La Programaci\u00f3n Orientada a Objetos (POO) es un paradigma de programaci\u00f3n que explota en los 80 pero nace a partir de ideas a finales de los  60 y 70. Por ejemplo, el primer lenguaje con las ideas b\u00e1sicas de POO fue Simula, un lenguaje creado en la d\u00e9cada de los 60.</p> <p>En la d\u00e9cada de los 60 lo habitual era la programaci\u00f3n procedural. Los programas se defin\u00edan usando tipos de datos abstractos y funciones. La modularizaci\u00f3n se realizaba mediante funciones.</p> <p>Como hemos mencionado, a finales de los 60, el lenguaje Simula introduce el concepto de clase. Una abstracci\u00f3n que agrupa estado y funciones en una \u00fanica entidad.</p> <p></p> <p>Sin embargo, tuvo que pasar m\u00e1s de una d\u00e9cada, hasta principios de los 80, para que el paradigma orientado a objetos se popularizara. Una de las razones principales de esta popularizaci\u00f3n fue el lenguaje Smalltalk, un lenguaje creado en Xerox PARC que fue revolucionario en muchos aspectos. Por ejemplo, Smaltallk introdujo conceptos como las interfaces gr\u00e1ficas de usuario (el uso del rat\u00f3n, de las ventanas) o un entorno integrado de programaci\u00f3n que estaba escrito en el propio Smalltalk y que el programador pod\u00eda adaptar y ampliar. En la figura de la derecha podemos ver un ejemplo del entorno, en el que se muestra un ejemplo de escritorio con m\u00faltiples ventanas que se solapan, men\u00fas desplegables, paneles gr\u00e1ficos, etc.</p> <p></p> <p>Alan Kay fue uno de los padres de Smalltalk, el creador del t\u00e9rmino \u201cObject-Oriented\u201d y una de las figuras fundamentales de la historia de la inform\u00e1tica moderna. Trabaj\u00f3 en Xerox PARC y desarroll\u00f3 all\u00ed ideas que han sido clave para la inform\u00e1tica personal (como el Dynabook, precursor de tablets y dispositivos m\u00f3viles y el lenguajes de programaci\u00f3n Smalltalk).</p> <p>Se puede tener una idea de toda esta gesta en su art\u00edculo \u201cThe Early History of Smalltalk\u201d. </p> <p>Algunas frases de Alan Kay:</p> <p>\u201cI invented the term Object-Oriented and I can tell you I did not have C++ in mind.\u201d</p> <p>\u201cSmalltalk is not only NOT its syntax or the class library, it is not even about classes. I'm sorry that I long ago coined the term objects for this topic because it gets many people to focus on the lesser idea. The big idea is messaging.\u201d</p> <p>\u201cSmalltalk's design\u2013and existence\u2013is due to the insight that everything we can describe can be represented by the recursive composition of a single kind of behavioral building block that hides its combination of state and process inside itself and can be dealt with only through the exchange of messages.\u201d</p> <p>En la d\u00e9cada de los 80 el paradigma orientado a objetos tuvo una enorme repercusi\u00f3n y, a partir de ah\u00ed, casi todos los lenguajes lo han adoptado. Lenguajes como  Smalltalk, Java, Scala, Ruby, Python, C#, C++, Swift, etc. utilizan el paradigma orientado a objetos.</p> <p>Entre las caracter\u00edsticas principales del paradigma de programaci\u00f3n orientado a objetos podemos destacar:</p> <ul> <li>Las clases son plantillas est\u00e1ticas definidas en tiempo de   compilaci\u00f3n. Los objetos se instancian a partir de las clases y   se modifican e interact\u00faan en tiempo de ejecuci\u00f3n.</li> <li>Los objetos agrupan estado interno (las denominadas propiedades,   campos o variables de instancias) y conducta (los m\u00e9todos a los   que puede responder el objeto).</li> <li>Existe el polimorfismo. Un mismo m\u00e9todo puede estar definido en m\u00e1s   de una clase. Dependiendo del tipo de la instancia el c\u00f3digo que se   ejecuta es distinto. Por ejemplo, podr\u00edamos definir un m\u00e9todo suma   en la clase Int y otro m\u00e9todo con el mismo nombre en otra clase   String. El primer m\u00e9todo suma dos enteros y el segundo concatena   dos cadenas.</li> <li>En algunos lenguajes orientados a objetos (como Python o Ruby) la   invocaci\u00f3n los m\u00e9todos se hace usando un dispatch   din\u00e1mico: cuando una operaci\u00f3n es invocada sobre un   objeto, el propio objeto determina en tiempo de ejecuci\u00f3n qu\u00e9 c\u00f3digo se ejecuta. </li> <li>Una caracter\u00edstica fundamental de la POO es la herencia. Las clases se pueden definir utilizando otras clases como   plantillas y modificando sus m\u00e9todos y/o variables de instancia para   hacerlas m\u00e1s especializadas.</li> </ul> <p>Existen dos tendencias ortogonales en el dise\u00f1o de lenguajes orientados a objetos. </p> <p>Por un lado una familia de lenguajes orientados a objetos son lenguajes muy din\u00e1micos. Son lenguajes con un tipado d\u00e9bil en los que muchas caracter\u00edsticas de los programas se obtienen en tiempo de ejecuci\u00f3n.</p> <p>Estos lenguajes permiten mayor flexibilidad y generalidad del c\u00f3digo, y tienen caracter\u00edsticas como el dispatch din\u00e1mico o la reflexi\u00f3n (posibilidad de consultar caracter\u00edsticas de la instancia como nombres de m\u00e9todos o propiedades en tiempo de ejecuci\u00f3n).</p> <p>Ejemplos de este tipo de lenguajes son Smalltalk, Ruby, Python, JavaScript o Java (en menor medida).</p> <p>Por otro lado, existen lenguajes de programaci\u00f3n orientados a objetos que tienen un alto componente est\u00e1tico, donde la mayor\u00eda de caracter\u00edsticas del programa se obtienen en tiempo de compilaci\u00f3n. En este tipo de lenguajes se prima que el compilador sea muy robusto y detecte la mayor cantidad de errores a priori y que genere c\u00f3digo muy eficiente. Son lenguajes fuertemente tipados como C++ o Swift.</p> <p>Vamos a detallar a continuaci\u00f3n las caracter\u00edsticas m\u00e1s importantes de Programaci\u00f3n Orientada a Objetos de Swift.</p>"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#2-clases-y-estructuras","title":"2. Clases y estructuras","text":"<p>En el caso de Swift, las clases y las estructuras son muchas m\u00e1s cercanas en funcionalidad que en otros lenguajes, como C o C++, y tienen muchas caracter\u00edsticas comunes. Muchas caracter\u00edsticas de las instancias de una clase se pueden aplicar tambi\u00e9n a las instancias de una estructura. Por eso en Swift se suele hablar de instancias (un t\u00e9rmino m\u00e1s general) en lugar de objetos.</p> <p>Las clases y las estructuras en Swift tienen muchas cosas en com\u00fan. Ambos pueden:</p> <ul> <li>Definir propiedades y almacenar valores</li> <li>Definir m\u00e9todos para proporcionar funcionalidad</li> <li>Definir inicializadores para configurar el estado inicial</li> <li>Ser extendidas para expandir su funcionalidad m\u00e1s all\u00e1 de una   implementaci\u00f3n por defecto</li> <li>Ajustarse a un protocolo </li> </ul> <p>La diferencia fundamental es que las estructuras son tipos valor, mientras que las clases son tipos referencia. La sem\u00e1ntica de copia de ambas es radicalmente distinta. Cuando asignamos una instancia de una estructura a una variable estamos realizando una copia de su valor (por ejemplo, cuando asignamos un n\u00famero entero). Sin embargo, cuando asignamos una instancia de una clase a una variable estamos guardando su referencia. De esta forma en las clases se permiten que existan m\u00e1s de una referencia apuntando a una instancia de una clase.</p> <p>Otras caracter\u00edsticas adicionales de las clases que no tienen las estructuras:</p> <ul> <li>Mediante la herencia una clase puede heredar las caracter\u00edsticas de   otra</li> <li>El casting de tipos permite comprobar e interpretar el tipo de una   instancia de una clase en tiempo de ejecuci\u00f3n</li> <li>Los deinicializadores permiten a una instancia de una clase liberar   los recursos que ha asignado</li> </ul>"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#21-definicion","title":"2.1. Definici\u00f3n","text":"<pre><code>class UnaClase {\n    // definici\u00f3n de clase\n}\nstruct UnaEstructura {\n    // definici\u00f3n de una estructura\n}\n</code></pre> <pre><code>struct CoordsPantalla {\n    var posX = 0\n    var posY = 0\n}\n\nclass Ventana {\n    var esquina = CoordsPantalla()\n    var altura = 0\n    var anchura = 0\n    var visible = true\n    var etiqueta: String?\n}\n</code></pre> <p>El ejemplo define una nueva estructura llamada <code>CoordsPantalla</code>, que describe una coordenada de pantalla con posiciones basadas en p\u00edxeles. La estructura tiene dos propiedades almacenadas llamadas <code>posX</code> y <code>posY</code>. Las propiedades son constantes o variables que se almacenan en la instancia de la clase o de la estructura. El compilador infiere que estas dos propiedades son <code>Int</code> al inicializarlas a los valores iniciales de 0.</p> <p>El ejemplo tambi\u00e9n define una nueva clase llamada <code>Ventana</code> que describe una ventana en una pantalla. Esta clase tiene cinco propiedades variables. La primera, <code>esquina</code>, se inicializa con una instancia nueva de una estructura <code>CoorsPantalla</code> y se infiere que es de tipo <code>CoordsPantalla</code>. Representa la posici\u00f3n superior izquierda de la ventana. Las propiedades <code>altura</code> y <code>anchura</code> representan el n\u00famero de p\u00edxeles de las dimensiones de la pantalla. Se inicializan a 0. La propiedad <code>visible</code> es un <code>Bool</code> que indica si la ventana es visible en pantalla. Por ejemplo, una ventana que est\u00e9 minimizada no ser\u00e1 visible. Por \u00faltimo, <code>etiqueta</code> representa el nombre que aparece en la parte superior de la ventana. Es un <code>String</code> opcional que se inicializa a <code>nil</code> porque no se le asigna un valor inicial.</p>"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#22-instancias-de-clases-y-estructuras","title":"2.2. Instancias de clases y estructuras","text":"<p>La definici\u00f3n de las estructuras y las clases \u00fanicamente definen sus aspectos generales. Para describir una configuraci\u00f3n espec\u00edfica (una resoluci\u00f3n o un modo de v\u00eddeo concreto) es necesario crear una instancia de una estructura o una clase. La sintaxis para crear ambas es similar:</p> <pre><code>var unasCoordsPantalla = CoordsPantalla()\nvar unaVentana = Ventana()\n</code></pre> <p>La forma m\u00e1s sencilla de inicializaci\u00f3n es la anterior. Se utiliza el nombre del tipo de la clase o estructura seguidos de par\u00e9ntesis vac\u00edos. Esto crea una nueva instancia de una clase o estructura, con sus propiedades inicializadas a los valores por defecto definidos en la declaraci\u00f3n de las propiedades.</p> <p>Swift proporciona este inicializador por defecto para clases y estructuras, siempre que no se defina alg\u00fan inicializador expl\u00edcito. M\u00e1s adelante comentaremos c\u00f3mo definir estos inicializadores expl\u00edcitos.</p> <p>En el caso de la instancia <code>unasCoordsPantalla</code> los valores a los que se han inicializado sus propiedades son:</p> <pre><code>unasCoordsPantalla.posX // 0\nunasCoordsPantalla.posY // 0\n</code></pre> <p>Las propiedades de la instancia <code>unaVentana</code> son:</p> <pre><code>unaVentana.esquina // CoordsPantalla con posX = 0 y posY = 0\nunaVentana.altura // 0\nunaVentana.anchura // 0\nunaVentana.visible // true\nunaVentana.etiqueta // nil\n</code></pre> <p>Todas las propiedades de una instancia deben estar definidas despu\u00e9s de haberse inicializado, a no ser que la propiedad sea un opcional.</p>"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#23-acceso-a-propiedades","title":"2.3. Acceso a propiedades","text":"<p>Se puede acceder y modificar las propiedades usando la sintaxis de punto:</p> <pre><code>// Accedemos a la propiedad\nunasCoordsPantalla.posX // Devuelve 0\n// Actualizamos la propiedad\nunasCoordsPantalla.posX = 100\nunaVentana.esquina.posY = 100\n</code></pre>"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#24-inicializacion-de-las-estructuras-por-sus-propiedades","title":"2.4. Inicializaci\u00f3n de las estructuras por sus propiedades","text":"<p>Si en las estructuras no se definen inicializadores expl\u00edcitos (veremos m\u00e1s adelante c\u00f3mo hacerlo) podemos utilizar un inicializador memberwise en el que podemos proporcionar valores de sus propiedades.</p> <p>En las clases no existen los inicializadores memberwise, s\u00f3lo en las estructuras.</p> <p>Por ejemplo, podemos crear una instancia de la estructura anterior con valores distintos de los valores por defecto definidos en la propia estructura.</p> <pre><code>let coords = CoordsPantalla(posX: 200, posY: 400)\n</code></pre> <p>Cuando se llama al inicializador memberwise podemos omitir valores de cualquier propiedad que tenga un valor por defecto, o que sea un opcional. En el ejemplo anterior, la estructura <code>CoordsPantalla</code> tiene valores por defecto de las propiedades <code>posX</code> y <code>posY</code>. Podr\u00edamos omitir cualquier propiedad o ambas y el inicializador usar\u00e1 el valor por defecto de lo que omitamos. Por ejemplo:</p> <pre><code>let coords1 = CoordsPantalla(posX: 200)\nprint(coords1.posX, coords1.posY)\n// Imprime 200 0\n</code></pre>"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#25-estructuras-y-enumeraciones-son-tipos-valor","title":"2.5. Estructuras y enumeraciones son tipos valor","text":"<p>Un tipo valor es un tipo cuyo valor se copia cuando se asigna a una variable o constante, o cuando se pasa a una funci\u00f3n.</p> <p>Todos los tipos b\u00e1sicos de Swift -enteros, n\u00fameros en punto flotante, cadenas, arrays y diccionarios- son tipos valor y se implementan como estructuras. Las estructuras y las enumeraciones son tipos valor en Swift.</p> <pre><code>var coords1 = CoordsPantalla(posX: 600, posY: 600)\nvar coords2 = coords1\ncoords2.posX = 1000\ncoords1.posX // devuelve 600\n</code></pre> <p>En el ejemplo se declara una constante llamada <code>coords1</code> y se asigna a una instancia de <code>CoordsPantalla</code> inicializada con la posici\u00f3n x de 600 y la posici\u00f3n y de 600. Despu\u00e9s se declara una variable llamada <code>coords2</code> y se asigna al valor actual de <code>coors1</code>. Debido a que <code>CoordsPantalla</code> es una estructura, se crea una copia de la instancia existente y esta nueva copia se asigna a <code>coords2</code>. Aunque ahora <code>coords2</code> y <code>coords1</code> tienen las mismas <code>posX</code> y <code>posY</code>, son dos instancias completamente distintas. Despu\u00e9s, la propiedad <code>posX</code> de <code>coords2</code> se actualiza a 1000.</p> <p>Podemos comprobar que la propiedad se modifica, pero que el valor de <code>posX</code> en <code>coords1</code> sigue siendo el mismo.</p>"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#26-las-clases-son-tipos-referencia","title":"2.6. Las clases son tipos referencia","text":"<p>A diferencia de los tipos valor, los tipos de referencias no se copian cuando se asignan o se pasan a funciones. En su lugar se usa una referencia a la misma instancia existente.</p> <p>En Swift las clases son tipos referencias. Veamos, por ejemplo, una instancia de la clase <code>Ventana</code>:</p> <pre><code>var ventana1 = Ventana()\nventana1.esquina = coords1\nventana1.altura = 800\nventana1.anchura = 800\nventana1.etiqueta = \"Finder\"\nvar ventana2 = ventana1\nventana2.anchura = 1000\nventana1.anchura // devuelve 1000\n</code></pre> <p>Declaramos una variable llamada <code>ventana1</code> inicializada con una instancia nueva de la clase <code>Ventana</code>. Le asignamos a la propiedad <code>esquina</code> una copia de la resoluci\u00f3n anterior <code>coords1</code>. Despu\u00e9s declaramos la altura, anchura y etiqueta de la ventana. Y, por \u00faltimo, <code>ventana1</code> se asigna a una nueva constante llamada <code>ventan2</code>, y la anchura se modifica.</p> <p>Debido a que son tipos de referencia, <code>ventana1</code> y <code>ventana2</code> se refieren a la misma instancia de <code>Ventana</code>. Son s\u00f3lo dos nombres distintos para la misma \u00fanica instancia. </p> <p>Lo podemos comprobar modificando una propiedad mediante una variable y viendo que esa misma propiedad en la otra variable se ha modificado tambi\u00e9n (l\u00edneas 7 y 8).</p> <p>Si tienes experiencia con C, C++, o Objective-C, puedes saber que estos lenguajes usan punteros para referirse a una direcci\u00f3n de memoria. Una constante o variable en Swift que se refiere a una instancia de un tipo referencia es similar a un puntero en C, pero no es un puntero que apunta a una direcci\u00f3n de memoria y no requiere que se escriba un asterisco (*) para indicar que estas creando una referencia. En su lugar, estas referencias se definen como cualquier otra constante o variable en Swift.</p>"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#27-declaracion-de-instancias-con-let","title":"2.7. Declaraci\u00f3n de instancias con <code>let</code>","text":"<p>Las estructuras y clases tambi\u00e9n tienen comportamientos distintos cuando se declaran las variables con <code>let</code>.</p> <p>Si definimos con <code>let</code> una instancia de una estructura estamos declarando constante la variable y todas las propiedades de la instancia. No podremos modificar ninguna:</p> <pre><code>let coords3 = CoordsPantalla(posX: 400, posY: 400)\ncoords3.posX = 800\n// error: cannot assign to property: 'coords3' is a 'let' constant\n</code></pre> <p>Si definimos con un <code>let</code> una instancia de una clase s\u00f3lo estamos declarando constante la variable. No podremos reasignarla, pero s\u00ed que podremos modificar las propiedades de la instancia referenciada por la variable:</p> <pre><code>let ventana3 = Ventana()\n// S\u00ed que podemos modificar una propiedad de la instancia:\nventana3.etiqueta = \"Listado\"\n// Pero no podemos reasignar la variable:\nventana3 = ventana1\n// error: cannot assign to value: 'ventana3' is a 'let' constant\n</code></pre>"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#28-operadores-de-identidad","title":"2.8. Operadores de identidad","text":"<p>A veces puede ser \u00fatil descubrir si dos constantes o variables se refieren exactamente a la misma instancia de una clase. Para permitir esto, Swift proporciona dos operadores de identidad:</p> <ul> <li>Id\u00e9ntico a (<code>===</code>)</li> <li>No id\u00e9ntico a (<code>!==</code>)</li> </ul> <pre><code>ventana1 === ventana2 // devuelve true\nventana1 === ventana3 // devuelve false\n</code></pre> <p>Estos operadores \"id\u00e9ntico a\" no son los mismos que los de \"igual a\" (representado por dos signos iguales <code>==</code>):</p> <ul> <li>\"Id\u00e9ntico a\" significa que dos constantes o variables de una clase   se refieren exactamente a la misma instancia de la clase.</li> <li>\"Igual a\" significa que dos instancias se consideran \"iguales\" o   \"equivalentes\" en su valor. Es responsabilidad del dise\u00f1ador de la   clase definir la implementaci\u00f3n de estos operadores.</li> </ul>"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#29-paso-como-parametro","title":"2.9. Paso como par\u00e1metro","text":"<p>En Swift los par\u00e1metros de las funciones son constantes, se definen usando el operador <code>let</code>. Esto hace que sea muy distinto el comportamiento de un par\u00e1metro dependiendo de si es una estructura o una clase.</p> <p>Si la instancia que se pasa como par\u00e1metro a una funci\u00f3n es una estructura su contenido no se podr\u00e1 modificar. Sin embargo, si lo que se pasa es una instancia de una clase, podremos modificar su contenido, ya que (como hemos visto anteriormente) el <code>let</code> hace constante \u00fanicamente la referencia, pero no el contenido.</p> <p>Por ejemplo, la siguiente funci\u00f3n es t\u00edpica de programaci\u00f3n imperativa o procedural. El par\u00e1metro <code>ventana</code> se pasa por referencia y se modifica en el interior de la funci\u00f3n. Su estado cambia. Una vez terminada la funci\u00f3n la variable que hemos pasado como par\u00e1metro contiene una instancia cambiada. Podemos hacerlo porque <code>ventana</code> es una clase.</p> <pre><code>func mueve(ventana: Ventana, incX: Int, incY: Int) {\n    var nuevaPos = CoordsPantalla()\n    nuevaPos.posX = ventana.esquina.posX + incX\n    nuevaPos.posY = ventana.esquina.posY + incY\n    ventana.esquina = nuevaPos\n}\n\nvar ventana1 = Ventana()\nmueve(ventana: ventana1, incX: 500, incY: 500)\nprint(ventana1.esquina)\n// Imprime: CoordsPantalla(posX: 500, posY: 500)\n</code></pre> <p>Sin embargo, si pasamos como par\u00e1metro una instancia de una estructura, \u00e9sta ser\u00e1 inmutable. El siguiente c\u00f3digo genera un error en el compilador que indica que el par\u00e1metro <code>coordsPantalla</code> es una constante y no puede ser modificado:</p> <pre><code>// \u00a1\u00a1C\u00d3DIGO ERR\u00d3NEO!!\nfunc mueve(coordsPantalla: CoordsPantalla, incX: Int, incY: Int) {\n    coordsPantalla.posX = coordsPantalla.posX + incX\n    coordsPantalla.posY = coordsPantalla.posY + incY\n}\n// error: cannot assign to property: 'coordsPantalla' is a 'let' constant\n</code></pre> <p>Si necesitamos hacer una funci\u00f3n con la que se obtenga un valor modificado de una estructura, podemos usar el enfoque funcional de crear una nueva estructura y devolverla como resultado:</p> <pre><code>func mueve(coordsPantalla: CoordsPantalla, incX: Int, incY: Int) -&gt; CoordsPantalla {\n    var nuevaCoord = CoordsPantalla()\n    nuevaCoord.posX = coordsPantalla.posX + incX\n    nuevaCoord.posY = coordsPantalla.posY + incY\n    return nuevaCoord\n}\n\nlet coord1 = CoordsPantalla()\nlet coord2 = mueve(coordsPantalla: coord1, incX: 100, incY: 100)\nprint(coord1)\n// Imprime CoordsPantalla(posX: 100, posY: 100)\n</code></pre> <p>Vemos en el c\u00f3digo que se crea una nueva instancia y que se modifica su valor de forma acorde a lo que quiere hacer la funci\u00f3n y que se devuelve ese nuevo valor.</p> <p>Usando esta \u00faltima funci\u00f3n podr\u00edamos reescribir el c\u00f3digo de la funci\u00f3n que mueve una ventana de la siguiente forma:</p> <pre><code>func mueve(ventana: Ventana, incX: Int, incY: Int) {\n    ventana.esquina = mueve(coordsPantalla: ventana.esquina, \n                            incX: incX, incY: incY)\n}\n</code></pre> <p>Nota</p> <p>Igual que en C, en Swift hay una forma de pasar como referencia una estructura. Hay que utilizar el operador <code>inout</code> precediendo el nombre del par\u00e1metro. Puedes encontrar m\u00e1s informaci\u00f3n en la     documentaci\u00f3n oficial de Swift. Busca el apartado In-Out paremeters en la p\u00e1gina sobre Funciones. </p>"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#210-criterios-para-usar-estructuras-y-clases","title":"2.10. Criterios para usar estructuras y clases","text":"<p>Podemos usar tanto clases como estructuras para definir nuestros tipos de datos y utilizarlos como bloques de construcci\u00f3n del c\u00f3digo de nuestros programas. Sin embargo, se utilizan para distintos tipos de tareas.</p> <p>Como regla general, utilizaremos una estructura cuando se cumplen una o m\u00e1s de las siguientes condiciones:</p> <ul> <li>El principal objetivo de la estructura es encapsular unos pocos   datos relativamente sencillos.</li> <li>Es razonable esperar que los valores encapsulados ser\u00e1n copiados,   m\u00e1s que referenciados, cuando asignamos o pasamos una instancia de   esa estructura.</li> <li>Todas las propiedades almacenadas en la estructura son a su vez   tipos valor, que tambi\u00e9n se espera que sean copiados m\u00e1s que   referenciados.</li> <li>La estructura no necesita heredar propiedades o conducta de otro   tipo existente.</li> </ul> <p>Ejemplos de buenos candidatos de estructuras incluyen:</p> <ul> <li>El tama\u00f1o de una forma geom\u00e9trica, encapsulando por ejemplo las   propiedades <code>ancho</code> y <code>alto</code> de tipo <code>Double</code>.</li> <li>Una forma de referirse a rangos dentro de una serie, encapsulando   por ejemplo, una propiedad <code>comienzo</code> y otra <code>longitud</code>, ambos del   tipo <code>Int</code>.</li> <li>Un punto en un sistema de coordenadas 3D, encapsulando quiz\u00e1s las   propiedades <code>x</code>, <code>y</code> y <code>z</code>, todos ellos de tipo <code>Double</code>.</li> </ul> <p>Usaremos clases cuando queramos utilizar una sem\u00e1ntica de referencia en lugar de una sem\u00e1ntica de valor. Por ejemplo, si queremos tener un grafo de objetos en los que m\u00e1s de un objeto refiere a otro. Tambi\u00e9n cuando queramos utilizar herencia y polimorfismo en nuestro c\u00f3digo.</p> <p>En la pr\u00e1ctica, esto representa que la mayor\u00eda de datos que construiremos en nuestros programas ser\u00e1n clases, no estructuras. Aunque usaremos muchas de las estructuras est\u00e1ndar de Swift.</p>"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#3-propiedades","title":"3. Propiedades","text":"<p>Las propiedades asocian valores con una clase, estructura o enumeraci\u00f3n particular. Las propiedades almacenadas (stored properties) almacenan valores constantes y variables como parte de una instancia, mientras que las propiedades calculadas (computed properties) calculan (en lugar de almacenar) un valor. Las propiedades calculadas se definen en clases, estructuras y enumeraciones. Las propiedades almacenadas se definen s\u00f3lo en clases y estructuras.</p> <ul> <li>Enumeraciones: pueden contener s\u00f3lo propiedades calculadas.</li> <li>Clases y estructuras: pueden contener propiedades almacenadas y calculadas.</li> </ul> <p>Las propiedades calculadas y almacenadas se asocian habitualmente con instancias de un tipo particular. Sin embargo, las propiedades tambi\u00e9n pueden asociarse con el propio tipo. Estas propiedades se conocen como propiedades del tipo (type properties).</p> <p>Adem\u00e1s, en Swift es posible definir observadores de propiedades que monitoricen cambios en los valores de una propiedad, a los que podemos responder con acciones programadas. Los observadores de propiedades pueden a\u00f1adirse tanto a propiedades almacenadas definidas por nosotros como a propiedades heredadas de la superclase.</p>"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#31-propiedades-almacenadas","title":"3.1. Propiedades almacenadas","text":"<p>En su forma m\u00e1s simple, una propiedad almacenada es una constante o variable que est\u00e1 almacenada como parte de una instancia de una clase o estructura particular. Las propiedades almacenadas pueden ser o bien variables (usando la palabra clave <code>var</code>) o bien constantes (usando la palabra clave <code>let</code>).</p> <p>Podemos proporcionar un valor por defecto para la inicializaci\u00f3n de las propiedades almacenadas, tanto variables como constantes.</p> <p>El siguiente ejemplo define una estructura llamada <code>RangoLongitudFija</code> que describe un rango de valores enteros cuya longitud no puede ser modificada una vez que se crea:</p> <pre><code>struct RangoLongitudFija {\n    var primerValor: Int\n    let longitud: Int\n}\nvar rangoTresItems = RangoLongitudFija(primerValor: 0, \n                                       longitud: 3)\n// el rango representa ahora 0, 1, 2\nrangoTresItems.primerValor = 6\n// el rango representa ahora 6, 7, 8\n</code></pre> <p>Las instancias de <code>RangoLongitudFija</code> tienen una propiedad almacenada variable llamada <code>primerValor</code> y una propiedad almacenada constante llamada <code>longitud</code>. En el ejemplo, <code>longitud</code> se inicializa cuando se crea el nuevo rango y no puede ser cambiada en el futuro, por ser una propiedad constante.</p>"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#32-propiedades-calculadas","title":"3.2. Propiedades calculadas","text":"<p>Adem\u00e1s de las propiedades almacenadas, las clases, estructuras y enumeraciones pueden definir propiedades calculadas, que no almacenan realmente un valor. En su lugar, proporcionan un getter y un opcional setter que devuelven y modifican otras propiedades y valores de forma indirecta.</p> <pre><code>struct Punto {\n    var x = 0.0, y = 0.0\n}\nstruct Tama\u00f1o {\n    var ancho = 0.0, alto = 0.0\n}\nstruct Rectangulo {\n    var origen = Punto()\n    var tama\u00f1o = Tama\u00f1o()\n    var centro: Punto {\n        get {\n            let centroX = origen.x + (tama\u00f1o.ancho / 2)\n            let centroY = origen.y + (tama\u00f1o.alto / 2)\n            return Punto(x: centroX, y: centroY)\n        }\n        set(centroNuevo) {\n            origen.x = centroNuevo.x - (tama\u00f1o.ancho / 2)\n            origen.y = centroNuevo.y - (tama\u00f1o.alto / 2)\n        }\n    }\n}\nvar cuadrado = Rectangulo(origen: Punto(x: 0.0, y: 0.0),\n                  tama\u00f1o: Tama\u00f1o(ancho: 10.0, alto: 10.0))\nlet centroCuadradoInicial = cuadrado.centro\ncuadrado.centro = Punto(x: 15.0, y: 15.0)\nprint(\"cuadrado.origen est\u00e1 ahora en (\\(cuadrado.origen.x), \\(cuadrado.origen.y))\")\n// Imprime \"cuadrado.origen est\u00e1 ahora en (10.0, 10.0)\"\n</code></pre> <p>Este ejemplo define tres estructuras para trabajar con formas geom\u00e9tricas:</p> <ul> <li><code>Punto</code> encapsula una coordenada <code>(x, y)</code></li> <li><code>Tama\u00f1o</code> encapsula un ancho y un alto</li> <li><code>Rectangulo</code> define una rect\u00e1ngulo por un punto de origen y un   tama\u00f1o</li> </ul> <p>La estructura <code>Rectangulo</code> proporciona una propiedad calculada llamada <code>centro</code>. La posici\u00f3n actual del centro de un <code>Rectangulo</code> puede ser siempre determinada a partir de su origen y su tama\u00f1o, por lo que no necesitamos almacenarlo como un <code>Punto</code> expl\u00edcito. En su lugar, <code>Rectangulo</code> define un getter y un setter programado para una variable calculada llamada <code>centro</code>, para permitirnos trabajar con el centro del rect\u00e1ngulo como si fuera una propiedad almacenada.</p> <p>En el ejemplo se crea una variable <code>Rectangulo</code> llamada <code>cuadrado</code>. La variable <code>cuadrado</code> se inicializa un punto origen de <code>(0, 0)</code> y un ancho y tama\u00f1o de <code>10</code>. Este cuadrado est\u00e1 representado por el cuadrado azul en el diagrama de abajo.</p> <p>Accedemos entonces a la propiedad <code>centro</code> de la variable <code>cuadrado</code> usando la sintaxis del punto (<code>cuadrado.centro</code>), lo que causa que se llame al getter de <code>centro</code> para devolver el valor actual de la propiedad. En lugar de devolver los valores existentes, el getter calcula realmente y devuelve un nuevo <code>Punto</code> para representar el centro del cuadrado. Como puede verse arriba, el getter devuelve correctamente un punto con los valores <code>(5, 5)</code>.</p> <p>Despu\u00e9s la propiedad centro se actualiza al nuevo valor de <code>(15, 15)</code> lo que mueve el cuadrado arriba a la derecha, a la nueva posici\u00f3n mostrada por el cuadrado naranja en el diagrama de abajo. Al asignar el nuevo valor a la propiedad se llama al setter del centro, lo que modifica los valores <code>x</code> e <code>y</code> de las propiedades almacenadas originales, y mueve el cuadrado a su nueva posici\u00f3n.</p> <p></p> <p>Se puede definir una versi\u00f3n acortada del setter usando la variable por defecto <code>newValue</code> que contiene el nuevo valor asignado en el setter:</p> <pre><code>struct Rectangulo {\n    var origen = Punto()\n    var tama\u00f1o = Tama\u00f1o()\n    var centro: Punto {\n        get {\n            let centroX = origen.x + (tama\u00f1o.ancho / 2)\n            let centroY = origen.y + (tama\u00f1o.alto / 2)\n            return Punto(x: centroX, y: centroY)\n        }\n        set {\n            origen.x = newValue.x - (tama\u00f1o.ancho / 2)\n            origen.y = newValue.y - (tama\u00f1o.alto / 2)\n        }\n    }\n}\n</code></pre>"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#33-propiedades-solo-lectura","title":"3.3. Propiedades solo-lectura","text":"<p>Una propiedad calculada con un getter y sin setter se conoce como una propiedad calculada de solo-lectura. Una propiedad calculada de solo-lectura siempre devuelve un valor, y puede accederse a ella usando la sintaxis de punto, pero no puede modificarse a un valor distinto.</p> <p>Es posible simplificar la declaraci\u00f3n de una propiedad calculada de solo-lectura eliminando la palabra clave <code>get</code> y sus llaves:</p> <pre><code>struct Cuboide {\n    var ancho = 0.0, alto = 0.0, profundo = 0.0\n    var volumen: Double {\n        return ancho * alto * profundo\n    }\n}\nlet cuatroPorCincoPorDos = Cuboide(ancho: 4.0, alto: 5.0, \n                                   profundo: 2.0)\nprint(\"el volumen de cuatroPorCincoPorDos es \\(cuatroPorCincoPorDos.volumen)\")\n// Imprime \"el volumen de cuatroPorCincoPorDos es 40.0\"\n</code></pre> <p>Este ejemplo define una nueva estructura llamada <code>Cubiode</code>, que representa una caja rectangular 3D con propiedades <code>ancho</code>, <code>alto</code> y <code>profundo</code>. Esta estructura tiene una propiedad calculada llamada <code>volumen</code>, que calcula y devuelve el volumen actual del cuboide. No tendr\u00eda sentido que el volumen fuera modificable, porque ser\u00eda ambiguo determinar qu\u00e9 valores concretos de ancho, alto y profundo deber\u00edan usarse para un valor particular del volumen.</p>"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#34-observadores-de-propiedades","title":"3.4. Observadores de propiedades","text":"<p>Los observadores de propiedades (property observers) observan y responden a cambios en el valor de una propiedad. Los observadores de propiedades se llaman cada vez que el valor de una propiedad es actualizado, incluso si el nuevo valor es el mismo que el valor actual de la propiedad.</p> <p>Se pueden a\u00f1adir observadores a cualquier propiedad almacenada que se definan. Se pueden tambi\u00e9n a\u00f1adir observadores a cualquier propiedad heredada (ya sea almacenada o calculada) sobreescribiendo la propiedad en la subclase. No es necesario definir observadores de propiedades calculadas no sobreescritas porque siempre es posible observar y responder a cambios en su valor en el setter de la propiedad.</p> <p>Es posible definir alguno o ambos de estos observadores sobre una propiedad:</p> <ul> <li><code>willSet</code> es llamado justo antes de que el nuevo valor se almacena   en la propiedad.</li> <li><code>didSet</code> es llamado inmediatamente despu\u00e9s de que el nuevo valor es   almacenado en la propiedad.</li> </ul> <p>Si implementamos un observador <code>willSet</code>, se le pasa el nuevo valor de la propiedad como un par\u00e1metro constante. Podemos especificar un nombre para este par\u00e1metro como parte de la implementaci\u00f3n de <code>willSet</code>. Si no escribimos el nombre del par\u00e1metro y los par\u00e9ntesis dentro de la implementaci\u00f3n, el par\u00e1metro estar\u00e1 disponible con el nombre por defecto de <code>newValue</code>.</p> <p>De forma similar, si implementamos un observador <code>didSet</code>, se pasa como un par\u00e1metro constante que contiene el valor antiguo de la propiedad. Podemos darle nombre al par\u00e1metro o usar el nombre por defecto de <code>oldValue</code>. Si asignamos un valor a la propiedad dentro de su propio observador <code>didSet</code>, el nuevo valor que asignamos reemplaza el que acaba de a\u00f1adirse a la propiedad.</p> <p>A continuaci\u00f3n podemos ver un ejemplo de <code>willSet</code> y <code>didSet</code> en acci\u00f3n. En \u00e9l definimos una clase nueva llamada <code>CuentaPasos</code>, que hace un seguimiento del n\u00famero total de pasos que una persona hace al caminar. Esta clase puede usarse con datos de entrada de un pod\u00f3metro o cualquier otro sistema de seguir el ejercicio de la persona durante su rutina diaria.</p> <pre><code>class ContadorPasos {\n    var totalPasos: Int = 0 {\n        willSet(nuevoTotalPasos) {\n            print(\"Voy a actualizar totalPasos a \\(nuevoTotalPasos)\")\n        }\n        didSet {\n            if totalPasos &gt; oldValue  {\n                print(\"A\u00f1adidos \\(totalPasos - oldValue) pasos\")\n            }\n        }\n    }\n}\nlet contadorPasos = ContadorPasos()\ncontadorPasos.totalPasos = 200\n// Imprime: \"Voy a actualizar totalPasos a 200\"\n// Imprime: \"A\u00f1adidos 200 pasos\"\ncontadorPasos.totalPasos = 360\n// Imprime: \"Voy a actualizar totalPasos a 360\"\n// Imprime: \"A\u00f1adidos 160 pasos\"\ncontadorPasos.totalPasos = 896\n// Imprime: \"Voy a actualizar totalPasos a 896\"\n// Imprime: \"A\u00f1adidos 536 pasos\"\n</code></pre> <p>La clase <code>CuentaPasos</code> declara la propiedad <code>totalPasos</code> de tipo <code>Int</code>. Esta es una propiedad almacenada con observadores <code>willSet</code> y <code>didSet</code>.</p> <p>Los observadores <code>willSet</code> y <code>didSet</code> de <code>totalPasos</code> se llaman siempre que se le asigna un nuevo valor a la propiedad. Esto es as\u00ed incluso si el nuevo valor es el mismo que el valor actual.</p> <p>El observador <code>willSet</code> usa un par\u00e1metro definido por nosotros con el nombre de <code>nuevoTotalPasos</code> para el valor que llega. En el ejemplo, sencillamente imprime el valor que est\u00e1 a punto de establecer.</p> <p>El observador <code>didSet</code> se llama despu\u00e9s de que el valor de <code>totalPasos</code> se ha actualizado. Compara el nuevo valor de <code>totalPasos</code> con el valor antiguo. Si el n\u00famero total de pasos se ha incrementado, se imprime un mensaje indicando cu\u00e1ntos pasos se han tomado. El observador <code>didSet</code> no proporciona un par\u00e1metro definido por nosotros para el valor antiguo, sino que usa el nombre por defecto <code>oldValue</code>.</p> <p>Podemos incluso utilizar el observador <code>didSet</code> para evitar que queden en las propiedades valores no deseados. Por ejemplo, podr\u00edamos evitar que se asignen valores negativos al total de pasos:</p> <pre><code>class ContadorPasos {\n    var totalPasos: Int = 0 {\n        willSet(nuevoTotalPasos) {\n            if nuevoTotalPasos &gt; 0 {\n                print(\"Voy a actualizar totalPasos a \\(nuevoTotalPasos)\")\n            }\n        }\n        didSet {\n            if totalPasos &lt; 0 {\n                totalPasos = oldValue\n            }\n            if totalPasos &gt; oldValue  {\n                print(\"A\u00f1adidos \\(totalPasos - oldValue) pasos\")\n            }\n        }\n    }\n}\nlet contadorPasos = ContadorPasos()\ncontadorPasos.totalPasos = 200\n// Imprime: \"Voy a actualizar totalPasos a 200\"\n// Imprime: \"A\u00f1adidos 200 pasos\"\ncontadorPasos.totalPasos = -10 // No imprime nada\ncontadorPasos.totalPasos // devuelve 200, el valor antiguo\n</code></pre> <p>Hay que hacer notar que al hacer la asignaci\u00f3n <code>totalPasos = oldValue</code> dentro del <code>didSet</code> no se vuelve a lanzar el <code>willSet</code>.</p>"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#35-variables-locales-y-globales","title":"3.5. Variables locales y globales","text":"<p>Las capacidades anteriores de propiedades calculadas y de observadores tambi\u00e9n est\u00e1n disponibles para variables globales y locales.</p> <p>El siguiente ejemplo muestra un ejemplo con una variable calculada a partir de otras dos:</p> <pre><code>var x = 10  {\n   didSet {\n      print(\"El nuevo valor: \\(x) y el valor antiguo: \\(oldValue)\")\n   }\n}\nvar y = 2 * x\nvar z : Int {\n   get {\n      return x + y\n   }\n   set {\n      x = newValue / 2\n      y = newValue / 2\n   }\n}\n\nprint(z)\nz = 100\nprint(x)\n</code></pre>"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#36-propiedades-del-tipo","title":"3.6. Propiedades del tipo","text":"<p>Las propiedades de las instancias son propiedades que pertenecen a una instancia de un tipo particular. Cada vez que creamos una nueva instancia de ese tipo, tiene su propio conjunto de valores de propiedades, separados de los de cualquier otra instancia.</p> <p>Podemos definir tambi\u00e9n propiedades que pertenecen al tipo propiamente dicho, no a ninguna de las instancias de ese tipo. S\u00f3lo habr\u00e1 una copia de estas propiedades, sea cual sea el n\u00famero de instancias de ese tipo que creemos. Estos tipos de propiedades se llaman propiedades del tipo (type propierties). Se pueden definir en tanto en estructuras, clases como en enumeraciones.</p> <p>Las propiedades del tipo son \u00fatiles para definir valores que son universales a todas las instancias de un tipo particular, como una propiedad constante que todas las instancias pueden usar (como una constante est\u00e1tica en C), o una propiedad variable que almacena un valor que es global a todas las instancias de ese tipo (como una variable est\u00e1tica en C).</p> <p>Las propiedades del tipo almacenadas pueden ser variables o constantes. Las propiedades del tipo calculadas se declaran siempre como propiedades variables, de la misma forma que las propiedades calculadas de instancias.</p> <p>A diferencia de las propiedades almacenadas de instancias, debemos siempre proporcionar un valor por defecto para las propiedades almacenadas de tipo. Esto es debido a que el tipo por si mismo no tiene un inicializador que pueda asignar un valor en tiempo de inicializaci\u00f3n.</p> <p>En Swift, las propiedades del tipo se definen como parte de la definici\u00f3n del tipo, dentro de las llaves del tipo. Las propiedades del tipo toman valor en el \u00e1mbito del tipo. Para definir una propiedad del tipo hay que usar la palabra clave <code>static</code>. Para propiedades de tipo calculadas de clases, podemos usar en su lugar la palabra clave <code>class</code> para permitir a las subclases que sobreescriban la implementaci\u00f3n de la superclase.</p> <p>Las propiedades del tipo pueden ser tambi\u00e9n constantes (<code>let</code>) o variables (<code>var</code>).</p> <p>Ejemplo:</p> <pre><code>struct UnaEstructura {\n    static var almacenada = \"A\"\n    static var calculada : Int {\n        return 1\n    }\n}\nenum UnaEnumeracion {\n    static var almacenada = \"A\"\n    static var calculada: Int {\n        return 1\n    }\n}\nclass UnaClase {\n    static var almacenada = \"A\"\n    static var calculada: Int {\n        return 1\n    }\n}\n</code></pre> <p>Las propiedades del tipo se consultan y actualizan usando tambi\u00e9n la sintaxis de punto, pero sobre el tipo:</p> <pre><code>UnaEstructura.almacenada // devuelve \"A\"\nUnaEstructura.almacenada = \"B\" \nUnaClase.calculada // devuelve 1\n</code></pre> <p>No es posible acceder a la variable del tipo a trav\u00e9s de una instancia:</p> <pre><code>let a = UnaEstructura()\na.almacenada // error\n</code></pre> <p>El siguiente ejemplo muestra c\u00f3mo es posible usar una variable del tipo para almacenar informaci\u00f3n global a todas las instancias de ese tipo:</p> <pre><code>struct Valor {\n   var valor: Int = 0 {\n      didSet {\n         Valor.sumaValores += valor\n      }\n   }\n   static var sumaValores = 0\n}\n\nvar c1 = Valor()\nvar c2 = Valor()\nvar c3 = Valor()\nc1.valor = 10\nc2.valor = 20\nc3.valor = 30\nprint(\"Suma de los cambios de valores: \\(Valor.sumaValores)\")\n// Imprime 60\n</code></pre>"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#4-metodos","title":"4. M\u00e9todos","text":"<p>Los m\u00e9todos son funciones que est\u00e1n asociadas a un tipo particular. Las clases, estructuras y enumeraciones pueden definir todas ellas m\u00e9todos de instancia, que encapsulan tareas y funcionalidades espec\u00edficas que trabajan con una instancia de un tipo dado. Las clases, estructuras y enumeraciones tambi\u00e9n pueden definir m\u00e9todos del tipo, que est\u00e1n asociados con el propio tipo. Los m\u00e9todos del tipo son similares a los m\u00e9todos de clase en Java.</p> <p>El hecho de que las estructuras y las enumeraciones puedan definir m\u00e9todos en Swift es una diferencia importante con C y Objective-C.</p>"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#41-metodos-de-instancia","title":"4.1. M\u00e9todos de instancia","text":"<p>Los m\u00e9todos de instancia son funciones que pertenecen a instancias de una clase, estructura o enumeraci\u00f3n. Proporcionan la funcionalidad de esas instancias, bien proporcionando formas de acceder y modificar propiedades de las instancias, o bien proporcionando funcionalidades relacionadas con el prop\u00f3sito de la instancia. Los m\u00e9todos de instancia tienen exactamente la misma sintaxis que las funciones.</p> <p>Los m\u00e9todos de instancia se escriben dentro de las llaves del tipo al que pertenecen. Un m\u00e9todo de instancia tiene acceso impl\u00edcito a todos los otros m\u00e9todos de instancia y propiedades del tipo. Un m\u00e9todo de instancia puede ser invocado s\u00f3lo sobre una instancia espec\u00edfica del tipo al que pertenece. No puede ser invocado de forma aislada sin una instancia existente.</p> <p>A continuaci\u00f3n podemos ver un ejemplo que define una sencilla clase <code>Contador</code>, que puede usarse para contar el n\u00famero de veces que sucede una acci\u00f3n:</p> <pre><code>class Contador {\n    var veces = 0\n    func incrementa() {\n        veces += 1\n    }\n    func incrementa(en cantidad: Int) {\n        veces += cantidad\n    }\n    func reset() {\n        veces = 0\n    }\n}\n</code></pre> <p>Y un ejemplo de uso:</p> <pre><code>let contador = Contador()\n// el valor inicial del contador es 0\ncontador.incrementa()\n// el valor del contador es ahora 1\ncontador.incrementa(en: 5)\n// el valor del contador es ahora 6\ncontador.reset()\n// el valor del contador es ahora 0\n</code></pre> <p>En el ejemplo anterior, los m\u00e9todos no devuelven ning\u00fan valor. Podemos modificar el ejemplo para que los m\u00e9todos devuelvan el valor actualizado del contador:</p> <pre><code>class Contador {\n    var veces = 0\n    func incrementa() -&gt; Int {\n        veces += 1\n        return veces\n    }\n    func incrementa(en cantidad: Int) -&gt; Int {\n        veces += cantidad\n        return veces\n    }\n    func reset() -&gt; Int {\n        veces = 0\n        return veces\n    }\n}\n</code></pre>"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#42-nombres-locales-y-externos-de-parametros","title":"4.2. Nombres locales y externos de par\u00e1metros","text":"<p>Ya vimos que los par\u00e1metros de las funciones pueden tener un nombre interno y un nombre externo. Lo mismo sucede con los m\u00e9todos, porque los m\u00e9todos no son m\u00e1s que funciones asociadas con un tipo.</p> <p>Los nombres de los m\u00e9todos en Swift se refieren normalmente al primer par\u00e1metro usando una preposici\u00f3n como <code>con</code>, <code>en</code>, <code>a</code> o <code>por</code>, como hemos visto en el ejemplo anterior <code>incrementa(en:)</code>. El uso de la preposici\u00f3n permite que el m\u00e9todo se lea como una frase.</p> <p>El nombre de un par\u00e1metro se utiliza tambi\u00e9n como etiqueta del argumento (nombre externo). Al igual que en las funciones, es posible definir dos nombres del par\u00e1metro, uno externo y otro interno. Y el nombre externo puede ser un <code>_</code> para indicar que no es necesario usar la etiqueta del argumento.</p> <p>Esta forma de invocar a los m\u00e9todos hace que el lenguaje sea m\u00e1s expresivo, sin necesidad de nombres largos de m\u00e9todos o funciones.</p> <p>Consideremos por ejemplo esta versi\u00f3n alternativa de la clase <code>Contador</code>, que define una forma m\u00e1s compleja del m\u00e9todo <code>incrementa(en:)</code>:</p> <pre><code>class Contador {\n    var veces = 0\n    func incrementa(en cantidad: Int, numeroDeVeces: Int) {\n        veces += cantidad * numeroDeVeces\n    }\n}\n</code></pre> <p>El m\u00e9todo <code>incrementa(en:numeroDeVeces:)</code> tiene dos par\u00e1metros: <code>cantidad</code> y <code>numeroDeVeces</code>. El primer par\u00e1metro tiene un nombre externo y otro interno. En el cuerpo del m\u00e9todo se utiliza el nombre interno (<code>cantidad</code>). El segundo par\u00e1metro <code>numeroDeVeces</code> es tanto nombre externo como interno. Podemos llamar al m\u00e9todo de la siguiente forma:</p> <pre><code>let contador = Contador()\ncontador.incrementa(en: 5, numeroDeVeces: 3)\n// el valor del contador es ahora 15\n</code></pre> <p>Al igual que en las funciones, podemos definir expl\u00edcitamente los nombres externos de los par\u00e1metros y usar el subrayado (<code>_</code>) para indicar que ese par\u00e1metro no tendr\u00e1 nombre externo.</p>"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#43-la-propiedad-self","title":"4.3. La propiedad <code>self</code>","text":"<p>Toda instancia de un tipo tiene una propiedad impl\u00edcita llamada <code>self</code>, que es exactamente equivalente a la instancia misma. Podemos usar la propiedad <code>self</code> para referirnos a la instancia actual dentro de sus propios m\u00e9todos de instancia.</p> <p>El m\u00e9todo <code>incrementa()</code> en el ejemplo anterior podr\u00eda haberse escrito de esta forma:</p> <pre><code>class Contador {\n    var veces = 0\n    func incrementa() {\n        self.veces += 1\n    }\n}\n</code></pre> <p>En la pr\u00e1ctica no es necesario usar <code>self</code> casi nunca. Swift asume que cualquier referencia a una propiedad dentro de un m\u00e9todo se refiere a la propiedad de la instancia. Es obligado usarlo es cuando el nombre de la propiedad coincide con el nombre de un par\u00e1metro. En esta situaci\u00f3n el nombre del par\u00e1metro toma precedencia y es necesario usar <code>self</code> para poder referirse a la propiedad de la instancia.</p> <p>Un ejemplo:</p> <pre><code>struct Punto {\n    var x = 0.0, y = 0.0\n    func estaAlaDerecha(de x: Double) -&gt; Bool {\n        return self.x &gt; x\n    }\n}\nlet unPunto = Punto(x: 4.0, y: 5.0)\nif unPunto.estaAlaDerecha(de: 1.0) {\n    print(\"Este punto est\u00e1 a la derecha de la l\u00ednea donde x == 1.0\")\n}\n// Imprime \"Este punto est\u00e1 a la derecha de la l\u00ednea donde x == 1.0\"\n</code></pre>"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#44-operaciones-con-instancias-de-tipo-valor","title":"4.4. Operaciones con instancias de tipo valor","text":"<p>Las estructuras y las enumeraciones son tipos valor. Por defecto, las propiedades de un tipo valor no pueden ser modificadas desde dentro de los m\u00e9todos de instancia.</p> <p>Si queremos modificar una propiedad de un tipo valor la forma m\u00e1s natural de hacerlo es creando una instancia nueva, usando el estilo de  programaci\u00f3n funcional:</p> <pre><code>struct Punto {\n    var x = 0.0, y = 0.0\n    func incrementado(incX: Double, incY: Double) -&gt; Punto {\n        return Punto(x: x+incX, y: y+incY)\n    }\n}\nlet unPunto = Punto(x: 1.0, y: 1.0)\nvar puntoMovido = unPunto.incrementado(incX: 2.0, incY: 3.0)\nprint(\"Hemos movido el punto a (\\(puntoMovido.x), \\(puntoMovido.y))\")\n// Imprime \"Hemos movido el punto a (3.0, 4.0)\"\n</code></pre> <p>Nota</p> <p>En la biblioteca est\u00e1ndar de Swift se utiliza el convenio de nombrar los m\u00e9todos no mutadores (que devuelven un objeto nuevo) con el verbo en participio (<code>array.sorted()</code>) y los m\u00e9todos mutadores (que modifican la propia estructura y no devuelven nada) con el verbo en imperativo (<code>array.sort()</code>).</p>"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#45-modificacion-de-tipos-valor-desde-dentro-de-la-instancia","title":"4.5. Modificaci\u00f3n de tipos valor desde dentro de la instancia","text":"<p>Sin embargo, hay ocasiones en las que necesitamos modificar las propiedades de nuestra estructura o enumeraci\u00f3n dentro de un m\u00e9todo particular. </p> <p>Podemos conseguir esta conducta colocando la palabra clave <code>mutating</code> antes de la palabra <code>func</code> del m\u00e9todo:</p> <pre><code>struct Punto {\n    var x = 0.0, y = 0.0\n    mutating func incrementa(incX: Double, incY: Double) {\n        x += incX\n        y += incY\n    }\n}\nvar unPunto = Punto(x: 1.0, y: 1.0)\nunPunto.incrementa(incX: 2.0, incY: 3.0)\nprint(\"El punto est\u00e1 ahora en (\\(unPunto.x), \\(unPunto.y))\")\n// Imprime \"El punto est\u00e1 ahora en (3.0, 4.0)\"\n</code></pre> <p>El m\u00e9todo tiene ahora una conducta mutadora, puede mutar las propiedades de la instancia. En concreto, el m\u00e9todo mutador <code>incrementa(incX:incY:)</code> mueve una instancia de <code>Punto</code> una cierta cantidad. En lugar de devolver un nuevo punto, el m\u00e9todo modifica realmente el punto en el que es llamado. La palabra clave <code>mutating</code> se a\u00f1ade a su definici\u00f3n para permitirle modificar sus propiedades.</p> <p>Hay que hacer notar que no es posible llamar a un m\u00e9todo mutador sobre una constante de un tipo estructura, porque sus propiedades no se pueden cambiar, incluso aunque sean propiedades variables:</p> <pre><code>let puntoFijo = Punto(x: 3.0, y: 3.0)\npuntoFijo.incrementa(incX: 2.0, incY: 3.0)\n// esto provocar\u00e1 un error\n</code></pre>"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#46-asignacion-a-self-en-un-metodo-mutador","title":"4.6. Asignaci\u00f3n a <code>self</code> en un m\u00e9todo mutador","text":"<p>Los m\u00e9todos mutadores pueden asignar una nueva instancia completamente nueva a la propiedad <code>self</code>. El anterior ejemplo <code>Punto</code> podr\u00eda habers escrito de la siguiente forma:</p> <pre><code>struct Punto {\n    var x = 0.0, y = 0.0\n    mutating func incrementa(incX: Double, incY: Double) {\n        self = Punto(x: x + incX, y: y + incY)\n    }\n}\n</code></pre> <p>Esta versi\u00f3n del m\u00e9todo mutador <code>incrementa(incX:incY:)</code> crea una estructura nueva cuyos valores <code>x</code> e <code>y</code> se inicializan a los valores deseados. El resutado final de llamar a esta versi\u00f3n alternativa ser\u00e1 exactamente el mismo que llamar a la versi\u00f3n anterior (aunque con una peque\u00f1a penalizaci\u00f3n de eficiencia: este m\u00e9todo es 1,3 veces m\u00e1s lento que el anterior en la versi\u00f3n 2.2 del compilador de Swift).</p> <p>Los m\u00e9todos mutadores de enumeraciones pueden establecer el par\u00e1metro <code>self</code> impl\u00edcito para que tenga un subtipo distinto de la misma enumeraci\u00f3n:</p> <pre><code>enum InterruptorTriEstado {\n    case apagado, medio, alto\n    mutating func siguiente() {\n        switch self {\n        case .apagado:\n            self = .medio\n        case .medio:\n            self = .alto\n        case .alto:\n            self = .apagado\n        }\n    }\n}\nvar luzHorno = InterruptorTriEstado.medio\nluzHorno.siguiente()\n// luzHorno es ahora .alto\nluzHorno.siguiente()\n// luzHorno es ahora .apagado\n</code></pre>"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#47-metodos-del-tipo","title":"4.7. M\u00e9todos del tipo","text":"<p>Los m\u00e9todos de instancia, como los descritos antes, se llaman en instancias de un tipo particular. Es posible tambi\u00e9n definir m\u00e9todos que se llaman en el propio tipo. Esta clase de m\u00e9todos se denominan m\u00e9todos del tipo. Se define un m\u00e9todo del tipo escribiendo la palabra clave <code>static</code> antes de la palabra clave <code>func</code> del m\u00e9todo. Las clases tambi\u00e9n pueden usar la palabra clave <code>class</code> para permitir a las subclases sobreescribir la implementaci\u00f3n del m\u00e9todo.</p> <p>Los m\u00e9todos del tipo se invocan tambi\u00e9n con la sintaxis de punto, escribiendo el nombre del tipo. Por ejemplo:</p> <pre><code>class NuevaClase {\n    static func unMetodoDelTipo() {\n        print(\"Hola desde el tipo\")\n    }\n}\nNuevaClase.unMetodoDelTipo()\n</code></pre> <p>Dentro del cuerpo del m\u00e9todo, la propiedad impl\u00edcita <code>self</code> se refiere al propio tipo, m\u00e1s que a una instancia de ese tipo. Para clases, estructuras y enumeraciones, esto significa que puedes usar <code>self</code> para desambiguar entre propiedades del tipo y los par\u00e1metros del m\u00e9todo, de la misma forma que se hace en los m\u00e9todos de instancias.</p> <p>Cualquier nombre de m\u00e9todo o propiedad que se utilice en el cuerpo de un m\u00e9todo del tipo se referir\u00e1 a otras propiedades o m\u00e9todos de nivel del tipo. Se puede utilizar estos nombres sin necesidad de a\u00f1adir el prefijo del nombre del tipo.</p> <p>Por ejemplo, podemos a\u00f1adir a la clase <code>Ventana</code> una propiedad y m\u00e9todo de clase con la que almacenar instancias de ventanas. Inicialmente guardamos un array vac\u00edo.</p> <pre><code>class Ventana {\n\n    // Propiedades\n\n\n    static var ventanas: [Ventana] = []\n    static func registrar(ventana: Ventana) {\n        ventanas.append(ventana)\n    }\n}\n</code></pre> <p>Cada vez que creamos una ventana podemos llamar al m\u00e9todo <code>registrar</code> de la clase para a\u00f1adirlo a la colecci\u00f3n de ventanas de la clase:</p> <pre><code>let v1 = Ventana()\nVentana.registrar(ventana: v1)\nprint(\"Se han registrado \\(Ventana.ventanas.count) ventanas\")\n// Imprime \"Se han registrado 1 ventanas\"\n</code></pre>"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#5-inicializacion","title":"5. Inicializaci\u00f3n","text":"<p>Inicializaci\u00f3n es el proceso de preparar para su uso una instancia de una clase, estructura o enumeraci\u00f3n. Este proceso incluye la asignaci\u00f3n de un valor inicial para cada propiedad almacenada y la ejecuci\u00f3n de cualquier otra operaci\u00f3n de inicializaci\u00f3n que se necesite para que la nueva instancia est\u00e9 lista para usarse.</p> <p>Para implementar este proceso de inicializaci\u00f3n hay que definir inicializadores, que son como m\u00e9todos especiales que pueden llamarse para crear una nueva instancia de un tipo particular. A diferencia de otros lenguajes, los inicializadores en Swift no devuelven un valor. Su papel principal es que las nuevas instancias del tipo est\u00e9n correctamente inicializadas antes de poder ser usadas por primera vez.</p> <p>Tambi\u00e9n es posible implementar deinicializadores, m\u00e9todos que se ejecutan cuando las instancias son eliminadas de la memoria (no vamos a explicarlos por falta de tiempo).</p> <p>El proceso de inicializaci\u00f3n de una instancia puede resultar un proceso complicado, sobre todo cuando se tienen relaciones de herencia y hay que especificar tambi\u00e9n c\u00f3mo realizar la inicializaci\u00f3n de la subclase utilizando la superclase. Por falta de tiempo no vamos a explicar todo el proceso completo. Recomendamos consultar la documentaci\u00f3n original de Swift.</p>"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#51-inicializadores-por-defecto-y-memberwise","title":"5.1. Inicializadores por defecto y memberwise","text":"<p>Ya hemos visto que es posible inicializar clases y estructuras definiendo valores por defecto a todas sus propiedades (con la posible excepci\u00f3n de las que tienen un tipo opcional). En ese caso, podemos no definir ning\u00fan inicializador y usar el inicializador por defecto que proporciona Swift.</p> <pre><code>struct Punto2D {\n    var x = 0.0\n    var y = 0.0\n}\nclass Segmento {\n    var p1 = Punto2D()\n    var p2 = Punto2D()\n}\n\nvar s = Segmento()\n</code></pre> <p>Tambi\u00e9n es posible en las estructuras utilizar el inicializador memberwise, en el que especificamos todos los valores de las propiedades:</p> <pre><code>var p = Punto2D(x: 10.0, y: 10.0)\n</code></pre> <p>Los inicializadores por defecto y memberwise desaparecen en el momento en que definimos alg\u00fan inicializador con la palabra <code>init</code>. Veamos c\u00f3mo definir inicializadores.</p>"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#52-inicializacion-de-propiedades-almacenadas","title":"5.2. Inicializaci\u00f3n de propiedades almacenadas","text":"<p>Como hemos dicho, las clases y estructuras deben definir todas sus propiedades almacenadas a un valor inicial en el momento en que la instancia se crea, a no ser que \u00e9stas sean opcionales, en cuyo caso quedar\u00edan inicializadas a <code>nil</code>.</p> <p>Podemos definir el valor inicial para una propiedad en un inicializador o asign\u00e1ndole un valor por defecto como parte de la definici\u00f3n de la propiedad.</p> <p>Un inicializador, en su forma m\u00e1s simple se escribe con la palabra clave <code>init</code>:</p> <pre><code>init() {\n    // realizar alguna inicializaci\u00f3n aqu\u00ed\n}\n</code></pre> <p>Por ejemplo, podemos definir la estructura <code>Farenheit</code> que almacena una temperatura en grados Farenheit. Tiene una propiedad almacenada de tipo <code>Double</code>. Definimos un inicializador que inicializa las instancias a 32.0 (equivalente a 0.0 grados Celsius).</p> <pre><code>struct Fahrenheit {\n    var temperatura: Double\n    init() {\n        temperatura = 32.0\n    }\n}\nvar f = Fahrenheit()\nprint(\"La temperatura por defecto es \\(f.temperatura) Fahrenheit\")\n// Imprime \"La temperatura por defecto es 32.0\u00b0 Fahrenheit\"\n</code></pre> <p>La implementaci\u00f3n anterior es equivalente a la que ya hemos visto con el inicializador por defecto:</p> <pre><code>struct Fahrenheit {\n    var temperatura = 32.0\n}\n</code></pre>"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#53-inicializadores-personalizados","title":"5.3. Inicializadores personalizados","text":"<p>Podemos proporcionar par\u00e1metros de inicializaci\u00f3n como parte de la definici\u00f3n de un inicializador, para definir los tipos y los nombres de los valores que personalizan el proceso de inicializaci\u00f3n. Los par\u00e1metros de inicializaci\u00f3n tienen las mismas capacidades y sintaxis que los par\u00e1metros de funciones y m\u00e9todos.</p> <pre><code>struct Celsius {\n    var temperaturaEnCelsius: Double\n    init(desdeFahrenheit fahrenheit: Double) {\n        temperaturaEnCelsius = (fahrenheit - 32.0) / 1.8\n    }\n    init(desdeKelvin kelvin: Double) {\n        temperaturaEnCelsius = kelvin - 273.15\n    }\n}\n\nlet puntoDeEbullicionDelAgua = Celsius(desdeFahrenheit: 212.0)\n// puntoDeEbullicionDelAgua.temperaturaEnCelsius es 100.0\nlet puntoDeCongelacionDelAgua = Celsius(desdeKelvin: 273.15)\n// puntoDeCongelacionDelAgua.temperaturaEnCelsius is 0.0\n</code></pre> <p>Vemos que dependiendo del nombre de par\u00e1metro proporcionado se escoge un inicializador u otro. En los inicializadores es obligatorio proporcionar los nombres de todos los par\u00e1metros:</p> <pre><code>struct Color {\n    let rojo, verde, azul: Double\n    init(rojo: Double, verde: Double, azul: Double) {\n        self.rojo   = rojo\n        self.verde = verde\n        self.azul  = azul\n    }\n    init(blanco: Double) {\n        rojo  = blanco\n        verde = blanco\n        azul  = blanco\n    }\n}\nlet magenta = Color(rojo: 1.0, verde: 0.0, azul: 1.0)\nlet medioGris = Color(blanco: 0.5)\n</code></pre> <p>Podemos evitar proporcionar nombres externos usando un subrayado. Por ejemplo, podemos a\u00f1adir al struct anterior <code>Celsius</code> un inicializador sin nombre externo para el caso en que pasemos la temperatura inicial precisamente en Celsius:</p> <pre><code>struct Celsius {\n   var temperaturaEnCelsius: Double\n   init(desdeFahrenheit fahrenheit: Double) {\n      temperaturaEnCelsius = (fahrenheit - 32.0) / 1.8\n   }\n   init(desdeKelvin kelvin: Double) {\n      temperaturaEnCelsius = kelvin - 273.15\n   }\n   init(_ celsius: Double) {\n      temperaturaEnCelsius = celsius\n   }\n}\n\nlet temperaturaCuerpo = Celsius(37.0)\n// temperaturaCuerpo.temperaturaEnCelsius es 37.0\n</code></pre> <p>Por \u00faltimo, es posible inicializar propiedades constantes definidas con <code>let</code>. S\u00f3lo toman valor en el momento de la inicializaci\u00f3n y despu\u00e9s no pueden modificarse.</p> <pre><code>class PreguntaEncuesta {\n    let texto: String\n    var respuesta: String?\n    init(texto: String) {\n        self.texto = texto\n    }\n    func pregunta() {\n        print(texto)\n    }\n}\nlet preguntaQueso = PreguntaEncuesta(texto: \"\u00bfTe gusta el queso?\")\npreguntaQueso.pregunta() // -&gt; \"\u00bfTe gusta el queso?\npreguntaQueso.respuesta // -&gt; nil\n</code></pre> <p>La propiedad <code>respuesta</code> se inicializa a <code>nil</code> al ser un opcional y no inicializarla en el inicializador.</p> <p>Por \u00faltimo, es posible definir m\u00e1s de un inicializador, as\u00ed como invocar a inicializadores m\u00e1s b\u00e1sicos desde otros. </p> <pre><code>struct Rectangulo {\n    var origen = Punto()\n    var tama\u00f1o = Tama\u00f1o()\n    init(){}\n    init(origen: Punto, tama\u00f1o: Tama\u00f1o) {\n        self.origen = origen\n        self.tama\u00f1o = tama\u00f1o\n    }\n    init(centro: Punto, tama\u00f1o: Tama\u00f1o) {\n        let origenX = centro.x - (tama\u00f1o.ancho / 2)\n        let origenY = centro.y - (tama\u00f1o.ancho / 2)\n        self.init(origen: Punto(x: origenX, y: origenY), tama\u00f1o: tama\u00f1o)\n    }\n}\nlet basicRectangulo = Rectangulo()\n// el origen de basicRectangulo es (0.0, 0.0) y su tama\u00f1o (0.0, 0.0)\nlet origenRectangulo = Rectangulo(origen: Punto(x: 2.0, y: 2.0),\n                        tama\u00f1o: Tama\u00f1o(ancho: 5.0, alto: 5.0))\n// el origne de origenRectangulo es (2.0, 2.0) y su tama\u00f1o (5.0, 5.0)\nlet centroRectangulo = Rectangulo(centro: Punto(x: 4.0, y: 4.0),\n                        tama\u00f1o: Tama\u00f1o(ancho: 3.0, alto: 3.0))\n// el origen de centroRectangulo es (2.5, 2.5) y su tama\u00f1o (3.0, 3.0)\n</code></pre> <p>El inicializador <code>init(){}</code> permite inicializar el <code>Rectangulo</code> a los valores por defecto definidos en las propiedades. Proporciona la misma funcionalidad que el inicializador por defecto, que tal y como hemos comentado, no se crea en una estructura o clase en la que definimos sus propios inicializadores.</p>"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#6-herencia","title":"6. Herencia","text":"<p>Una clase puede heredar m\u00e9todos, propiedades y otras caracter\u00edsticas de otra clase. Cuando una clase hereda de otra, la clase que hereda se denomina subclase, y la clase de la que se hereda se denomina su superclase. La herencia es una conducta fundamental que diferencia las clases de otros tipos en Swift.</p> <p>Las clases en Swift pueden llamar y acceder a m\u00e9todos y propiedades que pertenecen a su superclase y pueden proporcionar sus propias versiones que sobreescriben esos m\u00e9todos y propiedades. Para sobreescribir un m\u00e9todo o una propiedad es necesario cumplir con la definici\u00f3n proporcionada por la superclase.</p> <p>Las clases tambi\u00e9n pueden a\u00f1adir observadores a las propiedades heredadas para ser notificadas cuando cambia el valor de una propiedad. A cualquier propiedad heredada se le puede a\u00f1adir un observador de propiedad, independientemente de si es originalmente una propiedad almacenada o calculada.</p>"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#61-definicion-de-una-clase-base","title":"6.1. Definici\u00f3n de una clase base","text":"<p>Una clase que no hereda de ninguna otra se denomina una clase base (base class). A diferencia de otros lenguajes orientados a objetos, las clases en Swift no heredan de una clase base universal.</p> <p>Tambi\u00e9n a diferencia de otros lenguajes orientados a objetos Swift no permite definir clases abstractas que no permiten crear instancias. Cualquier clase en Swift puede ser instanciada.</p> <p>El siguiente ejemplo define una clase base llamada <code>Vehiculo</code>. Esta clase base define una propiedad almacenada llamada <code>velocidadActual</code> con un valor por defecto de 0.0. Esta propiedad se utiliza por una propiedad <code>String</code> calculada llamada <code>descripcion</code> que crea una descripci\u00f3n del veh\u00edculo.</p> <p>La clase base <code>Vehiculo</code> tambi\u00e9n define un m\u00e9todo llamdo <code>hazRuido</code>. Este m\u00e9todo no hace nada realmente para una instancia de un veh\u00edculo base, pero ser\u00e1 modificado m\u00e1s adelante por las subclases de <code>Vehiculo</code>.</p> <pre><code>class Vehiculo {\n    var velocidadActual = 0.0\n    var descripcion: String {\n        return \"viajando a \\(velocidadActual) kil\u00f3metros por hora\"\n    }\n    func hazRuido() -&gt; String {\n        // Devuelve una cadena vac\u00eda - un veh\u00edculo arbitrario no hace\n        // ruido necesariamente\n        return \"\"\n    }\n}\n</code></pre> <p>Creamos una instancia nueva de <code>Vehiculo</code> con la sintaxis de inicializaci\u00f3n que hemos visto, en la que se escribe el nombre del tipo de la clase seguido por par\u00e9ntesis vac\u00edos:</p> <pre><code>let unVehiculo = Vehiculo()\n</code></pre> <p>Habiendo creado una instancia nueva de <code>Vehiculo</code>, podemos acceder a su descripci\u00f3n:</p> <pre><code>print(\"Veh\u00edculo: \\(unVehiculo.descripcion)\")\n// Veh\u00edculo: viajando a 0.0 kil\u00f3metros por hora\n</code></pre> <p>La clase <code>Vehiculo</code> define caracter\u00edsticas comunes para un veh\u00edculo arbitrario, pero no es de mucha utilidad por si misma. Para hacerla m\u00e1s \u00fatil, tenemos que refinarla para describir tipos de veh\u00edculos m\u00e1s espec\u00edficos.</p>"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#62-construccion-de-subclases","title":"6.2. Construcci\u00f3n de subclases","text":"<p>La construcci\u00f3n de una subclase (subclassing) es la acci\u00f3n de basar una nueva clase en una clase existente. La subclase hereda caracter\u00edsticas de la clase existente, que despu\u00e9s podemos refinar. Tambi\u00e9n podemos a\u00f1adir nuevas caracter\u00edsticas a la subclase.</p> <p>Para indicar que una subclase tiene una superclase hay que escribir el nombre de la subclase antes de el de la superclase, separadas por dos puntos (<code>:</code>):</p> <pre><code>class UnaSubclase: UnaSuperClase {\n    // definici\u00f3n de la subclase\n}\n</code></pre> <p>En el ejemplo anterior del <code>Vehiculo</code> podemos definir una subclase <code>Bicicleta</code>:</p> <pre><code>class Bicicleta: Vehiculo {\n    var tieneCesta = false\n}\n</code></pre> <p>La nueva clase <code>Bicicleta</code> obtiene autom\u00e1ticamente todas las caracter\u00edsticas del <code>Vehiculo</code>, como sus propiedades <code>velocidadActual</code> y <code>descripcion</code> y su m\u00e9todo <code>haceRuido()</code>.</p> <p>Adem\u00e1s de las caracter\u00edsticas que hereda, la clase <code>Bicicleta</code> define una nueva propiedad almacenada, <code>tieneCesta</code>, con un valor por defecto de <code>false</code>.</p> <p>Por defecto, cualquier instancia nueva de <code>Bicicleta</code> no tendr\u00e1 una cesta. Puedes establecer la propiedad <code>tieneCesta</code> a <code>true</code> para una instancia particular de <code>Bicicleta</code> despu\u00e9s de crearla:</p> <pre><code>let bicicleta = Bicicleta()\nbicicleta.tieneCesta = true\n</code></pre> <p>Podemos tambi\u00e9n modificar la propiedad heredada <code>velocidadActual</code> y preguntar por la propiedad <code>descripcion</code>:</p> <pre><code>bicicleta.velocidadActual = 10.0\nprint(\"Bicicleta: \\(bicicleta.descripcion)\")\n// Bicicleta: viajando a 10.0 kil\u00f3metros por hora\n</code></pre> <p>Podemos construir subclases a partir de otras subclases. El siguiente ejemplo crea una subclase de <code>Bicicleta</code> que representa una bicicleta de dos sillines (un \"tandem\"):</p> <pre><code>class Tandem: Bicicleta {\n    var numeroActualDePasajeros = 0\n}\n</code></pre> <p><code>Tandem</code> hereda todas las propiedades y m\u00e9todos de <code>Bicicleta</code>, que a su vez hereda todas sus propiedades y m\u00e9todos de <code>Vehiculo</code>. La subclase <code>Tandem</code> tambi\u00e9n a\u00f1ade una nueva propiedad almacenada llamada <code>numeroActualDePasajeros</code>, con un valor por defecto de 0.</p> <p>Si creamos una instancia de <code>Tandem</code> podremos trabajar con cualquiera de sus propiedades nuevas y heredadas, y preguntar a la descripci\u00f3n de solo lectura que hereda de <code>Vehiculo</code>:</p> <pre><code>let tandem = Tandem()\ntandem.tieneCesta = true\ntandem.numeroActualDePasajeros = 2\ntandem.velocidadActual = 18.0\nprint(\"Tandem: \\(tandem.descripcion)\")\n// Tandem: viajando a 18.0 kil\u00f3metros por hora\n</code></pre>"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#63-sobreescritura","title":"6.3. Sobreescritura","text":"<p>Una subclase puede proporcionar su propia implementaci\u00f3n de un m\u00e9todo de la instancia o m\u00e9todo del tipo. Tambi\u00e9n puede proporcionar su propia implementaci\u00f3n de una propiedad calculada o a\u00f1adir observadores a cualquier propiedad que hereda de su superclase. Esto se conoce como sobreescritura (overriding).</p> <p>Para sobreescribir una caracter\u00edstica que ser\u00eda de otra forma heredada debemos usar el prefijo <code>override</code>. De esta forma se clarifica que intentamos proporcionar una sobreescritura y que no lo hacemos por error. Esta palabra clave tambi\u00e9n hace que el compilador comprueba que la superclase (o una de sus clases padre) tiene una declaraci\u00f3n que empareja con la que proporcionamos en la sobreescritura.</p> <p>El siguiente ejemplo define una nueva subclase de <code>Vehiculo</code> llamada <code>Tren</code>, que sobreescribe el m\u00e9todo <code>hazRuido()</code>:</p> <pre><code>class Tren: Vehiculo {\n    override func hazRuido() -&gt; String {\n        return \"Chuu Chuu\"\n    }\n}\n</code></pre> <p>Si creamos una nueva instancia de <code>Tren</code> y llamamos al m\u00e9todo <code>hazRuido</code> podemos comprobar que se llama a la versi\u00f3n del m\u00e9todo de la subclase:</p> <pre><code>let tren = Tren()\nprint(tren.hazRuido())\n// Imprime \"Chuu Chuu\"\n</code></pre> <p>Podemos sobreescribir cualquier propiedad heredada del tipo o de la instancia y proporcionar nuestros propios getters y setters para esa propiedad, o a\u00f1adir observadores de propiedades para observar cuando cambian los valores subyacentes de la propiedad.</p> <p>Podemos proporcionar un getter (o setter, si es apropiado) para sobreescribir cualquier propiedad heredada, independientemente de si la propiedad heredada se implementa como una propiedad almacenada o calculada. La naturaleza almacenada o calculada no se conoce por la subclase, que solo conoce su nombre y su tipo. Es posible convertir una propiedad heredada de solo-lectura en una de lectura-escritura. No es posible presentar una propiedad heredada de lectura-escritura como de solo-lectura.</p> <p>El siguiente ejemplo define una nueva clase llamada <code>Coche</code>, que es una subclase de <code>Vehiculo</code>. La clase <code>Coche</code> introduce una nueva propiedad almacenada llamada <code>marcha</code>, con un valor por defecto de 1. Tambi\u00e9n sobreescribe la propiedad heredada <code>descripcion</code>, incluyendo la marcha actual en la descripci\u00f3n.</p> <p>Vemos tambi\u00e9n en el ejemplo que cuando proporcionamos una sobreescritura podemos a los valores proporcionados por la clase padre usando la referencia <code>super</code>.</p> <pre><code>class Coche: Vehiculo {\n    var marcha = 1\n    override var descripcion: String {\n        return super.descripcion + \" con la marcha \\(marcha)\"\n    }\n}\n</code></pre> <p>Podemos ver el funcionamiento en el siguiente ejemplo:</p> <pre><code>let coche = Coche()\ncoche.velocidadActual = 50.0\ncoche.marcha = 3\nprint(\"Coche: \\(coche.descripcion)\")\n// Coche: viajando a 50.0 kil\u00f3metros por hora con la marcha 3\n</code></pre> <p>Por \u00faltimo, podemos a\u00f1adir observadores a propiedades heredadas. Esto nos permite ser notificados cuando el valor de una propiedad heredada cambia, independientemente de si esa propiedad se ha implementado en la subclase o en la superclase.</p> <p>El siguiente ejemplo define una nueva clase llamada <code>CocheAutomatico</code> que es una subclase de <code>Coche</code>. La clase <code>CocheAutomatico</code> representa un coche con una caja de cambios autom\u00e1tica, que selecciona autom\u00e1ticamente la marcha bas\u00e1ndose en la velocidad actual:</p> <pre><code>class CocheAutomatico: Coche {\n    override var velocidadActual: Double {\n        didSet {\n            marcha = min(Int(velocidadActual / 25.0) + 1, 5)\n        }\n    }\n}\n</code></pre> <p>En cualquier momento que se modifica la propiedad <code>velocidadActual</code> de una instancia de <code>CocheAutomatico</code>, el observador <code>didSet</code> establece la propiedad <code>marcha</code> a un valor apropiado para la nueva velocidad. Un ejemplo de ejecuci\u00f3n:</p> <pre><code>let automatico = CocheAutomatico()\nautomatico.velocidadActual = 100.0\nprint(\"CocheAutomatico: \\(automatico.descripcion)\")\n// CocheAutomatico: viajando a 100.0 kil\u00f3metros por hora con la marcha 5\n</code></pre>"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#64-inicializacion","title":"6.4. Inicializaci\u00f3n","text":"<p>Hasta ahora por simplificar no hemos definido inicializadores ni en la clase base ni en las subclases. Vamos a ver c\u00f3mo funciona la inicializaci\u00f3n en una relaci\u00f3n de herencia.</p> <p>Supongamos que a\u00f1adimos un inicializador a la clase base <code>Vehiculo</code>:</p> <pre><code>class Vehiculo {\n    var velocidadActual = 0.0\n\n    // Resto de c\u00f3digo de la clase\n\n    init(velocidad: Double) {\n        self.velocidadActual = velocidad\n    }\n}\n</code></pre> <p>Al hacer esto ya no podemos usar el inicializador por defecto para crear una instancia de <code>Vehiculo</code>, sino que debemos utilizar el inicializador definido:</p> <pre><code>// Error: let miVehiculo = Vehiculo()\nlet miVehiculo = Vehiculo(velocidad: 40)\n</code></pre> <p>Autom\u00e1ticamente las subclases heredan este inicializador y dejan de tener el inicializador por defecto:</p> <pre><code>// Error: let miBici = Bicicleta()\nlet miBic = Bicicleta(velocidad: 5)\n</code></pre> <p>Podemos definir inicializadores propios en las subclases que inicialicen sus atributos, pero siempre es necesario inicializar la clase base llamando a su inicializador con <code>super</code>:</p> <pre><code>class Bicicleta: Vehiculo {\n    var tieneCesta = false\n\n    init(tieneCesta: Bool, velocidad: Double) {\n        self.tieneCesta = tieneCesta\n        super.init(velocidad: velocidad)\n    }\n}\n</code></pre>"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#65-enlace-dinamico","title":"6.5. Enlace din\u00e1mico","text":"<p>Al igual que en Java y en otros lenguajes orientados a objetos, una relaci\u00f3n de herencia puede hacer imposible conocer en tiempo de compilaci\u00f3n el c\u00f3digo a ejecutar en una llamada a un m\u00e9todo o una propiedad.</p> <p>Por ejemplo, supongamos que creamos otra subclase derivada de <code>Veh\u00edculo</code> que haga un ruido distinto a la que hace el tren:</p> <pre><code>class Barco: Vehiculo {\n    override func hazRuido() -&gt; String {\n        return \"Buuuuuuuu\"\n    }\n}\n</code></pre> <p>Supongamos que definimos una funci\u00f3n que recibe un <code>Veh\u00edculo</code> y que imprime el resultado a la llamada al m\u00e9todo <code>hazRuido</code>:</p> <pre><code>func imprimeRuido(vehiculo: Vehiculo) {\n    print(vehiculo.hazRuido())\n}\n</code></pre> <p>En tiempo de compilaci\u00f3n no se puede saber qu\u00e9 tipo de veh\u00edculo va a pasarse como par\u00e1metro a la funci\u00f3n, por lo que no se puede generar el c\u00f3digo que va a ejecutarse en la llamada al m\u00e9todo <code>hazRuido()</code>. El c\u00f3digo s\u00f3lo se conocer\u00e1 en tiempo de ejecuci\u00f3n, dependiendo del tipo real de la instancia que se pasa como par\u00e1metro. Es lo que se denomina enlace din\u00e1mico o late binding.</p> <pre><code>let barco = Barco()\nlet tren = Tren()\nimprimeRuido(vehiculo: barco) // Imprime \"Buuuuuuuu\"\nimprimeRuido(vehiculo: tren) // Imprime \"Chu chu\"\n</code></pre>"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#66-modificador-final","title":"6.6. Modificador <code>final</code>","text":"<p>Por \u00faltimo, es posible prevenir un m\u00e9todo o propiedad de ser sobreescrito declar\u00e1ndolo como final. Para ello, hay que escribir el modificador <code>final</code> antes del nombre de la palabra clave que introduce el m\u00e9todo o la propiedad (como <code>final var</code>, <code>final func</code>). </p> <p>Tambi\u00e9n es posible marcar la clase completa como final, escribiendo el modificador antes de <code>class</code> (<code>final class</code>). De esta forma no se permite que se pueda heredar de ella.</p>"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#7-funciones-operadoras","title":"7. Funciones operadoras","text":"<p>Las clases y las estructuras pueden proporcionar sus propias implementaciones de operadores existentes. Esto se conoce como sobrecarga de los operadores existentes.</p> <p>En el siguiente ejemplo se muestra c\u00f3mo implementar el operador de suma (<code>+</code>) para una estructura. El operador suma es un operador binario (tiene dos operandos) e infijo (aparece junto entre los dos operandos). Definimos una estructura <code>Vector2D</code> para un vector de posici\u00f3n de dos dimensiones:</p> <pre><code>struct Vector2D {\n    var x = 0.0, y = 0.0\n    static func + (izquierdo: Vector2D, derecho: Vector2D) -&gt; Vector2D {\n        return Vector2D(x: izquierdo.x + derecho.x, y: izquierdo.y + derecho.y)\n    }\n}\n</code></pre> <p>La funci\u00f3n operador se define como una funci\u00f3n est\u00e1tica con un un nombre de funci\u00f3n que empareja con el operador a sobrecargar (<code>+</code>). Debido a que la suma aritm\u00e9tica se define como un operador binario, esta funci\u00f3n operador toma dos par\u00e1metros de entrada de tipo <code>Vector2D</code> y devuelve un \u00fanico valor de salida, tambi\u00e9n de tipo <code>Vector2D</code>.</p> <p>En esta implementaci\u00f3n, llamamos a los par\u00e1metros de entrada <code>izquierdo</code> y <code>derecho</code> para representar las instancias de <code>Vector2D</code> que estar\u00e1n a la izquierda y a la derecha del operador <code>+</code>. Son nombres arbitrarios, lo importante es la posici\u00f3n. El primer par\u00e1metro de la funci\u00f3n es el que hace de primer operador.</p> <p>La funci\u00f3n devuelve una nueva instancia de <code>Vector2D</code>, cuyas propiedades <code>x</code> e <code>y</code> se inicializan con la suma de las propiedades <code>x</code> e <code>y</code> de las instancias de <code>Vector2D</code> que se est\u00e1n sumando.</p> <p>La funci\u00f3n se define globalmente, m\u00e1s que como un m\u00e9todo en la estructura <code>Vector2D</code>, para que pueda usarse como un operador infijo entre instancias existentes de <code>Vector2D</code>:</p> <pre><code>let vector = Vector2D(x: 3.0, y: 1.0)\nlet otroVector = Vector2D(x: 2.0, y: 4.0)\nlet vectorSuma = vector + otroVector\n// vectorSuma es una instancia de Vector2D con valores de (5.0, 5.0)\n</code></pre>"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#71-operadores-prefijos-y-postfijos","title":"7.1. Operadores prefijos y postfijos","text":"<p>El ejemplo anterior demuestra una implementaci\u00f3n propia de un operador binario infijo. Las clases y las estructuras pueden tambi\u00e9n proporcionar implementaciones de los operadores unarios est\u00e1ndar. Los operadores unarios operan sobre un \u00fanico objetivo. Son prefijos se preceden el objetivo (como <code>-a</code>) y postfijos si siguen su objetivo (como en <code>b!</code>).</p> <p>Para implementar un operador unario prefijo o postfijo se debe escribir el modificador <code>prefix</code> o <code>postfix</code> antes de la palabra clave <code>func</code> en la declaraci\u00f3n de la funci\u00f3n operador:</p> <pre><code>struct Vector2D {\n   ...\n   static prefix func - (vector: Vector2D) -&gt; Vector2D {\n       return Vector2D(x: -vector.x, y: -vector.y)\n   }\n}\n</code></pre> <p>El ejemplo anterior implementa el operador unario negaci\u00f3n (<code>-a</code>) para instancias de <code>Vector2D</code>.</p> <p>Por ejemplo:</p> <pre><code>let positivo = Vector2D(x: 3.0, y: 4.0)\nlet negativo = -positivo\n// negativo es una instancia de Vector2D con valores de (-3.0, -4.0)\nlet tambienPositivo = -negativo\n// tambienPositivo es una instancia de Vector2D con valores de (3.0, 4.0)\n</code></pre>"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#8-protocolos","title":"8. Protocolos","text":"<p>Un protocolo (protocol) define un esquema de m\u00e9todos, propiedades y otros requisitos que encajan en una tarea particular o un trozo de funcionalidad. El protocolo puede luego ser adoptado (adopted) por una clase, estructura o enumeraci\u00f3n para proporcionar una implementaci\u00f3n real de esos requisitos. Cualquier tipo que satisface los requerimientos de un protocolo se dice que se ajusta o cumple (conform) ese protocolo. Podemos considerar los protocolos como una construcci\u00f3n de Swift que ampl\u00eda la idea de las interfaces de Java.</p> <p>La utilizaci\u00f3n de protocolos permite un estilo de programaci\u00f3n muy flexible que puede ser usado para definir bibliotecas que se adaptan f\u00e1cilmente a nuevos requisitos. En la charla de la conferencia de desarrolladores de Apple de 2015 (WWDC15) Protocol Oriented Programming Dave Abrahams, uno de los responsables del dise\u00f1o de la biblioteca est\u00e1ndar de Swift, propone la utilizaci\u00f3n de protocolos en un nuevo estilo de programaci\u00f3n que contrapone al estilo tradicional de la programaci\u00f3n orientada a objetos que usa herencia y clases abstractas.</p>"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#81-sintaxis","title":"8.1. Sintaxis","text":"<p>Los protocolos se definen de forma similar a las clases, estructuras y enumeraciones:</p> <pre><code>protocol UnProtocolo {\n    // definici\u00f3n del protocolo\n}\n</code></pre> <p>Para definir un tipo que se ajusta a un protocolo particular se debe poner el nombre del protocolo tras el nombre del tipo, separado por dos puntos. Podemos listar m\u00e1s de un protocolo, y se separan por comas:</p> <pre><code>struct UnStruct: PrimerProtocolo, OtroProtocolo {\n    // definici\u00f3n del struct\n}\n</code></pre> <p>Si una clase tiene una superclase, se escribe el nombre de la superclase antes de los protocolos, seguido por una coma:</p> <pre><code>class UnaClase: UnaSuperClase, PrimerProtocolo, OtroProto {\n    // definici\u00f3n de la clase\n}\n</code></pre>"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#82-requisitos-de-propiedades","title":"8.2. Requisitos de propiedades","text":"<p>Un protocolo puede requerir a cualquier tipo que se ajuste a \u00e9l que proporcione una propiedad de instancia o de tipo con un nombre y tipo particular. El protocolo no especifica si la propiedad es una propiedad calculada o almacenada, s\u00f3lo especifica el nombre y el tipo de la propiedad requerida. El protocolo tambi\u00e9n especifica si la propiedad debe ser de lectura y escritura o s\u00f3lo de lectura.</p> <p>Si un protocolo requiere que una propiedad sea de lectura y escritura, el requisito no puede ser satisfecho por una propiedad constante almacenada o por una propiedad calculada de s\u00f3lo lectura. Si el protocolo s\u00f3lo requiere que la propiedad sea de lectura, el requisito puede ser satisfecho por cualquier tipo de propiedad, y es v\u00e1lido que la propiedad sea tambi\u00e9n de escritura si es \u00fatil para nuestro propio c\u00f3digo.</p> <p>Los requisitos de la propiedad se declaran siempre como propiedades variables, precedido por la palabra clave <code>var</code>. Las propiedades de lectura y escritura se indican escribiendo <code>{ get set }</code> despu\u00e9s de la declaraci\u00f3n de su tipo, y las propiedades de s\u00f3lo lectura se indican escribiendo <code>{ get }</code>.</p> <pre><code>protocol UnProtocolo {\n    var debeSerEscribible: Int { get set }\n    var noTienePorQueSerEscribible: Int { get }\n}\n</code></pre> <p>Para definir una propiedad de tipo hay que precederla en el protocolo con la palabra clave <code>static</code>:</p> <pre><code>protocol OtroProtocolo {\n    static var unaPropiedadDeTipo: Int { get set }\n}\n</code></pre> <p>Veamos un ejemplo. Definimos el protocolo <code>TieneNombre</code> en el que se requiere que cualquier clase que se ajuste a \u00e9l debe tener una propiedad de instancia de lectura de tipo <code>String</code> que se llame <code>nombreCompleto</code>:</p> <pre><code>protocol TieneNombre {\n    var nombreCompleto: String { get }\n}\n</code></pre> <p>Un ejemplo de una sencilla estructura que adopta el protocolo:</p> <pre><code>struct Persona: TieneNombre {\n    var edad: Int\n    var nombreCompleto: String\n}\n\nlet john = Persona(edad: 35, nombreCompleto: \"John Appleseed\")\n// john.nombreCompleto es \"John Appleseed\"\n</code></pre> <p>Este ejemplo define una estructure llamada <code>Persona</code>, que representa una persona con una edad y un nombre espec\u00edfico. En la primera l\u00ednea se declara que se adopta el protocolo <code>TieneNombre</code>. Cada instancia de <code>Persona</code> tiene la propiedad almacenada llamada <code>nombreCompleto</code>, que es de tipo <code>String</code>. Esto cumple el \u00fanico requisito del protocolo <code>TieneNombre</code>, y signifca que <code>Persona</code> se ajusta correctamente al protocolo (Swift informa de un error en tiempo de compilaci\u00f3n si un requisito de un protocolo no se cumple).</p> <p>Otro ejemplo de una clase m\u00e1s compleja, que tambi\u00e9n adopta el protocolo:</p> <pre><code>class NaveEstelar: TieneNombre {\n    var prefijo: String?\n    var nombre: String\n    init(nombre: String, prefijo: String? = nil) {\n        self.nombre = nombre\n        self.prefijo = prefijo\n    }\n    var nombreCompleto: String {\n        return (prefijo != nil ? prefijo! + \" \" : \"\") + nombre\n    }\n}\nvar ncc1701 = NaveEstelar(nombre: \"Enterprise\", prefijo: \"USS\")\n// ncc1701.nombreCompleto es \"USS Enterprise\"\n</code></pre> <p>Esta clase implementa el requisito de la propiedad <code>nombreCompleto</code> como una propiedad calculada de solo lectura para una nave estelar. Cada instancia de <code>NavaEstelar</code> almacena un nombre obligatorio y un prefijo opcional. La propiedad <code>nombreCompleto</code> usa el valor del prefijo si existe, y la a\u00f1ade al comienzo del nombre para crear un nombre completo de la nave estelar.</p> <p>Podemos definir una variable de tipo <code>TieneNombre</code> para indicar que solo nos interesa la propiedad <code>nombreCompleto</code> de esa variable. En esa variable podemos almacenar cualquier instancia de cualquier tipo que cumpla el protocolo.</p> <pre><code>var algoConNombre: TieneNombre = ncc1701 // guardamos la nave estelar\nalgoConNombre = john // y ahora guardamos la persona\n</code></pre> <p>En esta variable no podemos acceder a otras propiedades que no sean las definidas por el tipo <code>TieneNombre</code>. </p> <pre><code>print(algoConNombre.edad) \n// error: value of type 'TieneNombre' has no member 'edad'\n</code></pre> <p>Esto es una ventaja, porque nos permite especializar el c\u00f3digo y concentrarnos solo en las caracter\u00edsticas necesarias definidas por el tipo. Hablaremos m\u00e1s de esto m\u00e1s adelante, cuando hablemos de downcasting.</p>"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#83-requisitos-de-metodos","title":"8.3. Requisitos de m\u00e9todos","text":"<p>Los protocolos pueden requerir que los tipos que se ajusten a ellos implementen m\u00e9todos de instancia y de tipos espec\u00edficos. Estos m\u00e9todos se escriben como parte de la definici\u00f3n del protocolo de la misma forma que los m\u00e9todos normales, pero sin sus cuerpos:</p> <pre><code>protocol UnProtocolo {\n    func unMetodo() -&gt; Int\n}\n</code></pre> <p>Los m\u00e9todos del tipo en el protocolo deben indicarse con la palabra clave <code>static</code>:</p> <pre><code>protocol UnProtocolo {\n    static func unMetodoDelTipo()\n}\n</code></pre> <p>Un ejemplo:</p> <pre><code>protocol GeneradorNumerosAleatorios {\n    func random() -&gt; Double\n}\n</code></pre> <p>Este protocolo, <code>GeneradorNumerosAleatorios</code>, requiere que cualquier tipo que se ajuste a \u00e9l tenga un m\u00e9todo de instancia llamado <code>random</code>, que devuelve un valor <code>Double</code> cada vez que se llama. Aunque no est\u00e1 especificado en el protocolo, se asume que este valor ser\u00e1 un n\u00famero entre 0.0 y 1.0 (sin incluirlo). El protocolo <code>GeneradorNumerosAleatorios</code> no hace ninguna suposici\u00f3n sobre c\u00f3mo ser\u00e1 generado cada n\u00famero aleatorio, simplemente requiere al generador que proporcione una forma est\u00e1ndar de generarlo.</p> <p>Una vez definido el protocolo podremos usarlo como un tipo otras en clases y structs (verlo m\u00e1s adelante en el struct <code>Dado</code>) y definir distintas implementaciones que lo cumplen.</p> <p>Por ejemplo, si no tuvi\u00e9ramos inicialmente una buena implementaci\u00f3n de un generador de n\u00fameros aleatorios podr\u00edamos hacer una implementaci\u00f3n fake como la siguiente:</p> <pre><code>class GeneradorNumerosAleatoriosFake: GeneradorNumerosAleatorios {\n    private var numeros: [Double] = [0.2, 0.5, 0.8]\n    private var indiceActual = 0\n\n    func random() -&gt; Double {\n        let resultado = numeros[indiceActual]\n        indiceActual = (indiceActual + 1) % numeros.count\n        return resultado\n    }\n}\n</code></pre> <p>El generador anterior va proporcionando c\u00edclicamente los n\u00fameros con los que se inicializa el array:</p> <pre><code>var generador = GeneradorNumerosAleatoriosFake()\nfor _ in 1...5 {\n    print(\"N\u00famero aleatorio: \\(generador.random())\")\n}\n// N\u00famero aleatorio: 0.2\n// N\u00famero aleatorio: 0.5\n// N\u00famero aleatorio: 0.8\n// N\u00famero aleatorio: 0.2\n// N\u00famero aleatorio: 0.5\n</code></pre>"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#84-requisito-de-metodo-mutating","title":"8.4. Requisito de m\u00e9todo <code>mutating</code>","text":"<p>Si definimos un protocolo con un requisito de m\u00e9todo de instancia que pretenda mutar las instancias del tipo que adopte el protocolo, se debe marcar el m\u00e9todo con la palabra <code>mutating</code>. Esto permite a las estructuras y enumeraciones que adopten el protocolo definir ese m\u00e9todo como <code>mutating</code>. No es necesario hacerlo con las clases, porque la palabra <code>mutating</code> solo es necesaria en estructuras y enumeraciones.</p> <p>Un ejemplo:</p> <pre><code>protocol Conmutable {\n    mutating func conmutar()\n}\n\nenum Interruptor: Conmutable {\n    case apagado, encendido\n    mutating func conmutar() {\n        switch self {\n        case .apagado:\n            self = .encendido\n        case .encendido:\n            self = .apagado\n        }\n    }\n}\n\nvar interruptorLampara = Interruptor.apagado\ninterruptorLampara.conmutar()\n// interruptorLampara es ahora igual a .encendido\n</code></pre>"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#85-protocolos-como-tipos","title":"8.5. Protocolos como tipos","text":"<p>Los protocolos no implementan realmente ninguna funcionalidad por ellos mismos. Sin embargo, cualquier protocolo que definamos se convierte autom\u00e1ticamente en un tipo con todas sus propiedades que podemos usar en nuestro c\u00f3digo.</p> <p>Podemos entonces usar el protocolo en cualquier sitio donde permitamos otros tipos, incluyendo:</p> <ul> <li>El tipo de un par\u00e1metro de una funci\u00f3n, m\u00e9todo o inicializador o de   sus valores devueltos.</li> <li>El tipo de una constante, variable o propiedad</li> <li>El tipo de los \u00edtems de un array, diccionario u otro contenedor</li> </ul> <pre><code>class Dado {\n    let caras: Int\n    let generador: GeneradorNumerosAleatorios\n    init(caras: Int, generador: GeneradorNumerosAleatorios) {\n        self.caras = caras\n        self.generador = generador\n    }\n    func tirar() -&gt; Int {\n        return Int(generador.random() * Double(caras)) + 1\n    }\n}\n</code></pre> <p>Este ejemplo define una nueva clase llamada <code>Dado</code>, que representa un dado de n caras que se puede usar en un juego de tablero. Las instancias de dados tienen una propiedad llamada <code>caras</code>, que representa cu\u00e1ntas caras tienen, y una propiedad llamada <code>generador</code>, que proporciona un generador a partir del cual crear valores de tiradas.</p> <p>La propiedad generador es del tipo <code>GeneradorNumerosAleatorios</code>. Podemos asignarle una instancia de cualquier tipo que adopte el protocolo <code>GeneradorNumerosAleatorios</code>.</p> <p><code>Dado</code> tiene tambi\u00e9n un inicializador, para configurar sus estado inicial. El inicializador tiene un par\u00e1metro llamado <code>generador</code>, que tambi\u00e9n es del tipo <code>GeneradorNumerosAleatorios</code>. Podemos pasarle un valor de cualquier instancia que se ajuste a este tipo. Y tambi\u00e9n proporciona un m\u00e9todo de instancia llamado <code>tirar</code>, que devuelve un valor entero entre 1 y el n\u00famero de caras del dado. Este m\u00e9todo llama al m\u00e9todo <code>random()</code> del generador para crear un nuevo n\u00famero aleatorio entre 0.0 y 1.0 y usa este n\u00famero aleatorio para crear un valor de tirada que est\u00e9 dentro del rango correcto. Debido a que sabemos que el generador se ajusta al protocolo <code>GeneradorNumerosAleatorios</code> tenemos la garant\u00eda de que va a existir un m\u00e9todo <code>random()</code> al que llamar.</p> <p>Podemos probar el c\u00f3digo usando una instancia del <code>GeneradorNumerosAleatoriosFake</code> que creamos anteriormente</p> <pre><code>var d6 = Dado(caras: 6, generador: GeneradorNumerosAleatoriosFake())\nfor _ in 1...5 {\n    print(\"Tirada: \\(d6.tirar())\")\n}\n// Tirada: 2\n// Tirada: 4\n// Tirada: 5\n// Tirada: 2\n// Tirada: 4\n</code></pre> <p>Una de las ventajas de la programaci\u00f3n con protocolos es que el c\u00f3digo es mucho m\u00e1s flexible porque no nos atamos a una implementaci\u00f3n concreta. Por ejemplo, en el caso anterior, pese a no tener una buena implementaci\u00f3n del generador de n\u00fameros aleatorios hemos podido probar la clase <code>Dado</code> e incluso podr\u00edamos ejecutarla en una versi\u00f3n inicial de un programa en el que necesitemos un dado aleatorio.</p> <p>Despu\u00e9s, m\u00e1s adelante, podremos definir una implementaci\u00f3n m\u00e1s correcta del protocolo y usarla para construir un dado mejor, sin tocar nada del c\u00f3digo de la clase <code>Dado</code>:</p> <p>Por ejemplo, una implementaci\u00f3n m\u00e1s correcta de un generador de n\u00fameros aleatorios es la siguiente:</p> <pre><code>class GeneradorLinealCongruente: GeneradorNumerosAleatorios {\n    var ultimoRandom = 42.0\n    let m = 139968.0\n    let a = 3877.0\n    let c = 29573.0\n    func random() -&gt; Double {\n        let number = ultimoRandom * a + c\n        ultimoRandom = number.truncatingRemainder(dividingBy: m)\n        return ultimoRandom / m\n    }\n}\nlet generador = GeneradorLinealCongruente()\nvar generador = GeneradorLinealCongruente()\nfor _ in 1...5 {\n    print(\"N\u00famero aleatorio: \\(generador.random())\")\n\n// N\u00famero aleatorio: 0.3746499199817101\n// N\u00famero aleatorio: 0.729023776863283\n// N\u00famero aleatorio: 0.6364669067215364\n// N\u00famero aleatorio: 0.7934813671696388\n// N\u00famero aleatorio: 0.5385445244627344\n</code></pre> <p>Y su uso para construir un dado m\u00e1s aleatorio que el anterior:</p> <pre><code>var dado = Dado(caras: 6, generador: GeneradorLinealCongruente())\nfor _ in 1...5 {\n    print(\"Tirada: \\(dado.tirar())\")\n}\n// Tirada: 3\n// Tirada: 5\n// Tirada: 4\n// Tirada: 5\n// Tirada: 4\n</code></pre>"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#86-colecciones-de-tipos-protocolo","title":"8.6. Colecciones de tipos protocolo","text":"<p>Como hemos comentado anteriormente, un protocolo puede usarse como el tipo que se almacena un una colecci\u00f3n (array, diccionario, etc.). Veamos un ejemplo:</p> <pre><code>var peterParker = Persona(edad: 24, nombreCompleto: \"Peter Parker\")\nvar ncc1701 = NaveEstelar(nombre: \"Enterprise\", prefijo: \"USS\")\n\nlet cosasConNombre: [TieneNombre] = [peterParker, ncc1701]\n\nfor cosa in cosasConNombre {\n   print(cosa.nombreCompleto)\n}\n// Peter Parker\n// USS Enterprise\n</code></pre> <p>Hay que hacer notar que el iterador <code>cosa</code> que va recorriendo los valores del array es de tipo <code>TieneNombre</code>, no es de tipo <code>Persona</code> ni de tipo <code>NaveEstelar</code>. Por ser de tipo <code>TieneNombre</code> sabemos que tiene una propiedad <code>nombreCompleto</code> (declarada por el protocolo) que usamos en la sentencia con la llamada a <code>print</code>.</p> <p>En el bucle podr\u00eda interesarnos tambi\u00e9n acceder a las propiedades <code>edad</code> o <code>prefijo</code> dependiendo de si tenemos una <code>Persona</code> o una <code>NaveEstelar</code>. Veremos m\u00e1s adelante como hacerlo cuando hablemos de Casting de tipos.</p>"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#87-protocolo-equatable","title":"8.7. Protocolo <code>Equatable</code>","text":"<p>En la biblioteca est\u00e1ndar de Swift se definen distintos protocolos como <code>Collection</code> y <code>Equatable</code> que describen abstracciones comunes. Muchos de estos protocolos incorporan implementaciones por defecto de algunos de sus m\u00e9todos mediante extensiones definidas en la propia biblioteca est\u00e1ndar.</p> <p>Veamos por ejemplo el protocolo <code>Equatable</code>. Se trata de un protocolo importante que define las operaciones de igualdad (<code>==</code>) y diferencia (<code>!=</code>). Debemos implementar la operaci\u00f3n de igualdad en cualquier clase que se ajuste al protocolo, pero la operaci\u00f3n de diferencia ya tiene una implementaci\u00f3n por defecto.</p> <p>Un ejemplo:</p> <pre><code>class Punto3D: Equatable {\n    let x, y, z: Double\n\n    init(x: Double, y: Double, z: Double) {\n        self.x = x \n        self.y = y \n        self.z = z \n    }\n\n    static func == (izquierda: Punto3D, derecha: Punto3D) -&gt; Bool {\n        return\n            izquierda.x == derecha.x &amp;&amp;\n            izquierda.y == derecha.y &amp;&amp;\n            izquierda.z == derecha.z\n    }\n}\n\nlet p1 = Punto3D(x: 0.0, y: 0.0, z: 0.0)\nlet p2 = Punto3D(x: 0.0, y: 0.0, z: 0.0)\n\nprint(p1 == p2)\n// Imprime true\nprint(p1 != p2)\n// Imprime false\n</code></pre> <p>El operador <code>==</code> se define en la propia clase, con un m\u00e9todo est\u00e1tico tal y como vimos en el apartado anterior sobre funciones operadoras.</p> <p>El operador <code>!=</code> que se usa en la \u00faltima instrucci\u00f3n se define en una implementaci\u00f3n por defecto proporcionada por Swift.</p> <p>En las estructuras y enumeraciones el compilador define una implementaci\u00f3n autom\u00e1tica del operador <code>==</code> al a\u00f1adir el protocolo <code>Equatable</code>, siempre que las propiedades almacenadas y los valores asociados cumplan ese protocolo.</p> <p>Por ejemplo, si en lugar de una clase definimos el <code>Punto3D</code> como una estructura el c\u00f3digo quedar\u00eda como sigue. No es necesario definir ni el inicializador por defecto ni el operador <code>==</code>:</p> <pre><code>struct Punto3D: Equatable {\n    let x, y, z: Double\n}\n\nlet p1 = Punto3D(x: 0.0, y: 0.0, z: 0.0)\nlet p2 = Punto3D(x: 0.0, y: 0.0, z: 0.0)\n\nprint(p1 == p2)\n// Imprime true\nprint(p1 != p2)\n// Imprime false\n</code></pre>"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#88-herencia-en-protocolos","title":"8.8 Herencia en protocolos","text":"<p>Un protocolo puede heredar uno o m\u00e1s protocolos y puede a\u00f1adir requisitos adicionales sobre los requisitos que hereda. La sintaxis de herencia de protocolos es similar a la sintaxis de herencia de clases, pero con la opci\u00f3n de poder heredar m\u00faltiples protocolos separados por comas:</p> <pre><code>protocol ProtocoloQueHereda: UnProtocolo, OtroProtocolo {\n    // definici\u00f3n del protocolo\n}\n</code></pre> <p>Por ejemplo, imaginemos que estamos programando un sistema para definir una biblioteca. Podr\u00edamos tener un protocolo <code>Libro</code> que define propiedades como el t\u00edtulo y el autor de un libro, y otro protocolo <code>LibroPrestable</code> que hereda del protocolo <code>Libro</code> y a\u00f1ade la capacidad de prestar y devolver libros.</p> <p>El c\u00f3digo ser\u00eda el siguiente:</p> <pre><code>protocol Libro {\n    var titulo: String { get }\n    var autor: String { get }\n}\n\nprotocol LibroPrestable: Libro {\n    var estaPrestado: Bool { get set }\n    mutating func prestar()\n    mutating func devolver()\n}\n</code></pre> <p>De esta forma, estamos obligando a que cualquier cosa que sea un libro prestable, tambi\u00e9n debe ser un libro. Esto es, cualquier tipo que cumpla el protocolo <code>LibroPrestable</code> debe definir unas propiedades de lectura <code>titulo</code> y <code>autor</code> (obligado por el protocolo <code>Libro</code> del que hereda <code>LibroPrestable</code>) y otra propiedad <code>estaPrestado</code> (obligado por el propio protocolo <code>LibroPrestable</code>).</p> <p>Un ejemplo de una estructura que cumple el protocolo y de su uso:</p> <pre><code>struct LibroDeBiblioteca: LibroPrestable {\n    var titulo: String\n    var autor: String\n    var estaPrestado: Bool = false\n\n    mutating func prestar() {\n        if !estaPrestado {\n            estaPrestado = true\n        } else {\n            print(\"El libro ya est\u00e1 prestado.\")\n        }\n    }\n\n    mutating func devolver() {\n        if estaPrestado {\n            estaPrestado = false\n        } else {\n            print(\"El libro no est\u00e1 prestado.\")\n        }\n    }\n}\n\nvar libro = LibroDeBiblioteca(titulo: \"1984\", autor: \"George Orwell\")\nprint(libro.estaPrestado)  // Imprime: false\nlibro.prestar()\nprint(libro.estaPrestado)  // Imprime: true\nlibro.devolver()\nprint(libro.estaPrestado)  // Imprime: false\n</code></pre> <p>Otro ejemplo de la librer\u00eda de Swift es <code>Comparable</code> y <code>Equatable</code>. El protocolo <code>Comparable</code> hereda de <code>Equatable</code>. Cumpliendo el protocolo <code>Comparable</code> tambi\u00e9n se debe cumplir el protocolo <code>Equatable</code>.</p> <p>En el caso de los structs, Swift crea autom\u00e1ticamente el operador <code>==</code> y nosotros solo tendr\u00edamos que definir el operador <code>&lt;</code>. Por ejemplo, podemos indicar que una coordenada de pantalla es menor que otra cuando su coordenada <code>x</code> es menor, y en el caso en que sean iguales, cuando su coordenada <code>y</code> sea menor:</p> <pre><code>struct CoordPantalla : Comparable {\n    var x: Int \n    var y: Int \n    static func &lt; (primero: CoordPantalla, segundo: CoordPantalla) -&gt; Bool { \n        return primero.x &lt; segundo.x || \n               (primero.x == segundo.x &amp;&amp; primero.y &lt; segundo.y) \n    } \n}\n</code></pre> <p>Autom\u00e1ticamente el compilador genera a partir de los operadores <code>&lt;</code> y <code>==</code> los operadores <code>&gt;</code>, <code>&lt;=</code>, etc.:</p> <pre><code>var c1 = CoordPantalla(x: 0, y: 0)\nvar c2 = CoordPantalla(x: 10, y: 10)\nc1 &lt; c2 // true\nc1 &gt; c2 // false\nc1.x = 10\nc1.y = 10\nc1 == c2 // true\n</code></pre>"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#9-casting-de-tipos","title":"9. Casting de tipos","text":"<p>El casting de tipos es una forma de comprobar el tipo de una instancia o de tratar esa instancia como de una superclase distinta o conseguir una subclase de alg\u00fan otro sitio en la propia jerarqu\u00eda de clase. La forma de implementarlo es utilizando los operadores <code>is</code> y <code>as</code>. Estos operadores proporcionan una forma simple y expresiva de comprobar el tipo de un valor o transformar un valor en uno de otro tipo. Tambi\u00e9n se puede usar el casting de tipos para comprobar si un tipo se ajusta a un protocolo.</p>"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#91-una-jerarquia-de-clases-para-el-casting-de-tipos","title":"9.1. Una jerarqu\u00eda de clases para el casting de tipos","text":"<p>Vamos a comenzar construyendo una jerarqu\u00eda de clases y subclases con las que trabajar. Utilizaremos el casting de tipos para comprobar el tipo de una instancia particular de una clase y para convertir esa instancia en otra clase dentro de la misma jerarqu\u00eda.</p> <p>En el primer fragmento de c\u00f3digo definimos una clase nueva llamada <code>MediaItem</code>. Esta clase proporciona la funcionalidad b\u00e1sica de cualquier tipo de \u00edtem que aparece en una biblioteca de medios digitales. Espec\u00edficamente, declara una propiedad <code>nombre</code> de tipo <code>String</code> y un inicializador <code>init nombre</code> (suponemos que todos los \u00edtems, incluyendo pel\u00edculas y canciones, tendr\u00e1n un nombre).</p> <pre><code>class MediaItem {\n    var nombre: String\n    init(nombre: String) {\n        self.nombre = nombre\n    }\n}\n</code></pre> <p>El siguiente fragmento define dos subclases de <code>MediaItem</code>. La primera subclase, <code>Pelicula</code>, encapsula informaci\u00f3n adicional sobre una pel\u00edcula. A\u00f1ade una propiedad <code>director</code> a la clase base <code>MediaItem</code>, con su correspondiente inicializador. La segunda subclase, <code>Cancion</code>, a\u00f1ade una propiedad <code>artista</code> y un inicializador a la clase base:</p> <pre><code>class Pelicula: MediaItem {\n    var director: String\n    init(nombre: String, director: String) {\n        self.director = director\n        super.init(nombre: nombre)\n    }\n}\n\nclass Cancion: MediaItem {\n    var artista: String\n    init(nombre: String, artista: String) {\n        self.artista = artista\n        super.init(nombre: nombre)\n    }\n}\n</code></pre> <p>Por \u00faltimo, creamos un array constante llamado <code>biblioteca</code>, que contienen dos instancias de <code>Pelicula</code> y tres instancias de <code>Cancion</code>. </p> <pre><code>let biblioteca: [MediaItem] = [\n    Pelicula(nombre: \"El Se\u00f1or de los Anillos\", director: \"Peter Jackson\"),\n    Cancion(nombre: \"Child in Time\", artista: \"Deep Purple\"),\n    Pelicula(nombre: \"El Puente de los Esp\u00edas\", director: \"Steven Spielberg\"),\n    Cancion(nombre: \"I Wish You Were Here\", artista: \"Pink Floyd\"),\n    Cancion(nombre: \"Yellow\", artista: \"Coldplay\")\n]\n</code></pre> <p>Podr\u00edamos tambi\u00e9n dejar que el compilador infiera el tipo del array. Es capaz de deducir que <code>Pelicula</code> y <code>Cancion</code> tienen una superclase com\u00fan <code>MediaItem</code>, por lo que infiere que el tipo del array es <code>[MediaItem]</code>:</p> <pre><code>// Declaraci\u00f3n equivalente a la anterior\nlet biblioteca  = [\n    Pelicula(nombre: \"El Se\u00f1or de los Anillos\", director: \"Peter Jackson\"),\n    Cancion(nombre: \"Child in Time\", artista: \"Deep Purple\"),\n    Pelicula(nombre: \"El Puente de los Esp\u00edas\", director: \"Steven Spielberg\"),\n    Cancion(nombre: \"I Wish You Were Here\", artista: \"Pink Floyd\"),\n    Cancion(nombre: \"Yellow\", artista: \"Coldplay\")\n]\n</code></pre> <p>Los \u00edtems almacenados en la biblioteca son todav\u00eda instancias de <code>Pelicula</code> y <code>Cancion</code>. Sin embargo, si iteramos sobre los contenidos de este array, los \u00edtems que recibiremos tendr\u00e1n el tipo <code>MediaItem</code> y no <code>Pelicula</code> o <code>Cancion</code>. Para trabajar con ellos como su tipo nativo, debemos chequear su tipo, y hacer un downcast a su tipo concreto. Lo veremos m\u00e1s adelante.</p> <p>Sucede igual en el ejemplo visto anteriormente en el que se guardan en un array de tipo <code>TieneNombre</code> (un protocolo) dos instancias de estructuras distinas (una <code>Persona</code> y una <code>NaveEstelar</code>) que cumplen el protocolo.</p> <pre><code>var peterParker = Persona(edad: 24, nombreCompleto: \"Peter Parker\")\nvar ncc1701 = NaveEstelar(nombre: \"Enterprise\", prefijo: \"USS\")\n\nlet cosasConNombre: [TieneNombre] = [peterParker, ncc1701]\n\nfor cosa in cosasConNombre {\n   print(cosa.nombreCompleto)\n}\n// Peter Parker\n// USS Enterprise\n</code></pre> <p>Tambi\u00e9n podemos aplicar los operadores de comprobaci\u00f3n de tipo y de downcasting que veremos a continuaci\u00f3n a este caso en el que instancias concretas est\u00e1n en variables del tipo del protocolo.</p>"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#92-comprobacion-del-tipo","title":"9.2. Comprobaci\u00f3n del tipo","text":"<p>Podemos usar el operador de comprobaci\u00f3n (check operator) <code>is</code> para comprobar si una instancia es de un cierto tipo. El operador de comprobaci\u00f3n devuelve <code>true</code> si la instancia es del tipo y <code>false</code> si no.</p> <p>Lo podemos comprobar en el siguiente ejemplo, en el que contamos las instancias de pel\u00edculas y canciones en el array <code>biblioteca</code>:</p> <pre><code>var contadorPeliculas = 0\nvar contadorCanciones = 0\n\nfor item in biblioteca {\n    if item is Pelicula {\n        contadorPeliculas += 1\n    } else if item is Cancion {\n        contadorCanciones += 1\n    }\n}\n\nprint(\"La biblioteca contiene \\(contadorCanciones) pel\u00edculas y \\(contadorPeliculas) canciones\")\n// Imprime \"La biblioteca contiene 3 pel\u00edculas y 2 canciones\"\n</code></pre> <p>El ejemplo itera por todos los \u00edtems del array <code>biblioteca</code>. En cada paso, el bucle <code>for-in</code> guarda en la constante <code>item</code> el siguiente <code>MediaItem</code> del array.</p> <p>La instrucci\u00f3n <code>item is Pelicula</code> devuelve <code>true</code> si el <code>MediaItem</code> actual es una instancia de <code>Pelicula</code> y <code>false</code> en otro caso. De forma similar, <code>item is Cancion</code> comprueba si el \u00edtem es una instancia de <code>Cancion</code>. Al final del bucle <code>for-in</code>, los valores de <code>contadorPeliculas</code> y <code>contadorCanciones</code> contendr\u00e1n una cuenta de cuantas instancias <code>MediaItem</code> de cada tipo se han encontrado.</p> <p>La misma comprobaci\u00f3n se puede hacer en el array <code>cosasConNombre</code> para contar el n\u00famero de \u00edtems que son de tipo <code>Persona</code> y <code>NaveEspacial</code>.</p>"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#93-downcasting","title":"9.3. Downcasting","text":"<p>Una constante o variable de un cierto tipo de clase puede referirse (contener) a una instancia de una subclase. Tambi\u00e9n, una variable declarada con el tipo de un protocolo contiene una instancia de un tipo concreto, que cumple el protocolo.</p> <p>Cuando sucede esto, podemos hacer un downcast al tipo de la subclase o del tipo que cumple el protocolo con un operador de cast (<code>as?</code> o <code>as!</code>). Como el downcast puede fallar, la versi\u00f3n condicional, <code>as?</code>, devuelve un valor opcional del tipo al que estamos intentando hacer el downcasting. La versi\u00f3n forzosa, <code>as!</code>, intenta el downcast y fuerza la desenvoltura del resultado en un \u00fanica acci\u00f3n compuesta.</p> <p>Debemos usar la versi\u00f3n condicional (<code>as?</code>) cuando no estamos seguros si el downcast tendr\u00e1 \u00e9xito. Se devolver\u00e1 un valor opcional y el valor ser\u00e1 <code>nil</code> si no es posible hacer el downcast. Esto permitir\u00e1 comprobar si ha habido un downcast con \u00e9xito.</p> <p>La otra versi\u00f3n (<code>as!</code>) se usa s\u00f3lo cuando estamos seguros de que el downcast tendr\u00e1 \u00e9xito. Esta versi\u00f3n del operador lanzar\u00e1 un error en tiempo de ejecuci\u00f3n si intentamos hacer un downcast a un tipo incorrecto.</p> <p>El siguiente ejemplo itera sobre cada <code>MediaItem</code> en <code>biblioteca</code>, e imprime una descripci\u00f3n apropiada para cada \u00edtem. Para hacerlo, necesita acceder a cada \u00edtem como una <code>Pelicula</code> o <code>Cancion</code> y no s\u00f3lo como una <code>MediaItem</code>. Esto es necesario para poder acceder a la propiedad <code>director</code> o <code>artista</code> de una instancia de <code>Pelicula</code> o <code>Cancion</code>.</p> <p>En este ejemplo, cada \u00edtem en el array podr\u00eda ser un <code>Pelicula</code> o podr\u00eda ser una <code>Cancion</code>. No sabemos por anticipado la clase verdadera de cada \u00edtem, por lo que es apropiado usar la versi\u00f3n condicional (<code>as?</code>) para comprobar el downcast cada vez a lo largo del bucle:</p> <pre><code>for item in biblioteca {\n    if let pelicula = item as? Pelicula {\n        print(\"Pel\u00edcula: \\(pelicula.nombre), dir. \\(pelicula.director)\")\n    } else if let cancion = item as? Cancion {\n        print(\"Cancion: \\(cancion.nombre), de \\(cancion.artista)\")\n    }\n}\n\n// Pel\u00edcula: El Se\u00f1or de los Anillos, dir. Peter Jackson\n// Cancion: Child in Time, de Deep Purple\n// Pel\u00edcula: El Puente de los Esp\u00edas, dir. Steven Spielberg\n// Cancion: I Wish You Were Here, de Pink Floyd\n// Cancion: Yellow, de Coldplay\n</code></pre> <p>El ejemplo comienza intentando hacer <code>downcast</code> del \u00edtem a una <code>Pelicula</code>. Debido a que es una instancia de <code>MediaItme</code>, es posible que sea un <code>Pelicula</code> o una <code>Cancion</code>, o incluso el tipo base <code>MediaItem</code>. Debido a esta incertidumbre, debemos usar la versi\u00f3n <code>as?</code> para devolver un valor opcional. El resultado ser\u00e1 una \"Pelicula opcional\". Podemos desenvolver el valor <code>Pelicula</code> usando un <code>if let</code> como vimos en el apartado de opcionales. Si tiene \u00e9xito el downcasting, las propiedades de la pel\u00edcula se pueden usar para imprimir una descripci\u00f3n de la pel\u00edcula llamando a los correspondientes m\u00e9todos de la clase <code>Pelicula</code>. Igual con <code>Cancion</code>.</p> <p>El mismo ejemplo se puede aplicar al array <code>cosasConNombre</code>. Prueba a adaptar el c\u00f3digo anterior a este array, recorri\u00e9ndolo y haciendo el downcasting a los tipos <code>Persona</code> y <code>NaveEspacial</code>.</p> <p>Otra forma de hacer el downcasting es usando un operador <code>switch as</code> en el que se definen los distintos tipos posibles que puede tener la variable y se asignan a una variable del tipo correspondiente con un operador <code>case let</code>. Por ejemplo, el siguiente c\u00f3digo es equivalente al anterior:</p> <pre><code>for item in biblioteca {\n    switch item {\n    case let pelicula as Pelicula:\n        print(\"Pel\u00edcula: \\(pelicula.nombre), dir. \\(pelicula.director)\")\n    case let cancion as Cancion:\n        print(\"Cancion: \\(cancion.nombre), de \\(cancion.artista)\")\n    default:\n        break\n    }\n}\n</code></pre>"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#94-el-tipo-any","title":"9.4. El tipo <code>Any</code>","text":"<p>El tipo <code>Any</code> puede representar una instancia de cualquier tipo, incluyendo tipos funci\u00f3n:</p> <pre><code>var array = [Any]()\n\narray.append(0)\narray.append(0.0)\narray.append(42)\narray.append(3.14159)\narray.append(\"hola\")\narray.append((3.0, 5.0))\narray.append(Pelicula(nombre: \"Ghostbusters\", director: \"Ivan Reitman\"))\narray.append({ (name: String) -&gt; String in \"Hola, \\(name)\" })\n</code></pre> <p>El array contiene dos valores <code>Int</code>, dos valores <code>Double</code>, un valor <code>String</code>, una tupla del tipo <code>(Double, Double)</code>, la pel\u00edcula \"Ghostbusters\", y una clausura que toma un <code>String</code> y devuelve otro <code>String</code>.</p> <p>Puedes usar los operadores <code>is</code> y <code>as</code> en una sentencia <code>switch</code> para descubrir en tiempo de ejecuci\u00f3n el tipo espec\u00edfico de una constante o variable de la que s\u00f3lo se sabe que es de tipo <code>Any</code>:</p> <pre><code>for item in array {\n    switch item {\n    case 0 as Int:\n        print(\"cero como un Int\")\n    case 0 as Double:\n        print(\"cero como un Double\")\n    case let someInt as Int:\n        print(\"un valor entero de \\(someInt)\")\n    case let unDouble as Double where unDouble &gt; 0:\n        print(\"a valor positivo de \\(unDouble)\")\n    case is Double:\n        print(\"alg\u00fan otro valor double que no quiero imprimir\")\n    case let someString as String:\n        print(\"una cadena con valor de \\\"\\(someString)\\\"\")\n    case let (x, y) as (Double, Double):\n        print(\"un punto (x, y) en \\(x), \\(y)\")\n    case let pelicula as Pelicula:\n        print(\"una pel\u00edcula: \\(pelicula.nombre), dir. \\(pelicula.director)\")\n    case let stringConverter as (String) -&gt; String:\n        print(stringConverter(\"Michael\"))\n    default:\n        print(\"alguna otra cosa\")\n    }\n}\n\n// cero como un Int\n// cero como un Double\n// un valor entero de 42\n// a valor positivo de 3.14159\n// una cadena con valor de \"hola\"\n// un punto (x, y) en 3.0, 5.0\n// una pel\u00edcula: Ghostbusters, dir. Ivan Reitman\n// Hola, Michael\n</code></pre>"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#95-comprobacion-de-ajustarse-a-un-protocolo","title":"9.5. Comprobaci\u00f3n de ajustarse a un protocolo","text":"<p>Podemos usar tambi\u00e9n los operadores anteriores <code>is</code> y <code>as</code> (y <code>as?</code> y <code>as!</code>) para comprobar si una instancia se ajusta a un protocolo y para hacer un cast a un protocolo espec\u00edfico.</p> <p>Veamos un ejemplo. Definimos el protocolo <code>TieneArea</code> con el \u00fanico requisito de una propiedad de lectura llamada <code>area</code> de tipo <code>Double</code>:</p> <pre><code>protocol TieneArea {\n    var area: Double { get }\n}\n</code></pre> <p>Definimos dos clases <code>Circulo</code> y <code>Pais</code> que se ajustan ambos al protocolo: </p> <pre><code>class Circulo: TieneArea {\n    let pi = 3.1415927\n    var radio: Double\n    var area: Double { return pi * radio * radio }\n    init(radio: Double) { self.radio = radio }\n}\n\nclass Pais: TieneArea {\n    var area: Double\n    init(area: Double) { self.area = area }\n}\n</code></pre> <p>La clase <code>Circulo</code> implementa el requisito como una propiedad calculada, basada en la propiedad almacenada <code>radio</code>. La clase <code>Pais</code> implementa el requisito directamente como una propiedad almacenada. Ambas clases se ajustan correctamente al protocolo <code>TieneArea</code>.</p> <p>Definimos una clase <code>Animal</code> que no se ajusta al protocolo:</p> <pre><code>class Animal {\n    var patas: Int\n    init(patas: Int) { self.patas = patas }\n}\n</code></pre> <p>Las clases <code>Circulo</code>, <code>Pais</code> y <code>Animal</code> no tienen ninguna clase base compartida. Sin embargo, todas son clases, por lo que las instancias de los tres tipos pueden usarse para inicializar un array que almacena valores de tipo <code>Any</code>:</p> <pre><code>let objetos: [Any] = [\n    Circulo(radio: 2.0),\n    Pais(area: 243_610),\n    Animal(patas: 4)\n]\n</code></pre> <p>Y ahora podemos iterar sobre el array de objetos, comprobando para cada \u00edtem si la instancia se ajusta al protocolo <code>TieneArea</code>:</p> <pre><code>for objecto in objetos {\n    if let objetoConArea = objecto as? TieneArea {\n        print(\"El \u00e1rea es \\(objetoConArea.area)\")\n    } else {\n        print(\"Algo que no tiene un \u00e1rea\")\n    }\n}\n\n// El \u00e1rea es 12.5663708\n// El \u00e1rea es 243610.0\n// Algo que no tiene un \u00e1rea\n</code></pre> <p>Cuando un objeto en el array se ajusta al protocolo <code>TieneArea</code>, el valor opcional devuelto por el operador <code>as?</code> se desenvuelve con un ligado opcional en una constante llamada <code>objetoConArea</code>. Esta constante tiene el tipo <code>TieneArea</code>, por lo que su propiedad <code>area</code> podr\u00e1 ser accedida e impresa.</p> <p>Hay que notar que los objetos subyacentes no cambian en el proceso de casting. Siguen siendo un <code>Circulo</code>, un <code>Pais</code> y un <code>Animal</code>. Sin embargo, en el momento en se almacenan en la constante <code>objetoConArea</code>, s\u00f3lo se sabe que son del tipo <code>TieneArea</code>, por lo que s\u00f3lo podremos acceder a su propiedad <code>area</code>.</p>"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#10-genericos","title":"10. Gen\u00e9ricos","text":"<p>Veamos c\u00f3mo podemos utilizar los gen\u00e9ricos con clases y estructuras.</p> <p>Vamos a utilizar como ejemplo un tipo de dato muy sencillo: una pila (stack) en la que se podr\u00e1n a\u00f1adir (push) y retirar (pop) elementos.</p> <p>La versi\u00f3n no gen\u00e9rica del tipo de dato es la siguiente, en la que se implementa una pila de enteros.</p> <pre><code>struct IntStack {\n    var items = [Int]()\n    mutating func push(_ item: Int) {\n        items.append(item)\n    }\n    mutating func pop() -&gt; Int {\n        return items.removeLast()\n    }\n}\n</code></pre> <p>La estructura usa un array para guardar los \u00edtems y los m\u00e9todos <code>push</code> y <code>pop</code> a\u00f1aden y retiran los elementos. </p> <p>El problema de esta estructura es su falta de genericidad; s\u00f3lo puede almacenar enteros.</p> <p>Aqu\u00ed est\u00e1 una versi\u00f3n gen\u00e9rica del mismo c\u00f3digo:</p> <pre><code>struct Stack&lt;Element&gt; {\n    var items = [Element]()\n    mutating func push(_ item: Element) {\n        items.append(item)\n    }\n    mutating func pop() -&gt; Element {\n        return items.removeLast()\n    }\n}\n</code></pre> <p>El par\u00e1metro del tipo <code>Element</code> define un tipo gen\u00e9rico que se utiliza como placeholder del tipo real del que se declare la estructura. Podemos ver que se utiliza en la definici\u00f3n de los distintos elementos de la estructura. Por ejemplo, el array de \u00edtems es un array de <code>Element</code>s. Y los \u00edtems a\u00f1adidos y retirados de la pila son tambi\u00e9n objetos de tipo <code>Element</code>.</p> <p>Por ejemplo, podemos crear una pila de cadenas:</p> <pre><code>var stackOfStrings = Stack&lt;String&gt;()\nstackOfStrings.push(\"uno\")\nstackOfStrings.push(\"dos\")\nstackOfStrings.push(\"tres\")\nstackOfStrings.push(\"cuatro\")\n// la pila contiene ahora 4 cadenas\n</code></pre> <p>Y podemos retirar la \u00faltima cadena de la pila:</p> <pre><code>let fromTheTop = stackOfStrings.pop()\n</code></pre>"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#101-restricciones-en-los-tipos-genericos","title":"10.1. Restricciones en los tipos gen\u00e9ricos","text":"<p>Es posible definir una restricci\u00f3n en el tipo gen\u00e9rico, indicando que debe heredar de una clase o cumplir un protocolo.</p>"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#1011-restriccion-de-un-tipo-generico","title":"10.1.1 Restricci\u00f3n de un tipo gen\u00e9rico","text":"<p>La sintaxis es la siguiente:</p> <pre><code>func someFunction&lt;T: SomeClassOrProtocol&gt;(someT: T) {\n    // function body goes here\n}\n</code></pre> <p>Por ejemplo, supongamos una funci\u00f3n que busca una cadena en un array de cadenas y devuelve el \u00edndice en el que se encuentra:</p> <pre><code>func findIndex(ofString valueToFind: String, in array: [String]) -&gt; Int? {\n    for (index, value) in array.enumerated() {\n        if value == valueToFind {\n            return index\n        }\n    }\n    return nil\n}\n</code></pre> <p>Un ejemplo de uso:</p> <pre><code>let cadenas = [\"gato\", \"perro\", \"llama\", \"kanguro\", \"colibr\u00ed\"]\nif let indiceEncontrado = findIndex(ofString: \"llama\", in: cadenas) {\n    print(\"El \u00edndice de la llama es \\(indiceEncontrado)\")\n}\n// Imprime: \"El \u00edndice de la llama es 2\"\n</code></pre> <p>La funci\u00f3n anterior busca en un array de cadenas. \u00bfPodr\u00edamos generalizarla para que buscara en un array de cualquier tipo? Vamos a probarlo: </p> <pre><code>func findIndex&lt;T&gt;(of valueToFind: T, in array: [T]) -&gt; Int? {\n    for (index, value) in array.enumerated() {\n        if value == valueToFind {\n            return index\n        }\n    }\n    return nil\n}\n</code></pre> <p>Si probamos el c\u00f3digo anterior, veremos que el compilador nos da el siguiente error:</p> <pre><code>error: binary operator '==' cannot be applied to two 'T' operands\n        if value == valueToFind {\n           ~~~~~ ^  ~~~~~~~~~~~\n</code></pre> <p>Lo que est\u00e1 pasando es que el operador <code>==</code> no est\u00e1 definido en todos los tipos, sino solo en aquellos que cumplen el protocolo <code>Equatable</code>. Debemos restringir el tipo gen\u00e9rico a ese protocolo:</p> <pre><code>func findIndex&lt;T: Equatable&gt;(of valueToFind: T, in array:[T]) -&gt; Int? {\n    for (index, value) in array.enumerated() {\n        if value == valueToFind {\n            return index\n        }\n    }\n    return nil\n}\n</code></pre> <p>De esta forma nos aseguramos que se puede realizar la comparaci\u00f3n <code>==</code> en la b\u00fasqueda del valor se obliga a que el tipo gen\u00e9rico <code>T</code> cumpla el protocolo <code>Equatable</code>. Si se intenta llamar a la funci\u00f3n <code>findIndex</code> con, por ejemplo, un array de <code>Persona</code>s (estructura en la que no se ha adoptado el protocolo <code>Equatable</code>) se obtendr\u00e1 un error en tiempo de compilaci\u00f3n.</p> <p>Ahora ya podemos usar en la funci\u00f3n <code>find</code> cualquier tipo que cumpla <code>Equatable</code>, como <code>Double</code>:</p> <pre><code>let doubleIndex = findIndex(of: 9.3, in: [3.14159, 0.1, 0.25, 9.3])\n// devuelve Int? 2\n</code></pre>"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#1012-restricciones-de-mas-de-un-tipo-generico","title":"10.1.2 Restricciones de m\u00e1s de un tipo gen\u00e9rico","text":"<p>Podemos definir m\u00e1s de un par\u00e1metro, cada uno con una restricci\u00f3n. Por ejemplo, podr\u00edamos definir dos tipos gen\u00e9ricos <code>T</code> y <code>U</code>, de forma que el primero deba heredar de una clase y el segundo cumplir un protocolo:</p> <pre><code>func someFunction&lt;T: SomeClass, U: SomeProtocol&gt;(someT: T, someU: U) {\n    // function body goes here\n}\n</code></pre> <p>Un ejemplo sencillo en el que se demuestra esta posibilidad:</p> <pre><code>class Animal {\n    var nombre: String\n\n    init(nombre: String) {\n        self.nombre = nombre\n    }\n}\n\nprotocol EmisorDeSonido {\n    func emitirSonido() -&gt; String\n}\n\nfunc reproducirSonido&lt;T: Animal, U: EmisorDeSonido&gt;(animal: T, emisorDeSonido: U) {\n    let sonido = emisorDeSonido.emitirSonido()\n    print(\"\\(animal.nombre) emite el sonido: \\(sonido)\")\n}\n\nclass Perro: Animal {}\n\nclass Silbato: EmisorDeSonido {\n    func emitirSonido() -&gt; String {\n        return \"silbido\"\n    }\n}\n\nlet perro = Perro(nombre: \"Fido\")\nlet silbato = Silbato()\n\nreproducirSonido(animal: perro, emisorDeSonido: silbato)\n// Output: Fido emite el sonido: silbido\n</code></pre>"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#11-extensiones","title":"11. Extensiones","text":"<p>Las extensiones a\u00f1aden nueva funcionalidad a una clase, estructura, enumeraci\u00f3n. Esto incluye la posibilidad de extender tipos para los que no tenemos acceso al c\u00f3digo fuente original (esto se conoce como modelado retroactivo).</p> <p>Entre otras cosas, las extensiones pueden: </p> <ul> <li>A\u00f1adir propiedades calculadas de instancia y de tipo</li> <li>Definir nuevos m\u00e9todos de instancia y de tipo</li> <li>Proporcionar nuevos inicializadores</li> </ul>"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#111-sintaxis","title":"11.1. Sintaxis","text":"<p>Para declarar una extensi\u00f3n hay que usar la palabra clave <code>extension</code>, indicando despu\u00e9s el tipo que se quiere extender (enumeraci\u00f3n, clase, estructura o protocolo)</p> <pre><code>extension UnTipoExistente {\n    // nueva funcionalidad para a\u00f1adir a UnTipo\n}\n</code></pre>"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#112-propiedades-calculadas","title":"11.2. Propiedades calculadas","text":"<p>Las extensiones pueden a\u00f1adir propiedades calculadas de instancias y de tipos. Como primer ejemplo, recordemos el tipo <code>Persona</code>:</p> <pre><code>protocol TieneNombre {\n    var nombreCompleto: String { get }\n}\n\nstruct Persona: TieneNombre {\n    var edad: Int\n    var nombreCompleto: String\n}\n</code></pre> <p>Vamos a a\u00f1adir a la estructura la propiedad calculada <code>mayorEdad</code>, un <code>Bool</code> que indica si la edad de la persona es mayor o igual de 18:</p> <pre><code>extension Persona {\n   var mayorEdad: Bool {\n      return edad &gt;= 18\n   }\n}\n</code></pre> <p>Una vez definida esta extensi\u00f3n, hemos ampliado la clase con esta nueva propiedad, sin modificar el c\u00f3digo inicial con la definici\u00f3n de la clase. </p> <p>Podemos preguntar si una persona es mayor de edad:</p> <pre><code>var p = Persona(edad: 15, nombreCompleto: \"Luc\u00eda\")\np.mayorEdad // false\n</code></pre>"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#113-inicializadores","title":"11.3. Inicializadores","text":"<p>Las extensiones pueden a\u00f1adir nuevos inicializadores a tipos existentes. Esto nos permite extender otros tipos para aceptar nuestros propios tipos como par\u00e1metros de la inicializaci\u00f3n, o para proporcionar opciones adicionales que no estaban incluidos en la implementaci\u00f3n original del tipo.</p> <p>Recordemos la estructura <code>Rectangulo</code>, definida por un <code>Punto</code> y un <code>Tama\u00f1o</code>. Supongamos que la definimos sin inicializadores:</p> <pre><code>struct Tama\u00f1o {\n    var ancho = 0.0, alto = 0.0\n}\nstruct Punto {\n    var x = 0.0, y = 0.0\n}\nstruct Rectangulo {\n    var origen = Punto()\n    var tama\u00f1o = Tama\u00f1o()\n}\n</code></pre> <p>Recordemos que debido a que la estructura <code>Rectangulo</code> proporciona valores por defecto para todas sus propiedades, tiene un inicializador por defecto que puede utilizarse para crear nuevas instancias. Tambi\u00e9n podemos inicializarlo asignando todas sus propieades:</p> <pre><code>let rectanguloPorDefecto = Rectangulo()\nlet rectanguloInicializado = Rectangulo(origen: Punto(x: 2.0, y: 2.0),\n                                tama\u00f1o: Tama\u00f1o(ancho: 5.0, alto: 5.0))\n</code></pre> <p>Podemos ahora extender la estructura <code>Rectangulo</code> para proporcionar un inicializador adicional que toma un punto espec\u00edfico del centro y un tama\u00f1o:</p> <pre><code>extension Rectangulo {\n    init(centro: Punto, tama\u00f1o: Tama\u00f1o) {\n        let origenX = centro.x - (tama\u00f1o.ancho / 2)\n        let origenY = centro.y - (tama\u00f1o.alto / 2)\n        self.init(origen: Punto(x: origenX, y: origenY), tama\u00f1o: tama\u00f1o)\n    }\n }\n</code></pre> <p>Este nuevo inicializador empieza por calcular un punto de origen basado en el centro propuesto y en el tama\u00f1o. El inicializador llama despu\u00e9s al inicializador autom\u00e1tico de la estructura <code>init(origen:tama\u00f1o:)</code>, que almacena los nuevos valores de las propiedades:</p> <pre><code> let rectanguloCentro = Rectangulo(centro: Punto(x: 4.0, y: 4.0),\n                           tama\u00f1o: Tama\u00f1o(ancho: 3.0, alto: 3.0))\n // el origen del rectanguloCentro es is (2.5, 2.5) y su tama\u00f1o es (3.0, 3.0)\n</code></pre>"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#114-metodos","title":"11.4. M\u00e9todos","text":"<p>Las extensiones pueden a\u00f1adir nuevos m\u00e9todos de instancia y nuevos m\u00e9todos del tipo.</p> <p>Por ejemplo, podemos a\u00f1adir el m\u00e9todo <code>descripcion()</code> a la estructura <code>Persona</code>:</p> <pre><code>extension Persona {\n    func descripcion() -&gt; String {\n        return \"Me llamo \\(nombreCompleto) y tengo \\(edad) a\u00f1os\"\n    }\n}\n\nlet reedRichards = Persona(edad: 40, nombreCompleto: \"Reed Richards\")\nprint(reedRichards.descripcion())\n</code></pre> <p>Es posible incluso extender estructuras de las librer\u00edas est\u00e1ndar de Swift, como <code>Int</code>, <code>Double</code>, <code>Array</code>, <code>String</code> y clases y estructuras importadas. </p>"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#1141-nuevo-metodo-del-tipo-int","title":"11.4.1 Nuevo m\u00e9todo del tipo <code>Int</code>","text":"<p>Por ejemplo podemos a\u00f1adir un nuevo m\u00e9todo de instancia llamado <code>repeticiones</code> al tipo <code>Int</code>:</p> <pre><code>extension Int {\n    func repeticiones(_ tarea: () -&gt; Void) {\n        for _ in 0..&lt;self {\n            tarea()\n        }\n    }\n}\n</code></pre> <p>El m\u00e9todo <code>repeticiones(_:)</code> toma un \u00fanico argumento de tipo <code>() -&gt; Void</code>, que indica una funci\u00f3n que no tiene par\u00e1metros y no devuelve ning\u00fan valor. Despu\u00e9s de definir esta extensi\u00f3n, podemos llamar al m\u00e9todo <code>repeticiones(_:)</code> en cualquier n\u00famero entero para ejecutar una tarea un cierto n\u00famero de veces:</p> <pre><code>3.repeticiones({\n   print(\"Hola!\")\n})\n// Hola!\n// Hola!\n// Hola!\n</code></pre> <p>Usando clausuras por la cola podemos hacer la llamada m\u00e1s concisa:</p> <pre><code>3.repeticiones {\n   print(\"Adios!\")\n}\n// Adios!\n// Adios!\n// Adios!\n</code></pre>"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#1142-nuevo-metodo-del-tipo-string","title":"11.4.2 Nuevo m\u00e9todo del tipo <code>String</code>","text":"<p>Veamos otro ejemplo de extensi\u00f3n de un tipo ya existente.</p> <p>Por ejemplo, en Swift es algo complicado devolver el car\u00e1cter situado en una posici\u00f3n de una cadena, porque el \u00edndice que se utiliza para el acceso a la posici\u00f3n no es de tipo <code>Int</code>, sino un valor del tipo <code>String.Index</code>:</p> <pre><code>let cadena = \"Hola\"\nlet posicion = 2\nlet index = cadena.index(cadena.startIndex, offsetBy: posicion)\ncadena[index] // Devuelve \"l\"\n</code></pre> <p>Para simplificar el acceso a una posici\u00f3n de un <code>String</code> podemos definir una extensi\u00f3n que a\u00f1ada esa funcionalidad a la estructura:</p> <pre><code>extension String {\n    func at(_ pos: Int) -&gt; Character {\n        let index = self.index(self.startIndex, offsetBy: pos)\n        return self[index]\n    }\n}\n</code></pre> <p>El m\u00e9todo <code>at</code> devuelve el car\u00e1cter situado en una posici\u00f3n de la cadena:</p> <pre><code>\"Hola\".at(3) // devuelve \"a\"\n</code></pre> <p>Incluso Swift permite definir un m\u00e9todo con la palabra clave <code>subscript</code> para despu\u00e9s usar la notaci\u00f3n t\u00edpica de corchetes para acceder a un componente:</p> <pre><code>extension String {\n    subscript (pos: Int) -&gt; Character {\n        let index = self.index(self.startIndex, offsetBy: pos)\n        return self[index]\n    }\n}\n\"Hola\"[3] // devuelve \"a\"\n</code></pre>"},{"location":"teoria/tema06-programacion-orientada-objetos-swift/tema06-programacion-orientada-objetos-swift.html#12-bibliografia","title":"12. Bibliograf\u00eda","text":"<ul> <li>Swift Language Guide<ul> <li>Classes and Structures</li> <li>Properties</li> <li>Methods</li> <li>Inheritance</li> <li>Initialization</li> <li>Protocolos</li> <li>Casting de tipos</li> <li>Extensiones</li> <li>Funciones operador</li> <li>Gen\u00e9ricos</li> </ul> </li> </ul> <p>Lenguajes y Paradigmas de Programaci\u00f3n, curso 2024\u201325 \u00a9 Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial, Universidad de Alicante Domingo Gallardo, Cristina Pomares, Antonio Bot\u00eda, Francisco Mart\u00ednez</p>"}]}