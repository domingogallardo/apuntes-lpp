
<!doctype html>
<html lang="es" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
      
      
      <link rel="icon" href="../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.5.34">
    
    
      
        <title>Tema 4: Estructuras de datos recursivas - LPP</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/main.35f28582.min.css">
      
        
        <link rel="stylesheet" href="../../assets/stylesheets/palette.06af60db.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
    <script>__md_scope=new URL("../..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    
    
      
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="teal" data-md-color-accent="teal">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#tema-4-estructuras-de-datos-recursivas" class="md-skip">
          Saltar a contenido
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Cabecera">
    <a href="../.." title="LPP" class="md-header__button md-logo" aria-label="LPP" data-md-component="logo">
      
  <img src="../../imagenes/logo.png" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            LPP
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Tema 4: Estructuras de datos recursivas
            
          </span>
        </div>
      </div>
    </div>
    
      
        <form class="md-header__option" data-md-component="palette">
  
    
    
    
    <input class="md-option" data-md-color-media="" data-md-color-scheme="default" data-md-color-primary="teal" data-md-color-accent="teal"  aria-label="Switch to dark mode"  type="radio" name="__palette" id="__palette_0">
    
      <label class="md-header__button md-icon" title="Switch to dark mode" for="__palette_1" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a4 4 0 0 0-4 4 4 4 0 0 0 4 4 4 4 0 0 0 4-4 4 4 0 0 0-4-4m0 10a6 6 0 0 1-6-6 6 6 0 0 1 6-6 6 6 0 0 1 6 6 6 6 0 0 1-6 6m8-9.31V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12z"/></svg>
      </label>
    
  
    
    
    
    <input class="md-option" data-md-color-media="" data-md-color-scheme="slate" data-md-color-primary="black" data-md-color-accent="indigo"  aria-label="Switch to light mode"  type="radio" name="__palette" id="__palette_1">
    
      <label class="md-header__button md-icon" title="Switch to light mode" for="__palette_0" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 18c-.89 0-1.74-.2-2.5-.55C11.56 16.5 13 14.42 13 12s-1.44-4.5-3.5-5.45C10.26 6.2 11.11 6 12 6a6 6 0 0 1 6 6 6 6 0 0 1-6 6m8-9.31V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12z"/></svg>
      </label>
    
  
</form>
      
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Búsqueda" placeholder="Búsqueda" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Buscar">
        
        <button type="reset" class="md-search__icon md-icon" title="Limpiar" aria-label="Limpiar" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Inicializando búsqueda
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navegación" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../.." title="LPP" class="md-nav__button md-logo" aria-label="LPP" data-md-component="logo">
      
  <img src="../../imagenes/logo.png" alt="logo">

    </a>
    LPP
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_1" >
        
          
          <label class="md-nav__link" for="__nav_1" id="__nav_1_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Teoría
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_1_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_1">
            <span class="md-nav__icon md-icon"></span>
            Teoría
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../tema00-descripcion-asignatura/tema00-descripcion-asignatura.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Descripción de la asignatura
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../tema01-historia-lenguajes-programacion/tema01-historia-lenguajes-programacion.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Tema 1: Historia de los lenguajes de programación
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../tema02-programacion-funcional/tema02-programacion-funcional.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Tema 2: Programación funcional
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2" >
        
          
          <label class="md-nav__link" for="__nav_2" id="__nav_2_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Seminarios
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2">
            <span class="md-nav__icon md-icon"></span>
            Seminarios
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../seminarios/seminario1-scheme/seminario1-scheme.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Seminario de Scheme
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3" >
        
          
          <label class="md-nav__link" for="__nav_3" id="__nav_3_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Prácticas
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3">
            <span class="md-nav__icon md-icon"></span>
            Prácticas
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../practicas/buenas-practicas-programacion-funcional.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Buenas prácticas de programación funcional
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../practicas/practica01/practica01.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Práctica 1
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../practicas/practica02/practica02.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Práctica 2
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../practicas/practica03/practica03.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Práctica 3
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../practicas/practica04/practica04.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Práctica 4
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Tabla de contenidos">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Tabla de contenidos
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#1-listas-estructuradas" class="md-nav__link">
    <span class="md-ellipsis">
      1. Listas estructuradas
    </span>
  </a>
  
    <nav class="md-nav" aria-label="1. Listas estructuradas">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#11-definicion-y-ejemplos" class="md-nav__link">
    <span class="md-ellipsis">
      1.1. Definición y ejemplos
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#12-funciones-recursivas-sobre-listas-estructuradas" class="md-nav__link">
    <span class="md-ellipsis">
      1.2. Funciones recursivas sobre listas estructuradas
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#2-arboles" class="md-nav__link">
    <span class="md-ellipsis">
      2. Árboles
    </span>
  </a>
  
    <nav class="md-nav" aria-label="2. Árboles">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#21-definicion-de-arboles-en-scheme" class="md-nav__link">
    <span class="md-ellipsis">
      2.1. Definición de árboles en Scheme
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#22-funciones-recursivas-sobre-arboles" class="md-nav__link">
    <span class="md-ellipsis">
      2.2. Funciones recursivas sobre árboles
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#3-arboles-binarios" class="md-nav__link">
    <span class="md-ellipsis">
      3. Arboles binarios
    </span>
  </a>
  
    <nav class="md-nav" aria-label="3. Arboles binarios">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#31-definicion-de-arboles-binarios-en-scheme" class="md-nav__link">
    <span class="md-ellipsis">
      3.1. Definición de árboles binarios en Scheme
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#32-funciones-recursivas-sobre-arboles-binarios" class="md-nav__link">
    <span class="md-ellipsis">
      3.2. Funciones recursivas sobre árboles binarios
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#4-bibliografia-sicp" class="md-nav__link">
    <span class="md-ellipsis">
      4. Bibliografía - SICP
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


<h1 id="tema-4-estructuras-de-datos-recursivas">Tema 4: Estructuras de datos recursivas<a class="headerlink" href="#tema-4-estructuras-de-datos-recursivas" title="Permanent link">&para;</a></h1>
<h2 id="1-listas-estructuradas">1. Listas estructuradas<a class="headerlink" href="#1-listas-estructuradas" title="Permanent link">&para;</a></h2>
<p>Hemos visto que las listas en Scheme se implementan como un estructura
de datos recursiva, formada por una pareja que enlaza en su parte
derecha el resto de la lista y que termina con una parte derecha en la
que hay una lista vacía.</p>
<p>En este apartado vamos a volver a estudiar las listas desde un nivel
de abstracción alto, usando las funciones:</p>
<ul>
<li><code>(first lista)</code> para obtener el primer elemento de una lista</li>
<li><code>(rest lista)</code> para obtener el resto de la lista</li>
<li><code>(cons dato lista)</code> para construir una nueva lista con el dato como
  primer elemento</li>
</ul>
<p>En la mayoría de funciones y ejemplos que hemos visto hasta ahora las
listas están formadas por datos y el recorrido por la lista es un
recorrido lineal, iterando por sus elementos.</p>
<p>En este apartado vamos a ampliar este concepto y estudiar cómo
trabajar con <em>listas que contienen otras listas</em>.</p>
<p>Veremos que esto cambia fundamentalmente la estructura de las listas y
de las funciones que van a operar con ellas. El cambio fundamental es
que la función <code>first lista</code> puede devolver dos tipos de elementos: </p>
<ul>
<li>Un elemento de la lista (del tipo de elementos que hay en la lista)</li>
<li>Otra lista (formada por el tipo de elementos de la lista)</li>
</ul>
<h3 id="11-definicion-y-ejemplos">1.1. Definición y ejemplos<a class="headerlink" href="#11-definicion-y-ejemplos" title="Permanent link">&para;</a></h3>
<p>Las listas en Scheme pueden tener cualquier tipo de elementos,
incluido otras listas.</p>
<p>Llamaremos <strong>lista estructurada</strong> a una lista que contiene otras
sublistas. Lo contrario de lista estructurada es una <strong>lista plana</strong>,
una lista formada por elementos que no son listas. Llamaremos
<strong>hojas</strong> a los elementos de una lista que no son sublistas.</p>
<p>A las listas estructuradas cuyas hojas son símbolos se les denomina en
el contexto de la programación funcional <em>expresiones-S</em>
(<a href="http://en.wikipedia.org/wiki/S-expression">S-expression</a>).</p>
<p>Por ejemplo, la lista estructurada:</p>
<div class="highlight"><pre><span></span><code>(a b (c d e) (f (g h)))
</code></pre></div>
<p>es una lista estructurada con 4 elementos:</p>
<ul>
<li>El elemento <code>'a</code>, una hoja</li>
<li>El elemento <code>'b</code>, otra hoja</li>
<li>La lista plana <code>(c d e)</code></li>
<li>La lista estructurada <code>(f (g h))</code></li>
</ul>
<p>Se puede construir con cualquiera de las siguientes expresiones:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">lista</span><span class="w"> </span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">a</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">b</span><span class="w"> </span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">c</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">d</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">e</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">f</span><span class="w"> </span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">g</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">h</span><span class="p">))))</span>
<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">lista</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="ss">a</span><span class="w"> </span><span class="ss">b</span><span class="w"> </span><span class="p">(</span><span class="ss">c</span><span class="w"> </span><span class="ss">d</span><span class="w"> </span><span class="ss">e</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="ss">f</span><span class="w"> </span><span class="p">(</span><span class="ss">g</span><span class="w"> </span><span class="ss">h</span><span class="p">))))</span>
</code></pre></div>
<p>Una lista formada por parejas la consideraremos una lista plana, ya
que no contiene ninguna sublista. Por ejemplo, la lista</p>
<div class="highlight"><pre><span></span><code><span class="p">((</span><span class="n">a</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">b</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="mi">5</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">c</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="mi">12</span><span class="p">))</span>
</code></pre></div>
<p>es una lista plana de tres elementos (hojas) que son parejas.</p>
<h4 id="111-definiciones-en-scheme">1.1.1. Definiciones en Scheme<a class="headerlink" href="#111-definiciones-en-scheme" title="Permanent link">&para;</a></h4>
<p>Vamos a escribir las definiciones anteriores de <code>hoja</code>, <code>plana</code> y
<code>estructurada</code> usando código de Scheme.</p>
<h5 id="1111-funcion-hoja-dato">1.1.1.1. Función <code>(hoja? dato)</code><a class="headerlink" href="#1111-funcion-hoja-dato" title="Permanent link">&para;</a></h5>
<p>Definimos una hoja como aquellos elementos de una lista estructurada
que no son listas:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">hoja?</span><span class="w"> </span><span class="n">elem</span><span class="p">)</span>
<span class="w">   </span><span class="p">(</span><span class="nb">not</span><span class="w"> </span><span class="p">(</span><span class="nb">list?</span><span class="w"> </span><span class="n">elem</span><span class="p">)))</span>
</code></pre></div>
<p>Utilizaremos esta función para comprobar si un determinado elemento de
una lista es o no una hoja. Por ejemplo, supongamos la siguiente
lista:</p>
<div class="highlight"><pre><span></span><code><span class="p">((</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="p">(</span><span class="mi">5</span><span class="w"> </span><span class="mi">6</span><span class="p">))</span>
</code></pre></div>
<p>Es una lista de 4 elementos, siendo el primero y el último otras
sublistas y el segundo y el tercero hojas. Podemos comprobar si son o
no hojas sus elementos:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">lista</span><span class="w"> </span><span class="o">&#39;</span><span class="p">((</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="p">(</span><span class="mi">5</span><span class="w"> </span><span class="mi">6</span><span class="p">)))</span>
<span class="p">(</span><span class="n">hoja?</span><span class="w"> </span><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="n">lista</span><span class="p">))</span><span class="w"> </span><span class="c1">; ⇒ #f</span>
<span class="p">(</span><span class="n">hoja?</span><span class="w"> </span><span class="p">(</span><span class="nb">second</span><span class="w"> </span><span class="n">lista</span><span class="p">))</span><span class="w"> </span><span class="c1">; ⇒ #t</span>
<span class="p">(</span><span class="n">hoja?</span><span class="w"> </span><span class="p">(</span><span class="nb">third</span><span class="w"> </span><span class="n">lista</span><span class="p">))</span><span class="w"> </span><span class="c1">; ⇒ #t</span>
<span class="p">(</span><span class="n">hoja?</span><span class="w"> </span><span class="p">(</span><span class="nb">fourth</span><span class="w"> </span><span class="n">lista</span><span class="p">))</span><span class="w"> </span><span class="c1">; ⇒ #f</span>
</code></pre></div>
<p>La lista vacía no es una hoja</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="n">hoja?</span><span class="w"> </span><span class="o">&#39;</span><span class="p">())</span><span class="w"> </span><span class="c1">; ⇒ #f</span>
</code></pre></div>
<h5 id="1112-funcion-plana-lista">1.1.1.2. Función <code>(plana? lista)</code><a class="headerlink" href="#1112-funcion-plana-lista" title="Permanent link">&para;</a></h5>
<p>Como hemos dicho antes, una lista es plana cuando todos sus elementos
son hojas. Queremos implementar la función <code>(plana? lista)</code> que lo
compruebe.</p>
<p>Por ejemplo:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="n">plana?</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="ss">a</span><span class="w"> </span><span class="ss">b</span><span class="w"> </span><span class="ss">c</span><span class="w"> </span><span class="ss">d</span><span class="w"> </span><span class="ss">e</span><span class="w"> </span><span class="ss">f</span><span class="p">))</span><span class="w"> </span><span class="c1">; ⇒ #t</span>
<span class="p">(</span><span class="n">plana?</span><span class="w"> </span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">a</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="s2">&quot;Hola&quot;</span><span class="w"> </span><span class="no">#f</span><span class="p">))</span><span class="w"> </span><span class="c1">; ⇒ #t</span>
<span class="p">(</span><span class="n">plana?</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="ss">a</span><span class="w"> </span><span class="p">(</span><span class="ss">b</span><span class="w"> </span><span class="ss">c</span><span class="p">)</span><span class="w"> </span><span class="ss">d</span><span class="p">))</span><span class="w"> </span><span class="c1">; ⇒ #f</span>
<span class="p">(</span><span class="n">plana?</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="ss">a</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="ss">b</span><span class="p">))</span><span class="w"> </span><span class="c1">; ⇒ #f</span>
</code></pre></div>
<p>Una definición recursiva de lista plana:</p>
<blockquote>
<p>Una lista es plana si y solo si el primer elemento es una hoja y el
resto es plana.</p>
</blockquote>
<p>Y el caso base:</p>
<blockquote>
<p>Una lista vacía es plana.</p>
</blockquote>
<p>Usando esta definición recursiva, podemos implementar en Scheme la
función <code>(plana? lista)</code> que comprueba si una lista es plana:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">plana?</span><span class="w"> </span><span class="n">lista</span><span class="p">)</span>
<span class="w">   </span><span class="p">(</span><span class="k">or</span><span class="w"> </span><span class="p">(</span><span class="nb">null?</span><span class="w"> </span><span class="n">lista</span><span class="p">)</span>
<span class="w">       </span><span class="p">(</span><span class="k">and</span><span class="w"> </span><span class="p">(</span><span class="n">hoja?</span><span class="w"> </span><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="n">lista</span><span class="p">))</span>
<span class="w">            </span><span class="p">(</span><span class="n">plana?</span><span class="w"> </span><span class="p">(</span><span class="nb">rest</span><span class="w"> </span><span class="n">lista</span><span class="p">)))))</span>
</code></pre></div>
<p>Se podría también implementar la función <code>plana?</code> usando la función de
orden superior <code>for-all?</code> que comprueba que todos los elementos de una
lista cumplen una propiedad. En esta caso, ser hoja.</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">plana-fos?</span><span class="w"> </span><span class="n">lista</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="n">for-all?</span><span class="w"> </span><span class="n">hoja?</span><span class="w"> </span><span class="n">lista</span><span class="p">))</span>
</code></pre></div>
<div class="admonition note">
<p class="admonition-title">Función <code>for-all?</code></p>
<p>Recordemos que la función <code>(for-all? predicado lista)</code> se implementa
de la siguiente forma:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">for-all?</span><span class="w"> </span><span class="n">predicado</span><span class="w"> </span><span class="n">lista</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="k">or</span><span class="w"> </span><span class="p">(</span><span class="nb">null?</span><span class="w"> </span><span class="n">lista</span><span class="p">)</span>
<span class="w">      </span><span class="p">(</span><span class="k">and</span><span class="w"> </span><span class="p">(</span><span class="n">predicado</span><span class="w"> </span><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="n">lista</span><span class="p">))</span>
<span class="w">           </span><span class="p">(</span><span class="n">for-all?</span><span class="w"> </span><span class="n">predicado</span><span class="w"> </span><span class="p">(</span><span class="nb">rest</span><span class="w"> </span><span class="n">lista</span><span class="p">)))))</span>
</code></pre></div>
</div>
<h5 id="1113-funcion-estructurada-lista">1.1.1.3. Función <code>(estructurada? lista)</code><a class="headerlink" href="#1113-funcion-estructurada-lista" title="Permanent link">&para;</a></h5>
<p>Una lista es estructurada cuando alguno de sus elementos es otra
lista. Como caso base, una lista vacía no es estructurada.</p>
<p>Queremos implementar la función <code>(estructurada? lista)</code> que compruebe
si una lista es estructurada.</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="n">estructurada?</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="p">))</span><span class="w"> </span><span class="c1">; ⇒ #f</span>
<span class="p">(</span><span class="n">estructurada?</span><span class="w"> </span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">a</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">b</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">c</span><span class="w"> </span><span class="mi">3</span><span class="p">)))</span><span class="w"> </span><span class="c1">; ⇒ #f</span>
<span class="p">(</span><span class="n">estructurada?</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="ss">a</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="ss">b</span><span class="p">))</span><span class="w"> </span><span class="c1">; ⇒ #t</span>
<span class="p">(</span><span class="n">estructurada?</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="ss">a</span><span class="w"> </span><span class="p">(</span><span class="ss">b</span><span class="w"> </span><span class="ss">c</span><span class="p">)</span><span class="w"> </span><span class="ss">d</span><span class="p">))</span><span class="w"> </span><span class="c1">; ⇒ #t</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">estructurada?</span><span class="w"> </span><span class="n">lista</span><span class="p">)</span>
<span class="w">   </span><span class="p">(</span><span class="k">and</span><span class="w"> </span><span class="p">(</span><span class="nb">not</span><span class="w"> </span><span class="p">(</span><span class="nb">null?</span><span class="w"> </span><span class="n">lista</span><span class="p">))</span>
<span class="w">        </span><span class="p">(</span><span class="k">or</span><span class="w"> </span><span class="p">(</span><span class="nb">list?</span><span class="w"> </span><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="n">lista</span><span class="p">))</span>
<span class="w">            </span><span class="p">(</span><span class="n">estructurada?</span><span class="w"> </span><span class="p">(</span><span class="nb">rest</span><span class="w"> </span><span class="n">lista</span><span class="p">)))))</span>
</code></pre></div>
<p>Se podría implementar también usando la función de orden superior
<code>exists?</code> para consultar si algún elemento de la lista es también otra
lista.</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">estructurada-fos?</span><span class="w"> </span><span class="n">lista</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="n">exists?</span><span class="w"> </span><span class="nb">list?</span><span class="w"> </span><span class="n">lista</span><span class="p">))</span>
</code></pre></div>
<div class="admonition note">
<p class="admonition-title">Función <code>exists?</code></p>
<p>Recordemos que la función <code>(exists? predicado lista)</code> se implementa de
la siguiente forma:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">exists?</span><span class="w"> </span><span class="n">predicado</span><span class="w"> </span><span class="n">lista</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">null?</span><span class="w"> </span><span class="n">lista</span><span class="p">)</span>
<span class="w">      </span><span class="no">#f</span>
<span class="w">      </span><span class="p">(</span><span class="k">or</span><span class="w"> </span><span class="p">(</span><span class="n">predicado</span><span class="w"> </span><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="n">lista</span><span class="p">))</span>
<span class="w">          </span><span class="p">(</span><span class="n">exists?</span><span class="w"> </span><span class="n">predicado</span><span class="w"> </span><span class="p">(</span><span class="nb">rest</span><span class="w"> </span><span class="n">lista</span><span class="p">)))))</span>
</code></pre></div>
</div>
<p>Realmente bastaría con haber hecho una de las dos definiciones y
escribir la otra como la negación de la primera:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">estructurada?</span><span class="w"> </span><span class="n">lista</span><span class="p">)</span>
<span class="w">   </span><span class="p">(</span><span class="nb">not</span><span class="w"> </span><span class="p">(</span><span class="n">plana?</span><span class="w"> </span><span class="n">lista</span><span class="p">)))</span>
</code></pre></div>
<h4 id="112-ejemplos-de-listas-estructuradas">1.1.2. Ejemplos de listas estructuradas<a class="headerlink" href="#112-ejemplos-de-listas-estructuradas" title="Permanent link">&para;</a></h4>
<p>Las listas estructuradas son muy útiles para representar información
jerárquica en donde queremos representar elementos que contienen otros
elementos.</p>
<p>Por ejemplo, las expresiones de Scheme son listas estructuradas:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">2</span><span class="p">))</span>
<span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="p">(</span><span class="nb">/</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="mi">45</span><span class="p">))</span>
<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">factorial</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="p">(</span><span class="n">factorial</span><span class="w"> </span><span class="p">(</span><span class="nb">-</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="mi">1</span><span class="p">)))))</span>
</code></pre></div>
<p>El análisis sintáctico de una oración puede generar una lista
estructurada de símbolos, en donde se agrupan los distintos elementos
de la oración:</p>
<div class="highlight"><pre><span></span><code><span class="p">((</span><span class="n">Juan</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">compró</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">la</span><span class="w"> </span><span class="n">entrada</span><span class="w"> </span><span class="p">(</span><span class="n">de</span><span class="w"> </span><span class="n">la</span><span class="w"> </span><span class="n">película</span><span class="p">))</span><span class="w"> </span><span class="p">(</span><span class="n">el</span><span class="w"> </span><span class="n">viernes</span><span class="w"> </span><span class="n">por</span><span class="w"> </span><span class="n">la</span><span class="w"> </span><span class="n">tarde</span><span class="p">))</span>
</code></pre></div>
<p>Una página HTML, con sus distintos elementos, unos dentro de otros,
también se puede representar con una lista estructurada:</p>
<div class="highlight"><pre><span></span><code><span class="p">((</span><span class="n">&lt;h1&gt;</span><span class="w"> </span><span class="n">Mi</span><span class="w"> </span><span class="n">lista</span><span class="w"> </span><span class="n">de</span><span class="w"> </span><span class="n">la</span><span class="w"> </span><span class="n">compra</span><span class="w"> </span><span class="n">&lt;/h1&gt;</span><span class="p">)</span>
<span class="w"> </span><span class="p">(</span><span class="n">&lt;ul&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">&lt;li&gt;</span><span class="w"> </span><span class="n">naranjas</span><span class="w"> </span><span class="n">&lt;/li&gt;</span><span class="p">)</span>
<span class="w">       </span><span class="p">(</span><span class="n">&lt;li&gt;</span><span class="w"> </span><span class="n">tomates</span><span class="w"> </span><span class="n">&lt;/li&gt;</span><span class="p">)</span>
<span class="w">       </span><span class="p">(</span><span class="n">&lt;li&gt;</span><span class="w"> </span><span class="n">huevos</span><span class="w"> </span><span class="n">&lt;/li&gt;</span><span class="p">)</span><span class="w"> </span><span class="n">&lt;/ul&gt;</span><span class="p">))</span>
</code></pre></div>
<h4 id="113-pseudo-arboles-con-niveles">1.1.3. <em>Pseudo árboles</em> con niveles<a class="headerlink" href="#113-pseudo-arboles-con-niveles" title="Permanent link">&para;</a></h4>
<p>Las listas estructuradas definen una estructura de niveles, donde la
lista inicial representa el primer nivel, y cada sublista representa
un nivel inferior. Los datos de las listas representan las hojas.</p>
<p>Por ejemplo, la representación en forma de niveles de la lista <code>((a b
c) d e)</code> es la siguiente:</p>
<p><img src="imagenes/expresion-e-1.png" width="400px"/></p>
<p>Cada asterisco <code>*</code> representa una lista. Las ramas que salen del
asterisco representan los elementos de la lista. En el ejemplo tenemos
en un primer nivel una lista con 3 elementos: la lista <code>(a b c)</code>, <code>d</code>
y <code>e</code>. Y en el segundo nivel se encuentra la lista <code>(a b c)</code> cuyos 3
elementos son hojas.</p>
<p>Las hojas <code>d</code> y <code>e</code> están en el nivel 1 y en las posiciones
2 y 3 de la lista y las hojas <code>a</code>, <code>b</code> y <code>c</code> en el nivel 2.</p>
<div class="admonition warning">
<p class="admonition-title">Una lista estructurada no es un árbol</p>
<p>Una lista estructurada no es un árbol propiamente dicho, porque
un árbol tiene datos en todos los nodos, mientras que en la lista 
estructurada los datos están sólo en las hojas.</p>
</div>
<p>Las listas estructuradas sirven para agrupar de forma jerárquica
un conjunto de datos en distintos niveles. </p>
<p>A pesar de ser distintas de los árboles, ambas son estructuras de
datos jerárquicas (con niveles) que se pueden definir de forma
recursiva y sobre las que se pueden definir algoritmos
recursivos. Veremos más adelante cómo definir y trabajar con árboles
en Scheme.</p>
<p>Otro ejemplo. ¿Cuál sería la representación en niveles de la siguiente
lista estructurada?:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="p">(</span><span class="k">lambda</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="mi">10</span><span class="p">))</span><span class="w"> </span><span class="p">(</span><span class="k">quote</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="p">)))</span>
</code></pre></div>
<p><img src="imagenes/expresion-e-2.png" width="500px"/></p>
<h3 id="12-funciones-recursivas-sobre-listas-estructuradas">1.2. Funciones recursivas sobre listas estructuradas<a class="headerlink" href="#12-funciones-recursivas-sobre-listas-estructuradas" title="Permanent link">&para;</a></h3>
<h4 id="121-numero-de-hojas">1.2.1. Número de hojas<a class="headerlink" href="#121-numero-de-hojas" title="Permanent link">&para;</a></h4>
<p>Veamos como primer ejemplo la función <code>(num-hojas lista)</code> que cuenta
el número de hojas de una lista estructurada.</p>
<p>Por ejemplo:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="n">num-hojas</span><span class="w"> </span><span class="o">&#39;</span><span class="p">((</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="w"> </span><span class="mi">6</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="mi">7</span><span class="p">)))</span><span class="w"> </span><span class="c1">; ⇒ 7</span>
</code></pre></div>
<p>Como hemos comentado antes, una cuestión clave en las funciones que
vamos a construir sobre listas estructuradas es que el <code>first</code> de una
lista estructurada puede ser a su vez otra lista.</p>
<p>Para calcular el número de hojas de una lista podemos obtener el
primer elemento y el resto de la lista, y contar recursivamente el
número de hojas del primer elemento y del resto. Al ser una lista
estructurada, el primer elemento puede ser a su vez otra lista, por lo
que llamamos a la recursión para contar sus hojas.</p>
<p>La definición de este caso general usando <em>pseudocódigo</em> es:</p>
<blockquote>
<p>El número de hojas de una lista estructurada es la suma del número
de hojas de su primer elemento (que puede ser otra lista) y del
número de hojas del resto.</p>
</blockquote>
<p><img src="imagenes/num-hojas-estructurada.png" width="400px"/></p>
<p>La recursión tiene dos llamadas recursivas. Una que recibe el
elemento de la cabeza de la lista y otra que recibe el resto de la
lista. </p>
<div class="highlight"><pre><span></span><code><span class="c1">;Caso general num-hojas</span>
<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">num-hojas</span><span class="w"> </span><span class="n">lisdat</span><span class="p">)</span>
<span class="w">  </span><span class="c1">; Falta caso base</span>
<span class="w">  </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="p">(</span><span class="n">num-hojas</span><span class="w"> </span><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="n">lisdat</span><span class="p">))</span>
<span class="w">     </span><span class="p">(</span><span class="n">num-hojas</span><span class="w"> </span><span class="p">(</span><span class="nb">rest</span><span class="w"> </span><span class="n">lisdat</span><span class="p">))))</span>
</code></pre></div>
<div class="admonition warning">
<p class="admonition-title">No hay coste exponencial</p>
<p>A pesar de haber dos llamadas recursivas, no pasa lo mismo que en
Fibonacci o Pascal ya que no se van a repetir llamadas a la recursión
con los mismos datos. La recursión recorre la lista estructurada y su
coste será el número de elementos de la lista.</p>
</div>
<p>Para considerar el <strong>caso base</strong>, veamos cómo las llamadas recursivas
reciben cada vez un problema más pequeño. </p>
<p>La llamada recursiva sobre el resto de la lista recibe cada vez una
lista con 1 elemento menos. Al final se llamará a la función con una
lista vacía. Ese será un caso base. El número de elementos de una
lista vacía es 0.</p>
<p>La llamada recursiva sobre la cabeza de la lista es algo
distinta. Recibe una lista en la que se ha descendido un nivel y
tiene, por tanto, un nivel menos. Al final se llamará a la función con
una hoja (un dato). Ese será el otro caso base y habrá que devolver 1.</p>
<p>La definición completa de la función queda de la siguiente forma:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">num-hojas</span><span class="w"> </span><span class="n">lisdat</span><span class="p">)</span>
<span class="w">   </span><span class="p">(</span><span class="k">cond</span>
<span class="w">      </span><span class="p">((</span><span class="nb">null?</span><span class="w"> </span><span class="n">lisdat</span><span class="p">)</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">      </span><span class="p">((</span><span class="n">hoja?</span><span class="w"> </span><span class="n">lisdat</span><span class="p">)</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>
<span class="w">      </span><span class="p">(</span><span class="k">else</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="p">(</span><span class="n">num-hojas</span><span class="w"> </span><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="n">lisdat</span><span class="p">))</span>
<span class="w">               </span><span class="p">(</span><span class="n">num-hojas</span><span class="w"> </span><span class="p">(</span><span class="nb">rest</span><span class="w"> </span><span class="n">lisdat</span><span class="p">))))))</span>
</code></pre></div>
<div class="admonition warning">
<p class="admonition-title">Importante</p>
<p>Hay que hacer notar que el parámetro <code>lisdat</code> puede ser tanto una lista
como un dato atómico. En ese caso la función <code>(hoja? lisdat)</code>
devuelve <code>#t</code>.</p>
<p>En lenguajes de programación fuertemente tipados esto no
sería posible, porque la lista y el dato serían de distinto
tipo. En ese caso el código debería ser un poco más largo y antes
de llamar a la recursión habría que comprobar si el elemento es un
dato o es otra lista. En el caso de Scheme, podemos aprovecharnos
de su característica de ser débilmente tipado y podemos hacer el
código más conciso, llamando siempre a la recursión con el <code>first</code>
de la lista, independientemente de si es un dato u otra lista.</p>
<p>El código de la  versión en la que comprobamos si el elemento es
una lista antes de llamar a la recursión sería el siguiente:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">num-hojas</span><span class="w"> </span><span class="n">lista</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="k">cond</span>
<span class="w">        </span><span class="p">((</span><span class="nb">null?</span><span class="w"> </span><span class="n">lista</span><span class="p">)</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">        </span><span class="p">((</span><span class="n">hoja?</span><span class="w"> </span><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="n">lista</span><span class="p">))</span>
<span class="w">            </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">(</span><span class="n">num-hojas</span><span class="w"> </span><span class="p">(</span><span class="nb">rest</span><span class="w"> </span><span class="n">lista</span><span class="p">))))</span>
<span class="w">        </span><span class="p">(</span><span class="k">else</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="p">(</span><span class="n">num-hojas</span><span class="w"> </span><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="n">lista</span><span class="p">))</span>
<span class="w">                 </span><span class="p">(</span><span class="n">num-hojas</span><span class="w"> </span><span class="p">(</span><span class="nb">rest</span><span class="w"> </span><span class="n">lista</span><span class="p">))))))</span>
</code></pre></div>
</div>
<h5 id="1211-version-con-funciones-de-orden-superior">1.2.1.1. Versión con funciones de orden superior<a class="headerlink" href="#1211-version-con-funciones-de-orden-superior" title="Permanent link">&para;</a></h5>
<p>Podemos usar también las funciones de orden superior <code>map</code> y
<code>foldr</code> para obtener una versión más concisa.</p>
<p>Una lista estructurada tiene como elementos en un primer nivel hojas o
otras sublistas. Podemos entonces mapear una expresión lambda que se
aplica a cada uno de esos elementos. En la expresión lambda
comprobamos si el elemento (el parámetro <code>sublista</code> de la expresión
lambda) es una hoja o una lista. En el primero caso devolvemos 1. En
el segundo aplicaremos <em>la propia función que estamos definiendo</em>
sobre la sublista, con lo que se devolverá el número de hojas de esa
sublista.</p>
<p>El resultado del map será una lista de números (el número de hojas de
cada componente), que podemos sumar haciendo un <code>foldr</code> con la
función <code>+</code>:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">num-hojas-fos</span><span class="w"> </span><span class="n">ld</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">hoja?</span><span class="w"> </span><span class="n">ld</span><span class="p">)</span>
<span class="w">        </span><span class="mi">1</span>
<span class="w">        </span><span class="p">(</span><span class="nb">foldr</span><span class="w"> </span><span class="nb">+</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="n">num-hojas-fos</span><span class="w"> </span><span class="n">ld</span><span class="p">))))</span>
</code></pre></div>
<p>Una explicación gráfica de cómo funciona la función sobre la lista <code>(1
(2 3) (4) (5 (6 7) 8))</code>:</p>
<p><img src="imagenes/map-lista.png" width="700px"/></p>
<p>Sería equivalente hacer un <code>apply</code> de la suma para sumar los números
de la lista devuelta por el <code>map</code>:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">num-hojas-fos</span><span class="w"> </span><span class="n">ld</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">hoja?</span><span class="w"> </span><span class="n">ld</span><span class="p">)</span>
<span class="w">        </span><span class="mi">1</span>
<span class="w">        </span><span class="p">(</span><span class="nb">apply</span><span class="w"> </span><span class="nb">+</span><span class="w"> </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="n">num-hojas-fos</span><span class="w"> </span><span class="n">ld</span><span class="p">))))</span>
</code></pre></div>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Es interesante conocer ambas expresiones (la del <code>foldr</code> y la del
<code>apply</code>) porque hay lenguajes de programación en los que la función
<code>apply</code> no está definida. Por ejemplo, Swift.</p>
</div>
<h4 id="122-aplanar-lista">1.2.2. Aplanar lista<a class="headerlink" href="#122-aplanar-lista" title="Permanent link">&para;</a></h4>
<p>Veamos otro ejemplo. La función <code>(aplana lista)</code> que devuelve una
lista plana con todas las hojas de la lista. </p>
<p>Por ejemplo:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="n">aplana</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="p">(</span><span class="mi">3</span><span class="w"> </span><span class="p">(</span><span class="mi">4</span><span class="w"> </span><span class="p">(</span><span class="mi">5</span><span class="p">)))</span><span class="w"> </span><span class="p">(((</span><span class="mi">6</span><span class="p">)))))</span>
<span class="c1">; ⇒ (1 2 3 4 5 6)</span>
</code></pre></div>
<p>La solución recursiva es:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">aplana</span><span class="w"> </span><span class="n">ld</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="k">cond</span>
<span class="w">    </span><span class="p">((</span><span class="nb">null?</span><span class="w"> </span><span class="n">ld</span><span class="p">)</span><span class="w"> </span><span class="o">&#39;</span><span class="p">())</span>
<span class="w">    </span><span class="p">((</span><span class="n">hoja?</span><span class="w"> </span><span class="n">ld</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="n">ld</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="k">else</span><span class="w"> </span>
<span class="w">     </span><span class="p">(</span><span class="nb">append</span><span class="w"> </span><span class="p">(</span><span class="n">aplana</span><span class="w"> </span><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="n">ld</span><span class="p">))</span>
<span class="w">             </span><span class="p">(</span><span class="n">aplana</span><span class="w"> </span><span class="p">(</span><span class="nb">rest</span><span class="w"> </span><span class="n">ld</span><span class="p">))))))</span>
</code></pre></div>
<p>Con funciones de orden superior:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">aplana-fos</span><span class="w"> </span><span class="n">ld</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">hoja?</span><span class="w"> </span><span class="n">ld</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="n">ld</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="nb">foldr</span><span class="w"> </span><span class="nb">append</span><span class="w"> </span><span class="o">&#39;</span><span class="p">()</span><span class="w"> </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="n">aplana-fos</span><span class="w"> </span><span class="n">ld</span><span class="p">))))</span>
</code></pre></div>
<p>Usando <code>apply</code>:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">aplana-fos</span><span class="w"> </span><span class="n">ld</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">hoja?</span><span class="w"> </span><span class="n">ld</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="n">ld</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="nb">apply</span><span class="w"> </span><span class="nb">append</span><span class="w"> </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="n">aplana-fos</span><span class="w"> </span><span class="n">ld</span><span class="p">))))</span>
</code></pre></div>
<h4 id="123-otras-funciones-recursivas">1.2.3. Otras funciones recursivas<a class="headerlink" href="#123-otras-funciones-recursivas" title="Permanent link">&para;</a></h4>
<p>Vamos a diseñar otras funciones recursivas que trabajan con la
estructura jerárquica de las listas estructuradas.</p>
<ul>
<li><code>(pertenece-estruct? dato lista)</code>: busca una hoja en una lista
  estructurada.</li>
<li><code>(cuadrado-estruct lista)</code>: eleva todas las hojas al cuadrado
  (suponemos que la lista estructurada contiene números).</li>
<li><code>(map-estruct f lista)</code>: similar a map, aplica una función a todas las
  hojas de la lista estructurada y devuelve el resultado (otra lista
  estructurada).</li>
<li><code>(altura lista)</code>: devuelve el número de niveles de una lista
  estructurada.</li>
<li><code>(nivel-hoja dato lista)</code>: devuelve el nivel en el que se encuentra
  un dato en una lista.</li>
</ul>
<h5 id="1231-pertenece-estruct-dato-lista">1.2.3.1. <code>(pertenece-estruct? dato lista)</code><a class="headerlink" href="#1231-pertenece-estruct-dato-lista" title="Permanent link">&para;</a></h5>
<p>Comprueba si el <code>dato</code> aparece en la lista estructurada. </p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="n">pertenece-estruct?</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">a</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="ss">b</span><span class="w"> </span><span class="ss">c</span><span class="w"> </span><span class="p">(</span><span class="ss">d</span><span class="w"> </span><span class="p">(</span><span class="ss">a</span><span class="p">))))</span><span class="w"> </span><span class="c1">; ⇒ #t</span>
<span class="p">(</span><span class="n">pertenece-estruct?</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">a</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="ss">b</span><span class="w"> </span><span class="ss">c</span><span class="w"> </span><span class="p">(</span><span class="ss">d</span><span class="w"> </span><span class="ss">e</span><span class="w"> </span><span class="p">(</span><span class="ss">f</span><span class="p">))</span><span class="w"> </span><span class="ss">g</span><span class="p">))</span><span class="w"> </span><span class="c1">; ⇒ #f</span>
</code></pre></div>
<p>Solución recursiva:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">pertenece-estruct?</span><span class="w"> </span><span class="n">dato</span><span class="w"> </span><span class="n">ld</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="k">cond</span><span class="w"> </span>
<span class="w">    </span><span class="p">((</span><span class="nb">null?</span><span class="w"> </span><span class="n">ld</span><span class="p">)</span><span class="w"> </span><span class="no">#f</span><span class="p">)</span>
<span class="w">    </span><span class="p">((</span><span class="n">hoja?</span><span class="w"> </span><span class="n">ld</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">equal?</span><span class="w"> </span><span class="n">dato</span><span class="w"> </span><span class="n">ld</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="k">else</span><span class="w"> </span><span class="p">(</span><span class="k">or</span><span class="w"> </span><span class="p">(</span><span class="n">pertenece-estruct?</span><span class="w"> </span><span class="n">dato</span><span class="w"> </span><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="n">ld</span><span class="p">))</span>
<span class="w">              </span><span class="p">(</span><span class="n">pertenece-estruct?</span><span class="w"> </span><span class="n">dato</span><span class="w"> </span><span class="p">(</span><span class="nb">rest</span><span class="w"> </span><span class="n">ld</span><span class="p">))))))</span>
</code></pre></div>
<p>Con funciones de orden superior:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">pertenece-fos?</span><span class="w"> </span><span class="n">dato</span><span class="w"> </span><span class="n">ld</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">hoja?</span><span class="w"> </span><span class="n">ld</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="nb">equal?</span><span class="w"> </span><span class="n">dato</span><span class="w"> </span><span class="n">ld</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="n">exists?</span><span class="w"> </span><span class="p">(</span><span class="k">lambda</span><span class="w"> </span><span class="p">(</span><span class="n">elem</span><span class="p">)</span>
<span class="w">               </span><span class="p">(</span><span class="n">pertenece-fos?</span><span class="w"> </span><span class="n">dato</span><span class="w"> </span><span class="n">elem</span><span class="p">))</span><span class="w"> </span><span class="n">ld</span><span class="p">)))</span>
</code></pre></div>
<h5 id="1232-cuadrado-estruct-lista">1.2.3.2. <code>(cuadrado-estruct lista)</code><a class="headerlink" href="#1232-cuadrado-estruct-lista" title="Permanent link">&para;</a></h5>
<p>Vamos ahora a ver un tipo de función distinta. Una que construye una
lista estructurada y la devuelve. </p>
<p>Queremos implementar la función <code>(cuadrado-estruct lista)</code> que recibe
una lista estructurada y devuelve otra lista estructurada con la misma
estructura y sus números elevados al cuadrado.</p>
<p>Por ejemplo:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="n">cuadrado-estruct</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="p">(</span><span class="mi">4</span><span class="w"> </span><span class="p">(</span><span class="mi">5</span><span class="p">))))</span><span class="w"> </span><span class="c1">; ⇒ (4 9 (16 (25))</span>
</code></pre></div>
<p>La solución recursiva es:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">cuadrado-estruct</span><span class="w"> </span><span class="n">ld</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="k">cond</span><span class="w"> </span><span class="p">((</span><span class="nb">null?</span><span class="w"> </span><span class="n">ld</span><span class="p">)</span><span class="w"> </span><span class="o">&#39;</span><span class="p">())</span>
<span class="w">        </span><span class="p">((</span><span class="n">hoja?</span><span class="w"> </span><span class="n">ld</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="n">ld</span><span class="w"> </span><span class="n">ld</span><span class="w"> </span><span class="p">))</span>
<span class="w">        </span><span class="p">(</span><span class="k">else</span><span class="w"> </span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="p">(</span><span class="n">cuadrado-estruct</span><span class="w"> </span><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="n">ld</span><span class="p">))</span>
<span class="w">                    </span><span class="p">(</span><span class="n">cuadrado-estruct</span><span class="w"> </span><span class="p">(</span><span class="nb">rest</span><span class="w"> </span><span class="n">ld</span><span class="p">))))))</span>
</code></pre></div>
<p>Se llama a la recursión con el <code>first</code> y con el <code>rest</code> de la lista
original. El resultado de ambas llamadas serán las correspondientes
listas estructuradas con sus elementos elevados al cuadrado. Y se
devuelve la lista resultante de insertar la lista devuelta en la
llamada recursiva con el <code>first</code> en la primera posición de la lista
devuelta en la llamada recursiva con el <code>rest</code>.</p>
<p>Es muy interesante la versión de esta función con funciones de orden
superior:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">cuadrado-estruct-fos</span><span class="w"> </span><span class="n">ld</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">hoja?</span><span class="w"> </span><span class="n">ld</span><span class="p">)</span>
<span class="w">      </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="n">ld</span><span class="w"> </span><span class="n">ld</span><span class="p">)</span>
<span class="w">      </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="n">cuadrado-estruct-fos</span><span class="w"> </span><span class="n">ld</span><span class="p">)))</span>
</code></pre></div>
<p>Como una lista estructurada está compuesta de datos o de otras
sublistas podemos aplicar <code>map</code> para que devuelva la lista resultante
de transformar la original con la función que le pasamos como
parámetro.</p>
<h5 id="1233-map-estruct-f-lista">1.2.3.3. <code>(map-estruct f lista)</code><a class="headerlink" href="#1233-map-estruct-f-lista" title="Permanent link">&para;</a></h5>
<p>Podemos generalizar la función anterior y definir la función de orden
superior sobre listas estructuradas <code>(map-estructurada f lista)</code> que
devuelve una lista estructurada igual que la original con el resultado
de aplicar a cada uno de sus hojas la función f</p>
<p>Por ejemplo:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="n">map-estruct</span><span class="w"> </span><span class="p">(</span><span class="k">lambda</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">x</span><span class="p">))</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="p">(</span><span class="mi">4</span><span class="w"> </span><span class="p">(</span><span class="mi">5</span><span class="p">))))</span><span class="w"> </span><span class="c1">; ⇒ (4 9 (16 (25))</span>
</code></pre></div>
<p>La solución recursiva es una generalización de la función anterior,
usando el parámetro <code>f</code>:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">map-estruct</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">ld</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="k">cond</span><span class="w"> </span><span class="p">((</span><span class="nb">null?</span><span class="w"> </span><span class="n">ld</span><span class="p">)</span><span class="w"> </span><span class="o">&#39;</span><span class="p">())</span>
<span class="w">        </span><span class="p">((</span><span class="n">hoja?</span><span class="w"> </span><span class="n">ld</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="n">ld</span><span class="p">))</span>
<span class="w">        </span><span class="p">(</span><span class="k">else</span><span class="w"> </span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="p">(</span><span class="n">map-estruct</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="n">ld</span><span class="p">))</span>
<span class="w">                    </span><span class="p">(</span><span class="n">map-estruct</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="p">(</span><span class="nb">rest</span><span class="w"> </span><span class="n">ld</span><span class="p">))))))</span>
</code></pre></div>
<p>Solución con <code>map</code>:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">map-estruct-fos</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">ld</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">hoja?</span><span class="w"> </span><span class="n">ld</span><span class="p">)</span>
<span class="w">      </span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="n">ld</span><span class="p">)</span>
<span class="w">      </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="p">(</span><span class="k">lambda</span><span class="w"> </span><span class="p">(</span><span class="n">elem</span><span class="p">)</span>
<span class="w">             </span><span class="p">(</span><span class="n">map-estruct-fos</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">elem</span><span class="p">))</span><span class="w"> </span><span class="n">ld</span><span class="p">)))</span>
</code></pre></div>
<h5 id="1234-altura-lista">1.2.3.4. <code>(altura lista)</code><a class="headerlink" href="#1234-altura-lista" title="Permanent link">&para;</a></h5>
<p>La <em>altura</em> de una lista estructurada viene dada por su número de
niveles: una lista plana tiene una altura de 1, la lista <code>((1 2 3) 4
5)</code> tiene una altura de 2.</p>
<p>Para calcular la altura de una lista estructurada tenemos que obtener
(de forma recursiva) la altura de su primer elemento, y la altura del
resto de la lista, sumarle 1 a la altura del primer elemento y
devolver el máximo de los dos números.</p>
<p><img src="imagenes/altura-estructurada.png" width="300px"/></p>
<p>Como casos base, la altura de una lista vacía o de una hoja (dato) es 0.</p>
<p>En Scheme:</p>
<p><div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">altura</span><span class="w"> </span><span class="n">ld</span><span class="p">)</span>
<span class="w">   </span><span class="p">(</span><span class="k">cond</span><span class="w"> </span>
<span class="w">      </span><span class="p">((</span><span class="nb">null?</span><span class="w"> </span><span class="n">ld</span><span class="p">)</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">      </span><span class="p">((</span><span class="n">hoja?</span><span class="w"> </span><span class="n">ld</span><span class="p">)</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">      </span><span class="p">(</span><span class="k">else</span><span class="w"> </span><span class="p">(</span><span class="nb">max</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">(</span><span class="n">altura</span><span class="w"> </span><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="n">ld</span><span class="p">)))</span>
<span class="w">                 </span><span class="p">(</span><span class="n">altura</span><span class="w"> </span><span class="p">(</span><span class="nb">rest</span><span class="w"> </span><span class="n">ld</span><span class="p">))))))</span>
</code></pre></div>
Por ejemplo:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="n">altura</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="p">(</span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="mi">4</span><span class="p">))</span><span class="w"> </span><span class="c1">; ⇒ 2</span>
<span class="p">(</span><span class="n">altura</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="p">(</span><span class="mi">2</span><span class="w"> </span><span class="p">(</span><span class="mi">3</span><span class="p">))</span><span class="w"> </span><span class="mi">3</span><span class="p">))</span><span class="w"> </span><span class="c1">; ⇒ 3</span>
</code></pre></div>
<h6 id="12321-version-con-funciones-de-orden-superior">1.2.3.2.1. Versión con funciones de orden superior<a class="headerlink" href="#12321-version-con-funciones-de-orden-superior" title="Permanent link">&para;</a></h6>
<p>Y la segunda versión, usando las funciones de orden superior <code>map</code>
para obtener la altura de sus elementos del primer nivel (puedes ser
hojas o sublistas) y <code>foldr</code> para quedarse con el máximo de la
lista de valores que devuelve el map.</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">altura-fos</span><span class="w"> </span><span class="n">ld</span><span class="p">)</span>
<span class="w">   </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">hoja?</span><span class="w"> </span><span class="n">ld</span><span class="p">)</span>
<span class="w">       </span><span class="mi">0</span>
<span class="w">       </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">(</span><span class="nb">foldr</span><span class="w"> </span><span class="nb">max</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="n">altura-fos</span><span class="w"> </span><span class="n">ld</span><span class="p">)))))</span>
</code></pre></div>
<p>Podríamos hacerlo también sustituyendo el <code>foldr</code> por un <code>apply</code>:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">altura-fos</span><span class="w"> </span><span class="n">ld</span><span class="p">)</span>
<span class="w">   </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">hoja?</span><span class="w"> </span><span class="n">ld</span><span class="p">)</span>
<span class="w">       </span><span class="mi">0</span>
<span class="w">       </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">(</span><span class="nb">apply</span><span class="w"> </span><span class="nb">max</span><span class="w"> </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="n">altura-fos</span><span class="w"> </span><span class="n">ld</span><span class="p">)))))</span>
</code></pre></div>
<h5 id="1235-nivel-hoja-dato-lista">1.2.3.5. <code>(nivel-hoja dato lista)</code><a class="headerlink" href="#1235-nivel-hoja-dato-lista" title="Permanent link">&para;</a></h5>
<p>Veamos una última función <code>(nivel-hoja dato lista)</code> que recorre una
lista estructurada buscando el dato y devuelve el nivel en que se
encuentra. Si el dato no se encuentra en la lista, se devolverá -1. Si
el dato se encuentra en más de un lugar de la lista se devolverá el
nivel mayor.</p>
<p>Ejemplos:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="n">nivel-hoja</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">b</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="ss">a</span><span class="w"> </span><span class="ss">b</span><span class="w"> </span><span class="p">(</span><span class="ss">c</span><span class="p">)))</span><span class="w"> </span><span class="c1">; ⇒ 1</span>
<span class="p">(</span><span class="n">nivel-hoja</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">b</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="ss">a</span><span class="w"> </span><span class="p">(</span><span class="ss">b</span><span class="p">)</span><span class="w"> </span><span class="ss">c</span><span class="p">))</span><span class="w"> </span><span class="c1">; ⇒ 2</span>
<span class="p">(</span><span class="n">nivel-hoja</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">b</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="ss">a</span><span class="w"> </span><span class="p">(</span><span class="ss">b</span><span class="p">)</span><span class="w"> </span><span class="ss">d</span><span class="w"> </span><span class="p">((</span><span class="ss">b</span><span class="p">))))</span><span class="w"> </span><span class="c1">; ⇒ 3</span>
<span class="p">(</span><span class="n">nivel-hoja</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">b</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="ss">a</span><span class="w"> </span><span class="ss">c</span><span class="w"> </span><span class="ss">d</span><span class="w"> </span><span class="p">((</span><span class="ss">e</span><span class="p">))))</span><span class="w"> </span><span class="c1">; ⇒ -1</span>
</code></pre></div>
<p>Solución recursiva:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">nivel-hoja</span><span class="w"> </span><span class="n">dato</span><span class="w"> </span><span class="n">ld</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="k">cond</span>
<span class="w">    </span><span class="p">((</span><span class="nb">null?</span><span class="w"> </span><span class="n">ld</span><span class="p">)</span><span class="w"> </span><span class="mi">-1</span><span class="p">)</span>
<span class="w">    </span><span class="p">((</span><span class="n">hoja?</span><span class="w"> </span><span class="n">ld</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">equal?</span><span class="w"> </span><span class="n">ld</span><span class="w"> </span><span class="n">dato</span><span class="p">)</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="mi">-1</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="k">else</span><span class="w"> </span><span class="p">(</span><span class="nb">max</span><span class="w"> </span><span class="p">(</span><span class="n">suma-1-si-mayor-igual-que-0</span><span class="w"> </span>
<span class="w">                    </span><span class="p">(</span><span class="n">nivel-hoja</span><span class="w"> </span><span class="n">dato</span><span class="w"> </span><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="n">ld</span><span class="p">)))</span>
<span class="w">               </span><span class="p">(</span><span class="n">nivel-hoja</span><span class="w"> </span><span class="n">dato</span><span class="w"> </span><span class="p">(</span><span class="nb">rest</span><span class="w"> </span><span class="n">ld</span><span class="p">))))))</span>
</code></pre></div>
<p>La función auxiliar se define de la siguiente forma:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">suma-1-si-mayor-igual-que-0</span><span class="w"> </span><span class="n">x</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">&gt;=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">      </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>
<span class="w">      </span><span class="n">x</span><span class="p">))</span>
</code></pre></div>
<p>Con funciones de orden superior:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">nivel-hoja-fos</span><span class="w"> </span><span class="n">dato</span><span class="w"> </span><span class="n">ld</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">hoja?</span><span class="w"> </span><span class="n">ld</span><span class="p">)</span>
<span class="w">      </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">equal?</span><span class="w"> </span><span class="n">ld</span><span class="w"> </span><span class="n">dato</span><span class="p">)</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="mi">-1</span><span class="p">)</span>
<span class="w">      </span><span class="p">(</span><span class="n">suma-1-si-mayor-igual-que-0</span>
<span class="w">       </span><span class="p">(</span><span class="nb">foldr</span><span class="w"> </span><span class="nb">max</span><span class="w"> </span><span class="mi">-1</span><span class="w"> </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="p">(</span><span class="k">lambda</span><span class="w"> </span><span class="p">(</span><span class="n">elem</span><span class="p">)</span>
<span class="w">                           </span><span class="p">(</span><span class="n">nivel-hoja-fos</span><span class="w"> </span><span class="n">dato</span><span class="w"> </span><span class="n">elem</span><span class="p">))</span><span class="w"> </span><span class="n">ld</span><span class="p">)))))</span>
</code></pre></div>
<h2 id="2-arboles">2. Árboles<a class="headerlink" href="#2-arboles" title="Permanent link">&para;</a></h2>
<h3 id="21-definicion-de-arboles-en-scheme">2.1. Definición de árboles en Scheme<a class="headerlink" href="#21-definicion-de-arboles-en-scheme" title="Permanent link">&para;</a></h3>
<h4 id="211-definicion-de-arbol">2.1.1. Definición de árbol<a class="headerlink" href="#211-definicion-de-arbol" title="Permanent link">&para;</a></h4>
<p>Un <strong>árbol</strong> es una estructura de datos definida por un valor raíz,
que es el padre de toda la estructura, del que salen otros subárboles
hijos
(<a href="https://en.wikipedia.org/wiki/Tree_(data_structure)">Wikipedia</a>).</p>
<p>Un <strong>árbol</strong> se puede definir recursivamente de la siguiente forma:</p>
<ul>
<li>Una colección de un <strong>dato</strong> (el valor de la raíz del árbol) y una
  <strong>lista de hijos</strong> que también son árboles.</li>
<li>Una <strong>hoja</strong> será un árbol sin hijos (un dato con una lista de hijos
  vacía).</li>
</ul>
<p>Un ejemplo de árbol:</p>
<p><img src="imagenes/arbol-sencillo.png" width="600px"/></p>
<p>El árbol anterior tiene como dato raíz el número 30 y tiene 3 árboles
hijos:</p>
<ul>
<li>El primer hijo es un árbol con raíz 15 y con dos hijos hoja, el 10 y
  el 12</li>
<li>El segundo hijo es un árbol hoja, con valor 18</li>
<li>El tercer hijo es un árbol con raíz 25 y con tres hijos hoja, el 19,
  21 y 22.</li>
</ul>
<h4 id="212-representacion-de-arboles-con-listas">2.1.2. Representación de árboles con listas<a class="headerlink" href="#212-representacion-de-arboles-con-listas" title="Permanent link">&para;</a></h4>
<p>En Scheme la lista es la estructura de datos principal. ¿Cómo
podemos construir un árbol usando listas?</p>
<p>Podemos hacerlo de varias formas, pero escogemos la siguiente: usar
<strong>una lista de <em>n+1</em> elementos</strong> para representar un árbol con <em>n</em> hijos:</p>
<p><img src="imagenes/arbol-lista.png" width="600px"/></p>
<ul>
<li>el primer elemento la lista será el dato de la raíz</li>
<li>el resto serán los árboles hijos</li>
</ul>
<div class="highlight"><pre><span></span><code>arbol -&gt; (dato hijo-1 hijo-2 ... hijo-n)
</code></pre></div>
<p>Los nodos hoja (datos al final del árbol que no tienen ningún hijo)
son también árboles. Al no tener hijos, se representan como listas con
un único elemento, el propio dato.</p>
<div class="highlight"><pre><span></span><code>Nodo hoja -&gt; (dato)
</code></pre></div>
<p>La forma de representar el árbol anterior </p>
<p><img src="imagenes/arbol-sencillo2.png" width="400px"/></p>
<p>será la siguiente lista:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="mi">30</span><span class="w"> </span><span class="p">(</span><span class="mi">15</span><span class="w"> </span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="mi">12</span><span class="p">))</span><span class="w"> </span><span class="p">(</span><span class="mi">18</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="mi">25</span><span class="w"> </span><span class="p">(</span><span class="mi">19</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="mi">21</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="mi">22</span><span class="p">)))</span>
</code></pre></div>
<p>Los elementos de esta lista son:</p>
<p><img src="imagenes/lista-arbol.png" width="600px"/></p>
<ul>
<li>El primer elemento es el número <code>30</code>, el dato valor de la raíz del
  árbol</li>
<li>El segundo elemento es la lista <code>(15 (10) (12))</code>, que representa el
  árbol con dato <code>15</code> y dos hijos</li>
<li>El tercer elemento es la lista <code>(18)</code> que representa el árbol hoja
  formado por un 18</li>
<li>El tercer elemento es la lista <code>(15 (19) (21) (22))</code>, que representa el
  árbol con un dato <code>15</code> y tres hijos</li>
</ul>
<p>Podríamos definir el árbol con la siguiente sentencia:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">arbol1</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">30</span><span class="w"> </span><span class="p">(</span><span class="mi">15</span><span class="w"> </span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="mi">12</span><span class="p">))</span><span class="w"> </span><span class="p">(</span><span class="mi">18</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="mi">25</span><span class="w"> </span><span class="p">(</span><span class="mi">19</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="mi">21</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="mi">22</span><span class="p">))))</span>
</code></pre></div>
<p>Otro ejemplo más. ¿Cómo se implementa en Scheme el árbol de la siguiente figura?</p>
<p><img src="imagenes/arbol2.png" width="300px"/></p>
<p>Se haría con la lista de la siguiente sentencia:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">arbol2</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">40</span><span class="w"> </span><span class="p">(</span><span class="mi">18</span><span class="w"> </span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="mi">23</span><span class="w"> </span><span class="p">(</span><span class="mi">29</span><span class="p">)))</span><span class="w"> </span><span class="p">(</span><span class="mi">52</span><span class="w"> </span><span class="p">(</span><span class="mi">47</span><span class="p">))))</span>
</code></pre></div>
<h4 id="213-barrera-de-abstraccion">2.1.3. Barrera de abstracción<a class="headerlink" href="#213-barrera-de-abstraccion" title="Permanent link">&para;</a></h4>
<p>Una vez definida la forma de representar árboles, vamos a definir las
funciones básicas para manejarlos. Veremos las funciones para obtener el dato
y los hijos y la función para construir un árbol nuevo. Estas
funciones proporcionan lo que se denomina <em>barrera de abstracción</em>
del tipo datos <em>árbol</em>.</p>
<p>En todos los nombres de las funciones de la barrera de abstracción
añadimos el sufijo <code>-arbol</code>.</p>
<p>Definimos dos conjuntos de funciones: <strong>constructores</strong> para construir un
nuevo árbol y <strong>selectores</strong> para obtener los elementos del árbol. Vamos a
empezar por los selectores.</p>
<p><strong>Selectores</strong></p>
<p>Funciones que obtienen los elementos de un árbol:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">dato-arbol</span><span class="w"> </span><span class="n">arbol</span><span class="p">)</span><span class="w"> </span>
<span class="w">    </span><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="n">arbol</span><span class="p">))</span>

<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">hijos-arbol</span><span class="w"> </span><span class="n">arbol</span><span class="p">)</span><span class="w"> </span>
<span class="w">    </span><span class="p">(</span><span class="nb">rest</span><span class="w"> </span><span class="n">arbol</span><span class="p">))</span>

<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">hoja-arbol?</span><span class="w"> </span><span class="n">arbol</span><span class="p">)</span><span class="w"> </span>
<span class="w">   </span><span class="p">(</span><span class="nb">null?</span><span class="w"> </span><span class="p">(</span><span class="n">hijos-arbol</span><span class="w"> </span><span class="n">arbol</span><span class="p">)))</span>
</code></pre></div>
<p>Es importante tener claro los tipos devueltos por las dos primeras
funciones:</p>
<ul>
<li><code>(dato-arbol arbol)</code>: devuelve <strong>el dato</strong> de la raíz del árbol.</li>
<li><code>(hijos-arbol arbol)</code>: devuelve <strong>una lista de árboles</strong> hijos. En
  algunas ocasiones llamaremos <em>bosque</em> a una lista de
  árboles. Podremos recorrer esa lista usando las funciones <code>first</code> y
  <code>rest</code> para obtener los árboles hijos.</li>
</ul>
<p>Volvemos a mostrar el <code>arbol1</code> para comprobar estas funciones.</p>
<p><img src="imagenes/arbol-sencillo2.png" width="400px"/></p>
<p>Las funciones anteriores devuelven los siguientes valores:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="n">dato-arbol</span><span class="w"> </span><span class="n">arbol1</span><span class="p">)</span><span class="w"> </span><span class="c1">; ⇒ 30</span>
<span class="p">(</span><span class="n">hijos-arbol</span><span class="w"> </span><span class="n">arbol1</span><span class="p">)</span><span class="w"> </span><span class="c1">; ⇒ ((15 (10) (12)) (18) (25 (19) (21) (22)))</span>
<span class="p">(</span><span class="n">hoja-arbol?</span><span class="w"> </span><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="p">(</span><span class="n">hijos-arbol</span><span class="w"> </span><span class="n">arbol1</span><span class="p">)))</span><span class="w"> </span><span class="c1">; ⇒ #f</span>
<span class="p">(</span><span class="n">hoja-arbol?</span><span class="w"> </span><span class="p">(</span><span class="nb">second</span><span class="w"> </span><span class="p">(</span><span class="n">hijos-arbol</span><span class="w"> </span><span class="n">arbol1</span><span class="p">)))</span><span class="w"> </span><span class="c1">; ⇒ #t</span>
</code></pre></div>
<ul>
<li>La llamada <code>(dato-arbol arbol1)</code> devuelve el dato que hay en la raíz
  del árbol, el número <code>30</code>.</li>
<li>La invocación <code>(hijos-arbol arbol1)</code> devuelve una lista de tres
  elementos, los árboles hijos:<ul>
<li>El primer elemento es la lista <code>(15 (10) (12))</code>, que representa el árbol
  formado por el <code>15</code> en su raíz y las hojas <code>10</code> y <code>12</code>.</li>
<li>El segundo elemento es el árbol hoja <code>18</code>, representado por la
  lista <code>(18)</code>.</li>
<li>El tercero es la lista <code>(25 (19) (21) (22))</code>, que representa el
  árbol formado por el <code>25</code> en su raíz y las hojas <code>19</code>, <code>21</code> y <code>22</code>.</li>
</ul>
</li>
</ul>
<p>Es muy importante considerar en cada caso con qué tipo de dato estamos
trabajando y usar la barrera de abstracción adecuada en cada caso:</p>
<ul>
<li>La función <code>hijos-arbol</code> siempre devuelve una <strong>lista de árboles</strong>, que
  podemos recorrer usando <code>first</code> y <code>rest</code>.</li>
<li>El <code>first</code> de una lista de árboles (devuelta por <code>hijos-arbol</code>) siempre
  es un árbol y debemos de usar las funciones de su barrera de
  abstracción: <code>dato-arbol</code> e <code>hijos-arbol</code>.</li>
<li>La función <code>dato-arbol</code> devuelve un <strong>dato</strong>, del tipo que
  guardemos en el árbol. En el caso del árbol ejemplo es un número.</li>
</ul>
<p>Por ejemplo, para obtener el número <code>12</code> en el árbol anterior tendríamos
que hacer lo siguiente: acceder al primer elemento de la lista de
hijos, después al segundo hijo de éste y por último acceder a su
dato. Recordemos que <code>hijos-arbol</code> devuelve la lista de árboles hijos,
por lo que utilizaremos las funciones <code>first</code> y <code>rest</code> para recorrerlas y
obtener los elementos que nos interesen:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="n">dato-arbol</span><span class="w"> </span><span class="p">(</span><span class="nb">second</span><span class="w"> </span><span class="p">(</span><span class="n">hijos-arbol</span><span class="w"> </span><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="p">(</span><span class="n">hijos-arbol</span><span class="w"> </span><span class="n">arbol1</span><span class="p">)))))</span>
<span class="c1">; ⇒ 12</span>
</code></pre></div>
<p><strong>Constructor</strong></p>
<p>Definimos una función constructora que abstrae la construcción de un
árbol y encapsula su implementación concreta. Para construir un árbol
necesitamos un dato y una lista de árboles hijos. Si la lista de
árboles hijos es vacía, tendremos un nodo hoja.</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">construye-arbol</span><span class="w"> </span><span class="n">dato</span><span class="w"> </span><span class="n">lista-arboles</span><span class="p">)</span>
<span class="w">   </span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="n">dato</span><span class="w"> </span><span class="n">lista-arboles</span><span class="p">))</span>
</code></pre></div>
<p>Llamaremos a la función <code>construye-arbol</code> pasando su dato
(obligatorio) y la lista de arboles hijos. Si se pasa una lista vacía
como parámetro estaremos definiendo un nodo hoja.</p>
<p>Por ejemplo, para definir un nodo hoja con el dato 2:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">arbol3</span><span class="w"> </span><span class="p">(</span><span class="n">construye-arbol</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">&#39;</span><span class="p">()))</span>
</code></pre></div>
<p>Y para definir un árbol con 3 hijos:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">arbol4</span><span class="w"> </span><span class="p">(</span><span class="n">construye-arbol</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="p">(</span><span class="n">construye-arbol</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">&#39;</span><span class="p">())</span>
<span class="w">                                         </span><span class="p">(</span><span class="n">construye-arbol</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="o">&#39;</span><span class="p">())</span><span class="w"> </span>
<span class="w">                                         </span><span class="p">(</span><span class="n">construye-arbol</span><span class="w"> </span><span class="mi">9</span><span class="w"> </span><span class="o">&#39;</span><span class="p">())))</span>
</code></pre></div>
<p>El árbol 1 anterior se puede construir con las siguientes llamadas al
constructor. Guardamos los árboles hijos en variables auxiliares para
hacer más entendible la expresión:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">arbol-15</span><span class="w"> </span><span class="p">(</span><span class="n">construye-arbol</span><span class="w"> </span><span class="mi">15</span><span class="w"> </span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="p">(</span><span class="n">construye-arbol</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="o">&#39;</span><span class="p">())</span>
<span class="w">                                           </span><span class="p">(</span><span class="n">construye-arbol</span><span class="w"> </span><span class="mi">12</span><span class="w"> </span><span class="o">&#39;</span><span class="p">()))))</span>
<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">arbol-18</span><span class="w"> </span><span class="p">(</span><span class="n">construye-arbol</span><span class="w"> </span><span class="mi">18</span><span class="w"> </span><span class="o">&#39;</span><span class="p">()))</span><span class="w">                                             </span>
<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">arbol-25</span><span class="w"> </span><span class="p">(</span><span class="n">construye-arbol</span><span class="w"> </span><span class="mi">25</span><span class="w"> </span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="p">(</span><span class="n">construye-arbol</span><span class="w"> </span><span class="mi">19</span><span class="w"> </span><span class="o">&#39;</span><span class="p">())</span>
<span class="w">                                           </span><span class="p">(</span><span class="n">construye-arbol</span><span class="w"> </span><span class="mi">21</span><span class="w"> </span><span class="o">&#39;</span><span class="p">())</span>
<span class="w">                                           </span><span class="p">(</span><span class="n">construye-arbol</span><span class="w"> </span><span class="mi">22</span><span class="w"> </span><span class="o">&#39;</span><span class="p">()))))</span>
<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">arbol1b</span><span class="w"> </span><span class="p">(</span><span class="n">construye-arbol</span><span class="w"> </span><span class="mi">30</span><span class="w"> </span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="n">arbol-15</span><span class="w"> </span><span class="n">arbol-18</span><span class="w"> </span><span class="n">arbol-25</span><span class="p">)))</span>
<span class="n">arbol1b</span><span class="w"> </span><span class="c1">; ⇒ (30 (15 (10) (12)) (18) (25 (19) (21) (22)))</span>
</code></pre></div>
<h4 id="214-barreras-de-abstraccion-de-arboles-y-listas-estructuradas">2.1.4. Barreras de abstracción de árboles y listas estructuradas<a class="headerlink" href="#214-barreras-de-abstraccion-de-arboles-y-listas-estructuradas" title="Permanent link">&para;</a></h4>
<p>Es importante diferenciar la barrera de abstracción de los árboles de
la de las listas estructuradas. Aunque un árbol se implementa en
Scheme con una lista estructurada, a la hora de definir funciones
sobre árboles hay que trabajar con las funciones definidas arriba.</p>
<p>El siguiente esquema resumen las características de los selectores de
la barrera de abstracción de listas y árboles:</p>
<p><img src="imagenes/barrera-abstraccion.png" width="550px"></p>
<div class="admonition important">
<p class="admonition-title">Importante</p>
<p>Debemos usar la barrera de abstracción al trabajar con
árboles porque así separamos nuestro código de la implementación
subyacente del tipo de dato. De esta forma es posible cambiar la
implementación del tipo de dato sin afectar a las funciones que hemos
definido usando la barrera. Lo único que hay que hacer es cambiar la
implementación de la barrera de abstracción.</p>
<p>Otras ventajas de utilizar la barrera de abstracción, tan
importantes como la anterior, son:</p>
<ul>
<li>
<p>El código es mucho más legible. Dado que Scheme es un lenguaje
débilmente tipado, en una expresión como <code>(dato-arbol elem)</code>
sabemos que el el elemento sobre el que se trabaja es un árbol (no
es un número, ni un string, ni un booleano).</p>
</li>
<li>
<p>El código es trasladable a cualquier lenguaje de
programación. Si queremos trabajar con árboles en JavaScript, por
ejemplo, sólo tendremos que implementar la barrera de abstracción
en este lenguaje. Una vez hecho eso todas las funciones que
trabajan con árboles, como las que veremos a continuación,
funcionarán correctamente.</p>
</li>
</ul>
</div>
<h3 id="22-funciones-recursivas-sobre-arboles">2.2. Funciones recursivas sobre árboles<a class="headerlink" href="#22-funciones-recursivas-sobre-arboles" title="Permanent link">&para;</a></h3>
<p>Vamos a diseñar las siguientes funciones recursivas:</p>
<ul>
<li><code>(suma-datos-arbol arbol)</code>: devuelve la suma de todos los nodos</li>
<li><code>(to-list-arbol arbol)</code>: devuelve una lista con los datos del árbol</li>
<li><code>(cuadrado-arbol arbol)</code>: eleva al cuadrado todos los datos de un
  árbol manteniendo la estructura del árbol original</li>
<li><code>(map-arbol f arbol)</code>: devuelve un árbol con la estructura del árbol
  original aplicando la función f a subdatos.</li>
<li><code>(altura-arbol arbol)</code>: devuelve la altura de un árbol</li>
</ul>
<p>Todas comparten un patrón similar de recursión mutua.</p>
<h4 id="221-funcion-suma-datos-arbol">2.2.1. Función suma-datos-arbol<a class="headerlink" href="#221-funcion-suma-datos-arbol" title="Permanent link">&para;</a></h4>
<p>Vamos a implementar una función recursiva que sume todos los datos de
un árbol.</p>
<p>Un árbol siempre va a tener un dato y una lista de hijos (que puede
ser vacía) que obtenemos con las funciones <code>dato-arbol</code> e
<code>hijos-arbol</code>. Podemos plantear entonces el problema de sumar los datos
de un árbol como la suma del dato de su raíz y lo que devuelva la
llamada a una función auxiliar que sume los datos de su lista de hijos
(llamamos <em>bosque</em> a una lista de hijos):</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">suma-datos-arbol</span><span class="w"> </span><span class="n">arbol</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="p">(</span><span class="n">dato-arbol</span><span class="w"> </span><span class="n">arbol</span><span class="p">)</span>
<span class="w">       </span><span class="p">(</span><span class="n">suma-datos-bosque</span><span class="w"> </span><span class="p">(</span><span class="n">hijos-arbol</span><span class="w"> </span><span class="n">arbol</span><span class="p">))))</span>
</code></pre></div>
<p>Esta función suma los datos de <strong>un</strong> árbol. La podemos utilizar
entonces para construir la siguiente función que suma una lista de
árboles:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">suma-datos-bosque</span><span class="w"> </span><span class="n">bosque</span><span class="p">)</span>
<span class="w">   </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">null?</span><span class="w"> </span><span class="n">bosque</span><span class="p">)</span>
<span class="w">       </span><span class="mi">0</span>
<span class="w">       </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="p">(</span><span class="n">suma-datos-arbol</span><span class="w"> </span><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="n">bosque</span><span class="p">))</span><span class="w"> </span><span class="p">(</span><span class="n">suma-datos-bosque</span><span class="w"> </span><span class="p">(</span><span class="nb">rest</span><span class="w"> </span><span class="n">bosque</span><span class="p">)))))</span>
</code></pre></div>
<p>Podemos visualizar el funcionamiento de la <code>suma-datos-bosque</code> en la
siguiente figura:</p>
<p><img src="imagenes/suma-datos-bosque.png" width="600px"/></p>
<p>El caso general de la función obtiene el primer árbol de la lista (un
árbol) y llama a la función <code>suma-datos-arbol</code> para obtener la suma de
sus datos. También obtiene el resto del bosque (otra lista de árboles)
y llama de forma recursiva a la propia función para sumar todos sus
árboles.</p>
<p>Tenemos una <strong>recursión mutua</strong>: para sumar los datos de una lista de
árboles llamamos a la suma de un árbol individual que a su vez llama a
la suma de sus hijos, etc. La recursión termina cuando calculamos la
suma de un árbol hoja. Entonces se pasa a <code>suma-datos-bosque</code> una
lista vacía y ésta devolverá 0.</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="n">suma-datos-arbol</span><span class="w"> </span><span class="n">arbol1</span><span class="p">)</span><span class="w"> </span><span class="c1">; ⇒ 172</span>
</code></pre></div>
<p><strong>Versión alternativa con funciones de orden superior</strong></p>
<p>Al igual que hacíamos con las listas estructuradas, es posible
conseguir una versión más concisa y elegante utilizando funciones de
orden superior:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">suma-datos-arbol-fos</span><span class="w"> </span><span class="n">arbol</span><span class="p">)</span>
<span class="w">   </span><span class="p">(</span><span class="nb">foldr</span><span class="w"> </span><span class="nb">+</span><span class="w"> </span>
<span class="w">          </span><span class="p">(</span><span class="n">dato-arbol</span><span class="w"> </span><span class="n">arbol</span><span class="p">)</span><span class="w"> </span>
<span class="w">          </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="n">suma-datos-arbol-fos</span><span class="w"> </span><span class="p">(</span><span class="n">hijos-arbol</span><span class="w"> </span><span class="n">arbol</span><span class="p">))))</span>
</code></pre></div>
<p>La función <code>map</code> aplica la propia función que estamos definiendo
(<code>suma-datos-arbol-fos</code>) a cada uno de los árboles hijos (obtenidos
con la función <code>(hijos-arbol arbol)</code>). Confiando en que la función
hace su trabajo, devolverá para cada arbol hijo la suma de todos sus
nodos. De esta forma, el resultado de <code>map</code> será una lista con la suma
de los nodos de todos los árboles hijos.</p>
<p>La función <code>foldr</code> suma todos esos números de la lista y el
número de la raíz.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Puede parecer que a la función anterior le falta un caso
base. ¿Cuándo termina la recursión? La respuesta está en el
funcionamiento de <code>map</code>, que cuando recibe una lista vacía
devuelve también una lista vacía. Para comprobarlo, puedes pensar en
qué pasaría si le pasas a la función un árbol hoja.</p>
</div>
<p>Un ejemplo de su funcionamiento sería el siguiente:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="n">suma-datos-arbol-fos</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="p">(</span><span class="mi">2</span><span class="w"> </span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="mi">4</span><span class="p">))</span><span class="w"> </span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="mi">6</span><span class="w"> </span><span class="p">(</span><span class="mi">7</span><span class="p">))))</span><span class="w"> </span><span class="n">⇒</span>
<span class="w">   </span><span class="p">(</span><span class="nb">foldr</span><span class="w"> </span><span class="nb">+</span><span class="w"> </span>
<span class="w">          </span><span class="mi">1</span><span class="w"> </span>
<span class="w">          </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="n">suma-datos-arbol-fos</span><span class="w"> </span><span class="o">&#39;</span><span class="p">((</span><span class="mi">2</span><span class="w"> </span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="mi">4</span><span class="p">))</span><span class="w"> </span>
<span class="w">                                      </span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="w">                                      </span><span class="p">(</span><span class="mi">6</span><span class="w"> </span><span class="p">(</span><span class="mi">7</span><span class="p">)))))</span><span class="w"> </span><span class="n">⇒</span>
<span class="p">(</span><span class="nb">foldr</span><span class="w"> </span><span class="nb">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">9</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="mi">13</span><span class="p">))</span><span class="w"> </span><span class="n">⇒</span>
<span class="mi">28</span>
</code></pre></div>
<ul>
<li>El árbol que queremos sumar tiene un 1 en la raíz y tres hijos: <code>(2
(3) (4))</code>, <code>(5)</code> y <code>(6 (7))</code>. </li>
<li>La aplicación de <code>map suma-datos-arbol-fos</code> sobre la lista de hijos
devuelve una lista con la suma de los nodos de cada hijo: <code>(9 5 13)</code>.</li>
<li>La función <code>foldr</code> suma esa lista y el valor del nodo raíz (<code>1</code>).</li>
</ul>
<p>Podemos visualizar gráficamente el funcionamiento del <code>map</code> con la
siguiente figura:</p>
<p><img src="imagenes/suma-datos-bosque-fos.png" width="500px"/></p>
<h4 id="222-funcion-to-list-arbol">2.2.2. Función to-list-arbol<a class="headerlink" href="#222-funcion-to-list-arbol" title="Permanent link">&para;</a></h4>
<p>Queremos diseñar una función <code>(to-list-arbol arbol)</code> que devuelva una
lista con los datos del árbol en un recorrido <em>preorden</em> (primero el
dato de la raíz y después el dato de sus hijos de izquierda a derecha).</p>
<p>La solución, siguiendo el patrón visto en <code>suma-datos</code>, es la siguiente.</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">to-list-arbol</span><span class="w"> </span><span class="n">arbol</span><span class="p">)</span>
<span class="w">   </span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="p">(</span><span class="n">dato-arbol</span><span class="w"> </span><span class="n">arbol</span><span class="p">)</span>
<span class="w">         </span><span class="p">(</span><span class="n">to-list-bosque</span><span class="w"> </span><span class="p">(</span><span class="n">hijos-arbol</span><span class="w"> </span><span class="n">arbol</span><span class="p">))))</span>

<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">to-list-bosque</span><span class="w"> </span><span class="n">bosque</span><span class="p">)</span>
<span class="w">   </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">null?</span><span class="w"> </span><span class="n">bosque</span><span class="p">)</span>
<span class="w">       </span><span class="o">&#39;</span><span class="p">()</span>
<span class="w">       </span><span class="p">(</span><span class="nb">append</span><span class="w"> </span><span class="p">(</span><span class="n">to-list-arbol</span><span class="w"> </span><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="n">bosque</span><span class="p">))</span>
<span class="w">               </span><span class="p">(</span><span class="n">to-list-bosque</span><span class="w"> </span><span class="p">(</span><span class="nb">rest</span><span class="w"> </span><span class="n">bosque</span><span class="p">)))))</span>
</code></pre></div>
<p>Igual que antes, la función utiliza una <em>recursión mutua</em>: para listar
todos los nodos, añadimos el dato a la lista de nodos que nos devuelve
la función <code>to-list-bosque</code>. Esta función coge una lista de árboles
(un <em>bosque</em>) y devuelve la lista <em>preorden</em> de sus nodos. Para ello,
concatena la lista de los nodos de su primer elemento (el primer
árbol) a la lista de nodos del resto de árboles (que devuelve la
llamada recursiva).</p>
<p>Ejemplo:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="n">to-list-arbol</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="ss">*</span><span class="w"> </span><span class="p">(</span><span class="ss">+</span><span class="w"> </span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="ss">*</span><span class="w"> </span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="mi">3</span><span class="p">))</span><span class="w"> </span><span class="p">(</span><span class="mi">10</span><span class="p">))</span><span class="w"> </span><span class="p">(</span><span class="ss">-</span><span class="w"> </span><span class="p">(</span><span class="mi">12</span><span class="p">))))</span><span class="w"> </span>
<span class="c1">; ⇒ (* + 5 * 2 3 10 - 12)</span>
</code></pre></div>
<p>Una definición alternativa usando funciones de orden superior:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">to-list-arbol-fos</span><span class="w"> </span><span class="n">arbol</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="p">(</span><span class="n">dato-arbol</span><span class="w"> </span><span class="n">arbol</span><span class="p">)</span>
<span class="w">          </span><span class="p">(</span><span class="nb">foldr</span><span class="w"> </span><span class="nb">append</span><span class="w"> </span><span class="o">&#39;</span><span class="p">()</span><span class="w"> </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="n">to-list-arbol-fos</span><span class="w"> </span><span class="p">(</span><span class="n">hijos-arbol</span><span class="w"> </span><span class="n">arbol</span><span class="p">)))))</span>
</code></pre></div>
<p>Esta versión es muy elegante y concisa. Usa la función <code>map</code> que
aplica una función a los elementos de una lista y devuelve la lista
resultante. Como lo que devuelve <code>(hijos-arbol arbol)</code> es precisamente
una lista de árboles podemos aplicar a sus elementos cualquier función
definida sobre árboles. Incluso la propia función que estamos
definiendo (¡confía en la recursión!).</p>
<h4 id="223-funcion-cuadrado-arbol">2.2.3. Función cuadrado-arbol<a class="headerlink" href="#223-funcion-cuadrado-arbol" title="Permanent link">&para;</a></h4>
<p>Veamos ahora la función <code>(cuadrado-arbol arbol)</code> que toma un árbol de
números y devuelve un árbol con la misma estructura y sus datos
elevados al cuadrado:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">cuadrado-arbol</span><span class="w"> </span><span class="n">arbol</span><span class="p">)</span>
<span class="w">   </span><span class="p">(</span><span class="n">construye-arbol</span><span class="w"> </span><span class="p">(</span><span class="n">cuadrado</span><span class="w"> </span><span class="p">(</span><span class="n">dato-arbol</span><span class="w"> </span><span class="n">arbol</span><span class="p">))</span>
<span class="w">                    </span><span class="p">(</span><span class="n">cuadrado-bosque</span><span class="w"> </span><span class="p">(</span><span class="n">hijos-arbol</span><span class="w"> </span><span class="n">arbol</span><span class="p">))))</span>

<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">cuadrado-bosque</span><span class="w"> </span><span class="n">bosque</span><span class="p">)</span>
<span class="w">   </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">null?</span><span class="w"> </span><span class="n">bosque</span><span class="p">)</span>
<span class="w">       </span><span class="o">&#39;</span><span class="p">()</span>
<span class="w">       </span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="p">(</span><span class="n">cuadrado-arbol</span><span class="w"> </span><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="n">bosque</span><span class="p">))</span>
<span class="w">               </span><span class="p">(</span><span class="n">cuadrado-bosque</span><span class="w"> </span><span class="p">(</span><span class="nb">rest</span><span class="w"> </span><span class="n">bosque</span><span class="p">)))))</span>
</code></pre></div>
<p>Ejemplo:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="n">cuadrado-arbol</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">2</span><span class="w"> </span><span class="p">(</span><span class="mi">3</span><span class="w"> </span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="mi">5</span><span class="p">))</span><span class="w"> </span><span class="p">(</span><span class="mi">6</span><span class="p">)))</span><span class="w"> </span>
<span class="c1">; ⇒ (4 (9 (16) (25)) (36))</span>
</code></pre></div>
<p>Versión 2, con la función de orden superior <code>map</code>:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">cuadrado-arbol-fos</span><span class="w"> </span><span class="n">arbol</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="n">construye-arbol</span><span class="w"> </span><span class="p">(</span><span class="n">cuadrado</span><span class="w"> </span><span class="p">(</span><span class="n">dato-arbol</span><span class="w"> </span><span class="n">arbol</span><span class="p">))</span>
<span class="w">                     </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="n">cuadrado-arbol-fos</span><span class="w"> </span><span class="p">(</span><span class="n">hijos-arbol</span><span class="w"> </span><span class="n">arbol</span><span class="p">))))</span>
</code></pre></div>
<h4 id="224-funcion-map-arbol">2.2.4. Función <code>map-arbol</code><a class="headerlink" href="#224-funcion-map-arbol" title="Permanent link">&para;</a></h4>
<p>La función <code>map-arbol</code> es una función de orden superior que generaliza
la función anterior. Definimos un parámetro adicional en el que se
pasa la función a aplicar a los elementos del árbol.</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">map-arbol</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">arbol</span><span class="p">)</span>
<span class="w">   </span><span class="p">(</span><span class="n">construye-arbol</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="p">(</span><span class="n">dato-arbol</span><span class="w"> </span><span class="n">arbol</span><span class="p">))</span>
<span class="w">                    </span><span class="p">(</span><span class="n">map-bosque</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="p">(</span><span class="n">hijos-arbol</span><span class="w"> </span><span class="n">arbol</span><span class="p">))))</span><span class="w">  </span>

<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">map-bosque</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">bosque</span><span class="p">)</span>
<span class="w">   </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">null?</span><span class="w"> </span><span class="n">bosque</span><span class="p">)</span>
<span class="w">       </span><span class="o">&#39;</span><span class="p">()</span>
<span class="w">       </span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="p">(</span><span class="n">map-arbol</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="n">bosque</span><span class="p">))</span>
<span class="w">             </span><span class="p">(</span><span class="n">map-bosque</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="p">(</span><span class="nb">rest</span><span class="w"> </span><span class="n">bosque</span><span class="p">)))))</span>
</code></pre></div>
<p>Ejemplos:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="n">map-arbol</span><span class="w"> </span><span class="n">cuadrado</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">2</span><span class="w"> </span><span class="p">(</span><span class="mi">3</span><span class="w"> </span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="mi">5</span><span class="p">))</span><span class="w"> </span><span class="p">(</span><span class="mi">6</span><span class="p">)))</span>
<span class="c1">; ⇒ (4 (9 (16) (25)) (36))</span>
<span class="p">(</span><span class="n">map-arbol</span><span class="w"> </span><span class="p">(</span><span class="k">lambda</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="mi">1</span><span class="p">))</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">2</span><span class="w"> </span><span class="p">(</span><span class="mi">3</span><span class="w"> </span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="mi">5</span><span class="p">))</span><span class="w"> </span><span class="p">(</span><span class="mi">6</span><span class="p">)))</span>
<span class="c1">; ⇒ (3 (4 (5) (6)) (7))</span>
</code></pre></div>
<p>Con <code>map</code>:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">map-arbol-fos</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">arbol</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="n">construye-arbol</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="p">(</span><span class="n">dato-arbol</span><span class="w"> </span><span class="n">arbol</span><span class="p">))</span>
<span class="w">               </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="p">(</span><span class="k">lambda</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="w">                       </span><span class="p">(</span><span class="n">map-arbol-fos</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">x</span><span class="p">))</span><span class="w"> </span><span class="p">(</span><span class="n">hijos-arbol</span><span class="w"> </span><span class="n">arbol</span><span class="p">))))</span>
</code></pre></div>
<h4 id="225-funcion-altura-arbol">2.2.5. Función <code>altura-arbol</code><a class="headerlink" href="#225-funcion-altura-arbol" title="Permanent link">&para;</a></h4>
<p>Vamos por último a definir una función que devuelve la altura de un
árbol. </p>
<p>Recordemos las siguientes definiciones relacionadas con los árboles:</p>
<ul>
<li>Longitud de un camino entre dos nodos: número de aristas.</li>
<li>Altura de un nodo: longitud del camino más largo del nodo a una hoja.</li>
<li>Profundidad de un nodo: longitud del camino de la raíz al nodo.</li>
<li>Profundidad de un árbol: profundidad del nodo más profundo.</li>
<li>Nivel de un nodo: número de predecesores.</li>
<li>Altura de árbol: altura de la raíz.</li>
</ul>
<p>Podemos implementar la altura de una forma similar a como hicimos con
las listas estructuradas: calculamos la altura de los árboles hijos,
nos quedamos con la mayor, y sumamos 1 para añadir la arista del
camino de la raíz al hijo.</p>
<p>La mayor altura de los hijos la calculamos con la función
<code>altura-bosque</code>.</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">altura-arbol</span><span class="w"> </span><span class="n">arbol</span><span class="p">)</span>
<span class="w">   </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">hoja-arbol?</span><span class="w"> </span><span class="n">arbol</span><span class="p">)</span>
<span class="w">       </span><span class="mi">0</span>
<span class="w">       </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">(</span><span class="n">altura-bosque</span><span class="w"> </span><span class="p">(</span><span class="n">hijos-arbol</span><span class="w"> </span><span class="n">arbol</span><span class="p">)))))</span>

<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">altura-bosque</span><span class="w"> </span><span class="n">bosque</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">null?</span><span class="w"> </span><span class="n">bosque</span><span class="p">)</span>
<span class="w">        </span><span class="mi">0</span>
<span class="w">        </span><span class="p">(</span><span class="nb">max</span><span class="w"> </span><span class="p">(</span><span class="n">altura-arbol</span><span class="w"> </span><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="n">bosque</span><span class="p">))</span>
<span class="w">             </span><span class="p">(</span><span class="n">altura-bosque</span><span class="w"> </span><span class="p">(</span><span class="nb">rest</span><span class="w"> </span><span class="n">bosque</span><span class="p">)))))</span>
</code></pre></div>
<p>Ejemplos:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="n">altura-arbol</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span><span class="w"> </span><span class="c1">;  ⇒ 0</span>
<span class="p">(</span><span class="n">altura-arbol</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">4</span><span class="w"> </span><span class="p">(</span><span class="mi">9</span><span class="w"> </span><span class="p">(</span><span class="mi">16</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="mi">25</span><span class="p">))</span><span class="w"> </span><span class="p">(</span><span class="mi">36</span><span class="p">)))</span><span class="w"> </span><span class="c1">; ⇒ 2</span>
</code></pre></div>
<p>La solución con funciones de orden superior es similar a la
que vimos con listas estructuradas:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">altura-arbol-fos</span><span class="w"> </span><span class="n">arbol</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">hoja-arbol?</span><span class="w"> </span><span class="n">arbol</span><span class="p">)</span>
<span class="w">      </span><span class="mi">0</span>
<span class="w">      </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">(</span><span class="nb">foldr</span><span class="w"> </span><span class="nb">max</span><span class="w"> </span><span class="mi">0</span>
<span class="w">                  </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="n">altura-arbol-fos</span><span class="w"> </span><span class="p">(</span><span class="n">hijos-arbol</span><span class="w"> </span><span class="n">arbol</span><span class="p">))))))</span>
</code></pre></div>
<p>La función <code>map</code> mapea sobre los árboles hijos la propia función, que
calcula la altura de cada hijo (será uno menos que la altura del padre, 0
si se trata de una hoja).</p>
<p>La función <code>map</code> devuelve entonces una lista altura de los hijos, de
la que obtenemos el máximo plegando la lista con la función <code>max</code>. </p>
<p>Por último sumamos 1 para devolver la altura del árbol completo (un
nivel más que el nivel máximo de los hijos).</p>
<h2 id="3-arboles-binarios">3. Arboles binarios<a class="headerlink" href="#3-arboles-binarios" title="Permanent link">&para;</a></h2>
<h3 id="31-definicion-de-arboles-binarios-en-scheme">3.1. Definición de árboles binarios en Scheme<a class="headerlink" href="#31-definicion-de-arboles-binarios-en-scheme" title="Permanent link">&para;</a></h3>
<p>Los árboles binarios son árboles cuyos nodos tienen 0, 1 o 2
hijos. Por ejemplo, el árbol mostrado en la siguiente figura es un
árbol binario.</p>
<p><img src="imagenes/binario-2.png" width="300px"/></p>
<p>A diferencia de los árboles genéricos vistos anteriormente un árbol
binario no puede tener más de dos hijos.</p>
<p>Los representaremos en Scheme utilizando una lista de tres elementos:</p>
<ul>
<li>Dato</li>
<li>Hijo izquierdo (otro árbol binario)</li>
<li>Hijo derecho (otro árbol binario)</li>
</ul>
<p>En el caso en que no exista el hijo izquierdo o el derecho (o ambos)
utilizaremos una lista vacía para indicar un nodo vacío.</p>
<p>De esta manera, un nodo hoja con el dato 10 se representará en Scheme con la lista:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="mi">10</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">())</span>
</code></pre></div>
<p>Por ejemplo, representamos el árbol de la figura anterior con la
siguiente lista:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="mi">40</span><span class="w"> </span><span class="p">(</span><span class="mi">18</span><span class="w"> </span><span class="p">(</span><span class="mi">3</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">())</span>
<span class="w">        </span><span class="p">(</span><span class="mi">23</span><span class="w"> </span><span class="p">()</span>
<span class="w">            </span><span class="p">(</span><span class="mi">29</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">())))</span>
<span class="w">    </span><span class="p">(</span><span class="mi">52</span><span class="w"> </span><span class="p">(</span><span class="mi">47</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">())</span>
<span class="w">        </span><span class="p">()))</span>
</code></pre></div>
<p>Visualmente lo podemos representar de la siguiente forma. La no
existencia de un hijo izquierdo o un hijo derecho se representa por
una lista vacía.</p>
<p><img src="imagenes/binario-3.png" width="350px"/></p>
<h4 id="311-barrera-de-abstraccion">3.1.1. Barrera de abstracción<a class="headerlink" href="#311-barrera-de-abstraccion" title="Permanent link">&para;</a></h4>
<p>Definimos la siguiente barrera de abstracción para los árboles
binarios. Terminamos todos los nombres de las funciones con el sufijo
<code>-arbolb</code> (árbol binario).</p>
<p><strong>Selectores</strong></p>
<p>Los selectores de la barrera de abstracción del árbol binario son los
siguientes.</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">dato-arbolb</span><span class="w"> </span><span class="n">arbol</span><span class="p">)</span>
<span class="w">   </span><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="n">arbol</span><span class="p">))</span>

<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">hijo-izq-arbolb</span><span class="w"> </span><span class="n">arbol</span><span class="p">)</span>
<span class="w">   </span><span class="p">(</span><span class="nb">second</span><span class="w"> </span><span class="n">arbol</span><span class="p">))</span>

<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">hijo-der-arbolb</span><span class="w"> </span><span class="n">arbol</span><span class="p">)</span>
<span class="w">   </span><span class="p">(</span><span class="nb">third</span><span class="w"> </span><span class="n">arbol</span><span class="p">))</span>

<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">arbolb-vacio</span><span class="w"> </span><span class="o">&#39;</span><span class="p">())</span>

<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">vacio-arbolb?</span><span class="w"> </span><span class="n">arbol</span><span class="p">)</span>
<span class="w">   </span><span class="p">(</span><span class="nb">equal?</span><span class="w"> </span><span class="n">arbol</span><span class="w"> </span><span class="n">arbolb-vacio</span><span class="p">))</span>

<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">hoja-arbolb?</span><span class="w"> </span><span class="n">arbol</span><span class="p">)</span>
<span class="w">   </span><span class="p">(</span><span class="k">and</span><span class="w"> </span><span class="p">(</span><span class="n">vacio-arbolb?</span><span class="w"> </span><span class="p">(</span><span class="n">hijo-izq-arbolb</span><span class="w"> </span><span class="n">arbol</span><span class="p">))</span>
<span class="w">        </span><span class="p">(</span><span class="n">vacio-arbolb?</span><span class="w"> </span><span class="p">(</span><span class="n">hijo-der-arbolb</span><span class="w"> </span><span class="n">arbol</span><span class="p">))))</span>
</code></pre></div>
<p>Como parte de la barrera de abstracción definimos la constante
<code>arbolb-vacio</code>, que toma el valor de una lista vacía.</p>
<p><strong>Constructor</strong></p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">construye-arbolb</span><span class="w"> </span><span class="n">dato</span><span class="w"> </span><span class="n">hijo-izq</span><span class="w"> </span><span class="n">hijo-der</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="n">dato</span><span class="w"> </span><span class="n">hijo-izq</span><span class="w"> </span><span class="n">hijo-der</span><span class="p">))</span>
</code></pre></div>
<p>Por ejemplo, para construir un árbol con 10 en la raíz y 8 en su hijo
izquierdo y 15 en su derecho utilizando el constructor de la barrera
de abstracción:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">arbolb1</span>
<span class="w">   </span><span class="p">(</span><span class="n">construye-arbolb</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="p">(</span><span class="n">construye-arbolb</span><span class="w"> </span><span class="mi">8</span><span class="w"> </span><span class="n">arbolb-vacio</span><span class="w"> </span><span class="n">arbolb-vacio</span><span class="p">)</span>
<span class="w">                        </span><span class="p">(</span><span class="n">construye-arbolb</span><span class="w"> </span><span class="mi">15</span><span class="w"> </span><span class="n">arbolb-vacio</span><span class="w"> </span><span class="n">arbolb-vacio</span><span class="p">)))</span>
</code></pre></div>
<p>Otro ejemplo, el árbol binario de la figura anterior utilizando el
constructor de la barrera de abstracción:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">arbolb2</span>
<span class="w">   </span><span class="p">(</span><span class="n">construye-arbolb</span><span class="w"> </span><span class="mi">40</span><span class="w"> </span>
<span class="w">                 </span><span class="p">(</span><span class="n">construye-arbolb</span><span class="w"> </span><span class="mi">18</span>
<span class="w">                               </span><span class="p">(</span><span class="n">construye-arbolb</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="n">arbolb-vacio</span><span class="w"> </span><span class="n">arbolb-vacio</span><span class="p">)</span>
<span class="w">                               </span><span class="p">(</span><span class="n">construye-arbolb</span><span class="w"> </span><span class="mi">23</span><span class="w"> </span>
<span class="w">                                             </span><span class="n">arbolb-vacio</span>
<span class="w">                                             </span><span class="p">(</span><span class="n">construye-arbolb</span><span class="w"> </span><span class="mi">29</span><span class="w"> </span>
<span class="w">                                                           </span><span class="n">arbolb-vacio</span>
<span class="w">                                                           </span><span class="n">arbolb-vacio</span><span class="p">)))</span>
<span class="w">                 </span><span class="p">(</span><span class="n">construye-arbolb</span><span class="w"> </span><span class="mi">52</span>
<span class="w">                               </span><span class="p">(</span><span class="n">construye-arbolb</span><span class="w"> </span><span class="mi">47</span><span class="w"> </span><span class="n">arbolb-vacio</span><span class="w"> </span><span class="n">arbolb-vacio</span><span class="p">)</span>
<span class="w">                               </span><span class="n">arbolb-vacio</span><span class="p">)))</span>
</code></pre></div>
<h3 id="32-funciones-recursivas-sobre-arboles-binarios">3.2. Funciones recursivas sobre árboles binarios<a class="headerlink" href="#32-funciones-recursivas-sobre-arboles-binarios" title="Permanent link">&para;</a></h3>
<p>Veamos las siguientes funciones recursivas sobre árboles binarios:</p>
<ul>
<li><code>(suma-datos-arbolb arbol)</code>: devuelve la suma de todos los nodos</li>
<li><code>(to-list-arbolb arbol)</code>: devuelve una lista con los datos del árbol</li>
<li><code>(cuadrado-arbolb arbol)</code>: eleva al cuadrado todos los datos de un
  árbol manteniendo la estructura del árbol original</li>
</ul>
<p>Estas funciones utilizan una mezcla de los patrones usados en la
recursión para trabajar con árboles genéricos y la recursión para
trabajar con listas estructuradas. Tenemos un dato en la raíz, que
tenemos que combinar con lo que devuelve la recursión aplicada sobre
el hijo izquierdo y lo que devuelve la recursión aplicada sobre el
hijo derecho.</p>
<p><strong>suma-datos-arbolb</strong></p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">suma-datos-arbolb</span><span class="w"> </span><span class="n">arbol</span><span class="p">)</span>
<span class="w">   </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">vacio-arbolb?</span><span class="w"> </span><span class="n">arbol</span><span class="p">)</span>
<span class="w">      </span><span class="mi">0</span>
<span class="w">      </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="p">(</span><span class="n">dato-arbolb</span><span class="w"> </span><span class="n">arbol</span><span class="p">)</span>
<span class="w">         </span><span class="p">(</span><span class="n">suma-datos-arbolb</span><span class="w"> </span><span class="p">(</span><span class="n">hijo-izq-arbolb</span><span class="w"> </span><span class="n">arbol</span><span class="p">))</span>
<span class="w">         </span><span class="p">(</span><span class="n">suma-datos-arbolb</span><span class="w"> </span><span class="p">(</span><span class="n">hijo-der-arbolb</span><span class="w"> </span><span class="n">arbol</span><span class="p">)))))</span>

<span class="p">(</span><span class="n">suma-datos-arbolb</span><span class="w"> </span><span class="n">arbolb2</span><span class="p">)</span><span class="w"> </span><span class="c1">; ⇒ 212</span>
</code></pre></div>
<p>Como el hijo izquierdo y el hijo derecho son también árboles binarios,
podemos llamar a la recursión con esos árboles. Esas llamadas
recursivas nos devolverán la suma de los datos en cada subárbol. Y
sumamos el dato de la raíz.</p>
<p>Para definir el caso base, podemos ver que en cada llamada recursiva
vamos obteniendo el hijo izquierdo y el hijo derecho. Al final
llegaremos a un árbol vacío, en cuyo caso devolvemos 0. </p>
<p>La siguiente figura representa el funcionamiento del caso general.</p>
<p><img src="imagenes/suma-datos-binario.png" width="500px"/></p>
<p><strong>to-list-arbolb</strong></p>
<p>La función <code>to-list-arbolb</code> es similar a la vista con los árboles
genéricos. Recibe un árbol binario y devuelve una lista con los datos
en un recorrido preorden.</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">to-list-arbolb</span><span class="w"> </span><span class="n">arbol</span><span class="p">)</span>
<span class="w">   </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">vacio-arbolb?</span><span class="w"> </span><span class="n">arbol</span><span class="p">)</span>
<span class="w">      </span><span class="o">&#39;</span><span class="p">()</span>
<span class="w">      </span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="p">(</span><span class="n">dato-arbolb</span><span class="w"> </span><span class="n">arbol</span><span class="p">)</span>
<span class="w">            </span><span class="p">(</span><span class="nb">append</span><span class="w"> </span><span class="p">(</span><span class="n">to-list-arbolb</span><span class="w"> </span><span class="p">(</span><span class="n">hijo-izq-arbolb</span><span class="w"> </span><span class="n">arbol</span><span class="p">))</span>
<span class="w">                    </span><span class="p">(</span><span class="n">to-list-arbolb</span><span class="w"> </span><span class="p">(</span><span class="n">hijo-der-arbolb</span><span class="w"> </span><span class="n">arbol</span><span class="p">))))))</span>

<span class="p">(</span><span class="n">to-list-arbolb</span><span class="w"> </span><span class="n">arbolb2</span><span class="p">)</span><span class="w"> </span><span class="c1">; ⇒ (40 18 3 23 29 52 47)</span>
</code></pre></div>
<p>El funcionamiento es similar a la suma: llamamos a la recursión por la
izquierda y por la derecha. El resultado de las llamadas recursivas
serán dos listas que tenemos que concatenar con <code>append</code>. Y por
últimos añadimos en cabeza el dato de la raíz con <code>cons</code>.</p>
<p><strong>cuadrado-arbolb</strong></p>
<p>Por último, la función <code>cuadrado-arbolb</code> construye un nuevo árbol
binario elevando al cuadrado el dato de la raíz, su hijo izquierdo y
su hijo derecho. Para construir el árbol binario llamamos al
constructor <code>construye-arbolb</code>.</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">cuadrado-arbolb</span><span class="w"> </span><span class="n">arbol</span><span class="p">)</span>
<span class="w">   </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">vacio-arbolb?</span><span class="w"> </span><span class="n">arbol</span><span class="p">)</span>
<span class="w">      </span><span class="n">arbolb-vacio</span>
<span class="w">      </span><span class="p">(</span><span class="n">construye-arbolb</span><span class="w"> </span><span class="p">(</span><span class="n">cuadrado</span><span class="w"> </span><span class="p">(</span><span class="n">dato-arbolb</span><span class="w"> </span><span class="n">arbol</span><span class="p">))</span>
<span class="w">                        </span><span class="p">(</span><span class="n">cuadrado-arbolb</span><span class="w"> </span><span class="p">(</span><span class="n">hijo-izq-arbolb</span><span class="w"> </span><span class="n">arbol</span><span class="p">))</span>
<span class="w">                        </span><span class="p">(</span><span class="n">cuadrado-arbolb</span><span class="w"> </span><span class="p">(</span><span class="n">hijo-der-arbolb</span><span class="w"> </span><span class="n">arbol</span><span class="p">)))))</span>

<span class="p">(</span><span class="n">cuadrado-arbolb</span><span class="w"> </span><span class="n">arbolb1</span><span class="p">)</span><span class="w"> </span><span class="c1">; ⇒ (100 (64 () ()) (225 () ()))</span>
</code></pre></div>
<h2 id="4-bibliografia-sicp">4. Bibliografía - SICP<a class="headerlink" href="#4-bibliografia-sicp" title="Permanent link">&para;</a></h2>
<p>En este tema explicamos conceptos de los siguientes capítulos del libro <em>Structure and Intepretation of Computer Programs</em>:</p>
<ul>
<li><a href="https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book-Z-H-15.html#%_sec_2.2.2">2.2.2 - Hierarchical Structures</a></li>
</ul>
<hr />
<p>Lenguajes y Paradigmas de Programación, curso 2024-25<br />
© Departamento Ciencia de la Computación e Inteligencia Artificial, Universidad de Alicante<br />
Domingo Gallardo, Cristina Pomares, Antonio Botía, Francisco Martínez</p>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "../..", "features": ["content.code.copy"], "search": "../../assets/javascripts/workers/search.07f07601.min.js", "translations": {"clipboard.copied": "Copiado al portapapeles", "clipboard.copy": "Copiar al portapapeles", "search.result.more.one": "1 m\u00e1s en esta p\u00e1gina", "search.result.more.other": "# m\u00e1s en esta p\u00e1gina", "search.result.none": "No se encontraron documentos", "search.result.one": "1 documento encontrado", "search.result.other": "# documentos encontrados", "search.result.placeholder": "Teclee para comenzar b\u00fasqueda", "search.result.term.missing": "Falta", "select.version": "Seleccionar versi\u00f3n"}}</script>
    
    
      <script src="../../assets/javascripts/bundle.56dfad97.min.js"></script>
      
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML"></script>
      
    
  </body>
</html>