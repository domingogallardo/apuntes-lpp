



<!doctype html>
<html lang="es" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      <meta http-equiv="x-ua-compatible" content="ie=edge">
      
      
      
      
        <meta name="lang:clipboard.copy" content="Copiar al portapapeles">
      
        <meta name="lang:clipboard.copied" content="Copiado al portapapeles">
      
        <meta name="lang:search.language" content="en">
      
        <meta name="lang:search.pipeline.stopwords" content="True">
      
        <meta name="lang:search.pipeline.trimmer" content="True">
      
        <meta name="lang:search.result.none" content="No se encontraron documentos">
      
        <meta name="lang:search.result.one" content="1 documento encontrado">
      
        <meta name="lang:search.result.other" content="# documentos encontrados">
      
        <meta name="lang:search.tokenizer" content="[\s\-]+">
      
      <link rel="shortcut icon" href="../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.1, mkdocs-material-4.6.3">
    
    
      
        <title>Tema 4: Estructuras recursivas - LPP</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/application.adb8469c.css">
      
        <link rel="stylesheet" href="../../assets/stylesheets/application-palette.a8b3c06d.css">
      
      
        
        
        <meta name="theme-color" content="#009688">
      
    
    
      <script src="../../assets/javascripts/modernizr.86422ebf.js"></script>
    
    
      
        <link href="https://fonts.gstatic.com" rel="preconnect" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700%7CRoboto+Mono&display=fallback">
        <style>body,input{font-family:"Roboto","Helvetica Neue",Helvetica,Arial,sans-serif}code,kbd,pre{font-family:"Roboto Mono","Courier New",Courier,monospace}</style>
      
    
    <link rel="stylesheet" href="../../assets/fonts/material-icons.css">
    
    
    
      
    
    
  </head>
  
    
    
    <body dir="ltr" data-md-color-primary="teal" data-md-color-accent="teal">
  
    <svg class="md-svg">
      <defs>
        
        
      </defs>
    </svg>
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" data-md-component="overlay" for="__drawer"></label>
    
      <a href="#tema-4-estructuras-de-datos-recursivas" tabindex="0" class="md-skip">
        Saltar a contenido
      </a>
    
    
      <header class="md-header" data-md-component="header">
  <nav class="md-header-nav md-grid">
    <div class="md-flex">
      <div class="md-flex__cell md-flex__cell--shrink">
        <a href="../.." title="LPP" aria-label="LPP" class="md-header-nav__button md-logo">
          
            <img alt="logo" src="../../imagenes/logo.png" width="24" height="24">
          
        </a>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        <label class="md-icon md-icon--menu md-header-nav__button" for="__drawer"></label>
      </div>
      <div class="md-flex__cell md-flex__cell--stretch">
        <div class="md-flex__ellipsis md-header-nav__title" data-md-component="title">
          
            <span class="md-header-nav__topic">
              LPP
            </span>
            <span class="md-header-nav__topic">
              
                Tema 4: Estructuras recursivas
              
            </span>
          
        </div>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        
          <label class="md-icon md-icon--search md-header-nav__button" for="__search"></label>
          
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" aria-label="search" name="query" placeholder="Búsqueda" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="query" data-md-state="active">
      <label class="md-icon md-search__icon" for="__search"></label>
      <button type="reset" class="md-icon md-search__icon" data-md-component="reset" tabindex="-1">
        &#xE5CD;
      </button>
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="result">
          <div class="md-search-result__meta">
            Teclee para comenzar búsqueda
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
        
      </div>
      
    </div>
  </nav>
</header>
    
    <div class="md-container">
      
        
      
      
      <main class="md-main" role="main">
        <div class="md-main__inner md-grid" data-md-component="container">
          
            
              <div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    <nav class="md-nav md-nav--primary" data-md-level="0">
  <label class="md-nav__title md-nav__title--site" for="__drawer">
    <a href="../.." title="LPP" class="md-nav__button md-logo">
      
        <img alt="logo" src="../../imagenes/logo.png" width="48" height="48">
      
    </a>
    LPP
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      

  


  <li class="md-nav__item md-nav__item--active md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-1" type="checkbox" id="nav-1" checked>
    
    <label class="md-nav__link" for="nav-1">
      Teoría
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-1">
        Teoría
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../tema00-descripcion-asignatura/tema00-descripcion-asignatura.html" title="Descripción de la asignatura" class="md-nav__link">
      Descripción de la asignatura
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../tema01-historia-lenguajes-programacion/tema01-historia-lenguajes-programacion.html" title="Tema 1: Historia de los lenguajes de programación" class="md-nav__link">
      Tema 1: Historia de los lenguajes de programación
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../tema02-programacion-funcional/tema02-programacion-funcional.html" title="Tema 2: Programación funcional" class="md-nav__link">
      Tema 2: Programación funcional
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../tema03-procedimientos-recursivos/tema03-procedimientos-recursivos.html" title="Tema 3: Procedimientos recursivos" class="md-nav__link">
      Tema 3: Procedimientos recursivos
    </a>
  </li>

        
          
          
          

  


  <li class="md-nav__item md-nav__item--active">
    
    <input class="md-toggle md-nav__toggle" data-md-toggle="toc" type="checkbox" id="__toc">
    
      
    
    
      <label class="md-nav__link md-nav__link--active" for="__toc">
        Tema 4: Estructuras recursivas
      </label>
    
    <a href="tema04-estructuras-recursivas.html" title="Tema 4: Estructuras recursivas" class="md-nav__link md-nav__link--active">
      Tema 4: Estructuras recursivas
    </a>
    
      
<nav class="md-nav md-nav--secondary">
  
  
    
  
  
    <label class="md-nav__title" for="__toc">Tabla de contenidos</label>
    <ul class="md-nav__list" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#listas-estructuradas" class="md-nav__link">
    Listas estructuradas
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#definicion-y-ejemplos" class="md-nav__link">
    Definición y ejemplos
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#funciones-recursivas-sobre-listas-estructuradas" class="md-nav__link">
    Funciones recursivas sobre listas estructuradas
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#bibliografia-sicp" class="md-nav__link">
    Bibliografía - SICP
  </a>
  
</li>
      
      
      
      
      
    </ul>
  
</nav>
    
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-2" type="checkbox" id="nav-2">
    
    <label class="md-nav__link" for="nav-2">
      Seminarios
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-2">
        Seminarios
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../seminarios/seminario1-scheme/seminario1-scheme.html" title="Seminario de Scheme" class="md-nav__link">
      Seminario de Scheme
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-3" type="checkbox" id="nav-3">
    
    <label class="md-nav__link" for="nav-3">
      Prácticas
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-3">
        Prácticas
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../practicas/practica01/practica01.html" title="Práctica 1" class="md-nav__link">
      Práctica 1
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../practicas/practica02/practica02.html" title="Práctica 2" class="md-nav__link">
      Práctica 2
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../practicas/practica03/practica03.html" title="Práctica 3" class="md-nav__link">
      Práctica 3
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../practicas/practica04/practica04.html" title="Práctica 4" class="md-nav__link">
      Práctica 4
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../practicas/practica05/practica05.html" title="Práctica 5" class="md-nav__link">
      Práctica 5
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              <div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    
<nav class="md-nav md-nav--secondary">
  
  
    
  
  
    <label class="md-nav__title" for="__toc">Tabla de contenidos</label>
    <ul class="md-nav__list" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#listas-estructuradas" class="md-nav__link">
    Listas estructuradas
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#definicion-y-ejemplos" class="md-nav__link">
    Definición y ejemplos
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#funciones-recursivas-sobre-listas-estructuradas" class="md-nav__link">
    Funciones recursivas sobre listas estructuradas
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#bibliografia-sicp" class="md-nav__link">
    Bibliografía - SICP
  </a>
  
</li>
      
      
      
      
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content">
            <article class="md-content__inner md-typeset">
              
                
                
                <h1 id="tema-4-estructuras-de-datos-recursivas">Tema 4: Estructuras de datos recursivas<a class="headerlink" href="#tema-4-estructuras-de-datos-recursivas" title="Permanent link">&para;</a></h1>
<h2 id="listas-estructuradas">Listas estructuradas<a class="headerlink" href="#listas-estructuradas" title="Permanent link">&para;</a></h2>
<p>Hemos visto que las listas en Scheme se implementan como un estructura
de datos recursiva, formada por una pareja que enlaza en su parte
derecha el resto de la lista y que termina con una parte derecha en la
que hay una lista vacía.</p>
<p>En este apartado vamos a volver a estudiar las listas desde un nivel
de abstracción alto, usando las funciones:</p>
<ul>
<li><code>(car lista)</code> para obtener el primer elemento de una lista</li>
<li><code>(cdr lista)</code> para obtener el resto de la lista</li>
<li><code>(cons dato lista)</code> para construir una nueva lista con el dato como
  primer elemento</li>
</ul>
<p>En la mayoría de funciones y ejemplos que hemos visto hasta ahora las
listas están formadas por datos y el recorrido por la lista es un
recorrido lineal, iterando por sus elementos.</p>
<p>En este apartado vamos a ampliar este concepto y estudiar cómo
trabajar con <em>listas que contienen otras listas</em>.</p>
<p>Veremos que esto cambia fundamentalmente la estructura de las listas y
de las funciones que van a operar con ellas. El cambio fundamental es
que la función <code>car lista</code> puede devolver dos tipos de elementos: </p>
<ul>
<li>Un elemento de la lista (del tipo de elementos que hay en la lista)</li>
<li>Otra lista (formada por el tipo de elementos de la lista)</li>
</ul>
<h3 id="definicion-y-ejemplos">Definición y ejemplos<a class="headerlink" href="#definicion-y-ejemplos" title="Permanent link">&para;</a></h3>
<p>Las listas en Scheme pueden tener cualquier tipo de elementos,
incluido otras listas.</p>
<p>Llamaremos <strong>lista estructurada</strong> a una lista que contiene otras
sublistas. Lo contrario de lista estructurada es una <strong>lista plana</strong>,
una lista formada por elementos que no son listas. Llamaremos
<strong>hojas</strong> a los elementos de una lista que no son sublistas.</p>
<p>A las listas estructuradas cuyas hojas son símbolos se les denomina en
el contexto de la programación funcional <em>expresiones-S</em>
(<a href="http://en.wikipedia.org/wiki/S-expression">S-expression</a>).</p>
<p>Por ejemplo, la lista estructurada:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><code><span class="err">(a b (c d e) (f (g h)))</span>
</code></pre></div>
</td></tr></table>

<p>es una lista estructurada con 4 elementos:</p>
<ul>
<li>El elemento <code>'a</code>, una hoja</li>
<li>El elemento <code>'b</code>, otra hoja</li>
<li>La lista plana <code>(c d e)</code></li>
<li>La lista estructurada <code>(f (g h))</code></li>
</ul>
<p>Se puede construir con cualquiera de las siguientes expresiones:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><code><span class="p">(</span><span class="k">define</span> <span class="n">lista</span> <span class="p">(</span><span class="nb">list</span> <span class="o">&#39;</span><span class="ss">a</span> <span class="o">&#39;</span><span class="ss">b</span> <span class="p">(</span><span class="nb">list</span> <span class="o">&#39;</span><span class="ss">c</span> <span class="o">&#39;</span><span class="ss">d</span> <span class="o">&#39;</span><span class="ss">e</span><span class="p">)</span> <span class="p">(</span><span class="nb">list</span> <span class="o">&#39;</span><span class="ss">f</span> <span class="p">(</span><span class="nb">list</span> <span class="o">&#39;</span><span class="ss">g</span> <span class="o">&#39;</span><span class="ss">h</span><span class="p">))))</span>
<span class="p">(</span><span class="k">define</span> <span class="n">lista</span> <span class="o">&#39;</span><span class="p">(</span><span class="ss">a</span> <span class="ss">b</span> <span class="p">(</span><span class="ss">c</span> <span class="ss">d</span> <span class="ss">e</span><span class="p">)</span> <span class="p">(</span><span class="ss">f</span> <span class="p">(</span><span class="ss">g</span> <span class="ss">h</span><span class="p">))))</span>
</code></pre></div>
</td></tr></table>

<p>Una lista formada por parejas la consideraremos una lista plana, ya
que no contiene ninguna sublista. Por ejemplo, la lista</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><code><span class="p">((</span><span class="n">a</span> <span class="o">.</span> <span class="mi">3</span><span class="p">)</span> <span class="p">(</span><span class="n">b</span> <span class="o">.</span> <span class="mi">5</span><span class="p">)</span> <span class="p">(</span><span class="n">c</span> <span class="o">.</span> <span class="mi">12</span><span class="p">))</span>
</code></pre></div>
</td></tr></table>

<p>es una lista plana de tres elementos (hojas) que son parejas.</p>
<h4>Definiciones en Scheme</h4>
<p>Vamos a escribir las definiciones anteriores de <code>hoja</code>, <code>plana</code> y
<code>estructurada</code> usando código de Scheme.</p>
<h5>Función <code>(hoja? dato)</code></h5>
<p>Definimos una hoja como aquellos elementos de una lista estructurada
que no son listas:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><code><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="n">hoja?</span> <span class="n">elem</span><span class="p">)</span>
   <span class="p">(</span><span class="nb">not</span> <span class="p">(</span><span class="nb">list?</span> <span class="n">elem</span><span class="p">)))</span>
</code></pre></div>
</td></tr></table>

<p>Utilizaremos esta función para comprobar si un determinado elemento de
una lista es o no una hoja. Por ejemplo, supongamos la siguiente
lista:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><code><span class="p">((</span><span class="mi">1</span> <span class="mi">2</span><span class="p">)</span> <span class="mi">3</span> <span class="mi">4</span> <span class="p">(</span><span class="mi">5</span> <span class="mi">6</span><span class="p">))</span>
</code></pre></div>
</td></tr></table>

<p>Es una lista de 4 elementos, siendo el primero y el último otras
sublistas y el segundo y el tercero hojas. Podemos comprobar si son o
no hojas sus elementos:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><code><span class="p">(</span><span class="k">define</span> <span class="n">lista</span> <span class="o">&#39;</span><span class="p">((</span><span class="mi">1</span> <span class="mi">2</span><span class="p">)</span> <span class="mi">3</span> <span class="mi">4</span> <span class="p">(</span><span class="mi">5</span> <span class="mi">6</span><span class="p">)))</span>
<span class="p">(</span><span class="n">hoja?</span> <span class="p">(</span><span class="nb">car</span> <span class="n">lista</span><span class="p">))</span> <span class="c1">; ⇒ #f</span>
<span class="p">(</span><span class="n">hoja?</span> <span class="p">(</span><span class="nb">cadr</span> <span class="n">lista</span><span class="p">))</span> <span class="c1">; ⇒ #t</span>
<span class="p">(</span><span class="n">hoja?</span> <span class="p">(</span><span class="nb">caddr</span> <span class="n">lista</span><span class="p">))</span> <span class="c1">; ⇒ #t</span>
<span class="p">(</span><span class="n">hoja?</span> <span class="p">(</span><span class="nb">cadddr</span> <span class="n">lista</span><span class="p">))</span> <span class="c1">; ⇒ #f</span>
</code></pre></div>
</td></tr></table>

<p>La lista vacía no es una hoja</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><code><span class="p">(</span><span class="n">hoja?</span> <span class="o">&#39;</span><span class="p">())</span> <span class="c1">; ⇒ #f</span>
</code></pre></div>
</td></tr></table>

<h5>Función <code>(plana? lista)</code></h5>
<p>Una definición recursiva de lista plana:</p>
<blockquote>
<p>Una lista es plana si y solo si el primer elemento es una hoja y el
resto es plana.</p>
</blockquote>
<p>Y el caso base:</p>
<blockquote>
<p>Una lista vacía es plana.</p>
</blockquote>
<p>Usando esta definición recursiva, podemos implementar en Scheme la
función <code>(plana? lista)</code> que comprueba si una lista es plana:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><code><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="n">plana?</span> <span class="n">lista</span><span class="p">)</span>
   <span class="p">(</span><span class="k">or</span> <span class="p">(</span><span class="nb">null?</span> <span class="n">lista</span><span class="p">)</span>
       <span class="p">(</span><span class="k">and</span> <span class="p">(</span><span class="n">hoja?</span> <span class="p">(</span><span class="nb">car</span> <span class="n">lista</span><span class="p">))</span>
            <span class="p">(</span><span class="n">plana?</span> <span class="p">(</span><span class="nb">cdr</span> <span class="n">lista</span><span class="p">)))))</span>
</code></pre></div>
</td></tr></table>

<p>Ejemplos:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><code><span class="p">(</span><span class="n">plana?</span> <span class="o">&#39;</span><span class="p">(</span><span class="ss">a</span> <span class="ss">b</span> <span class="ss">c</span> <span class="ss">d</span> <span class="ss">e</span> <span class="ss">f</span><span class="p">))</span> <span class="c1">; ⇒ #t</span>
<span class="p">(</span><span class="n">plana?</span> <span class="p">(</span><span class="nb">list</span> <span class="p">(</span><span class="nb">cons</span> <span class="o">&#39;</span><span class="ss">a</span> <span class="mi">1</span><span class="p">)</span> <span class="s2">&quot;Hola&quot;</span> <span class="no">#f</span><span class="p">))</span> <span class="c1">; ⇒ #t</span>
<span class="p">(</span><span class="n">plana?</span> <span class="o">&#39;</span><span class="p">(</span><span class="ss">a</span> <span class="p">(</span><span class="ss">b</span> <span class="ss">c</span><span class="p">)</span> <span class="ss">d</span><span class="p">))</span> <span class="c1">; ⇒ #f</span>
<span class="p">(</span><span class="n">plana?</span> <span class="o">&#39;</span><span class="p">(</span><span class="ss">a</span> <span class="p">()</span> <span class="ss">b</span><span class="p">))</span> <span class="c1">; ⇒ #f</span>
</code></pre></div>
</td></tr></table>

<p>Se podría también implementar la función <code>plana?</code> usando la función de
orden superior <code>for-all?</code> que comprueba que todos los elementos de una
lista cumplen una propiedad. En esta caso, ser hoja.</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><code><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="n">plana-fos?</span> <span class="n">lista</span><span class="p">)</span>
  <span class="p">(</span><span class="n">for-all?</span> <span class="n">hoja?</span> <span class="n">lista</span><span class="p">))</span>
</code></pre></div>
</td></tr></table>

<div class="admonition note">
<p class="admonition-title">Función <code>for-all?</code></p>
<p>Recordemos que la función <code>(for-all? predicado lista)</code> se implementa
de la siguiente forma:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><code><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="n">for-all?</span> <span class="n">predicado</span> <span class="n">lista</span><span class="p">)</span>
  <span class="p">(</span><span class="k">or</span> <span class="p">(</span><span class="nb">null?</span> <span class="n">lista</span><span class="p">)</span>
      <span class="p">(</span><span class="k">and</span> <span class="p">(</span><span class="n">predicado</span> <span class="p">(</span><span class="nb">car</span> <span class="n">lista</span><span class="p">))</span>
           <span class="p">(</span><span class="n">for-all?</span> <span class="n">predicado</span> <span class="p">(</span><span class="nb">cdr</span> <span class="n">lista</span><span class="p">)))))</span>
</code></pre></div>
</td></tr></table>

</div>
<h5>Función <code>(estructurada? lista)</code></h5>
<p>Una lista es estructurada cuando alguno de sus elementos es otra
lista. Como caso base, una lista vacía no es estructurada.</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><code><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="n">estructurada?</span> <span class="n">lista</span><span class="p">)</span>
   <span class="p">(</span><span class="k">and</span> <span class="p">(</span><span class="nb">not</span> <span class="p">(</span><span class="nb">null?</span> <span class="n">lista</span><span class="p">))</span>
        <span class="p">(</span><span class="k">or</span> <span class="p">(</span><span class="nb">list?</span> <span class="p">(</span><span class="nb">car</span> <span class="n">lista</span><span class="p">))</span>
            <span class="p">(</span><span class="n">estructurada?</span> <span class="p">(</span><span class="nb">cdr</span> <span class="n">lista</span><span class="p">)))))</span>
</code></pre></div>
</td></tr></table>

<p>Ejemplos:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><code><span class="p">(</span><span class="n">estructurada?</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">))</span> <span class="c1">; ⇒ #f</span>
<span class="p">(</span><span class="n">estructurada?</span> <span class="p">(</span><span class="nb">list</span> <span class="p">(</span><span class="nb">cons</span> <span class="o">&#39;</span><span class="ss">a</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nb">cons</span> <span class="o">&#39;</span><span class="ss">b</span> <span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="nb">cons</span> <span class="o">&#39;</span><span class="ss">c</span> <span class="mi">3</span><span class="p">)))</span> <span class="c1">; ⇒ #f</span>
<span class="p">(</span><span class="n">estructurada?</span> <span class="o">&#39;</span><span class="p">(</span><span class="ss">a</span> <span class="p">()</span> <span class="ss">b</span><span class="p">))</span> <span class="c1">; ⇒ #t</span>
<span class="p">(</span><span class="n">estructurada?</span> <span class="o">&#39;</span><span class="p">(</span><span class="ss">a</span> <span class="p">(</span><span class="ss">b</span> <span class="ss">c</span><span class="p">)</span> <span class="ss">d</span><span class="p">))</span> <span class="c1">; ⇒ #t</span>
</code></pre></div>
</td></tr></table>

<p>Se podría implementar también usando la función de orden superior
<code>exists?</code> para consultar si algún elemento de la lista es también otra
lista.</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><code><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="n">estructurada-fos?</span> <span class="n">lista</span><span class="p">)</span>
  <span class="p">(</span><span class="n">exists?</span> <span class="nb">list?</span> <span class="n">lista</span><span class="p">))</span>
</code></pre></div>
</td></tr></table>

<div class="admonition note">
<p class="admonition-title">Función <code>exists?</code></p>
<p>Recordemos que la función <code>(exists? predicado lista)</code> se implementa de
la siguiente forma:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><code><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="n">exists?</span> <span class="n">predicado</span> <span class="n">lista</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">null?</span> <span class="n">lista</span><span class="p">)</span>
      <span class="no">#f</span>
      <span class="p">(</span><span class="k">or</span> <span class="p">(</span><span class="n">predicado</span> <span class="p">(</span><span class="nb">car</span> <span class="n">lista</span><span class="p">))</span>
          <span class="p">(</span><span class="n">exists?</span> <span class="n">predicado</span> <span class="p">(</span><span class="nb">cdr</span> <span class="n">lista</span><span class="p">)))))</span>
</code></pre></div>
</td></tr></table>

</div>
<p>Realmente bastaría con haber hecho una de las dos definiciones y
escribir la otra como la negación de la primera:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><code><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="n">estructurada?</span> <span class="n">lista</span><span class="p">)</span>
   <span class="p">(</span><span class="nb">not</span> <span class="p">(</span><span class="n">plana?</span> <span class="n">lista</span><span class="p">)))</span>
</code></pre></div>
</td></tr></table>

<h4>Ejemplos de listas estructuradas</h4>
<p>Las listas estructuradas son muy útiles para representar información
jerárquica en donde queremos representar elementos que contienen otros
elementos.</p>
<p>Por ejemplo, las expresiones de Scheme son listas estructuradas:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><code><span class="p">(</span><span class="nb">=</span> <span class="mi">4</span> <span class="p">(</span><span class="nb">+</span> <span class="mi">2</span> <span class="mi">2</span><span class="p">))</span>
<span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">=</span> <span class="n">x</span> <span class="n">y</span><span class="p">)</span> <span class="p">(</span><span class="nb">*</span> <span class="n">x</span> <span class="n">y</span><span class="p">)</span> <span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="nb">/</span> <span class="n">x</span> <span class="n">y</span><span class="p">)</span> <span class="mi">45</span><span class="p">))</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="n">factorial</span> <span class="n">x</span><span class="p">)</span> <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">=</span> <span class="n">x</span> <span class="mi">0</span><span class="p">)</span> <span class="mi">1</span> <span class="p">(</span><span class="nb">*</span> <span class="n">x</span> <span class="p">(</span><span class="n">factorial</span> <span class="p">(</span><span class="nb">-</span> <span class="n">x</span> <span class="mi">1</span><span class="p">)))))</span>
</code></pre></div>
</td></tr></table>

<p>El análisis sintáctico de una oración puede generar una lista
estructurada de símbolos, en donde se agrupan los distintos elementos
de la oración:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><code><span class="p">((</span><span class="n">Juan</span><span class="p">)</span> <span class="p">(</span><span class="n">compró</span><span class="p">)</span> <span class="p">(</span><span class="n">la</span> <span class="n">entrada</span> <span class="p">(</span><span class="n">de</span> <span class="n">la</span> <span class="n">película</span><span class="p">))</span> <span class="p">(</span><span class="n">el</span> <span class="n">viernes</span> <span class="n">por</span> <span class="n">la</span> <span class="n">tarde</span><span class="p">))</span>
</code></pre></div>
</td></tr></table>

<p>Una página HTML, con sus distintos elementos, unos dentro de otros,
también se puede representar con una lista estructurada:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><code><span class="p">((</span><span class="n">&lt;h1&gt;</span> <span class="n">Mi</span> <span class="n">lista</span> <span class="n">de</span> <span class="n">la</span> <span class="n">compra</span> <span class="n">&lt;/h1&gt;</span><span class="p">)</span>
 <span class="p">(</span><span class="n">&lt;ul&gt;</span> <span class="p">(</span><span class="n">&lt;li&gt;</span> <span class="n">naranjas</span> <span class="n">&lt;/li&gt;</span><span class="p">)</span>
       <span class="p">(</span><span class="n">&lt;li&gt;</span> <span class="n">tomates</span> <span class="n">&lt;/li&gt;</span><span class="p">)</span>
       <span class="p">(</span><span class="n">&lt;li&gt;</span> <span class="n">huevos</span> <span class="n">&lt;/li&gt;</span><span class="p">)</span> <span class="n">&lt;/ul&gt;</span><span class="p">))</span>
</code></pre></div>
</td></tr></table>

<h4><em>Pseudo árboles</em> con niveles</h4>
<p>Las listas estructuradas definen una estructura de niveles, donde la
lista inicial representa el primer nivel, y cada sublista representa
un nivel inferior. Los datos de las listas representan las hojas.</p>
<p>Por ejemplo, la representación en forma de niveles de la lista <code>((a b
c) d e)</code> es la siguiente:</p>
<p><img src="imagenes/expresion-e-1.png" width="400px"/></p>
<p>Cada asterisco <code>*</code> representa una lista. Las ramas que salen del
asterisco representan los elementos de la lista. En el ejemplo tenemos
en un primer nivel una lista con 3 elementos: la lista <code>(a b c)</code>, <code>d</code>
y <code>e</code>. Y en el segundo nivel se encuentra la lista <code>(a b c)</code> cuyos 3
elementos son hojas.</p>
<p>Las hojas <code>d</code> y <code>e</code> están en el nivel 1 y en las posiciones
2 y 3 de la lista y las hojas <code>a</code>, <code>b</code> y <code>c</code> en el nivel 2.</p>
<div class="admonition warning">
<p class="admonition-title">Una lista estructurada no es un árbol</p>
<p>Una lista estructurada no es un árbol propiamente dicho, porque
un árbol tiene datos en todos los nodos, mientras que en la lista 
estructurada los datos están sólo en las hojas.</p>
</div>
<p>Las listas estructuradas sirven para agrupar de forma jerárquica
un conjunto de datos en distintos niveles. </p>
<p>A pesar de ser distintas de los árboles, ambas son estructuras de
datos jerárquicas (con niveles) que se pueden definir de forma
recursiva y sobre las que se pueden definir algoritmos
recursivos. Veremos más adelante cómo definir y trabajar con árboles
en Scheme.</p>
<p>Otro ejemplo. ¿Cuál sería la representación en niveles de la siguiente
lista estructurada?:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><code><span class="p">(</span><span class="nb">map</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">+</span> <span class="n">x</span> <span class="mi">10</span><span class="p">))</span> <span class="p">(</span><span class="k">quote</span> <span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">)))</span>
</code></pre></div>
</td></tr></table>

<p><img src="imagenes/expresion-e-2.png" width="500px"/></p>
<h3 id="funciones-recursivas-sobre-listas-estructuradas">Funciones recursivas sobre listas estructuradas<a class="headerlink" href="#funciones-recursivas-sobre-listas-estructuradas" title="Permanent link">&para;</a></h3>
<h4>Número de hojas</h4>
<p>Veamos como primer ejemplo la función <code>(num-hojas lista)</code> que cuenta
el número de hojas de una lista estructurada.</p>
<p>Por ejemplo:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><code><span class="p">(</span><span class="n">num-hojas</span> <span class="o">&#39;</span><span class="p">((</span><span class="mi">1</span> <span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="mi">3</span> <span class="mi">4</span> <span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="mi">6</span><span class="p">)</span> <span class="p">(</span><span class="mi">7</span><span class="p">)))</span> <span class="c1">; ⇒ 7</span>
</code></pre></div>
</td></tr></table>

<p>Como hemos comentado antes, una cuestión clave en las funciones que
vamos a construir sobre listas estructuradas es que el <code>car</code> de una
lista estructurada puede ser a su vez otra lista.</p>
<p>Para calcular el número de hojas de una lista podemos obtener el
primer elemento y el resto de la lista, y contar recursivamente el
número de hojas del primer elemento y del resto. Al ser una lista
estructurada, el primer elemento puede ser a su vez otra lista, por lo
que llamamos a la recursión para contar sus hojas.</p>
<p>La definición de este caso general usando <em>pseudocódigo</em> es:</p>
<blockquote>
<p>El número de hojas de una lista estructurada es la suma del número
de hojas de su primer elemento (que puede ser otra lista) y del
número de hojas del resto.</p>
</blockquote>
<p><img src="imagenes/num-hojas-estructurada.png" width="400px"/></p>
<p>La recursión tiene dos llamadas recursivas. Una que recibe el
elemento de la cabeza de la lista y otra que recibe el resto de la
lista. </p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><code><span class="c1">;Caso general num-hojas</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="n">num-hojas</span> <span class="n">lista</span><span class="p">)</span>
  <span class="c1">; Falta caso base</span>
  <span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="n">num-hojas</span> <span class="p">(</span><span class="nb">car</span> <span class="n">lista</span><span class="p">))</span>
     <span class="p">(</span><span class="n">num-hojas</span> <span class="p">(</span><span class="nb">cdr</span> <span class="n">lista</span><span class="p">))))</span>
</code></pre></div>
</td></tr></table>

<div class="admonition warning">
<p class="admonition-title">No hay coste exponencial</p>
<p>A pesar de haber dos llamadas recursivas, no pasa lo mismo que en
Fibonacci o Pascal ya que no se van a repetir llamadas a la recursión
con los mismos datos. La recursión recorre la lista estructurada y su
coste será el número de elementos de la lista.</p>
</div>
<p>Para considerar el <strong>caso base</strong>, veamos cómo las llamadas recursivas
reciben cada vez un problema más pequeño. </p>
<p>La llamada recursiva sobre el resto de la lista recibe cada vez una
lista con 1 elemento menos. Al final se llamará a la función con una
lista vacía. Ese será un caso base. El número de elementos de una
lista vacía es 0.</p>
<p>La llamada recursiva sobre la cabeza de la lista es algo
distinta. Recibe una lista en la que se ha descendido un nivel y
tiene, por tanto, un nivel menos. Al final se llamará a la función con
una hoja (un dato). Ese será el otro caso base y habrá que devolver 1.</p>
<p>La definición completa de la función queda de la siguiente forma:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><code><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="n">num-hojas</span> <span class="n">elem</span><span class="p">)</span>
   <span class="p">(</span><span class="k">cond</span>
      <span class="p">((</span><span class="nb">null?</span> <span class="n">elem</span><span class="p">)</span> <span class="mi">0</span><span class="p">)</span>
      <span class="p">((</span><span class="n">hoja?</span> <span class="n">elem</span><span class="p">)</span> <span class="mi">1</span><span class="p">)</span>
      <span class="p">(</span><span class="k">else</span> <span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="n">num-hojas</span> <span class="p">(</span><span class="nb">car</span> <span class="n">elem</span><span class="p">))</span>
               <span class="p">(</span><span class="n">num-hojas</span> <span class="p">(</span><span class="nb">cdr</span> <span class="n">elem</span><span class="p">))))))</span>
</code></pre></div>
</td></tr></table>

<p>Hay que hacer notar que el parámetro <code>elem</code> puede ser tanto una lista
como un dato atómico (una hoja). Estamos aprovechándonos de la
característica de Scheme de ser débilmente tipado para hacer un
código bastante conciso.</p>
<h5>Versión con funciones de orden superior</h5>
<p>Podemos usar también las funciones de orden superior <code>map</code> y
<code>foldr</code> para obtener una versión más concisa.</p>
<p>Una lista estructurada tiene como elementos en un primer nivel hojas o
otras sublistas. Podemos entonces mapear una expresión lambda que se
aplica a cada uno de esos elementos. En la expresión lambda
comprobamos si el elemento (el parámetro <code>sublista</code> de la expresión
lambda) es una hoja o una lista. En el primero caso devolvemos 1. En
el segundo aplicaremos <em>la propia función que estamos definiendo</em>
sobre la sublista, con lo que se devolverá el número de hojas de esa
sublista.</p>
<p>El resultado del map será una lista de números (el número de hojas de
cada componente), que podemos sumar haciendo un <code>fold-right</code> con la
función <code>+</code>:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><code><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="n">num-hojas-fos</span> <span class="n">lista</span><span class="p">)</span>
    <span class="p">(</span><span class="n">fold-right</span> <span class="nb">+</span> <span class="mi">0</span> <span class="p">(</span><span class="nb">map</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="n">elem</span><span class="p">)</span>
                           <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="n">hoja?</span> <span class="n">elem</span><span class="p">)</span>
                               <span class="mi">1</span>
                               <span class="p">(</span><span class="n">num-hojas-fos</span> <span class="n">elem</span><span class="p">)))</span> <span class="n">lista</span><span class="p">)))</span>
</code></pre></div>
</td></tr></table>

<p>Una explicación gráfica de cómo funciona la función sobre la lista <code>(1
(2 3) (4) (5 (6 7) 8))</code>:</p>
<p><img src="imagenes/map-lista.png" width="700px"/></p>
<h4>Altura de una lista estructurada</h4>
<p>La <em>altura</em> de una lista estructurada viene dada por su número de
niveles: una lista plana tiene una altura de 1, la lista <code>((1 2 3) 4
5)</code> tiene una altura de 2.</p>
<p>Para calcular la altura de una lista estructurada tenemos que obtener
(de forma recursiva) la altura de su primer elemento, y la altura del
resto de la lista, sumarle 1 a la altura del primer elemento y
devolver el máximo de los dos números.</p>
<p><img src="imagenes/altura-estructurada.png" width="300px"/></p>
<p>Como casos base, la altura de una lista vacía o de una hoja (dato) es 0.</p>
<p>En Scheme:</p>
<p><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><code><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="n">altura</span> <span class="n">elem</span><span class="p">)</span>
   <span class="p">(</span><span class="k">cond</span> 
      <span class="p">((</span><span class="nb">null?</span> <span class="n">elem</span><span class="p">)</span> <span class="mi">0</span><span class="p">)</span>
      <span class="p">((</span><span class="n">hoja?</span> <span class="n">elem</span><span class="p">)</span> <span class="mi">0</span><span class="p">)</span>
      <span class="p">(</span><span class="k">else</span> <span class="p">(</span><span class="nb">max</span> <span class="p">(</span><span class="nb">+</span> <span class="mi">1</span> <span class="p">(</span><span class="n">altura</span> <span class="p">(</span><span class="nb">car</span> <span class="n">elem</span><span class="p">)))</span>
                 <span class="p">(</span><span class="n">altura</span> <span class="p">(</span><span class="nb">cdr</span> <span class="n">elem</span><span class="p">))))))</span>
</code></pre></div>
</td></tr></table>
Por ejemplo:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><code><span class="p">(</span><span class="n">altura</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="p">(</span><span class="mi">2</span> <span class="mi">3</span><span class="p">)</span> <span class="mi">4</span><span class="p">))</span> <span class="c1">; ⇒ 2</span>
<span class="p">(</span><span class="n">altura</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="p">(</span><span class="mi">2</span> <span class="p">(</span><span class="mi">3</span><span class="p">))</span> <span class="mi">3</span><span class="p">))</span> <span class="c1">; ⇒ 3</span>
</code></pre></div>
</td></tr></table>

<h5>Versión con funciones de orden superior</h5>
<p>Y la segunda versión, usando las funciones de orden superior <code>map</code>
para obtener la altura de sus elementos del primer nivel (puedes ser
hojas o sublistas) y <code>fold-right</code> para quedarse con el máximo de la
lista de valores que devuelve el map.</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><code><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="n">altura-fos</span> <span class="n">lista</span><span class="p">)</span>
   <span class="p">(</span><span class="nb">+</span> <span class="mi">1</span> <span class="p">(</span><span class="n">fold-right</span> <span class="nb">max</span> <span class="mi">0</span> <span class="p">(</span><span class="nb">map</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="n">elem</span><span class="p">)</span>
                                 <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="n">hoja?</span> <span class="n">elem</span><span class="p">)</span>
                                     <span class="mi">0</span>
                                     <span class="p">(</span><span class="n">altura-fos</span> <span class="n">elem</span><span class="p">)))</span> <span class="n">lista</span><span class="p">))))</span>
</code></pre></div>
</td></tr></table>

<h4>Otras funciones recursivas</h4>
<p>Vamos a diseñar otras funciones recursivas que trabajan con la
estructura jerárquica de las listas estructuradas.</p>
<ul>
<li><code>(aplana lista)</code>: devuelve una lista plana con todas las hojas de la lista</li>
<li><code>(pertenece-lista? dato lista)</code>: busca una hoja en una lista
  estructurada</li>
<li><code>(nivel-hoja dato lista)</code>: devuelve el nivel en el que se encuentra
  un dato en una lista</li>
<li><code>(cuadrado-lista lista)</code>: eleva todas las hojas al cuadrado
  (suponemos que la lista estructurada contiene números)</li>
<li><code>(map-estruct f lista)</code>: similar a map, aplica una función a todas las
  hojas de la lista estructurada y devuelve el resultado (otra lista
  estructurada)</li>
</ul>
<h5><code>(aplana lista)</code></h5>
<p>Devuelve una lista plana con todas las hojas de la lista.</p>
<p>Por ejemplo:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><code><span class="p">(</span><span class="n">aplana</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="p">(</span><span class="mi">3</span> <span class="p">(</span><span class="mi">4</span> <span class="p">(</span><span class="mi">5</span><span class="p">)))</span> <span class="p">(((</span><span class="mi">6</span><span class="p">)))))</span>
<span class="c1">; ⇒ (1 2 3 4 5 6)</span>
</code></pre></div>
</td></tr></table>

<p>La solución recursiva es:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><code><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="n">aplana</span> <span class="n">elem</span><span class="p">)</span>
  <span class="p">(</span><span class="k">cond</span>
    <span class="p">((</span><span class="nb">null?</span> <span class="n">elem</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">())</span>
    <span class="p">((</span><span class="n">hoja?</span> <span class="n">elem</span><span class="p">)</span> <span class="p">(</span><span class="nb">list</span> <span class="n">elem</span><span class="p">))</span>
    <span class="p">(</span><span class="k">else</span> 
     <span class="p">(</span><span class="nb">append</span> <span class="p">(</span><span class="n">aplana</span> <span class="p">(</span><span class="nb">car</span> <span class="n">elem</span><span class="p">))</span>
             <span class="p">(</span><span class="n">aplana</span> <span class="p">(</span><span class="nb">cdr</span> <span class="n">elem</span><span class="p">))))))</span>
</code></pre></div>
</td></tr></table>

<p>Con funciones de orden superior:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><code><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="n">aplana-fos</span> <span class="n">lista</span><span class="p">)</span>
  <span class="p">(</span><span class="n">fold-right</span> <span class="nb">append</span>
              <span class="o">&#39;</span><span class="p">()</span>
              <span class="p">(</span><span class="nb">map</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="n">elem</span><span class="p">)</span>
                     <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="n">hoja?</span> <span class="n">elem</span><span class="p">)</span>
                         <span class="p">(</span><span class="nb">list</span> <span class="n">elem</span><span class="p">)</span>
                         <span class="p">(</span><span class="n">aplana-fos</span> <span class="n">elem</span><span class="p">)))</span> <span class="n">lista</span><span class="p">)))</span>
</code></pre></div>
</td></tr></table>

<h5><code>(pertenece-lista? dato lista)</code></h5>
<p>Comprueba si el <code>dato</code> aparece en la lista estructurada. </p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><code><span class="p">(</span><span class="n">pertenece?</span> <span class="o">&#39;</span><span class="ss">a</span> <span class="o">&#39;</span><span class="p">(</span><span class="ss">b</span> <span class="ss">c</span> <span class="p">(</span><span class="ss">d</span> <span class="p">(</span><span class="ss">a</span><span class="p">))))</span> <span class="c1">; ⇒ #t</span>
<span class="p">(</span><span class="n">pertenece?</span> <span class="o">&#39;</span><span class="ss">a</span> <span class="o">&#39;</span><span class="p">(</span><span class="ss">b</span> <span class="ss">c</span> <span class="p">(</span><span class="ss">d</span> <span class="ss">e</span> <span class="p">(</span><span class="ss">f</span><span class="p">))</span> <span class="ss">g</span><span class="p">))</span> <span class="c1">; ⇒ #f</span>
</code></pre></div>
</td></tr></table>

<p>Solución recursiva:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><code><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="n">pertenece?</span> <span class="n">dato</span> <span class="n">elem</span><span class="p">)</span>
  <span class="p">(</span><span class="k">cond</span> 
    <span class="p">((</span><span class="nb">null?</span> <span class="n">elem</span><span class="p">)</span> <span class="no">#f</span><span class="p">)</span>
    <span class="p">((</span><span class="n">hoja?</span> <span class="n">elem</span><span class="p">)</span> <span class="p">(</span><span class="nb">equal?</span> <span class="n">dato</span> <span class="n">elem</span><span class="p">))</span>
    <span class="p">(</span><span class="k">else</span> <span class="p">(</span><span class="k">or</span> <span class="p">(</span><span class="n">pertenece?</span> <span class="n">dato</span> <span class="p">(</span><span class="nb">car</span> <span class="n">elem</span><span class="p">))</span>
              <span class="p">(</span><span class="n">pertenece?</span> <span class="n">dato</span> <span class="p">(</span><span class="nb">cdr</span> <span class="n">elem</span><span class="p">))))))</span>
</code></pre></div>
</td></tr></table>

<p>Con funciones de orden superior:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><code><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="n">pertenece-fos?</span> <span class="n">dato</span> <span class="n">lista</span><span class="p">)</span>
  <span class="p">(</span><span class="n">exists</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="n">elem</span><span class="p">)</span>
             <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="n">hoja?</span> <span class="n">elem</span><span class="p">)</span>
                 <span class="p">(</span><span class="nb">equal?</span> <span class="n">dato</span> <span class="n">elem</span><span class="p">)</span>
                 <span class="p">(</span><span class="n">pertenece-fos?</span> <span class="n">dato</span> <span class="n">elem</span><span class="p">)))</span> <span class="n">lista</span><span class="p">))</span>
</code></pre></div>
</td></tr></table>

<h5><code>(nivel-hoja dato lista)</code></h5>
<p>Veamos una última función <code>(nivel-hoja dato lista)</code> que recorre una
lista estructurada buscando el dato y devuelve el nivel en que se
encuentra. Si el dato no se encuentra en la lista, se devolverá -1. Si
el dato se encuentra en más de un lugar de la lista se devolverá el
nivel mayor.</p>
<p>Ejemplos:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><code><span class="p">(</span><span class="n">nivel-hoja</span> <span class="o">&#39;</span><span class="ss">b</span> <span class="o">&#39;</span><span class="p">(</span><span class="ss">a</span> <span class="ss">b</span> <span class="p">(</span><span class="ss">c</span><span class="p">)))</span> <span class="c1">; ⇒ 1</span>
<span class="p">(</span><span class="n">nivel-hoja</span> <span class="o">&#39;</span><span class="ss">b</span> <span class="o">&#39;</span><span class="p">(</span><span class="ss">a</span> <span class="p">(</span><span class="ss">b</span><span class="p">)</span> <span class="ss">c</span><span class="p">))</span> <span class="c1">; ⇒ 2</span>
<span class="p">(</span><span class="n">nivel-hoja</span> <span class="o">&#39;</span><span class="ss">b</span> <span class="o">&#39;</span><span class="p">(</span><span class="ss">a</span> <span class="p">(</span><span class="ss">b</span><span class="p">)</span> <span class="ss">d</span> <span class="p">((</span><span class="ss">b</span><span class="p">))))</span> <span class="c1">; ⇒ 3</span>
<span class="p">(</span><span class="n">nivel-hoja</span> <span class="o">&#39;</span><span class="ss">b</span> <span class="o">&#39;</span><span class="p">(</span><span class="ss">a</span> <span class="ss">c</span> <span class="ss">d</span> <span class="p">((</span><span class="ss">e</span><span class="p">))))</span> <span class="c1">; ⇒ -1</span>
</code></pre></div>
</td></tr></table>

<p>Solución recursiva:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><code><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="n">nivel-hoja</span> <span class="n">dato</span> <span class="n">elem</span><span class="p">)</span>
  <span class="p">(</span><span class="k">cond</span>
    <span class="p">((</span><span class="nb">null?</span> <span class="n">elem</span><span class="p">)</span> <span class="mi">-1</span><span class="p">)</span>
    <span class="p">((</span><span class="n">hoja?</span> <span class="n">elem</span><span class="p">)</span> <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">equal?</span> <span class="n">elem</span> <span class="n">dato</span><span class="p">)</span> <span class="mi">0</span> <span class="mi">-1</span><span class="p">))</span>
    <span class="p">(</span><span class="k">else</span> <span class="p">(</span><span class="nb">max</span> <span class="p">(</span><span class="n">suma-1-si-mayor-igual-que-0</span> 
                    <span class="p">(</span><span class="n">nivel-hoja</span> <span class="n">dato</span> <span class="p">(</span><span class="nb">car</span> <span class="n">elem</span><span class="p">)))</span>
               <span class="p">(</span><span class="n">nivel-hoja</span> <span class="n">dato</span> <span class="p">(</span><span class="nb">cdr</span> <span class="n">elem</span><span class="p">))))))</span>
</code></pre></div>
</td></tr></table>

<p>La función auxiliar se define de la siguiente forma:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><code><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="n">suma-1-si-mayor-igual-que-0</span> <span class="n">x</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">&gt;=</span> <span class="n">x</span> <span class="mi">0</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">+</span> <span class="n">x</span> <span class="mi">1</span><span class="p">)</span>
      <span class="n">x</span><span class="p">))</span>
</code></pre></div>
</td></tr></table>

<p>Con funciones de orden superior:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><code><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="n">nivel-hoja-fos</span> <span class="n">dato</span> <span class="n">lista</span><span class="p">)</span>
  <span class="p">(</span><span class="n">suma-1-si-mayor-igual-que-0</span>
       <span class="p">(</span><span class="n">fold-right</span> <span class="nb">max</span> <span class="mi">-1</span>
                   <span class="p">(</span><span class="nb">map</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="n">elem</span><span class="p">)</span>
                          <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="n">hoja?</span> <span class="n">elem</span><span class="p">)</span>
                              <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">equal?</span> <span class="n">elem</span> <span class="n">dato</span><span class="p">)</span> <span class="mi">0</span> <span class="mi">-1</span><span class="p">)</span>
                              <span class="p">(</span><span class="n">nivel-hoja-fos</span> <span class="n">dato</span> <span class="n">elem</span><span class="p">)))</span>  
                        <span class="n">lista</span><span class="p">))))</span>
</code></pre></div>
</td></tr></table>

<p>Se puede hacer otra versión de la función anterior, que aproveche que
Scheme es un lenguaje débilmente tipado y que devuelva <code>#f</code> si el dato no
se encuentra:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><code><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="n">incrementa-nivel-si-encontrado</span> <span class="n">x</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">not</span> <span class="n">x</span><span class="p">)</span>
      <span class="n">x</span> 
      <span class="p">(</span><span class="nb">+</span> <span class="n">x</span> <span class="mi">1</span><span class="p">)))</span>

<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="n">mayor-nivel-si-encontrado</span> <span class="n">x</span> <span class="n">y</span><span class="p">)</span>
  <span class="p">(</span><span class="k">cond</span>
    <span class="p">((</span><span class="nb">not</span> <span class="n">x</span><span class="p">)</span> <span class="n">y</span><span class="p">)</span>
    <span class="p">((</span><span class="nb">not</span> <span class="n">y</span><span class="p">)</span> <span class="n">x</span><span class="p">)</span>
    <span class="p">(</span><span class="k">else</span> <span class="p">(</span><span class="nb">max</span> <span class="n">x</span> <span class="n">y</span><span class="p">))))</span>

<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="n">nivel-hoja2</span> <span class="n">dato</span> <span class="n">elem</span><span class="p">)</span>
  <span class="p">(</span><span class="k">cond</span>
    <span class="p">((</span><span class="nb">null?</span> <span class="n">elem</span><span class="p">)</span> <span class="no">#f</span><span class="p">)</span>
    <span class="p">((</span><span class="n">hoja?</span> <span class="n">elem</span><span class="p">)</span> <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">equal?</span> <span class="n">x</span> <span class="n">dato</span><span class="p">)</span> <span class="mi">0</span> <span class="no">#f</span><span class="p">))</span>
    <span class="p">(</span><span class="k">else</span> <span class="p">(</span><span class="n">mayor-nivel-si-encontrado</span>
               <span class="p">(</span><span class="n">incrementa-nivel-si-encontrado</span> <span class="p">(</span><span class="n">nivel-hoja</span> <span class="n">dato</span> <span class="p">(</span><span class="nb">car</span> <span class="n">elem</span><span class="p">)))</span>
               <span class="p">(</span><span class="n">nivel-hoja2</span> <span class="n">dato</span> <span class="p">(</span><span class="nb">cdr</span> <span class="n">elem</span><span class="p">))))))</span>
</code></pre></div>
</td></tr></table>

<p>Las funciones auxiliares <code>incrementa-nivel-si-encontrado</code> y
<code>mayor-nivel-si-encontrado</code> realizan la suma de 1 y calculan el máximo
tratando con los casos en los que alguno de los argumentos es <code>#f</code>
porque no se ha encontrado el dato.</p>
<p>Ejemplos:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><code><span class="p">(</span><span class="n">nivel-hoja2</span> <span class="o">&#39;</span><span class="ss">b</span> <span class="o">&#39;</span><span class="p">(</span><span class="ss">a</span> <span class="ss">b</span> <span class="p">(</span><span class="ss">c</span><span class="p">)))</span> <span class="c1">; ⇒ 1</span>
<span class="p">(</span><span class="n">nivel-hoja2</span> <span class="o">&#39;</span><span class="ss">b</span> <span class="o">&#39;</span><span class="p">(</span><span class="ss">a</span> <span class="p">(</span><span class="ss">b</span><span class="p">)</span> <span class="ss">c</span><span class="p">))</span> <span class="c1">; ⇒ 2</span>
<span class="p">(</span><span class="n">nivel-hoja2</span> <span class="o">&#39;</span><span class="ss">b</span> <span class="o">&#39;</span><span class="p">(</span><span class="ss">a</span> <span class="p">(</span><span class="ss">b</span><span class="p">)</span> <span class="ss">d</span> <span class="p">((</span><span class="ss">b</span><span class="p">))))</span> <span class="c1">; ⇒ 3</span>
<span class="p">(</span><span class="n">nivel-hoja2</span> <span class="o">&#39;</span><span class="ss">b</span> <span class="o">&#39;</span><span class="p">(</span><span class="ss">a</span> <span class="ss">c</span> <span class="ss">d</span> <span class="p">((</span><span class="ss">e</span><span class="p">))))</span> <span class="c1">; ⇒ #f</span>
</code></pre></div>
</td></tr></table>

<h5><code>(cuadrado-lista lista)</code></h5>
<p>Vamos ahora a ver un tipo de función distinta. Una que construye una
lista estructurada y la devuelve. </p>
<p>Queremos implementar la función <code>(cuadrado-lista lista)</code> que recibe
una lista estructurada y devuelve otra lista estructurada con la misma
estructura y sus números elevados al cuadrado.</p>
<p>Por ejemplo:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><code><span class="p">(</span><span class="n">cuadrado-lista</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">2</span> <span class="mi">3</span> <span class="p">(</span><span class="mi">4</span> <span class="p">(</span><span class="mi">5</span><span class="p">))))</span> <span class="c1">; ⇒ (4 9 (16 (25))</span>
</code></pre></div>
</td></tr></table>

<p>La solución recursiva es:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><code><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="n">cuadrado-lista</span> <span class="n">elem</span><span class="p">)</span>
  <span class="p">(</span><span class="k">cond</span> <span class="p">((</span><span class="nb">null?</span> <span class="n">elem</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">())</span>
        <span class="p">((</span><span class="n">hoja?</span> <span class="n">elem</span><span class="p">)</span> <span class="p">(</span><span class="nb">*</span> <span class="n">elem</span> <span class="n">elem</span><span class="p">))</span>
        <span class="p">(</span><span class="k">else</span> <span class="p">(</span><span class="nb">cons</span> <span class="p">(</span><span class="n">cuadrado-lista</span> <span class="p">(</span><span class="nb">car</span> <span class="n">elem</span><span class="p">))</span>
                    <span class="p">(</span><span class="n">cuadrado-lista</span> <span class="p">(</span><span class="nb">cdr</span> <span class="n">elem</span><span class="p">))))))</span>
</code></pre></div>
</td></tr></table>

<p>Es muy interesante la versión de esta función con funciones de orden
superior:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><code><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="n">cuadrado-lista-fos</span> <span class="n">lista</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">map</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="n">elem</span><span class="p">)</span>
           <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="n">hoja?</span> <span class="n">elem</span><span class="p">)</span>
               <span class="p">(</span><span class="nb">*</span> <span class="n">elem</span> <span class="n">elem</span><span class="p">)</span>
               <span class="p">(</span><span class="n">cuadrado-lista-fos</span> <span class="n">elem</span><span class="p">)))</span> <span class="n">lista</span><span class="p">))</span>
</code></pre></div>
</td></tr></table>

<p>Como una lista estructurada está compuesta de datos o de otras
sublistas podemos aplicar <code>map</code> para que devuelva la lista resultante
de transformar la original con la función que le pasamos como
parámetro.</p>
<h5><code>(map-estruct f lista)</code></h5>
<p>Podemos generalizar la función anterior y definir la función de orden
superior sobre listas estructuradas <code>(map-estructurada f lista)</code> que
devuelve una lista estructurada igual que la original con el resultado
de aplicar a cada uno de sus hojas la función f</p>
<p>Por ejemplo:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><code><span class="p">(</span><span class="n">map-estruct</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">*</span> <span class="n">x</span> <span class="n">x</span><span class="p">))</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">2</span> <span class="mi">3</span> <span class="p">(</span><span class="mi">4</span> <span class="p">(</span><span class="mi">5</span><span class="p">))))</span> <span class="c1">; ⇒ (4 9 (16 (25))</span>
</code></pre></div>
</td></tr></table>

<p>La solución recursiva es una generalización de la función anterior,
usando el parámetro <code>f</code>:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><code><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="n">map-estruct</span> <span class="n">f</span> <span class="n">elem</span><span class="p">)</span>
  <span class="p">(</span><span class="k">cond</span> <span class="p">((</span><span class="nb">null?</span> <span class="n">elem</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">())</span>
        <span class="p">((</span><span class="n">hoja?</span> <span class="n">elem</span><span class="p">)</span> <span class="p">(</span><span class="n">f</span> <span class="n">elem</span><span class="p">))</span>
        <span class="p">(</span><span class="k">else</span> <span class="p">(</span><span class="nb">cons</span> <span class="p">(</span><span class="n">map-estruct</span> <span class="n">f</span> <span class="p">(</span><span class="nb">car</span> <span class="n">elem</span><span class="p">))</span>
                    <span class="p">(</span><span class="n">map-estruct</span> <span class="n">f</span> <span class="p">(</span><span class="nb">cdr</span> <span class="n">elem</span><span class="p">))))))</span>
</code></pre></div>
</td></tr></table>

<p>Solución con <code>map</code>:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><code><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="n">map-estruct-fos</span> <span class="n">f</span> <span class="n">lista</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">map</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="n">elem</span><span class="p">)</span>
          <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="n">hoja?</span> <span class="n">elem</span><span class="p">)</span>
              <span class="p">(</span><span class="n">f</span> <span class="n">elem</span><span class="p">)</span>
              <span class="p">(</span><span class="n">map-estruct-fos</span> <span class="n">f</span> <span class="n">elem</span><span class="p">)))</span> <span class="n">lista</span><span class="p">))</span>
</code></pre></div>
</td></tr></table>

<!--

## Árboles

### Definición de árboles en Scheme

#### Definición de árbol

Un **árbol** es una estructura de datos definida por un valor raíz,
que es el padre de toda la estructura, del que salen otros subárboles
hijos
([Wikipedia](https://en.wikipedia.org/wiki/Tree_(data_structure))).

Un **árbol** se puede definir recursivamente de la siguiente forma:

- Una colección de un **dato** (el valor de la raíz del árbol) y una
  **lista de hijos** que también son árboles.
- Una **hoja** será un árbol sin hijos (un dato con una lista de hijos
  vacía).

Un ejemplo de árbol:

<img src="imagenes/arbol-sencillo.png" width="250px"/>

El árbol anterior tiene como dato de la raíz es el símbolo `+` y tiene
3 árboles hijos:

<img src="imagenes/tres-arboles-hijos.png" width="300px"/>

- El primer hijo es un árbol hoja, con valor 5 y sin hijos
- El segundo hijo es un árbol con valor `*` y dos hijos hoja, el 2 y
  el 3
- El tercer hijo es otro árbol hoja, con valor 10

#### Representación de árboles con listas

En Scheme la lista es la estructura de datos principal. ¿Cómo
podemos construir un árbol usando listas?

Podemos hacerlo de varias formas, pero escogemos la siguiente: usar
**una lista de _n+1_ elems** para representar un árbol con n hijos:

- el primer elemento la lista será el dato de la raíz
- el resto serán los árboles hijos

> Árbol: (dato hijo-1 hijo-2 ... hijo-n)

Los nodos hoja (datos al final del árbol que no tienen ningún hijo)
son también árboles. Al no tener hijos, se representan como listas con
un único elemento, el propio dato:

> Nodo hoja: (dato)

<img src="imagenes/arbol-sencillo.png" width="250px"/>

La forma de representar el árbol anterior será la siguiente lista:

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><code><span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="p">(</span><span class="nb">*</span> <span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="mi">3</span><span class="p">))</span> <span class="p">(</span><span class="mi">10</span><span class="p">))</span>
</code></pre></div>
</td></tr></table>

Los elementos de esta lista son:

- El primer elemento es el símbolo `+`, el dato valor de la raíz del
  árbol
- El segundo elemento es la lista `(5)`, que representa el árbol hoja
  formado por un 5
- El tercer elemento es la lista `(* (2) (3))`, que representa el
  árbol con un dato `*` y dos hijos
- El cuarto elemento es la lista `(10)`, que representa el árbol hoja
  formado por un 10

Podríamos definir el árbol con la siguiente sentencia:

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><code><span class="p">(</span><span class="k">define</span> <span class="n">arbol1</span> <span class="o">&#39;</span><span class="p">(</span><span class="ss">+</span> <span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="p">(</span><span class="ss">*</span> <span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="mi">3</span><span class="p">))</span> <span class="p">(</span><span class="mi">10</span><span class="p">)))</span>
</code></pre></div>
</td></tr></table>

Otro ejemplo más. ¿Cómo se implementa en Scheme el árbol de la siguiente figura?

<img src="imagenes/binario-2.png" width="300px"/>

Se haría con la lista de la siguiente sentencia:

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><code><span class="p">(</span><span class="k">define</span> <span class="n">arbol2</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">40</span> <span class="p">(</span><span class="mi">18</span> <span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="p">(</span><span class="mi">23</span> <span class="p">(</span><span class="mi">29</span><span class="p">)))</span> <span class="p">(</span><span class="mi">52</span> <span class="p">(</span><span class="mi">47</span><span class="p">))))</span>
</code></pre></div>
</td></tr></table>

#### Barrera de abstracción

Una vez definida la forma de representar árboles, vamos a definir las
funciones básicas para manejarlos. Veremos las funciones para obtener el dato
y los hijos y la función para construir un árbol nuevo. Estas
funciones proporcionan lo que se denomina _barrera de abstracción_
del tipo datos *árbol*.

En todos los nombres de las funciones de la barrera de abstracción
añadimos el sufijo `-arbol`.

Definimos dos conjuntos de funciones: **constructores** para construir un
nuevo árbol y **selectores** para obtener los elementos del árbol. Vamos a
empezar por los selectores.

**Selectores**

Funciones que obtienen los elementos de un árbol:

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><code><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="n">dato-arbol</span> <span class="n">arbol</span><span class="p">)</span> 
    <span class="p">(</span><span class="nb">car</span> <span class="n">arbol</span><span class="p">))</span>

<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="n">hijos-arbol</span> <span class="n">arbol</span><span class="p">)</span> 
    <span class="p">(</span><span class="nb">cdr</span> <span class="n">arbol</span><span class="p">))</span>

<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="n">hoja-arbol?</span> <span class="n">arbol</span><span class="p">)</span> 
   <span class="p">(</span><span class="nb">null?</span> <span class="p">(</span><span class="n">hijos-arbol</span> <span class="n">arbol</span><span class="p">)))</span>
</code></pre></div>
</td></tr></table>

Es importante tener claro los tipos devueltos por las dos primeras
funciones:

- `(dato-arbol arbol)`: devuelve **el dato** de la raíz del árbol.
- `(hijos-arbol arbol)`: devuelve **una lista de árboles** hijos. En
  algunas ocasiones llamaremos *bosque* a una lista de
  árboles. Podremos recorrer esa lista usando las funciones `car` y
  `cdr` para obtener los árboles hijos.

Volvemos a mostrar el `arbol1` para comprobar estas funciones.

<img src="imagenes/arbol-sencillo.png" width="250px"/>

Las funciones anteriores devuelven los siguientes valores:

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><code><span class="p">(</span><span class="n">dato-arbol</span> <span class="n">arbol1</span><span class="p">)</span> <span class="c1">; ⇒ +</span>
<span class="p">(</span><span class="n">hijos-arbol</span> <span class="n">arbol1</span><span class="p">)</span> <span class="c1">; ⇒ ((5) (* (2) (3)) (10))x</span>
<span class="p">(</span><span class="n">hoja-arbol?</span> <span class="p">(</span><span class="nb">car</span> <span class="p">(</span><span class="n">hijos-arbol</span> <span class="n">arbol1</span><span class="p">)))</span> <span class="c1">; ⇒ #t</span>
</code></pre></div>
</td></tr></table>

- La llamada `(dato-arbol arbol1)` devuelve el dato que hay en la raíz
  del árbol, el símbolo `+`
- La invocación `(hijos-arbol arbol1)` devuelve una lista de tres
  elementos, los árboles hijos: `((5) (* (2) (3)) (10))`:
    - El primer elemento se puede obtener con la función `(car
      (hijos-arbol arbol))` y es la lista `(5)`, que representa el árbol
      hoja formado por el `5`
    - El segundo es la lista `(* (2) (3))`, que representa el árbol
      formado por el `*` en su raíz y las hojas `2` y `3`. Se puede
      obtener con la llamada `(cadr (hijos-arbol arbol))`.
    - El tercero es el árbol hoja `10`, representado por la lista
      `(10)`, que se puede obtener con la llamada `(caddr
      (hijos-arbol arbol))`.
- El primer y el tercer elemento de la lista de hijos son árboles hoja:
  `(hoja-arbol? (car (hijos-arbol arbol1))) ⇒ #t` y `(hoja-arbol?
  (caddr (hijos-arbol arbol1))) ⇒ #t`.

Es muy importante considerar en cada caso con qué tipo de dato estamos
trabajando y usar la barrera de abstracción adecuada en cada caso:

- La función `hijos-arbol` siempre devuelve una lista de árboles, que
  podemos recorrer usando `car` y `cdr`.
- El `car` de una lista de árboles (devuelta por `hijos-arbol`) siempre
  es un árbol y debemos de usar las funciones de su barrera de
  abstracción: `dato-arbol` e `hijos-arbol`.
- La función `dato-arbol` devuelve un dato de árbol, del tipo que
  guardemos en el árbol. En el caso del árbol ejemplo es un número.

Por ejemplo, para obtener el número 2 en el árbol anterior tendríamos
que hacer lo siguiente: acceder al segundo elemento de la lista de
hijos, después al primer hijo de éste y por último acceder a su
dato. Recordemos que `hijos-arbol` devuelve la lista de árboles hijos,
por lo que utilizaremos las funciones `car` y `cdr` para recorrerlas y
obtener los elementos que nos interesen:

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><code><span class="p">(</span><span class="n">dato-arbol</span> <span class="p">(</span><span class="nb">car</span> <span class="p">(</span><span class="n">hijos-arbol</span> <span class="p">(</span><span class="nb">cadr</span> <span class="p">(</span><span class="n">hijos-arbol</span> <span class="n">arbol1</span><span class="p">)))))</span> <span class="c1">; ⇒ 2</span>
</code></pre></div>
</td></tr></table>


**Constructor**

Definimos una función constructora que abstrae la construcción de un
árbol y encapsula su implementación concreta. Para construir un árbol
necesitamos un dato y una lista de árboles hijos. Si la lista de
árboles hijos es vacía, tendremos un nodo hoja.

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><code><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="n">construye-arbol</span> <span class="n">dato</span> <span class="n">lista-arboles</span><span class="p">)</span>  
   <span class="p">(</span><span class="nb">cons</span> <span class="n">dato</span> <span class="n">lista-arboles</span><span class="p">))</span>
</code></pre></div>
</td></tr></table>

Llamaremos a la función `construye-arbol` pasando su dato
(obligatorio) y la lista de arboles hijos. Si se pasa una lista vacía
como parámetro estaremos definiendo un nodo hoja.

Por ejemplo, para definir un nodo hoja con el dato 2:

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><code><span class="p">(</span><span class="k">define</span> <span class="n">arbol3</span> <span class="p">(</span><span class="n">construye-arbol</span> <span class="mi">2</span> <span class="o">&#39;</span><span class="p">()))</span>
</code></pre></div>
</td></tr></table>

Y para definir un árbol con 3 hijos:

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><code><span class="p">(</span><span class="k">define</span> <span class="n">arbol4</span> <span class="p">(</span><span class="n">construye-arbol</span> <span class="mi">10</span> <span class="p">(</span><span class="nb">list</span> <span class="p">(</span><span class="n">construye-arbol</span> <span class="mi">2</span> <span class="o">&#39;</span><span class="p">())</span>
                                         <span class="p">(</span><span class="n">construye-arbol</span> <span class="mi">5</span> <span class="o">&#39;</span><span class="p">())</span> 
                                         <span class="p">(</span><span class="n">construye-arbol</span> <span class="mi">9</span> <span class="o">&#39;</span><span class="p">())))</span>
</code></pre></div>
</td></tr></table>
El árbol 1 anterior se puede construir con las siguientes llamadas al constructor:

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><code><span class="p">(</span><span class="n">construye-arbol</span> <span class="o">&#39;</span><span class="ss">+</span> <span class="p">(</span><span class="nb">list</span> <span class="p">(</span><span class="n">construye-arbol</span> <span class="mi">5</span> <span class="o">&#39;</span><span class="p">())</span>
                          <span class="p">(</span><span class="n">construye-arbol</span> <span class="o">&#39;</span><span class="ss">*</span> <span class="p">(</span><span class="nb">list</span> <span class="p">(</span><span class="n">construye-arbol</span> <span class="mi">2</span> <span class="o">&#39;</span><span class="p">())</span>
                                                    <span class="p">(</span><span class="n">construye-arbol</span> <span class="mi">3</span> <span class="o">&#39;</span><span class="p">())))</span>
                          <span class="p">(</span><span class="n">construye-arbol</span> <span class="mi">10</span> <span class="o">&#39;</span><span class="p">()))</span>
</code></pre></div>
</td></tr></table>

#### Barreras de abstracción de árboles y listas estructuradas

Es importante diferenciar la barrera de abstracción de los árboles de
la de las listas estructuradas. Aunque un árbol se implementa en
Scheme con una lista estructurada, a la hora de definir funciones
sobre árboles hay que trabajar con las funciones definidas arriba.

El siguiente esquema resumen las características de los selectores de
la barrera de abstracción de listas y árboles:

<img src="imagenes/barrera-abstraccion.png" width="550px">

!!! Important "Importante"
    Es muy importante usar la barrera de abstracción al trabajar con
    árboles porque así separamos nuestro código de la implementación
    subyacente del tipo de dato. De esta forma es posible cambiar la
    implementación del tipo de dato sin afectar a las funciones que hemos
    definido usando la barrera. Lo único que hay que hacer es cambiar la
    implementación de la barrera de abstracción.

    Otras ventajas de utilizar la barrera de abstracción, tan
    importantes como la anterior, son:

    - El código es mucho más legible. Dado que Scheme es un lenguaje
    débilmente tipado, en una expresión como `(dato-arbol elem)`
    sabemos que el el elemento sobre el que se trabaja es un árbol (no
    es un número, ni un string, ni un booleano).

    - El código es trasladable a cualquier lenguaje de
    programación. Si queremos trabajar con árboles en JavaScript, por
    ejemplo, sólo tendremos que implementar la barrera de abstracción
    en este lenguaje. Una vez hecho eso todas las funciones que
    trabajan con árboles, como las que veremos a continuación,
    funcionarán correctamente.

### Funciones recursivas sobre árboles

Vamos a diseñar las siguientes funciones recursivas:

* `(suma-datos-arbol arbol)`: devuelve la suma de todos los nodos
* `(to-list-arbol arbol)`: devuelve una lista con los datos del árbol
* `(cuadrado-arbol arbol)`: eleva al cuadrado todos los datos de un
  árbol manteniendo la estructura del árbol original
* `(map-arbol f arbol)`: devuelve un árbol con la estructura del árbol
  original aplicando la función f a subdatos.
* `(altura-arbol arbol)`: devuelve la altura de un árbol

Todas comparten un patrón similar de recursión mutua.

#### Función `(suma-datos-arbol arbol)`

Vamos a implementar una función recursiva que sume todos los datos de
un árbol.

Un árbol siempre va a tener un dato y una lista de hijos (que puede
ser vacía) que obtenemos con las funciones `dato-arbol` e
`hijos-arbol`. Podemos plantear entonces el problema de sumar los datos
de un árbol como la suma del dato de su raíz y lo que devuelva la
llamada a una función auxiliar que sume los datos de su lista de hijos
(llamamos _bosque_ a una lista de hijos):

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><code><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="n">suma-datos-arbol</span> <span class="n">arbol</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="n">dato-arbol</span> <span class="n">arbol</span><span class="p">)</span>
       <span class="p">(</span><span class="n">suma-datos-bosque</span> <span class="p">(</span><span class="n">hijos-arbol</span> <span class="n">arbol</span><span class="p">))))</span>
</code></pre></div>
</td></tr></table>

Esta función suma los datos de **un** árbol. La podemos utilizar
entonces para construir la siguiente función que suma una lista de
árboles:

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><code><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="n">suma-datos-bosque</span> <span class="n">bosque</span><span class="p">)</span>
   <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">null?</span> <span class="n">bosque</span><span class="p">)</span>
       <span class="mi">0</span>
       <span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="n">suma-datos-arbol</span> <span class="p">(</span><span class="nb">car</span> <span class="n">bosque</span><span class="p">))</span> <span class="p">(</span><span class="n">suma-datos-bosque</span> <span class="p">(</span><span class="nb">cdr</span> <span class="n">bosque</span><span class="p">)))))</span>
</code></pre></div>
</td></tr></table>

Tenemos una **recursión mutua**: para sumar los datos de una lista de
árboles llamamos a la suma de un árbol individual que a su vez llama a
la suma de sus hijos, etc. La recursión termina cuando calculamos la
suma de un árbol hoja. Entonces se pasa a `suma-datos-bosque` una
lista vacía y ésta devolverá 0.


<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><code><span class="p">(</span><span class="n">suma-datos-arbol</span> <span class="n">arbol2</span><span class="p">)</span> <span class="c1">; ⇒ 212</span>
</code></pre></div>
</td></tr></table>

**Versión alternativa con funciones de orden superior**

Al igual que hacíamos con las listas estructuradas, es posible
conseguir una versión más concisa y elegante utilizando funciones de
orden superior:

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><code><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="n">suma-datos-arbol-fos</span> <span class="n">arbol</span><span class="p">)</span>
   <span class="p">(</span><span class="n">fold-right</span> <span class="nb">+</span> <span class="p">(</span><span class="n">dato-arbol</span> <span class="n">arbol</span><span class="p">)</span> 
       <span class="p">(</span><span class="nb">map</span> <span class="n">suma-datos-arbol-fos</span> <span class="p">(</span><span class="n">hijos-arbol</span> <span class="n">arbol</span><span class="p">))))</span>
</code></pre></div>
</td></tr></table>

La función `map` aplica la propia función que estamos definiendo
(`suma-datos-arbol-fos`) a cada uno de los árboles hijos (obtenidos
con la función `(hijos-arbol arbol)`). Confiando en que la función
hace su trabajo, devolverá para cada arbol hijo la suma de todos sus
nodos. De esta forma, el resultado de `map` será una lista con la suma
de los nodos de todos los árboles hijos.

La función `fold-right` suma todos esos números de la lista y el
número de la raíz.

Un ejemplo de su funcionamiento sería el siguiente:

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><code><span class="p">(</span><span class="n">suma-datos-arbol-fos</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="p">(</span><span class="mi">2</span> <span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="p">(</span><span class="mi">4</span><span class="p">))</span> <span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="p">(</span><span class="mi">6</span> <span class="p">(</span><span class="mi">7</span><span class="p">))))</span> <span class="n">⇒</span>
   <span class="p">(</span><span class="n">fold-right</span> <span class="nb">+</span> <span class="mi">1</span> <span class="p">(</span><span class="nb">map</span> <span class="n">suma-datos-arbol-fos</span> <span class="o">&#39;</span><span class="p">((</span><span class="mi">2</span> <span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="p">(</span><span class="mi">4</span><span class="p">))</span> 
                                                <span class="p">(</span><span class="mi">5</span><span class="p">)</span>
                                                <span class="p">(</span><span class="mi">6</span> <span class="p">(</span><span class="mi">7</span><span class="p">)))))</span> <span class="n">⇒</span>
<span class="p">(</span><span class="n">fold-right</span> <span class="nb">+</span> <span class="mi">1</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">9</span> <span class="mi">5</span> <span class="mi">13</span><span class="p">))</span> <span class="n">⇒</span>
<span class="mi">28</span>
</code></pre></div>
</td></tr></table>

- El árbol que queremos sumar tiene un 1 en la raíz y tres hijos: `(2
(3) (4))`, `(5)` y `(6 (7))`. 
- La aplicación de `map suma-datos-arbol-fos` sobre la lista de hijos
devuelve una lista con la suma de los nodos de cada hijo: `(9 5 13)`.
- La función `fold-right` suma esa lista y el valor del nodo raíz (`1`).

#### Función `(to-list-arbol arbol)`

Queremos diseñar una función `(to-list-arbol arbol)` que devuelva una
lista con los datos del árbol en un recorrido *preorden*.

La solución, siguiendo el patrón visto en `suma-datos`, es la siguiente.

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><code><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="n">to-list-arbol</span> <span class="n">arbol</span><span class="p">)</span>
   <span class="p">(</span><span class="nb">cons</span> <span class="p">(</span><span class="n">dato-arbol</span> <span class="n">arbol</span><span class="p">)</span>
         <span class="p">(</span><span class="n">to-list-bosque</span> <span class="p">(</span><span class="n">hijos-arbol</span> <span class="n">arbol</span><span class="p">))))</span>

<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="n">to-list-bosque</span> <span class="n">bosque</span><span class="p">)</span>
   <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">null?</span> <span class="n">bosque</span><span class="p">)</span>
       <span class="o">&#39;</span><span class="p">()</span>
       <span class="p">(</span><span class="nb">append</span> <span class="p">(</span><span class="n">to-list-arbol</span> <span class="p">(</span><span class="nb">car</span> <span class="n">bosque</span><span class="p">))</span>
               <span class="p">(</span><span class="n">to-list-bosque</span> <span class="p">(</span><span class="nb">cdr</span> <span class="n">bosque</span><span class="p">)))))</span>
</code></pre></div>
</td></tr></table>

La función utiliza también una *recursión mutua*: para listar todos los nodos,
añadimos el dato a la lista de nodos que nos devuelve la función
`to-list-bosque`. Esta función coge una lista de árboles (un *bosque*)
y devuelve la lista *preorden* de sus nodos. Para ello, concatena la
lista de los nodos de su primer elemento (el primer árbol) a la lista
de nodos del resto de árboles (que devuelve la llamada recursiva).

Ejemplo:

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><code><span class="p">(</span><span class="n">to-list-arbol</span> <span class="o">&#39;</span><span class="p">(</span><span class="ss">*</span> <span class="p">(</span><span class="ss">+</span> <span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="p">(</span><span class="ss">*</span> <span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="mi">3</span><span class="p">))</span> <span class="p">(</span><span class="mi">10</span><span class="p">))</span> <span class="p">(</span><span class="ss">-</span> <span class="p">(</span><span class="mi">12</span><span class="p">))))</span> 
<span class="c1">; ⇒ (* + 5 * 2 3 10 - 12)</span>
</code></pre></div>
</td></tr></table>

Una definición alternativa usando funciones de orden superior:

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><code><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="n">to-list-arbol-fos</span> <span class="n">arbol</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">cons</span> <span class="p">(</span><span class="n">dato-arbol</span> <span class="n">arbol</span><span class="p">)</span>
          <span class="p">(</span><span class="n">fold-right</span> <span class="nb">append</span> <span class="o">&#39;</span><span class="p">()</span> <span class="p">(</span><span class="nb">map</span> <span class="n">to-list-arbol-fos</span> <span class="p">(</span><span class="n">hijos-arbol</span> <span class="n">arbol</span><span class="p">)))))</span>
</code></pre></div>
</td></tr></table>

Esta versión es muy elegante y concisa. Usa la función `map` que
aplica una función a los elementos de una lista y devuelve la lista
resultante. Como lo que devuelve `(hijos-arbol arbol)` es precisamente
una lista de árboles podemos aplicar a sus elementos cualquier función
definida sobre árboles. Incluso la propia función que estamos
definiendo (¡confía en la recursión!).

#### Función `(cuadrado-arbol arbol)`

Veamos ahora la función `(cuadrado-arbol arbol)` que toma un árbol de
números y devuelve un árbol con la misma estructura y sus datos
elevados al cuadrado:

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><code><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="n">cuadrado-arbol</span> <span class="n">arbol</span><span class="p">)</span>
   <span class="p">(</span><span class="n">construye-arbol</span> <span class="p">(</span><span class="n">cuadrado</span> <span class="p">(</span><span class="n">dato-arbol</span> <span class="n">arbol</span><span class="p">))</span>
                    <span class="p">(</span><span class="n">cuadrado-bosque</span> <span class="p">(</span><span class="n">hijos-arbol</span> <span class="n">arbol</span><span class="p">))))</span>  

<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="n">cuadrado-bosque</span> <span class="n">bosque</span><span class="p">)</span>
   <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">null?</span> <span class="n">bosque</span><span class="p">)</span>
       <span class="o">&#39;</span><span class="p">()</span>
       <span class="p">(</span><span class="nb">cons</span> <span class="p">(</span><span class="n">cuadrado-arbol</span> <span class="p">(</span><span class="nb">car</span> <span class="n">bosque</span><span class="p">))</span>
               <span class="p">(</span><span class="n">cuadrado-bosque</span> <span class="p">(</span><span class="nb">cdr</span> <span class="n">bosque</span><span class="p">)))))</span>
</code></pre></div>
</td></tr></table>

Ejemplo:

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><code><span class="p">(</span><span class="n">cuadrado-arbol</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">2</span> <span class="p">(</span><span class="mi">3</span> <span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="p">(</span><span class="mi">5</span><span class="p">))</span> <span class="p">(</span><span class="mi">6</span><span class="p">)))</span> 
<span class="c1">; ⇒ (4 (9 (16) (25)) (36))</span>
</code></pre></div>
</td></tr></table>

Versión 2, con la función de orden superior `map`:

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><code><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="n">cuadrado-arbol-fos</span> <span class="n">arbol</span><span class="p">)</span>
   <span class="p">(</span><span class="n">construye-arbol</span> <span class="p">(</span><span class="n">cuadrado</span> <span class="p">(</span><span class="n">dato-arbol</span> <span class="n">arbol</span><span class="p">))</span>
                    <span class="p">(</span><span class="nb">map</span> <span class="n">cuadrado-arbol-fos</span> <span class="p">(</span><span class="n">hijos-arbol</span> <span class="n">arbol</span><span class="p">))))</span>
</code></pre></div>
</td></tr></table>

#### Función `map-arbol`

La función `map-arbol` es una función de orden superior que generaliza
la función anterior. Definimos un parámetro adicional en el que se
pasa la función a aplicar a los elementos del árbol.

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><code><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="n">map-arbol</span> <span class="n">f</span> <span class="n">arbol</span><span class="p">)</span>
   <span class="p">(</span><span class="n">construye-arbol</span> <span class="p">(</span><span class="n">f</span> <span class="p">(</span><span class="n">dato-arbol</span> <span class="n">arbol</span><span class="p">))</span>
              <span class="p">(</span><span class="n">map-bosque</span> <span class="n">f</span> <span class="p">(</span><span class="n">hijos-arbol</span> <span class="n">arbol</span><span class="p">))))</span>  

<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="n">map-bosque</span> <span class="n">f</span> <span class="n">bosque</span><span class="p">)</span>
   <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">null?</span> <span class="n">bosque</span><span class="p">)</span>
       <span class="o">&#39;</span><span class="p">()</span>
       <span class="p">(</span><span class="nb">cons</span> <span class="p">(</span><span class="n">map-arbol</span> <span class="n">f</span> <span class="p">(</span><span class="nb">car</span> <span class="n">bosque</span><span class="p">))</span>
             <span class="p">(</span><span class="n">map-bosque</span> <span class="n">f</span> <span class="p">(</span><span class="nb">cdr</span> <span class="n">bosque</span><span class="p">)))))</span>
</code></pre></div>
</td></tr></table>

Ejemplos:

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><code><span class="p">(</span><span class="n">map-arbol</span> <span class="n">cuadrado</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">2</span> <span class="p">(</span><span class="mi">3</span> <span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="p">(</span><span class="mi">5</span><span class="p">))</span> <span class="p">(</span><span class="mi">6</span><span class="p">)))</span>
<span class="c1">; ⇒ (4 (9 (16) (25)) (36))</span>
<span class="p">(</span><span class="n">map-arbol</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">+</span> <span class="n">x</span> <span class="mi">1</span><span class="p">))</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">2</span> <span class="p">(</span><span class="mi">3</span> <span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="p">(</span><span class="mi">5</span><span class="p">))</span> <span class="p">(</span><span class="mi">6</span><span class="p">)))</span>
<span class="c1">; ⇒ (3 (4 (5) (6)) (7))</span>
</code></pre></div>
</td></tr></table>

Con `map`:

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><code><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="n">map-arbol-fos</span> <span class="n">f</span> <span class="n">arbol</span><span class="p">)</span>
  <span class="p">(</span><span class="n">construye-arbol</span> <span class="p">(</span><span class="n">f</span> <span class="p">(</span><span class="n">dato-arbol</span> <span class="n">arbol</span><span class="p">))</span>
             <span class="p">(</span><span class="nb">map</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="n">x</span><span class="p">)</span>
                    <span class="p">(</span><span class="n">map-arbol-fos</span> <span class="n">f</span> <span class="n">x</span><span class="p">))</span> <span class="p">(</span><span class="n">hijos-arbol</span> <span class="n">arbol</span><span class="p">))))</span>
</code></pre></div>
</td></tr></table>


#### Función `altura-arbol`

Vamos por último a definir una función que devuelve la altura de un
árbol (el nivel del nodo de mayor nivel). Un nodo hoja tiene de altura
0.

Podemos implementarla de una forma similar a como hicimos con las
listas estructuradas: comprobamos la altura del bosque y sumamos uno
para compensar el nivel de la raíz.

Para calcular la altura del bosque, devolvemos la máxima altura de sus
árboles.

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><code><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="n">altura-arbol</span> <span class="n">arbol</span><span class="p">)</span>
   <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="n">hoja-arbol?</span> <span class="n">arbol</span><span class="p">)</span>
       <span class="mi">0</span>
       <span class="p">(</span><span class="nb">+</span> <span class="mi">1</span> <span class="p">(</span><span class="n">altura-bosque</span> <span class="p">(</span><span class="n">hijos-arbol</span> <span class="n">arbol</span><span class="p">)))))</span>  

<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="n">altura-bosque</span> <span class="n">bosque</span><span class="p">)</span>
    <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">null?</span> <span class="n">bosque</span><span class="p">)</span>
        <span class="mi">0</span>
        <span class="p">(</span><span class="nb">max</span> <span class="p">(</span><span class="n">altura-arbol</span> <span class="p">(</span><span class="nb">car</span> <span class="n">bosque</span><span class="p">))</span>
             <span class="p">(</span><span class="n">altura-bosque</span> <span class="p">(</span><span class="nb">cdr</span> <span class="n">bosque</span><span class="p">)))))</span>
</code></pre></div>
</td></tr></table>

Ejemplos:


<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><code><span class="p">(</span><span class="n">altura-arbol</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span> <span class="c1">;  ⇒ 0</span>
<span class="p">(</span><span class="n">altura-arbol</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">4</span> <span class="p">(</span><span class="mi">9</span> <span class="p">(</span><span class="mi">16</span><span class="p">)</span> <span class="p">(</span><span class="mi">25</span><span class="p">))</span> <span class="p">(</span><span class="mi">36</span><span class="p">)))</span> <span class="c1">; ⇒ 2</span>
</code></pre></div>
</td></tr></table>

La solución con funciones de orden superior es algo distinta de la
que vimos con listas estructuradas

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><code><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="n">altura-arbol-fos</span> <span class="n">arbol</span><span class="p">)</span>
   <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="n">hoja-arbol?</span> <span class="n">arbol</span><span class="p">)</span>
       <span class="mi">0</span>
      <span class="p">(</span><span class="nb">+</span> <span class="mi">1</span>  <span class="p">(</span><span class="n">fold-right</span> <span class="nb">max</span> <span class="mi">0</span>
                           <span class="p">(</span><span class="nb">map</span> <span class="n">altura-arbol-fos</span> <span class="p">(</span><span class="n">hijos-arbol</span> <span class="n">arbol</span><span class="p">))))))</span>
</code></pre></div>
</td></tr></table>

La función `map` mapea sobre los árboles hijos la propia función, que
calcula la altura de cada hijo (será uno menos que la altura del padre, 0
si se trata de una hoja).

La función `map` devuelve entonces una lista altura de los hijos, de
la que obtenemos el máximo plegando la lista con la función `max`. 

Por último sumamos 1 para devolver la altura del árbol completo (un
nivel más que el nivel máximo de los hijos).

## Arboles binarios

### Definición de árboles binarios en Scheme

Los árboles binarios son árboles cuyos nodos tienen 0, 1 o 2
hijos. Por ejemplo, el árbol mostrado en la siguiente figura es un
árbol binario.

<img src="imagenes/binario-2.png" width="300px"/>

A diferencia de los árboles genéricos vistos anteriormente un árbol
binario no puede tener más de dos hijos.

Los representaremos en Scheme utilizando una lista de tres elementos:

- Dato
- Hijo izquierdo (otro árbol binario)
- Hijo derecho (otro árbol binario)

En el caso en que no exista el hijo izquierdo o el derecho (o ambos)
utilizaremos una lista vacía para indicar un nodo vacío.

De esta manera, un nodo hoja con el dato 10 se representará en Scheme con la lista:

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><code><span class="p">(</span><span class="mi">10</span> <span class="p">()</span> <span class="p">())</span>
</code></pre></div>
</td></tr></table>

Por ejemplo, representamos el árbol de la figura anterior con la
siguiente lista:

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><code><span class="p">(</span><span class="mi">40</span> <span class="p">(</span><span class="mi">18</span> <span class="p">(</span><span class="mi">3</span> <span class="p">()</span> <span class="p">())</span>
        <span class="p">(</span><span class="mi">23</span> <span class="p">()</span>
            <span class="p">(</span><span class="mi">29</span> <span class="p">()</span> <span class="p">())))</span>
    <span class="p">(</span><span class="mi">52</span> <span class="p">(</span><span class="mi">47</span> <span class="p">()</span> <span class="p">())</span>
        <span class="p">()))</span>
</code></pre></div>
</td></tr></table>

#### Barrera de abstracción ####

Definimos la siguiente barrera de abstracción para los árboles
binarios. Terminamos todos los nombres de las funciones con el sufijo
`-arbolb` (árbol binario).

**Selectores**

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><code><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="n">dato-arbolb</span> <span class="n">arbol</span><span class="p">)</span>
   <span class="p">(</span><span class="nb">car</span> <span class="n">arbol</span><span class="p">))</span>

<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="n">hijo-izq-arbolb</span> <span class="n">arbol</span><span class="p">)</span>
   <span class="p">(</span><span class="nb">cadr</span> <span class="n">arbol</span><span class="p">))</span>

<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="n">hijo-der-arbolb</span> <span class="n">arbol</span><span class="p">)</span>
   <span class="p">(</span><span class="nb">caddr</span> <span class="n">arbol</span><span class="p">))</span>

<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="n">vacio-arbolb?</span> <span class="n">arbol</span><span class="p">)</span>
   <span class="p">(</span><span class="nb">null?</span> <span class="n">arbol</span><span class="p">))</span>

<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="n">hoja-arbolb?</span> <span class="n">arbol</span><span class="p">)</span>
   <span class="p">(</span><span class="k">and</span> <span class="p">(</span><span class="n">vacio-arbolb?</span> <span class="p">(</span><span class="n">hijo-izq-arbolb</span> <span class="n">arbol</span><span class="p">))</span>
        <span class="p">(</span><span class="n">vacio-arbolb?</span> <span class="p">(</span><span class="n">hijo-der-arbolb</span> <span class="n">arbol</span><span class="p">))))</span>

<span class="p">(</span><span class="k">define</span> <span class="n">arbolb-vacio</span> <span class="o">&#39;</span><span class="p">())</span>
</code></pre></div>
</td></tr></table>

**Constructor**

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><code><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="n">construye-arbolb</span> <span class="n">dato</span> <span class="n">hijo-izq</span> <span class="n">hijo-der</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">list</span> <span class="n">dato</span> <span class="n">hijo-izq</span> <span class="n">hijo-der</span><span class="p">))</span>
</code></pre></div>
</td></tr></table>

Por ejemplo, para construir un árbol con 10 en la raíz y 8 en su hijo
izquierdo y 15 en su derecho utilizando el constructor de la barrera
de abstracción:

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><code><span class="p">(</span><span class="k">define</span> <span class="n">arbolb1</span>
   <span class="p">(</span><span class="n">construye-arbolb</span> <span class="mi">10</span> <span class="p">(</span><span class="n">construye-arbolb</span> <span class="mi">8</span> <span class="n">arbolb-vacio</span> <span class="n">arbolb-vacio</span><span class="p">)</span>
                        <span class="p">(</span><span class="n">construye-arbolb</span> <span class="mi">15</span> <span class="n">arbolb-vacio</span> <span class="n">arbolb-vacio</span><span class="p">)))</span>
</code></pre></div>
</td></tr></table>

Otro ejemplo, el árbol binario de la figura anterior utilizando el
constructor de la barrera de abstracción:

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><code><span class="p">(</span><span class="k">define</span> <span class="n">arbolb2</span>
   <span class="p">(</span><span class="n">construye-arbolb</span> <span class="mi">40</span> 
                    <span class="p">(</span><span class="n">construye-arbolb</span> <span class="mi">18</span>
                                      <span class="p">(</span><span class="n">construye-arbolb</span> <span class="mi">3</span> <span class="n">arbolb-vacio</span> <span class="n">arbolb-vacio</span><span class="p">)</span>
                                      <span class="p">(</span><span class="n">construye-arbolb</span> <span class="mi">23</span> 
                                                        <span class="n">arbolb-vacio</span>
                                                        <span class="p">(</span><span class="n">construye-arbolb</span> <span class="mi">29</span> 
                                                                          <span class="n">arbolb-vacio</span>
                                                                          <span class="n">arbolb-vacio</span><span class="p">)))</span>
                    <span class="p">(</span><span class="n">construye-arbolb</span> <span class="mi">52</span>
                                      <span class="p">(</span><span class="n">construye-arbolb</span> <span class="mi">47</span> <span class="n">arbolb-vacio</span> <span class="n">arbolb-vacio</span><span class="p">)</span>
                                      <span class="n">arbolb-vacio</span><span class="p">)))</span>
</code></pre></div>
</td></tr></table>

### Funciones recursivas sobre árboles binarios

Veamos las siguientes funciones recursivas sobre árboles binarios:

* `(suma-datos-arbolb arbol)`: devuelve la suma de todos los nodos
* `(to-list-arbolb arbol)`: devuelve una lista con los datos del árbol
* `(cuadrado-arbolb arbol)`: eleva al cuadrado todos los datos de un
  árbol manteniendo la estructura del árbol original

Estas funciones utilizan una mezcla de los patrones usados en la
recursión para trabajar con árboles genéricos y la recursión para
trabajar con listas estructuradas. Tenemos un dato en la raíz, que
tenemos que combinar con lo que devuelve la recursión aplicada sobre
el hijo izquierdo y lo que devuelve la recursión aplicada sobre el
hijo derecho.


**suma-datos-arbolb**

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><code><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="n">suma-datos-arbolb</span> <span class="n">arbol</span><span class="p">)</span>
   <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="n">vacio-arbolb?</span> <span class="n">arbol</span><span class="p">)</span>
      <span class="mi">0</span>
      <span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="n">dato-arbolb</span> <span class="n">arbol</span><span class="p">)</span>
         <span class="p">(</span><span class="n">suma-datos-arbolb</span> <span class="p">(</span><span class="n">hijo-izq-arbolb</span> <span class="n">arbol</span><span class="p">))</span>
         <span class="p">(</span><span class="n">suma-datos-arbolb</span> <span class="p">(</span><span class="n">hijo-der-arbolb</span> <span class="n">arbol</span><span class="p">)))))</span>

<span class="p">(</span><span class="n">suma-datos-arbolb</span> <span class="n">arbolb2</span><span class="p">)</span> <span class="c1">; ⇒ 212</span>
</code></pre></div>
</td></tr></table>


**to-list-arbolb**

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><code><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="n">to-list-arbolb</span> <span class="n">arbol</span><span class="p">)</span>
   <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="n">vacio-arbolb?</span> <span class="n">arbol</span><span class="p">)</span>
      <span class="o">&#39;</span><span class="p">()</span>
      <span class="p">(</span><span class="nb">cons</span> <span class="p">(</span><span class="n">dato-arbolb</span> <span class="n">arbol</span><span class="p">)</span>
            <span class="p">(</span><span class="nb">append</span> <span class="p">(</span><span class="n">to-list-arbolb</span> <span class="p">(</span><span class="n">hijo-izq-arbolb</span> <span class="n">arbol</span><span class="p">))</span>
                    <span class="p">(</span><span class="n">to-list-arbolb</span> <span class="p">(</span><span class="n">hijo-der-arbolb</span> <span class="n">arbol</span><span class="p">))))))</span>

<span class="p">(</span><span class="n">to-list-arbolb</span> <span class="n">arbolb2</span><span class="p">)</span> <span class="c1">; ⇒ (40 18 3 23 29 52 47)</span>
</code></pre></div>
</td></tr></table>


**cuadrado-arbolb**

Por último, la función `cuadrado-arbolb` construye un nuevo árbol
binario elevando al cuadrado el dato de la raíz, su hijo izquierdo y
su hijo derecho. Para construir el árbol binario llamamos al
constructor `construye-arbolb`.

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><code><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="n">cuadrado-arbolb</span> <span class="n">arbol</span><span class="p">)</span>
   <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="n">vacio-arbolb?</span> <span class="n">arbol</span><span class="p">)</span>
      <span class="n">arbolb-vacio</span>
      <span class="p">(</span><span class="n">construye-arbolb</span> <span class="p">(</span><span class="n">cuadrado</span> <span class="p">(</span><span class="n">dato-arbolb</span> <span class="n">arbol</span><span class="p">))</span>
                        <span class="p">(</span><span class="n">cuadrado-arbolb</span> <span class="p">(</span><span class="n">hijo-izq-arbolb</span> <span class="n">arbol</span><span class="p">))</span>
                        <span class="p">(</span><span class="n">cuadrado-arbolb</span> <span class="p">(</span><span class="n">hijo-der-arbolb</span> <span class="n">arbol</span><span class="p">)))))</span>

<span class="p">(</span><span class="n">cuadrado-arbolb</span> <span class="n">arbolb1</span><span class="p">)</span> <span class="c1">; ⇒ (100 (64 () ()) (225 () ()))</span>
</code></pre></div>
</td></tr></table>

-->

<h2 id="bibliografia-sicp">Bibliografía - SICP<a class="headerlink" href="#bibliografia-sicp" title="Permanent link">&para;</a></h2>
<p>En este tema explicamos conceptos de los siguientes capítulos del libro <em>Structure and Intepretation of Computer Programs</em>:</p>
<ul>
<li><a href="https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book-Z-H-15.html#%_sec_2.2.2">2.2.2 - Hierarchical Structures</a></li>
</ul>
<hr />
<p>Lenguajes y Paradigmas de Programación, curso 2019-20<br />
© Departamento Ciencia de la Computación e Inteligencia Artificial, Universidad de Alicante<br />
Domingo Gallardo, Cristina Pomares, Antonio Botía, Francisco Martínez</p>
                
                  
                
                
              
              
                


              
            </article>
          </div>
        </div>
      </main>
      
        
<footer class="md-footer">
  
    <div class="md-footer-nav">
      <nav class="md-footer-nav__inner md-grid">
        
          <a href="../tema03-procedimientos-recursivos/tema03-procedimientos-recursivos.html" title="Tema 3: Procedimientos recursivos" class="md-flex md-footer-nav__link md-footer-nav__link--prev" rel="prev">
            <div class="md-flex__cell md-flex__cell--shrink">
              <i class="md-icon md-icon--arrow-back md-footer-nav__button"></i>
            </div>
            <div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
              <span class="md-flex__ellipsis">
                <span class="md-footer-nav__direction">
                  Anterior
                </span>
                Tema 3: Procedimientos recursivos
              </span>
            </div>
          </a>
        
        
          <a href="../../seminarios/seminario1-scheme/seminario1-scheme.html" title="Seminario de Scheme" class="md-flex md-footer-nav__link md-footer-nav__link--next" rel="next">
            <div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
              <span class="md-flex__ellipsis">
                <span class="md-footer-nav__direction">
                  Siguiente
                </span>
                Seminario de Scheme
              </span>
            </div>
            <div class="md-flex__cell md-flex__cell--shrink">
              <i class="md-icon md-icon--arrow-forward md-footer-nav__button"></i>
            </div>
          </a>
        
      </nav>
    </div>
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-footer-copyright">
        
        powered by
        <a href="https://www.mkdocs.org" target="_blank" rel="noopener">MkDocs</a>
        and
        <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
          Material for MkDocs</a>
      </div>
      
    </div>
  </div>
</footer>
      
    </div>
    
      <script src="../../assets/javascripts/application.c33a9706.js"></script>
      
      <script>app.initialize({version:"1.1",url:{base:"../.."}})</script>
      
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML"></script>
      
    
  </body>
</html>