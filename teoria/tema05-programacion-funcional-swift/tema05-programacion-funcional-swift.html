



<!doctype html>
<html lang="es" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      <meta http-equiv="x-ua-compatible" content="ie=edge">
      
      
      
      
        <meta name="lang:clipboard.copy" content="Copiar al portapapeles">
      
        <meta name="lang:clipboard.copied" content="Copiado al portapapeles">
      
        <meta name="lang:search.language" content="en">
      
        <meta name="lang:search.pipeline.stopwords" content="True">
      
        <meta name="lang:search.pipeline.trimmer" content="True">
      
        <meta name="lang:search.result.none" content="No se encontraron documentos">
      
        <meta name="lang:search.result.one" content="1 documento encontrado">
      
        <meta name="lang:search.result.other" content="# documentos encontrados">
      
        <meta name="lang:search.tokenizer" content="[\s\-]+">
      
      <link rel="shortcut icon" href="../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.0.4, mkdocs-material-4.4.0">
    
    
      
        <title>Tema 5: Programación funcional con Swift - LPP</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/application.0284f74d.css">
      
        <link rel="stylesheet" href="../../assets/stylesheets/application-palette.01803549.css">
      
      
        
        
        <meta name="theme-color" content="#009688">
      
    
    
      <script src="../../assets/javascripts/modernizr.74668098.js"></script>
    
    
      
        <link href="https://fonts.gstatic.com" rel="preconnect" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700|Roboto+Mono&display=fallback">
        <style>body,input{font-family:"Roboto","Helvetica Neue",Helvetica,Arial,sans-serif}code,kbd,pre{font-family:"Roboto Mono","Courier New",Courier,monospace}</style>
      
    
    <link rel="stylesheet" href="../../assets/fonts/material-icons.css">
    
    
    
      
    
    
  </head>
  
    
    
    <body dir="ltr" data-md-color-primary="teal" data-md-color-accent="teal">
  
    <svg class="md-svg">
      <defs>
        
        
      </defs>
    </svg>
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" data-md-component="overlay" for="__drawer"></label>
    
      <a href="#tema-5-programacion-funcional-con-swift" tabindex="1" class="md-skip">
        Saltar a contenido
      </a>
    
    
      <header class="md-header" data-md-component="header">
  <nav class="md-header-nav md-grid">
    <div class="md-flex">
      <div class="md-flex__cell md-flex__cell--shrink">
        <a href="../.." title="LPP" class="md-header-nav__button md-logo">
          
            <img src="../../imagenes/logo.png" width="24" height="24">
          
        </a>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        <label class="md-icon md-icon--menu md-header-nav__button" for="__drawer"></label>
      </div>
      <div class="md-flex__cell md-flex__cell--stretch">
        <div class="md-flex__ellipsis md-header-nav__title" data-md-component="title">
          
            <span class="md-header-nav__topic">
              LPP
            </span>
            <span class="md-header-nav__topic">
              
                Tema 5: Programación funcional con Swift
              
            </span>
          
        </div>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        
          <label class="md-icon md-icon--search md-header-nav__button" for="__search"></label>
          
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" placeholder="Búsqueda" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="query" data-md-state="active">
      <label class="md-icon md-search__icon" for="__search"></label>
      <button type="reset" class="md-icon md-search__icon" data-md-component="reset" tabindex="-1">
        &#xE5CD;
      </button>
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="result">
          <div class="md-search-result__meta">
            Teclee para comenzar búsqueda
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
        
      </div>
      
    </div>
  </nav>
</header>
    
    <div class="md-container">
      
        
      
      
      <main class="md-main">
        <div class="md-main__inner md-grid" data-md-component="container">
          
            
              <div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    <nav class="md-nav md-nav--primary" data-md-level="0">
  <label class="md-nav__title md-nav__title--site" for="__drawer">
    <a href="../.." title="LPP" class="md-nav__button md-logo">
      
        <img src="../../imagenes/logo.png" width="48" height="48">
      
    </a>
    LPP
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      

  


  <li class="md-nav__item md-nav__item--active md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-1" type="checkbox" id="nav-1" checked>
    
    <label class="md-nav__link" for="nav-1">
      Teoría
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-1">
        Teoría
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../tema00-descripcion-asignatura/tema00-descripcion-asignatura.html" title="Descripción de la asignatura" class="md-nav__link">
      Descripción de la asignatura
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../tema01-historia-lenguajes-programacion/tema01-historia-lenguajes-programacion.html" title="Tema 1: Historia de los lenguajes de programación" class="md-nav__link">
      Tema 1: Historia de los lenguajes de programación
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../tema02-programacion-funcional/tema02-programacion-funcional.html" title="Tema 2: Programación funcional" class="md-nav__link">
      Tema 2: Programación funcional
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../tema03-procedimientos-recursivos/tema03-procedimientos-recursivos.html" title="Tema 3: Procedimientos recursivos" class="md-nav__link">
      Tema 3: Procedimientos recursivos
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../tema04-estructuras-recursivas/tema04-estructuras-recursivas.html" title="Tema 4: Estructuras recursivas" class="md-nav__link">
      Tema 4: Estructuras recursivas
    </a>
  </li>

        
          
          
          

  


  <li class="md-nav__item md-nav__item--active">
    
    <input class="md-toggle md-nav__toggle" data-md-toggle="toc" type="checkbox" id="__toc">
    
      
    
    
      <label class="md-nav__link md-nav__link--active" for="__toc">
        Tema 5: Programación funcional con Swift
      </label>
    
    <a href="tema05-programacion-funcional-swift.html" title="Tema 5: Programación funcional con Swift" class="md-nav__link md-nav__link--active">
      Tema 5: Programación funcional con Swift
    </a>
    
      
<nav class="md-nav md-nav--secondary">
  
  
    
  
  
    <label class="md-nav__title" for="__toc">Tabla de contenidos</label>
    <ul class="md-nav__list" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#1-introduccion" title="1. Introducción" class="md-nav__link">
    1. Introducción
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#12-conceptos-fundamentales-de-programacion-funcional" title="1.2. Conceptos fundamentales de Programación Funcional" class="md-nav__link">
    1.2. Conceptos fundamentales de Programación Funcional
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#13-caracteristicas-basicas-de-swift" title="1.3. Características básicas de Swift" class="md-nav__link">
    1.3. Características básicas de Swift
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#2-inmutabilidad" title="2. Inmutabilidad" class="md-nav__link">
    2. Inmutabilidad
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#21-creacion-de-nuevas-estructuras-y-mutacion" title="2.1. Creación de nuevas estructuras y mutación" class="md-nav__link">
    2.1. Creación de nuevas estructuras y mutación
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#3-funciones" title="3. Funciones" class="md-nav__link">
    3. Funciones
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#31-definicion-de-una-funcion-en-swift" title="3.1. Definición de una función en Swift" class="md-nav__link">
    3.1. Definición de una función en Swift
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#32-etiquetas-de-argumentos-y-nombres-de-parametros" title="3.2. Etiquetas de argumentos y nombres de parámetros" class="md-nav__link">
    3.2. Etiquetas de argumentos y nombres de parámetros
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#33-parametros-y-valores-devueltos" title="3.3. Parámetros y valores devueltos" class="md-nav__link">
    3.3. Parámetros y valores devueltos
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#4-recursion" title="4. Recursión" class="md-nav__link">
    4. Recursión
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#5-tipos-funcion" title="5. Tipos función" class="md-nav__link">
    5. Tipos función
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#51-funciones-que-reciben-otras-funciones" title="5.1. Funciones que reciben otras funciones" class="md-nav__link">
    5.1. Funciones que reciben otras funciones
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#52-funciones-en-estructuras" title="5.2. Funciones en estructuras" class="md-nav__link">
    5.2. Funciones en estructuras
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#53-funciones-que-devuelven-otras-funciones" title="5.3 Funciones que devuelven otras funciones" class="md-nav__link">
    5.3 Funciones que devuelven otras funciones
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#6-tipos" title="6. Tipos" class="md-nav__link">
    6. Tipos
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#61-tipos-con-nombre" title="6.1. Tipos con nombre" class="md-nav__link">
    6.1. Tipos con nombre
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#62-tipos-compuestos" title="6.2. Tipos compuestos" class="md-nav__link">
    6.2. Tipos compuestos
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#63-tipos-valor-y-tipos-referencia" title="6.3. Tipos valor y tipos referencia" class="md-nav__link">
    6.3. Tipos valor y tipos referencia
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#7-enumeraciones" title="7. Enumeraciones" class="md-nav__link">
    7. Enumeraciones
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#71-valores-brutos-de-enumeraciones" title="7.1. Valores brutos de enumeraciones" class="md-nav__link">
    7.1. Valores brutos de enumeraciones
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#8-enumeraciones-instanciables" title="8. Enumeraciones instanciables" class="md-nav__link">
    8. Enumeraciones instanciables
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#81-valores-asociados-a-instancias-de-enumeraciones" title="8.1. Valores asociados a instancias de enumeraciones" class="md-nav__link">
    8.1. Valores asociados a instancias de enumeraciones
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#82-enumeraciones-recursivas" title="8.2. Enumeraciones recursivas" class="md-nav__link">
    8.2. Enumeraciones recursivas
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
      
      
      
      
    </ul>
  
</nav>
    
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-2" type="checkbox" id="nav-2">
    
    <label class="md-nav__link" for="nav-2">
      Seminarios
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-2">
        Seminarios
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../seminarios/seminario1-scheme/seminario1-scheme.html" title="Seminario de Scheme" class="md-nav__link">
      Seminario de Scheme
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../seminarios/seminario2-swift/seminario2-swift.html" title="Seminario de Swift" class="md-nav__link">
      Seminario de Swift
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-3" type="checkbox" id="nav-3">
    
    <label class="md-nav__link" for="nav-3">
      Prácticas
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-3">
        Prácticas
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../practicas/buenas-practicas-programacion-funcional.html" title="Buenas prácticas de programación funcional" class="md-nav__link">
      Buenas prácticas de programación funcional
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../practicas/practica01/practica01.html" title="Práctica 1" class="md-nav__link">
      Práctica 1
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../practicas/practica02/practica02.html" title="Práctica 2" class="md-nav__link">
      Práctica 2
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../practicas/practica03/practica03.html" title="Práctica 3" class="md-nav__link">
      Práctica 3
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../practicas/practica04/practica04.html" title="Práctica 4" class="md-nav__link">
      Práctica 4
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../practicas/practica05/practica05.html" title="Práctica 5" class="md-nav__link">
      Práctica 5
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../practicas/practica06/practica06.html" title="Práctica 6" class="md-nav__link">
      Práctica 6
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../practicas/practica07/practica07.html" title="Práctica 7" class="md-nav__link">
      Práctica 7
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../practicas/practica08/practica08.html" title="Práctica 8" class="md-nav__link">
      Práctica 8
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              <div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    
<nav class="md-nav md-nav--secondary">
  
  
    
  
  
    <label class="md-nav__title" for="__toc">Tabla de contenidos</label>
    <ul class="md-nav__list" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#1-introduccion" title="1. Introducción" class="md-nav__link">
    1. Introducción
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#12-conceptos-fundamentales-de-programacion-funcional" title="1.2. Conceptos fundamentales de Programación Funcional" class="md-nav__link">
    1.2. Conceptos fundamentales de Programación Funcional
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#13-caracteristicas-basicas-de-swift" title="1.3. Características básicas de Swift" class="md-nav__link">
    1.3. Características básicas de Swift
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#2-inmutabilidad" title="2. Inmutabilidad" class="md-nav__link">
    2. Inmutabilidad
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#21-creacion-de-nuevas-estructuras-y-mutacion" title="2.1. Creación de nuevas estructuras y mutación" class="md-nav__link">
    2.1. Creación de nuevas estructuras y mutación
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#3-funciones" title="3. Funciones" class="md-nav__link">
    3. Funciones
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#31-definicion-de-una-funcion-en-swift" title="3.1. Definición de una función en Swift" class="md-nav__link">
    3.1. Definición de una función en Swift
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#32-etiquetas-de-argumentos-y-nombres-de-parametros" title="3.2. Etiquetas de argumentos y nombres de parámetros" class="md-nav__link">
    3.2. Etiquetas de argumentos y nombres de parámetros
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#33-parametros-y-valores-devueltos" title="3.3. Parámetros y valores devueltos" class="md-nav__link">
    3.3. Parámetros y valores devueltos
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#4-recursion" title="4. Recursión" class="md-nav__link">
    4. Recursión
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#5-tipos-funcion" title="5. Tipos función" class="md-nav__link">
    5. Tipos función
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#51-funciones-que-reciben-otras-funciones" title="5.1. Funciones que reciben otras funciones" class="md-nav__link">
    5.1. Funciones que reciben otras funciones
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#52-funciones-en-estructuras" title="5.2. Funciones en estructuras" class="md-nav__link">
    5.2. Funciones en estructuras
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#53-funciones-que-devuelven-otras-funciones" title="5.3 Funciones que devuelven otras funciones" class="md-nav__link">
    5.3 Funciones que devuelven otras funciones
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#6-tipos" title="6. Tipos" class="md-nav__link">
    6. Tipos
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#61-tipos-con-nombre" title="6.1. Tipos con nombre" class="md-nav__link">
    6.1. Tipos con nombre
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#62-tipos-compuestos" title="6.2. Tipos compuestos" class="md-nav__link">
    6.2. Tipos compuestos
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#63-tipos-valor-y-tipos-referencia" title="6.3. Tipos valor y tipos referencia" class="md-nav__link">
    6.3. Tipos valor y tipos referencia
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#7-enumeraciones" title="7. Enumeraciones" class="md-nav__link">
    7. Enumeraciones
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#71-valores-brutos-de-enumeraciones" title="7.1. Valores brutos de enumeraciones" class="md-nav__link">
    7.1. Valores brutos de enumeraciones
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#8-enumeraciones-instanciables" title="8. Enumeraciones instanciables" class="md-nav__link">
    8. Enumeraciones instanciables
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#81-valores-asociados-a-instancias-de-enumeraciones" title="8.1. Valores asociados a instancias de enumeraciones" class="md-nav__link">
    8.1. Valores asociados a instancias de enumeraciones
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#82-enumeraciones-recursivas" title="8.2. Enumeraciones recursivas" class="md-nav__link">
    8.2. Enumeraciones recursivas
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
      
      
      
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content">
            <article class="md-content__inner md-typeset">
              
                
                
                <h1 id="tema-5-programacion-funcional-con-swift">Tema 5: Programación Funcional con Swift<a class="headerlink" href="#tema-5-programacion-funcional-con-swift" title="Permanent link">&para;</a></h1>
<h2 id="1-introduccion">1. Introducción<a class="headerlink" href="#1-introduccion" title="Permanent link">&para;</a></h2>
<p>Te recomendamos que leas el seminario de Swift
en el que se introduce el lenguaje y se explica cómo ejecutar
programas en este lenguaje:</p>
<ul>
<li><a href="../../seminarios/seminario2-swift/seminario2-swift.html">Seminario de Swift</a></li>
</ul>
<h3 id="12-conceptos-fundamentales-de-programacion-funcional">1.2. Conceptos fundamentales de Programación Funcional<a class="headerlink" href="#12-conceptos-fundamentales-de-programacion-funcional" title="Permanent link">&para;</a></h3>
<p>Vamos a repasar en este tema cómo se implementan en Swift conceptos
principalmente funcionales como:</p>
<ul>
<li>Valores inmutables</li>
<li>Tipos de datos recursivos</li>
<li>Funciones como objetos de primera clase y clasuras</li>
<li>Funciones de orden superior</li>
</ul>
<p>Repasamos rápidamente algunos conceptos básicos de programación
funcional, vistos en los primeros temas de la asignatura.</p>
<p>Programación Funcional:</p>
<blockquote>
<p>La Programación Funcional es un paradigma de programación que trata
la computación como la evaluación de funciones matemáticas y que
evita cambios de estado y datos mutables.</p>
</blockquote>
<p>Funciones matemáticas o puras:</p>
<blockquote>
<p>Las funciones matemáticas tienen la característica de que cuando las
invocas con el mismo argumento siempre te devolverán el mismo
resultado.</p>
</blockquote>
<p>Funciones como objetos de primera clase:</p>
<blockquote>
<p>En programación funcional, las funciones son objetos de primera
clase del lenguaje, similares a enteros o <em>strings</em>. Podemos pasar
funciones como argumentos en las denominadas <em>funciones de orden
superior</em> o devolver funciones creadas en tiempo de ejecución
(clausuras).</p>
</blockquote>
<h3 id="13-caracteristicas-basicas-de-swift">1.3. Características básicas de Swift<a class="headerlink" href="#13-caracteristicas-basicas-de-swift" title="Permanent link">&para;</a></h3>
<p>Swift es un lenguaje principalmente imperativo, pero en su diseño se
han introducido conceptos modernos de programación funcional,
extraídos de lenguajes como Rust o Haskell. Por ello se puede
considerar un lenguaje <strong>multi-paradigma</strong>, en el que se puede definir
código funcional que se puede ejecutar junto con código imperativo.</p>
<p>Como dice su creador <a href="http://nondot.org/sabre/">Chris Lattner</a>:</p>
<blockquote>
<p>El lenguaje Swift es el resultado de un esfuerzo incansable de un
equipo de expertos en lenguajes, gurús de documentación, ninjas de
optimización de compiladores [..]. Por supuesto, también se
benefició enormemente de las experiencias ganadas en muchos otros
lenguajes, tomando ideas de Objective-C, Rust, Haskell, Ruby,
Python, C#, CLU, y demasiados otros para ser enumerados.</p>
</blockquote>
<h4>1.3.1. Lenguaje fuertemente tipado</h4>
<p>A diferencia de Scheme, Swift es un lenguaje <strong>fuertemente tipado</strong> en el
que hay que definir los tipos de variables, parámetros y
funciones.</p>
<p>Por ejemplo, en las siguientes declaraciones definimos variables de
distintos tipos:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">let</span> <span class="nv">n</span><span class="p">:</span> <span class="nb">Int</span> <span class="p">=</span> <span class="mi">10</span>
<span class="kd">let</span> <span class="nv">str</span><span class="p">:</span> <span class="nb">String</span> <span class="p">=</span> <span class="s">&quot;Hola&quot;</span>
<span class="kd">let</span> <span class="nv">array</span><span class="p">:</span> <span class="p">[</span><span class="nb">Int</span><span class="p">]</span> <span class="p">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
</pre></div>
</td></tr></table>

<p>El compilador de Swift permite identificar los tipos de las variables
cuando se realiza una asignación. La técnica se denomina <strong>inferencia
de tipos</strong> y permite declarar variables sin escribir su tipo. Por
ejemplo, las variables anteriores se pueden declarar también asi:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">let</span> <span class="nv">n</span> <span class="p">=</span> <span class="mi">10</span>
<span class="kd">let</span> <span class="nv">str</span> <span class="p">=</span> <span class="s">&quot;Hola&quot;</span>
<span class="kd">let</span> <span class="nv">array</span> <span class="p">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
</pre></div>
</td></tr></table>

<p>Aunque no hayamos declarado explícitamente el tipo de las variables,
el compilador les ha asignado el tipo correspondiente. Por ejemplo, no
podemos asignarles un valor de distinto tipo:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">var</span> <span class="nv">x</span> <span class="p">=</span> <span class="mi">5</span>
<span class="n">x</span> <span class="p">=</span> <span class="mi">4</span> <span class="c1">// correcto</span>
<span class="n">x</span> <span class="p">=</span> <span class="mf">6.0</span> <span class="c1">// error</span>
<span class="c1">// error: cannot assign value of type &#39;Double&#39; to type &#39;Int&#39;</span>
<span class="c1">// x = 5.0</span>
<span class="c1">//     ^~~</span>
<span class="c1">//    Int( )</span>
</pre></div>
</td></tr></table>

<p>El compilador indica el error e incluso sugiere una posible solución
del mismo. En este caso llamar al constructor <code>Int()</code> pasándole un
<code>Double</code> como parámetro.</p>
<h4>1.3.2. Lenguaje multi-paradigma</h4>
<p>Swift permite combinar características funcionales con características
imperativas y de programación orientada a objetos. Veremos en este
tema muchas características funcionales que podremos utilizar en
cualquier programa Swift que desarrollemos.</p>
<p>Por ejemplo, cuando declaramos una variable podemos declararla como
mutable, usando la declaración <code>var</code>, o como inmutable, usando la
declaración <code>let</code>. Si queremos utilizar un enfoque funcional
preferiremos siempre declarar las variables con <code>let</code>. </p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">var</span> <span class="nv">x</span> <span class="p">=</span> <span class="mi">10</span>
<span class="n">x</span> <span class="p">=</span> <span class="mi">20</span> <span class="c1">// x es mutable</span>
<span class="kd">let</span> <span class="nv">y</span> <span class="p">=</span> <span class="mi">10</span>
<span class="n">y</span> <span class="p">=</span> <span class="mi">20</span> <span class="c1">// error: y es inmutable</span>
</pre></div>
</td></tr></table>

<p>Una ventaja de la inmutabilidad es que permite que el compilador de
Swift optimice el código de forma muy eficiente. De hecho, el propio
compilador nos indica que es preferible definir una variable como
<code>let</code> si no la vamos a modificar:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">func</span> <span class="nf">saluda</span><span class="p">(</span><span class="n">nombre</span><span class="p">:</span> <span class="nb">String</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">String</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">saludo</span> <span class="p">=</span> <span class="s">&quot;Hola &quot;</span> <span class="o">+</span> <span class="n">nombre</span> <span class="o">+</span> <span class="s">&quot;!&quot;</span>
    <span class="k">return</span> <span class="n">saludo</span>
<span class="p">}</span>
<span class="c1">//warning: variable &#39;saludo&#39; was never mutated; consider changing to &#39;let&#39; constant</span>
<span class="c1">//    var saludo = &quot;Hola &quot; + nombre</span>
<span class="c1">//    ~~~ ^</span>
<span class="c1">//    let</span>
</pre></div>
</td></tr></table>

<h2 id="2-inmutabilidad">2. Inmutabilidad<a class="headerlink" href="#2-inmutabilidad" title="Permanent link">&para;</a></h2>
<p>Una de las características funcionales importantes de Swift es el
énfasis en la inmutabilidad para reforzar la seguridad del
lenguaje. </p>
<p>Hemos visto que la palabra clave <code>let</code> permite definir constantes y
que Swift recomienda su uso si el valor que definimos es un valor que
no va a ser modificado.</p>
<p>El valor asignado a una constante <code>let</code> puede no conocerse en tiempo
de compilación, sino que puede ser obtenido en tiempo de ejecución
como un valor devuelto por una función:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">let</span> <span class="nv">respuesta</span><span class="p">:</span> <span class="nb">String</span> <span class="p">=</span> <span class="n">respuestaUsuario</span><span class="p">.</span><span class="n">respuesta</span><span class="p">()</span>
</pre></div>
</td></tr></table>

<p>Al declarar una variable como <code>let</code> se bloquea su contenido y no se
permite su modificación. Una de las ventajas del paradigma funcional y
de la inmutabilidad es que garantiza que el código que escribimos no
tiene efectos laterales y puede ser ejecutado sin problemas en
entornos multi-procesador o multi-hilo.</p>
<h3 id="21-creacion-de-nuevas-estructuras-y-mutacion">2.1. Creación de nuevas estructuras y mutación<a class="headerlink" href="#21-creacion-de-nuevas-estructuras-y-mutacion" title="Permanent link">&para;</a></h3>
<p>En la <a href="https://developer.apple.com/documentation/swift/swift_standard_library">biblioteca estándar de
Swift</a>
existen una gran cantidad de estructuras (como <code>Int</code>, <code>Double</code>,
<code>Bool</code>, <code>String</code>, <code>Array</code>, <code>Dictionary</code>, etc.) que tienen dos tipos de
métodos: métodos que mutan la estructura y métodos que devuelven una
nueva estructura. Cuando estemos escribiendo código con estilo
funcional deberemos utilizar siempre estos últimos métodos, los que
construyen estructuras nuevas.</p>
<p>Por ejemplo, en el struct <code>Array</code> se define el método <code>sort</code> y el
método <code>sorted</code>. El primero ordena el array con mutación y el segundo
devuelve una copia ordenada, sin modificar el array original. En el
siguiente código no se modifica el array original, sino que se
construye un array nuevo ordenado:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="c1">// Código recomendable en programación funcional</span>
<span class="c1">// porque utiliza el método sorted que devuelve una</span>
<span class="c1">// copia del array original</span>
<span class="kd">let</span> <span class="nv">miArray</span> <span class="p">=</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">80</span><span class="p">]</span>
<span class="kd">let</span> <span class="nv">arrayOrdenado</span> <span class="p">=</span> <span class="n">miArray</span><span class="p">.</span><span class="bp">sorted</span><span class="p">()</span>
<span class="bp">print</span><span class="p">(</span><span class="n">miArray</span><span class="p">)</span>
<span class="bp">print</span><span class="p">(</span><span class="n">arrayOrdenado</span><span class="p">)</span>
<span class="c1">// Imprime:</span>
<span class="c1">// [10, -1, 3, 80]</span>
<span class="c1">// [-1, 3, 10, 80]</span>
</pre></div>
</td></tr></table>

<p>Este código es el recomendable cuando estemos escribiendo código con
un estilo de programación funcional.</p>
<p>Sin embargo, el siguiente código es imperativo y utiliza la mutación del array original:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="c1">// Código no recomendable en programación funcional</span>
<span class="c1">// porque utiliza el método sort que muta el array original</span>
<span class="kd">var</span> <span class="nv">miArray</span> <span class="p">=</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">80</span><span class="p">]</span>
<span class="n">miArray</span><span class="p">.</span><span class="bp">sort</span><span class="p">()</span>
<span class="bp">print</span><span class="p">(</span><span class="n">miArray</span><span class="p">)</span>
<span class="c1">// Imprime:</span>
<span class="c1">// [-1, 3, 10, 80]</span>
</pre></div>
</td></tr></table>

<p>Otro ejemplo es en la forma de añadir elementos a un array. Podemos
hacerlo con un enfoque funcional, usando el operador <code>+</code> que construye
un array nuevo:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="c1">// Código recomendable en programación funcional</span>
<span class="kd">let</span> <span class="nv">miArray</span> <span class="p">=</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">80</span><span class="p">]</span>
<span class="kd">let</span> <span class="nv">array2</span> <span class="p">=</span> <span class="n">miArray</span> <span class="o">+</span> <span class="p">[</span><span class="mi">100</span><span class="p">]</span>
<span class="bp">print</span><span class="p">(</span><span class="n">array2</span><span class="p">)</span>
<span class="c1">// Imprime:</span>
<span class="c1">// [10, -1, 3, 80, 100]</span>
</pre></div>
</td></tr></table>

<p>Y podemos hacerlo usando un enfoque imperativo, con el método
<code>append</code>:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="c1">// Código no recomendable en programación funcional</span>
<span class="kd">var</span> <span class="nv">miArray</span> <span class="p">=</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">80</span><span class="p">]</span>
<span class="n">miArray</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
<span class="bp">print</span><span class="p">(</span><span class="n">miArray</span><span class="p">)</span>
<span class="c1">// Imprime:</span>
<span class="c1">// [10, -1, 3, 80, 100]</span>
</pre></div>
</td></tr></table>

<div class="admonition important">
<p class="admonition-title">Importante</p>
<p>En programación funcional debemos usar siempre los métodos
<strong>que no modifican las estructuras</strong>. Así evitaremos los efectos
laterales y nuestro código funcionará correctamente en entornos
multi-hilo.</p>
</div>
<p>Cuando definimos una variable de tipo <code>let</code> el valor que se
asigne a esa variable se convierte en inmutable. Si se trata de una
estructura o una clase con métodos mutables el compilador dará un
error. Por ejemplo:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">let</span> <span class="nv">miArray</span> <span class="p">=</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">80</span><span class="p">]</span>
<span class="n">miArray</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
<span class="c1">// error: cannot use mutating member on immutable value: &#39;miArray&#39; is a &#39;let&#39; constant</span>
</pre></div>
</td></tr></table>

<p>Otro ejemplo. El método <code>append(_:)</code> de un <code>String</code> es un método
mutable. Si definimos una cadena con <code>let</code> no podremos modificarla y
daría error el siguiente código:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">var</span> <span class="nv">cadenaMutable</span> <span class="p">=</span> <span class="s">&quot;Hola&quot;</span>
<span class="kd">let</span> <span class="nv">cadenaInmutable</span> <span class="p">=</span> <span class="s">&quot;Adios&quot;</span>
<span class="n">cadenaMutable</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">cadenaInmutable</span><span class="p">)</span> <span class="c1">// cadenaMutable es &quot;HolaAdios&quot;</span>
<span class="n">cadenaInmutable</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="s">&quot;Adios&quot;</span><span class="p">)</span>
<span class="c1">// error: cannot use mutating member on immutable value: &#39;cadenaInmutable&#39; is a &#39;let&#39; constant</span>
</pre></div>
</td></tr></table>

<h2 id="3-funciones">3. Funciones<a class="headerlink" href="#3-funciones" title="Permanent link">&para;</a></h2>
<h3 id="31-definicion-de-una-funcion-en-swift">3.1. Definición de una función en Swift<a class="headerlink" href="#31-definicion-de-una-funcion-en-swift" title="Permanent link">&para;</a></h3>
<p>Para definir una función en Swift se debe usar la palabra <code>func</code>,
definir el nombre de la función, sus parámetros y el tipo de
vuelto. El valor devuelto por la función se debe devolver usando la
palabra <code>return</code>.</p>
<p>Código de la función <code>saluda(nombre:)</code>:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">func</span> <span class="nf">saluda</span><span class="p">(</span><span class="n">nombre</span><span class="p">:</span> <span class="nb">String</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">String</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nv">saludo</span> <span class="p">=</span> <span class="s">&quot;Hola, &quot;</span> <span class="o">+</span> <span class="n">nombre</span> <span class="o">+</span> <span class="s">&quot;!&quot;</span>
    <span class="k">return</span> <span class="n">saludo</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<p>Una característica de Swift es que para invocar a la función es
necesario preceder al argumento con la etiqueta definida por el nombre
del parámetro.</p>
<p>Por ejemplo, sería un error llamar a la función anterior de la
siguiente forma:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="c1">// Error: hay que especificar la etiqueta `nombre:`</span>
<span class="bp">print</span><span class="p">(</span><span class="n">saluda</span><span class="p">(</span><span class="s">&quot;Ana&quot;</span><span class="p">))</span>
</pre></div>
</td></tr></table>

<p>La forma correcta de llamar a la función es la siguiente:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="bp">print</span><span class="p">(</span><span class="n">saluda</span><span class="p">(</span><span class="n">nombre</span><span class="p">:</span><span class="s">&quot;Ana&quot;</span><span class="p">))</span>
<span class="bp">print</span><span class="p">(</span><span class="n">saluda</span><span class="p">(</span><span class="n">nombre</span><span class="p">:</span><span class="s">&quot;Pedro&quot;</span><span class="p">))</span>
<span class="c1">// Imprime &quot;Hola, Ana!&quot;</span>
<span class="c1">// Imprime &quot;Hola, Pedro!&quot;</span>
</pre></div>
</td></tr></table>

<p>Esta característica de Swift hace que el código sea más legible y
fácil de entender, ya que podemos ver claramente cuál es el propósito
de cada argumento al llamar a la función. </p>
<p>Por ejemplo, podemos tener también otra función similar que devuelve
un saludo recibiendo el nombre y la edad de una persona:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">func</span> <span class="nf">crearSaludo</span><span class="p">(</span><span class="n">nombre</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span> <span class="n">edad</span><span class="p">:</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">String</span> <span class="p">{</span>
    <span class="k">return</span> <span class="s">&quot;Hola, </span><span class="si">\(</span><span class="n">nombre</span><span class="si">)</span><span class="s">! Tienes </span><span class="si">\(</span><span class="n">edad</span><span class="si">)</span><span class="s"> años.&quot;</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nv">saludo</span> <span class="p">=</span> <span class="n">crearSaludo</span><span class="p">(</span><span class="n">nombre</span><span class="p">:</span> <span class="s">&quot;Carlos&quot;</span><span class="p">,</span> <span class="n">edad</span><span class="p">:</span> <span class="mi">25</span><span class="p">)</span>
<span class="bp">print</span><span class="p">(</span><span class="n">saludo</span><span class="p">)</span>
</pre></div>
</td></tr></table>

<p>Al llamar a la función <code>crearSaludo</code> queda claro que estamos pasando
el nombre y la edad de la persona a la que queremos saludar.</p>
<h3 id="32-etiquetas-de-argumentos-y-nombres-de-parametros">3.2. Etiquetas de argumentos y nombres de parámetros<a class="headerlink" href="#32-etiquetas-de-argumentos-y-nombres-de-parametros" title="Permanent link">&para;</a></h3>
<p>Es posible hacer distintos la etiqueta del argumento (nombre externo
con el que hay que llamar a la función) del nombre del parámetro
(nombre interno que se usa en el cuerpo de la función):</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">func</span> <span class="nf">saluda</span><span class="p">(</span><span class="n">nombre</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span> <span class="n">de</span> <span class="n">ciudad</span><span class="p">:</span> <span class="nb">String</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">String</span> <span class="p">{</span>
    <span class="k">return</span> <span class="s">&quot;Hola </span><span class="si">\(</span><span class="n">nombre</span><span class="si">)</span><span class="s">! Me alegro de que hayas podido visitarnos desde </span><span class="si">\(</span><span class="n">ciudad</span><span class="si">)</span><span class="s">.&quot;</span>
<span class="p">}</span>
<span class="bp">print</span><span class="p">(</span><span class="n">saluda</span><span class="p">(</span><span class="n">nombre</span><span class="p">:</span> <span class="s">&quot;Bill&quot;</span><span class="p">,</span> <span class="n">de</span><span class="p">:</span> <span class="s">&quot;Cupertino&quot;</span><span class="p">))</span>
<span class="c1">// Imprime &quot;Hola Bill! Me alegro de que hayas podido visitarnos desde Cupertino.&quot;</span>
</pre></div>
</td></tr></table>

<p>En este caso el nombre externo del parámetro, el que usamos al invocar
la función, es <code>de</code> y el nombre interno, el que se usa en el cuerpo de
la función, es <code>ciudad</code>.</p>
<p>Otro ejemplo, la siguiente función <code>concatena(palabra:con:)</code>: </p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">func</span> <span class="nf">concatena</span><span class="p">(</span><span class="n">palabra</span> <span class="n">str1</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span> <span class="n">con</span> <span class="n">str2</span><span class="p">:</span> <span class="nb">String</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">String</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">str1</span><span class="o">+</span><span class="n">str2</span>
<span class="p">}</span>

<span class="bp">print</span><span class="p">(</span><span class="n">concatena</span><span class="p">(</span><span class="n">palabra</span><span class="p">:</span><span class="s">&quot;Hola&quot;</span><span class="p">,</span> <span class="n">con</span><span class="p">:</span><span class="s">&quot;adios&quot;</span><span class="p">))</span>
</pre></div>
</td></tr></table>

<p>Si no se quiere una etiqueta del argumento para un parámetro, se puede
escribir un subrayado (<code>_</code>) en lugar de una etiqueta del argumento
explícita para ese parámetro. Esto nos permite llamar a la función sin
usar un nombre de parámetro. Por ejemplo, la función <code>max(_:_:)</code> y la
función <code>divide(_:entre:)</code>:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">func</span> <span class="nf">max</span><span class="p">(</span><span class="kc">_</span> <span class="n">x</span><span class="p">:</span> <span class="nb">Int</span><span class="p">,</span> <span class="kc">_</span> <span class="n">y</span><span class="p">:</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Int</span> <span class="p">{</span>
   <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="n">y</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">x</span>
   <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">y</span>
   <span class="p">}</span>
<span class="p">}</span>

<span class="bp">print</span><span class="p">(</span><span class="bp">max</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>

<span class="kd">func</span> <span class="nf">divide</span><span class="p">(</span><span class="kc">_</span> <span class="n">x</span><span class="p">:</span> <span class="nb">Double</span><span class="p">,</span> <span class="n">entre</span> <span class="n">y</span><span class="p">:</span> <span class="nb">Double</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Double</span> <span class="p">{</span>
   <span class="k">return</span> <span class="n">x</span> <span class="o">/</span> <span class="n">y</span>
<span class="p">}</span>

<span class="bp">print</span><span class="p">(</span><span class="n">divide</span><span class="p">(</span><span class="mi">30</span><span class="p">,</span> <span class="n">entre</span><span class="p">:</span><span class="mi">4</span><span class="p">))</span>
</pre></div>
</td></tr></table>

<p>La firma de la función ("function signature" en inglés, también
llamada "perfil" de la función) está formada por el nombre de la
función, las etiquetas de los argumentos y sus tipos y el tipo
devuelto por la función.</p>
<p>Por ejemplo, en el caso anterior, la firma de la función <code>max</code> sería:</p>
<ul>
<li>Nombre: <code>max</code></li>
<li>Lista de parámetros: <code>(_ x: Int, _ y: Int)</code></li>
<li>Tipo de retorno: <code>Int</code></li>
</ul>
<p>Y la firma de la función <code>divide</code> sería:</p>
<ul>
<li>Nombre: <code>divide</code></li>
<li>Lista de parámetros: <code>(_ x: Double, entre y: Double)</code></li>
<li>Tipo de retorno: <code>Double</code></li>
</ul>
<p>Esta firma permite al compilador y al programador identificar y
diferenciar funciones con el mismo nombre pero con diferentes listas
de parámetros o tipos de retorno.</p>
<p>En la documentación de las funciones en Swift se suele usar para
nombrarlas su nombre completo: el nombre de la propia función más el
nombre de los parámetros. Por ejemplo, las funciones anteriores se
nombran como <code>max(_:_:)</code> y <code>divide(_:entre:)</code>.</p>
<p>Como hemos dicho, los nombres de los parámetros son parte del nombre
completo de la función. Es posible definir funciones distintas con
sólo distintos nombres de parámetros, como las siguientes funciones
<code>mitad(par:)</code> y <code>mitad(impar:)</code>:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">func</span> <span class="nf">mitad</span><span class="p">(</span><span class="n">par</span><span class="p">:</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Int</span><span class="p">{</span>
    <span class="k">return</span> <span class="n">par</span><span class="o">/</span><span class="mi">2</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">mitad</span><span class="p">(</span><span class="n">impar</span><span class="p">:</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Int</span><span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">impar</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>
<span class="p">}</span>

<span class="bp">print</span><span class="p">(</span><span class="n">mitad</span><span class="p">(</span><span class="n">par</span><span class="p">:</span> <span class="mi">8</span><span class="p">))</span>
<span class="c1">// Imprime 4</span>
<span class="bp">print</span><span class="p">(</span><span class="n">mitad</span><span class="p">(</span><span class="n">impar</span><span class="p">:</span> <span class="mi">9</span><span class="p">))</span>
<span class="c1">// Imprime 5</span>
</pre></div>
</td></tr></table>

<h3 id="33-parametros-y-valores-devueltos">3.3. Parámetros y valores devueltos<a class="headerlink" href="#33-parametros-y-valores-devueltos" title="Permanent link">&para;</a></h3>
<p>Es posible definir funciones sin parámetros:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">func</span> <span class="nf">diHolaMundo</span><span class="p">()</span> <span class="p">-&gt;</span> <span class="nb">String</span> <span class="p">{</span>
    <span class="k">return</span> <span class="s">&quot;hola, mundo&quot;</span>
<span class="p">}</span>
<span class="bp">print</span><span class="p">(</span><span class="n">diHolaMundo</span><span class="p">())</span>
<span class="c1">// Imprime &quot;hola, mundo&quot;</span>
</pre></div>
</td></tr></table>

<p>Podemos definir funciones sin valor devuelto. Por ejemplo, la
siguiente función <code>diAdios(nombre:)</code>. No hay que escribir flecha con el
tipo devuelto. Cuidado, no sería propiamente programación funcional.</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">func</span> <span class="nf">diAdios</span><span class="p">(</span><span class="n">nombre</span><span class="p">:</span> <span class="nb">String</span><span class="p">)</span> <span class="p">{</span>
    <span class="bp">print</span><span class="p">(</span><span class="s">&quot;Adiós, </span><span class="si">\(</span><span class="n">nombre</span><span class="si">)</span><span class="s">!&quot;</span><span class="p">)</span>
<span class="p">}</span>
<span class="n">diAdios</span><span class="p">(</span><span class="n">nombre</span><span class="p">:</span><span class="s">&quot;Dave&quot;</span><span class="p">)</span>
<span class="c1">// Imprime &quot;Adiós, Dave!&quot;</span>
</pre></div>
</td></tr></table>

<p>Es posible devolver múltiples valores, construyendo una tupla. Por
ejemplo, la siguiente función <code>ecuacion(a:b:c:)</code> calcula las dos
soluciones de una ecuación de segundo grado:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">func</span> <span class="nf">ecuacion</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="nb">Double</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="nb">Double</span><span class="p">,</span> <span class="n">c</span><span class="p">:</span> <span class="nb">Double</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="p">(</span><span class="n">pos</span><span class="p">:</span> <span class="nb">Double</span><span class="p">,</span> <span class="n">neg</span><span class="p">:</span> <span class="nb">Double</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nv">discriminante</span> <span class="p">=</span> <span class="n">b</span><span class="o">*</span><span class="n">b</span><span class="o">-</span><span class="mi">4</span><span class="o">*</span><span class="n">a</span><span class="o">*</span><span class="n">c</span>
    <span class="kd">let</span> <span class="nv">raizPositiva</span> <span class="p">=</span> <span class="p">(</span><span class="o">-</span><span class="n">b</span> <span class="o">+</span> <span class="n">discriminante</span><span class="p">.</span><span class="n">squareRoot</span><span class="p">())</span> <span class="o">/</span> <span class="mi">2</span><span class="o">*</span><span class="n">a</span>
    <span class="kd">let</span> <span class="nv">raizNegativa</span> <span class="p">=</span> <span class="p">(</span><span class="o">-</span><span class="n">b</span> <span class="o">-</span> <span class="n">discriminante</span><span class="p">.</span><span class="n">squareRoot</span><span class="p">())</span> <span class="o">/</span> <span class="mi">2</span><span class="o">*</span><span class="n">a</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">raizPositiva</span><span class="p">,</span> <span class="n">raizNegativa</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<p>Recordemos (consultar el seminario de Swift) que podemos acceder a los
valores de la tupla por posición:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">let</span> <span class="nv">resultado</span> <span class="p">=</span> <span class="n">ecuacion</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="n">c</span><span class="p">:</span> <span class="mi">6</span><span class="p">)</span>
<span class="bp">print</span><span class="p">(</span><span class="s">&quot;Las raíces de la ecuación son </span><span class="si">\(</span><span class="n">resultado</span><span class="p">.</span><span class="mi">0</span><span class="si">)</span><span class="s"> y </span><span class="si">\(</span><span class="n">resultado</span><span class="p">.</span><span class="mi">1</span><span class="si">)</span><span class="s">&quot;</span><span class="p">)</span>
<span class="c1">//Imprime &quot;Las raíces de la ecuación son 3.0 y 2.0&quot;</span>
</pre></div>
</td></tr></table>

<p>En este caso en la definición del tipo devuelto por la función estamos
etiquetando esos valores con las etiquetas <code>pos</code> y <code>neg</code>. De esta
forma podemos acceder a los componentes de la tupla usando esas
etiquetas definidas:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">let</span> <span class="nv">resultado</span> <span class="p">=</span> <span class="n">ecuacion</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="n">c</span><span class="p">:</span> <span class="mi">6</span><span class="p">)</span>
<span class="bp">print</span><span class="p">(</span><span class="s">&quot;Las raíces de la ecuación son </span><span class="si">\(</span><span class="n">resultado</span><span class="p">.</span><span class="n">pos</span><span class="si">)</span><span class="s"> y </span><span class="si">\(</span><span class="n">resultado</span><span class="p">.</span><span class="n">neg</span><span class="si">)</span><span class="s">&quot;</span><span class="p">)</span>
<span class="c1">//Imprime &quot;Las raíces de la ecuación son 3.0 y 2.0&quot;</span>
</pre></div>
</td></tr></table>

<h2 id="4-recursion">4. Recursión<a class="headerlink" href="#4-recursion" title="Permanent link">&para;</a></h2>
<p>Veamos algunos ejemplos de funciones recursivas en Swift.</p>
<p>Primero una función <code>suma(hasta:)</code> que devuelve la suma desde 0 hasta
el número que le pasamos como parámetro.</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">func</span> <span class="nf">suma</span><span class="p">(</span><span class="n">hasta</span> <span class="n">x</span><span class="p">:</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Int</span> <span class="p">{</span>
  <span class="k">if</span> <span class="n">x</span> <span class="p">==</span> <span class="mi">0</span> <span class="p">{</span>
    <span class="k">return</span> <span class="mi">0</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">suma</span><span class="p">(</span><span class="n">hasta</span><span class="p">:</span> <span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="bp">print</span><span class="p">(</span><span class="n">suma</span><span class="p">(</span><span class="n">hasta</span><span class="p">:</span> <span class="mi">5</span><span class="p">))</span>
<span class="c1">// Imprime &quot;15&quot;</span>
</pre></div>
</td></tr></table>

<p>También es posible definir recursiones que recorran arrays de una
forma similar a cómo trabajábamos en Scheme. Los arrays en Swift no
funcionan exactamente como las listas de Scheme (no son listas de
parejas), pero podemos obtener el primer elemento y el resto de la
siguiente forma.</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">let</span> <span class="nv">a</span> <span class="p">=</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">60</span><span class="p">]</span>
<span class="kd">let</span> <span class="nv">primero</span> <span class="p">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="kd">let</span> <span class="nv">resto</span> <span class="p">=</span> <span class="nb">Array</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="bp">dropFirst</span><span class="p">())</span>
</pre></div>
</td></tr></table>

<p>En <code>primero</code> se guarda el número 10. En <code>resto</code> se guarda el <code>Array</code>
del 20 al 60. El método <code>dropFirst</code> devuelve una <code>ArraySlice</code>, que es
una vista de un rango de elementos del array, en este caso el que va
desde la posición 1 hasta la 5 (la posición inicial de un array es la
0). Es necesario el constructor <code>Array</code> para convertir ese
<code>ArraySlice</code> en un <code>Array</code>.</p>
<p>Usando las instrucciones anteriores podemos definir la función recursiva que suma los
valores de un Array de la siguiente forma similar a cómo lo hacíamos
en Scheme:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">func</span> <span class="nf">sumaValores</span><span class="p">(</span><span class="kc">_</span> <span class="n">valores</span><span class="p">:</span> <span class="p">[</span><span class="nb">Int</span><span class="p">])</span> <span class="p">-&gt;</span> <span class="nb">Int</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">valores</span><span class="p">.</span><span class="bp">isEmpty</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">0</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="kd">let</span> <span class="nv">primero</span> <span class="p">=</span> <span class="n">valores</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="kd">let</span> <span class="nv">resto</span> <span class="p">=</span> <span class="nb">Array</span><span class="p">(</span><span class="n">valores</span><span class="p">.</span><span class="bp">dropFirst</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">primero</span> <span class="o">+</span> <span class="n">sumaValores</span><span class="p">(</span><span class="n">resto</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="bp">print</span><span class="p">(</span><span class="n">sumaValores</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">]))</span> 
<span class="c1">// Imprime &quot;36&quot;</span>
</pre></div>
</td></tr></table>

<p>Un último ejemplo es la siguiente función <code>minMax(array:)</code> que
devuelve el número más pequeño y más grande de un array de enteros:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">func</span> <span class="nf">minMax</span><span class="p">(</span><span class="n">array</span><span class="p">:</span> <span class="p">[</span><span class="nb">Int</span><span class="p">])</span> <span class="p">-&gt;</span> <span class="p">(</span><span class="bp">min</span><span class="p">:</span> <span class="nb">Int</span><span class="p">,</span> <span class="bp">max</span><span class="p">:</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">array</span><span class="p">.</span><span class="bp">count</span> <span class="p">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">array</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">array</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="kd">let</span> <span class="nv">primero</span> <span class="p">=</span> <span class="n">array</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="kd">let</span> <span class="nv">resto</span> <span class="p">=</span> <span class="nb">Array</span><span class="p">(</span><span class="n">array</span><span class="p">.</span><span class="bp">dropFirst</span><span class="p">())</span>

        <span class="c1">// Llamada recursiva que devuelve el mínimo y el máximo del</span>
        <span class="c1">// resto del array</span>
        <span class="kd">let</span> <span class="nv">minMaxResto</span> <span class="p">=</span> <span class="n">minMax</span><span class="p">(</span><span class="n">array</span><span class="p">:</span> <span class="n">resto</span><span class="p">)</span>

        <span class="kd">let</span> <span class="nv">minimo</span> <span class="p">=</span> <span class="bp">min</span><span class="p">(</span><span class="n">primero</span><span class="p">,</span> <span class="n">minMaxResto</span><span class="p">.</span><span class="bp">min</span><span class="p">)</span>
        <span class="kd">let</span> <span class="nv">maximo</span> <span class="p">=</span> <span class="bp">max</span><span class="p">(</span><span class="n">primero</span><span class="p">,</span> <span class="n">minMaxResto</span><span class="p">.</span><span class="bp">max</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">minimo</span><span class="p">,</span> <span class="n">maximo</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nv">limites</span> <span class="p">=</span> <span class="n">minMax</span><span class="p">(</span><span class="n">array</span><span class="p">:</span> <span class="p">[</span><span class="mi">8</span><span class="p">,</span> <span class="o">-</span><span class="mi">6</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">71</span><span class="p">])</span>
<span class="bp">print</span><span class="p">(</span><span class="s">&quot;El mínimo es </span><span class="si">\(</span><span class="n">limites</span><span class="p">.</span><span class="bp">min</span><span class="si">)</span><span class="s"> y el máximo es </span><span class="si">\(</span><span class="n">limites</span><span class="p">.</span><span class="bp">max</span><span class="si">)</span><span class="s">&quot;</span><span class="p">)</span>
<span class="c1">// Imprime &quot;El mímimo es -6 y el máximo es 100&quot;</span>
</pre></div>
</td></tr></table>

<p>En este ejemplo nos apartamos un poco de la solución vista en Scheme
porque permitimos pasos de ejecución que inicializan variables. Pero
no nos salimos del paradigma funcional, porque todas son variables
inmutables definidas con <code>let</code>.</p>
<h2 id="5-tipos-funcion">5. Tipos función<a class="headerlink" href="#5-tipos-funcion" title="Permanent link">&para;</a></h2>
<p>En Swift las funciones son objetos de primera clase y podemos
asignarlas a variables, pasarlas como parámetro o devolverlas como
resultado de otra función. </p>
<p>El siguiente ejemplo muestra todos los posibles usos de una función
como objeto de primera clase en Swift. Más adelante veremos con más
detalle cada uno de los casos.</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="c1">// Definimos una función simple que suma dos números</span>
<span class="kd">func</span> <span class="nf">suma</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="nb">Int</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Int</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
<span class="p">}</span>

<span class="c1">// Asignamos la función suma a una variable</span>
<span class="kd">let</span> <span class="nv">miSuma</span> <span class="p">=</span> <span class="n">suma</span>

<span class="c1">// Llamamos a la función suma usando la variable</span>
<span class="kd">let</span> <span class="nv">resultado</span> <span class="p">=</span> <span class="n">miSuma</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="bp">print</span><span class="p">(</span><span class="s">&quot;La suma de 3 y 4 es: </span><span class="si">\(</span><span class="n">resultado</span><span class="si">)</span><span class="s">&quot;</span><span class="p">)</span> 
<span class="c1">// Salida: La suma de 3 y 4 es: 7</span>

<span class="c1">// Definimos una función que toma otra función como parámetro y la aplica a dos números</span>
<span class="kd">func</span> <span class="nf">aplicarOperacion</span><span class="p">(</span><span class="kc">_</span> <span class="n">operacion</span><span class="p">:</span> <span class="p">(</span><span class="nb">Int</span><span class="p">,</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Int</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span> <span class="nb">Int</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Int</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">operacion</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nv">resultadoAplicarOperacion</span> <span class="p">=</span> <span class="n">aplicarOperacion</span><span class="p">(</span><span class="n">suma</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="mi">6</span><span class="p">)</span>
<span class="bp">print</span><span class="p">(</span><span class="s">&quot;La suma de 5 y 6 es: </span><span class="si">\(</span><span class="n">resultadoAplicarOperacion</span><span class="si">)</span><span class="s">&quot;</span><span class="p">)</span> 
<span class="c1">// Salida: La suma de 5 y 6 es: 11</span>

<span class="c1">// Definimos una función que devuelve otra función como resultado</span>
<span class="kd">func</span> <span class="nf">obtenerOperacion</span><span class="p">()</span> <span class="p">-&gt;</span> <span class="p">((</span><span class="nb">Int</span><span class="p">,</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">suma</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nv">funcionObtenida</span> <span class="p">=</span> <span class="n">obtenerOperacion</span><span class="p">()</span>
<span class="kd">let</span> <span class="nv">resultadoFuncionObtenida</span> <span class="p">=</span> <span class="n">funcionObtenida</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
<span class="bp">print</span><span class="p">(</span><span class="s">&quot;La suma de 7 y 8 es: </span><span class="si">\(</span><span class="n">resultadoFuncionObtenida</span><span class="si">)</span><span class="s">&quot;</span><span class="p">)</span> 
<span class="c1">// Salida: La suma de 7 y 8 es: 15</span>
</pre></div>
</td></tr></table>

<p>Como vemos en el ejemplo anterior, el funcionamiento de los objetos
función es similar al que ya hemos visto en Scheme. Pero con una
diferencia importante: al ser Swift un lenguaje fuertemente tipado,
debemos especificar el tipo de los parámetros o resultados de tipo
función.</p>
<p>El tipo específico de la función está definido por el tipo de sus
parámetros y el tipo del valor devuelto.</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">func</span> <span class="nf">sumaDosInts</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="nb">Int</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Int</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">multiplicaDosInts</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="nb">Int</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Int</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">*</span> <span class="n">b</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<p>El tipo de estas funciones es <code>(Int, Int) -&gt; Int</code>, que se puede leer como:</p>
<p>"Un tipo función que tiene dos parámetros, ambos de tipo <code>Int</code> y que
devuelve un valor de tipo <code>Int</code>".</p>
<p>Como hemos visto en el primer ejemplo, podemos asignar estas funciones
a una variable de tipo función:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">var</span> <span class="nv">f</span> <span class="p">=</span> <span class="n">sumaDosInts</span>
<span class="bp">print</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
<span class="c1">// Imprime &quot;5&quot;</span>
<span class="n">f</span> <span class="p">=</span> <span class="n">multiplicaDosInts</span>
<span class="bp">print</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
<span class="c1">// Imprime &quot;6&quot;</span>
</pre></div>
</td></tr></table>

<p>La variable <code>f</code> es una variable de tipo <code>(Int, Int) -&gt; Int</code>, o sea,
una variable que contiene funciones de dos argumentos <code>Int</code> que
devuelven un <code>Int</code>.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Habrás notado que al invocar a <code>f</code> no se ponen etiquetas en los
argumentos. De hecho, si las pusiéramos el compilador de Swift se
quejaría:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="bp">print</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">a</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span><span class="mi">3</span><span class="p">))</span>
<span class="c1">//error: extraneous argument labels &#39;a:b:&#39; in call</span>
</pre></div>
</td></tr></table>

<p>Esto es debido a que al ser <code>f</code> una variable se le puede asignar
cualquier función que tenga el tipo <code>(Int, Int) -&gt; Int</code> sin
tener en cuenta las etiquetas de los argumentos.</p>
</div>
<h3 id="51-funciones-que-reciben-otras-funciones">5.1. Funciones que reciben otras funciones<a class="headerlink" href="#51-funciones-que-reciben-otras-funciones" title="Permanent link">&para;</a></h3>
<p>Tal y como vimos en el ejemplo inicial, podemos usar un tipo función
en parámetros de otras funciones:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">func</span> <span class="nf">printResultado</span><span class="p">(</span><span class="n">funcion</span><span class="p">:</span> <span class="p">(</span><span class="nb">Int</span><span class="p">,</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Int</span><span class="p">,</span> <span class="kc">_</span> <span class="n">a</span><span class="p">:</span> <span class="nb">Int</span><span class="p">,</span> <span class="kc">_</span> <span class="n">b</span><span class="p">:</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">{</span>
    <span class="bp">print</span><span class="p">(</span><span class="s">&quot;Resultado: </span><span class="si">\(</span><span class="n">funcion</span><span class="si">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="si">))</span><span class="s">&quot;</span><span class="p">)</span>
<span class="p">}</span>
<span class="n">printResultado</span><span class="p">(</span><span class="n">funcion</span><span class="p">:</span> <span class="n">sumaDosInts</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="c1">// Prints &quot;Resultado: 8&quot;</span>
</pre></div>
</td></tr></table>

<p>La función <code>printResultado(funcion:_:_:)</code> toma como primer parámetro otra
función que recibe dos <code>Int</code> y devuelve un <code>Int</code>, y como segundo y
tercer parámetro dos <code>Int</code>. Y en el cuerpo llama a la función que se
pasa como parámetro con los argumentos <code>a</code> y <code>b</code>.</p>
<p>Veamos otro ejemplo, que ya vimos en Scheme. Supongamos que queremos
calcular el sumatorio desde <code>a</code> hasta <code>b</code> en el que aplicamos una
función <code>f</code> a cada número que sumamos:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span>sumatorio(a, b, f) = f(a) + f(a+1) + f(a+2) + ... + f(b)
</pre></div>
</td></tr></table>

<p>Recordamos que se resuelve con la siguiente recursión:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span>sumatorio(a, b, f) = f(a) + sumatorio(a+1, b, f)
sumatorio(a, b, f) = 0 si a &gt; b
</pre></div>
</td></tr></table>

<p>Veamos cómo se implementa en Swift: </p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">func</span> <span class="nf">sumatorio</span><span class="p">(</span><span class="n">desde</span> <span class="n">a</span><span class="p">:</span> <span class="nb">Int</span><span class="p">,</span> <span class="n">hasta</span> <span class="n">b</span><span class="p">:</span> <span class="nb">Int</span><span class="p">,</span> <span class="kd">func</span> <span class="nf">f</span><span class="p">:</span> <span class="p">(</span><span class="nb">Int</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Int</span> <span class="p">{</span>
   <span class="k">if</span> <span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span> <span class="p">{</span> 
      <span class="k">return</span> <span class="mi">0</span> 
   <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">f</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">+</span> <span class="n">sumatorio</span><span class="p">(</span><span class="n">desde</span><span class="p">:</span> <span class="n">a</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">hasta</span><span class="p">:</span> <span class="n">b</span><span class="p">,</span> <span class="kd">func</span><span class="p">:</span> <span class="n">f</span><span class="p">)</span>
   <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">identidad</span><span class="p">(</span><span class="kc">_</span> <span class="n">x</span><span class="p">:</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Int</span> <span class="p">{</span>
   <span class="k">return</span> <span class="n">x</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">doble</span><span class="p">(</span><span class="kc">_</span> <span class="n">x</span><span class="p">:</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Int</span> <span class="p">{</span>
   <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">x</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">cuadrado</span><span class="p">(</span><span class="kc">_</span> <span class="n">x</span><span class="p">:</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Int</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span>
<span class="p">}</span>

<span class="bp">print</span><span class="p">(</span><span class="n">sumatorio</span><span class="p">(</span><span class="n">desde</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="n">hasta</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span> <span class="kd">func</span><span class="p">:</span> <span class="n">identidad</span><span class="p">))</span> <span class="c1">// Imprime 55</span>
<span class="bp">print</span><span class="p">(</span><span class="n">sumatorio</span><span class="p">(</span><span class="n">desde</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="n">hasta</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span> <span class="kd">func</span><span class="p">:</span> <span class="n">doble</span><span class="p">))</span> <span class="c1">// Imprime 110</span>
<span class="bp">print</span><span class="p">(</span><span class="n">sumatorio</span><span class="p">(</span><span class="n">desde</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="n">hasta</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span> <span class="kd">func</span><span class="p">:</span> <span class="n">cuadrado</span><span class="p">))</span> <span class="c1">// Imprime 385</span>
</pre></div>
</td></tr></table>

<h3 id="52-funciones-en-estructuras">5.2. Funciones en estructuras<a class="headerlink" href="#52-funciones-en-estructuras" title="Permanent link">&para;</a></h3>
<p>Como cualquier otro tipo Las funciones pueden también incluirse en
  estructuras de datos compuestas, como arrays:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">let</span> <span class="nv">funciones</span> <span class="p">=</span> <span class="p">[</span><span class="n">identidad</span><span class="p">,</span> <span class="n">doble</span><span class="p">,</span> <span class="n">cuadrado</span><span class="p">]</span>
<span class="bp">print</span><span class="p">(</span><span class="n">funciones</span><span class="p">[</span><span class="mi">0</span><span class="p">](</span><span class="mi">10</span><span class="p">))</span> <span class="c1">// 10</span>
<span class="bp">print</span><span class="p">(</span><span class="n">funciones</span><span class="p">[</span><span class="mi">1</span><span class="p">](</span><span class="mi">10</span><span class="p">))</span> <span class="c1">// 20 </span>
<span class="bp">print</span><span class="p">(</span><span class="n">funciones</span><span class="p">[</span><span class="mi">2</span><span class="p">](</span><span class="mi">10</span><span class="p">))</span> <span class="c1">// 100</span>
</pre></div>
</td></tr></table>

<p>El tipo de la variable <code>funciones</code> sería <code>[(Int) -&gt; Int]</code>. </p>
<p>Al ser Swift fuertemente tipado, no podríamos hacer un array con
distintos tipos de funciones. Por ejemplo el siguiente código daría un
error:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">func</span> <span class="nf">suma</span><span class="p">(</span><span class="kc">_</span> <span class="n">x</span><span class="p">:</span> <span class="nb">Int</span><span class="p">,</span> <span class="kc">_</span> <span class="n">y</span><span class="p">:</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Int</span> <span class="p">{</span>
   <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
<span class="p">}</span>
<span class="c1">// La siguiente línea genera un error</span>
<span class="kd">let</span> <span class="nv">misFunciones</span> <span class="p">=</span> <span class="p">[</span><span class="n">doble</span><span class="p">,</span> <span class="n">cuadrado</span><span class="p">,</span> <span class="n">suma</span><span class="p">]</span>
<span class="c1">// error: heterogenous collection literal could only be inferred to</span>
<span class="c1">// &#39;[Any]&#39;; add explicit type annotation if this is intentional</span>
</pre></div>
</td></tr></table>

<h3 id="53-funciones-que-devuelven-otras-funciones">5.3 Funciones que devuelven otras funciones<a class="headerlink" href="#53-funciones-que-devuelven-otras-funciones" title="Permanent link">&para;</a></h3>
<p>Por último, veamos un ejemplo de funciones que devuelven otras
funciones. </p>
<p>Es un ejemplo sencillo, una función que devuelve otra que
suma 10:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">func</span> <span class="nf">construyeSumador10</span><span class="p">()</span> <span class="p">-&gt;</span> <span class="p">(</span><span class="nb">Int</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Int</span> <span class="p">{</span>
  <span class="kd">func</span> <span class="nf">suma10</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Int</span> <span class="p">{</span><span class="k">return</span> <span class="n">x</span><span class="o">+</span><span class="mi">10</span><span class="p">}</span>
  <span class="k">return</span> <span class="n">suma10</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nv">g</span> <span class="p">=</span> <span class="n">construyeSumador10</span><span class="p">()</span>
<span class="bp">print</span><span class="p">(</span><span class="n">g</span><span class="p">(</span><span class="mi">20</span><span class="p">))</span>
<span class="c1">// Imprime 30</span>
</pre></div>
</td></tr></table>

<p>La función devuelta por <code>construyeSumador10()</code> es una función con el tipo
<code>(Int) -&gt; Int</code> (recibe un parámetro entero y devuelve un entero). En
la llamada a <code>construyeSumador10()</code> se crea esa función y se asigna a la
variable <code>g</code>.</p>
<p>Estas funciones devueltas se denominan <strong>clausuras</strong>. Más adelante
hablaremos algo más de ellas. Veremos también más adelante que es
posible usar <strong>expresiones de clausura</strong> que construyen clausuras
anónimas. </p>
<p>Podemos modificar el ejemplo anterior, haciendo que la función
<code>construyeSumador</code> reciba el número a sumar como parámetro:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">func</span> <span class="nf">construyeSumador</span><span class="p">(</span><span class="n">inc</span><span class="p">:</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="p">(</span><span class="nb">Int</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Int</span> <span class="p">{</span>
  <span class="kd">func</span> <span class="nf">suma</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Int</span> <span class="p">{</span><span class="k">return</span> <span class="n">x</span><span class="o">+</span><span class="n">inc</span><span class="p">}</span>
  <span class="k">return</span> <span class="n">suma</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nv">f2</span> <span class="p">=</span> <span class="n">construyeSumador</span><span class="p">(</span><span class="n">inc</span><span class="p">:</span> <span class="mi">10</span><span class="p">)</span>
<span class="kd">let</span> <span class="nv">f3</span> <span class="p">=</span> <span class="n">construyeSumador</span><span class="p">(</span><span class="n">inc</span><span class="p">:</span> <span class="mi">100</span><span class="p">)</span>
<span class="bp">print</span><span class="p">(</span><span class="n">f2</span><span class="p">(</span><span class="mi">20</span><span class="p">))</span>
<span class="c1">// Imprime &quot;30&quot;</span>
<span class="bp">print</span><span class="p">(</span><span class="n">f3</span><span class="p">(</span><span class="mi">20</span><span class="p">))</span>
<span class="c1">// Imprime &quot;120&quot;</span>
</pre></div>
</td></tr></table>

<p>Invocamos dos veces a <code>construyeSumador(inc:)</code> y guardamos las
clausuras construidas en las variables <code>f2</code> y <code>f3</code>. En <code>f2</code> se guarda una
función que suma <code>10</code> a su argumento y en <code>f3</code> otra que suma <code>100</code>.</p>
<h2 id="6-tipos">6. Tipos<a class="headerlink" href="#6-tipos" title="Permanent link">&para;</a></h2>
<p>Entre las ventajas del uso de tipos está la detección de errores en
los programas en tiempo de compilación o las ayudas del entorno de
desarrollo para autocompletar código. Entre los inconvenientes se
encuentra la necesidad de ser más estrictos a la hora de definir los
parámetros y los valores devueltos por las funciones, lo que impide la
flexibilidad de Scheme.</p>
<p>Se utilizan tipos para definir los posibles valores de:</p>
<ul>
<li>variables</li>
<li>parámetros de funciones</li>
<li>valores devueltos por funciones</li>
</ul>
<p>Tal y como hemos visto cuando hemos comentado que Swift es fuertemente
tipado las definiciones de tipos van precedidas de dos puntos en las
variables y parámetros, o de una flecha (<code>-&gt;</code>) en la definición de los
tipos de los valores devueltos por una función:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">let</span> <span class="nv">valorDouble</span> <span class="p">:</span> <span class="nb">Double</span> <span class="p">=</span> <span class="mf">3.0</span>
<span class="kd">let</span> <span class="nv">unaCadena</span><span class="p">:</span> <span class="nb">String</span> <span class="p">=</span> <span class="s">&quot;Hola&quot;</span>

<span class="kd">func</span> <span class="nf">calculaEstadisticas</span><span class="p">(</span><span class="n">valores</span><span class="p">:</span> <span class="nb">Array</span><span class="p">&lt;</span><span class="nb">Int</span><span class="p">&gt;)</span> <span class="p">-&gt;</span> <span class="p">(</span><span class="bp">min</span><span class="p">:</span> <span class="nb">Int</span><span class="p">,</span> <span class="bp">max</span><span class="p">:</span> <span class="nb">Int</span><span class="p">,</span> <span class="n">media</span><span class="p">:</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">{</span>
   <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<p>En Swift existen dos clases de tipos: tipos con nombre y tipos compuestos. </p>
<h3 id="61-tipos-con-nombre">6.1. Tipos con nombre<a class="headerlink" href="#61-tipos-con-nombre" title="Permanent link">&para;</a></h3>
<p>Un tipo con nombre es un tipo al que podemos dar un nombre determinado
cuando se define. Por ejemplo, al definir un nombre de una clase o de
un enumerado estamos también definiendo un nombre de un tipo.</p>
<p>En Swift es posible definir los siguientes tipos con nombre:</p>
<ul>
<li>nombres de clases</li>
<li>nombres de estructuras</li>
<li>nombres de enumeraciones</li>
<li>nombres de protocolos </li>
</ul>
<p>Por ejemplo, instancias de una clase definida por el usuario llamada
<code>MiClase</code> tienen el tipo <code>MiClase</code>. </p>
<p>Además de los tipos definidos por el usuario, la biblioteca estándar
de Swift tiene un gran número de tipos predefinidos. A diferencia de
otros lenguajes, estos tipos no son parte del propio lenguaje sino que
se definen en su mayoría como estructuras implementadas en esta
biblioteca estándar. Por ejemplo, arrays, diccionarios o incluso los
tipos más básicos como <code>String</code> o <code>Int</code> están construidos en esa
biblioteca. La implementación de estos elementos está disponible en
abierto en el <a href="https://github.com/apple/swift/tree/master/stdlib/public/core">sitio GitHub de
Swift</a>. </p>
<h3 id="62-tipos-compuestos">6.2. Tipos compuestos<a class="headerlink" href="#62-tipos-compuestos" title="Permanent link">&para;</a></h3>
<p>Los tipos compuestos son tipos sin nombre. En Swift se definen dos:
tuplas y tipos función. Un tipo compuesto puede tener tipos con nombre
y otros tipos compuestos. Por ejemplo la tupla <code>(Int, (Int, Int))</code>
contiene dos elementos: el primero es el tipo con nombre <code>Int</code> y el
segundo el tipo compuesto que define la tupla <code>(Int, Int)</code>. Los tipos
función los hemos visto previamente.</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">let</span> <span class="nv">tupla</span><span class="p">:</span> <span class="p">(</span><span class="nb">Int</span><span class="p">,</span> <span class="nb">Int</span><span class="p">,</span> <span class="nb">String</span><span class="p">)</span> <span class="p">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="s">&quot;Hola&quot;</span><span class="p">)</span>
<span class="kd">let</span> <span class="nv">otraTupla</span><span class="p">:</span> <span class="p">(</span><span class="nb">Int</span><span class="p">,</span> <span class="nb">Int</span><span class="p">,</span> <span class="nb">String</span><span class="p">)</span> <span class="p">=</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="s">&quot;Adios&quot;</span><span class="p">)</span>

<span class="kd">func</span> <span class="nf">sumaTupla</span><span class="p">(</span><span class="n">tupla</span> <span class="n">t1</span><span class="p">:</span> <span class="p">(</span><span class="nb">Int</span><span class="p">,</span> <span class="nb">Int</span><span class="p">),</span> <span class="n">con</span> <span class="n">t2</span><span class="p">:</span> <span class="p">(</span><span class="nb">Int</span><span class="p">,</span> <span class="nb">Int</span><span class="p">))</span> <span class="p">-&gt;</span> <span class="p">(</span><span class="nb">Int</span><span class="p">,</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">(</span><span class="n">t1</span><span class="p">.</span><span class="mi">0</span> <span class="o">+</span> <span class="n">t2</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="n">t1</span><span class="p">.</span><span class="mi">1</span> <span class="o">+</span> <span class="n">t2</span><span class="p">.</span><span class="mi">1</span><span class="p">)</span>
<span class="p">}</span>

<span class="bp">print</span><span class="p">(</span><span class="n">sumaTupla</span><span class="p">(</span><span class="n">tupla</span><span class="p">:</span> <span class="p">(</span><span class="n">tupla</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="n">tupla</span><span class="p">.</span><span class="mi">1</span><span class="p">),</span>
                <span class="n">con</span><span class="p">:</span> <span class="p">(</span><span class="n">otraTupla</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="n">otraTupla</span><span class="p">.</span><span class="mi">1</span><span class="p">)))</span>

<span class="c1">// Imprime (7, 11)</span>
</pre></div>
</td></tr></table>

<h4>6.2.1. Typealias</h4>
<p>En Swift se define la palabra clave <code>typealias</code> para darle un nombre
asignado a cualquier otro tipo. Ambos tipos son iguales a todos los
efectos (es únicamente azúcar sintáctico).</p>
<p>Por ejemplo, en el siguiente código definimos un <code>typealias</code> llamado
<code>Resultado</code> que corresponde a una tupla con dos <code>Int</code> correspondientes
al resultado de un partido de futbol. Una vez definido, podemos usarlo
como un tipo. La función <code>quiniela(partido:)</code> devuelve un <code>String</code>
correspondiente al resultado de la quiniela de un partido:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">typealias</span> <span class="n">Resultado</span> <span class="p">=</span> <span class="p">(</span><span class="nb">Int</span><span class="p">,</span> <span class="nb">Int</span><span class="p">)</span>

<span class="kd">func</span> <span class="nf">quiniela</span><span class="p">(</span><span class="n">partido</span><span class="p">:</span> <span class="n">Resultado</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">String</span> <span class="p">{</span>
  <span class="k">switch</span> <span class="n">partido</span> <span class="p">{</span>
    <span class="k">case</span> <span class="kd">let</span> <span class="p">(</span><span class="n">goles1</span><span class="p">,</span> <span class="n">goles2</span><span class="p">)</span> <span class="k">where</span> <span class="n">goles1</span> <span class="o">&lt;</span> <span class="n">goles2</span><span class="p">:</span>
      <span class="k">return</span> <span class="s">&quot;Dos&quot;</span>
    <span class="k">case</span> <span class="kd">let</span> <span class="p">(</span><span class="n">goles1</span><span class="p">,</span> <span class="n">goles2</span><span class="p">)</span> <span class="k">where</span> <span class="n">goles1</span> <span class="o">&gt;</span> <span class="n">goles2</span><span class="p">:</span>
      <span class="k">return</span> <span class="s">&quot;Uno&quot;</span>
    <span class="k">default</span><span class="p">:</span>
      <span class="k">return</span> <span class="s">&quot;Equis&quot;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="bp">print</span><span class="p">(</span><span class="n">quiniela</span><span class="p">(</span><span class="n">partido</span><span class="p">:</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)))</span>
<span class="c1">// Imprime &quot;Dos&quot;</span>
<span class="bp">print</span><span class="p">(</span><span class="n">quiniela</span><span class="p">(</span><span class="n">partido</span><span class="p">:</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)))</span>
<span class="c1">// Imprime &quot;Equis&quot;</span>
</pre></div>
</td></tr></table>

<p>En el ejemplo se usa una sentencia <code>switch</code> que recibe el resultado
del partido. Este resultado es una tupla de dos enteros. En el <code>case
let</code> se instancia los valores de esa tupla en las variables <code>goles1</code> y
<code>goles2</code> y después se define una condición para entrar en el caso. En
el primer caso, que <code>goles1</code> sea menor que <code>goles2</code> y en el segundo
que <code>goles1</code> sea mayor que <code>goles2</code>.</p>
<h3 id="63-tipos-valor-y-tipos-referencia">6.3. Tipos valor y tipos referencia<a class="headerlink" href="#63-tipos-valor-y-tipos-referencia" title="Permanent link">&para;</a></h3>
<p>En Swift existen dos tipos de construcciones que forman la base de la
programación orientada a objetos: las estructuras (<em>structs</em>) y las
clases. En el tema siguiente hablaremos sobre ello.</p>
<p>En la <a href="https://developer.apple.com/documentation/swift/swift_standard_library">biblioteca estándar de
Swift</a>
la mayor parte de los tipos definidos (como <code>Int</code>, <code>Double</code>, <code>Bool</code>,
<code>String</code>, <code>Array</code>, <code>Dictionary</code>, etc.) son estructuras, no clases.</p>
<p>Una de las diferencias más importantes entre estructuras y clases es
su comportamiento en una asignación: las estructuras tienen una
<strong>semántica de copia</strong> (son tipos valor) y las clases tienen una <strong>semántica de
referencia</strong> (son tipos referencia).</p>
<p>Un <em>tipo valor</em> es un tipo que tiene semántica de copia en las
asignaciones y cuando se pasan como parámetro en llamadas a funciones.</p>
<p>Los tipos valor son muy útiles porque evitan los efectos laterales en
los programas y simplifican el comportamiento del compilador en la
gestión de memoria. Al no existir referencias, se simplifica
enormemente la gestión de memoria de estas estructuras. No es
necesario llevar la cuenta de qué referencias apuntan a un determinado
valor, sino que se puede liberar la memoria en cuanto se elimina el
ámbito actual.</p>
<p>Frente a un tipo valor, un tipo de referencia es aquel en los que los
valores se asignan a variables con una semántica de referencia. Cuando
se realizan varias asignaciones de una misma instancia a distintas
variables todas ellas guardan una referencia a la misma instancia. Si
la instancia se modifica, todas las variables reflejarán el nuevo
valor. Cuando veamos las clases en el próximo tema veremos algunos ejemplos.</p>
<p>Veamos ahora algunos ejemplos de copia por valor en estructuras.</p>
<p>Por ejemplo, si asignamos una cadena a otra, se realiza una copia:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">var</span> <span class="nv">str1</span> <span class="p">=</span> <span class="s">&quot;Hola&quot;</span>
<span class="kd">var</span> <span class="nv">str2</span> <span class="p">=</span> <span class="n">str1</span>
<span class="n">str1</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="s">&quot;Adios&quot;</span><span class="p">)</span>
<span class="bp">print</span><span class="p">(</span><span class="n">str1</span><span class="p">)</span> <span class="c1">// Imprime &quot;HolaAdios&quot;</span>
<span class="bp">print</span><span class="p">(</span><span class="n">str2</span><span class="p">)</span> <span class="c1">// Imprime &quot;Hola&quot;</span>
</pre></div>
</td></tr></table>

<p>Los arrays también son estructuras y, por tanto, también tienen
semántica de copia:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">var</span> <span class="nv">array1</span> <span class="p">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="kd">var</span> <span class="nv">array2</span> <span class="p">=</span> <span class="n">array1</span>
<span class="n">array1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">=</span> <span class="mi">10</span>
<span class="bp">print</span><span class="p">(</span><span class="n">array1</span><span class="p">)</span> <span class="c1">// [10, 2, 3, 4]</span>
<span class="bp">print</span><span class="p">(</span><span class="n">array2</span><span class="p">)</span> <span class="c1">// [1, 2, 3, 4]</span>
</pre></div>
</td></tr></table>

<p>A diferencia de otros lenguajes como Java, los parámetros de una
función siempre son inmutables y se pasan por copia, para reforzar el
carácter funcional de las funciones. Por ejemplo, es incorrecto
escribir lo siguiente:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">func</span><span class="w"> </span><span class="n">ponCero</span><span class="p">(</span><span class="k">array</span><span class="err">:</span><span class="w"> </span><span class="o">[</span><span class="n">Int</span><span class="o">]</span><span class="p">,</span><span class="w"> </span><span class="nl">pos</span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="p">)</span><span class="w"> </span><span class="err">{</span><span class="w"></span>
<span class="w">    </span><span class="k">array</span><span class="o">[</span><span class="n">pos</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>
<span class="o">//</span><span class="w"> </span><span class="nl">error</span><span class="p">:</span><span class="w"> </span><span class="n">cannot</span><span class="w"> </span><span class="n">assign</span><span class="w"> </span><span class="n">through</span><span class="w"> </span><span class="nl">subscript</span><span class="p">:</span><span class="w"> </span><span class="s1">&#39;array&#39;</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="s1">&#39;let&#39;</span><span class="w"> </span><span class="n">constant</span><span class="w"></span>
<span class="err">}</span><span class="w"></span>
</pre></div>
</td></tr></table>

<p>Se podría pensar que es muy costoso copiar un array entero. Por
ejemplo, si asignamos o pasamos como parámetro un array de 1000
elementos. Pero no es así. El compilador de Swift optimiza estas
sentencias y sólo realiza la copia en el momento en que hay una
modificación de una de las variables que comparten el array. Es lo que
se llama <em>copy on write</em>.</p>
<h2 id="7-enumeraciones">7. Enumeraciones<a class="headerlink" href="#7-enumeraciones" title="Permanent link">&para;</a></h2>
<p>Las enumeraciones definen un tipo con un valor restringido de posibles
valores:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">enum</span> <span class="nc">Direccion</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">norte</span>
    <span class="k">case</span> <span class="n">sur</span>
    <span class="k">case</span> <span class="n">este</span>
    <span class="k">case</span> <span class="n">oeste</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<p>Cualquier variable del tipo <code>Direccion</code> solo puede tener uno de los
cuatro valores definidos. Se obtiene el valor escribiendo el nombre de
la enumeración, un punto y el valor definido. Si el tipo de
enumeración se puede inferir no es necesario escribirlo.</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">let</span> <span class="nv">hemosGirado</span> <span class="p">=</span> <span class="kc">true</span>
<span class="kd">var</span> <span class="nv">direccionActual</span> <span class="p">=</span> <span class="n">Direccion</span><span class="p">.</span><span class="n">norte</span>
<span class="k">if</span> <span class="n">hemosGirado</span> <span class="p">{</span>
   <span class="n">direccionActual</span> <span class="p">=</span> <span class="p">.</span><span class="n">sur</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<p>En sentencias switch:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">let</span> <span class="nv">direccionAIr</span> <span class="p">=</span> <span class="n">Direccion</span><span class="p">.</span><span class="n">sur</span>
<span class="k">switch</span> <span class="n">direccionAIr</span> <span class="p">{</span>
<span class="k">case</span> <span class="p">.</span><span class="n">norte</span><span class="p">:</span>
   <span class="bp">print</span><span class="p">(</span><span class="s">&quot;Nos vamos al norte&quot;</span><span class="p">)</span>
<span class="k">case</span> <span class="p">.</span><span class="n">sur</span><span class="p">:</span>
   <span class="bp">print</span><span class="p">(</span><span class="s">&quot;Cuidado con los pinguinos&quot;</span><span class="p">)</span>
<span class="k">case</span> <span class="p">.</span><span class="n">este</span><span class="p">:</span>
    <span class="bp">print</span><span class="p">(</span><span class="s">&quot;Donde nace el sol&quot;</span><span class="p">)</span>
<span class="k">case</span> <span class="p">.</span><span class="n">oeste</span><span class="p">:</span>
    <span class="bp">print</span><span class="p">(</span><span class="s">&quot;Donde el cielo es azul&quot;</span><span class="p">)</span>
<span class="p">}</span>
<span class="c1">// Imprime &quot;Cuidado con los pinguinos&quot;</span>
</pre></div>
</td></tr></table>

<p>Otro ejemplo:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">enum</span> <span class="nc">Planeta</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">mercurio</span><span class="p">,</span> <span class="n">venus</span><span class="p">,</span> <span class="n">tierra</span><span class="p">,</span> <span class="n">marte</span><span class="p">,</span> <span class="n">jupiter</span><span class="p">,</span> <span class="n">saturno</span><span class="p">,</span> <span class="n">urano</span><span class="p">,</span> <span class="n">neptuno</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<p>Y, por último, es más correcto definir el resultado de una quiniela con un
enumerado en lugar de con un <code>String</code>:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">enum</span> <span class="nc">Quiniela</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">uno</span><span class="p">,</span> <span class="n">equis</span><span class="p">,</span> <span class="n">dos</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<h3 id="71-valores-brutos-de-enumeraciones">7.1. Valores brutos de enumeraciones<a class="headerlink" href="#71-valores-brutos-de-enumeraciones" title="Permanent link">&para;</a></h3>
<p>Es posible asignar a las constantes del enumerado un valor concreto de
un tipo subyacente, por ejemplo enteros:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">enum</span> <span class="nc">Quiniela</span><span class="p">:</span> <span class="nb">Int</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">uno</span><span class="p">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">equis</span><span class="p">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">dos</span><span class="p">=</span><span class="mi">2</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<p>Se puede obtener el valor bruto a partir del propio tipo o de una
variable del tipo, usando <code>rawValue</code>:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="c1">// Obtenemos el valor bruto a partir del tipo</span>
<span class="kd">let</span> <span class="nv">valorEquis</span><span class="p">:</span> <span class="nb">Int</span> <span class="p">=</span> <span class="n">Quiniela</span><span class="p">.</span><span class="n">equis</span><span class="p">.</span><span class="n">rawValue</span>

<span class="c1">// Obtenemos el valor bruto a partir de una variable</span>
<span class="kd">let</span> <span class="nv">res</span> <span class="p">=</span> <span class="n">Quiniela</span><span class="p">.</span><span class="n">equis</span>
<span class="kd">let</span> <span class="nv">valorEquis</span> <span class="p">=</span> <span class="n">res</span><span class="p">.</span><span class="n">rawValue</span>
</pre></div>
</td></tr></table>

<p>También se puede asignar los valores de forma implícita, dando un
valor a la primera constante. Las siguientes tienen el valor consecutivo:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">enum</span> <span class="nc">Planeta</span><span class="p">:</span> <span class="nb">Int</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">mercurio</span><span class="p">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">venus</span><span class="p">,</span> <span class="n">tierra</span><span class="p">,</span> <span class="n">marte</span><span class="p">,</span> <span class="n">jupiter</span><span class="p">,</span> <span class="n">saturno</span><span class="p">,</span> <span class="n">urano</span><span class="p">,</span> <span class="n">neptuno</span>
<span class="p">}</span>
<span class="kd">let</span> <span class="nv">posicionTierra</span> <span class="p">=</span> <span class="n">Planeta</span><span class="p">.</span><span class="n">tierra</span><span class="p">.</span><span class="n">rawValue</span>
<span class="c1">// posicionTierra es 3</span>
</pre></div>
</td></tr></table>

<p>Podemos escoger cualquier tipo subyacente. Por ejemplo el tipo <code>Character</code>:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">enum</span> <span class="nc">CaracterControlASCII</span><span class="p">:</span> <span class="nb">Character</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">tab</span> <span class="p">=</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">&quot;</span>
    <span class="k">case</span> <span class="n">lineFeed</span> <span class="p">=</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span>
    <span class="k">case</span> <span class="n">carriageReturn</span> <span class="p">=</span> <span class="s">&quot;</span><span class="se">\r</span><span class="s">&quot;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<p>El carácter nueva línea (<em>lineFeed</em>) se puede obtener de la siguiente forma:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">let</span> <span class="n">nuevaLinea</span> <span class="o">=</span> <span class="n">CaracterControlASCII</span><span class="p">.</span><span class="n">LineFeed</span><span class="p">.</span><span class="n">rawValue</span>
</pre></div>
</td></tr></table>

<p>Y por último, se puede definir como tipo subyacente <code>String</code> y los
valores brutos de las constantes serán sus nombres convertidos a
cadenas:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">enum</span> <span class="nc">Direccion</span><span class="p">:</span> <span class="nb">String</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">norte</span><span class="p">,</span> <span class="n">sur</span><span class="p">,</span> <span class="n">este</span><span class="p">,</span> <span class="n">oeste</span>
<span class="p">}</span>
<span class="kd">let</span> <span class="nv">direccionAtardecer</span> <span class="p">=</span> <span class="n">Direccion</span><span class="p">.</span><span class="n">oeste</span><span class="p">.</span><span class="n">rawValue</span>
<span class="c1">// direccionAtardecer es &quot;oeste&quot;</span>
</pre></div>
</td></tr></table>

<p>En este caso, también se puede inicializar el valor bruto con una
asignación explícita y no usar el propio nombre:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">enum</span> <span class="nc">Direccion</span><span class="p">:</span> <span class="nb">String</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">norte</span> <span class="p">=</span> <span class="s">&quot;north&quot;</span>
    <span class="k">case</span> <span class="n">sur</span> <span class="p">=</span> <span class="s">&quot;south&quot;</span>
    <span class="k">case</span> <span class="n">este</span> <span class="p">=</span> <span class="s">&quot;east&quot;</span>
    <span class="k">case</span> <span class="n">oeste</span> <span class="p">=</span> <span class="s">&quot;west&quot;</span>
<span class="p">}</span>
<span class="kd">let</span> <span class="nv">direccionAtardecer</span> <span class="p">=</span> <span class="n">Direccion</span><span class="p">.</span><span class="n">oeste</span><span class="p">.</span><span class="n">rawValue</span>
<span class="c1">// direccionAtardecer es &quot;west&quot;</span>
</pre></div>
</td></tr></table>

<p>Cuando se definen valores brutos es posible inicializar el enumerado
de una forma similar a una estructura o una clase pasando el valor
bruto. Devuelve el valor enumerado correspondiente o <code>nil</code> (un
opcional):</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">let</span> <span class="nv">posiblePlaneta</span> <span class="p">=</span> <span class="n">Planeta</span><span class="p">(</span><span class="n">rawValue</span><span class="p">:</span> <span class="mi">7</span><span class="p">)</span>
<span class="c1">// posiblePlaneta es de tipo Planeta? y es igual a Planeta.urano</span>
</pre></div>
</td></tr></table>

<h2 id="8-enumeraciones-instanciables">8. Enumeraciones instanciables<a class="headerlink" href="#8-enumeraciones-instanciables" title="Permanent link">&para;</a></h2>
<p>Una característica singular de las enumeraciones en Swift es que
permiten definir valores variables asociados a cada caso de la
enumeración, creando algo muy parecido a una instancia de la
enumeración.</p>
<h3 id="81-valores-asociados-a-instancias-de-enumeraciones">8.1. Valores asociados a instancias de enumeraciones<a class="headerlink" href="#81-valores-asociados-a-instancias-de-enumeraciones" title="Permanent link">&para;</a></h3>
<p>Un enumerado instanciable permite asociar valores a la instancia del
enumerado. Para crear una instancia del enumerado debemos proporcionar
el valor asociado.</p>
<p>Al igual que un enumerado normal, el enumerado puede especificar
distintos casos. Cada caso puede determinar un tipo de valor asociado.</p>
<p>En otros lenguajes de programación se llaman <em>uniones etiquetadas</em> o
<em>variantes</em>.</p>
<p>Por ejemplo, podemos definir un enumerado que permita guardar un
<code>Int</code> o un <code>String</code>:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">enum</span> <span class="nc">Multiple</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">num</span><span class="p">(</span><span class="nb">Int</span><span class="p">)</span>
    <span class="k">case</span> <span class="n">str</span><span class="p">(</span><span class="nb">String</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<p>De esta forma, podemos crear valores de tipo <code>Multiple</code> que contienen
un <code>Int</code> (instanciando el caso <code>num</code>) o un <code>String</code> (instanciando el
caso <code>str</code>):</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">let</span> <span class="nv">valor3</span> <span class="p">=</span> <span class="n">Multiple</span><span class="p">.</span><span class="n">num</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="kd">let</span> <span class="nv">valor4</span> <span class="p">=</span> <span class="n">Multiple</span><span class="p">.</span><span class="n">str</span><span class="p">(</span><span class="s">&quot;Hola&quot;</span><span class="p">)</span>
</pre></div>
</td></tr></table>

<p>Para obtener el valor asociado debemos usar una expresión <code>case let</code>
en una sentencia <code>switch</code> con una variable a la que se asigna el
valor. Por ejemplo, la siguiente función reciba instancias de tipo
<code>Multiple</code> e imprime el valor asociado al enumerado que se pasa como
parámetro.</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">func</span> <span class="nf">imprime</span><span class="p">(</span><span class="n">multiple</span><span class="p">:</span> <span class="n">Multiple</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">switch</span> <span class="n">multiple</span> <span class="p">{</span>
    <span class="k">case</span> <span class="kd">let</span> <span class="p">.</span><span class="n">num</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="bp">print</span><span class="p">(</span><span class="s">&quot;Multiple tiene un Int: </span><span class="si">\(</span><span class="n">x</span><span class="si">)</span><span class="s">&quot;</span><span class="p">)</span>
    <span class="k">case</span> <span class="kd">let</span> <span class="p">.</span><span class="n">str</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
        <span class="bp">print</span><span class="p">(</span><span class="s">&quot;Multiple tiene un String: </span><span class="si">\(</span><span class="n">s</span><span class="si">)</span><span class="s">&quot;</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="n">imprime</span><span class="p">(</span><span class="n">multiple</span><span class="p">:</span> <span class="n">valor3</span><span class="p">)</span>
<span class="c1">// Imprime &quot;Multiple tiene un Int: 10&quot;</span>
<span class="n">imprime</span><span class="p">(</span><span class="n">multiple</span><span class="p">:</span> <span class="n">valor4</span><span class="p">)</span>
<span class="c1">// Imprime &quot;Multiple tiene un String: Hola</span>
</pre></div>
</td></tr></table>

<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>No hay que confundir un valor asociado a un caso y un valor bruto:
el valor bruto de un caso de enumeración es el mismo para todas
las instancias, mientras que el valor asociado es distinto y se
proporciona cuando se define el valor concreto de la enumeración.</p>
</div>
<p>El tipo del caso también puede ser un tipo compuesto, como una
tupla. Usamos un enum para definir posibles valores de un código de
barras, en el que incluimos dos posibles tipos de código de barras: el
código de barras lineal (denominado UPC) y el código QR:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">enum</span> <span class="nc">CodigoBarras</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">upc</span><span class="p">(</span><span class="nb">Int</span><span class="p">,</span> <span class="nb">Int</span><span class="p">,</span> <span class="nb">Int</span><span class="p">,</span> <span class="nb">Int</span><span class="p">)</span>
    <span class="k">case</span> <span class="n">qrCode</span><span class="p">(</span><span class="nb">String</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<p>Se lee de la siguiente forma: “Definimos un tipo enumerado llamado
<code>CodigoBarras</code>, que puede tomar como valor un <code>upc</code> (código de barras
lineal) con un valor asociado de tipo <code>(Int, Int, Int, Int)</code> (una
tupla de 4 enteros que representan los 4 números que hay en los
códigos de barras lineales) o un valor <code>qrCode</code> con valor asociado de
tipo <code>String</code>". </p>
<p>Veamos un ejemplo de uso, en el que creamos un código de barras de
producto de tipo UPC, después lo modificamos a otro de tipo código QR
y por último lo imprimimos:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">var</span> <span class="nv">codigoBarrasProducto</span> <span class="p">=</span> <span class="n">CodigoBarras</span><span class="p">.</span><span class="n">upc</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">85909</span><span class="p">,</span> <span class="mi">51226</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="n">codigoBarrasProducto</span> <span class="p">=</span> <span class="p">.</span><span class="n">qrCode</span><span class="p">(</span><span class="s">&quot;ABCDEFGHIJKLMNOP&quot;</span><span class="p">)</span>

<span class="k">switch</span> <span class="n">codigoBarrasProducto</span> <span class="p">{</span>
<span class="k">case</span> <span class="kd">let</span> <span class="p">.</span><span class="n">upc</span><span class="p">(</span><span class="n">sistemaNumeracion</span><span class="p">,</span> <span class="n">fabricante</span><span class="p">,</span> <span class="n">producto</span><span class="p">,</span> <span class="n">control</span><span class="p">):</span>
   <span class="bp">print</span><span class="p">(</span><span class="s">&quot;UPC: </span><span class="si">\(</span><span class="n">sistemaNumeracion</span><span class="si">)</span><span class="s">, </span><span class="si">\(</span><span class="n">fabricante</span><span class="si">)</span><span class="s">, </span><span class="si">\(</span><span class="n">producto</span><span class="si">)</span><span class="s">, </span><span class="si">\(</span><span class="n">control</span><span class="si">)</span><span class="s">.&quot;</span><span class="p">)</span>
<span class="k">case</span> <span class="kd">let</span> <span class="p">.</span><span class="n">qrCode</span><span class="p">(</span><span class="n">codigoProducto</span><span class="p">):</span>
   <span class="bp">print</span><span class="p">(</span><span class="s">&quot;Código QR: </span><span class="si">\(</span><span class="n">codigoProducto</span><span class="si">)</span><span class="s">.&quot;</span><span class="p">)</span>
<span class="p">}</span>
<span class="c1">// Imprime  &quot;Código QR : ABCDEFGHIJKLMNOP.&quot;</span>
</pre></div>
</td></tr></table>

<h3 id="82-enumeraciones-recursivas">8.2. Enumeraciones recursivas<a class="headerlink" href="#82-enumeraciones-recursivas" title="Permanent link">&para;</a></h3>
<p>Es posible combinar las características de las enumeraciones con valor
con la recursión para crear enumeraciones recursivas. Hay que preceder
la palabra clave <code>enum</code> con <code>indirect</code>:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kr">indirect</span> <span class="kd">enum</span> <span class="nc">ExpresionAritmetica</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">numero</span><span class="p">(</span><span class="nb">Int</span><span class="p">)</span>
    <span class="k">case</span> <span class="n">suma</span><span class="p">(</span><span class="n">ExpresionAritmetica</span><span class="p">,</span> <span class="n">ExpresionAritmetica</span><span class="p">)</span>
    <span class="k">case</span> <span class="n">multiplicacion</span><span class="p">(</span><span class="n">ExpresionAritmetica</span><span class="p">,</span> <span class="n">ExpresionAritmetica</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nv">cinco</span> <span class="p">=</span> <span class="n">ExpresionAritmetica</span><span class="p">.</span><span class="n">numero</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="kd">let</span> <span class="nv">cuatro</span> <span class="p">=</span> <span class="n">ExpresionAritmetica</span><span class="p">.</span><span class="n">numero</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="kd">let</span> <span class="nv">suma</span> <span class="p">=</span> <span class="n">ExpresionAritmetica</span><span class="p">.</span><span class="n">suma</span><span class="p">(</span><span class="n">cinco</span><span class="p">,</span> <span class="n">cuatro</span><span class="p">)</span>
<span class="kd">let</span> <span class="nv">producto</span> <span class="p">=</span> <span class="n">ExpresionAritmetica</span><span class="p">.</span><span class="n">multiplicacion</span><span class="p">(</span><span class="n">suma</span><span class="p">,</span> <span class="n">ExpresionAritmetica</span><span class="p">.</span><span class="n">numero</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
</pre></div>
</td></tr></table>

<p>Es muy cómodo manejar enumeraciones recursivas de forma recursiva:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">func</span> <span class="nf">evalua</span><span class="p">(</span><span class="n">expresion</span><span class="p">:</span> <span class="n">ExpresionAritmetica</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Int</span> <span class="p">{</span>
    <span class="k">switch</span> <span class="n">expresion</span> <span class="p">{</span>
    <span class="k">case</span> <span class="kd">let</span> <span class="p">.</span><span class="n">numero</span><span class="p">(</span><span class="n">valor</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">valor</span>
    <span class="k">case</span> <span class="kd">let</span> <span class="p">.</span><span class="n">suma</span><span class="p">(</span><span class="n">izquierda</span><span class="p">,</span> <span class="n">derecha</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">evalua</span><span class="p">(</span><span class="n">expresion</span><span class="p">:</span> <span class="n">izquierda</span><span class="p">)</span> <span class="o">+</span> <span class="n">evalua</span><span class="p">(</span><span class="n">expresion</span><span class="p">:</span> <span class="n">derecha</span><span class="p">)</span>
    <span class="k">case</span> <span class="kd">let</span> <span class="p">.</span><span class="n">multiplicacion</span><span class="p">(</span><span class="n">izquierda</span><span class="p">,</span> <span class="n">derecha</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">evalua</span><span class="p">(</span><span class="n">expresion</span><span class="p">:</span> <span class="n">izquierda</span><span class="p">)</span> <span class="o">*</span> <span class="n">evalua</span><span class="p">(</span><span class="n">expresion</span><span class="p">:</span> <span class="n">derecha</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="bp">print</span><span class="p">(</span><span class="n">evalua</span><span class="p">(</span><span class="n">expresion</span><span class="p">:</span> <span class="n">producto</span><span class="p">))</span>
<span class="c1">// Imprime 18</span>
</pre></div>
</td></tr></table>

<p>Otro ejemplo de enums recursivos, para definir un tipo de datos
<code>Lista</code> similar al que vimos en Scheme. La lista puede ser una lista
vacía o puede contener dos elementos: un valor <code>Int</code> y otra lista:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kr">indirect</span> <span class="kd">enum</span> <span class="nc">Lista</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">vacia</span>
    <span class="k">case</span> <span class="n">nodo</span><span class="p">(</span><span class="nb">Int</span><span class="p">,</span> <span class="n">Lista</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<p>Para crear una lista de tipo <code>nodo</code> deberemos dar un valor entero (el
valor de la cabeza de la lista) y otra lista (el resto de la
lista). También podemos crear una lista vacía.</p>
<p>Por ejemplo, podemos crear la lista <code>(10, 20, 30)</code> de la siguiente
manera:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">let</span> <span class="nv">lista1</span> <span class="p">=</span> <span class="n">Lista</span><span class="p">.</span><span class="n">nodo</span><span class="p">(</span><span class="mi">30</span><span class="p">,</span> <span class="n">Lista</span><span class="p">.</span><span class="n">vacia</span><span class="p">)</span>
<span class="kd">let</span> <span class="nv">lista2</span> <span class="p">=</span> <span class="n">Lista</span><span class="p">.</span><span class="n">nodo</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="n">lista1</span><span class="p">)</span>
<span class="kd">let</span> <span class="nv">lista3</span> <span class="p">=</span> <span class="n">Lista</span><span class="p">.</span><span class="n">nodo</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">lista2</span><span class="p">)</span>
</pre></div>
</td></tr></table>

<p>Podríamos crear esta misma lista de una forma más abreviada:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">let</span> <span class="nv">lista</span><span class="p">:</span> <span class="n">Lista</span> <span class="p">=</span> <span class="p">.</span><span class="n">nodo</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="p">.</span><span class="n">nodo</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="p">.</span><span class="n">nodo</span><span class="p">(</span><span class="mi">30</span><span class="p">,</span> <span class="p">.</span><span class="n">vacia</span><span class="p">)))</span>
</pre></div>
</td></tr></table>

<p>Una vez definido el tipo enumerado, podemos definir funciones que
trabajen con él. La siguiente función, por ejemplo, es una función
recursiva que recibe una lista y devuelve la suma de sus
elementos. Funciona de una forma muy similar a la definición que
hicimos en Scheme:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">func</span> <span class="nf">suma</span><span class="p">(</span><span class="n">lista</span><span class="p">:</span> <span class="n">Lista</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Int</span> <span class="p">{</span>
    <span class="k">switch</span> <span class="n">lista</span> <span class="p">{</span>
    <span class="k">case</span>  <span class="p">.</span><span class="n">vacia</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>
    <span class="k">case</span> <span class="kd">let</span> <span class="p">.</span><span class="n">nodo</span><span class="p">(</span><span class="bp">first</span><span class="p">,</span> <span class="n">rest</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">first</span> <span class="o">+</span> <span class="n">suma</span><span class="p">(</span><span class="n">lista</span><span class="p">:</span> <span class="n">rest</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nv">z</span><span class="p">:</span> <span class="n">Lista</span> <span class="p">=</span> <span class="p">.</span><span class="n">nodo</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="p">.</span><span class="n">nodo</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="p">.</span><span class="n">vacia</span><span class="p">))</span>

<span class="bp">print</span><span class="p">(</span><span class="n">suma</span><span class="p">(</span><span class="n">lista</span><span class="p">:</span> <span class="n">z</span><span class="p">))</span>
<span class="c1">// Imprime 30</span>
</pre></div>
</td></tr></table>

<p>Podemos también definir una función recursiva <code>construye(lista:[Int])</code>
que devuelve una lista a partir de una array de enteros:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">func</span> <span class="nf">construye</span><span class="p">(</span><span class="n">lista</span><span class="p">:</span> <span class="p">[</span><span class="nb">Int</span><span class="p">])</span> <span class="p">-&gt;</span> <span class="n">Lista</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">lista</span><span class="p">.</span><span class="bp">isEmpty</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">Lista</span><span class="p">.</span><span class="n">vacia</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="kd">let</span> <span class="nv">primero</span> <span class="p">=</span> <span class="n">lista</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="kd">let</span> <span class="nv">resto</span> <span class="p">=</span> <span class="nb">Array</span><span class="p">(</span><span class="n">lista</span><span class="p">.</span><span class="bp">dropFirst</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">Lista</span><span class="p">.</span><span class="n">nodo</span><span class="p">(</span><span class="n">primero</span><span class="p">,</span> <span class="n">construye</span><span class="p">(</span><span class="n">lista</span><span class="p">:</span> <span class="n">resto</span><span class="p">))</span>
    <span class="p">}</span> 
<span class="p">}</span>

<span class="kd">let</span> <span class="nv">lista2</span> <span class="p">=</span> <span class="n">construye</span><span class="p">(</span><span class="n">lista</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">])</span>

<span class="bp">print</span><span class="p">(</span><span class="n">suma</span><span class="p">(</span><span class="n">lista</span><span class="p">:</span> <span class="n">lista2</span><span class="p">))</span>
<span class="c1">// Imprime 15</span>
</pre></div>
</td></tr></table>

<!--

## 9. Opcionales

Una de las características principales que Swift intenta promover es
la seguridad y la robustez. Debe ser difícil que el desarrollador
escriba código con errores y que rompa la aplicación. Por ejemplo, la
comprobación estática de los tipos de datos o el manejo automático de
la gestión de memoria son dos características del lenguaje que van en
esta dirección.

Otro de los elementos más importantes del lenguaje para promover la
seguridad son los opcionales. Vamos a estudiar su uso y utilidad.

En muchos lenguajes existe el concepto de _valor vacío_. Por ejemplo,
en Java se usa _null_ o en Python _None_. 

!!! Note "Nota"
    Tony Hoare introdujo el concepto de _Null_ en ALGOL, en 1965. En
    una conferencia en 2009 habla sobre esta idea y la considera un
    costoso error: [Null References: The Billion Dollar
    Mistake](https://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare). 

El concepto de _null_ es un concepto peligroso, como lo saben bien los
desarrolladores Java. En Java, si intentamos usar una variable que
contiene _null_ se produce la típica excepción _null pointer
exception_ y la aplicación se rompe. Todos hemos caído en este error,
y con más frecuencia de la que sería deseable.

En Swift también existe el valor nulo. La forma de representarlo es el
identificador `nil`. 

La característica de seguridad que introduce Swift con respecto a Java
y a otros lenguajes es que no es posible asignar `nil` a una variable
de un tipo normal.

Por ejemplo, la siguiente línea daría un error de compilación:

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">let</span> <span class="nv">cadena</span><span class="p">:</span> <span class="nb">String</span> <span class="p">=</span> <span class="kc">nil</span>
<span class="c1">// error: &#39;nil&#39; cannot initialize specified type &#39;String&#39;</span>
</pre></div>
</td></tr></table>

Si queremos utilizar `nil` debemos declarar la variable usando lo que
se denomina **tipo opcional**:

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">var</span> <span class="nv">cadena</span><span class="p">:</span> <span class="nb">String</span><span class="p">?</span> <span class="p">=</span> <span class="s">&quot;Hola&quot;</span>
<span class="n">cadena</span> <span class="p">=</span> <span class="kc">nil</span>
</pre></div>
</td></tr></table>

El tipo `String?` indica que podemos tener un valor `nil` o un valor
del tipo original. Primero estamos definiendo la variable `cadena` del
tipo `String?` (`String` opcional) y le estamos asignando un valor
determinado (de tipo `String`). Y después le asignamos `nil`.

El uso de opcionales es necesario en situaciones en las que podemos
obtener un valor desconocido. Por ejemplo, en alguna función en la que
pedimos un valor al usuario y el usuario puede no introducir
ninguno. O en estructuras de datos en las que hacemos búsquedas que
pueden no devolver ningún valor, como en un diccionario:

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">var</span> <span class="nv">edades</span> <span class="p">=</span> <span class="p">[</span>
    <span class="s">&quot;Raquel&quot;</span><span class="p">:</span> <span class="mi">30</span><span class="p">,</span>
    <span class="s">&quot;Pedro&quot;</span><span class="p">:</span> <span class="mi">22</span><span class="p">,</span>
<span class="p">]</span>
<span class="kd">let</span> <span class="nv">edad1</span> <span class="p">=</span> <span class="n">edades</span><span class="p">[</span><span class="s">&quot;Raquel&quot;</span><span class="p">]</span>
<span class="kd">let</span> <span class="nv">edad2</span> <span class="p">=</span> <span class="n">edades</span><span class="p">[</span><span class="s">&quot;Ana&quot;</span><span class="p">]</span> <span class="c1">// devuelve nil</span>
</pre></div>
</td></tr></table>

En el código anterior definimos un diccionario `edades` con claves de
tipo `String` y valores `Int`. Después buscamos en el diccionario por
la clave `"Raquel"` y se devuelve el valor `30`, que se guarda en la
variable `edad1`. Cuando se busca por la clave `"Ana"` se devuelve un
`nil` porque no está definida. 

Por ello, la variable `edad2` será de tipo `Int?` (`Int` opcional) y
contendrá un `nil`.

Un valor opcional no puede ser usado directamente. Primero debemos
comprobar si el valor es distinto de `nil` y sólo después podremos
usarlo. 

Para reforzar esto, Swift _esconde_ o _envuelve_ (_wrap_) el valor
real del opcional y obliga a llamar al operador `!` para
_desenvolverlo_ (_unwrap_) y usarlo. Este operador se denomina de
**desenvoltura forzosa** (_forced unwrapping_).

Por ejemplo, el siguiente código produce un error de compilación
porque intentamos usar un opcional sin desenvolverlo:

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">var</span> <span class="nv">x</span><span class="p">:</span> <span class="nb">Int</span><span class="p">?</span> <span class="p">=</span> <span class="mi">10</span>
<span class="kd">let</span> <span class="nv">y</span> <span class="p">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">10</span> 
<span class="c1">// error: value of optional type &#39;Int?&#39; must be unwrapped to a value of type &#39;Int&#39;</span>
</pre></div>
</td></tr></table>

Para usar el valor asignado a `x` debemos desenvolverlo con el
operador `!`:

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">var</span> <span class="nv">x</span><span class="p">:</span> <span class="nb">Int</span><span class="p">?</span> <span class="p">=</span> <span class="mi">10</span>
<span class="kd">let</span> <span class="nv">y</span> <span class="p">=</span> <span class="n">x</span><span class="p">!</span> <span class="o">+</span> <span class="mi">10</span> 
<span class="bp">print</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="c1">// Imprime &quot;20&quot;</span>
</pre></div>
</td></tr></table>

Si se aplica el operador `!` a un valor `nil` se produce un error en
tiempo de ejecución y la aplicación se rompe:

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">var</span> <span class="nv">respuestaEncuesta</span><span class="p">:</span> <span class="nb">String</span><span class="p">?</span>
<span class="bp">print</span><span class="p">(</span><span class="n">respuestaEncuesta</span><span class="p">!)</span>
<span class="c1">// Fatal error: Unexpectedly found nil while unwrapping an Optional value</span>
</pre></div>
</td></tr></table>

Podemos definir como opcional variables, parámetros
o valores devueltos por funciones de cualquier tipo, añadiéndoles la
interrogación al final.

Por ejemplo, la siguiente función `max` es una función que devuelve un
`Int?`, un entero opcional en el caso de que se le pase un array
vacío. Al devolver un opcional, debemos desenvolver el valor devuelto
cuando queramos usarlo como `Int` (por ejemplo, en la llamada recursiva).

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">func</span> <span class="nf">max</span><span class="p">(</span><span class="n">array</span><span class="p">:[</span><span class="nb">Int</span><span class="p">])</span> <span class="p">-&gt;</span> <span class="nb">Int</span><span class="p">?</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">array</span><span class="p">.</span><span class="bp">isEmpty</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kc">nil</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">array</span><span class="p">.</span><span class="bp">count</span> <span class="p">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">array</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="kd">let</span> <span class="nv">primero</span> <span class="p">=</span> <span class="n">array</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="kd">let</span> <span class="nv">resto</span> <span class="p">=</span> <span class="nb">Array</span><span class="p">(</span><span class="n">array</span><span class="p">.</span><span class="bp">dropFirst</span><span class="p">())</span>
        <span class="k">return</span> <span class="bp">max</span><span class="p">(</span><span class="n">primero</span><span class="p">,</span> <span class="bp">max</span><span class="p">(</span><span class="n">array</span><span class="p">:</span><span class="n">resto</span><span class="p">)</span><span class="o">!</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nv">maximo</span> <span class="p">=</span> <span class="bp">max</span><span class="p">(</span><span class="n">array</span><span class="p">:[</span><span class="mi">10</span><span class="p">,</span><span class="mi">200</span><span class="p">,</span><span class="o">-</span><span class="mi">100</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="bp">print</span><span class="p">(</span><span class="n">maximo</span><span class="p">!)</span>
<span class="c1">// Imprime &quot;200&quot;</span>
</pre></div>
</td></tr></table>

Una variable opcional sin asignar ningún valor se inicializa
automáticamente a `nil`:

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">var</span> <span class="nv">respuestaEncuesta</span><span class="p">:</span> <span class="nb">String</span><span class="p">?</span>
<span class="c1">// respuestaEncuesta es inicializado automáticamente a nil</span>
</pre></div>
</td></tr></table>

### 9.1 Ligado opcional

Para comprobar si un valor opcional es `nil` podemos usar un `if`. Es
obligado hacerlo si desconocemos el valor que nos llega. Por ejemplo,
supongamos que la función `leerRespuesta()` lee una respuesta del
usuario y devuelve un `String?`. Para usar esta función deberíamos
comprobar si el valor devuelto es distinto de `nil`:

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">let</span> <span class="nv">respuestaEncuesta</span> <span class="p">=</span> <span class="n">leerRespuesta</span><span class="p">()</span>
<span class="k">if</span> <span class="n">respuestaEncuesta</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nv">respuesta</span> <span class="p">=</span> <span class="n">respuestaEncuesta</span><span class="p">!</span>
    <span class="bp">print</span><span class="p">(</span><span class="s">&quot;Respuesta: &quot;</span> <span class="o">+</span> <span class="n">respuesta</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

Como es muy habitual hacer lo anterior, en Swift es posible comprobar
si un opcional tiene valor y asignar su valor a otra variable al mismo
tiempo con una construcción llamada _ligado opcional_ (_optional
binding_):

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">let</span> <span class="nv">respuestaEncuesta</span> <span class="p">=</span> <span class="n">leerRespuesta</span><span class="p">()</span>
<span class="k">if</span> <span class="kd">let</span> <span class="nv">respuesta</span> <span class="p">=</span> <span class="n">respuestaEncuesta</span> <span class="p">{</span>
    <span class="bp">print</span> <span class="p">(</span><span class="s">&quot;Respuesta: &quot;</span> <span class="o">+</span> <span class="n">respuesta</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

Podemos leer el código anterior de la siguiente forma: "Si el
opcional `respuestaEncuesta` contiene un valor, define
la constante `respuesta` con el valor contenido en el opcional".

Una forma aún mejor de escribir el código anterior sería la siguiente,
en la que sólo usamos una variable:

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="c1">// Mejor este código que el anterior</span>
<span class="k">if</span> <span class="kd">let</span> <span class="nv">respuesta</span> <span class="p">=</span> <span class="n">leerRespuesta</span><span class="p">()</span> <span class="p">{</span>
    <span class="bp">print</span> <span class="p">(</span><span class="s">&quot;Respuesta: &quot;</span> <span class="o">+</span> <span class="n">respuesta</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

!!! Note "Nota"
    Para no tener que buscar un nuevo nombre de variable, Swift permite 
    usar el mismo nombre de variable en la sentencia `if let`:

    <table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">var</span> <span class="nv">x</span><span class="p">:</span> <span class="nb">Int</span><span class="p">?</span> <span class="p">=</span> <span class="mi">0</span>
<span class="k">if</span> <span class="kd">let</span> <span class="nv">x</span> <span class="p">=</span> <span class="n">x</span> <span class="p">{</span>
    <span class="bp">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>
    La variable `x` creada por el `if let` es de tipo no opcional y sólo tiene valor 
    en el ámbito del `if`.

Otro ejemplo, el método `first` de un array devuelve un opcional que
contiene `nil` si el array está vacío o el primer elemento del array
en el caso en que exista. El siguiente código utiliza un ligado
opcional para implementar otra versión de la función que suma los
valores de un array:

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">func</span> <span class="nf">sumaValores</span><span class="p">(</span><span class="kc">_</span> <span class="n">valores</span><span class="p">:</span> <span class="p">[</span><span class="nb">Int</span><span class="p">])</span> <span class="p">-&gt;</span> <span class="nb">Int</span> <span class="p">{</span>
    <span class="k">if</span> <span class="kd">let</span> <span class="nv">primero</span> <span class="p">=</span> <span class="n">valores</span><span class="p">.</span><span class="bp">first</span> <span class="p">{</span>
        <span class="kd">let</span> <span class="nv">resto</span> <span class="p">=</span> <span class="nb">Array</span><span class="p">(</span><span class="n">valores</span><span class="p">.</span><span class="bp">dropFirst</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">primero</span> <span class="o">+</span> <span class="n">sumaValores</span><span class="p">(</span><span class="n">resto</span><span class="p">)</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">0</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="bp">print</span><span class="p">(</span><span class="n">sumaValores</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">]))</span> 
<span class="c1">// Imprime &quot;36&quot;</span>
</pre></div>
</td></tr></table>

Si tenemos varios opcionales es posible comprobar que todos ellos son
distintos de `nil` usando varios `let` en el mismo `if`:

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">var</span> <span class="nv">x1</span><span class="p">:</span> <span class="nb">Int</span><span class="p">?</span> <span class="p">=</span> <span class="n">pedirNumUsuario</span><span class="p">()</span>
<span class="kd">var</span> <span class="nv">x2</span><span class="p">:</span> <span class="nb">Int</span><span class="p">?</span> <span class="p">=</span> <span class="n">pedirNumUsuario</span><span class="p">()</span>
<span class="kd">var</span> <span class="nv">x3</span><span class="p">:</span> <span class="nb">Int</span><span class="p">?</span> <span class="p">=</span> <span class="n">pedirNumUsuario</span><span class="p">()</span>
<span class="k">if</span> <span class="kd">let</span> <span class="nv">dato1</span> <span class="p">=</span> <span class="n">x1</span><span class="p">,</span> <span class="kd">let</span> <span class="nv">dato2</span> <span class="p">=</span> <span class="n">x2</span><span class="p">,</span> <span class="kd">let</span> <span class="nv">dato3</span> <span class="p">=</span> <span class="n">x3</span> <span class="p">{</span>
   <span class="kd">let</span> <span class="nv">suma</span> <span class="p">=</span> <span class="n">dato1</span><span class="o">+</span><span class="n">dato2</span><span class="o">+</span><span class="n">dato3</span>
   <span class="bp">print</span><span class="p">(</span><span class="s">&quot;Ningún nil y la suma de todos los datos es: </span><span class="si">\(</span><span class="n">suma</span><span class="si">)</span><span class="s">&quot;</span><span class="p">)</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
   <span class="bp">print</span><span class="p">(</span><span class="s">&quot;Algún dato del usuario es nil&quot;</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

### 9.2 Comparación con opcionales ###

No es necesario desenvolver un opcional para compararlo con otro valor
usando los operadores `==` o `!=`.

Por ejemplo, el siguiente código es correcto:

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">var</span> <span class="nv">x</span><span class="p">:</span> <span class="nb">Int</span><span class="p">?</span> <span class="p">=</span> <span class="mi">10</span>
<span class="n">x</span> <span class="p">==</span> <span class="mi">10</span> <span class="c1">// devuelve true</span>
<span class="n">x</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="c1">// devuelve true</span>
<span class="n">x</span> <span class="p">==</span> <span class="mi">0</span> <span class="c1">// devuelve false</span>
</pre></div>
</td></tr></table>

Si en el opcional hay `nil` solo devolverá `true` cuando se compare
con `nil`:

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">x</span> <span class="p">=</span> <span class="kc">nil</span>
<span class="n">x</span> <span class="p">==</span> <span class="kc">nil</span> <span class="c1">// devuelve true</span>
<span class="n">x</span> <span class="p">==</span> <span class="mi">10</span> <span class="c1">// devuelve false</span>
</pre></div>
</td></tr></table>

### 9.3. Operador _nil-coalescing_ ###

El operador _nil-coalescing_ (`??`) permite definir un valor por
defecto en una asignación si un opcional es nil.

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">let</span> <span class="nv">a</span><span class="p">:</span> <span class="nb">Int</span><span class="p">?</span> <span class="p">=</span> <span class="kc">nil</span>
<span class="kd">let</span> <span class="nv">b</span><span class="p">:</span> <span class="nb">Int</span><span class="p">?</span> <span class="p">=</span> <span class="mi">10</span>
<span class="kd">let</span> <span class="nv">x</span> <span class="p">=</span> <span class="n">a</span> <span class="p">??</span> <span class="o">-</span><span class="mi">1</span>
<span class="kd">let</span> <span class="nv">y</span> <span class="p">=</span> <span class="n">b</span> <span class="p">??</span> <span class="o">-</span><span class="mi">1</span>
<span class="bp">print</span><span class="p">(</span><span class="s">&quot;Resultado: </span><span class="si">\(</span><span class="n">x</span><span class="si">)</span><span class="s">, </span><span class="si">\(</span><span class="n">y</span><span class="si">)</span><span class="s">&quot;</span><span class="p">)</span>
<span class="c1">// Imprime Resultado: -1, 10</span>
</pre></div>
</td></tr></table>

En el ejemplo anterior, en la variable `x` se guardará el valor `-1` y
en la variable `y` el valor `10`.

### 9.4. Encadenamiento de opcionales ###

El encadenamiento de opcionales (_optional chaining_) permite llamar a
un método de una variable que contiene un opcional. Si la variable no
es `nil`, se ejecuta el método y se devuelve su valor como un
opcional. Si la variable es `nil` se devuelve `nil`.


<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">let</span> <span class="nv">nombre1</span><span class="p">:</span> <span class="nb">String</span><span class="p">?</span> <span class="p">=</span> <span class="s">&quot;Pedro&quot;</span>
<span class="kd">let</span> <span class="nv">nombre2</span><span class="p">:</span> <span class="nb">String</span><span class="p">?</span> <span class="p">=</span> <span class="kc">nil</span>

<span class="c1">// Error: let str1 = nombre1.lowercased()</span>
<span class="c1">// No podemos llamar al método lowercased() del String</span>
<span class="c1">// porque nombre es opcional y puede tener nil</span>

<span class="kd">let</span> <span class="nv">str1</span> <span class="p">=</span> <span class="n">nombre1</span><span class="p">?.</span><span class="n">lowercased</span><span class="p">()</span>
<span class="kd">let</span> <span class="nv">str2</span> <span class="p">=</span> <span class="n">nombre2</span><span class="p">?.</span><span class="n">lowercased</span><span class="p">()</span>
<span class="c1">// str1: String? = &quot;pedro&quot;</span>
<span class="c1">// str2: String? = nil</span>
</pre></div>
</td></tr></table>


### 9.5. Definición de `Lista` con opcionales

Veamos como último ejemplo una segunda versión del enum `Lista`, en el que
utilizamos un único `case`, pero dando la posibilidad de que el resto
de la lista sea `nil` haciéndolo opcional.

Definimos el enumerado y también la función `suma(lista:)`:

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kr">indirect</span> <span class="kd">enum</span> <span class="nc">Lista</span><span class="p">{</span>
    <span class="k">case</span> <span class="n">nodo</span><span class="p">(</span><span class="nb">Int</span><span class="p">,</span> <span class="n">Lista</span><span class="p">?)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">suma</span><span class="p">(</span><span class="n">lista</span><span class="p">:</span> <span class="n">Lista</span><span class="p">?)</span> <span class="p">-&gt;</span> <span class="nb">Int</span> <span class="p">{</span>
    <span class="k">switch</span> <span class="n">lista</span> <span class="p">{</span>
        <span class="k">case</span> <span class="kc">nil</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">case</span> <span class="kd">let</span> <span class="p">.</span><span class="n">nodo</span><span class="p">(</span><span class="bp">first</span><span class="p">,</span> <span class="n">rest</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">first</span> <span class="o">+</span> <span class="n">suma</span><span class="p">(</span><span class="n">lista</span><span class="p">:</span> <span class="n">rest</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nv">z</span><span class="p">:</span> <span class="n">Lista</span> <span class="p">=</span> <span class="p">.</span><span class="n">nodo</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="p">.</span><span class="n">nodo</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="kc">nil</span><span class="p">))</span>
<span class="bp">print</span><span class="p">(</span><span class="n">suma</span><span class="p">(</span><span class="n">lista</span><span class="p">:</span> <span class="n">z</span><span class="p">))</span>
<span class="c1">/// Devuelve 30</span>
</pre></div>
</td></tr></table>


## 10. Clausuras

Ya hemos visto previamente que en Swift las funciones son objetos de
primera clase del lenguaje y que es posible definir funciones y
pasarlas como parámetro de otras funciones. 

También es posible construir clausuras, funciones definidas en el
ámbito de otras funcionas y devueltas como resultados.

Veremos primero cómo definir de forma compacta funciones que se pasan
como parámetro de otras, utilizando _expresiones de clausuras_. Y
después veremos cómo las clausuras definidas en el interior de otras
funciones capturan las variables definidas en el ámbito de la función principal.


### 10.1. Expresiones de clausuras

Swift permite definir expresiones compactas con las que construir
estas funciones que se pasan como parámetro de otras funciones. Se
denominan _expresiones de clausuras_ (_closure expressions_). Estas
expresiones proporcionan optimizaciones de sintaxis para escribir
clausuras de forma concisa y clara. Vamos a ver las distintas
optimizaciones utilizando como ejemplo el método `sorted(by:)`.

### 10.2. El método `sorted(by:)`

Tal y como hemos visto anteriormente la biblioteca stándar de Swift
define un método `sorted()` que devuelve los elementos ordenados de un
[Array](https://developer.apple.com/reference/swift/array). El array
original no se modifica. La comparación entre los elementos se realiza
usando el comparador `<`.

Veamos un ejemplo con un array de cadenas:

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">let</span> <span class="nv">estudiantes</span> <span class="p">=</span> <span class="p">[</span><span class="s">&quot;Kofi&quot;</span><span class="p">,</span> <span class="s">&quot;Abena&quot;</span><span class="p">,</span> <span class="s">&quot;Peter&quot;</span><span class="p">,</span> <span class="s">&quot;Kweku&quot;</span><span class="p">,</span> <span class="s">&quot;Akosua&quot;</span><span class="p">]</span>
<span class="kd">let</span> <span class="nv">ordenados</span> <span class="p">=</span> <span class="n">estudiantes</span><span class="p">.</span><span class="bp">sorted</span><span class="p">()</span>
<span class="bp">print</span><span class="p">(</span><span class="n">ordenados</span><span class="p">)</span>
<span class="c1">// Imprime &quot;[&quot;Abena&quot;, &quot;Akosua&quot;, &quot;Kofi&quot;, &quot;Kweku&quot;, &quot;Peter&quot;]&quot;</span>
</pre></div>
</td></tr></table>

Esta función es similar a las que hay en muchos lenguajes. El único
aspecto funcional es que el array original no se modifica, sino que la
ordenación construye un nuevo array (existe una función alternativa
mutable que se denomina `sort()`). 

Lo interesante relacionado con las clausuras está en la función
`sorted(by:)`. En esta función se utiliza una clausura como parámetro
para modificar la comparación entre elementos y resultar en una
ordenación distinta. Es una de las distintas funciones de orden
superior que se definen en las colecciones (más adelante veremos
otras).

El perfil de la función `sorted(by:)` es:

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">func</span> <span class="n">sorted</span><span class="p">(</span><span class="k">by</span> <span class="n">areInIncreasingOrder</span><span class="p">:</span> <span class="p">(</span><span class="n">Element</span><span class="p">,</span> <span class="n">Element</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Bool</span><span class="p">)</span>
</pre></div>
</td></tr></table>

El parámetro es una función de dos parámetros (del tipo de los
elementos del array) que devuelve un booleano indicando si el primer
parámetro va antes que el segundo en el array ordenado. La clausura de
ordenación devuelve `true` si el primer valor debería aparecer antes
del segundo valor y `false` en otro caso.

Por ejemplo, podríamos ordenar un array de cadenas en orden alfabético
inverso. 

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">func</span> <span class="nf">primeroMayor</span><span class="p">(</span><span class="n">s1</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span> <span class="n">s2</span><span class="p">:</span> <span class="nb">String</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Bool</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">s1</span> <span class="o">&gt;</span> <span class="n">s2</span>
<span class="p">}</span>
<span class="kd">let</span> <span class="nv">estudiantes</span> <span class="p">=</span> <span class="p">[</span><span class="s">&quot;Kofi&quot;</span><span class="p">,</span> <span class="s">&quot;Abena&quot;</span><span class="p">,</span> <span class="s">&quot;Peter&quot;</span><span class="p">,</span> <span class="s">&quot;Kweku&quot;</span><span class="p">,</span> <span class="s">&quot;Akosua&quot;</span><span class="p">]</span>
<span class="kd">let</span> <span class="nv">alreves</span> <span class="p">=</span> <span class="n">estudiantes</span><span class="p">.</span><span class="bp">sorted</span><span class="p">(</span><span class="n">by</span><span class="p">:</span> <span class="n">primeroMayor</span><span class="p">)</span>
<span class="bp">print</span><span class="p">(</span><span class="n">alreves</span><span class="p">)</span>
<span class="c1">// Imprime [&quot;Peter&quot;, &quot;Kweku&quot;, &quot;Kofi&quot;, &quot;Akosua&quot;, &quot;Abena&quot;]</span>
</pre></div>
</td></tr></table>

Si la primera cadena (`s1`) es mayor que la segunda cadena (`s2`), la
función `primeroMayor(s1:s2:)` devolverá `true`, indicando que `s1`
debería aparecer antes que `s2` en el array ordenado. La ordenación
mayor o menor se refiere a la ordenación alfabética, al estar tratando
con caracteres.

La versión anterior esta es una forma bastante complicada de escribir
lo que básicamente es una función de una única expresión (`a > b`). En
este ejemplo, sería preferible escribir la clausura de ordenación
_inline_, utilizando la sintaxis de expresiones de clausuras.

### 10.3. Sintaxis de las expresiones de clausura

La sintaxis de las expresiones de clausura tiene la siguiente forma
general:

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span>{ ( &lt;parametros&gt;) -&gt; &lt;tipo devuelto&gt; in
   &lt;sentencias&gt;
}
</pre></div>
</td></tr></table>

Si aplicamos esta sintaxis al ejemplo anterior:

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">let</span> <span class="nv">alreves</span> <span class="p">=</span> <span class="n">estudiantes</span><span class="p">.</span><span class="bp">sorted</span><span class="p">(</span><span class="n">by</span><span class="p">:</span> <span class="p">{</span> <span class="p">(</span><span class="n">s1</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span> <span class="n">s2</span><span class="p">:</span> <span class="nb">String</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Bool</span> <span class="k">in</span>
    <span class="k">return</span> <span class="n">s1</span> <span class="o">&gt;</span> <span class="n">s2</span>
<span class="p">})</span>
</pre></div>
</td></tr></table>

Hay que hacer notar que la declaración de los parámetros y el tipo
devuelto por esta clausura _inline_ es idéntica a la declaración de la
función `primeroMayor(s1:s2:)`. En ambos casos, se escribe como `(s1:
String, s2: String) -> Bool`. Sin embargo, en la expresión de clausura
los parámetros y el tipo devuelto se escribe dentro de las llaves, no
fuera.

El comienzo del cuerpo de la clausura se introduce por la palabra
clave `in`. Esta palabra clave indica que la definición de los
parámetros y del tipo devuelto por la clausura ha terminado, y que el
cuerpo de la clausura va a comenzar.

Como el cuerpo de la clausura es corto, podemos incluso escribirlo en
una única línea:

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">let</span> <span class="nv">alreves</span> <span class="p">=</span> <span class="n">estudiantes</span><span class="p">.</span><span class="bp">sorted</span><span class="p">(</span><span class="n">by</span><span class="p">:</span> <span class="p">{</span> <span class="p">(</span><span class="n">s1</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span> <span class="n">s2</span><span class="p">:</span> <span class="nb">String</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Bool</span> <span class="k">in</span> <span class="k">return</span> <span class="n">s1</span> <span class="o">&gt;</span> <span class="n">s2</span> <span class="p">}</span> <span class="p">)</span>
</pre></div>
</td></tr></table>

### 10.4. Inferencia del tipo por el contexto

Como la clausura de ordenación se pasa como argumento de un método,
Swift puede inferir los tipos de sus parámetros y el tipo del valor
que devuelve. El método `sorted(by:)` se llama sobre un array de cadenas,
por lo que su argumento debe ser una función del tipo `(String,
String) -> Bool`. Esto significa que los tipos `(String, String)` y
`Bool` no necesitan escribirse como parte de la definición de la
expresión de la clausura. Debido a que todos los tipos pueden ser
inferidos, la flecha del tipo devuelto y los paréntesis alrededor de
los nombres de los parámetros también pueden omitirse:

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">let</span> <span class="nv">alreves</span> <span class="p">=</span> <span class="n">estudiantes</span><span class="p">.</span><span class="bp">sorted</span><span class="p">(</span><span class="n">by</span><span class="p">:</span> <span class="p">{</span> <span class="n">s1</span><span class="p">,</span> <span class="n">s2</span> <span class="k">in</span> <span class="k">return</span> <span class="n">s1</span> <span class="o">&gt;</span> <span class="n">s2</span> <span class="p">}</span> <span class="p">)</span>
</pre></div>
</td></tr></table>

### 10.5. Devoluciones implícitas en clausuras con una única expresión

En clausuras con una única expresión podemos omitir también la palabra
clave `return`:

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">let</span> <span class="nv">alreves</span> <span class="p">=</span> <span class="n">estudiantes</span><span class="p">.</span><span class="bp">sorted</span><span class="p">(</span><span class="n">by</span><span class="p">:</span> <span class="p">{</span> <span class="n">s1</span><span class="p">,</span> <span class="n">s2</span> <span class="k">in</span> <span class="n">s1</span> <span class="o">&gt;</span> <span class="n">s2</span> <span class="p">}</span> <span class="p">)</span>
</pre></div>
</td></tr></table>

### 10.6. Abreviaturas en los nombres de los argumentos

Swift proporciona automáticamente abreviaturas para los nombres de
argumentos de las clausuras _inline_ que pueden usarse para referirse
a los valores de los argumentos de la clausura usando los nombres
`$0`, `$1`, `$2`, etc.

Si se usa estos argumentos abreviados, se puede omitir la definición
de la lista de los argumentos:

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">let</span> <span class="nv">alreves</span> <span class="p">=</span> <span class="n">estudiantes</span><span class="p">.</span><span class="bp">sorted</span><span class="p">(</span><span class="n">by</span><span class="p">:</span> <span class="p">{</span> <span class="nv">$0</span> <span class="o">&gt;</span> <span class="nv">$1</span> <span class="p">}</span> <span class="p">)</span>
</pre></div>
</td></tr></table>

### 10.7. Funciones operadoras

Incluso hay una forma aun más corta de escribir la expresión de
clausura anterior.  Swift define una implementación específica de
cadenas del operador mayor-que (`>`) como una función que tiene dos
parámetros de tipo `String` y devuelve un `Bool`. Esto es exactamente
lo que necesita el método `sorted(by:)`. Podemos, por tanto, pasar
simplemente este operador mayor-que, y Swift inferirá que queremos
usar el específico de cadenas:

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">let</span> <span class="nv">alreves</span> <span class="p">=</span> <span class="n">estudiantes</span><span class="p">.</span><span class="bp">sorted</span><span class="p">(</span><span class="n">by</span><span class="p">:</span> <span class="o">&gt;</span><span class="p">)</span>
</pre></div>
</td></tr></table>

### 10.8. Clausuras al final

Si necesitamos pasar una expresión de clausura a una función como el
argumento final de la clausura y la expresión es larga, puede ser útil
escribirla en su lugar como una clausura al final (_trailing
closure_). Una clausura al final es una expresión de clausura que se
escribe fuera de (y después de) los paréntesis de la función a la que
se le pasa como parámetro:

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">let</span> <span class="nv">alreves</span> <span class="p">=</span> <span class="n">estudiantes</span><span class="p">.</span><span class="bp">sorted</span><span class="p">()</span> <span class="p">{</span> <span class="nv">$0</span> <span class="o">&gt;</span> <span class="nv">$1</span> <span class="p">}</span>
</pre></div>
</td></tr></table>

Cuando se proporciona una expresión de clausura como único argumento de
una función o método y se pasa como una clausura al final, no es
necesario escribir los paréntesis tras el nombre de la función:

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">let</span> <span class="nv">alreves</span> <span class="p">=</span> <span class="n">estudiantes</span><span class="p">.</span><span class="bp">sorted</span> <span class="p">{</span> <span class="nv">$0</span> <span class="o">&gt;</span> <span class="nv">$1</span> <span class="p">}</span>
</pre></div>
</td></tr></table>


### 10.9. Variables capturadas

!!! Danger "Cuidado"
    Los ejemplos que vamos a ver a continuación no usan programación
    funcional, porque la variable capturada por la clausura es una
    variable **mutable** (se ha definido con `var` y no con `let`). Por
    eso las funciones resultantes no son funciones puras, sino que
    devuelven un valor distinto cada vez que son invocadas. Son 
    funciones con estado local mutable.

Una clausura puede capturar constantes y variables del contexto en el
que se define. La clausura puede referirse y modificar esos valores
dentro de su cuerpo, incluso si ya no existe el ámbito (_scope_)
original en el que se definieron estas constantes y variables.

En Swift, la forma más sencilla de una clausura que captura variables es
una función anidada (_nested function_) escrita en el cuerpo de otra
función. Una función anidada puede capturar cualquiera de los
argumentos de su función exterior y también puede capturar cualquier
constante y variable definida dentro de la función exterior.

Veamos un ejemplo similar al que vimos en Scheme. La función
`construyeIncrementador` contiene una función anidada llamada
`incrementador`. Esta función captura dos variables de su contexto:
`totalAcumulado` y `cantidad`. Después de capturar estas variables,
`incrementador` es devuelto por `construyeIncrementador` como una
clausura que incrementa `totalAcumulado` en `cantidad` cada vez que se
llama.

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">func</span> <span class="nf">construyeIncrementador</span><span class="p">(</span><span class="n">incremento</span> <span class="n">cantidad</span><span class="p">:</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="p">()</span> <span class="p">-&gt;</span> <span class="nb">Int</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">totalAcumulado</span> <span class="p">=</span> <span class="mi">0</span>
    <span class="kd">func</span> <span class="nf">incrementador</span><span class="p">()</span> <span class="p">-&gt;</span> <span class="nb">Int</span> <span class="p">{</span>
        <span class="n">totalAcumulado</span> <span class="o">+=</span> <span class="n">cantidad</span>
        <span class="k">return</span> <span class="n">totalAcumulado</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">incrementador</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

El tipo devuelto de `construyeIncrementador` es `() -> Int`. Esto
significa que devuelve una función que no tiene parámetros y que
devuelve un `Int` cada vez que es llamada.

La función `construyeIncrementador(incremento:)` tiene un único
parámetro `Int` con nombre externo `incremento` y nombre local
`cantidad`. El argumento pasado a este parámetro especifica cuánto
será incrementado `totalAcumulado` cada vez que se llama a la función
`incrementador` devuelta. La función `construyeIncrementador` define
una función anidada llamada `incrementador`, que realiza el incremento
real. Esta función simplemente añade `cantidad` a `totalAcumulado`, y
devuelve el resultado.

Si la consideramos aislada, la función anidada `incrementador()`
podría parecer extraña:

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">func</span> <span class="nf">incrementador</span><span class="p">()</span> <span class="p">-&gt;</span> <span class="nb">Int</span> <span class="p">{</span>
    <span class="n">totalAcumulado</span> <span class="o">+=</span> <span class="n">cantidad</span>
    <span class="k">return</span> <span class="n">totalAcumulado</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

La función no tiene ningún parámetro, y sin embargo se refiere a
`totalAcumulado` y a `cantidad` en su cuerpo. Lo puede hacer porque ha
capturado una referencia a estas variables de la función de alrededor
y las usa en su propio cuerpo. Al capturar estas referencias las
variables `totalAcumulado` y `cantidad` no desaparecen cuando termina
la llamada a `construyeIncrementador`. Estas variables también estarán
disponibles la próxima vez que se llame la función `incrementador`.

Aquí hay un ejemplo de `construyeIncrementador` en acción:

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">let</span> <span class="nv">incrementaDiez</span> <span class="p">=</span> <span class="n">construyeIncrementador</span><span class="p">(</span><span class="n">incremento</span><span class="p">:</span> <span class="mi">10</span><span class="p">)</span>
</pre></div>
</td></tr></table>

Este ejemplo define una constante llamada `incrementaDiez` para
referenciar la función `incrementador` que devuelve
`construyeIncrementador`. Esta función añade 10 a la variable
`totalAcumulado` cada vez que se es llamada. Si llamamos a la función
más de una vez podemos comprobar su conducta en acción:

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">incrementaDiez</span><span class="p">()</span>
<span class="c1">// devuelve 10</span>
<span class="n">incrementaDiez</span><span class="p">()</span>
<span class="c1">// devuelve 20</span>
<span class="n">incrementaDiez</span><span class="p">()</span>
<span class="c1">// devuelve 30</span>
</pre></div>
</td></tr></table>

Si creamos un segundo incrementador, tendrá sus propias referencias a
un variable `totalAcumulado` nueva, distinta de la anterior:

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">let</span> <span class="nv">incrementaSiete</span> <span class="p">=</span> <span class="n">construyeIncrementador</span><span class="p">(</span><span class="n">incremento</span><span class="p">:</span> <span class="mi">7</span><span class="p">)</span>
<span class="n">incrementaSiete</span><span class="p">()</span>
<span class="c1">// devuelve 7</span>
</pre></div>
</td></tr></table>

Si llamamos a la función `incrementador` original (`incrementaDiez`)
vemos que sigue incrementando su propia variable `totalAcumulado` y
que no se ve afectada por la variable capturada por `incrementaSiete`:

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">incrementaDiez</span><span class="p">()</span>
<span class="c1">// devuelve 40</span>
</pre></div>
</td></tr></table>


### 10.10. Clausuras con expresiones de clausura ###

En el ejemplo anterior hemos usado una definición interna de una
función para definir la clausura que se devuelve. Lo hemos hecho por
claridad, pero no es necesario. Es posible escribir un código más
compacto usando expresiones de clausura.

Por ejemplo, la función `construyeSumador()` vista en el apartado
"Funciones que devuelven otras funciones":

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">func</span> <span class="nf">construyeSumador10</span><span class="p">()</span> <span class="p">-&gt;</span> <span class="p">(</span><span class="nb">Int</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Int</span> <span class="p">{</span>
  <span class="kd">func</span> <span class="nf">suma10</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Int</span> <span class="p">{</span><span class="k">return</span> <span class="n">x</span><span class="o">+</span><span class="mi">10</span><span class="p">}</span>
  <span class="k">return</span> <span class="n">suma10</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

Una versión de esta misma función usando una expresión de clausura es
la siguiente:

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">func</span> <span class="nf">construyeSumador10</span><span class="p">()</span> <span class="p">-&gt;</span> <span class="p">(</span><span class="nb">Int</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Int</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">{</span><span class="nv">$0</span> <span class="o">+</span> <span class="mi">10</span><span class="p">}</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nv">f</span> <span class="p">=</span> <span class="n">construyeSumador10</span><span class="p">()</span>
<span class="bp">print</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="mi">20</span><span class="p">))</span>
<span class="c1">// Imprime &quot;30&quot;</span>
</pre></div>
</td></tr></table>

Y lo mismo con la función `constryeIncrementador(incremento:)` vista
en el apartado anterior:

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">func</span> <span class="nf">construyeIncrementador</span><span class="p">(</span><span class="n">incremento</span> <span class="n">cantidad</span><span class="p">:</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="p">()</span> <span class="p">-&gt;</span> <span class="nb">Int</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">totalAcumulado</span> <span class="p">=</span> <span class="mi">0</span>
    <span class="kd">func</span> <span class="nf">incrementador</span><span class="p">()</span> <span class="p">-&gt;</span> <span class="nb">Int</span> <span class="p">{</span>
        <span class="n">totalAcumulado</span> <span class="o">+=</span> <span class="n">cantidad</span>
        <span class="k">return</span> <span class="n">totalAcumulado</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">incrementador</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

La versión con una expresión de clausura:

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">func</span> <span class="nf">construyeIncrementador</span><span class="p">(</span><span class="n">incremento</span> <span class="n">cantidad</span><span class="p">:</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="p">()</span> <span class="p">-&gt;</span> <span class="nb">Int</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">totalAcumulado</span> <span class="p">=</span> <span class="mi">0</span>
    <span class="k">return</span> <span class="p">{</span><span class="n">totalAcumulado</span> <span class="o">+=</span> <span class="n">cantidad</span>
            <span class="k">return</span> <span class="n">totalAcumulado</span><span class="p">}</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nv">incrementaDiez</span> <span class="p">=</span> <span class="n">construyeIncrementador</span><span class="p">(</span><span class="n">incremento</span><span class="p">:</span> <span class="mi">10</span><span class="p">)</span>
<span class="bp">print</span><span class="p">(</span><span class="n">incrementaDiez</span><span class="p">())</span>
<span class="c1">// Imprime &quot;10&quot;</span>
<span class="bp">print</span><span class="p">(</span><span class="n">incrementaDiez</span><span class="p">())</span>
<span class="c1">// Imprime &quot;20&quot;</span>
</pre></div>
</td></tr></table>


### 10.11. Variables capturadas por clausuras y variables del ámbito de invocación ###

Las clasuras usan las variables capturadas y no las variables declaradas
en el ámbito en el que se invoca a la clausura. Vamos a explicarlo con un ejemplo.

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">func</span> <span class="nf">construyeFunc</span><span class="p">()</span> <span class="p">-&gt;</span> <span class="p">()</span> <span class="p">-&gt;</span> <span class="nb">Int</span> <span class="p">{</span>
<span class="hll">   <span class="kd">var</span> <span class="nv">x</span> <span class="p">=</span> <span class="mi">0</span>
</span>   <span class="k">return</span> <span class="p">{</span>
      <span class="n">x</span> <span class="p">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>
      <span class="k">return</span> <span class="n">x</span>
   <span class="p">}</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nv">f</span> <span class="p">=</span> <span class="n">construyeFunc</span><span class="p">()</span>
<span class="bp">print</span><span class="p">(</span><span class="n">f</span><span class="p">())</span> <span class="c1">// -&gt; 1</span>
<span class="bp">print</span><span class="p">(</span><span class="n">f</span><span class="p">())</span> <span class="c1">// -&gt; 2</span>

<span class="kd">func</span> <span class="nf">usaFunc</span><span class="p">(</span><span class="kc">_</span> <span class="n">f</span><span class="p">:</span> <span class="p">()</span> <span class="p">-&gt;</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Int</span> <span class="p">{</span>
<span class="hll">     <span class="kd">var</span> <span class="nv">x</span> <span class="p">=</span> <span class="mi">10</span>
</span>     <span class="k">return</span> <span class="n">f</span><span class="p">()</span>
<span class="p">}</span>

<span class="bp">print</span><span class="p">(</span><span class="n">usaFunc</span><span class="p">(</span><span class="n">f</span><span class="p">))</span> <span class="c1">// -&gt; 3</span>

<span class="hll"><span class="kd">var</span> <span class="nv">x</span> <span class="p">=</span> <span class="mi">100</span>
</span><span class="bp">print</span><span class="p">(</span><span class="n">usaFunc</span> <span class="p">{</span><span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">10</span><span class="p">})</span> <span class="c1">// -&gt; 110</span>
</pre></div>
</td></tr></table>

En el código anterior se resaltan las tres declaraciones de variables
`x`. Es muy importante comprobar el ámbito en el que se realizan esas
declaraciones. La primera declaración se realiza dentro de la función
`construyeFunc()`, la segunda dentro de la función `usaFunc()` y la
tercera en el ámbito global. En cada caso, la variable se inicializará
cuando se ejecute esa línea de código. 

La función `usaFunc` definida en la línea 13 recibe una función `f`
sin parámetros que devuelve un entero. En el ámbito local de `usaFunc`
se define la variable local `x` que tiene el valor `10` antes de
invocar a la función `f` recibida.

¿Qué pasa si la función recibida es una clausura que ha capturado una
variable que también se llama `x`? En el caso de la invocación a
`usaFunc` que hay en la línea 18, la función `f` que se pasa como
parámetro es la clausura obtenida en la línea 9. Esta clausura ha
capturado la variable `x` definida en la línea 2. Y en ese momento
esa variable tiene el valor 2. El código de la clausura es el definido
en las líneas 3 a 6:

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">{</span>
<span class="n">x</span> <span class="p">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>
<span class="k">return</span> <span class="n">x</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

¿A qué variable `x` se refiere ese código? ¿A la variable capturada que
tiene un valor de 2? ¿O a la variable en el ámbito de ejecución (línea
14) que tiene un valor de 10?

Si ejecutamos el código veremos que la expresión devuelve 3. O sea que
las clausuras usan siempre las variables capturadas.

Podemos comprobarlo también en la invocación de la línea 21. Ahí la
clausura que se pasa es una expresión de clausura que captura la
variable `x` definida en la línea anterior. Por eso cuando se ejecuta
la sentencia se imprime el valor `110` y no el valor `20`.


### 10.12. Las clausuras son tipos de referencia

En el ejemplo anterior, `incrementaSiete` e `incrementaDiez` son
constantes, pero las clausuras a las que estas constantes se refieren
pueden incrementar la variable `totalAcumulado` que han
capturado. Esto es porque funciones y clausuras son tipos referencia.

Siempre que asignamos una función o una clausura a una constante o una
variable, estamos realmente estableciendo que la constante o variable
es una referencia a la función o la clausura. En el ejemplo anterior,
es la elección de la clausura a la que referencia `incrementaDiez` la
que es constante, no los contenidos propios de la clausura.

Esto también significa que si asignamos una clausura a dos constantes
o variables distintas, ambas constantes o variables se referirán a la
misma clausura:

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">let</span> <span class="nv">tambienIncrementaDiez</span> <span class="p">=</span> <span class="n">incrementaDiez</span>
<span class="n">tambienIncrementaDiez</span><span class="p">()</span>
<span class="c1">// devuelve 50</span>
</pre></div>
</td></tr></table>


## 11. Funciones de orden superior

Una de las características funcionales que más hemos usado para
trabajar con listas en Scheme son las funciones de orden superior como
`map`, `filter` o `foldl`. Swift tiene definidas funciones
equivalentes para trabajar con colecciones. Se denominan `map`,
`filter` y `reduce`. Todas ellas aceptan expresiones de clausura como
argumento.

### 11.1 Map

El método `map` se define en el protocolo
[`CollectionType`](https://developer.apple.com/library/ios/documentation/Swift/Reference/Swift_CollectionType_Protocol/index.html#//apple_ref/swift/intfm/CollectionType/s:FEsPs14CollectionType3mapurFzFzWx9Generator7Element_qd__GSaqd___)
y es adoptado por múltiples estructuras como `Array`, `Dictionary`,
`Set`.

La firma del método `map` es el siguiente:

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">func</span> <span class="nf">map</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="kc">_</span> <span class="n">transform</span><span class="p">:</span> <span class="p">(</span><span class="n">Element</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">T</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="p">[</span><span class="n">T</span><span class="p">]</span>
</pre></div>
</td></tr></table>

Se trata de un método genérico (lo veremos más adelante) que recibe
como parámetro una función unaria (función de transformación) 
del tipo de los elementos de la colección y que devuelve otro elemento
(puede ser del mismo o de distinto tipo que los elementos de la
colección). Devuelve un array que contiene el resultado de aplicar
la función de transformación a cada elemento del array original.

Por ejemplo:

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">let</span> <span class="nv">numeros</span> <span class="p">=</span> <span class="p">[</span><span class="nb">Int</span><span class="p">](</span><span class="mf">0.</span><span class="p">..</span><span class="mi">5</span><span class="p">)</span>
<span class="n">numeros</span><span class="p">.</span><span class="bp">map</span> <span class="p">{</span><span class="nv">$0</span> <span class="o">*</span> <span class="nv">$0</span><span class="p">}</span>
<span class="c1">// devuelve [0, 1, 4, 9, 16, 25]</span>
</pre></div>
</td></tr></table>

Otro ejemplo, en el que usamos `map` para implementar la función
`sumaParejas(parejas: [(Int, Int)]) -> [Int]` que devuelve recibe el
array `parejas` de tuplas de dos enteros y devuelve un array con el
resultado de sumar los dos elementos de cada pareja:

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">func</span> <span class="nf">suma</span><span class="p">(</span><span class="n">parejas</span><span class="p">:</span> <span class="p">[(</span><span class="nb">Int</span><span class="p">,</span> <span class="nb">Int</span><span class="p">)])</span> <span class="p">-&gt;</span> <span class="p">[</span><span class="nb">Int</span><span class="p">]</span> <span class="p">{</span>
   <span class="k">return</span> <span class="n">parejas</span><span class="p">.</span><span class="bp">map</span><span class="p">({(</span><span class="n">pareja</span><span class="p">:</span> <span class="p">(</span><span class="nb">Int</span><span class="p">,</span> <span class="nb">Int</span><span class="p">))</span> <span class="p">-&gt;</span> <span class="nb">Int</span> <span class="k">in</span>
                        <span class="k">return</span> <span class="n">pareja</span><span class="p">.</span><span class="mi">0</span> <span class="o">+</span> <span class="n">pareja</span><span class="p">.</span><span class="mi">1</span><span class="p">})</span>
<span class="p">}</span>
<span class="n">suma</span><span class="p">(</span><span class="n">parejas</span><span class="p">:[(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">)])</span>
<span class="c1">// devuelve [2, 4, 6, 8]</span>
</pre></div>
</td></tr></table>

Podemos usar en el cuerpo de la expresión de clausura de `map` una
variable capturada. Por ejemplo en la siguiente función
`incrementaValores(_:con:)` que suma `con` a todos los números de un
array que se le pasa por parámetro:

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">func</span> <span class="nf">incrementa</span><span class="p">(</span><span class="n">valores</span><span class="p">:</span> <span class="p">[</span><span class="nb">Int</span><span class="p">],</span> <span class="n">con</span><span class="p">:</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="p">[</span><span class="nb">Int</span><span class="p">]</span> <span class="p">{</span>
   <span class="k">return</span> <span class="n">valores</span><span class="p">.</span><span class="bp">map</span><span class="p">({(</span><span class="n">x</span><span class="p">:</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Int</span> <span class="k">in</span>
                        <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">con</span><span class="p">})</span>
<span class="p">}</span>
<span class="n">incrementa</span><span class="p">(</span><span class="n">valores</span><span class="p">:[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span class="p">],</span> <span class="n">con</span><span class="p">:</span> <span class="mi">5</span><span class="p">)</span>
<span class="c1">// devuelve [15, 25, 35]</span>
</pre></div>
</td></tr></table>
La versión abreviada de la expresión de clausura es:

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">func</span> <span class="nf">incrementa</span><span class="p">(</span><span class="n">valores</span><span class="p">:</span> <span class="p">[</span><span class="nb">Int</span><span class="p">],</span> <span class="n">con</span> <span class="n">inc</span><span class="p">:</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="p">[</span><span class="nb">Int</span><span class="p">]</span> <span class="p">{</span>
   <span class="k">return</span> <span class="n">valores</span><span class="p">.</span><span class="bp">map</span> <span class="p">{</span><span class="nv">$0</span> <span class="o">+</span> <span class="n">inc</span><span class="p">}</span>
<span class="p">}</span>
<span class="n">incrementa</span><span class="p">(</span><span class="n">valores</span><span class="p">:</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span class="p">],</span> <span class="n">con</span><span class="p">:</span> <span class="mi">5</span><span class="p">)</span>
<span class="c1">// devuelve [15, 25, 35]</span>
</pre></div>
</td></tr></table>


### 11.2. Filter


La función `filter` es también igual que la definida en Scheme. Su
perfil es:

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">func</span> <span class="nf">filter</span><span class="p">(</span><span class="kc">_</span> <span class="n">isIncluded</span><span class="p">:</span> <span class="p">(</span><span class="n">Element</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Bool</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="p">[</span><span class="n">Element</span><span class="p">]</span>
</pre></div>
</td></tr></table>

Recibe una clausura de un argumento que devuelve
un booleano. La función devuelve un array con los elementos de la
colección para los que la clausura devuelve _true_. 

Ejemplo:

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">let</span> <span class="nv">numeros</span> <span class="p">=</span> <span class="p">[</span><span class="nb">Int</span><span class="p">](</span><span class="mf">0.</span><span class="p">..</span><span class="mi">10</span><span class="p">)</span>
<span class="n">numeros</span><span class="p">.</span><span class="bp">filter</span> <span class="p">{</span><span class="nv">$0</span> <span class="o">%</span> <span class="mi">2</span> <span class="p">==</span> <span class="mi">0</span><span class="p">}</span>
<span class="c1">// devuelve [0, 2, 4, 6, 8, 10]</span>
</pre></div>
</td></tr></table>


### 11.3. Reduce 

Similar al _foldl_ de Scheme. Su firma es el siguiente:


<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">func</span> <span class="nf">reduce</span><span class="p">&lt;</span><span class="n">Result</span><span class="p">&gt;(</span><span class="kc">_</span> <span class="n">initialResult</span><span class="p">:</span> <span class="n">Result</span><span class="p">,</span> 
                    <span class="kc">_</span> <span class="n">nextPartialResult</span><span class="p">:</span> <span class="p">(</span><span class="n">Result</span><span class="p">,</span> <span class="n">Element</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">Result</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">Result</span>
</pre></div>
</td></tr></table>

Es una función genérica que devuelve un valor de un tipo genérico (el
tipo del resultado que se construye en la función). Recibe como
parámetro un valor inicial y una _función de plegado_ que se aplica al
resultado anterior y al elemento de la colección, devolviendo un
resultado. El resultado final es el resultado de aplicar la función de
plegado a todos los elementos de la colección, empezando por el valor
inicial.

Por ejemplo, podemos usar `reduce` para sumar todos los números de un array:


<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">let</span> <span class="nv">numeros</span> <span class="p">=</span> <span class="p">[</span><span class="nb">Int</span><span class="p">](</span><span class="mf">0.</span><span class="p">..</span><span class="mi">10</span><span class="p">)</span>
<span class="n">numeros</span><span class="p">.</span><span class="bp">reduce</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">+</span><span class="p">)</span>
</pre></div>
</td></tr></table>

La función combina los elementos de la colección usando la función de
combinación que se pasa como parámetro. La función que se pasa como
parámetro recibe dos parámetros: el primero es el resultado de la
combinación y el segundo se coge de la colección. 

Por ejemplo, el siguiente código usa `reduce` para sumar la longitud
de todas las cadenas de un array:

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">let</span> <span class="nv">cadenas</span> <span class="p">=</span> <span class="p">[</span><span class="s">&quot;Patatas&quot;</span><span class="p">,</span> <span class="s">&quot;Arroz&quot;</span><span class="p">,</span> <span class="s">&quot;Huevos&quot;</span><span class="p">]</span>
<span class="n">cadenas</span><span class="p">.</span><span class="bp">reduce</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">{(</span><span class="n">i</span><span class="p">:</span> <span class="nb">Int</span><span class="p">,</span> <span class="n">c</span><span class="p">:</span> <span class="nb">String</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Int</span> <span class="k">in</span>
                      <span class="n">c</span><span class="p">.</span><span class="bp">count</span> <span class="o">+</span> <span class="n">i</span> <span class="p">})</span>
<span class="c1">// devuelve 18</span>
</pre></div>
</td></tr></table>

Es posible simplificar la notación anterior:

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">cadenas</span><span class="p">.</span><span class="bp">reduce</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">{</span><span class="nv">$1</span><span class="p">.</span><span class="bp">count</span> <span class="o">+</span> <span class="nv">$0</span><span class="p">})</span>
</pre></div>
</td></tr></table>

También se puede utilizar la notación de clausura al final:

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">cadenas</span><span class="p">.</span><span class="bp">reduce</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span><span class="nv">$1</span><span class="p">.</span><span class="bp">count</span> <span class="o">+</span> <span class="nv">$0</span><span class="p">}</span>
</pre></div>
</td></tr></table>

La combinación se hace de izquierda a derecha:

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">let</span> <span class="nv">cadenas</span> <span class="p">=</span> <span class="p">[</span><span class="s">&quot;Patatas&quot;</span><span class="p">,</span> <span class="s">&quot;Arroz&quot;</span><span class="p">,</span> <span class="s">&quot;Huevos&quot;</span><span class="p">]</span>
<span class="bp">print</span><span class="p">(</span><span class="n">cadenas</span><span class="p">.</span><span class="bp">reduce</span><span class="p">(</span><span class="s">&quot;*&quot;</span><span class="p">,</span> <span class="p">{</span><span class="nv">$0</span> <span class="o">+</span> <span class="s">&quot;-&quot;</span> <span class="o">+</span> <span class="nv">$1</span><span class="p">}))</span>
<span class="c1">// Imprime &quot;*-Patatas-Arroz-Huevos&quot;</span>
</pre></div>
</td></tr></table>

El primer argumento de la función de plegado (`$0`) es el resultado
anterior (empieza por `"*"`) y el segundo argumento (`$1`) se coge del
array de cadenas.


### 11.4. Combinación de funciones de orden superior

Cuando el resultado de aplicar una función de orden superior a una
colección es otra colección es posible aplicar otra función de
orden superior a este resultado.

Por ejemplo, la siguiente sentencia devuelve todos los números pares
del array inicial elevados al cuadrado:


<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">let</span> <span class="nv">numeros</span> <span class="p">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">10</span><span class="p">]</span>
<span class="n">numeros</span><span class="p">.</span><span class="bp">filter</span><span class="p">{</span><span class="nv">$0</span> <span class="o">%</span> <span class="mi">2</span> <span class="p">==</span> <span class="mi">0</span><span class="p">}.</span><span class="bp">map</span><span class="p">{</span><span class="nv">$0</span><span class="o">*</span><span class="nv">$0</span><span class="p">}</span>
<span class="c1">// Devuelve el array [4,16,36,64,100]</span>
</pre></div>
</td></tr></table>

Y la siguiente devuelve la suma números mayores de 100:

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">let</span> <span class="nv">numeros</span> <span class="p">=</span> <span class="p">[</span><span class="mi">103</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">330</span><span class="p">,</span> <span class="mi">42</span><span class="p">,</span> <span class="mi">532</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">125</span><span class="p">]</span>
<span class="n">numeros</span><span class="p">.</span><span class="bp">filter</span><span class="p">{</span><span class="nv">$0</span> <span class="o">&gt;=</span> <span class="mi">100</span><span class="p">}.</span><span class="bp">reduce</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="o">+</span><span class="p">)</span>
<span class="c1">// Devuelve 1090</span>
</pre></div>
</td></tr></table>


## 12. Genéricos


Empecemos con un ejemplo sencillo. Supongamos la siguiente función
`intercambia(_:)` que recibe una tupla `(Int, String)` y devuelve una
tupla `(String, Int)` con los valores intercambiados.

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">func</span> <span class="nf">intercambia</span><span class="p">(</span><span class="kc">_</span> <span class="n">tupla</span><span class="p">:</span> <span class="p">(</span><span class="nb">Int</span><span class="p">,</span> <span class="nb">String</span><span class="p">))</span> <span class="p">-&gt;</span> <span class="p">(</span><span class="nb">String</span><span class="p">,</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">{</span>
   <span class="kd">let</span> <span class="nv">tuplaNueva</span> <span class="p">=</span> <span class="p">(</span><span class="n">tupla</span><span class="p">.</span><span class="mi">1</span><span class="p">,</span> <span class="n">tupla</span><span class="p">.</span><span class="mi">0</span><span class="p">)</span>
   <span class="k">return</span> <span class="n">tuplaNueva</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nv">tupla</span> <span class="p">=</span> <span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="s">&quot;Hola&quot;</span><span class="p">)</span>
<span class="n">intercambia</span><span class="p">(</span><span class="n">tupla</span><span class="p">)</span>
<span class="c1">// devuelve (&quot;Hola&quot;, 10)</span>
</pre></div>
</td></tr></table>

La función es interesante, pero sólo recibe tuplas cuya primera
componente es un `Int` y su segunda componente es un
`String`. Supongamos que queremos hacer la misma función para
intercambiar elementos de una tupla `(Int, Int)`. Tendríamos que usar
el mismo código, pero cambiando los tipos:

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">func</span> <span class="nf">intercambia</span><span class="p">(</span><span class="kc">_</span> <span class="n">tupla</span><span class="p">:</span> <span class="p">(</span><span class="nb">Int</span><span class="p">,</span> <span class="nb">Int</span><span class="p">))</span> <span class="p">-&gt;</span> <span class="p">(</span><span class="nb">Int</span><span class="p">,</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">{</span>
   <span class="kd">let</span> <span class="nv">tuplaNueva</span> <span class="p">=</span> <span class="p">(</span><span class="n">tupla</span><span class="p">.</span><span class="mi">1</span><span class="p">,</span> <span class="n">tupla</span><span class="p">.</span><span class="mi">0</span><span class="p">)</span>
   <span class="k">return</span> <span class="n">tuplaNueva</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nv">tupla</span> <span class="p">=</span> <span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>
<span class="n">intercambia</span><span class="p">(</span><span class="n">tupla</span><span class="p">)</span>
<span class="c1">// devuelve (20, 10)</span>
</pre></div>
</td></tr></table>

El código es el mismo, lo único distinto son los tipos. ¿Podríamos
**generalizar** las funciones anteriores para hacer que el código
pueda trabajar con cualquier tipo? La respuesta es sí, usando
**función genérica**:

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">func</span> <span class="nf">intercambia</span><span class="p">&lt;</span><span class="n">A</span><span class="p">,</span><span class="n">B</span><span class="p">&gt;(</span><span class="kc">_</span> <span class="n">tupla</span><span class="p">:</span> <span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">))</span> <span class="p">-&gt;</span> <span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">A</span><span class="p">)</span> <span class="p">{</span>
   <span class="kd">let</span> <span class="nv">tuplaNueva</span> <span class="p">=</span> <span class="p">(</span><span class="n">tupla</span><span class="p">.</span><span class="mi">1</span><span class="p">,</span> <span class="n">tupla</span><span class="p">.</span><span class="mi">0</span><span class="p">)</span>
   <span class="k">return</span> <span class="n">tuplaNueva</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

El cuerpo de la función es idéntico a la función anterior. La
diferencia es que en la versión genérica se usan *placeholders* (los
símbolos `A` y `B`) en lugar de tipos concretos. Son tipos genéricos,
que se definen usando un identificador entre símbolos de `<` y
`>`. Los tipos reales que se van a usar en la función se determinan en
cada invocación a la función, dependiendo del tipo del parámetro que
se utiliza en la llamada:

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">let</span> <span class="nv">tupla</span> <span class="p">=</span> <span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="s">&quot;Hola&quot;</span><span class="p">)</span>
<span class="n">intercambia</span><span class="p">(</span><span class="n">tupla</span><span class="p">)</span>
<span class="c1">// devuelve (&quot;Hola&quot;, 10)</span>
<span class="kd">let</span> <span class="nv">tupla2</span> <span class="p">=</span> <span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>
<span class="n">intercambia</span><span class="p">(</span><span class="n">tupla2</span><span class="p">)</span>
<span class="c1">// devuelve (20, 10)</span>
<span class="kd">let</span> <span class="nv">tupla3</span> <span class="p">=</span> <span class="p">(</span><span class="kc">true</span><span class="p">,</span> <span class="mf">10.5</span><span class="p">)</span>
<span class="n">intercambia</span><span class="p">(</span><span class="n">tupla3</span><span class="p">)</span>
<span class="c1">// devuelve (10.5, true)</span>
</pre></div>
</td></tr></table>

En el primer ejemplo, los tipos `A` y `B` se infieren como `Int` y
`String`. En el segundo ejemplo como `Int` e `Int`. Y en el tercero
como `Bool` y `Double`.

Los tipos genéricos se pueden usar en la definición de todos los
elementos de Swift: funciones, enums, estructuras, clases, protocolos
o extensiones. Terminamos con un ejemplo en el que incluimos muchos
conceptos vistos en este tema. Se trata de la implementación en Swift
de listas al estilo Scheme, con las funciones `first`, `resty `vacia`
usando un enum recursivo con un tipo genérico que permite generalizar
el tipo de elementos de la lista.

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kr">indirect</span> <span class="kd">enum</span> <span class="nc">Lista</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="p">{</span>
     <span class="k">case</span> <span class="n">vacia</span>
     <span class="k">case</span> <span class="n">nodo</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">Lista</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">first</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="kc">_</span> <span class="n">lista</span><span class="p">:</span> <span class="n">Lista</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;)</span> <span class="p">-&gt;</span> <span class="n">T</span><span class="p">?</span> <span class="p">{</span>
   <span class="k">switch</span> <span class="n">lista</span> <span class="p">{</span>
      <span class="k">case</span> <span class="kd">let</span> <span class="p">.</span><span class="n">nodo</span><span class="p">(</span><span class="n">primero</span><span class="p">,</span> <span class="kc">_</span><span class="p">):</span>
         <span class="k">return</span> <span class="n">primero</span>
      <span class="k">case</span> <span class="p">.</span><span class="n">vacia</span><span class="p">:</span>
         <span class="k">return</span> <span class="kc">nil</span>
   <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">rest</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="kc">_</span> <span class="n">lista</span><span class="p">:</span> <span class="n">Lista</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;)</span> <span class="p">-&gt;</span> <span class="n">Lista</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;?</span> <span class="p">{</span>
   <span class="k">switch</span> <span class="n">lista</span> <span class="p">{</span>
      <span class="k">case</span> <span class="kd">let</span> <span class="p">.</span><span class="n">nodo</span><span class="p">(</span><span class="kc">_</span><span class="p">,</span> <span class="n">resto</span><span class="p">):</span>
         <span class="k">return</span> <span class="n">resto</span>
      <span class="k">case</span> <span class="p">.</span><span class="n">vacia</span><span class="p">:</span>
         <span class="k">return</span> <span class="kc">nil</span>
   <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">vacia</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="kc">_</span> <span class="n">lista</span><span class="p">:</span> <span class="n">Lista</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;)</span> <span class="p">-&gt;</span> <span class="nb">Bool</span> <span class="p">{</span>
   <span class="k">switch</span> <span class="n">lista</span> <span class="p">{</span>
      <span class="k">case</span> <span class="p">.</span><span class="n">vacia</span><span class="p">:</span>
         <span class="k">return</span> <span class="kc">true</span>
      <span class="k">default</span><span class="p">:</span>
         <span class="k">return</span> <span class="kc">false</span>
   <span class="p">}</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nv">lista</span> <span class="p">:</span> <span class="n">Lista</span> <span class="p">=</span> <span class="p">.</span><span class="n">nodo</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="p">.</span><span class="n">nodo</span><span class="p">(</span><span class="mi">30</span><span class="p">,</span> <span class="p">.</span><span class="n">nodo</span><span class="p">(</span><span class="mi">40</span><span class="p">,</span> <span class="p">.</span><span class="n">vacia</span><span class="p">)))</span>
<span class="kd">let</span> <span class="nv">lista2</span> <span class="p">:</span> <span class="n">Lista</span> <span class="p">=</span> <span class="p">.</span><span class="n">nodo</span><span class="p">(</span><span class="s">&quot;A&quot;</span><span class="p">,</span> <span class="p">.</span><span class="n">nodo</span><span class="p">(</span><span class="s">&quot;B&quot;</span><span class="p">,</span> <span class="p">.</span><span class="n">nodo</span><span class="p">(</span><span class="s">&quot;C&quot;</span><span class="p">,</span> <span class="p">.</span><span class="n">vacia</span><span class="p">)))</span>

<span class="bp">print</span><span class="p">(</span><span class="bp">first</span><span class="p">(</span><span class="n">rest</span><span class="p">(</span><span class="n">lista</span><span class="p">)</span><span class="o">!</span><span class="p">)</span><span class="o">!</span><span class="p">)</span> <span class="c1">// Imprime 30</span>
<span class="bp">print</span><span class="p">(</span><span class="bp">first</span><span class="p">(</span><span class="n">rest</span><span class="p">(</span><span class="n">lista2</span><span class="p">)</span><span class="o">!</span><span class="p">)</span><span class="o">!</span><span class="p">)</span> <span class="c1">// Imprime &quot;B&quot;</span>
</pre></div>
</td></tr></table>


## 13. Bibliografía

- Swift Language Guide
    - [The Basics](https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/TheBasics.html#//apple_ref/doc/uid/TP40014097-CH5-ID309)
    - [Collection Types](https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/CollectionTypes.html#//apple_ref/doc/uid/TP40014097-CH8-ID105)
    - [Functions](https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Functions.html#//apple_ref/doc/uid/TP40014097-CH10-ID158)
    - [Closures](https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Closures.html#//apple_ref/doc/uid/TP40014097-CH11-ID94)
    - [Enumerations](https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Enumerations.html#//apple_ref/doc/uid/TP40014097-CH12-ID145)
    - [Generics](https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Generics.html#//apple_ref/doc/uid/TP40014097-CH26-ID179)
- [Biblioteca estándar de Swift](https://developer.apple.com/library/ios/documentation/General/Reference/SwiftStandardLibraryReference/)

-->

<hr />
<p>Lenguajes y Paradigmas de Programación, curso 2023–24<br />
© Departamento Ciencia de la Computación e Inteligencia Artificial, Universidad de Alicante<br />
Domingo Gallardo, Cristina Pomares, Antonio Botía, Francisco Martínez</p>
                
                  
                
              
              
                


              
            </article>
          </div>
        </div>
      </main>
      
        
<footer class="md-footer">
  
    <div class="md-footer-nav">
      <nav class="md-footer-nav__inner md-grid">
        
          <a href="../tema04-estructuras-recursivas/tema04-estructuras-recursivas.html" title="Tema 4: Estructuras recursivas" class="md-flex md-footer-nav__link md-footer-nav__link--prev" rel="prev">
            <div class="md-flex__cell md-flex__cell--shrink">
              <i class="md-icon md-icon--arrow-back md-footer-nav__button"></i>
            </div>
            <div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
              <span class="md-flex__ellipsis">
                <span class="md-footer-nav__direction">
                  Anterior
                </span>
                Tema 4: Estructuras recursivas
              </span>
            </div>
          </a>
        
        
          <a href="../../seminarios/seminario1-scheme/seminario1-scheme.html" title="Seminario de Scheme" class="md-flex md-footer-nav__link md-footer-nav__link--next" rel="next">
            <div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
              <span class="md-flex__ellipsis">
                <span class="md-footer-nav__direction">
                  Siguiente
                </span>
                Seminario de Scheme
              </span>
            </div>
            <div class="md-flex__cell md-flex__cell--shrink">
              <i class="md-icon md-icon--arrow-forward md-footer-nav__button"></i>
            </div>
          </a>
        
      </nav>
    </div>
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-footer-copyright">
        
        powered by
        <a href="https://www.mkdocs.org">MkDocs</a>
        and
        <a href="https://squidfunk.github.io/mkdocs-material/">
          Material for MkDocs</a>
      </div>
      
    </div>
  </div>
</footer>
      
    </div>
    
      <script src="../../assets/javascripts/application.245445c6.js"></script>
      
      <script>app.initialize({version:"1.0.4",url:{base:"../.."}})</script>
      
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML"></script>
      
    
  </body>
</html>