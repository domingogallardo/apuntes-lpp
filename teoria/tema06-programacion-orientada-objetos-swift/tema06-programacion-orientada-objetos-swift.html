



<!doctype html>
<html lang="es" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      <meta http-equiv="x-ua-compatible" content="ie=edge">
      
      
      
      
        <meta name="lang:clipboard.copy" content="Copiar al portapapeles">
      
        <meta name="lang:clipboard.copied" content="Copiado al portapapeles">
      
        <meta name="lang:search.language" content="en">
      
        <meta name="lang:search.pipeline.stopwords" content="True">
      
        <meta name="lang:search.pipeline.trimmer" content="True">
      
        <meta name="lang:search.result.none" content="No se encontraron documentos">
      
        <meta name="lang:search.result.one" content="1 documento encontrado">
      
        <meta name="lang:search.result.other" content="# documentos encontrados">
      
        <meta name="lang:search.tokenizer" content="[\s\-]+">
      
      <link rel="shortcut icon" href="../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.0.4, mkdocs-material-4.6.0">
    
    
      
        <title>Tema06 programacion orientada objetos swift - LPP</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/application.1b62728e.css">
      
        <link rel="stylesheet" href="../../assets/stylesheets/application-palette.a8b3c06d.css">
      
      
        
        
        <meta name="theme-color" content="#009688">
      
    
    
      <script src="../../assets/javascripts/modernizr.268332fc.js"></script>
    
    
      
        <link href="https://fonts.gstatic.com" rel="preconnect" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Ubuntu:300,400,400i,700%7CRoboto+Mono&display=fallback">
        <style>body,input{font-family:"Ubuntu","Helvetica Neue",Helvetica,Arial,sans-serif}code,kbd,pre{font-family:"Roboto Mono","Courier New",Courier,monospace}</style>
      
    
    <link rel="stylesheet" href="../../assets/fonts/material-icons.css">
    
    
    
      
    
    
  </head>
  
    
    
    <body dir="ltr" data-md-color-primary="teal" data-md-color-accent="teal">
  
    <svg class="md-svg">
      <defs>
        
        
      </defs>
    </svg>
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" data-md-component="overlay" for="__drawer"></label>
    
      <a href="#tema-6-programacion-orientada-a-objetos-con-swift" tabindex="1" class="md-skip">
        Saltar a contenido
      </a>
    
    
      <header class="md-header" data-md-component="header">
  <nav class="md-header-nav md-grid">
    <div class="md-flex">
      <div class="md-flex__cell md-flex__cell--shrink">
        <a href="../.." title="LPP" class="md-header-nav__button md-logo">
          
            <img src="../../imagenes/logo.png" width="24" height="24">
          
        </a>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        <label class="md-icon md-icon--menu md-header-nav__button" for="__drawer"></label>
      </div>
      <div class="md-flex__cell md-flex__cell--stretch">
        <div class="md-flex__ellipsis md-header-nav__title" data-md-component="title">
          
            <span class="md-header-nav__topic">
              LPP
            </span>
            <span class="md-header-nav__topic">
              
                Tema06 programacion orientada objetos swift
              
            </span>
          
        </div>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        
          <label class="md-icon md-icon--search md-header-nav__button" for="__search"></label>
          
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" placeholder="Búsqueda" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="query" data-md-state="active">
      <label class="md-icon md-search__icon" for="__search"></label>
      <button type="reset" class="md-icon md-search__icon" data-md-component="reset" tabindex="-1">
        &#xE5CD;
      </button>
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="result">
          <div class="md-search-result__meta">
            Teclee para comenzar búsqueda
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
        
      </div>
      
    </div>
  </nav>
</header>
    
    <div class="md-container">
      
        
      
      
      <main class="md-main" role="main">
        <div class="md-main__inner md-grid" data-md-component="container">
          
            
              <div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    <nav class="md-nav md-nav--primary" data-md-level="0">
  <label class="md-nav__title md-nav__title--site" for="__drawer">
    <a href="../.." title="LPP" class="md-nav__button md-logo">
      
        <img src="../../imagenes/logo.png" width="48" height="48">
      
    </a>
    LPP
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-1" type="checkbox" id="nav-1">
    
    <label class="md-nav__link" for="nav-1">
      Teoría
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-1">
        Teoría
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../tema00-descripcion-asignatura/tema00-descripcion-asignatura.html" title="Descripción de la asignatura" class="md-nav__link">
      Descripción de la asignatura
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../tema01-historia-lenguajes-programacion/tema01-historia-lenguajes-programacion.html" title="Tema 1: Historia de los lenguajes de programación" class="md-nav__link">
      Tema 1: Historia de los lenguajes de programación
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../tema02-programacion-funcional/tema02-programacion-funcional.html" title="Tema 2: Programación funcional" class="md-nav__link">
      Tema 2: Programación funcional
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-2" type="checkbox" id="nav-2">
    
    <label class="md-nav__link" for="nav-2">
      Seminarios
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-2">
        Seminarios
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../seminarios/seminario1-scheme/seminario1-scheme.html" title="Seminario de Scheme" class="md-nav__link">
      Seminario de Scheme
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              <div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    
<nav class="md-nav md-nav--secondary">
  
  
    
  
  
    <label class="md-nav__title" for="__toc">Tabla de contenidos</label>
    <ul class="md-nav__list" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#mas-conceptos-sobre-clausuras" class="md-nav__link">
    Más conceptos sobre clausuras
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#repaso-de-clausuras" class="md-nav__link">
    Repaso de clausuras
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#clausuras-escapadas" class="md-nav__link">
    Clausuras escapadas
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#autoclausuras" class="md-nav__link">
    Autoclausuras
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#introduccion-historia-y-caracteristicas-de-la-programacion-orientada-a-objetos" class="md-nav__link">
    Introducción, historia y características de la Programación Orientada a Objetos
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#nacimiento" class="md-nav__link">
    Nacimiento
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#alan-kay" class="md-nav__link">
    Alan Kay
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#interesados-en-smalltalk" class="md-nav__link">
    ¿Interesados en Smalltalk?
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#lenguajes-oo" class="md-nav__link">
    Lenguajes OO
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#del-paradigma-imperativo-al-oo" class="md-nav__link">
    Del paradigma imperativo al OO
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#caracteristicas-de-la-poo" class="md-nav__link">
    Características de la POO
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#clases-y-objetos" class="md-nav__link">
    Clases y objetos
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#lenguajes-poo-dinamicos-vs-estaticos" class="md-nav__link">
    Lenguajes POO dinámicos vs. estáticos
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#clases-y-estructuras" class="md-nav__link">
    Clases y estructuras
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#definicion" class="md-nav__link">
    Definición
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#instancias-de-clases-y-estructuras" class="md-nav__link">
    Instancias de clases y estructuras
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#acceso-a-propiedades" class="md-nav__link">
    Acceso a propiedades
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#inicializacion-de-las-estructuras-por-sus-propiedades" class="md-nav__link">
    Inicialización de las estructuras por sus propiedades
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#estructuras-y-enumeraciones-son-tipos-valor" class="md-nav__link">
    Estructuras y enumeraciones son tipos valor
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#las-clases-son-tipos-referencia" class="md-nav__link">
    Las clases son tipos referencia
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#declaracion-de-instancias-con-let" class="md-nav__link">
    Declaración de instancias con let
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#operadores-de-identidad" class="md-nav__link">
    Operadores de identidad
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#criterios-para-usar-estructuras-y-clases" class="md-nav__link">
    Criterios para usar estructuras y clases
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#propiedades" class="md-nav__link">
    Propiedades
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#propiedades-almacenadas" class="md-nav__link">
    Propiedades almacenadas
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#propiedades-calculadas" class="md-nav__link">
    Propiedades calculadas
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#propiedades-solo-lectura" class="md-nav__link">
    Propiedades solo-lectura
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#observadores-de-propiedades" class="md-nav__link">
    Observadores de propiedades
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#variables-locales-y-globales" class="md-nav__link">
    Variables locales y globales
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#propiedades-del-tipo" class="md-nav__link">
    Propiedades del tipo
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#metodos" class="md-nav__link">
    Métodos
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#metodos-de-instancia" class="md-nav__link">
    Métodos de instancia
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#nombres-locales-y-externos-de-parametros" class="md-nav__link">
    Nombres locales y externos de parámetros
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#la-propiedad-self" class="md-nav__link">
    La propiedad self
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#operaciones-con-instancias-de-tipo-valor" class="md-nav__link">
    Operaciones con instancias de tipo valor
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#modificacion-de-tipos-valor-desde-dentro-de-la-instancia" class="md-nav__link">
    Modificación de tipos valor desde dentro de la instancia
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#asignacion-a-self-en-un-metodo-mutador" class="md-nav__link">
    Asignación a self en un método mutador
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#metodos-del-tipo" class="md-nav__link">
    Métodos del tipo
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#inicializacion" class="md-nav__link">
    Inicialización
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#inicializadores-por-defecto-y-memberwise" class="md-nav__link">
    Inicializadores por defecto y memberwise
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#inicializacion-de-propiedades-almacenadas" class="md-nav__link">
    Inicialización de propiedades almacenadas
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#inicializadores-personalizados" class="md-nav__link">
    Inicializadores personalizados
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#herencia" class="md-nav__link">
    Herencia
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#definicion-de-una-clase-base" class="md-nav__link">
    Definición de una clase base
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#construccion-de-subclases" class="md-nav__link">
    Construcción de subclases
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#sobreescritura" class="md-nav__link">
    Sobreescritura
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#protocolos" class="md-nav__link">
    Protocolos
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#sintaxis" class="md-nav__link">
    Sintaxis
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#requisitos-de-propiedades" class="md-nav__link">
    Requisitos de propiedades
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#requisitos-de-metodos" class="md-nav__link">
    Requisitos de métodos
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#requisito-de-metodo-mutating" class="md-nav__link">
    Requisito de método mutating
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#protocolos-como-tipos" class="md-nav__link">
    Protocolos como tipos
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#colecciones-de-tipos-protocolo" class="md-nav__link">
    Colecciones de tipos protocolo
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#protocolo-equatable" class="md-nav__link">
    Protocolo Equatable
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#casting-de-tipos" class="md-nav__link">
    Casting de tipos
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#una-jerarquia-de-clases-para-el-casting-de-tipos" class="md-nav__link">
    Una jerarquía de clases para el casting de tipos
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#comprobacion-del-tipo" class="md-nav__link">
    Comprobación del tipo
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#downcasting" class="md-nav__link">
    Downcasting
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#el-tipo-any" class="md-nav__link">
    El tipo Any
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#comprobacion-de-ajustarse-a-un-protocolo" class="md-nav__link">
    Comprobación de ajustarse a un protocolo
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#extensiones" class="md-nav__link">
    Extensiones
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#sintaxis_1" class="md-nav__link">
    Sintaxis
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#propiedades-calculadas_1" class="md-nav__link">
    Propiedades calculadas
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#inicializadores" class="md-nav__link">
    Inicializadores
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#metodos_1" class="md-nav__link">
    Métodos
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#metodos-de-instancia-mutadores" class="md-nav__link">
    Métodos de instancia mutadores
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ajustar-un-tipo-a-un-protocolo-mediante-una-extension" class="md-nav__link">
    Ajustar un tipo a un protocolo mediante una extensión
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#declaracion-de-la-adopcion-de-un-protocolo-con-una-extension" class="md-nav__link">
    Declaración de la adopción de un protocolo con una extensión
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#implementacion-de-metodos-de-un-protocolo" class="md-nav__link">
    Implementación de métodos de un protocolo
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#funciones-operadoras" class="md-nav__link">
    Funciones operadoras
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#operadores-prefijos-y-postfijos" class="md-nav__link">
    Operadores prefijos y postfijos
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#operadores-de-equivalencia" class="md-nav__link">
    Operadores de equivalencia
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#genericos" class="md-nav__link">
    Genéricos
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#extension-de-un-tipo-generico" class="md-nav__link">
    Extensión de un tipo genérico
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#restriccion-en-las-extensiones-de-un-protocolo" class="md-nav__link">
    Restricción en las extensiones de un protocolo
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#bibliografia" class="md-nav__link">
    Bibliografía
  </a>
  
</li>
      
      
      
      
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content">
            <article class="md-content__inner md-typeset">
              
                
                
                <!--

Para el curso que viene:

Cosas importantes que no contamos, que habría que contar (si hubiera 
tiempo en la última sesión):

- Un protocolo puede extender otro protocolo (o más de uno)
https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Protocols.html#//apple_ref/doc/uid/TP40014097-CH25-ID280

- Ampliar el tema de genéricos con type constraints y cláusula where

-->

<h1 id="tema-6-programacion-orientada-a-objetos-con-swift">Tema 6: Programación Orientada a Objetos con Swift<a class="headerlink" href="#tema-6-programacion-orientada-a-objetos-con-swift" title="Permanent link">&para;</a></h1>
<h2 id="mas-conceptos-sobre-clausuras">Más conceptos sobre clausuras<a class="headerlink" href="#mas-conceptos-sobre-clausuras" title="Permanent link">&para;</a></h2>
<h3 id="repaso-de-clausuras">Repaso de clausuras<a class="headerlink" href="#repaso-de-clausuras" title="Permanent link">&para;</a></h3>
<p>Ya vimos en el tema anterior que las clausuras en Swift son bloques de
código con funcionalidades que se pueden pasar de un sitio a otro en
nuestro programa. Son muy similares a las expresiones lambda de Scheme
o de Java 8 o a los bloques de Objective-C. Una clausura puede
capturar o almacenar referencias a cualquier constante o variable del
contexto o ámbito dentro de la cual han sido definidas.</p>
<p>Se pueden definir clausuras en Swift de las siguientes formas:</p>
<ul>
<li>Funciones anidadas que pueden capturar valores de la función englobante:</li>
</ul>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">func</span> <span class="nf">construyeFunc</span><span class="p">()</span> <span class="p">-&gt;</span> <span class="p">()</span> <span class="p">-&gt;</span> <span class="nb">Int</span> <span class="p">{</span>
   <span class="kd">var</span> <span class="nv">x</span> <span class="p">=</span> <span class="mi">0</span>
   <span class="kd">func</span> <span class="nf">funcion</span><span class="p">()</span> <span class="p">-&gt;</span> <span class="nb">Int</span> <span class="p">{</span>
      <span class="n">x</span> <span class="p">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>
      <span class="k">return</span> <span class="n">x</span>
   <span class="p">}</span>
   <span class="k">return</span> <span class="n">funcion</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nv">f</span> <span class="p">=</span> <span class="n">construyeFunc</span><span class="p">()</span>
<span class="n">f</span><span class="p">()</span> <span class="c1">// -&gt; 1</span>
<span class="n">f</span><span class="p">()</span> <span class="c1">// -&gt; 2</span>
</pre></div>
</td></tr></table>

<p>La función devuelta por <code>construyeFunc()</code> también se puede formular
como una expresión de clausura:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">func</span> <span class="nf">construyeFunc</span><span class="p">()</span> <span class="p">-&gt;</span> <span class="p">()</span> <span class="p">-&gt;</span> <span class="nb">Int</span> <span class="p">{</span>
   <span class="kd">var</span> <span class="nv">x</span> <span class="p">=</span> <span class="mi">0</span>
   <span class="k">return</span> <span class="p">{</span>
      <span class="n">x</span> <span class="p">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>
      <span class="k">return</span> <span class="n">x</span>
   <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<p>En el siguiente ejemplo vemos claramente que la función captura las
variables definidas en el ámbito en el que se creó. En el caso
anterior la clausura devuelta captura la variable <code>x</code> con el valor 0.</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">func</span> <span class="nf">usaFunc</span><span class="p">(</span><span class="kc">_</span> <span class="n">f</span><span class="p">:</span> <span class="p">()</span> <span class="p">-&gt;</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Int</span> <span class="p">{</span>
     <span class="kd">var</span> <span class="nv">x</span> <span class="p">=</span> <span class="mi">4</span>
     <span class="k">return</span> <span class="n">f</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nv">f</span> <span class="p">=</span> <span class="n">construyeFunc</span><span class="p">()</span>
<span class="n">usaFunc</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="c1">// -&gt; 1</span>
</pre></div>
</td></tr></table>

<p>El valor devuelto por <code>usaFunc</code> en el resultado de la invocación a
<code>f()</code> en su segunda línea de código. Y el valor de <code>x</code> usado por la
clausura <code>f</code> es el capturado en el momento de su creación (el valor
<code>x=0</code> definido en la primera línea de <code>construyeFunc</code>).</p>
<ul>
<li>Funciones anónimas que pueden capturar valores del contexto que las rodean:</li>
</ul>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">var</span> <span class="nv">x</span> <span class="p">=</span> <span class="mi">100</span>
<span class="n">usaFunc</span> <span class="p">{</span><span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">10</span><span class="p">}</span> <span class="c1">// -&gt; 110</span>
</pre></div>
</td></tr></table>

<p>En el ejemplo anterior la expresión de clausura se define en el ámbito
global donde la <code>x</code>toma el valor 100. Ese valor queda capturado y es
el que se usa en la evaluación de la función. Por tanto, en el
contexto donde se evalúa esa clausura (dentro del cuerpo de la
funcioón <code>usaFunc</code>), la <code>x</code>que toma es la capturada y no la definida
en el cuerpo de <code>usaFunc</code>.</p>
<h3 id="clausuras-escapadas">Clausuras escapadas<a class="headerlink" href="#clausuras-escapadas" title="Permanent link">&para;</a></h3>
<p>Se dice que una clausura escapa de una función cuando la función
recibe una función o clausura como parámetro que se llama después de
que la función finalice su ejecución.</p>
<p>Por ejemplo, definimos un array global de tipo función:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">var</span> <span class="nv">array</span> <span class="p">:</span> <span class="p">[()</span> <span class="p">-&gt;</span> <span class="nb">Int</span><span class="p">]</span> <span class="p">=</span> <span class="p">[]</span>
</pre></div>
</td></tr></table>

<p>Definimos una función que recibe una clausura como parámetro, pero no
se llama dentro de la función que la recibe, sólo la almacena en el
array. Al no ser llamada dentro de la función, hay que ponerle el
atributo <code>@escaping</code> delante del tipo del parámetro para que Swift
permita que sea llamada posteriormente fuera de la función que la
recibe. Si no lo ponemos, el compilador da un error:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">func</span> <span class="nf">usaClausura</span><span class="p">(</span><span class="kc">_</span> <span class="n">f</span><span class="p">:</span> <span class="p">@</span><span class="n">escaping</span> <span class="p">()</span> <span class="p">-&gt;</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Void</span> <span class="p">{</span>
   <span class="n">array</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="p">}</span>

<span class="n">usaClausura</span> <span class="p">{</span><span class="k">return</span> <span class="mi">4</span><span class="p">}</span>
</pre></div>
</td></tr></table>

<p>Se llama posteriormente, fuera de la función:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">array</span><span class="p">[</span><span class="mi">0</span><span class="p">]()</span> <span class="c1">//-&gt; 4</span>
</pre></div>
</td></tr></table>

<h3 id="autoclausuras">Autoclausuras<a class="headerlink" href="#autoclausuras" title="Permanent link">&para;</a></h3>
<p>Una autoclausura permite crear automáticamente una función en tiempo
de ejecución sin necesidad de utilizar la sintaxis de las expresiones
de clausura.</p>
<p>Se puede ver la autoclausura como una forma de retardar la evaluación,
porque esa expresión no se evaluará hasta que se llame a la
clausura. Retardar la evaluación es útil con trozos de código que
provocan efectos laterales o son costosos computacionalmente, ya que
nos permiten controlar el momento de su evaluación.</p>
<p>Por ejemplo, podemos modificar la función anterior <code>usaFunc</code> añadiendo
la anotación <code>@autoclosure</code> antes del tipo del parámetro clausura:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">func</span> <span class="nf">usaFunc</span><span class="p">(</span><span class="kc">_</span> <span class="n">f</span><span class="p">:</span> <span class="kr">@autoclosure</span> <span class="p">()</span> <span class="p">-&gt;</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Int</span> <span class="p">{</span>
     <span class="kd">var</span> <span class="nv">x</span> <span class="p">=</span> <span class="mi">4</span>
     <span class="k">return</span> <span class="n">f</span><span class="p">()</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<p>Al declararlo de esta forma, se puede llamar a <code>usaFunc</code> escribiendo
como parámetro una sentencia que el compilador convierte a clausura:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">var</span> <span class="nv">x</span> <span class="p">=</span> <span class="mi">100</span>
<span class="n">usaFunc</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">10</span><span class="p">)</span>
</pre></div>
</td></tr></table>

<p>La expresión <code>x + 10</code> se considera <em>retardada</em>: se construye una
clausura con ella y su evaluación se realiza dentro de <code>usaFunc</code>.</p>
<p>Otro ejemplo en el que podemos comprobar el orden de evaluación:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">func</span> <span class="nf">printTest2</span><span class="p">(</span><span class="kc">_</span> <span class="n">result</span><span class="p">:</span> <span class="kr">@autoclosure</span> <span class="p">()</span> <span class="p">-&gt;</span> <span class="nb">Void</span><span class="p">)</span> <span class="p">{</span>
    <span class="bp">print</span><span class="p">(</span><span class="s">&quot;Antes&quot;</span><span class="p">)</span>
    <span class="n">result</span><span class="p">()</span>
    <span class="bp">print</span><span class="p">(</span><span class="s">&quot;Después&quot;</span><span class="p">)</span>
<span class="p">}</span>

<span class="n">printTest2</span><span class="p">(</span><span class="bp">print</span><span class="p">(</span><span class="s">&quot;Hola&quot;</span><span class="p">))</span>

<span class="c1">// Imprime: </span>
<span class="c1">//     Antes</span>
<span class="c1">//     Hola</span>
<span class="c1">//     Después</span>
</pre></div>
</td></tr></table>

<p>La sentencia <code>print("Hola")</code> se pasa como una autoclausura, por lo que
el compilador crea automáticamente una clausura con ella sin tener
nosotros que escribir la expresión de clausura.</p>
<h2 id="introduccion-historia-y-caracteristicas-de-la-programacion-orientada-a-objetos">Introducción, historia y características de la Programación Orientada a Objetos<a class="headerlink" href="#introduccion-historia-y-caracteristicas-de-la-programacion-orientada-a-objetos" title="Permanent link">&para;</a></h2>
<h3 id="nacimiento">Nacimiento<a class="headerlink" href="#nacimiento" title="Permanent link">&para;</a></h3>
<ul>
<li>La Programación Orientada a Objetos es un paradigma de programación
  que explota en los 80 pero nace a partir de ideas a finales de los
  60 y 70</li>
<li>Primer lenguaje con las ideas fundamentales de POO: Simula</li>
<li>Smalltalk (1980) como lenguaje paradigmática de POO</li>
<li><strong>Alan Kay</strong> es el creador del término “Object-Oriented” y una de las
  figuras fundamentales de la historia de la informática
  moderna. Trabajó en Xerox Park y desarrolló allí ideas que han sido
  clave para la informática personal (como el Dynabook, precursor de
  tablets y dispositivos móviles y el lenguajes de programación Smalltalk)</li>
<li>Artículo de Alan Kay:
  <a href="http://gagne.homedns.org/%7etgagne/contrib/EarlyHistoryST.html">“The Early History of Smalltalk”</a>,
  ACM SIGPLAN, March 1993</li>
</ul>
<h3 id="alan-kay">Alan Kay<a class="headerlink" href="#alan-kay" title="Permanent link">&para;</a></h3>
<blockquote>
<p>“I invented the term Object-Oriented and I can tell you I did not
have C++ in mind.”</p>
<p>“Smalltalk is not only NOT its syntax or the class library, it is
not even about classes. I'm sorry that I long ago coined the term
objects for this topic because it gets many people to focus on the
lesser idea. The big idea is messaging.”</p>
<p>“Smalltalk's design–and existence–is due to the insight that
everything we can describe can be represented by the recursive
composition of a single kind of behavioral building block that hides
its combination of state and process inside itself and can be dealt
with only through the exchange of messages.”</p>
</blockquote>
<h3 id="interesados-en-smalltalk">¿Interesados en Smalltalk?<a class="headerlink" href="#interesados-en-smalltalk" title="Permanent link">&para;</a></h3>
<p>Visitar:</p>
<ul>
<li><a href="http://www.squeak.org/">http://www.squeak.org/</a></li>
<li><a href="http://swiki.agro.uba.ar/small_land">http://swiki.agro.uba.ar/small_land</a></li>
<li><a href="http://www.squeakland.org">http://www.squeakland.org</a></li>
</ul>
<h3 id="lenguajes-oo">Lenguajes OO<a class="headerlink" href="#lenguajes-oo" title="Permanent link">&para;</a></h3>
<ul>
<li>Smalltalk, Java, Scala, Ruby, Python, C#, C++, Swift, ...</li>
</ul>
<h3 id="del-paradigma-imperativo-al-oo">Del paradigma imperativo al OO<a class="headerlink" href="#del-paradigma-imperativo-al-oo" title="Permanent link">&para;</a></h3>
<ul>
<li>Programación procedural: estado abstracto (tipos de datos y barrera
  de abstracción) + funciones</li>
<li>Siguiente paso: agrupar estado y funciones en una única entidad</li>
<li>Los objetos son estas entidades</li>
</ul>
<h3 id="caracteristicas-de-la-poo">Características de la POO<a class="headerlink" href="#caracteristicas-de-la-poo" title="Permanent link">&para;</a></h3>
<ul>
<li>Objetos (creados/instanciados en tiempo de ejecución) y clases
  (plantillas estáticas/tiempo de compilación)</li>
<li>Los objetos agrupan estado y conducta (métodos)</li>
<li>Los métodos se invocan mediante mensajes</li>
<li><em>Dispatch dinámico</em>: cuando una operación es invocada sobre un
  objeto, el propio objeto determina qué código se ejecuta. Dos
  objetos con la misma interfaz pueden tener implementaciones
  distintas.</li>
<li>Herencia: las clases se pueden definir utilizando otras clases como
  plantillas y modificando sus métodos y/o variables de instancia.</li>
</ul>
<h3 id="clases-y-objetos">Clases y objetos<a class="headerlink" href="#clases-y-objetos" title="Permanent link">&para;</a></h3>
<p>Objeto:</p>
<ul>
<li>Un objeto contiene un estado (propiedades, atributos o variables de
  instancia) y un conjunto de funciones (métodos) que se ejecutan en
  el ámbito del objeto e implementan las funcionalidades soportadas</li>
<li>Al ejecutar un método, el objeto modifica su estado</li>
<li>Pedimos a un objeto que ejecute un método</li>
</ul>
<p>Clase:</p>
<ul>
<li>Una clase es la plantilla que sirve para definir los objetos</li>
<li>En una clase se define los elementos que componen el objeto (sus
  atributos o campos) y sus métodos</li>
<li>En algunos lenguajes se pueden definir también en las clases
  variables (variables de clase) compartidas por todos los objetos de
  esa clase</li>
</ul>
<h3 id="lenguajes-poo-dinamicos-vs-estaticos">Lenguajes POO dinámicos vs. estáticos<a class="headerlink" href="#lenguajes-poo-dinamicos-vs-estaticos" title="Permanent link">&para;</a></h3>
<p>Dos tendencias:</p>
<ul>
<li>
<p>Lenguajes <strong>dinámicos</strong>: muchas características del programa se
  obtienen en tiempo de ejecución</p>
<ul>
<li>Mayor flexibilidad y generalidad del código</li>
<li>Dispatch dinámico</li>
<li>Reflexión (posibilidad de consultar características de la
  instancia (nombres de métodos, propiedades, etc.) en tiempo de
  ejecución)</li>
<li>Ejemplos: Smalltalk, Ruby, Python, JavaScript, Java (en menor
  medida)</li>
</ul>
</li>
<li>
<p>Lenguajes <strong>estáticos</strong>: la mayoría de características del programa
  se obtienen en tiempo de compilación</p>
<ul>
<li>Mayor eficiencia</li>
<li>Se conoce a priori el tipo de la mayor parte de instancias del
  programa</li>
<li>Fuertemente tipeado</li>
<li>Ejemplos: C++, Swift</li>
</ul>
</li>
</ul>
<p>Vamos a detallar a continuación las <strong>características de Programación
Orientada a Objetos de Swift</strong>. Para tener una introducción rápida
puedes empezar leyendo los últimos apartados del <a href="https://github.com/domingogallardo/apuntes-lpp/blob/master/seminarios/seminario2-swift/seminario2-swift.md">seminario de
Swift</a>
(los apartados <strong>Objetos, clases y estructuras</strong>, <strong>Protocolos y
extensiones</strong> y <strong>Genéricos</strong>).</p>
<h2 id="clases-y-estructuras">Clases y estructuras<a class="headerlink" href="#clases-y-estructuras" title="Permanent link">&para;</a></h2>
<p>En el caso de Swift, las clases y las estructuras son muchas más
cercanas en funcionalidad que en otros lenguajes, como C o C++, y
tienen muchas características comunes. Muchas características de las
instancias de una clase se pueden aplicar también a las instancias de
una estructura. Por eso en Swift se suele hablar de <em>instancias</em> (un
término más general) en lugar de <em>objetos</em>.</p>
<p>Las clases y las estructuras en Swift tienen muchas cosas en
común. Ambos pueden:</p>
<ul>
<li>Definir propiedades y almacenar valores</li>
<li>Definir métodos para proporcionar funcionalidad</li>
<li>Definir subíndices para proporcionar acceso a sus valores usando una
  sintaxis de subíndice</li>
<li>Definir inicializadores para configurar el estado inicial</li>
<li>Ser extendidas para expandir su funcionalidad más allá de una
  implementación por defecto</li>
<li>Ajustarse a un protocolo </li>
</ul>
<p>Las clases tienen características adicionales que no tienen las
estructuras:</p>
<ul>
<li>Mediante la herencia una clase puede heredar las características de
  otra</li>
<li>El casting de tipos permite comprobar e interpretar el tipo de una
  instancia de una clase en tiempo de ejecución</li>
<li>Los deinicializadores permiten a una instancia de una clase liberar
  los recursos que ha asignado</li>
<li>Mediante el conteo de referencias se permite que exista más de una
  referencia a una instancia de una clase</li>
</ul>
<h3 id="definicion">Definición<a class="headerlink" href="#definicion" title="Permanent link">&para;</a></h3>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">class</span> <span class="nc">UnaClase</span> <span class="p">{</span>
    <span class="c1">// definición de clase</span>
<span class="p">}</span>
<span class="kd">struct</span> <span class="nc">UnaEstructura</span> <span class="p">{</span>
    <span class="c1">// definición de una estructura</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">struct</span> <span class="nc">CoordsPantalla</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">posX</span> <span class="p">=</span> <span class="mi">0</span>
    <span class="kd">var</span> <span class="nv">posY</span> <span class="p">=</span> <span class="mi">0</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nc">Ventana</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">esquina</span> <span class="p">=</span> <span class="n">CoordsPantalla</span><span class="p">()</span>
    <span class="kd">var</span> <span class="nv">altura</span> <span class="p">=</span> <span class="mi">0</span>
    <span class="kd">var</span> <span class="nv">anchura</span> <span class="p">=</span> <span class="mi">0</span>
    <span class="kd">var</span> <span class="nv">visible</span> <span class="p">=</span> <span class="kc">true</span>
    <span class="kd">var</span> <span class="nv">etiqueta</span><span class="p">:</span> <span class="nb">String</span><span class="p">?</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<p>El ejemplo define una nueva estructura llamada <code>CoordsPantalla</code>, que
describe una coordenada de pantalla con posiciones basadas en
píxeles. La estructura tiene dos propiedades almacenadas llamadas
<code>posX</code> y <code>posY</code>. Las propiedades son constantes o variables que se
almacenan en la instancia de la clase o de la estructura. El
compilador infiere que estas dos propiedades son <code>Int</code> al
inicializarlas a los valores iniciales de 0.</p>
<p>El ejemplo también define una nueva clase llamada <code>Ventana</code> que
describe una ventana en una pantalla. Esta clase tiene cinco
propiedades variables. La primera, <code>esquina</code>, se inicializa con una
instancia nueva de una estructura <code>CoorsPantalla</code> y se infiere que es
de tipo <code>CoordsPantalla</code>. Representa la posición superior izquierda de
la pantalla. Las propiedades <code>altura</code> y <code>anchura</code> representan el
número de píxeles de las dimensiones de la pantalla. Se inicializan
a 0. La propiedad <code>visible</code> es un <code>Bool</code> que indica si la ventana es
visible en pantalla. Por ejemplo, una ventana que esté minimizada no
será visible. Por último, <code>etiqueta</code> representa el nombre que aparece
en la parte superior de la ventana. Es un <code>String</code> opcional que se
inicializa a <code>nil</code> porque no se le asigna un valor inicial.</p>
<h3 id="instancias-de-clases-y-estructuras">Instancias de clases y estructuras<a class="headerlink" href="#instancias-de-clases-y-estructuras" title="Permanent link">&para;</a></h3>
<p>La definición de las estructuras y las clases únicamente definen sus
aspectos generales. Para describir una configuración específica (una
resolución o un modo de vídeo concreto) es necesario crear una
instancia de una estructura o una clase. La sintaxis para crear ambas
es similar:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">var</span> <span class="nv">unasCoordsPantalla</span> <span class="p">=</span> <span class="n">CoordsPantalla</span><span class="p">()</span>
<span class="kd">var</span> <span class="nv">unaVentana</span> <span class="p">=</span> <span class="n">Ventana</span><span class="p">()</span>
</pre></div>
</td></tr></table>

<p>La forma más sencilla de inicialización es la anterior. Se utiliza el
nombre del tipo de la clase o estructura seguidos de paréntesis
vacíos. Esto crea una nueva instancia de una clase o estructura, con
sus propiedades inicializadas a los valores por defecto definidos en
la declaración de las propiedades.</p>
<p>Swift proporciona este <strong>inicializador por defecto</strong> para clases y
estructuras, siempre que no se defina algún inicializador
explícito. Más adelante comentaremos cómo definir estos
inicializadores explícitos.</p>
<p>En el caso de la instancia <code>unasCoordsPantalla</code> los valores a los que
se han inicializado sus propiedades son:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">unasCoordsPantalla</span><span class="p">.</span><span class="n">posX</span> <span class="c1">// 0</span>
<span class="n">unasCoordsPantalla</span><span class="p">.</span><span class="n">posY</span> <span class="c1">// 0</span>
</pre></div>
</td></tr></table>

<p>Las propiedades de la instancia <code>unaVentana</code> son:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">unaVentana</span><span class="p">.</span><span class="n">esquina</span> <span class="c1">// CoordsPantalla con posX = 0 y posY = 0</span>
<span class="n">unaVentana</span><span class="p">.</span><span class="n">altura</span> <span class="c1">// 0</span>
<span class="n">unaVentana</span><span class="p">.</span><span class="n">anchura</span> <span class="c1">// 0</span>
<span class="n">unaVentana</span><span class="p">.</span><span class="n">visible</span> <span class="c1">// true</span>
<span class="n">unaVentana</span><span class="p">.</span><span class="n">etiqueta</span> <span class="c1">// nil</span>
</pre></div>
</td></tr></table>

<p>Todas las propiedades de una instancia deben estar definidas después
de haberse inicializado, a no ser que la propiedad se un opcional.</p>
<h3 id="acceso-a-propiedades">Acceso a propiedades<a class="headerlink" href="#acceso-a-propiedades" title="Permanent link">&para;</a></h3>
<p>Se puede acceder y modificar las propiedades usando la <em>sintaxis de
punto</em>:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="c1">// Accedemos a la propiedad</span>
<span class="n">coords</span><span class="p">.</span><span class="n">posX</span> <span class="c1">// Devuelve 0</span>
<span class="c1">// Actualizamos la propiedad</span>
<span class="n">coords</span><span class="p">.</span><span class="n">posX</span> <span class="p">=</span> <span class="mi">100</span>
<span class="n">ventana</span><span class="p">.</span><span class="n">esquina</span><span class="p">.</span><span class="n">posY</span> <span class="p">=</span> <span class="mi">100</span>
</pre></div>
</td></tr></table>

<h3 id="inicializacion-de-las-estructuras-por-sus-propiedades">Inicialización de las estructuras por sus propiedades<a class="headerlink" href="#inicializacion-de-las-estructuras-por-sus-propiedades" title="Permanent link">&para;</a></h3>
<p>Si en las estructuras no se se definen inicializadores explícitos
(veremos más adelante cómo hacerlo) podemos utilizar un
<strong>inicializador <em>memberwise</em></strong> (de todas las propiedades) en el que
hay que proporcionar los valores de todas sus propiedades.</p>
<p>En las clases no existen los inicializadores <em>memberwise</em>, sólo en las
estructuras.</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">var</span> <span class="nv">coords</span> <span class="p">=</span> <span class="n">CoordsPantalla</span><span class="p">(</span><span class="n">posX</span><span class="p">:</span> <span class="mi">200</span><span class="p">,</span> <span class="n">posY</span><span class="p">:</span> <span class="mi">400</span><span class="p">)</span>
</pre></div>
</td></tr></table>

<p>Es necesario inicializar todas las propiedades. Si no, el compilador
da un error:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">var</span> <span class="nv">coords2</span> <span class="p">=</span> <span class="n">CoordsPantalla</span><span class="p">(</span><span class="n">posX</span><span class="p">:</span> <span class="mi">200</span><span class="p">)</span>
<span class="c1">// error</span>
</pre></div>
</td></tr></table>

<h3 id="estructuras-y-enumeraciones-son-tipos-valor">Estructuras y enumeraciones son tipos valor<a class="headerlink" href="#estructuras-y-enumeraciones-son-tipos-valor" title="Permanent link">&para;</a></h3>
<p>Un <em>tipo valor</em> es un tipo cuyo valor se copia cuando se asigna a una
variable o constante, o cuando se pasa a una función.</p>
<p>Todos los tipos básicos de Swift -enteros, números en punto flotante,
cadenas, arrays y diccionarios- son tipos valor y se implementan como
estructuras. Las estructuras y las enumeraciones son tipos valor en
Swift.</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">var</span> <span class="nv">coords1</span> <span class="p">=</span> <span class="n">CoordsPantalla</span><span class="p">(</span><span class="n">posX</span><span class="p">:</span> <span class="mi">600</span><span class="p">,</span> <span class="n">posY</span><span class="p">:</span> <span class="mi">600</span><span class="p">)</span>
<span class="kd">var</span> <span class="nv">coords2</span> <span class="p">=</span> <span class="n">coords1</span>
<span class="n">coords2</span><span class="p">.</span><span class="n">posX</span> <span class="p">=</span> <span class="mi">1000</span>
<span class="n">coords1</span><span class="p">.</span><span class="n">poxX</span> <span class="c1">// devuelve 600</span>
</pre></div>
</td></tr></table>

<p>En el ejemplo se declara una constante llamada <code>coords1</code> y se asigna a una
instancia de <code>CoordsPantalla</code> inicializada con la posición x de 600 y
la posición y de 600. Después se declara una variable llamada
<code>coords2</code> y se asigna al valor actual de <code>coors1</code>. Debido a que <code>CoordsPantalla</code>
es una estructura, se crea <em>una copia</em> de la instancia existente y
esta nueva copia se asigna a <code>coords2</code>. Aunque ahora <code>coords2</code> y <code>coords1</code> tienen
las mismas <code>posX</code> y <code>posY</code>, son dos instancias completamente
distintas. Después, la propiedad <code>posX</code> de <code>coords2</code> se actualiza a 1000.</p>
<p>Podemos comprobar que la propiedad se modifica, pero que el valor de
<code>posX</code> en <code>coords1</code> sigue siendo el mismo.</p>
<h3 id="las-clases-son-tipos-referencia">Las clases son tipos referencia<a class="headerlink" href="#las-clases-son-tipos-referencia" title="Permanent link">&para;</a></h3>
<p>A diferencia de los tipos valor, los tipos de referencias no se copian
cuando se asignan o se pasan a funciones. En su lugar se usa una
referencia a la misma instancia existente.</p>
<p>En Swift las clases son tipos referencias. Veamos, por ejemplo, una
instancia de la clase <code>Ventana</code>:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">var</span> <span class="nv">ventana1</span> <span class="p">=</span> <span class="n">Ventana</span><span class="p">()</span>
<span class="n">ventana1</span><span class="p">.</span><span class="n">esquina</span> <span class="p">=</span> <span class="n">coords1</span>
<span class="n">ventana1</span><span class="p">.</span><span class="n">altura</span> <span class="p">=</span> <span class="mi">800</span>
<span class="n">ventana1</span><span class="p">.</span><span class="n">anchura</span> <span class="p">=</span> <span class="mi">800</span>
<span class="n">ventana1</span><span class="p">.</span><span class="n">etiqueta</span> <span class="p">=</span> <span class="s">&quot;Finder&quot;</span>
<span class="kd">var</span> <span class="nv">ventana2</span> <span class="p">=</span> <span class="n">ventana1</span>
<span class="n">ventana2</span><span class="p">.</span><span class="n">anchura</span> <span class="p">=</span> <span class="mi">1000</span>
<span class="n">ventana1</span><span class="p">.</span><span class="n">anchura</span> <span class="c1">// devuelve 1000</span>
</pre></div>
</td></tr></table>

<p>Declaramos una variable llamada <code>ventana1</code> inicializada con una
instancia nueva de la clase <code>Ventana</code>. Le asignamos a la propiedad
<code>esquina</code> una copia de la resolución anterior <code>coords1</code>. Después
declaramos la altura, anchura y etiqueta de la ventana. Y, por último,
<code>ventana1</code> se asigna a una nueva constante llamada <code>ventan2</code>, y la
anchura se modifica.</p>
<p>Debido a que son tipos de referencia, <strong><code>ventana1</code> y <code>ventana2</code> se
refieren a la misma instancia de <code>Ventana</code></strong>. Son sólo dos nombres
distintos para la misma única instancia. </p>
<p>Lo podemos comprobar modificando una propiedad mediante una variable y
viendo que esa misma propiedad en la otra variable se ha modificado
también (líneas 7 y 8).</p>
<p>Si tienes experiencia con C, C++, o Objective-C, puedes saber que
estos lenguajes usan punteros para referirse a una dirección de
memoria. Una constante o variable en Swift que se refiere a una
instancia de un tipo referencia es similar a un puntero en C, pero no
es un puntero que apunta a una dirección de memoria y no requiere que
se escriba un asterisco (*) para indicar que estas creando una
referencia. En su lugar, estas referencias se definen como cualquier
otra constante o variable en Swift.</p>
<h3 id="declaracion-de-instancias-con-let">Declaración de instancias con <code>let</code><a class="headerlink" href="#declaracion-de-instancias-con-let" title="Permanent link">&para;</a></h3>
<p>Las estructuras y clases también tienen comportamientos distintos
cuando se declaran las variables con <code>let</code>.</p>
<p>Si definimos con <code>let</code> una instancia de una estructura estamos
declarando constante la variable y todas las propiedades de la
instancia. No podremos modificar ninguna:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">let</span> <span class="nv">coords3</span> <span class="p">=</span> <span class="n">CoordsPantalla</span><span class="p">(</span><span class="n">posX</span><span class="p">:</span> <span class="mi">400</span><span class="p">,</span> <span class="n">posY</span><span class="p">:</span> <span class="mi">400</span><span class="p">)</span>
<span class="n">coords3</span><span class="p">.</span><span class="n">posX</span> <span class="p">=</span> <span class="mi">800</span>
<span class="c1">// error: cannot assign to property: &#39;coords3&#39; is a &#39;let&#39; constant</span>
</pre></div>
</td></tr></table>

<p>Si definimos con un <code>let</code> una instancia de una clase sólo estamos
declarando constante la variable. No podremos reasignarla, pero sí que
podremos modificar las propiedades de la instancia referenciada por la
variable:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">let</span> <span class="nv">ventana3</span> <span class="p">=</span> <span class="n">Ventana</span><span class="p">()</span>
<span class="c1">// Sí que podemos modificar una propiedad de la instancia:</span>
<span class="n">ventana3</span><span class="p">.</span><span class="n">etiqueta</span> <span class="p">=</span> <span class="s">&quot;Listado&quot;</span>
<span class="c1">// Pero no podemos reasignar la variable:</span>
<span class="n">ventana3</span> <span class="p">=</span> <span class="n">ventana1</span>
<span class="c1">// error: cannot assign to value: &#39;ventana3&#39; is a &#39;let&#39; constant</span>
</pre></div>
</td></tr></table>

<h3 id="operadores-de-identidad">Operadores de identidad<a class="headerlink" href="#operadores-de-identidad" title="Permanent link">&para;</a></h3>
<p>A veces puede ser útil descubrir si dos constantes o variables se
refieren exactamente a la misma instancia de una clase. Para permitir
esto, Swift proporciona dos operadores de identidad:</p>
<ul>
<li>Idéntico a (<code>===</code>)</li>
<li>No idéntico a (<code>!==</code>)</li>
</ul>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">ventana1</span> <span class="p">===</span> <span class="n">ventana2</span> <span class="c1">// devuelve true</span>
<span class="n">ventana1</span> <span class="p">===</span> <span class="n">ventana3</span> <span class="c1">// devuelve false</span>
</pre></div>
</td></tr></table>

<p>Estos operadores "idéntico a" no son los mismos que los de "igual a"
(representado por dos signos iguales <code>==</code>):</p>
<ul>
<li>"Idéntico a" significa que dos constantes o variables de una clase
  se refieren exactamente a la misma instancia de la clase.</li>
<li>"Igual a" significa que dos instancias se consideran "iguales" o
  "equivalentes" en su valor. Es responsabilidad del diseñador de la
  clase definir la implementación de estos operadores.</li>
</ul>
<h3 id="criterios-para-usar-estructuras-y-clases">Criterios para usar estructuras y clases<a class="headerlink" href="#criterios-para-usar-estructuras-y-clases" title="Permanent link">&para;</a></h3>
<p>Podemos usar tanto clases como estructuras para definir nuestros tipos
de datos y utilizarlos como bloques de construcción del código de
nuestros programas. Sin embargo, se utilizan para distintos tipos de
tareas.</p>
<p>Como regla general, utilizaremos una estructura cuando se cumplen una
o más de las siguientes condiciones:</p>
<ul>
<li>El principal objetivo de la estructura es encapsular unos pocos
  datos relativamente sencillos.</li>
<li>Es razonable esperar que los valores encapsulados serán copiados,
  más que referenciados, cuando asignamos o pasamos una instancia de
  esa estructura.</li>
<li>Todas las propiedades almacenadas en la estructura son a su vez
  tipos valor, que también se espera que sean copiados más que
  referenciados.</li>
<li>La estructura no necesita heredar propiedades o conducta de otro
  tipo existente.</li>
</ul>
<p>Ejemplos de buenos candidatos de estructuras incluyen:</p>
<ul>
<li>El tamaño de una forma geométrica, encapsulando por ejemplo las
  propiedades <code>ancho</code> y <code>alto</code> de tipo <code>Double</code>.</li>
<li>Una forma de referirse a rangos dentro de una serie, encapsulando
  por ejemplo, una propiedad <code>comienzo</code> y otra <code>longitud</code>, ambos del
  tipo <code>Int</code>.</li>
<li>Un punto en un sistema de coordenadas 3D, encapsulando quizás las
  propiedades <code>x</code>, <code>y</code> y <code>z</code>, todos ellos de tipo <code>Double</code>.</li>
</ul>
<p>En el resto de casos, definiremos una clase y crearemos instancias de
esa clase que tendrán que ser gestionadas y pasadas por referencia. En
la práctica, esto representa que la mayoría de datos que construiremos
en nuestros programas deberían clases, no estructuras. Aunque usaremos
muchas de las estructuras estándar de Swift.</p>
<h2 id="propiedades">Propiedades<a class="headerlink" href="#propiedades" title="Permanent link">&para;</a></h2>
<p>Las <em>propiedades</em> asocian valores con una clase, estructura o
enumeración particular. Las propiedades almacenadas (<em>stored
properties</em>) almacenan valores constantes y variables como parte de
una instancia, mientras que las propiedades calculadas (<em>computed
properties</em>) calculan (en lugar de almacenar) un valor. Las
propiedades calculadas se definen en clases, estructuras y
enumeraciones. Las propiedades almacenadas se definen sólo en clases y
estructuras.</p>
<ul>
<li>Enumeraciones: pueden contener sólo propiedades calculadas.</li>
<li>Clases y estructuras: pueden contener propiedades almacenadas y calculadas.</li>
</ul>
<p>Las propiedades calculadas y almacenadas se asocian habitualmente con
instancias de un tipo particular. Sin embargo, las propiedades también
pueden asociarse con el propio tipo. Estas propiedades se conocen como
propiedades del tipo (<em>type properties</em>).</p>
<p>Además, en Swift es posible definir observadores de propiedades que
monitoricen cambios en los valores de una propiedad, a los que podemos
responder con acciones programadas. Los observadores de propiedades
pueden añadirse tanto a propiedades almacenadas definidas por nosotros
como a propiedades heredadas de la superclase.</p>
<h3 id="propiedades-almacenadas">Propiedades almacenadas<a class="headerlink" href="#propiedades-almacenadas" title="Permanent link">&para;</a></h3>
<p>En su forma más simple, una propiedad almacenada es una constante o
variable que está almacenada como parte de una instancia de una clase
o estructura particular. Las propiedades almacenadas pueden ser o bien
variables (usando la palabra clave <code>var</code>) o bien constantes (usando la
palabra clave <code>let</code>).</p>
<p>Podemos proporcionar un valor por defecto para la inicialización de
las propiedades almacenadas, tanto variables como constantes.</p>
<p>El siguiente ejemplo define una estructura llamada <code>RangoLongitudFija</code>
que describe un rango de valores enteros cuya longitud no puede ser
modificada una vez que se crea:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">struct</span> <span class="nc">RangoLongitudFija</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">primerValor</span><span class="p">:</span> <span class="nb">Int</span>
    <span class="kd">let</span> <span class="nv">longitud</span><span class="p">:</span> <span class="nb">Int</span>
<span class="p">}</span>
<span class="kd">var</span> <span class="nv">rangoDeTresItemss</span> <span class="p">=</span> <span class="n">RangoLongitudFija</span><span class="p">(</span><span class="n">primerValor</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="n">longitud</span><span class="p">:</span> <span class="mi">3</span><span class="p">)</span>
<span class="c1">// el rango representa ahora valores enteros the range represents integer values 0, 1, and 2</span>
<span class="n">rangoDeTresItemss</span><span class="p">.</span><span class="n">primerValor</span> <span class="p">=</span> <span class="mi">6</span>
<span class="c1">// el rango representa ahora valores enteros 6, 7 y 8</span>
</pre></div>
</td></tr></table>

<p>Las instancias de <code>RangoLongitudFija</code> tienen una propiedad almacenada
variable llamada <code>primerValor</code> y una propiedad almacenada constante
llamada <code>longitud</code>. En el ejemplo, <code>longitud</code> se inicializa cuando se
crea el nuevo rango y no puede ser cambiada en el futuro, por ser una
propiedad constante.</p>
<h3 id="propiedades-calculadas">Propiedades calculadas<a class="headerlink" href="#propiedades-calculadas" title="Permanent link">&para;</a></h3>
<p>Además de las propiedades almacenadas, las clases, estructuras y
enumeraciones pueden definir <em>propiedades calculadas</em>, que no
almacenan realmente un valor. En su lugar, proporcionan un <em>getter</em> y
un opcional <em>setter</em> que devuelven y modifican otras propiedades y
valores de forma indirecta.</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">struct</span> <span class="nc">Punto</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">x</span> <span class="p">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">y</span> <span class="p">=</span> <span class="mf">0.0</span>
<span class="p">}</span>
<span class="kd">struct</span> <span class="nc">Tamaño</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">ancho</span> <span class="p">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">alto</span> <span class="p">=</span> <span class="mf">0.0</span>
<span class="p">}</span>
<span class="kd">struct</span> <span class="nc">Rectangulo</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">origen</span> <span class="p">=</span> <span class="n">Punto</span><span class="p">()</span>
    <span class="kd">var</span> <span class="nv">tamaño</span> <span class="p">=</span> <span class="n">Tamaño</span><span class="p">()</span>
    <span class="kd">var</span> <span class="nv">centro</span><span class="p">:</span> <span class="n">Punto</span> <span class="p">{</span>
        <span class="kr">get</span> <span class="p">{</span>
            <span class="kd">let</span> <span class="nv">centroX</span> <span class="p">=</span> <span class="n">origen</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="p">(</span><span class="n">tamaño</span><span class="p">.</span><span class="n">ancho</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
            <span class="kd">let</span> <span class="nv">centroY</span> <span class="p">=</span> <span class="n">origen</span><span class="p">.</span><span class="n">y</span> <span class="o">+</span> <span class="p">(</span><span class="n">tamaño</span><span class="p">.</span><span class="n">alto</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">Punto</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">centroX</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">centroY</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="kr">set</span><span class="p">(</span><span class="n">centroNuevo</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">origen</span><span class="p">.</span><span class="n">x</span> <span class="p">=</span> <span class="n">centroNuevo</span><span class="p">.</span><span class="n">x</span> <span class="o">-</span> <span class="p">(</span><span class="n">tamaño</span><span class="p">.</span><span class="n">ancho</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">origen</span><span class="p">.</span><span class="n">y</span> <span class="p">=</span> <span class="n">centroNuevo</span><span class="p">.</span><span class="n">y</span> <span class="o">-</span> <span class="p">(</span><span class="n">tamaño</span><span class="p">.</span><span class="n">alto</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kd">var</span> <span class="nv">cuadrado</span> <span class="p">=</span> <span class="n">Rectangulo</span><span class="p">(</span><span class="n">origen</span><span class="p">:</span> <span class="n">Punto</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">),</span>
                  <span class="n">tamaño</span><span class="p">:</span> <span class="n">Tamaño</span><span class="p">(</span><span class="n">ancho</span><span class="p">:</span> <span class="mf">10.0</span><span class="p">,</span> <span class="n">alto</span><span class="p">:</span> <span class="mf">10.0</span><span class="p">))</span>
<span class="kd">let</span> <span class="nv">centroCuadradoInicial</span> <span class="p">=</span> <span class="n">cuadrado</span><span class="p">.</span><span class="n">centro</span>
<span class="n">cuadrado</span><span class="p">.</span><span class="n">centro</span> <span class="p">=</span> <span class="n">Punto</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="mf">15.0</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="mf">15.0</span><span class="p">)</span>
<span class="bp">print</span><span class="p">(</span><span class="s">&quot;cuadrado.origen está ahora en (</span><span class="si">\(</span><span class="n">cuadrado</span><span class="p">.</span><span class="n">origen</span><span class="p">.</span><span class="n">x</span><span class="si">)</span><span class="s">, </span><span class="si">\(</span><span class="n">cuadrado</span><span class="p">.</span><span class="n">origen</span><span class="p">.</span><span class="n">y</span><span class="si">)</span><span class="s">)&quot;</span><span class="p">)</span>
<span class="c1">// Prints &quot;cuadrado.origen está ahora en (10.0, 10.0)&quot;</span>
</pre></div>
</td></tr></table>

<p>Este ejemplo define tres estructuras para trabajar con formas
geométricas:</p>
<ul>
<li><code>Punto</code> encapsula una coordenada <code>(x, y)</code></li>
<li><code>Tamaño</code> encapsula un ancho y un alto</li>
<li><code>Rectangulo</code> define una rectángulo por un punto de origen y un
  tamaño</li>
</ul>
<p>La estructura <code>Rectangulo</code> proporciona una propiedad calculada llamada
<code>centro</code>. La posición actual del centro de un <code>Rectangulo</code> puede ser
siempre determinada a partir de su origen y su tamaño, por lo que no
necesitamos almacenarlo como un <code>Punto</code> explícito. En su lugar,
<code>Rectangulo</code> define un <em>getter</em> y un <em>setter</em> programado para una
variable calculada llamada <code>centro</code>, para permitirnos trabajar con el
centro del rectángulo como si fuera una propiedad almacenada.</p>
<p>En el ejemplo se crea una variable <code>Rectangulo</code> llamada <code>cuadrado</code>. La
variable <code>cuadrado</code> se inicializa un punto origen de <code>(0, 0)</code> y un
ancho y tamaño de <code>10</code>. Este cuadrado está representado por el
cuadrado azul en el diagrama de abajo.</p>
<p>Accedemos entonces a la propiedad <code>centro</code> de la variable <code>cuadrado</code>
usando la sintaxis del punto (<code>cuadrado.centro</code>), lo que causa que se
llame al <em>getter</em> de <code>centro</code> para devolver el valor actual de la
propiedad. En lugar de devolver los valores existentes, el <em>getter</em>
calcula realmente y devuelve un nuevo <code>Punto</code> para representar el
centro del cuadrado. Como puede verse arriba, el <em>getter</em> devuelve
correctamente un punto con los valores <code>(5, 5)</code>.</p>
<p>Después la propiedad centro se actualiza al nuevo valor de <code>(15, 15)</code>
lo que mueve el cuadrado arriba a la derecha, a la nueva posición
mostrada por el cuadrado naranja en el diagrama de abajo. Al asignar
el nuevo valor a la propiedad se llama al <em>setter</em> del centro, lo que
modifica los valores <code>x</code> e <code>y</code> de las propiedades almacenadas
originales, y mueve el cuadrado a su nueva posición.</p>
<p><img src="imagenes/computedProperties.png" width="300px"/></p>
<p>Se puede definir una versión acortada del <em>setter</em> usando la variable
por defecto <code>newValue</code> que contiene el nuevo valor asignado en el
<em>setter</em>:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">struct</span> <span class="nc">Rectangulo</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">origen</span> <span class="p">=</span> <span class="n">Punto</span><span class="p">()</span>
    <span class="kd">var</span> <span class="nv">tamaño</span> <span class="p">=</span> <span class="n">Tamaño</span><span class="p">()</span>
    <span class="kd">var</span> <span class="nv">centro</span><span class="p">:</span> <span class="n">Punto</span> <span class="p">{</span>
        <span class="kr">get</span> <span class="p">{</span>
            <span class="kd">let</span> <span class="nv">centroX</span> <span class="p">=</span> <span class="n">origen</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="p">(</span><span class="n">tamaño</span><span class="p">.</span><span class="n">ancho</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
            <span class="kd">let</span> <span class="nv">centroY</span> <span class="p">=</span> <span class="n">origen</span><span class="p">.</span><span class="n">y</span> <span class="o">+</span> <span class="p">(</span><span class="n">tamaño</span><span class="p">.</span><span class="n">alto</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">Punto</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">centroX</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">centroY</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="kr">set</span> <span class="p">{</span>
            <span class="n">origen</span><span class="p">.</span><span class="n">x</span> <span class="p">=</span> <span class="n">newValue</span><span class="p">.</span><span class="n">x</span> <span class="o">-</span> <span class="p">(</span><span class="n">tamaño</span><span class="p">.</span><span class="n">ancho</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">origen</span><span class="p">.</span><span class="n">y</span> <span class="p">=</span> <span class="n">newValue</span><span class="p">.</span><span class="n">y</span> <span class="o">-</span> <span class="p">(</span><span class="n">tamaño</span><span class="p">.</span><span class="n">alto</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<h3 id="propiedades-solo-lectura">Propiedades solo-lectura<a class="headerlink" href="#propiedades-solo-lectura" title="Permanent link">&para;</a></h3>
<p>Una propiedad calculada con un <em>getter</em> y sin <em>setter</em> se conoce como
una propiedad calculada de solo-lectura. Una propiedad calculada de
solo-lectura siempre devuelve un valor, y puede accederse a ella
usando la sintaxis de punto, pero no puede modificarse a un valor
distinto.</p>
<p>Es posible simplificar la declaración de una propiedad calculada de
solo-lectura eliminando la palabra clave <code>get</code> y sus llaves:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">struct</span> <span class="nc">Cuboide</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">ancho</span> <span class="p">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">alto</span> <span class="p">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">profundo</span> <span class="p">=</span> <span class="mf">0.0</span>
    <span class="kd">var</span> <span class="nv">volumen</span><span class="p">:</span> <span class="nb">Double</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">ancho</span> <span class="o">*</span> <span class="n">alto</span> <span class="o">*</span> <span class="n">profundo</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kd">let</span> <span class="nv">cuatroPorCincoPorDos</span> <span class="p">=</span> <span class="n">Cuboide</span><span class="p">(</span><span class="n">ancho</span><span class="p">:</span> <span class="mf">4.0</span><span class="p">,</span> <span class="n">alto</span><span class="p">:</span> <span class="mf">5.0</span><span class="p">,</span> <span class="n">profundo</span><span class="p">:</span> <span class="mf">2.0</span><span class="p">)</span>
<span class="bp">print</span><span class="p">(</span><span class="s">&quot;el volumen de cuatroPorCincoPorDos es </span><span class="si">\(</span><span class="n">cuatroPorCincoPorDos</span><span class="p">.</span><span class="n">volumen</span><span class="si">)</span><span class="s">&quot;</span><span class="p">)</span>
<span class="c1">// Imprime &quot;el volumen de cuatroPorCincoPorDos es 40.0&quot;</span>
</pre></div>
</td></tr></table>

<p>Este ejemplo define una nueva estructura llamada <code>Cubiode</code>, que
representa una caja rectangular 3D con propiedades <code>ancho</code>, <code>alto</code> y
<code>profundo</code>. Esta estructura tiene una propiedad calculada llamada
<code>volumen</code>, que calcula y devuelve el volumen actual del cuboide. No
tendría sentido que el volumen fuera modificable, porque no sería
ambiguo determinar qué valores concretos de ancho, alto y profundo
deberían usarse para un valor particular del volumen.</p>
<h3 id="observadores-de-propiedades">Observadores de propiedades<a class="headerlink" href="#observadores-de-propiedades" title="Permanent link">&para;</a></h3>
<p>Los observadores de propiedades (<em>property observers</em>) observan y
responden a cambios en el valor de una propiedad. Los observadores de
propiedades se llaman cada vez que el valor de una propiedad es
actualizado, incluso si el nuevo valor es el mismo que el valor actual
de la propiedad.</p>
<p>Se pueden añadir observadores a cualquier <strong>propiedad almacenada</strong> que se
definan. Se pueden también añadir observadores a cualquier propiedad
heredada (ya sea almacenada o calculada) sobreescribiendo la propiedad
en la subclase. No es necesario definir observadores de propiedades
calculadas no sobreescritas porque siempre es posible observar y
responder a cambios en su valor en el <em>setter</em> de la propiedad.</p>
<p>Es posible definir alguno o ambos de estos observadores sobre una propiedad:</p>
<ul>
<li><code>willSet</code> es llamado justo antes de que el nuevo valor se almacena
  en la propiedad.</li>
<li><code>didSet</code> es llamado inmediatamente después de que el nuevo valor es
  almacenado en la propiedad.</li>
</ul>
<p>Si implementamos un observador <code>willSet</code>, se le pasa el nuevo valor de
la propiedad como un parámetro constante. Podemos especificar un
nombre para este parámetro como parte de la implementación de
<code>willSet</code>. Si no escribimos el nombre del parámetro y los paréntesis
dentro de la implementación, el parámetro estará disponible con el
nombre por defecto de <code>newValue</code>.</p>
<p>De forma similar, si implementamos un observador <code>didSet</code>, se pasa
como un parámetro constante que contiene el valor antiguo de la
propiedad. Podemos darle nombre al parámetro o usar el nombre por
defecto de <code>oldValue</code>. Si asignamos un valor a la propiedad dentro de
su propio observador <code>didSet</code>, el nuevo valor que asignamos reemplaza
el que acaba de añadirse a la propiedad.</p>
<p>A continuación podemos ver un ejemplo de <code>willSet</code> y <code>didSet</code> en
acción. En él definimos una clase nueva llamada <code>CuentaPasos</code>, que
hace un seguimiento del número total de pasos que una persona hace al
caminar. Esta clase puede usarse con datos de entrada de un
<em>podómetro</em> o cualquier otro sistema de seguir el ejercicio de la
persona durante su rutina diaria.</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">class</span> <span class="nc">ContadorPasos</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">totalPasos</span><span class="p">:</span> <span class="nb">Int</span> <span class="p">=</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="kr">willSet</span><span class="p">(</span><span class="n">nuevoTotalPasos</span><span class="p">)</span> <span class="p">{</span>
            <span class="bp">print</span><span class="p">(</span><span class="s">&quot;A punto de actualizar totoalPasos a </span><span class="si">\(</span><span class="n">nuevoTotalPasos</span><span class="si">)</span><span class="s">&quot;</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="kr">didSet</span> <span class="p">{</span>
            <span class="k">if</span> <span class="n">totalPasos</span> <span class="o">&gt;</span> <span class="n">oldValue</span>  <span class="p">{</span>
                <span class="bp">print</span><span class="p">(</span><span class="s">&quot;Añadidos </span><span class="si">\(</span><span class="n">totalPasos</span> <span class="o">-</span> <span class="n">oldValue</span><span class="si">)</span><span class="s"> pasos&quot;</span><span class="p">)</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kd">let</span> <span class="nv">contadorPasos</span> <span class="p">=</span> <span class="n">ContadorPasos</span><span class="p">()</span>
<span class="n">contadorPasos</span><span class="p">.</span><span class="n">totalPasos</span> <span class="p">=</span> <span class="mi">200</span>
<span class="c1">// Imprime: &quot;A punto de actualizar totalPasos a 200&quot;</span>
<span class="c1">// Imprime: &quot;Añadidos 200 pasos&quot;</span>
<span class="n">contadorPasos</span><span class="p">.</span><span class="n">totalPasos</span> <span class="p">=</span> <span class="mi">360</span>
<span class="c1">// Imprime: &quot;A punto de actualizar totalPasos a 360&quot;</span>
<span class="c1">// Imprime: &quot;Añadidos 160 pasos&quot;</span>
<span class="n">contadorPasos</span><span class="p">.</span><span class="n">totalPasos</span> <span class="p">=</span> <span class="mi">896</span>
<span class="c1">// Imprime: &quot;A punto de actualizar totalPasos a 896&quot;</span>
<span class="c1">// Imprime: &quot;Añadidos 536 pasos&quot;</span>
</pre></div>
</td></tr></table>

<p>La clase <code>CuentaPasos</code> declara la propiedad <code>totalPasos</code> de tipo
<code>Int</code>. Esta es una propiedad almacenada con observadores <code>willSet</code> y
<code>didSet</code>.</p>
<p>Los observadores <code>willSet</code> y <code>didSet</code> de <code>totalPasos</code> se llaman
siempre que se le asigna un nuevo valor a la propiedad. Esto es así
incluso si el nuevo valor es el mismo que el valor actual.</p>
<p>El observador <code>willSet</code> usa un parámetro definido por nosotros con el
nombre de <code>nuevoTotalPasos</code> para el valor que llega. En el ejemplo,
sencillamente imprime el valor que está a punto de establecer.</p>
<p>El observador <code>didSet</code> se llama después de que el valor de
<code>totalPasos</code> se ha actualizado. Compara el nuevo valor de <code>totalPasos</code>
con el valor antiguo. Si el número total de pasos se ha incrementado,
se imprime un mensaje indicando cuántos pasos se han tomado. El
observador <code>didSet</code> no proporciona un parámetro definido por nosotros
para el valor antiguo, sino que usa el nombre por defecto <code>oldValue</code>.</p>
<h3 id="variables-locales-y-globales">Variables locales y globales<a class="headerlink" href="#variables-locales-y-globales" title="Permanent link">&para;</a></h3>
<p>Las capacidades anteriores de propiedades calculadas y de observadores
también están disponibles para variables globales y locales.</p>
<p>El siguiente ejemplo muestra un ejemplo con una variable calculada a
partir de otras dos:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">var</span> <span class="nv">x</span> <span class="p">=</span> <span class="mi">10</span>  <span class="p">{</span>
   <span class="kr">didSet</span> <span class="p">{</span>
      <span class="bp">print</span><span class="p">(</span><span class="s">&quot;El nuevo valor: </span><span class="si">\(</span><span class="n">x</span><span class="si">)</span><span class="s"> y el valor antiguo: </span><span class="si">\(</span><span class="n">oldValue</span><span class="si">)</span><span class="s">&quot;</span><span class="p">)</span>
   <span class="p">}</span>
<span class="p">}</span>
<span class="kd">var</span> <span class="nv">y</span> <span class="p">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">x</span>
<span class="kd">var</span> <span class="nv">z</span> <span class="p">:</span> <span class="nb">Int</span> <span class="p">{</span>
   <span class="kr">get</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
   <span class="p">}</span>
   <span class="kr">set</span> <span class="p">{</span>
      <span class="n">x</span> <span class="p">=</span> <span class="n">newValue</span> <span class="o">/</span> <span class="mi">2</span>
      <span class="n">y</span> <span class="p">=</span> <span class="n">newValue</span> <span class="o">/</span> <span class="mi">2</span>
   <span class="p">}</span>
<span class="p">}</span>

<span class="bp">print</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
<span class="n">z</span> <span class="p">=</span> <span class="mi">100</span>
<span class="bp">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</td></tr></table>

<h3 id="propiedades-del-tipo">Propiedades del tipo<a class="headerlink" href="#propiedades-del-tipo" title="Permanent link">&para;</a></h3>
<p>Las propiedades de las instancias son propiedades que pertenecen a una
instancia de un tipo particular. Cada vez que creamos una nueva
instancia de ese tipo, tiene su propio conjunto de valores de
propiedades, separados de los de cualquier otra instancia.</p>
<p>Podemos definir también propiedades que pertenecen al tipo propiamente
dicho, no a ninguna de las instancias de ese tipo. Sólo habrá una
copia de estas propiedades, sea cual sea el número de instancias de
ese tipo que creemos. Estos tipos de propiedades se llaman propiedades
del tipo (<em>type propierties</em>). Se pueden definir en tanto en
estructuras, clases como en enumeraciones.</p>
<p>Las propiedades del tipo son útiles para definir valores que son
universales a todas las instancias de un tipo particular, como una
propiedad constante que todas las instancias pueden usar (como una
constante estática en C), o una propiedad variable que almacena un
valor que es global a todas las instancias de ese tipo (como una
variable estática en C).</p>
<p>Las propiedades del tipo almacenadas pueden ser variables o
constantes. Las propiedades del tipo calculadas se declaran siempre
como propiedades variables, de la misma forma que las propiedades
calculadas de instancias.</p>
<p>A diferencia de las propiedades almacenadas de instancias, debemos
siempre proporcionar un valor por defecto para las propiedades
almacenadas de tipo. Esto es debido a que el tipo por si mismo no
tiene un inicializador que pueda asignar un valor en tiempo de
inicialización.</p>
<p>En Swift, las propiedades del tipo se definen como parte de la
definición del tipo, dentro de las llaves del tipo. Las propiedades
del tipo toman valor en el ámbito del tipo. Para definir una propiedad
del tipo hay que usar la palabra clave <code>static</code>. Para propiedades de
tipo calculadas de clases, podemos usar en su lugar la palabra clave
<code>class</code> para permitir a las subclases que sobreescriban la
implementación de la superclase.</p>
<p>Las propiedades del tipo pueden ser también constantes (<code>let</code>) o
variables (<code>var</code>).</p>
<p>Ejemplo:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">struct</span> <span class="nc">UnaEstructura</span> <span class="p">{</span>
    <span class="kd">static</span> <span class="kd">var</span> <span class="nv">almacenada</span> <span class="p">=</span> <span class="s">&quot;A&quot;</span>
    <span class="kd">static</span> <span class="kd">var</span> <span class="nv">calculada</span> <span class="p">:</span> <span class="nb">Int</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">1</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kd">enum</span> <span class="nc">UnaEnumeracion</span> <span class="p">{</span>
    <span class="kd">static</span> <span class="kd">var</span> <span class="nv">almacenada</span> <span class="p">=</span> <span class="s">&quot;A&quot;</span>
    <span class="kd">static</span> <span class="kd">var</span> <span class="nv">calculada</span><span class="p">:</span> <span class="nb">Int</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">1</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kd">class</span> <span class="nc">UnaClase</span> <span class="p">{</span>
    <span class="kd">static</span> <span class="kd">var</span> <span class="nv">almacenada</span> <span class="p">=</span> <span class="s">&quot;A&quot;</span>
    <span class="kd">static</span> <span class="kd">var</span> <span class="nv">calculada</span><span class="p">:</span> <span class="nb">Int</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">1</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<p>Las propiedades del tipo se consultan y actualizan usando también la
sintaxis de punto, pero sobre <em>el tipo</em>:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">UnaEstructura</span><span class="p">.</span><span class="n">almacenada</span> <span class="c1">// devuelve &quot;A&quot;</span>
<span class="n">UnaEstructura</span><span class="p">.</span><span class="n">almacenada</span> <span class="p">=</span> <span class="s">&quot;B&quot;</span> 
<span class="n">UnaClase</span><span class="p">.</span><span class="n">calculada</span> <span class="c1">// devuelve 1</span>
</pre></div>
</td></tr></table>

<ul>
<li>No es posible acceder a la variable del tipo a través de una instancia:</li>
</ul>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">let</span> <span class="nv">a</span> <span class="p">=</span> <span class="n">UnaEstructura</span><span class="p">()</span>
<span class="n">a</span><span class="p">.</span><span class="n">almacenada</span> <span class="c1">// error</span>
</pre></div>
</td></tr></table>

<p>El siguiente ejemplo muestra cómo es posible usar una variable del
tipo para almacenar información global a todas las instancias de ese tipo:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">struct</span> <span class="nc">Valor</span> <span class="p">{</span>
   <span class="kd">var</span> <span class="nv">valor</span><span class="p">:</span> <span class="nb">Int</span> <span class="p">=</span> <span class="mi">0</span> <span class="p">{</span>
      <span class="kr">didSet</span> <span class="p">{</span>
         <span class="n">Valor</span><span class="p">.</span><span class="n">sumaValores</span> <span class="o">+=</span> <span class="n">valor</span>
      <span class="p">}</span>
   <span class="p">}</span>
   <span class="kd">static</span> <span class="kd">var</span> <span class="nv">sumaValores</span> <span class="p">=</span> <span class="mi">0</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nv">c1</span> <span class="p">=</span> <span class="n">Valor</span><span class="p">()</span>
<span class="kd">var</span> <span class="nv">c2</span> <span class="p">=</span> <span class="n">Valor</span><span class="p">()</span>
<span class="kd">var</span> <span class="nv">c3</span> <span class="p">=</span> <span class="n">Valor</span><span class="p">()</span>
<span class="n">c1</span><span class="p">.</span><span class="n">valor</span> <span class="p">=</span> <span class="mi">10</span>
<span class="n">c2</span><span class="p">.</span><span class="n">valor</span> <span class="p">=</span> <span class="mi">20</span>
<span class="n">c3</span><span class="p">.</span><span class="n">valor</span> <span class="p">=</span> <span class="mi">30</span>
<span class="bp">print</span><span class="p">(</span><span class="s">&quot;Suma de los cambios de valores: </span><span class="si">\(</span><span class="n">Valor</span><span class="p">.</span><span class="n">sumaValores</span><span class="si">)</span><span class="s">&quot;</span><span class="p">)</span>
<span class="c1">// Imprime 60</span>
</pre></div>
</td></tr></table>

<h2 id="metodos">Métodos<a class="headerlink" href="#metodos" title="Permanent link">&para;</a></h2>
<p>Los <em>métodos</em> son funciones que están asociadas a un tipo
particular. Las clases, estructuras y enumeraciones pueden definir
todas ellas métodos de instancia, que encapsulan tareas y
funcionalidades específicas que trabajan con una instancia de un tipo
dado. Las clases, estructuras y enumeraciones también pueden definir
métodos del tipo, que están asociados con el propio tipo. Los métodos
del tipo son similares a los métodos de clase en Java.</p>
<p>El hecho de que las estructuras y las enumeraciones puedan definir
métodos en Swift es una diferencia importante con C y Objective-C.</p>
<h3 id="metodos-de-instancia">Métodos de instancia<a class="headerlink" href="#metodos-de-instancia" title="Permanent link">&para;</a></h3>
<p>Los métodos de instancia son funciones que pertenecen a instancias de
una clase, estructura o enumeración. Proporcionan la funcionalidad de
esas instancias, bien proporcionando formas de acceder y modificar
propiedades de las instancias, o bien proporcionando funcionalidades
relacionadas con el propósito de la instancia. Los métodos de
instancia tienen exactamente la misma sintaxis que las funciones.</p>
<p>Los métodos de instancia se escriben dentro de las llaves del tipo al
que pertenecen. Un método de instancia tiene acceso implícito a todos
los otros métodos de instancia y propiedades del tipo. Un método de
instancia puede ser invocado sólo sobre una instancia específica del
tipo al que pertenece. No puede ser invocado de forma aislada sin una
instancia existente.</p>
<p>A continuación podemos ver un ejemplo que define una sencilla clase
<code>Contador</code>, que puede usarse para contar el número de veces que sucede
una acción:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">class</span> <span class="nc">Contador</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">veces</span> <span class="p">=</span> <span class="mi">0</span>
    <span class="kd">func</span> <span class="nf">incrementa</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">veces</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="p">}</span>
    <span class="kd">func</span> <span class="nf">incrementa</span><span class="p">(</span><span class="n">en</span> <span class="n">cantidad</span><span class="p">:</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">veces</span> <span class="o">+=</span> <span class="n">cantidad</span>
    <span class="p">}</span>
    <span class="kd">func</span> <span class="nf">reset</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">veces</span> <span class="p">=</span> <span class="mi">0</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<p>Y un ejemplo de uso:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">let</span> <span class="nv">contador</span> <span class="p">=</span> <span class="n">Contador</span><span class="p">()</span>
<span class="c1">// el valor inicial del contador es 0</span>
<span class="n">contador</span><span class="p">.</span><span class="n">incrementa</span><span class="p">()</span>
<span class="c1">// el valor del contador es ahora 1</span>
<span class="n">contador</span><span class="p">.</span><span class="n">incrementa</span><span class="p">(</span><span class="n">en</span><span class="p">:</span> <span class="mi">5</span><span class="p">)</span>
<span class="c1">// el valor del contador es ahora 6</span>
<span class="n">contador</span><span class="p">.</span><span class="n">reset</span><span class="p">()</span>
<span class="c1">// el valor del contador es ahora 0</span>
</pre></div>
</td></tr></table>

<p>En el ejemplo anterior, los métodos no devuelven ningún
valor. Podemos modificar el ejemplo para que los métodos
devuelvan el valor actualizado del contador:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">class</span> <span class="nc">Contador</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">veces</span> <span class="p">=</span> <span class="mi">0</span>
    <span class="kd">func</span> <span class="nf">incrementa</span><span class="p">()</span> <span class="p">-&gt;</span> <span class="nb">Int</span> <span class="p">{</span>
        <span class="n">veces</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">veces</span>
    <span class="p">}</span>
    <span class="kd">func</span> <span class="nf">incrementa</span><span class="p">(</span><span class="n">en</span> <span class="n">cantidad</span><span class="p">:</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Int</span> <span class="p">{</span>
        <span class="n">veces</span> <span class="o">+=</span> <span class="n">cantidad</span>
        <span class="k">return</span> <span class="n">veces</span>
    <span class="p">}</span>
    <span class="kd">func</span> <span class="nf">reset</span><span class="p">()</span> <span class="p">-&gt;</span> <span class="nb">Int</span> <span class="p">{</span>
        <span class="n">veces</span> <span class="p">=</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="n">veces</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<h3 id="nombres-locales-y-externos-de-parametros">Nombres locales y externos de parámetros<a class="headerlink" href="#nombres-locales-y-externos-de-parametros" title="Permanent link">&para;</a></h3>
<p>Ya vimos que los parámetros de las funciones pueden tener un nombre
interno y un nombre externo. Lo mismo sucede con los métodos, porque
los métodos no son más que funciones asociadas con un tipo.</p>
<p>Los nombres de los métodos en Swift se refieren normalmente al primer
parámetro usando una preposición como <code>con</code>, <code>en</code>, <code>a</code> o <code>por</code>, como
hemos visto en el ejemplo anterior <code>incrementa(en:)</code>. El uso de la
preposición permite que el método se lea como una frase.</p>
<p>El nombre de una parámetro se utiliza también como etiqueta del
argumento (nombre externo). Al igual que en las funciones, es posible
definir dos nombres del parámetro, uno externo y otro interno. Y el
nombre externo puede ser un <code>_</code> para indicar que no es necesario usar
la etiqueta del argumento.</p>
<p>Esta forma de invocar a los métodos hace que el lenguaje sea más
expresivo, sin necesidad de nombres largos de métodos o funciones.</p>
<p>Consideremos por ejemplo esta versión alternativa de la clase
<code>Contador</code>, que define una forma más compleja del método
<code>incrementa(en:)</code>:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">class</span> <span class="nc">Contador</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">valor</span><span class="p">:</span> <span class="nb">Int</span> <span class="p">=</span> <span class="mi">0</span>
    <span class="kd">func</span> <span class="nf">incrementa</span><span class="p">(</span><span class="n">en</span> <span class="n">cantidad</span><span class="p">:</span> <span class="nb">Int</span><span class="p">,</span> <span class="n">numeroDeVeces</span><span class="p">:</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">valor</span> <span class="o">+=</span> <span class="n">cantidad</span> <span class="o">*</span> <span class="n">numeroDeVeces</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<p>El método <code>incrementa(en:numeroDeVeces:)</code> tiene dos parámetros:
<code>cantidad</code> y <code>numeroDeVeces</code>. El primer parámetro tiene un nombre
externo y otro interno. En el cuerpo del método se utiliza el nombre
interno (<code>cantidad</code>). El segundo parámetro <code>numeroDeVeces</code> es tanto
nombre externo como interno. Podemos llamar al método de la siguiente
forma:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">let</span> <span class="nv">contador</span> <span class="p">=</span> <span class="n">Contador</span><span class="p">()</span>
<span class="n">contador</span><span class="p">.</span><span class="n">incrementa</span><span class="p">(</span><span class="n">en</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span> <span class="n">numeroDeVeces</span><span class="p">:</span> <span class="mi">3</span><span class="p">)</span>
<span class="c1">// el valor del contador es ahora 15</span>
</pre></div>
</td></tr></table>

<p>Al igual que en las funciones, podemos definir explícitamente los
nombres externos de los parámetros y usar el subrayado (<code>_</code>) para
indicar que ese parámetro no tendrá nombre externo.</p>
<h3 id="la-propiedad-self">La propiedad <code>self</code><a class="headerlink" href="#la-propiedad-self" title="Permanent link">&para;</a></h3>
<p>Toda instancia de un tipo tiene una propiedad implícita llamada
<code>self</code>, que es exactamente equivalente a la instancia misma. Podemos
usar la propiedad <code>self</code> para referirnos a la instancia actual dentro
de sus propios métodos de instancia.</p>
<p>El método <code>incrementa()</code> en el ejemplo anterior podría haberse escrito
de esta forma:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">func</span> <span class="nf">incrementa</span><span class="p">()</span> <span class="p">{</span>
    <span class="kc">self</span><span class="p">.</span><span class="n">veces</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<p>En la práctica no es necesario usar <code>self</code> casi nunca. Swift asume que
cualquier referencia a una propiedad dentro de un método se refiere a
la propiedad de la instancia. Es obligado usarlo es cuando el nombre
de la propiedad coincide con el nombre de un parámetro. En esta
situación el nombre del parámetro toma precedencia y es necesario usar
<code>self</code> para poder referirse a la propiedad de la instancia.</p>
<p>Un ejemplo:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">struct</span> <span class="nc">Punto</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">x</span> <span class="p">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">y</span> <span class="p">=</span> <span class="mf">0.0</span>
    <span class="kd">func</span> <span class="nf">estaAlaDerecha</span><span class="p">(</span><span class="n">de</span> <span class="n">x</span><span class="p">:</span> <span class="nb">Double</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Bool</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kc">self</span><span class="p">.</span><span class="n">x</span> <span class="o">&gt;</span> <span class="n">x</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kd">let</span> <span class="nv">unPunto</span> <span class="p">=</span> <span class="n">Punto</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="mf">4.0</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="mf">5.0</span><span class="p">)</span>
<span class="k">if</span> <span class="n">unPunto</span><span class="p">.</span><span class="n">estaAlaDerecha</span><span class="p">(</span><span class="n">de</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">)</span> <span class="p">{</span>
    <span class="bp">print</span><span class="p">(</span><span class="s">&quot;Este punto está a la derecha de la línea donde x == 1.0&quot;</span><span class="p">)</span>
<span class="p">}</span>
<span class="c1">// Imprime &quot;Este punto está a la derecha de la línea donde x == 1.0&quot;</span>
</pre></div>
</td></tr></table>

<h3 id="operaciones-con-instancias-de-tipo-valor">Operaciones con instancias de tipo valor<a class="headerlink" href="#operaciones-con-instancias-de-tipo-valor" title="Permanent link">&para;</a></h3>
<p>Las estructuras y las enumeraciones son <strong>tipos valor</strong>. Por defecto,
las propiedades de un tipo valor no pueden ser modificadas desde
dentro de los métodos de instancia.</p>
<p>Si queremos modificar una propiedad de un tipo valor la forma más
natural de hacerlo es creando una instancia nueva, usando el estilo de 
programación funcional:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">struct</span> <span class="nc">Punto</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">x</span> <span class="p">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">y</span> <span class="p">=</span> <span class="mf">0.0</span>
    <span class="kd">func</span> <span class="nf">incrementa</span><span class="p">(</span><span class="n">incX</span><span class="p">:</span> <span class="nb">Double</span><span class="p">,</span> <span class="n">incY</span><span class="p">:</span> <span class="nb">Double</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">Punto</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">Punto</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">+</span><span class="n">incX</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">y</span><span class="o">+</span><span class="n">incY</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kd">let</span> <span class="nv">unPunto</span> <span class="p">=</span> <span class="n">Punto</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">)</span>
<span class="kd">var</span> <span class="nv">puntoMovido</span> <span class="p">=</span> <span class="n">unPunto</span><span class="p">.</span><span class="n">incrementa</span><span class="p">(</span><span class="n">incX</span><span class="p">:</span> <span class="mf">2.0</span><span class="p">,</span> <span class="n">incY</span><span class="p">:</span> <span class="mf">3.0</span><span class="p">)</span>
<span class="bp">print</span><span class="p">(</span><span class="s">&quot;Hemos movido el punto a (</span><span class="si">\(</span><span class="n">puntoMovido</span><span class="p">.</span><span class="n">x</span><span class="si">)</span><span class="s">, </span><span class="si">\(</span><span class="n">puntoMovido</span><span class="p">.</span><span class="n">y</span><span class="si">)</span><span class="s">)&quot;</span><span class="p">)</span>
<span class="c1">// Imprime &quot;Hemos movido el punto a (3.0, 4.0)&quot;</span>
</pre></div>
</td></tr></table>

<h3 id="modificacion-de-tipos-valor-desde-dentro-de-la-instancia">Modificación de tipos valor desde dentro de la instancia<a class="headerlink" href="#modificacion-de-tipos-valor-desde-dentro-de-la-instancia" title="Permanent link">&para;</a></h3>
<p>Sin embargo, hay ocasiones en las que necesitamos modificar las
propiedades de nuestra estructura o enumeración dentro de un método
particular. </p>
<p>Necesitamos conseguir una conducta <em>mutadora</em> para ese método. El
método puede mutar (esto es, cambiar) sus propiedades desde dentro del
método, así como asignar una instancia completamente nueva a su
propiedad implícita <code>self</code>, con lo que esta nueva instancia
reemplazará la existente cuando el método termine.</p>
<p>Podemos conseguir esta conducta colocando la palabra clave <code>mutating</code>
antes de la palabra <code>func</code> del método:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">struct</span> <span class="nc">Punto</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">x</span> <span class="p">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">y</span> <span class="p">=</span> <span class="mf">0.0</span>
    <span class="kr">mutating</span> <span class="kd">func</span> <span class="nf">incrementado</span><span class="p">(</span><span class="n">incX</span><span class="p">:</span> <span class="nb">Double</span><span class="p">,</span> <span class="n">incY</span><span class="p">:</span> <span class="nb">Double</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">x</span> <span class="o">+=</span> <span class="n">incX</span>
        <span class="n">y</span> <span class="o">+=</span> <span class="n">incY</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kd">var</span> <span class="nv">unPunto</span> <span class="p">=</span> <span class="n">Punto</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">)</span>
<span class="n">unPunto</span><span class="p">.</span><span class="n">incrementado</span><span class="p">(</span><span class="n">incX</span><span class="p">:</span> <span class="mf">2.0</span><span class="p">,</span> <span class="n">incY</span><span class="p">:</span> <span class="mf">3.0</span><span class="p">)</span>
<span class="bp">print</span><span class="p">(</span><span class="s">&quot;El punto está ahora en (</span><span class="si">\(</span><span class="n">unPunto</span><span class="p">.</span><span class="n">x</span><span class="si">)</span><span class="s">, </span><span class="si">\(</span><span class="n">unPunto</span><span class="p">.</span><span class="n">y</span><span class="si">)</span><span class="s">)&quot;</span><span class="p">)</span>
<span class="c1">// Imprime &quot;El punto está ahora en (3.0, 4.0)&quot;</span>
</pre></div>
</td></tr></table>

<p>La estructura <code>Punto</code> anterior define un método mutador
<code>incrementado(incX:incY:)</code> que mueve una instancia de <code>Punto</code> una cierta
cantidad. En lugar de devolver un nuevo punto, el método modifica
realmente el punto en el que es llamado. La palabra clave <code>mutating</code>
se añade a su definición para permitirle modificar sus propiedades.</p>
<p>Hay que hacer notar que no es posible llamar a un método mutador sobre
una constante de un tipo estructura, porque sus propiedades no se
pueden cambiar, incluso aunque sean propiedades variables:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">let</span> <span class="nv">puntoFijo</span> <span class="p">=</span> <span class="n">Punto</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="mf">3.0</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="mf">3.0</span><span class="p">)</span>
<span class="n">puntoFijo</span><span class="p">.</span><span class="n">incrementado</span><span class="p">(</span><span class="n">incX</span><span class="p">:</span> <span class="mf">2.0</span><span class="p">,</span> <span class="n">incY</span><span class="p">:</span> <span class="mf">3.0</span><span class="p">)</span>
<span class="c1">// esto provocará un error</span>
</pre></div>
</td></tr></table>

<h3 id="asignacion-a-self-en-un-metodo-mutador">Asignación a <code>self</code> en un método mutador<a class="headerlink" href="#asignacion-a-self-en-un-metodo-mutador" title="Permanent link">&para;</a></h3>
<p>Los métodos mutadores pueden asignar una nueva instancia completamente
nueva a la propiedad <code>self</code>. El anterior ejemplo <code>Punto</code> podría habers
escrito de la siguiente forma:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">struct</span> <span class="nc">Punto</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">x</span> <span class="p">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">y</span> <span class="p">=</span> <span class="mf">0.0</span>
    <span class="kr">mutating</span> <span class="kd">func</span> <span class="nf">incrementa</span><span class="p">(</span><span class="n">incX</span><span class="p">:</span> <span class="nb">Double</span><span class="p">,</span> <span class="n">incY</span><span class="p">:</span> <span class="nb">Double</span><span class="p">)</span> <span class="p">{</span>
        <span class="kc">self</span> <span class="p">=</span> <span class="n">Punto</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">+</span> <span class="n">incX</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">y</span> <span class="o">+</span> <span class="n">incY</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<p>Esta versión del método mutador <code>incrementa(incX:incY:)</code> crea una
estructura nueva cuyos valores <code>x</code> e <code>y</code> se inicializan a los valores
desados. El resutado final de llamar a esta versión alternativa será
exactamente el mismo que llamar a la versión anterior (aunque con una
pequeña penalización de eficiencia: este método es 1,3 veces más lento
que el anterior en la versión 2.2 del compilador de Swift).</p>
<p>Los métodos mutadores de enumeraciones pueden establecer el parámetro
<code>self</code> implícito para que tenga un subtipo distinto de la misma
enumeración:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">enum</span> <span class="nc">InterruptorTriEstado</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">apagado</span><span class="p">,</span> <span class="n">medio</span><span class="p">,</span> <span class="n">alto</span>
    <span class="kr">mutating</span> <span class="kd">func</span> <span class="nf">siguiente</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">switch</span> <span class="kc">self</span> <span class="p">{</span>
        <span class="k">case</span> <span class="p">.</span><span class="n">apagado</span><span class="p">:</span>
            <span class="kc">self</span> <span class="p">=</span> <span class="p">.</span><span class="n">medio</span>
        <span class="k">case</span> <span class="p">.</span><span class="n">medio</span><span class="p">:</span>
            <span class="kc">self</span> <span class="p">=</span> <span class="p">.</span><span class="n">alto</span>
        <span class="k">case</span> <span class="p">.</span><span class="n">alto</span><span class="p">:</span>
            <span class="kc">self</span> <span class="p">=</span> <span class="p">.</span><span class="n">apagado</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kd">var</span> <span class="nv">luzHorno</span> <span class="p">=</span> <span class="n">InterruptorTriEstado</span><span class="p">.</span><span class="n">medio</span>
<span class="n">luzHorno</span><span class="p">.</span><span class="n">siguiente</span><span class="p">()</span>
<span class="c1">// luzHorno es ahora .alto</span>
<span class="n">luzHorno</span><span class="p">.</span><span class="n">siguiente</span><span class="p">()</span>
<span class="c1">// luzHorno es ahora .apagado</span>
</pre></div>
</td></tr></table>

<h3 id="metodos-del-tipo">Métodos del tipo<a class="headerlink" href="#metodos-del-tipo" title="Permanent link">&para;</a></h3>
<p>Los métodos de instancia, como los descritos antes, se llaman en
instancias de un tipo particular. Es posible también definir métodos
que se llaman en el propio tipo. Esta clase de métodos se denominan
<em>métodos del tipo</em>. Se define un método del tipo escribiendo la
palabra clave <code>static</code> antes de la palabra clave <code>func</code> del
método. Las clases también pueden usar la palabra clave <code>class</code> para
permitir a las subclases sobreescribir la implementación del método.</p>
<p>Los métodos del tipo se invocan también con la sintaxis de punto,
escribiendo el nombre del tipo. Por ejemplo:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">class</span> <span class="nc">NuevaClase</span> <span class="p">{</span>
    <span class="kd">static</span> <span class="kd">func</span> <span class="nf">unMetodoDelTipo</span><span class="p">()</span> <span class="p">{</span>
        <span class="bp">print</span><span class="p">(</span><span class="s">&quot;Hola desde el tipo&quot;</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="n">NuevaClase</span><span class="p">.</span><span class="n">unMetodoDelTipo</span><span class="p">()</span>
</pre></div>
</td></tr></table>

<p>Dentro del cuerpo del método, la propiedad implícita <code>self</code> se refiere
al propio tipo, más que a una instancia de ese tipo. Para estructuras
y enumeraciones, esto significa que puedes usar <code>self</code> para
desambiguar entre propiedades del tipo y los parámetros del método, de
la misma forma que se hace en los métodos de instancias.</p>
<p>Cualquier nombre de método o propiedad que se utilice en el cuerpo de
un método del tipo se referirá a otras propiedades o métodos de nivel
del tipo. Se puede utilizar estos nombres sin necesidad de añadir el
prefijo del nombre del tipo.</p>
<p>Por ejemplo, podemos añadir a la clase <code>Ventana</code> una propiedad
y método de clase con la que almacenar instancias de ventanas. Inicialmente
guardamos un array vacío.</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">class</span> <span class="nc">Ventana</span> <span class="p">{</span>

    <span class="c1">// Propiedades</span>


    <span class="kd">static</span> <span class="kd">var</span> <span class="nv">ventanas</span><span class="p">:</span> <span class="p">[</span><span class="n">Ventana</span><span class="p">]</span> <span class="p">=</span> <span class="p">[]</span>
    <span class="kd">static</span> <span class="kd">func</span> <span class="nf">registrar</span><span class="p">(</span><span class="n">ventana</span><span class="p">:</span> <span class="n">Ventana</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">ventanas</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">ventana</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<p>Cada vez que creamos una ventana podemos llamar al método <code>registrar</code>
de la clase para añadirlo a la colección de ventanas de la clase:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">let</span> <span class="nv">v1</span> <span class="p">=</span> <span class="n">Ventana</span><span class="p">()</span>
<span class="n">Ventana</span><span class="p">.</span><span class="n">registrar</span><span class="p">(</span><span class="n">ventana</span><span class="p">:</span> <span class="n">v1</span><span class="p">)</span>
<span class="bp">print</span><span class="p">(</span><span class="s">&quot;Se han registrado </span><span class="si">\(</span><span class="n">Ventana</span><span class="p">.</span><span class="n">ventanas</span><span class="p">.</span><span class="bp">count</span><span class="si">)</span><span class="s"> ventanas&quot;</span><span class="p">)</span>
<span class="c1">// Imprime &quot;Se han registrado 1 ventanas&quot;</span>
</pre></div>
</td></tr></table>

<h2 id="inicializacion">Inicialización<a class="headerlink" href="#inicializacion" title="Permanent link">&para;</a></h2>
<p><em>Inicialización</em> es el proceso de preparar para su uso una instancia
de una clase, estructura o enumeración. Este proceso incluye la
asignación de un valor inicial para cada propiedad almacenada y la
ejecución de cualquier otra operación de inicialización que se
necesite para que la nueva instancia esté lista para usarse.</p>
<p>Para implementar este proceso de inicialización hay que definir
<em>inicializadores</em>, que son como métodos especiales que pueden llamarse
para crear una nueva instancia de un tipo particular. A diferencia de
otros lenguajes, los inicializadores en Swift no devuelven un
valor. Su papel principal es que las nuevas instancias del tipo estén
correctamente inicializadas antes de poder ser usadas por primera vez.</p>
<p>También es posible implementar <em>deinicializadores</em>, métodos que se
ejecutan cuando las instancias son eliminadas de la memoria (no vamos
a explicarlos por falta de tiempo).</p>
<p>El proceso de inicialización de una instancia puede resultar un
proceso complicado, sobre todo cuando se tienen relaciones de herencia
y hay que especificar también cómo realizar la inicialización de la
subclase utilizando la superclase. Por falta de tiempo no vamos a
explicar todo el proceso completo. Recomendamos consultar la
<a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Initialization.html#//apple_ref/doc/uid/TP40014097-CH18-ID203">documentación original de Swift</a>.</p>
<h3 id="inicializadores-por-defecto-y-memberwise">Inicializadores por defecto y <em>memberwise</em><a class="headerlink" href="#inicializadores-por-defecto-y-memberwise" title="Permanent link">&para;</a></h3>
<p>Ya hemos visto que es posible inicializar clases y estructuras
definiendo valores por defecto a todas sus propiedades (con la posible
excepción de las que tienen un tipo opcional). En ese caso, podemos no
definir ningún inicializador y usar el inicializador por defecto que
proporciona Swift.</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">struct</span> <span class="nc">Punto2D</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">x</span> <span class="p">=</span> <span class="mf">0.0</span>
    <span class="kd">var</span> <span class="nv">y</span> <span class="p">=</span> <span class="mf">0.0</span>
<span class="p">}</span>
<span class="kd">class</span> <span class="nc">Segmento</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">p1</span> <span class="p">=</span> <span class="n">Punto2D</span><span class="p">()</span>
    <span class="kd">var</span> <span class="nv">p2</span> <span class="p">=</span> <span class="n">Punto2D</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nv">s</span> <span class="p">=</span> <span class="n">Segmento</span><span class="p">()</span>
</pre></div>
</td></tr></table>

<p>También es posible en las estructuras utilizar el inicializador
<em>memberwise</em>, en el que especificamos todos los valores de las
propiedades:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">var</span> <span class="nv">p</span> <span class="p">=</span> <span class="n">Punto2D</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="mf">10.0</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="mf">10.0</span><span class="p">)</span>
</pre></div>
</td></tr></table>

<p>Los inicializadores por defecto y <em>memberwise</em> desaparecen en el
momento en que definimos algún inicializador con la palabra
<code>init</code>. Veamos cómo definir inicializadores.</p>
<h3 id="inicializacion-de-propiedades-almacenadas">Inicialización de propiedades almacenadas<a class="headerlink" href="#inicializacion-de-propiedades-almacenadas" title="Permanent link">&para;</a></h3>
<p>Como hemos dicho, las clases y estructuras deben definir todas sus
propiedades almacenadas a un valor inicial en el tiempo en la
instancia se crea, a no ser que éstas sean opcionales, en cuyo caso
quedarían inicializadas a <code>nil</code>.</p>
<p>Podemos definir el valor inicial para una propiedad en un
inicializador o asignándole un valor por defecto como parte de la
definición de la propiedad.</p>
<p>Un <em>inicializador</em>, en su forma más simple se escribe con la palabra
clave <code>init</code>:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">init</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// realizar alguna inicialización aquí</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<p>Por ejemplo, podemos definir la estructura <code>Farenheit</code> que almacena
una temperatura en grados Farenheit. Tiene una propiedad almacenada de
tipo <code>Double</code>. Definimos un inicializador que inicializa las
instancias a 32.0 (equivalente a 0.0 grados Celsius).</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">struct</span> <span class="nc">Fahrenheit</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">temperatura</span><span class="p">:</span> <span class="nb">Double</span>
    <span class="kd">init</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">temperatura</span> <span class="p">=</span> <span class="mf">32.0</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kd">var</span> <span class="nv">f</span> <span class="p">=</span> <span class="n">Fahrenheit</span><span class="p">()</span>
<span class="bp">print</span><span class="p">(</span><span class="s">&quot;La temperatura por defecto es </span><span class="si">\(</span><span class="n">f</span><span class="p">.</span><span class="n">temperatura</span><span class="si">)</span><span class="s"> Fahrenheit&quot;</span><span class="p">)</span>
<span class="c1">// Imprime &quot;La temperatura por defecto es 32.0° Fahrenheit&quot;</span>
</pre></div>
</td></tr></table>

<p>La implementación anterior es equivalente a la que ya hemos visto con
el inicializador por defecto:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">struct</span> <span class="nc">Fahrenheit</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">temperatura</span> <span class="p">=</span> <span class="mf">32.0</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<h3 id="inicializadores-personalizados">Inicializadores personalizados<a class="headerlink" href="#inicializadores-personalizados" title="Permanent link">&para;</a></h3>
<p>Podemos proporcionar parámetros de inicialización como parte de la
definición de un inicializador, para definir los tipos y los nombres
de los valores que personalizan el proceso de inicialización. Los
parámetros de inicialización tienen las mismas capacidades y sintaxis
que los parámetros de funciones y métodos.</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">struct</span> <span class="nc">Celsius</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">temperaturaEnCelsius</span><span class="p">:</span> <span class="nb">Double</span>
    <span class="kd">init</span><span class="p">(</span><span class="n">desdeFahrenheit</span> <span class="n">fahrenheit</span><span class="p">:</span> <span class="nb">Double</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">temperaturaEnCelsius</span> <span class="p">=</span> <span class="p">(</span><span class="n">fahrenheit</span> <span class="o">-</span> <span class="mf">32.0</span><span class="p">)</span> <span class="o">/</span> <span class="mf">1.8</span>
    <span class="p">}</span>
    <span class="kd">init</span><span class="p">(</span><span class="n">desdeKelvin</span> <span class="n">kelvin</span><span class="p">:</span> <span class="nb">Double</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">temperaturaEnCelsius</span> <span class="p">=</span> <span class="n">kelvin</span> <span class="o">-</span> <span class="mf">273.15</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nv">puntoDeEbullicionDelAgua</span> <span class="p">=</span> <span class="n">Celsius</span><span class="p">(</span><span class="n">desdeFahrenheit</span><span class="p">:</span> <span class="mf">212.0</span><span class="p">)</span>
<span class="c1">// puntoDeEbullicionDelAgua.temperaturaEnCelsius es 100.0</span>
<span class="kd">let</span> <span class="nv">puntoDeCongelacionDelAgua</span> <span class="p">=</span> <span class="n">Celsius</span><span class="p">(</span><span class="n">desdeKelvin</span><span class="p">:</span> <span class="mf">273.15</span><span class="p">)</span>
<span class="c1">// puntoDeCongelacionDelAgua.temperaturaEnCelsius is 0.0</span>
</pre></div>
</td></tr></table>

<p>Vemos que dependiendo del nombre de parámetro proporcionado se escoge
un inicializador u otro. En los inicializadores es obligatorio
proporcionar los nombres de todos los parámetros:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">struct</span> <span class="nc">Color</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nv">rojo</span><span class="p">,</span> <span class="n">verde</span><span class="p">,</span> <span class="n">azul</span><span class="p">:</span> <span class="nb">Double</span>
    <span class="kd">init</span><span class="p">(</span><span class="n">rojo</span><span class="p">:</span> <span class="nb">Double</span><span class="p">,</span> <span class="n">verde</span><span class="p">:</span> <span class="nb">Double</span><span class="p">,</span> <span class="n">azul</span><span class="p">:</span> <span class="nb">Double</span><span class="p">)</span> <span class="p">{</span>
        <span class="kc">self</span><span class="p">.</span><span class="n">rojo</span>   <span class="p">=</span> <span class="n">rojo</span>
        <span class="kc">self</span><span class="p">.</span><span class="n">verde</span> <span class="p">=</span> <span class="n">verde</span>
        <span class="kc">self</span><span class="p">.</span><span class="n">azul</span>  <span class="p">=</span> <span class="n">azul</span>
    <span class="p">}</span>
    <span class="kd">init</span><span class="p">(</span><span class="n">blanco</span><span class="p">:</span> <span class="nb">Double</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">rojo</span>  <span class="p">=</span> <span class="n">blanco</span>
        <span class="n">verde</span> <span class="p">=</span> <span class="n">blanco</span>
        <span class="n">azul</span>  <span class="p">=</span> <span class="n">blanco</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kd">let</span> <span class="nv">magenta</span> <span class="p">=</span> <span class="n">Color</span><span class="p">(</span><span class="n">rojo</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">verde</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">azul</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">)</span>
<span class="kd">let</span> <span class="nv">medioGris</span> <span class="p">=</span> <span class="n">Color</span><span class="p">(</span><span class="n">blanco</span><span class="p">:</span> <span class="mf">0.5</span><span class="p">)</span>
</pre></div>
</td></tr></table>

<p>Podemos evitar proporcionar nombres externos usando un subrayado. Por
ejemplo, podemos añadir al struct anterior <code>Celsius</code> un inicializador
sin nombre externo para el caso en que pasemos la temperatura inicial
precisamente en Celsius:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">struct</span> <span class="nc">Celsius</span> <span class="p">{</span>
   <span class="kd">var</span> <span class="nv">temperaturaEnCelsius</span><span class="p">:</span> <span class="nb">Double</span>
   <span class="kd">init</span><span class="p">(</span><span class="n">desdeFahrenheit</span> <span class="n">fahrenheit</span><span class="p">:</span> <span class="nb">Double</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">temperaturaEnCelsius</span> <span class="p">=</span> <span class="p">(</span><span class="n">fahrenheit</span> <span class="o">-</span> <span class="mf">32.0</span><span class="p">)</span> <span class="o">/</span> <span class="mf">1.8</span>
   <span class="p">}</span>
   <span class="kd">init</span><span class="p">(</span><span class="n">desdeKelvin</span> <span class="n">kelvin</span><span class="p">:</span> <span class="nb">Double</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">temperaturaEnCelsius</span> <span class="p">=</span> <span class="n">kelvin</span> <span class="o">-</span> <span class="mf">273.15</span>
   <span class="p">}</span>
   <span class="kd">init</span><span class="p">(</span><span class="kc">_</span> <span class="n">celsius</span><span class="p">:</span> <span class="nb">Double</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">temperaturaEnCelsius</span> <span class="p">=</span> <span class="n">celsius</span>
   <span class="p">}</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nv">temperaturaCuerpo</span> <span class="p">=</span> <span class="n">Celsius</span><span class="p">(</span><span class="mf">37.0</span><span class="p">)</span>
<span class="c1">// temperaturaCuerpo.temperaturaEnCelsius es 37.0</span>
</pre></div>
</td></tr></table>

<p>Por último, es posible inicializar propiedades constantes definidas
con <code>let</code>. Sólo toman valor en el momento de la inicialización y
después no pueden modificarse.</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">class</span> <span class="nc">PreguntaEncuesta</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nv">texto</span><span class="p">:</span> <span class="nb">String</span>
    <span class="kd">var</span> <span class="nv">respuesta</span><span class="p">:</span> <span class="nb">String</span><span class="p">?</span>
    <span class="kd">init</span><span class="p">(</span><span class="n">texto</span><span class="p">:</span> <span class="nb">String</span><span class="p">)</span> <span class="p">{</span>
        <span class="kc">self</span><span class="p">.</span><span class="n">texto</span> <span class="p">=</span> <span class="n">texto</span>
    <span class="p">}</span>
    <span class="kd">func</span> <span class="nf">pregunta</span><span class="p">()</span> <span class="p">{</span>
        <span class="bp">print</span><span class="p">(</span><span class="n">texto</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kd">let</span> <span class="nv">preguntaQueso</span> <span class="p">=</span> <span class="n">PreguntaEncuesta</span><span class="p">(</span><span class="n">texto</span><span class="p">:</span> <span class="s">&quot;¿Te gusta el queso?&quot;</span><span class="p">)</span>
<span class="n">preguntaQueso</span><span class="p">.</span><span class="n">pregunta</span><span class="p">()</span> <span class="c1">// -&gt; &quot;¿Te gusta el queso?</span>
<span class="n">preguntaQueso</span><span class="p">.</span><span class="n">respuesta</span> <span class="c1">// -&gt; nil</span>
</pre></div>
</td></tr></table>

<p>La propiedad <code>respuesta</code> se inicializa a <code>nil</code> al ser un opcional y no
inicializarla en el inicializador.</p>
<p>Por último, es posible definir más de un inicializador, así como
invocar a inicializadores más básicos desde otros. </p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">struct</span> <span class="nc">Rectangulo</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">origen</span> <span class="p">=</span> <span class="n">Punto</span><span class="p">()</span>
    <span class="kd">var</span> <span class="nv">tamaño</span> <span class="p">=</span> <span class="n">Tamaño</span><span class="p">()</span>
    <span class="kd">init</span><span class="p">(){}</span>
    <span class="kd">init</span><span class="p">(</span><span class="n">origen</span><span class="p">:</span> <span class="n">Punto</span><span class="p">,</span> <span class="n">tamaño</span><span class="p">:</span> <span class="n">Tamaño</span><span class="p">)</span> <span class="p">{</span>
        <span class="kc">self</span><span class="p">.</span><span class="n">origen</span> <span class="p">=</span> <span class="n">origen</span>
        <span class="kc">self</span><span class="p">.</span><span class="n">tamaño</span> <span class="p">=</span> <span class="n">tamaño</span>
    <span class="p">}</span>
    <span class="kd">init</span><span class="p">(</span><span class="n">centro</span><span class="p">:</span> <span class="n">Punto</span><span class="p">,</span> <span class="n">tamaño</span><span class="p">:</span> <span class="n">Tamaño</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">let</span> <span class="nv">origenX</span> <span class="p">=</span> <span class="n">centro</span><span class="p">.</span><span class="n">x</span> <span class="o">-</span> <span class="p">(</span><span class="n">tamaño</span><span class="p">.</span><span class="n">ancho</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
        <span class="kd">let</span> <span class="nv">origenY</span> <span class="p">=</span> <span class="n">centro</span><span class="p">.</span><span class="n">y</span> <span class="o">-</span> <span class="p">(</span><span class="n">tamaño</span><span class="p">.</span><span class="n">ancho</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
        <span class="kc">self</span><span class="p">.</span><span class="kd">init</span><span class="p">(</span><span class="n">origen</span><span class="p">:</span> <span class="n">Punto</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">origenX</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">origenY</span><span class="p">),</span> <span class="n">tamaño</span><span class="p">:</span> <span class="n">tamaño</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kd">let</span> <span class="nv">basicRectangulo</span> <span class="p">=</span> <span class="n">Rectangulo</span><span class="p">()</span>
<span class="c1">// el origen de basicRectangulo es (0.0, 0.0) y su tamaño (0.0, 0.0)</span>
<span class="kd">let</span> <span class="nv">origenRectangulo</span> <span class="p">=</span> <span class="n">Rectangulo</span><span class="p">(</span><span class="n">origen</span><span class="p">:</span> <span class="n">Punto</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="mf">2.0</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="mf">2.0</span><span class="p">),</span>
                        <span class="n">tamaño</span><span class="p">:</span> <span class="n">Tamaño</span><span class="p">(</span><span class="n">ancho</span><span class="p">:</span> <span class="mf">5.0</span><span class="p">,</span> <span class="n">alto</span><span class="p">:</span> <span class="mf">5.0</span><span class="p">))</span>
<span class="c1">// el origne de origenRectangulo es (2.0, 2.0) y su tamaño (5.0, 5.0)</span>
<span class="kd">let</span> <span class="nv">centroRectangulo</span> <span class="p">=</span> <span class="n">Rectangulo</span><span class="p">(</span><span class="n">centro</span><span class="p">:</span> <span class="n">Punto</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="mf">4.0</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="mf">4.0</span><span class="p">),</span>
                        <span class="n">tamaño</span><span class="p">:</span> <span class="n">Tamaño</span><span class="p">(</span><span class="n">ancho</span><span class="p">:</span> <span class="mf">3.0</span><span class="p">,</span> <span class="n">alto</span><span class="p">:</span> <span class="mf">3.0</span><span class="p">))</span>
<span class="c1">// el origen de centroRectangulo es (2.5, 2.5) y su tamaño (3.0, 3.0)</span>
</pre></div>
</td></tr></table>

<p>El inicializador <code>init(){}</code> permite inicializar el <code>Rectangulo</code> a los
valores por defecto definidos en las propiedades. Proporciona la misma
funcionalidad que el inicializador por defecto, que tal y como hemos
comentado, no se crea en una estructura o clase en la que definimos
sus propios inicializadores.</p>
<h2 id="herencia">Herencia<a class="headerlink" href="#herencia" title="Permanent link">&para;</a></h2>
<p>Una clase puede <em>heredar</em> métodos, propiedades y otras características
de otra clase. Cuando una clase hereda de otra, la clase que hereda se
denomina <em>subclase</em>, y la clase de la que se hereda se denomina su
<em>superclase</em>. La herencia es una conducta fundamental que diferencia
las clases de otros tipos en Swift.</p>
<p>Las clases en Swift pueden llamar y acceder a métodos y propiedades
que pertenecen a su superclase y pueden proporcionar sus propias
versiones que sobreescriben esos métodos y propiedades. Para
sobreescribir un método o una propiedad es necesario cumplir con la
definición proporcionada por la superclase.</p>
<p>Las clases también pueden añadir observadores a las propiedades
heredadas para ser notificadas cuando cambia el valor de una
propiedad. A cualquier propiedad se le puede añadir un observador de
propiedad, independientemente de si es originalmente una propiedad
almacenada o calculada.</p>
<h3 id="definicion-de-una-clase-base">Definición de una clase base<a class="headerlink" href="#definicion-de-una-clase-base" title="Permanent link">&para;</a></h3>
<p>Una clase que no hereda de ninguna otra se denomina una <em>clase base</em>
(<em>base class</em>). A diferencia de otros lenguajes orientados a objetos,
las clases en Swift no heredan de una clase base universal.</p>
<p>También a diferencia de otros lenguajes orientados a objetos Swift no
permite definir clases <em>abstractas</em> que no permiten crear
instancias. Cualquier clase en Swift puede ser instanciada.</p>
<p>El siguiente ejemplo define una clase base llamada <code>Vehiculo</code>. Esta
clase base define una propiedad almacenada llamada <code>velocidadActual</code>
con un valor por defecto de 0.0. Esta propiedad se utiliza por una
propiedad <code>String</code> calculada llamada <code>descripcion</code> que crea una
descripción del vehículo.</p>
<p>La clase base <code>Vehiculo</code> también define un método llamdo
<code>hazRuido</code>. Este método no hace nada realmente para una instancia de
un vehículo base, pero será modificado más adelante por las subclases
de <code>Vehiculo</code>.</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">class</span> <span class="nc">Vehiculo</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">velocidadActual</span> <span class="p">=</span> <span class="mf">0.0</span>
    <span class="kd">var</span> <span class="nv">descripcion</span><span class="p">:</span> <span class="nb">String</span> <span class="p">{</span>
        <span class="k">return</span> <span class="s">&quot;viajando a </span><span class="si">\(</span><span class="n">velocidadActual</span><span class="si">)</span><span class="s"> kilómetros por hora&quot;</span>
    <span class="p">}</span>
    <span class="kd">func</span> <span class="nf">hazRuido</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// no hace nada - un vehículo arbitrario no hace ruido necesariamente</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<p>Creamos una instancia nueva de <code>Vehiculo</code> con la sintaxis de
inicialización que hemos visto, en la que se escribe el nombre del
tipo de la clase seguido por paréntesis vacíos:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">let</span> <span class="nv">unVehiculo</span> <span class="p">=</span> <span class="n">Vehiculo</span><span class="p">()</span>
</pre></div>
</td></tr></table>

<p>Habiendo creado una instancia nueva de <code>Vehiculo</code>, podemos acceder a
su descripción:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="bp">print</span><span class="p">(</span><span class="s">&quot;Vehículo: </span><span class="si">\(</span><span class="n">unVehiculo</span><span class="p">.</span><span class="n">descripcion</span><span class="si">)</span><span class="s">&quot;</span><span class="p">)</span>
<span class="c1">// Vehículo: viajando a 0.0 kilómetros por hora</span>
</pre></div>
</td></tr></table>

<p>La clase <code>Vehiculo</code> define características comunes para un vehículo
arbitrario, pero no es de mucha utilidad por si misma. Para hacerla
más útil, tenemos que refinarla para describir tipos de vehículos más
específicos.</p>
<h3 id="construccion-de-subclases">Construcción de subclases<a class="headerlink" href="#construccion-de-subclases" title="Permanent link">&para;</a></h3>
<p>La construcción de una subclase (<em>subclassing</em>) es la acción de basar
una nueva clase en una clase existente. La subclase hereda
características de la clase existente, que después podemos
refinar. También podemos añadir nuevas características a la subclase.</p>
<p>Para indicar que una subclase tiene una superclase hay que escribir el
nombre de la subclase antes de el de la superclase, separadas por dos
puntos (<code>:</code>):</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">class</span> <span class="nc">UnaSubclase</span><span class="p">:</span> <span class="n">UnaSuperClase</span> <span class="p">{</span>
    <span class="c1">// definición de la subclase</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<p>En el ejemplo anterior del <code>Vehiculo</code> podemos definir una subclase
<code>Bicicleta</code>:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">class</span> <span class="nc">Bicicleta</span><span class="p">:</span> <span class="n">Vehiculo</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">tieneCesta</span> <span class="p">=</span> <span class="kc">false</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<p>La nueva clase <code>Bicicleta</code> obtiene automáticamente todas las
características del <code>Vehiculo</code>, como sus propiedades <code>velocidadActual</code>
y <code>descripcion</code> y su método <code>haceRuido()</code>.</p>
<p>Además de las características que hereda, la clase <code>Bicicleta</code> define
una nueva propiedad almacenada, <code>tieneCesta</code>, con un valor por defecto
de <code>false</code>.</p>
<p>Por defecto, cualquier instancia nueva de <code>Bicicleta</code> no tendrá una
cesta. Puedes establecer la propiedad <code>tieneCesta</code> a <code>true</code> para una
instancia particular de <code>Bicicleta</code> después de crearla:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">let</span> <span class="nv">bicicleta</span> <span class="p">=</span> <span class="n">Bicicleta</span><span class="p">()</span>
<span class="n">bicicleta</span><span class="p">.</span><span class="n">tieneCesta</span> <span class="p">=</span> <span class="kc">true</span>
</pre></div>
</td></tr></table>

<p>Podemos también modificar la propiedad heredada <code>velocidadActual</code> y
preguntar por la propiedad <code>descripcion</code>:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">bicicleta</span><span class="p">.</span><span class="n">velocidadActual</span> <span class="p">=</span> <span class="mf">10.0</span>
<span class="bp">print</span><span class="p">(</span><span class="s">&quot;Bicicleta: </span><span class="si">\(</span><span class="n">bicicleta</span><span class="p">.</span><span class="n">descripcion</span><span class="si">)</span><span class="s">&quot;</span><span class="p">)</span>
<span class="c1">// Bicicleta: viajando a 10.0 kilómetros por hora</span>
</pre></div>
</td></tr></table>

<p>Podemos construir subclases a partir de otras subclases. El siguiente
ejemplo crea una subclase de <code>Bicicleta</code> que representa una bicicleta
de dos sillines (un "tandem"):</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">class</span> <span class="nc">Tandem</span><span class="p">:</span> <span class="n">Bicicleta</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">numeroActualDePasajeros</span> <span class="p">=</span> <span class="mi">0</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<p><code>Tandem</code> hereda todas las propiedades y métodos de <code>Bicicleta</code>, que a
su vez hereda todas sus propiedades y métodos de <code>Vehiculo</code>. La
subclase <code>Tandem</code> también añade una nueva propiedad almacenada llamada
<code>numeroActualDePasajeros</code>, con un valor por defecto de 0.</p>
<p>Si creamos una instancia de <code>Tandem</code> podremos trabajar con cualquiera
de sus propiedades nuevas y heredadas, y preguntar a la descripción de
solo lectura que hereda de <code>Vehiculo</code>:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">let</span> <span class="nv">tandem</span> <span class="p">=</span> <span class="n">Tandem</span><span class="p">()</span>
<span class="n">tandem</span><span class="p">.</span><span class="n">tieneCesta</span> <span class="p">=</span> <span class="kc">true</span>
<span class="n">tandem</span><span class="p">.</span><span class="n">numeroActualDePasajeros</span> <span class="p">=</span> <span class="mi">2</span>
<span class="n">tandem</span><span class="p">.</span><span class="n">velocidadActual</span> <span class="p">=</span> <span class="mf">18.0</span>
<span class="bp">print</span><span class="p">(</span><span class="s">&quot;Tandem: </span><span class="si">\(</span><span class="n">tandem</span><span class="p">.</span><span class="n">descripcion</span><span class="si">)</span><span class="s">&quot;</span><span class="p">)</span>
<span class="c1">// Tandem: viajando a 18.0 kilómetros por hora</span>
</pre></div>
</td></tr></table>

<h3 id="sobreescritura">Sobreescritura<a class="headerlink" href="#sobreescritura" title="Permanent link">&para;</a></h3>
<p>Una subclase puede proporcionar su propia implementación de un método
de la instancia, método del tipo, propiedad de la instancia o
propiedad del tipo que hereda de su superclase. Esto se conoce como
<em>sobreescritura</em> (<em>overriding</em>).</p>
<p>Para sobreescribir una característica que sería de otra forma heredada
debemos usar el prefijo <code>override</code>. De esta forma se clarifica que
intentamos proporcionar una sobreescritura y que no lo hacemos por
error. Esta palabra clave también hace que el compilador comprueba que
la superclase (o una de sus clases padre) tiene una declaración que
empareja con la que proporcionamos en la sobreescritura.</p>
<p>Cuando proporcionamos una sobreescritura puede ser útil acceder a los
valores proporcionados por la clase padre. Para acceder a ellos
podemos usar el prefijo <code>super</code>.</p>
<p>El siguiente ejemplo define una nueva subclase de <code>Vehiculo</code> llamada
<code>Tren</code>, que sobreescribe el método <code>hazRuido()</code>:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">class</span> <span class="nc">Tren</span><span class="p">:</span> <span class="n">Vehiculo</span> <span class="p">{</span>
    <span class="kr">override</span> <span class="kd">func</span> <span class="nf">hazRuido</span><span class="p">()</span> <span class="p">{</span>
        <span class="bp">print</span><span class="p">(</span><span class="s">&quot;Chuu Chuu&quot;</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<p>Si creamos una nueva instancia de <code>Tren</code> y llamamos al método
<code>hazRuido</code> podemos comprobar que se llama a la versión del método de
la subclase:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">let</span> <span class="nv">tren</span> <span class="p">=</span> <span class="n">Tren</span><span class="p">()</span>
<span class="n">tren</span><span class="p">.</span><span class="n">hazRuido</span><span class="p">()</span>
<span class="c1">// Imprime &quot;Chuu Chuu&quot;</span>
</pre></div>
</td></tr></table>

<p>Podemos sobreescribir cualquier propiedad heredada del tipo o de la
instancia y proporcionar nuestros propios <em>getters</em> y <em>setters</em> para
esa propiedad, o añadir observadores de propiedades para observar
cuando cambian los valores subyacentes de la propiedad.</p>
<p>Podemos proporcionar un <em>getter</em> (o <em>setter</em>, si es apropiado) para
sobreescribir cualquier propiedad heredada, independientemente de si
la propiedad heredada se implementa como una propiedad almacenada o
calculada. La naturaleza almacenada o calculada no se conoce por la
subclase, que solo conoce su nombre y su tipo. Es posible convertir
una propiedad heredada de solo-lectura en una de lectura-escritura. No
es posible presentar una propiedad heredada de lectura-escritura como
de solo-lectura.</p>
<p>El siguiente ejemplo define una nueva clase llamada <code>Coche</code>, que es
una subclase de <code>Vehiculo</code>. La clase <code>Coche</code> introduce una nueva
propiedad almacenada llamada <code>marcha</code>, con un valor por defecto
de 1. También sobreescribe la propiedad heredada <code>descripcion</code>,
incluyendo la marcha actual en la descripción:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">class</span> <span class="nc">Coche</span><span class="p">:</span> <span class="n">Vehiculo</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">marcha</span> <span class="p">=</span> <span class="mi">1</span>
    <span class="kr">override</span> <span class="kd">var</span> <span class="nv">descripcion</span><span class="p">:</span> <span class="nb">String</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kc">super</span><span class="p">.</span><span class="n">descripcion</span> <span class="o">+</span> <span class="s">&quot; con la marcha </span><span class="si">\(</span><span class="n">marcha</span><span class="si">)</span><span class="s">&quot;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<p>Podemos ver el funcionamiento en el siguiente ejemplo:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">let</span> <span class="nv">coche</span> <span class="p">=</span> <span class="n">Coche</span><span class="p">()</span>
<span class="n">coche</span><span class="p">.</span><span class="n">velocidadActual</span> <span class="p">=</span> <span class="mf">50.0</span>
<span class="n">coche</span><span class="p">.</span><span class="n">marcha</span> <span class="p">=</span> <span class="mi">3</span>
<span class="bp">print</span><span class="p">(</span><span class="s">&quot;Coche: </span><span class="si">\(</span><span class="n">coche</span><span class="p">.</span><span class="n">descripcion</span><span class="si">)</span><span class="s">&quot;</span><span class="p">)</span>
<span class="c1">// Coche: viajando a 50.0 kilómetros por hora con la marcha 3</span>
</pre></div>
</td></tr></table>

<p>Por último, podemos añadir observadores a propiedades heredadas. Esto
nos permite ser notificados cuando el valor de una propiedad heredada
cambia, independientemente de si esa propiedad se ha implementado en
la subclase o en la superclase.</p>
<p>El siguiente ejemplo define una nueva clase llamada <code>CocheAutomatico</code>
que es una subclase de <code>Coche</code>. La clase <code>CocheAutomatico</code> representa
un coche con una caja de cambios automática, que selecciona
automáticamente la marcha basándose en la velocidad actual:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">class</span> <span class="nc">CocheAutomatico</span><span class="p">:</span> <span class="n">Coche</span> <span class="p">{</span>
    <span class="kr">override</span> <span class="kd">var</span> <span class="nv">velocidadActual</span><span class="p">:</span> <span class="nb">Double</span> <span class="p">{</span>
        <span class="kr">didSet</span> <span class="p">{</span>
            <span class="n">marcha</span> <span class="p">=</span> <span class="bp">min</span><span class="p">(</span><span class="nb">Int</span><span class="p">(</span><span class="n">velocidadActual</span> <span class="o">/</span> <span class="mf">25.0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<p>En cualquier momento que se modifica la propiedad <code>velocidadActual</code> de
una instancia de <code>CocheAutomatico</code>, el observador <code>didSet</code> establece
la propiedad <code>marcha</code> a un valor apropiado para la nueva velocidad. Un
ejemplo de ejecución:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">let</span> <span class="nv">automatico</span> <span class="p">=</span> <span class="n">CocheAutomatico</span><span class="p">()</span>
<span class="n">automatico</span><span class="p">.</span><span class="n">velocidadActual</span> <span class="p">=</span> <span class="mf">100.0</span>
<span class="bp">print</span><span class="p">(</span><span class="s">&quot;CocheAutomatico: </span><span class="si">\(</span><span class="n">automatico</span><span class="p">.</span><span class="n">descripcion</span><span class="si">)</span><span class="s">&quot;</span><span class="p">)</span>
<span class="c1">// CocheAutomatico: viajando a 100.0 kilómetros por hora con la marcha 5</span>
</pre></div>
</td></tr></table>

<p>Por último, es posible prevenir un método o propiedad de ser
sobreescrito declarándolo como <em>final</em>. Para ello, hay que escribir el
modificador <code>final</code> antes del nombre de la palabra clave que introduce
el método o la propiedad (como <code>final var</code>, <code>final func</code>). </p>
<p>También es posible marcar la clase completa como final, escribiendo el
modificador antes de <code>class</code> (<code>final class</code>).</p>
<h2 id="protocolos">Protocolos<a class="headerlink" href="#protocolos" title="Permanent link">&para;</a></h2>
<p>Un <em>protocolo</em> (<em>protocol</em>) define un esquema de métodos, propiedades
y otros requisitos que encajan en una tarea particular o un trozo de
funcionalidad. El protocolo puede luego ser <em>adoptado</em> (<em>adopted</em>) por
una clase, estructura o enumarción para proporcionar una
implementación real de esos requisitos. Cualquier tipo que satisface
los requerimientos de un protocolo se dice que <em>se ajusta</em> o <em>cumple</em>
(<em>conform</em>) ese protocolo.</p>
<p>Además de especificar los requisitos de los tipos que cumplen el
protocolo, también se puede <strong>extender un protocolo</strong> (lo veremos más
adelante, cuando hablemos de <strong>extensiones</strong>) para proporcionar una
implementación de algunos de los métodos requeridos por el protocolo.</p>
<h3 id="sintaxis">Sintaxis<a class="headerlink" href="#sintaxis" title="Permanent link">&para;</a></h3>
<p>Los protocolos se definen de forma similar a las clases, estructuras y
enumeraciones:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">protocol</span> <span class="nc">UnProtocolo</span> <span class="p">{</span>
    <span class="c1">// definición del protocolo</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<p>Para definir un tipo que se ajusta a un protocolo particular se debe
poner el nombre del protocolo tras el nombre del tipo, separado por
dos puntos. Podemos listar más de un protocolo, y se separan por
comas:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">struct</span> <span class="nc">UnStruct</span><span class="p">:</span> <span class="n">PrimerProtocolo</span><span class="p">,</span> <span class="n">OtroProtocolo</span> <span class="p">{</span>
    <span class="c1">// definición del struct</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<p>Si una clase tiene una superclase, se escribe el nombre de la
superclase antes de los protocolos, seguido por una coma:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">class</span> <span class="nc">UnaClase</span><span class="p">:</span> <span class="n">UnaSuperClase</span><span class="p">,</span> <span class="n">PrimerProtocolo</span><span class="p">,</span> <span class="n">OtroProto</span> <span class="p">{</span>
    <span class="c1">// definición de la clase</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<h3 id="requisitos-de-propiedades">Requisitos de propiedades<a class="headerlink" href="#requisitos-de-propiedades" title="Permanent link">&para;</a></h3>
<p>Un protocolo puede requerir a cualquier tipo que se ajuste a él que
proporcione una propiedad de instancia o de tipo con un nombre y tipo
particular. El protocolo no especifica si la propiedad es una
propiedad calculada o almacenada, sólo especifica el nombre y el tipo
de la propiedad requerida. El protocolo también especifica si la
propiedad debe ser de lectura y escritura o sólo de lectura.</p>
<p>Si un protocolo requiere que una propiedad sea de lectura y escritura,
el requisito no puede ser satisfecho por una propiedad constante
almacenada o por una propiedad calculada de sólo lectura. Si el
protocolo sólo requiere que la propiedad sea de lectura, el requisito
puede ser satisfecho por cualquier tipo de propiedad, y es válido que
la propiedad sea también de escritura si es útil para nuestro propio
código.</p>
<p>Los requisitos de la propiedad se declaran siempre como propiedades
variables, precedido por la palabra clave <code>var</code>. Las propiedades de
lectura y escritura se indican escribiendo <code>{ get set }</code> después de la
declaración de su tipo, y las propiedades de sólo lectura se indican
escribiendo <code>{ get }</code>.</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">protocol</span> <span class="nc">UnProtocolo</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">debeSerEscribible</span><span class="p">:</span> <span class="nb">Int</span> <span class="p">{</span> <span class="kr">get</span> <span class="kr">set</span> <span class="p">}</span>
    <span class="kd">var</span> <span class="nv">noTienePorQueSerEscribible</span><span class="p">:</span> <span class="nb">Int</span> <span class="p">{</span> <span class="kr">get</span> <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<p>Para definir una propiedad de tipo hay que precederla en el protocolo
con la palabra clave <code>static</code>:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">protocol</span> <span class="nc">OtroProtocolo</span> <span class="p">{</span>
    <span class="kd">static</span> <span class="kd">var</span> <span class="nv">unaPropiedadDeTipo</span><span class="p">:</span> <span class="nb">Int</span> <span class="p">{</span> <span class="kr">get</span> <span class="kr">set</span> <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<p>Veamos un ejemplo. Definimos el protocolo <code>TieneNombre</code> en el que se
requiere que cualquier clase que se ajuste a él debe tener una
propiedad de instancia de lectura de tipo <code>String</code> que se llame
<code>nombreCompleto</code>:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">protocol</span> <span class="nc">TieneNombre</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">nombreCompleto</span><span class="p">:</span> <span class="nb">String</span> <span class="p">{</span> <span class="kr">get</span> <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<p>Un ejemplo de una sencilla estructura que adopta el protocolo:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">struct</span> <span class="nc">Persona</span><span class="p">:</span> <span class="n">TieneNombre</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">edad</span><span class="p">:</span> <span class="nb">Int</span>
    <span class="kd">var</span> <span class="nv">nombreCompleto</span><span class="p">:</span> <span class="nb">String</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nv">john</span> <span class="p">=</span> <span class="n">Persona</span><span class="p">(</span><span class="n">edad</span><span class="p">:</span> <span class="mi">35</span><span class="p">,</span> <span class="n">nombreCompleto</span><span class="p">:</span> <span class="s">&quot;John Appleseed&quot;</span><span class="p">)</span>
<span class="c1">// john.nombreCompleto es &quot;John Appleseed&quot;</span>
</pre></div>
</td></tr></table>

<p>Este ejemplo define una estructure llamada <code>Persona</code>, que representa
una persona con una edad y un nombre específico. En la primera línea
se declara que se adopta el protocolo <code>TieneNombre</code>. Cada instancia de
<code>Persona</code> tiene la propiedad almacenada llamada <code>nombreCompleto</code>, que
es de tipo <code>String</code>. Esto cumple el único requisito del protocolo
<code>TieneNombre</code>, y signifca que <code>Persona</code> se ajusta correctamente al
protocolo (Swift informa de un error en tiempo de compilación si un
requisito de un protocolo no se cumple).</p>
<p>Otro ejemplo de una clase más compleja, que también adopta el protocolo:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">class</span> <span class="nc">NaveEstelar</span><span class="p">:</span> <span class="n">TieneNombre</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">prefijo</span><span class="p">:</span> <span class="nb">String</span><span class="p">?</span>
    <span class="kd">var</span> <span class="nv">nombre</span><span class="p">:</span> <span class="nb">String</span>
    <span class="kd">init</span><span class="p">(</span><span class="n">nombre</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span> <span class="n">prefijo</span><span class="p">:</span> <span class="nb">String</span><span class="p">?</span> <span class="p">=</span> <span class="kc">nil</span><span class="p">)</span> <span class="p">{</span>
        <span class="kc">self</span><span class="p">.</span><span class="n">nombre</span> <span class="p">=</span> <span class="n">nombre</span>
        <span class="kc">self</span><span class="p">.</span><span class="n">prefijo</span> <span class="p">=</span> <span class="n">prefijo</span>
    <span class="p">}</span>
    <span class="kd">var</span> <span class="nv">nombreCompleto</span><span class="p">:</span> <span class="nb">String</span> <span class="p">{</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">prefijo</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">?</span> <span class="n">prefijo</span><span class="p">!</span> <span class="o">+</span> <span class="s">&quot; &quot;</span> <span class="p">:</span> <span class="s">&quot;&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="n">nombre</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kd">var</span> <span class="nv">ncc1701</span> <span class="p">=</span> <span class="n">NaveEstelar</span><span class="p">(</span><span class="n">nombre</span><span class="p">:</span> <span class="s">&quot;Enterprise&quot;</span><span class="p">,</span> <span class="n">prefijo</span><span class="p">:</span> <span class="s">&quot;USS&quot;</span><span class="p">)</span>
<span class="c1">// ncc1701.nombreCompleto es &quot;USS Enterprise&quot;</span>
</pre></div>
</td></tr></table>

<p>Esta clase implementa el requisito de la propiedad <code>nombreCompleto</code>
como una propiedad calculada de solo lectura para una nave
estelar. Cada instancia de <code>NavaEstelar</code> almacena un nombre
obligatorio y un prefijo opcional. La propiedad <code>nombreCompleto</code> usa
el valor del prefijo si existe, y la añade al comienzo del nombre para
crear un nombre completo de la nave estelar.</p>
<h3 id="requisitos-de-metodos">Requisitos de métodos<a class="headerlink" href="#requisitos-de-metodos" title="Permanent link">&para;</a></h3>
<p>Los protocolos pueden requerir que los tipos que se ajusten a ellos
implementen métodos de instancia y de tipos específicos. Estos métodos
se escriben como parte de la definición del protocolo de la misma
forma que los métodos normales, pero sin sus cuerpos:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">protocol</span> <span class="nc">UnProtocolo</span> <span class="p">{</span>
    <span class="kd">func</span> <span class="nf">unMetodo</span><span class="p">()</span> <span class="p">-&gt;</span> <span class="nb">Int</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<p>Los métodos del tipo en el protocolo deben indicarse con la palabra
clave <code>static</code>:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">protocol</span> <span class="nc">UnProtocolo</span> <span class="p">{</span>
    <span class="kd">static</span> <span class="kd">func</span> <span class="nf">unMetodoDelTipo</span><span class="p">()</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<p>Un ejemplo:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">protocol</span> <span class="nc">GeneradorNumerosAleatorios</span> <span class="p">{</span>
    <span class="kd">func</span> <span class="nf">random</span><span class="p">()</span> <span class="p">-&gt;</span> <span class="nb">Double</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<p>Este protocolo, <code>GeneradorNumerosAleatorios</code>, requiere que cualquier
tipo que se ajuste a él tenga un método de instancia llamado <code>random</code>,
que devuelve un valor <code>Double</code> cada vez que se llama. Aunque no está
especificado en el protocolo, se asume que este valor será un número
entre 0.0 y 1.0 (sin incluirlo). El protocolo
<code>GeneradorNumerosAleatorios</code> no hace ninguna suposición sobre cómo
será generado cada número aleatorio, simplemente requiere al generador
que proporcione una forma estándar de generarlo.</p>
<p>Una implementación de una clase que adopta el protocolo:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">class</span> <span class="nc">GeneradorLinealCongruente</span><span class="p">:</span> <span class="n">GeneradorNumerosAleatorios</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">ultimoRandom</span> <span class="p">=</span> <span class="mf">42.0</span>
    <span class="kd">let</span> <span class="nv">m</span> <span class="p">=</span> <span class="mf">139968.0</span>
    <span class="kd">let</span> <span class="nv">a</span> <span class="p">=</span> <span class="mf">3877.0</span>
    <span class="kd">let</span> <span class="nv">c</span> <span class="p">=</span> <span class="mf">29573.0</span>
    <span class="kd">func</span> <span class="nf">random</span><span class="p">()</span> <span class="p">-&gt;</span> <span class="nb">Double</span> <span class="p">{</span>
        <span class="kd">let</span> <span class="nv">number</span> <span class="p">=</span> <span class="n">ultimoRandom</span> <span class="o">*</span> <span class="n">a</span> <span class="o">+</span> <span class="n">c</span>
        <span class="n">ultimoRandom</span> <span class="p">=</span> <span class="n">number</span><span class="p">.</span><span class="n">truncatingRemainder</span><span class="p">(</span><span class="n">dividingBy</span><span class="p">:</span> <span class="n">m</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ultimoRandom</span> <span class="o">/</span> <span class="n">m</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kd">let</span> <span class="nv">generador</span> <span class="p">=</span> <span class="n">GeneradorLinealCongruente</span><span class="p">()</span>
<span class="bp">print</span><span class="p">(</span><span class="s">&quot;Un número aleatorio: </span><span class="si">\(</span><span class="n">generador</span><span class="p">.</span><span class="n">random</span><span class="si">())</span><span class="s">&quot;</span><span class="p">)</span>
<span class="c1">// Imprime &quot;Un número aleatorio: 0.37464991998171&quot;</span>
<span class="bp">print</span><span class="p">(</span><span class="s">&quot;Y otro: </span><span class="si">\(</span><span class="n">generador</span><span class="p">.</span><span class="n">random</span><span class="si">())</span><span class="s">&quot;</span><span class="p">)</span>
<span class="c1">// Imprime &quot;Y otro: 0.729023776863283&quot;</span>
</pre></div>
</td></tr></table>

<h3 id="requisito-de-metodo-mutating">Requisito de método <code>mutating</code><a class="headerlink" href="#requisito-de-metodo-mutating" title="Permanent link">&para;</a></h3>
<p>Si definimos un protocolo con un requisito de método de instancia que
pretenda mutar las instancias del tipo que adopte el protocolo, se
debe marcar el método con la palabra <code>mutating</code>. Esto permite a las
estructuras y enumeraciones que adopten el protocolo definir ese
método como <code>mutating</code>. No es necesario hacerlo con las clases, porque
la palabra <code>mutating</code> solo es necesaria en estructuras y
enumeraciones.</p>
<p>Un ejemplo:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">protocol</span> <span class="nc">Conmutable</span> <span class="p">{</span>
    <span class="kr">mutating</span> <span class="kd">func</span> <span class="nf">conmutar</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">enum</span> <span class="nc">Interruptor</span><span class="p">:</span> <span class="n">Conmutable</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">apagado</span><span class="p">,</span> <span class="n">encendido</span>
    <span class="kr">mutating</span> <span class="kd">func</span> <span class="nf">conmutar</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">switch</span> <span class="kc">self</span> <span class="p">{</span>
        <span class="k">case</span> <span class="p">.</span><span class="n">apagado</span><span class="p">:</span>
            <span class="kc">self</span> <span class="p">=</span> <span class="p">.</span><span class="n">encendido</span>
        <span class="k">case</span> <span class="p">.</span><span class="n">encendido</span><span class="p">:</span>
            <span class="kc">self</span> <span class="p">=</span> <span class="p">.</span><span class="n">apagado</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nv">interruptorLampara</span> <span class="p">=</span> <span class="n">Interruptor</span><span class="p">.</span><span class="n">apagado</span>
<span class="n">interruptorLampara</span><span class="p">.</span><span class="n">conmutar</span><span class="p">()</span>
<span class="c1">// interruptorLampara es ahora igual a .encendido</span>
</pre></div>
</td></tr></table>

<h3 id="protocolos-como-tipos">Protocolos como tipos<a class="headerlink" href="#protocolos-como-tipos" title="Permanent link">&para;</a></h3>
<p>Los protocolos no implementan realmente ninguna funcionalidad por
ellos mismos. Sin embargo, cualquier protocolo que definamos se
convierte automáticamente en un tipo con todas sus propiedades que
podemos usar en nuestro código.</p>
<p>Podemos entonces usar el protocolo en cualquier sitio donde permitamos
otros tipos, incluyendo:</p>
<ul>
<li>El tipo de un parámetro de una función, método o inicializador o de
  sus valores devueltos.</li>
<li>El tipo de una constante, variable o propiedad</li>
<li>El tipo de los ítems de un array, diccionario u otro contenedor</li>
</ul>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">class</span> <span class="nc">Dado</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nv">caras</span><span class="p">:</span> <span class="nb">Int</span>
    <span class="kd">let</span> <span class="nv">generador</span><span class="p">:</span> <span class="n">GeneradorNumerosAleatorios</span>
    <span class="kd">init</span><span class="p">(</span><span class="n">caras</span><span class="p">:</span> <span class="nb">Int</span><span class="p">,</span> <span class="n">generador</span><span class="p">:</span> <span class="n">GeneradorNumerosAleatorios</span><span class="p">)</span> <span class="p">{</span>
        <span class="kc">self</span><span class="p">.</span><span class="n">caras</span> <span class="p">=</span> <span class="n">caras</span>
        <span class="kc">self</span><span class="p">.</span><span class="n">generador</span> <span class="p">=</span> <span class="n">generador</span>
    <span class="p">}</span>
    <span class="kd">func</span> <span class="nf">tirar</span><span class="p">()</span> <span class="p">-&gt;</span> <span class="nb">Int</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nb">Int</span><span class="p">(</span><span class="n">generador</span><span class="p">.</span><span class="n">random</span><span class="p">()</span> <span class="o">*</span> <span class="nb">Double</span><span class="p">(</span><span class="n">caras</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<p>Este ejemplo define una nueva clase llamada <code>Dado</code>, que representa un
dado de <em>n</em> caras que se puede usar en un juego de tablero. Las
instancias de dados tienen una propiedad llamada <code>caras</code>, que
representa cuántas caras tienen, y una propiedad llamada <code>generador</code>,
que proporciona un generador a partir del cual crear valores de
tiradas.</p>
<p>La propiedad generador es del tipo
<code>GeneradorNumerosAleatorios</code>. Podemos asignarle una instancia de
cualquier tipo que adopte el protocolo <code>GeneradorNumerosAleatorios</code>.</p>
<p><code>Dado</code> tiene también un inicializador, para configurar sus estado
inicial. El inicializador tiene un parámetro llamado <code>generador</code>, que
también es del tipo <code>GeneradorNumerosAleatorios</code>. Podemos pasarle un
valor de cualquier instancia que se ajuste a este tipo. Y también
proporciona un método de instancia llamado <code>tirar</code>, que devuelve un
valor entero entre 1 y el número de caras del dado. Este método llama
al método <code>random()</code> del generador para crear un nuevo número
aleatorio entre 0.0 y 1.0 y usa este número aleatorio para crear un
valor de tirada que esté dentro del rango correcto. Debido a que
sabemos que el generador se ajusta al protocolo
<code>GeneradorNumerosAleatorios</code> tenemos la garantía de que va a existir
un método <code>random()</code> al que llamar.</p>
<p>Un ejemplo de uso del código:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">var</span> <span class="nv">d6</span> <span class="p">=</span> <span class="n">Dado</span><span class="p">(</span><span class="n">caras</span><span class="p">:</span> <span class="mi">6</span><span class="p">,</span> <span class="n">generador</span><span class="p">:</span> <span class="n">GeneradorLinealCongruente</span><span class="p">())</span>
<span class="k">for</span> <span class="kc">_</span> <span class="k">in</span> <span class="mf">1.</span><span class="p">..</span><span class="mi">5</span> <span class="p">{</span>
    <span class="bp">print</span><span class="p">(</span><span class="s">&quot;La tirada del dado es </span><span class="si">\(</span><span class="n">d6</span><span class="p">.</span><span class="n">tirar</span><span class="si">())</span><span class="s">&quot;</span><span class="p">)</span>
<span class="p">}</span>
<span class="c1">// La tirada del dado es 3</span>
<span class="c1">// La tirada del dado es 5</span>
<span class="c1">// La tirada del dado es 4</span>
<span class="c1">// La tirada del dado es 5</span>
<span class="c1">// La tirada del dado es 4</span>
</pre></div>
</td></tr></table>

<h3 id="colecciones-de-tipos-protocolo">Colecciones de tipos protocolo<a class="headerlink" href="#colecciones-de-tipos-protocolo" title="Permanent link">&para;</a></h3>
<p>Como hemos comentado anteriormente, un protocolo puede usarse como el
tipo que se almacena un una colección (array, diccionario,
etc.). Veamos un ejemplo:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">var</span> <span class="nv">peterParker</span> <span class="p">=</span> <span class="n">Persona</span><span class="p">(</span><span class="n">edad</span><span class="p">:</span> <span class="mi">24</span><span class="p">,</span> <span class="n">nombreCompleto</span><span class="p">:</span> <span class="s">&quot;Peter Parker&quot;</span><span class="p">)</span>
<span class="kd">var</span> <span class="nv">ncc1701</span> <span class="p">=</span> <span class="n">NaveEstelar</span><span class="p">(</span><span class="n">nombre</span><span class="p">:</span> <span class="s">&quot;Enterprise&quot;</span><span class="p">,</span> <span class="n">prefijo</span><span class="p">:</span> <span class="s">&quot;USS&quot;</span><span class="p">)</span>

<span class="kd">let</span> <span class="nv">cosasConNombre</span><span class="p">:</span> <span class="p">[</span><span class="n">TieneNombre</span><span class="p">]</span> <span class="p">=</span> <span class="p">[</span><span class="n">peterParker</span><span class="p">,</span> <span class="n">ncc1701</span><span class="p">]</span>

<span class="k">for</span> <span class="n">cosa</span> <span class="k">in</span> <span class="n">cosasConNombre</span> <span class="p">{</span>
   <span class="bp">print</span><span class="p">(</span><span class="n">cosa</span><span class="p">.</span><span class="n">nombreCompleto</span><span class="p">)</span>
<span class="p">}</span>
<span class="c1">// Peter Parker</span>
<span class="c1">// USS Enterprise</span>
</pre></div>
</td></tr></table>

<p>Hay que hacer notar que la constante <code>cosa</code> que itera sobre los
elementos del array es de tipo <code>TieneNombre</code>], no es de tipo <code>Persona</code>
ni de tipo <code>NaveEstelar</code>, incluso aunque las instancias que hay tras
de escena son do esos tipos. Por ser del tipo <code>TieneNombre</code> sabemos
que tiene una propiedad <code>nombreCompleto</code> que podemos usar sobre la
variable iteradora.</p>
<h3 id="protocolo-equatable">Protocolo <code>Equatable</code><a class="headerlink" href="#protocolo-equatable" title="Permanent link">&para;</a></h3>
<p>En la <a href="https://developer.apple.com/documentation/swift">biblioteca estándar de
Swift</a> se definen
distintos protocolos como <code>Collection</code> y <code>Equatable</code> que describen
abstracciones comunes. Muchos de estos protocolos incorporan
implementaciones por defecto de algunos de sus métodos mediante
extensiones definidas en la propia biblioteca estándar.</p>
<p>Veamos por ejemplo el protocolo
<a href="https://developer.apple.com/documentation/swift/equatable"><code>Equatable</code></a>. Se
trata de un protocolo importante que define las operaciones de
igualdad (<code>==</code>) y diferencia (<code>!=</code>). Debemos implementar la operación
de igualdad en cualquier clase que se ajuste al protocolo, pero la
operación de diferencia ya tiene una implementación por defecto.</p>
<p>Un ejemplo:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">class</span> <span class="nc">Punto3D</span><span class="p">:</span> <span class="nb">Equatable</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nv">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">:</span> <span class="nb">Double</span>

    <span class="kd">init</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">Double</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="nb">Double</span><span class="p">,</span> <span class="n">z</span><span class="p">:</span> <span class="nb">Double</span><span class="p">)</span> <span class="p">{</span>
        <span class="kc">self</span><span class="p">.</span><span class="n">x</span> <span class="p">=</span> <span class="n">x</span> 
        <span class="kc">self</span><span class="p">.</span><span class="n">y</span> <span class="p">=</span> <span class="n">y</span> 
        <span class="kc">self</span><span class="p">.</span><span class="n">z</span> <span class="p">=</span> <span class="n">z</span> 
    <span class="p">}</span>

    <span class="kd">static</span> <span class="kd">func</span> <span class="p">==</span> <span class="p">(</span><span class="n">izquierda</span><span class="p">:</span> <span class="n">Punto3D</span><span class="p">,</span> <span class="n">derecha</span><span class="p">:</span> <span class="n">Punto3D</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Bool</span> <span class="p">{</span>
        <span class="k">return</span>
            <span class="n">izquierda</span><span class="p">.</span><span class="n">x</span> <span class="p">==</span> <span class="n">derecha</span><span class="p">.</span><span class="n">x</span> <span class="o">&amp;&amp;</span>
            <span class="n">izquierda</span><span class="p">.</span><span class="n">y</span> <span class="p">==</span> <span class="n">derecha</span><span class="p">.</span><span class="n">y</span> <span class="o">&amp;&amp;</span>
            <span class="n">izquierda</span><span class="p">.</span><span class="n">z</span> <span class="p">==</span> <span class="n">derecha</span><span class="p">.</span><span class="n">z</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nv">p1</span> <span class="p">=</span> <span class="n">Punto3D</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">z</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">)</span>
<span class="kd">let</span> <span class="nv">p2</span> <span class="p">=</span> <span class="n">Punto3D</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">z</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">)</span>

<span class="bp">print</span><span class="p">(</span><span class="n">p1</span> <span class="p">==</span> <span class="n">p2</span><span class="p">)</span>
<span class="c1">// Imprime true</span>
<span class="bp">print</span><span class="p">(</span><span class="n">p1</span> <span class="o">!=</span> <span class="n">p2</span><span class="p">)</span>
<span class="c1">// Imprime false</span>
</pre></div>
</td></tr></table>

<p>El operador <code>==</code> se define en la propia estructura. Se utiliza la
palabra <code>static</code> para indicar que se trata de un operador que estamos
sobrecargando (hablaremos más adelante de los operadores).</p>
<p>El operador <code>!=</code> que se usa en la última instrucción se define en una
implementación por defecto.</p>
<p>En <strong>Swift 5</strong> el compilador define una <strong>implementación automática
del operador <code>==</code> en las estructuras y enumeraciones</strong> al añadir el
protocolo <code>Equatable</code>, siempre que las propiedades almacenadas y los
valores asociados cumplan ese protocolo.</p>
<p>Por ejemplo, si en lugar de una clase definimos un <code>struct Punto3D</code> el
código quedaría como sigue (no es necesario definir ni el
inicializador por defecto ni el operador <code>==</code>):</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">struct</span> <span class="nc">Punto3D</span><span class="p">:</span> <span class="nb">Equatable</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nv">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">:</span> <span class="nb">Double</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nv">p1</span> <span class="p">=</span> <span class="n">Punto3D</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">z</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">)</span>
<span class="kd">let</span> <span class="nv">p2</span> <span class="p">=</span> <span class="n">Punto3D</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">z</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">)</span>

<span class="bp">print</span><span class="p">(</span><span class="n">p1</span> <span class="p">==</span> <span class="n">p2</span><span class="p">)</span>
<span class="c1">// Imprime true</span>
<span class="bp">print</span><span class="p">(</span><span class="n">p1</span> <span class="o">!=</span> <span class="n">p2</span><span class="p">)</span>
<span class="c1">// Imprime false</span>
</pre></div>
</td></tr></table>

<h2 id="casting-de-tipos">Casting de tipos<a class="headerlink" href="#casting-de-tipos" title="Permanent link">&para;</a></h2>
<p>El <em>casting</em> de tipos es una forma de comprobar el tipo de una
instancia o de tratar esa instancia como de una superclase distinta o
conseguir una subclase de algún otro sitio en la propia jerarquía de
clase. La forma de implementarlo es utilizando los operadores <code>is</code> y
<code>as</code>. Estos operadores proporcionan una forma simple y expresiva de
comprobar el tipo de un valor o transformar un valor en uno de otro
tipo. También se puede usar el <em>casting</em> de tipos para comprobar si un
tipo se ajusta a un protocolo.</p>
<h3 id="una-jerarquia-de-clases-para-el-casting-de-tipos">Una jerarquía de clases para el casting de tipos<a class="headerlink" href="#una-jerarquia-de-clases-para-el-casting-de-tipos" title="Permanent link">&para;</a></h3>
<p>Vamos a comenzar construyendo una jerarquía de clases y subclases con
las que trabajar. Utilizaremos el <em>casting</em> de tipos para comprobar el
tipo de una instancia particular de una clase y para convertir esa
instancia en otra clase dentro de la misma jerarquía.</p>
<p>En el primer fragmento de código definimos una clase nueva llamada
<code>MediaItem</code>. Esta clase proporciona la funcionalidad básica de
cualquier tipo de ítem que aparece en una biblioteca de medios
digitales. Específicamente, declara una propiedad <code>nombre</code> de tipo
<code>String</code> y un inicializador <code>init nombre</code> (suponemos que todos los
ítems, incluyendo películas y canciones, tendrán un nombre).</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">class</span> <span class="nc">MediaItem</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">nombre</span><span class="p">:</span> <span class="nb">String</span>
    <span class="kd">init</span><span class="p">(</span><span class="n">nombre</span><span class="p">:</span> <span class="nb">String</span><span class="p">)</span> <span class="p">{</span>
        <span class="kc">self</span><span class="p">.</span><span class="n">nombre</span> <span class="p">=</span> <span class="n">nombre</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<p>El siguiente fragmento define dos subclases de <code>MediaItem</code>. La primera
subclase, <code>Pelicula</code>, encapsula información adicional sobre una
película. Añade una propiedad <code>director</code> a la clase base <code>MediaItem</code>,
con su correspondiente inicializador. La segunda subclase, <code>Cancion</code>,
añade una propiedad <code>artista</code> y un inicializador a la clase base:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">class</span> <span class="nc">Pelicula</span><span class="p">:</span> <span class="n">MediaItem</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">director</span><span class="p">:</span> <span class="nb">String</span>
    <span class="kd">init</span><span class="p">(</span><span class="n">nombre</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span> <span class="n">director</span><span class="p">:</span> <span class="nb">String</span><span class="p">)</span> <span class="p">{</span>
        <span class="kc">self</span><span class="p">.</span><span class="n">director</span> <span class="p">=</span> <span class="n">director</span>
        <span class="kc">super</span><span class="p">.</span><span class="kd">init</span><span class="p">(</span><span class="n">nombre</span><span class="p">:</span> <span class="n">nombre</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nc">Cancion</span><span class="p">:</span> <span class="n">MediaItem</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">artista</span><span class="p">:</span> <span class="nb">String</span>
    <span class="kd">init</span><span class="p">(</span><span class="n">nombre</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span> <span class="n">artista</span><span class="p">:</span> <span class="nb">String</span><span class="p">)</span> <span class="p">{</span>
        <span class="kc">self</span><span class="p">.</span><span class="n">artista</span> <span class="p">=</span> <span class="n">artista</span>
        <span class="kc">super</span><span class="p">.</span><span class="kd">init</span><span class="p">(</span><span class="n">nombre</span><span class="p">:</span> <span class="n">nombre</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<p>Por último, creamos un array constante llamado <code>biblioteca</code>, que
contienen dos instancias de <code>Pelicula</code> y tres instancias de
<code>Cancion</code>. </p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">let</span> <span class="nv">biblioteca</span><span class="p">:</span> <span class="p">[</span><span class="n">MediaItem</span><span class="p">]</span> <span class="p">=</span> <span class="p">[</span>
    <span class="n">Pelicula</span><span class="p">(</span><span class="n">nombre</span><span class="p">:</span> <span class="s">&quot;El Señor de los Anillos&quot;</span><span class="p">,</span> <span class="n">director</span><span class="p">:</span> <span class="s">&quot;Peter Jackson&quot;</span><span class="p">),</span>
    <span class="n">Cancion</span><span class="p">(</span><span class="n">nombre</span><span class="p">:</span> <span class="s">&quot;Child in Time&quot;</span><span class="p">,</span> <span class="n">artista</span><span class="p">:</span> <span class="s">&quot;Deep Purple&quot;</span><span class="p">),</span>
    <span class="n">Pelicula</span><span class="p">(</span><span class="n">nombre</span><span class="p">:</span> <span class="s">&quot;El Puente de los Espías&quot;</span><span class="p">,</span> <span class="n">director</span><span class="p">:</span> <span class="s">&quot;Steven Spielberg&quot;</span><span class="p">),</span>
    <span class="n">Cancion</span><span class="p">(</span><span class="n">nombre</span><span class="p">:</span> <span class="s">&quot;I Wish You Were Here&quot;</span><span class="p">,</span> <span class="n">artista</span><span class="p">:</span> <span class="s">&quot;Pink Floyd&quot;</span><span class="p">),</span>
    <span class="n">Cancion</span><span class="p">(</span><span class="n">nombre</span><span class="p">:</span> <span class="s">&quot;Yellow&quot;</span><span class="p">,</span> <span class="n">artista</span><span class="p">:</span> <span class="s">&quot;Coldplay&quot;</span><span class="p">)</span>
<span class="p">]</span>
</pre></div>
</td></tr></table>

<p>Podríamos también dejar que el compilador infiera el tipo del
array. Es capaz de deducir que <code>Pelicula</code> y <code>Cancion</code> tienen una
superclase común <code>MediaItem</code>, por lo que <strong>infiere que el tipo del
array es <code>[MediaItem]</code></strong>:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="c1">// Declaración equivalente a la anterior</span>
<span class="kd">let</span> <span class="nv">biblioteca</span>  <span class="p">=</span> <span class="p">[</span>
    <span class="n">Pelicula</span><span class="p">(</span><span class="n">nombre</span><span class="p">:</span> <span class="s">&quot;El Señor de los Anillos&quot;</span><span class="p">,</span> <span class="n">director</span><span class="p">:</span> <span class="s">&quot;Peter Jackson&quot;</span><span class="p">),</span>
    <span class="n">Cancion</span><span class="p">(</span><span class="n">nombre</span><span class="p">:</span> <span class="s">&quot;Child in Time&quot;</span><span class="p">,</span> <span class="n">artista</span><span class="p">:</span> <span class="s">&quot;Deep Purple&quot;</span><span class="p">),</span>
    <span class="n">Pelicula</span><span class="p">(</span><span class="n">nombre</span><span class="p">:</span> <span class="s">&quot;El Puente de los Espías&quot;</span><span class="p">,</span> <span class="n">director</span><span class="p">:</span> <span class="s">&quot;Steven Spielberg&quot;</span><span class="p">),</span>
    <span class="n">Cancion</span><span class="p">(</span><span class="n">nombre</span><span class="p">:</span> <span class="s">&quot;I Wish You Were Here&quot;</span><span class="p">,</span> <span class="n">artista</span><span class="p">:</span> <span class="s">&quot;Pink Floyd&quot;</span><span class="p">),</span>
    <span class="n">Cancion</span><span class="p">(</span><span class="n">nombre</span><span class="p">:</span> <span class="s">&quot;Yellow&quot;</span><span class="p">,</span> <span class="n">artista</span><span class="p">:</span> <span class="s">&quot;Coldplay&quot;</span><span class="p">)</span>
<span class="p">]</span>
</pre></div>
</td></tr></table>

<p>Los ítems almacenados en la biblioteca son todavía instancias de
<code>Pelicula</code> y <code>Cancion</code>. Sin embargo, si iteramos sobre los contenidos
de este array, los ítems que recibiremos tendrán el tipo <code>MediaItem</code> y
no <code>Pelicula</code> o <code>Cancion</code>. Para trabajar con ellos como su tipo
nativo, debemos chequear su tipo, y hacer un <em>downcast</em> a su tipo
concreto.</p>
<h3 id="comprobacion-del-tipo">Comprobación del tipo<a class="headerlink" href="#comprobacion-del-tipo" title="Permanent link">&para;</a></h3>
<p>Podemos usar el <em>operador de comprobación</em> (<em>check operator</em>) <code>is</code>
para comprobar si una instancia es de un cierto tipo subclase. El
operador de comprobación devuelve <code>true</code> si la instancia es del tipo
de la subclase y <code>false</code> si no.</p>
<p>Lo podemos comprobar en el siguiente ejemplo, en el que contamos las
instancias de películas y canciones en el array <code>biblioteca</code>:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">var</span> <span class="nv">contadorPeliculas</span> <span class="p">=</span> <span class="mi">0</span>
<span class="kd">var</span> <span class="nv">contadorCanciones</span> <span class="p">=</span> <span class="mi">0</span>

<span class="k">for</span> <span class="n">item</span> <span class="k">in</span> <span class="n">biblioteca</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">item</span> <span class="k">is</span> <span class="n">Pelicula</span> <span class="p">{</span>
        <span class="n">contadorPeliculas</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">item</span> <span class="k">is</span> <span class="n">Cancion</span> <span class="p">{</span>
        <span class="n">contadorCanciones</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="bp">print</span><span class="p">(</span><span class="s">&quot;La biblioteca contiene </span><span class="si">\(</span><span class="n">contadorCanciones</span><span class="si">)</span><span class="s"> películas y </span><span class="si">\(</span><span class="n">contadorPeliculas</span><span class="si">)</span><span class="s"> canciones&quot;</span><span class="p">)</span>
<span class="c1">// Imprime &quot;La biblioteca contiene 3 películas y 2 canciones&quot;</span>
</pre></div>
</td></tr></table>

<p>El ejemplo itera por todos los ítems del array <code>biblioteca</code>. En cada
paso, el bucle <code>for-in</code> guarda en la constante <code>item</code> el siguiente
<code>MediaItem</code> del array.</p>
<p>La instrucción <code>item is Pelicula</code> devuelve <code>true</code> si el <code>MediaItem</code>
actual es una instancia de <code>Pelicula</code> y <code>false</code> en otro caso. De forma
similar, <code>item is Cancion</code> comprueba si el ítem es una instancia de
<code>Cancion</code>. Al final del bucle <code>for-in</code>, los valores de
<code>contadorPeliculas</code> y <code>contadorCanciones</code> contendrán una cuenta de
cuantas instancias <code>MediaItem</code> de cada tipo se han encontrado.</p>
<h3 id="downcasting">Downcasting<a class="headerlink" href="#downcasting" title="Permanent link">&para;</a></h3>
<p>Una constante o variable de un cierto tipo de clase puede referirse
(contener) a una instancia de una subclase. Cuando creemos que sucede
esto, podemos intentar hacer un <em>downcast</em> al tipo de la subclase con
un operador de <em>cast</em> (<code>as?</code> o <code>as!</code>). Como el <em>downcast</em> puede
fallar, la versión condicional, <code>as?</code>, devuelve un valor opcional del
tipo al que estamos intentando hacer el <em>downcasting</em>. La versión
forzosa, <code>as!</code>, intenta el <em>downcast</em> y fuerza la desenvoltura del
resultado en un única acción compuesta.</p>
<p>Debemos usar la versión condicional (<code>as?</code>) cuando no estamos seguros
si el <em>downcast</em> tendrá éxito. Se devolverá un valor opcional y el
valor será <code>nil</code> si no es posible hacer el <em>downcast</em>. Esto permitirá
comprobar si ha habido un <em>downcast</em> con éxito.</p>
<p>La otra versión (<code>as!</code>) se usa sólo cuando estamos seguros de que el
<em>downcast</em> tendrá éxito. Esta versión del operador lanzará un error en
tiempo de ejecución si intentamos hacer un <em>downcast</em> a un tipo
incorrecto.</p>
<p>El siguiente ejemplo itera sobre cada <code>MediaItem</code> en <code>biblioteca</code>, e
imprime una descripción apropiada para cada ítem. Para hacerlo,
necesita acceder a cada ítem como una <code>Pelicula</code> o <code>Cancion</code> y no sólo
como una <code>MediaItem</code>. Esto es necesario para poder acceder a la
propiedad <code>director</code> o <code>artista</code> de una instancia de <code>Pelicula</code> o
<code>Cancion</code>.</p>
<p>En este ejemplo, cada ítem en el array podría ser un <code>Pelicula</code> o
podría ser una <code>Cancion</code>. No sabemos por anticipado la clase verdadera
de cada ítem, por lo que es apropiado usar la versión condicional
(<code>as?</code>) para comprobar el <em>downcast</em> cada vez a lo largo del bucle:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="k">for</span> <span class="n">item</span> <span class="k">in</span> <span class="n">biblioteca</span> <span class="p">{</span>
    <span class="k">if</span> <span class="kd">let</span> <span class="nv">pelicula</span> <span class="p">=</span> <span class="n">item</span> <span class="k">as</span><span class="p">?</span> <span class="n">Pelicula</span> <span class="p">{</span>
        <span class="bp">print</span><span class="p">(</span><span class="s">&quot;Película: </span><span class="si">\(</span><span class="n">pelicula</span><span class="p">.</span><span class="n">nombre</span><span class="si">)</span><span class="s">, dir. </span><span class="si">\(</span><span class="n">pelicula</span><span class="p">.</span><span class="n">director</span><span class="si">)</span><span class="s">&quot;</span><span class="p">)</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="kd">let</span> <span class="nv">cancion</span> <span class="p">=</span> <span class="n">item</span> <span class="k">as</span><span class="p">?</span> <span class="n">Cancion</span> <span class="p">{</span>
        <span class="bp">print</span><span class="p">(</span><span class="s">&quot;Cancion: </span><span class="si">\(</span><span class="n">cancion</span><span class="p">.</span><span class="n">nombre</span><span class="si">)</span><span class="s">, de </span><span class="si">\(</span><span class="n">cancion</span><span class="p">.</span><span class="n">artista</span><span class="si">)</span><span class="s">&quot;</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Película: El Señor de los Anillos, dir. Peter Jackson</span>
<span class="c1">// Cancion: Child in Time, de Deep Purple</span>
<span class="c1">// Película: El Puente de los Espías, dir. Steven Spielberg</span>
<span class="c1">// Cancion: I Wish You Were Here, de Pink Floyd</span>
<span class="c1">// Cancion: Yellow, de Coldplay</span>
</pre></div>
</td></tr></table>

<p>El ejemplo comienza intentando hacer <code>downcast</code> del ítem a una
<code>Pelicula</code>. Debido a que es una instancia de <code>MediaItme</code>, es posible
que sea un <code>Pelicula</code> o una <code>Cancion</code>, o incluso el tipo base
<code>MediaItem</code>. Debido a esta incertidumbre, debemos usar la versión
<code>as?</code> para devolver un valor opcional. El resultado será una "Pelicula
opcional". Podemos desenvolver el valor <code>Pelicula</code> usando un <code>if let</code>
como vimos en el apartado de opcionales. Si tiene éxito el
<em>downcasting</em>, las propiedades de la película se pueden usar para
imprimir una descripción de la película llamando a los
correspondientes métodos de la clase <code>Pelicula</code>. Igual con <code>Cancion</code>.</p>
<h3 id="el-tipo-any">El tipo <code>Any</code><a class="headerlink" href="#el-tipo-any" title="Permanent link">&para;</a></h3>
<p>El tipo <code>Any</code> puede representar una instancia de cualquier tipo,
incluyendo tipos función:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">var</span> <span class="nv">array</span> <span class="p">=</span> <span class="p">[</span><span class="nb">Any</span><span class="p">]()</span>

<span class="n">array</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">array</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)</span>
<span class="n">array</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="n">array</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="mf">3.14159</span><span class="p">)</span>
<span class="n">array</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="s">&quot;hola&quot;</span><span class="p">)</span>
<span class="n">array</span><span class="p">.</span><span class="n">append</span><span class="p">((</span><span class="mf">3.0</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">))</span>
<span class="n">array</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">Pelicula</span><span class="p">(</span><span class="n">nombre</span><span class="p">:</span> <span class="s">&quot;Ghostbusters&quot;</span><span class="p">,</span> <span class="n">director</span><span class="p">:</span> <span class="s">&quot;Ivan Reitman&quot;</span><span class="p">))</span>
<span class="n">array</span><span class="p">.</span><span class="n">append</span><span class="p">({</span> <span class="p">(</span><span class="n">name</span><span class="p">:</span> <span class="nb">String</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">String</span> <span class="k">in</span> <span class="s">&quot;Hola, </span><span class="si">\(</span><span class="n">name</span><span class="si">)</span><span class="s">&quot;</span> <span class="p">})</span>
</pre></div>
</td></tr></table>

<p>El array contiene dos valores <code>Int</code>, dos valores <code>Double</code>, un valor
<code>String</code>, una tupla del tipo <code>(Double, Double)</code>, la película
"Ghostbusters", y una clausura que toma un <code>String</code> y devuelve otro
<code>String</code>.</p>
<p>Puedes usar los operadores <code>is</code> y <code>as</code> en una sentencia <code>switch</code> para
descubrir en tiempo de ejecución el tipo específico de una constante o
variable de la que sólo se sabe que es de tipo <code>Any</code>:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="k">for</span> <span class="n">item</span> <span class="k">in</span> <span class="n">array</span> <span class="p">{</span>
    <span class="k">switch</span> <span class="n">item</span> <span class="p">{</span>
    <span class="k">case</span> <span class="mi">0</span> <span class="k">as</span> <span class="nb">Int</span><span class="p">:</span>
        <span class="bp">print</span><span class="p">(</span><span class="s">&quot;cero como un Int&quot;</span><span class="p">)</span>
    <span class="k">case</span> <span class="mi">0</span> <span class="k">as</span> <span class="nb">Double</span><span class="p">:</span>
        <span class="bp">print</span><span class="p">(</span><span class="s">&quot;cero como un Double&quot;</span><span class="p">)</span>
    <span class="k">case</span> <span class="kd">let</span> <span class="nv">someInt</span> <span class="k">as</span> <span class="nb">Int</span><span class="p">:</span>
        <span class="bp">print</span><span class="p">(</span><span class="s">&quot;un valor entero de </span><span class="si">\(</span><span class="n">someInt</span><span class="si">)</span><span class="s">&quot;</span><span class="p">)</span>
    <span class="k">case</span> <span class="kd">let</span> <span class="nv">unDouble</span> <span class="k">as</span> <span class="nb">Double</span> <span class="k">where</span> <span class="n">unDouble</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="bp">print</span><span class="p">(</span><span class="s">&quot;a valor positivo de </span><span class="si">\(</span><span class="n">unDouble</span><span class="si">)</span><span class="s">&quot;</span><span class="p">)</span>
    <span class="k">case</span> <span class="k">is</span> <span class="nb">Double</span><span class="p">:</span>
        <span class="bp">print</span><span class="p">(</span><span class="s">&quot;algún otro valor double que no quiero imprimir&quot;</span><span class="p">)</span>
    <span class="k">case</span> <span class="kd">let</span> <span class="nv">someString</span> <span class="k">as</span> <span class="nb">String</span><span class="p">:</span>
        <span class="bp">print</span><span class="p">(</span><span class="s">&quot;una cadena con valor de </span><span class="se">\&quot;</span><span class="si">\(</span><span class="n">someString</span><span class="si">)</span><span class="se">\&quot;</span><span class="s">&quot;</span><span class="p">)</span>
    <span class="k">case</span> <span class="kd">let</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="k">as</span> <span class="p">(</span><span class="nb">Double</span><span class="p">,</span> <span class="nb">Double</span><span class="p">):</span>
        <span class="bp">print</span><span class="p">(</span><span class="s">&quot;un punto (x, y) en </span><span class="si">\(</span><span class="n">x</span><span class="si">)</span><span class="s">, </span><span class="si">\(</span><span class="n">y</span><span class="si">)</span><span class="s">&quot;</span><span class="p">)</span>
    <span class="k">case</span> <span class="kd">let</span> <span class="nv">pelicula</span> <span class="k">as</span> <span class="n">Pelicula</span><span class="p">:</span>
        <span class="bp">print</span><span class="p">(</span><span class="s">&quot;una película: </span><span class="si">\(</span><span class="n">pelicula</span><span class="p">.</span><span class="n">nombre</span><span class="si">)</span><span class="s">, dir. </span><span class="si">\(</span><span class="n">pelicula</span><span class="p">.</span><span class="n">director</span><span class="si">)</span><span class="s">&quot;</span><span class="p">)</span>
    <span class="k">case</span> <span class="kd">let</span> <span class="nv">stringConverter</span> <span class="k">as</span> <span class="p">(</span><span class="nb">String</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">String</span><span class="p">:</span>
        <span class="bp">print</span><span class="p">(</span><span class="n">stringConverter</span><span class="p">(</span><span class="s">&quot;Michael&quot;</span><span class="p">))</span>
    <span class="k">default</span><span class="p">:</span>
        <span class="bp">print</span><span class="p">(</span><span class="s">&quot;alguna otra cosa&quot;</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// cero como un Int</span>
<span class="c1">// cero como un Double</span>
<span class="c1">// un valor entero de 42</span>
<span class="c1">// a valor positivo de 3.14159</span>
<span class="c1">// una cadena con valor de &quot;hola&quot;</span>
<span class="c1">// un punto (x, y) en 3.0, 5.0</span>
<span class="c1">// una película: Ghostbusters, dir. Ivan Reitman</span>
<span class="c1">// Hola, Michael</span>
</pre></div>
</td></tr></table>

<h3 id="comprobacion-de-ajustarse-a-un-protocolo">Comprobación de ajustarse a un protocolo<a class="headerlink" href="#comprobacion-de-ajustarse-a-un-protocolo" title="Permanent link">&para;</a></h3>
<p>Podemos usar también los operadores anteriores <code>is</code> y <code>as</code> (y <code>as?</code> y
<code>as!</code>) para comprobar si una instancia se ajusta a un protocolo y para
hacer un <em>cast</em> a un protocolo específico.</p>
<p>Veamos un ejemplo. Definimos el protocolo <code>TieneArea</code> con el único
requisito de una propiedad de lectura llamada <code>area</code> de tipo <code>Double</code>:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">protocol</span> <span class="nc">TieneArea</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">area</span><span class="p">:</span> <span class="nb">Double</span> <span class="p">{</span> <span class="kr">get</span> <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<p>Definimos dos clases <code>Circulo</code> y <code>Pais</code> que se ajustan ambos al protocolo: </p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">class</span> <span class="nc">Circulo</span><span class="p">:</span> <span class="n">TieneArea</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nv">pi</span> <span class="p">=</span> <span class="mf">3.1415927</span>
    <span class="kd">var</span> <span class="nv">radio</span><span class="p">:</span> <span class="nb">Double</span>
    <span class="kd">var</span> <span class="nv">area</span><span class="p">:</span> <span class="nb">Double</span> <span class="p">{</span> <span class="k">return</span> <span class="n">pi</span> <span class="o">*</span> <span class="n">radio</span> <span class="o">*</span> <span class="n">radio</span> <span class="p">}</span>
    <span class="kd">init</span><span class="p">(</span><span class="n">radio</span><span class="p">:</span> <span class="nb">Double</span><span class="p">)</span> <span class="p">{</span> <span class="kc">self</span><span class="p">.</span><span class="n">radio</span> <span class="p">=</span> <span class="n">radio</span> <span class="p">}</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nc">Pais</span><span class="p">:</span> <span class="n">TieneArea</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">area</span><span class="p">:</span> <span class="nb">Double</span>
    <span class="kd">init</span><span class="p">(</span><span class="n">area</span><span class="p">:</span> <span class="nb">Double</span><span class="p">)</span> <span class="p">{</span> <span class="kc">self</span><span class="p">.</span><span class="n">area</span> <span class="p">=</span> <span class="n">area</span> <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<p>La clase <code>Circulo</code> implementa el requisito como una propiedad
calculada, basada en la propiedad almacenada <code>radio</code>. La clase <code>Pais</code>
implementa el requisito directamente como una propiedad
almacenada. Ambas clases se ajustan correctamente al protocolo
<code>TieneArea</code>.</p>
<p>Definimos una clase <code>Animal</code> que no se ajusta al protocolo:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">class</span> <span class="nc">Animal</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">patas</span><span class="p">:</span> <span class="nb">Int</span>
    <span class="kd">init</span><span class="p">(</span><span class="n">patas</span><span class="p">:</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">{</span> <span class="kc">self</span><span class="p">.</span><span class="n">patas</span> <span class="p">=</span> <span class="n">patas</span> <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<p>Las clases <code>Circulo</code>, <code>Pais</code> y <code>Animal</code> no tienen ninguna clase base
compartida. Sin embargo, todas son clases, por lo que las instancias
de los tres tipos pueden usarse para inicializar un array que almacena
valores de tipo <code>Any</code>:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">let</span> <span class="nv">objetos</span><span class="p">:</span> <span class="p">[</span><span class="nb">Any</span><span class="p">]</span> <span class="p">=</span> <span class="p">[</span>
    <span class="n">Circulo</span><span class="p">(</span><span class="n">radio</span><span class="p">:</span> <span class="mf">2.0</span><span class="p">),</span>
    <span class="n">Pais</span><span class="p">(</span><span class="n">area</span><span class="p">:</span> <span class="mi">243_610</span><span class="p">),</span>
    <span class="n">Animal</span><span class="p">(</span><span class="n">patas</span><span class="p">:</span> <span class="mi">4</span><span class="p">)</span>
<span class="p">]</span>
</pre></div>
</td></tr></table>

<p>Y ahora podemos iterar sobre el array de objetos, comprobando para
cada ítem si la instancia se ajusta al protocolo <code>TieneArea</code>:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="k">for</span> <span class="n">objecto</span> <span class="k">in</span> <span class="n">objetos</span> <span class="p">{</span>
    <span class="k">if</span> <span class="kd">let</span> <span class="nv">objetoConArea</span> <span class="p">=</span> <span class="n">objecto</span> <span class="k">as</span><span class="p">?</span> <span class="n">TieneArea</span> <span class="p">{</span>
        <span class="bp">print</span><span class="p">(</span><span class="s">&quot;El área es </span><span class="si">\(</span><span class="n">objetoConArea</span><span class="p">.</span><span class="n">area</span><span class="si">)</span><span class="s">&quot;</span><span class="p">)</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="bp">print</span><span class="p">(</span><span class="s">&quot;Algo que no tiene un área&quot;</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// El área es 12.5663708</span>
<span class="c1">// El área es 243610.0</span>
<span class="c1">// Algo que no tiene un área</span>
</pre></div>
</td></tr></table>

<p>Cuando un objeto en el array se ajusta al protocolo <code>TieneArea</code>, el
valor opcional devuelto por el operador <code>as?</code> se desenvuelve con un
ligado opcional en una constante llamada <code>objetoConArea</code>. Esta
constante tiene el tipo <code>TieneArea</code>, por lo que su propiedad <code>area</code>
podrá ser accedida e impresa.</p>
<p>Hay que notar que los objetos subyacentes no cambian en el proceso de
<em>casting</em>. Siguen siendo un <code>Circulo</code>, un <code>Pais</code> y un <code>Animal</code>. Sin
embargo, en el momento en se almacenan en la constante
<code>objetoConArea</code>, sólo se sabe que son del tipo <code>TieneArea</code>, por lo que
sólo podremos acceder a su propiedad <code>area</code>.</p>
<h2 id="extensiones">Extensiones<a class="headerlink" href="#extensiones" title="Permanent link">&para;</a></h2>
<p>Las <em>extensiones</em> añaden nueva funcionalidad a una clase, estructura,
enumeración o protocolo. Esto incluye la posibilidad de extender tipos
para los que no tenemos acceso al código fuente original (esto se
conoce como <em>modelado retroactivo</em>).</p>
<p>Entre otras cosas, las extensiones pueden: </p>
<ul>
<li>Añadir <strong>propiedades calculadas</strong> de instancia y de tipo</li>
<li>Definir métodos de instancia y de tipo</li>
<li>Proporcionar nuevos inicializadores</li>
<li>Hacer que un tipo existente se ajuste a un protocolo</li>
</ul>
<h3 id="sintaxis_1">Sintaxis<a class="headerlink" href="#sintaxis_1" title="Permanent link">&para;</a></h3>
<p>Para declarar una extensión hay que usar la palabra clave <code>extension</code>,
indicando después el tipo que se quiere extender (enumeración, clase,
estructura o protocolo)</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">extension</span> <span class="nc">UnTipoExistente</span> <span class="p">{</span>
    <span class="c1">// nueva funcionalidad para añadir a UnTipo</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<h3 id="propiedades-calculadas_1">Propiedades calculadas<a class="headerlink" href="#propiedades-calculadas_1" title="Permanent link">&para;</a></h3>
<p>Las extensiones pueden añadir propiedades calculadas de instancias y
de tipos. Como primer ejemplo, recordemos el tipo <code>Persona</code>:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">protocol</span> <span class="nc">TieneNombre</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">nombreCompleto</span><span class="p">:</span> <span class="nb">String</span> <span class="p">{</span> <span class="kr">get</span> <span class="p">}</span>
<span class="p">}</span>

<span class="kd">struct</span> <span class="nc">Persona</span><span class="p">:</span> <span class="n">TieneNombre</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">edad</span><span class="p">:</span> <span class="nb">Int</span>
    <span class="kd">var</span> <span class="nv">nombreCompleto</span><span class="p">:</span> <span class="nb">String</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<p>Vamos a añadir a la estructura la propiedad calculada <code>mayorEdad</code>, un
<code>Bool</code> que indica si la edad de la persona es mayor o igual de 18:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">extension</span> <span class="nc">Persona</span> <span class="p">{</span>
   <span class="kd">var</span> <span class="nv">mayorEdad</span><span class="p">:</span> <span class="nb">Bool</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">edad</span> <span class="o">&gt;=</span> <span class="mi">18</span>
   <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<p>Una vez definida esta extensión, hemos ampliado la clase con esta
nueva propiedad, sin modificar el código inicial con la definición de
la clase. </p>
<p>Podemos preguntar si una persona es mayor de edad:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">var</span> <span class="nv">p</span> <span class="p">=</span> <span class="n">Persona</span><span class="p">(</span><span class="n">edad</span><span class="p">:</span> <span class="mi">15</span><span class="p">,</span> <span class="n">nombreCompleto</span><span class="p">:</span> <span class="s">&quot;Lucía&quot;</span><span class="p">)</span>
<span class="n">p</span><span class="p">.</span><span class="n">mayorEdad</span> <span class="c1">// false</span>
</pre></div>
</td></tr></table>

<p>Es posible incluso extender clases de las librerías estándar de
Swift, como <code>Int</code>, <code>Double</code>, <code>Array</code>, etc.</p>
<p>Por ejemplo, podemos añadir propiedades calculadas a la clase Double
para trabajar con unidades de distancia. Las siguientes propiedades
convierten una cantidad en las unidades correspondientes a su
equivalente en metros:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">extension</span> <span class="nc">Double</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">km</span><span class="p">:</span> <span class="nb">Double</span> <span class="p">{</span> <span class="k">return</span> <span class="kc">self</span> <span class="o">*</span> <span class="mf">1_000.0</span> <span class="p">}</span>
    <span class="kd">var</span> <span class="nv">m</span><span class="p">:</span> <span class="nb">Double</span> <span class="p">{</span> <span class="k">return</span> <span class="kc">self</span> <span class="p">}</span>
    <span class="kd">var</span> <span class="nv">cm</span><span class="p">:</span> <span class="nb">Double</span> <span class="p">{</span> <span class="k">return</span> <span class="kc">self</span> <span class="o">/</span> <span class="mf">100.0</span> <span class="p">}</span>
    <span class="kd">var</span> <span class="nv">mm</span><span class="p">:</span> <span class="nb">Double</span> <span class="p">{</span> <span class="k">return</span> <span class="kc">self</span> <span class="o">/</span> <span class="mf">1_000.0</span> <span class="p">}</span>
    <span class="kd">var</span> <span class="nv">ft</span><span class="p">:</span> <span class="nb">Double</span> <span class="p">{</span> <span class="k">return</span> <span class="kc">self</span> <span class="o">/</span> <span class="mf">3.28084</span> <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<p>Una vez definida la extensión, podemos usarla en cualquier variable
<code>Double</code>. Incluso la podemos usar en literales:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">let</span> <span class="nv">distancia</span> <span class="p">=</span> <span class="mf">11.</span><span class="n">km</span>
<span class="c1">// En distancia tendremos 11000 metros</span>
<span class="kd">let</span> <span class="nv">unaPulgada</span> <span class="p">=</span> <span class="mf">25.4</span><span class="p">.</span><span class="n">mm</span>
<span class="bp">print</span><span class="p">(</span><span class="s">&quot;Una pulgada es </span><span class="si">\(</span><span class="n">unaPulgada</span><span class="si">)</span><span class="s"> metros&quot;</span><span class="p">)</span>
<span class="c1">// Una pulgada es 0.0254 metros</span>
<span class="kd">let</span> <span class="nv">tresPies</span> <span class="p">=</span> <span class="mf">3.</span><span class="n">ft</span>
<span class="bp">print</span><span class="p">(</span><span class="s">&quot;Tres pies son </span><span class="si">\(</span><span class="n">tresPies</span><span class="si">)</span><span class="s"> metros&quot;</span><span class="p">)</span>
<span class="c1">// Tres pies son 0.914399970739201 metros</span>
</pre></div>
</td></tr></table>

<p>Por ejemplo, cuando se escribe <code>11.km</code> se pide el valor de la
propiedad calculada <code>km</code> de la instancia <code>11</code>. La propiedad calculada
devuelve el resultado de multiplicar <code>11</code> por <code>1000</code>, esto es, los
metros correspondientes a 11 kilómetros.</p>
<p>De forma similar, hay 3.28084 pies en un metro, por lo que la
propiedad calculada <code>ft</code> divide el valor <code>Double</code> subyacente por
3.28084, para conventirlo de pies a metros.</p>
<p>Estas propiedades son propiedades calculadas de solo lectura, por lo
que se expresan sin la palabra clave <code>get</code>, por brevedad. Sus valores
devueltos son de tipo <code>Double</code>, y pueden usarse en cálculos
matemáticos en cualquier sitio que se acepte un <code>Double</code>:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">let</span> <span class="nv">unMaraton</span> <span class="p">=</span> <span class="mf">42.</span><span class="n">km</span> <span class="o">+</span> <span class="mf">195.</span><span class="n">m</span>
<span class="bp">print</span><span class="p">(</span><span class="s">&quot;Un maratón tiene una longitud de </span><span class="si">\(</span><span class="n">unMaraton</span><span class="si">)</span><span class="s"> metros&quot;</span><span class="p">)</span>
<span class="c1">// Un maratón tiene una longitud de 42195.0 metros</span>
</pre></div>
</td></tr></table>

<h3 id="inicializadores">Inicializadores<a class="headerlink" href="#inicializadores" title="Permanent link">&para;</a></h3>
<p>Las extensiones pueden añadir nuevos inicializadores a tipos
existentes. Esto nos permite extender otros tipos para aceptar
nuestros propios tipos como parámetros de la inicialización, o para
proporcionar opciones adicionales que no estaban incluidos en la
implementación original del tipo.</p>
<p>Recordemos la estructura <code>Rectangulo</code>, definida por un <code>Punto</code> y un
<code>Tamaño</code>. Supongamos que la definimos sin inicializadores:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">struct</span> <span class="nc">Tamaño</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">ancho</span> <span class="p">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">alto</span> <span class="p">=</span> <span class="mf">0.0</span>
<span class="p">}</span>
<span class="kd">struct</span> <span class="nc">Punto</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">x</span> <span class="p">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">y</span> <span class="p">=</span> <span class="mf">0.0</span>
<span class="p">}</span>
<span class="kd">struct</span> <span class="nc">Rectangulo</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">origen</span> <span class="p">=</span> <span class="n">Punto</span><span class="p">()</span>
    <span class="kd">var</span> <span class="nv">tamaño</span> <span class="p">=</span> <span class="n">Tamaño</span><span class="p">()</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<p>Recordemos que debido a que la estructura <code>Rectangulo</code> proporciona
valores por defecto para todas sus propiedades, tiene un inicializador
por defecto que puede utilizarse para crear nuevas instancias. También
podemos inicializarlo asignando todas sus propieades:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">let</span> <span class="nv">rectanguloPorDefecto</span> <span class="p">=</span> <span class="n">Rectangulo</span><span class="p">()</span>
<span class="kd">let</span> <span class="nv">rectanguloInicializado</span> <span class="p">=</span> <span class="n">Rectangulo</span><span class="p">(</span><span class="n">origen</span><span class="p">:</span> <span class="n">Punto</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="mf">2.0</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="mf">2.0</span><span class="p">),</span>
                                <span class="n">tamaño</span><span class="p">:</span> <span class="n">Tamaño</span><span class="p">(</span><span class="n">ancho</span><span class="p">:</span> <span class="mf">5.0</span><span class="p">,</span> <span class="n">alto</span><span class="p">:</span> <span class="mf">5.0</span><span class="p">))</span>
</pre></div>
</td></tr></table>

<p>Podemos ahora extender la estructura <code>Rectangulo</code> para proporcionar un
inicializador adicional que toma un punto específico del centro y un
tamaño:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">extension</span> <span class="nc">Rectangulo</span> <span class="p">{</span>
    <span class="kd">init</span><span class="p">(</span><span class="n">centro</span><span class="p">:</span> <span class="n">Punto</span><span class="p">,</span> <span class="n">tamaño</span><span class="p">:</span> <span class="n">Tamaño</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">let</span> <span class="nv">origenX</span> <span class="p">=</span> <span class="n">centro</span><span class="p">.</span><span class="n">x</span> <span class="o">-</span> <span class="p">(</span><span class="n">tamaño</span><span class="p">.</span><span class="n">ancho</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
        <span class="kd">let</span> <span class="nv">origenY</span> <span class="p">=</span> <span class="n">centro</span><span class="p">.</span><span class="n">y</span> <span class="o">-</span> <span class="p">(</span><span class="n">tamaño</span><span class="p">.</span><span class="n">alto</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
        <span class="kc">self</span><span class="p">.</span><span class="kd">init</span><span class="p">(</span><span class="n">origen</span><span class="p">:</span> <span class="n">Punto</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">origenX</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">origenY</span><span class="p">),</span> <span class="n">tamaño</span><span class="p">:</span> <span class="n">tamaño</span><span class="p">)</span>
    <span class="p">}</span>
 <span class="p">}</span>
</pre></div>
</td></tr></table>

<p>Este nuevo inicializador empieza por calcular un punto de origen
basado en el centro propuesto y en el tamaño. El inicializador llama
después al inicializador automático de la estructura
<code>init(origen:tamaño:)</code>, que almacena los nuevos valores de las
propiedades:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span> <span class="kd">let</span> <span class="nv">rectanguloCentro</span> <span class="p">=</span> <span class="n">Rectangulo</span><span class="p">(</span><span class="n">centro</span><span class="p">:</span> <span class="n">Punto</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="mf">4.0</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="mf">4.0</span><span class="p">),</span>
                           <span class="n">tamaño</span><span class="p">:</span> <span class="n">Tamaño</span><span class="p">(</span><span class="n">ancho</span><span class="p">:</span> <span class="mf">3.0</span><span class="p">,</span> <span class="n">alto</span><span class="p">:</span> <span class="mf">3.0</span><span class="p">))</span>
 <span class="c1">// el origen del rectanguloCentro es is (2.5, 2.5) y su tamaño es (3.0, 3.0)</span>
</pre></div>
</td></tr></table>

<h3 id="metodos_1">Métodos<a class="headerlink" href="#metodos_1" title="Permanent link">&para;</a></h3>
<p>Las extensiones pueden añadir nuevos métodos de instancia y nuevos
métodos del tipo.</p>
<p>Por ejemplo, podemos añadir el método <code>descripcion()</code> a la estructura
<code>Persona</code>:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">extension</span> <span class="nc">Persona</span> <span class="p">{</span>
    <span class="kd">func</span> <span class="nf">descripcion</span><span class="p">()</span> <span class="p">-&gt;</span> <span class="nb">String</span> <span class="p">{</span>
        <span class="k">return</span> <span class="s">&quot;Me llamo </span><span class="si">\(</span><span class="n">nombreCompleto</span><span class="si">)</span><span class="s"> y tengo </span><span class="si">\(</span><span class="n">edad</span><span class="si">)</span><span class="s"> años&quot;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nv">reedRichards</span> <span class="p">=</span> <span class="n">Persona</span><span class="p">(</span><span class="n">edad</span><span class="p">:</span> <span class="mi">40</span><span class="p">,</span> <span class="n">nombreCompleto</span><span class="p">:</span> <span class="s">&quot;Reed Richards&quot;</span><span class="p">)</span>
<span class="bp">print</span><span class="p">(</span><span class="n">reedRichards</span><span class="p">.</span><span class="n">descripcion</span><span class="p">())</span>
</pre></div>
</td></tr></table>

<p>También podemos añadir métodos a clases y estructuras importadas. Por
ejemplo podemos añadir un nuevo método de instancia llamado
<code>repeticiones</code> al tipo <code>Int</code>:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">extension</span> <span class="nc">Int</span> <span class="p">{</span>
    <span class="kd">func</span> <span class="nf">repeticiones</span><span class="p">(</span><span class="kc">_</span> <span class="n">tarea</span><span class="p">:</span> <span class="p">()</span> <span class="p">-&gt;</span> <span class="nb">Void</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="kc">_</span> <span class="k">in</span> <span class="mf">0.</span><span class="p">.&lt;</span><span class="kc">self</span> <span class="p">{</span>
            <span class="n">tarea</span><span class="p">()</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<p>El método <code>repeticiones(_:)</code> toma un único argumento de tipo <code>() -&gt;
Void</code>, que indica una función que no tiene parámetros y no devuelve
ningún valor. Después de definir esta extensión, podemos llamar al
método <code>repeticiones(_:)</code> en cualquier número entero para ejecutar una
tarea un cierto número de veces:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="mf">3.</span><span class="n">repeticiones</span><span class="p">({</span>
   <span class="bp">print</span><span class="p">(</span><span class="s">&quot;Hola!&quot;</span><span class="p">)</span>
<span class="p">})</span>
<span class="c1">// Hola!</span>
<span class="c1">// Hola!</span>
<span class="c1">// Hola!</span>
</pre></div>
</td></tr></table>

<p>Usando clausuras por la cola podemos hacer la llamada más concisa:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="mf">3.</span><span class="n">repeticiones</span> <span class="p">{</span>
   <span class="bp">print</span><span class="p">(</span><span class="s">&quot;Adios!&quot;</span><span class="p">)</span>
<span class="p">}</span>
<span class="c1">// Adios!</span>
<span class="c1">// Adios!</span>
<span class="c1">// Adios!</span>
</pre></div>
</td></tr></table>

<h3 id="metodos-de-instancia-mutadores">Métodos de instancia mutadores<a class="headerlink" href="#metodos-de-instancia-mutadores" title="Permanent link">&para;</a></h3>
<p>Los métodos de instancia añadidos con una extensión también pueden
modificar (o mutar) la propia instancia. Los métodos de las
estructuras y los enumerados que modifican <code>self</code> o sus propiedades
deben marcarse como <code>mutating</code>.</p>
<p>Por ejemplo: </p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">extension</span> <span class="nc">Int</span> <span class="p">{</span>
    <span class="kr">mutating</span> <span class="kd">func</span> <span class="nf">cuadrado</span><span class="p">()</span> <span class="p">{</span>
        <span class="kc">self</span> <span class="p">=</span> <span class="kc">self</span> <span class="o">*</span> <span class="kc">self</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kd">var</span> <span class="nv">unInt</span> <span class="p">=</span> <span class="mi">3</span>
<span class="n">unInt</span><span class="p">.</span><span class="n">cuadrado</span><span class="p">()</span>
<span class="c1">// unInt es ahora 9</span>
</pre></div>
</td></tr></table>

<h3 id="ajustar-un-tipo-a-un-protocolo-mediante-una-extension">Ajustar un tipo a un protocolo mediante una extensión<a class="headerlink" href="#ajustar-un-tipo-a-un-protocolo-mediante-una-extension" title="Permanent link">&para;</a></h3>
<p>Una extensión puede extender un tipo existente para hacer que se
ajuste a uno o más protocolos. En este caso, los nombres de los
protocolos se escriben exactamente de la misma forma que en una clase
o estructura:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">extension</span> <span class="nc">UnTipo</span><span class="p">:</span> <span class="n">UnProtocolo</span><span class="p">,</span> <span class="n">OtroProtocolo</span> <span class="p">{</span>
    <span class="c1">// implementación de los requisitos del protocolo</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<p>Las instancias del tipo adoptarán automáticamente el protocolo y se
ajustarán al protocolo con las propiedades y métodos añadidos por la
extensión.</p>
<p>Por ejemplo, este protocolo, llamado <code>RepresentableComoTexto</code> puede
ser implementado por cualquier tipo que tenga una forma de
representarse como texto. Esto puede ser una descripción de si mismo o
una versión de texto de su estado actual:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">protocol</span> <span class="nc">RepresentableComoTexto</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">descripcionTextual</span><span class="p">:</span> <span class="nb">String</span> <span class="p">{</span> <span class="kr">get</span> <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<p>La clase <code>Dado</code> que vimos anteriormente puede extenderse para ajustarse al protocolo:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">extension</span> <span class="nc">Dado</span><span class="p">:</span> <span class="n">RepresentableComoTexto</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">descripcionTextual</span><span class="p">:</span> <span class="nb">String</span> <span class="p">{</span>
        <span class="k">return</span> <span class="s">&quot;Un dado de </span><span class="si">\(</span><span class="n">caras</span><span class="si">)</span><span class="s"> caras&quot;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<p>Esta extensión adopta el nuevo protocolo exactamente como si el <code>Dado</code>
lo hubiera proporcionado en su implementación original. El nombre del
protocolo se indica tras el nombre del tipo, separado por dos puntos,
y se proporciona una implementación entre llaves.</p>
<p>Cualquier instancia de un dado se puede tratar ahora como <code>RepresentableComoTexto</code>:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">let</span> <span class="nv">d12</span> <span class="p">=</span> <span class="n">Dado</span><span class="p">(</span><span class="n">caras</span><span class="p">:</span> <span class="mi">12</span><span class="p">,</span> <span class="n">generador</span><span class="p">:</span> <span class="n">GeneradorLinealCongruente</span><span class="p">())</span>
<span class="bp">print</span><span class="p">(</span><span class="n">d12</span><span class="p">.</span><span class="n">descripcionTextual</span><span class="p">)</span>
<span class="c1">// Un dado de 12 caras</span>
</pre></div>
</td></tr></table>

<p>De forma similar, un <code>Rectangulo</code> también puede extenderse para
adoptar y ajustarse al protocolo:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">extension</span> <span class="nc">Rectangulo</span><span class="p">:</span> <span class="n">RepresentableComoTexto</span> <span class="p">{</span>
   <span class="kd">var</span> <span class="nv">descripcionTextual</span><span class="p">:</span> <span class="nb">String</span> <span class="p">{</span>
      <span class="k">return</span> <span class="s">&quot;Un rectángulo situado en (</span><span class="si">\(</span><span class="n">origen</span><span class="p">.</span><span class="n">x</span><span class="si">)</span><span class="s">, </span><span class="si">\(</span><span class="n">origen</span><span class="p">.</span><span class="n">y</span><span class="si">)</span><span class="s">)&quot;</span>
   <span class="p">}</span>
<span class="p">}</span>
<span class="kd">let</span> <span class="nv">rectanguloInicializado</span> <span class="p">=</span> <span class="n">Rectangulo</span><span class="p">(</span><span class="n">origen</span><span class="p">:</span> <span class="n">Punto</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="mf">2.0</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="mf">2.0</span><span class="p">),</span>
                                <span class="n">tamaño</span><span class="p">:</span> <span class="n">Tamaño</span><span class="p">(</span><span class="n">ancho</span><span class="p">:</span> <span class="mf">5.0</span><span class="p">,</span> <span class="n">alto</span><span class="p">:</span> <span class="mf">5.0</span><span class="p">))</span>

<span class="bp">print</span><span class="p">(</span><span class="n">rectanguloInicializado</span><span class="p">.</span><span class="n">descripcionTextual</span><span class="p">)</span>
<span class="c1">// Un rectángulo situado en (2.0, 2.0)</span>
</pre></div>
</td></tr></table>

<h3 id="declaracion-de-la-adopcion-de-un-protocolo-con-una-extension">Declaración de la adopción de un protocolo con una extensión<a class="headerlink" href="#declaracion-de-la-adopcion-de-un-protocolo-con-una-extension" title="Permanent link">&para;</a></h3>
<p>Si un tipo ya se ajusta a todos los requisitos de un protocolo, pero
todavía no se ha declarado que se ajusta al protocolo, podemos hacer
que lo adopte con una extensión vacía:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">struct</span> <span class="nc">Hamster</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">nombre</span><span class="p">:</span> <span class="nb">String</span>
    <span class="kd">var</span> <span class="nv">descripcionTextual</span><span class="p">:</span> <span class="nb">String</span> <span class="p">{</span>
        <span class="k">return</span> <span class="s">&quot;Un hamster llamado </span><span class="si">\(</span><span class="n">nombre</span><span class="si">)</span><span class="s">&quot;</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kd">extension</span> <span class="nc">Hamster</span><span class="p">:</span> <span class="n">RepresentableComoTexto</span> <span class="p">{}</span>
</pre></div>
</td></tr></table>

<p>Las instancias de <code>Hamster</code> pueden ahora usarse en cualquier sitio que
se requiera un tipo <code>RepresentableComoTexto</code>:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">let</span> <span class="nv">simonElHamster</span> <span class="p">=</span> <span class="n">Hamster</span><span class="p">(</span><span class="n">nombre</span><span class="p">:</span> <span class="s">&quot;Simon&quot;</span><span class="p">)</span>
<span class="kd">let</span> <span class="nv">algoRepresentableComoTexto</span><span class="p">:</span> <span class="n">RepresentableComoTexto</span> <span class="p">=</span> <span class="n">simonElHamster</span>
<span class="bp">print</span><span class="p">(</span><span class="n">algoRepresentableComoTexto</span><span class="p">.</span><span class="n">descripcionTextual</span><span class="p">)</span>
<span class="c1">// Un hamster llamado Simon</span>
</pre></div>
</td></tr></table>

<h3 id="implementacion-de-metodos-de-un-protocolo">Implementación de métodos de un protocolo<a class="headerlink" href="#implementacion-de-metodos-de-un-protocolo" title="Permanent link">&para;</a></h3>
<p>Podemos definir extensiones en los protocolos para proporcionar
implementaciones de métodos y propiedades a todos los tipos que se
ajustan a él. Esto permite definir conductas en los propios
protocolos, más que en cada tipo individual o en una función global.</p>
<p>Por ejemplo, el protocolo <code>GeneradorNumerosAleatorios</code> puede ser extendido
para proporcionar un método <code>boolAleatorio()</code>, que usa el resultado del
<code>random()</code> requerido para devolver un valor <code>Bool</code> aleatorio:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">extension</span> <span class="nc">GeneradorNumerosAleatorios</span> <span class="p">{</span>
    <span class="kd">func</span> <span class="nf">randomBool</span><span class="p">()</span> <span class="p">-&gt;</span> <span class="nb">Bool</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">random</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mf">0.5</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<p>Al crear una extensión en el protocolo, todos los tipos que se ajustan
a él adquieren automáticamente esta implementación sin ninguna
modificación adicional.</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="err">let generator = GeneradorLinealCongruente()</span>
<span class="err">print(&quot;Un número aleatorio: \(generator.random())&quot;)</span>
<span class="err">// Imprime &quot;Un número aleatorio: 0.37464991998171&quot;</span>
<span class="err">print(&quot;Y un booleano aleatorio: \(generator.randomBool())&quot;)</span>
<span class="err">// Imprime &quot;Un booleano aleatorio: true&quot;</span>
</pre></div>
</td></tr></table>

<p>El tipo que se ajusta al protocolo puede proporcionar su propia
implementación, que se usará en lugar de la proporcionada por la extensión.</p>
<h2 id="funciones-operadoras">Funciones operadoras<a class="headerlink" href="#funciones-operadoras" title="Permanent link">&para;</a></h2>
<p>Las clases y las estructuras pueden proporcionar sus propias
implementaciones de operadores existentes. Esto se conoce como
<em>sobrecarga</em> de los operadores existentes.</p>
<p>En el siguiente ejemplo se muestra cómo implementar el operador de
suma (<code>+</code>) para una estructura. El operador suma es un operador
binario (tiene dos operandos) e infijo (aparece junto entre los dos
operandos). Definimos una estructura <code>Vector2D</code> para un vector de
posición de dos dimensiones:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">struct</span> <span class="nc">Vector2D</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">x</span> <span class="p">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">y</span> <span class="p">=</span> <span class="mf">0.0</span>
    <span class="kd">static</span> <span class="kd">func</span> <span class="o">+</span> <span class="p">(</span><span class="n">izquierdo</span><span class="p">:</span> <span class="n">Vector2D</span><span class="p">,</span> <span class="n">derecho</span><span class="p">:</span> <span class="n">Vector2D</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">Vector2D</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">Vector2D</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">izquierdo</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">derecho</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">izquierdo</span><span class="p">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">derecho</span><span class="p">.</span><span class="n">y</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<p>La función operador se define como una función estática con un un
nombre de función que empareja con el operador a sobrecargar
(<code>+</code>). Debido a que la suma aritmética se define como un operador
binario, esta función operador toma dos parámetros de entrada de tipo
<code>Vector2D</code> y devuelve un único valor de salida, también de tipo
<code>Vector2D</code>.</p>
<p>En esta implementación, llamamos a los parámetros de entrada
<code>izquierdo</code> y <code>derecho</code> para representar las instancias de <code>Vector2D</code>
que estarán a la izquierda y a la derecha del operador <code>+</code>. Son
nombres arbitrarios, lo importante es la posición. El primer parámetro
de la función es el que hace de primer operador.</p>
<p>La función devuelve una nueva instancia de <code>Vector2D</code>, cuyas
propiedades <code>x</code> e <code>y</code> se inicializan con la suma de las propiedades
<code>x</code> e <code>y</code> de las instancias de <code>Vector2D</code> que se están sumando.</p>
<p>La función se define globalmente, más que como un método en la
estructura <code>Vector2D</code>, para que pueda usarse como un operador infijo
entre instancias existentes de <code>Vector2D</code>:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">let</span> <span class="nv">vector</span> <span class="p">=</span> <span class="n">Vector2D</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="mf">3.0</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">)</span>
<span class="kd">let</span> <span class="nv">otroVector</span> <span class="p">=</span> <span class="n">Vector2D</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="mf">2.0</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="mf">4.0</span><span class="p">)</span>
<span class="kd">let</span> <span class="nv">vectorSuma</span> <span class="p">=</span> <span class="n">vector</span> <span class="o">+</span> <span class="n">otroVector</span>
<span class="c1">// vectorSuma es una instancia de Vector2D con valores de (5.0, 5.0)</span>
</pre></div>
</td></tr></table>

<h3 id="operadores-prefijos-y-postfijos">Operadores prefijos y postfijos<a class="headerlink" href="#operadores-prefijos-y-postfijos" title="Permanent link">&para;</a></h3>
<p>El ejemplo anterior demuestra una implementación propia de un operador
binario infijo. Las clases y las estructuras pueden también
proporcionar implementaciones de los operadores unarios estándar. Los
operadores unarios operan sobre un único objetivo. Son prefijos se
preceden el objetivo (como <code>-a</code>) y postfijos si siguen su objetivo
(como en <code>b!</code>).</p>
<p>Para implementar un operador unario prefijo o postfijo se debe
escribir el modificador <code>prefix</code> o <code>postfix</code> antes de la palabra clave
<code>func</code> en la declaración de la función operador:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">struct</span> <span class="nc">Vector2D</span> <span class="p">{</span>
   <span class="p">...</span>
   <span class="kd">static</span> <span class="kr">prefix</span> <span class="kd">func</span> <span class="o">-</span> <span class="p">(</span><span class="n">vector</span><span class="p">:</span> <span class="n">Vector2D</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">Vector2D</span> <span class="p">{</span>
       <span class="k">return</span> <span class="n">Vector2D</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="o">-</span><span class="n">vector</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="o">-</span><span class="n">vector</span><span class="p">.</span><span class="n">y</span><span class="p">)</span>
   <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<p>El ejemplo anterior implementa el operador unario negación (<code>-a</code>) para
instancias de <code>Vector2D</code>.</p>
<p>Por ejemplo:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">let</span> <span class="nv">positivo</span> <span class="p">=</span> <span class="n">Vector2D</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="mf">3.0</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="mf">4.0</span><span class="p">)</span>
<span class="kd">let</span> <span class="nv">negativo</span> <span class="p">=</span> <span class="o">-</span><span class="n">positivo</span>
<span class="c1">// negativo es una instancia de Vector2D con valores de (-3.0, -4.0)</span>
<span class="kd">let</span> <span class="nv">tambienPositivo</span> <span class="p">=</span> <span class="o">-</span><span class="n">negativo</span>
<span class="c1">// tambienPositivo es una instancia de Vector2D con valores de (3.0, 4.0)</span>
</pre></div>
</td></tr></table>

<h3 id="operadores-de-equivalencia">Operadores de equivalencia<a class="headerlink" href="#operadores-de-equivalencia" title="Permanent link">&para;</a></h3>
<p>Como ya hemos visto, las clases no tienen una implementación por
defecto de los operadores "igual a" (<code>==</code>) y "no igual a" (<code>!=</code>), pero
las estructuras sí (a partir de Swift 5). Para comparar dos instancias
de una clase debemos proporcionar una implementación del operador <code>==</code>.</p>
<p>A partir de Swift 5 si declaramos que una estructura cumple el
protocolo <code>Equatable</code> el compilador de Swift implementará una
comparación por defecto, siempre que todas las propiedades de la
estructura sean a su vez <code>Equatable</code>.</p>
<p>En Swift 4 para implementar la igualdad en la estructura <code>Vector2D</code>
tenemos que definir una extensión que cumple el protocolo
<code>Equatable</code>:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="c1">// Swift 4</span>
<span class="kd">extension</span> <span class="nc">Vector2D</span><span class="p">:</span> <span class="nb">Equatable</span> <span class="p">{</span>
   <span class="kd">static</span> <span class="kd">func</span> <span class="p">==</span> <span class="p">(</span><span class="n">izquierdo</span><span class="p">:</span> <span class="n">Vector2D</span><span class="p">,</span> <span class="n">derecho</span><span class="p">:</span> <span class="n">Vector2D</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Bool</span> <span class="p">{</span>
       <span class="k">return</span> <span class="p">(</span><span class="n">izquierdo</span><span class="p">.</span><span class="n">x</span> <span class="p">==</span> <span class="n">derecho</span><span class="p">.</span><span class="n">x</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">izquierdo</span><span class="p">.</span><span class="n">y</span> <span class="p">==</span> <span class="n">derecho</span><span class="p">.</span><span class="n">y</span><span class="p">)</span>
   <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<p>En el ejemplo anterior se implementa un operador "igual a" (<code>==</code>) que
comprueba si dos instancias de <code>Vector2D</code> tienen valores
equivalentes. En el contexto del <code>Vector2D</code> tiene sentido considerar
"igual" como "ambas instancias tienen los mismos valores x e y", por
lo que esta es la lógica usada por la implementación. </p>
<p>La implementación del operador "no igual a" (<code>!=</code>) se realiza por
defecto como una negación del anterior.</p>
<p>En Swift 5 basta con declarar con la extensión que el <code>Vector2D</code>
cumple el protocolo:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="c1">// Swift 5</span>
<span class="kd">extension</span> <span class="nc">Vector2D</span><span class="p">:</span> <span class="nb">Equatable</span> <span class="p">{}</span>
</pre></div>
</td></tr></table>

<p>Una vez definido el operador <code>==</code> podemos comparar dos instancias de <code>Vector2D</code>:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">let</span> <span class="nv">dosTres</span> <span class="p">=</span> <span class="n">Vector2D</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="mf">2.0</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="mf">3.0</span><span class="p">)</span>
<span class="kd">let</span> <span class="nv">otroDosTres</span> <span class="p">=</span> <span class="n">Vector2D</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="mf">2.0</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="mf">3.0</span><span class="p">)</span>
<span class="kd">let</span> <span class="nv">unoDos</span> <span class="p">=</span> <span class="n">Vector2D</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="mf">2.0</span><span class="p">)</span>
<span class="k">if</span> <span class="n">dosTres</span> <span class="p">==</span> <span class="n">otroDosTres</span> <span class="p">{</span>
    <span class="bp">print</span><span class="p">(</span><span class="s">&quot;Los vectores </span><span class="si">\(</span><span class="n">dosTres</span><span class="si">)</span><span class="s"> y </span><span class="si">\(</span><span class="n">otroDosTres</span><span class="si">)</span><span class="s"> son equivalentes.&quot;</span><span class="p">)</span>
<span class="p">}</span>
<span class="k">if</span> <span class="p">(</span><span class="n">unoDos</span> <span class="o">!=</span> <span class="n">dosTres</span><span class="p">)</span> <span class="p">{</span>
    <span class="bp">print</span><span class="p">(</span><span class="s">&quot;Los vectores </span><span class="si">\(</span><span class="n">unoDos</span><span class="si">)</span><span class="s"> y </span><span class="si">\(</span><span class="n">dosTres</span><span class="si">)</span><span class="s"> son distintos.&quot;</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<h2 id="genericos">Genéricos<a class="headerlink" href="#genericos" title="Permanent link">&para;</a></h2>
<p>Veamos cómo podemos utilizar los genéricos con clases y estructuras.</p>
<p>Vamos a utilizar como ejemplo un tipo de dato muy sencillo: una pila
(<em>stack</em>) en la que se podrán añadir (<em>push</em>) y retirar (<em>pop</em>)
elementos.</p>
<p>La versión no genérica del tipo de dato es la siguiente, en la que se
implementa una pila de enteros.</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">struct</span> <span class="nc">IntStack</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">items</span> <span class="p">=</span> <span class="p">[</span><span class="nb">Int</span><span class="p">]()</span>
    <span class="kr">mutating</span> <span class="kd">func</span> <span class="nf">push</span><span class="p">(</span><span class="kc">_</span> <span class="n">item</span><span class="p">:</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">items</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="kr">mutating</span> <span class="kd">func</span> <span class="nf">pop</span><span class="p">()</span> <span class="p">-&gt;</span> <span class="nb">Int</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">items</span><span class="p">.</span><span class="bp">removeLast</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<p>La estructura usa un array para guardar los ítems y los métodos <code>push</code>
y <code>pop</code> añaden y retiran los elementos. </p>
<p>El problema de esta estructura es su falta de genericidad; sólo puede
almacenar enteros.</p>
<p>Aquí está una versión genérica del mismo código:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">struct</span> <span class="nc">Stack</span><span class="p">&lt;</span><span class="n">Element</span><span class="p">&gt;</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">items</span> <span class="p">=</span> <span class="p">[</span><span class="n">Element</span><span class="p">]()</span>
    <span class="kr">mutating</span> <span class="kd">func</span> <span class="nf">push</span><span class="p">(</span><span class="kc">_</span> <span class="n">item</span><span class="p">:</span> <span class="n">Element</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">items</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="kr">mutating</span> <span class="kd">func</span> <span class="nf">pop</span><span class="p">()</span> <span class="p">-&gt;</span> <span class="n">Element</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">items</span><span class="p">.</span><span class="bp">removeLast</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<p>El parámetro del tipo <code>Element</code> define un tipo genérico que se utiliza
como <em>placeholder</em> del tipo real del que se declare la
estructura. Podemos ver que se utiliza en la definición de los
distintos elementos de la estructura. Por ejemplo, el array de ítems
es un array de <code>Element</code>s. Y los ítems añadidos y retirados de la pila
son también objetos de tipo <code>Element</code>.</p>
<p>Por ejemplo, podemos crear una pila de cadenas:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">var</span> <span class="nv">stackOfStrings</span> <span class="p">=</span> <span class="n">Stack</span><span class="p">&lt;</span><span class="nb">String</span><span class="p">&gt;()</span>
<span class="n">stackOfStrings</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="s">&quot;uno&quot;</span><span class="p">)</span>
<span class="n">stackOfStrings</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="s">&quot;dos&quot;</span><span class="p">)</span>
<span class="n">stackOfStrings</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="s">&quot;tres&quot;</span><span class="p">)</span>
<span class="n">stackOfStrings</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="s">&quot;cuatro&quot;</span><span class="p">)</span>
<span class="c1">// la pila contiene ahora 4 cadenas</span>
</pre></div>
</td></tr></table>

<p>Y podemos retirar la última cadena de la pila:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">let</span> <span class="nv">fromTheTop</span> <span class="p">=</span> <span class="n">stackOfStrings</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span>
</pre></div>
</td></tr></table>

<h3 id="extension-de-un-tipo-generico">Extensión de un tipo genérico<a class="headerlink" href="#extension-de-un-tipo-generico" title="Permanent link">&para;</a></h3>
<p>Cuando se extiende un tipo genérico, no hace falta añadir el parámetro
del tipo entre <code>&lt;&gt;</code>. El tipo genérico está disponible a partir de la
definición original y se puede usar tal cual en el cuerpo de la
extensión.</p>
<p>Por ejemplo, podemos extender el tipo genérico <code>Stack</code> para añadir una
propiedad computable de sólo lectura que devuelva el tope de la pila:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">extension</span> <span class="nc">Stack</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">topItem</span><span class="p">:</span> <span class="n">Element</span><span class="p">?</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">items</span><span class="p">.</span><span class="bp">isEmpty</span> <span class="p">?</span> <span class="kc">nil</span> <span class="p">:</span> <span class="n">items</span><span class="p">[</span><span class="n">items</span><span class="p">.</span><span class="bp">count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<p>En la extensión se utiliza el nombre genérico <code>Element</code> sin tener que
declararlo después de <code>Stack</code>, porque está definido en la estructura
original.</p>
<p>Ahora ya se puede acceder al tope de la pila sin retirar el elemento:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="k">if</span> <span class="kd">let</span> <span class="nv">topItem</span> <span class="p">=</span> <span class="n">stackOfStrings</span><span class="p">.</span><span class="n">topItem</span> <span class="p">{</span>
    <span class="bp">print</span><span class="p">(</span><span class="s">&quot;El ítem en el tope de la pila es </span><span class="si">\(</span><span class="n">topItem</span><span class="si">)</span><span class="s">.&quot;</span><span class="p">)</span>
<span class="p">}</span>
<span class="c1">// Imprime &quot;El ítem en el tope de la pila es tres.&quot;</span>
</pre></div>
</td></tr></table>

<h3 id="restriccion-en-las-extensiones-de-un-protocolo">Restricción en las extensiones de un protocolo<a class="headerlink" href="#restriccion-en-las-extensiones-de-un-protocolo" title="Permanent link">&para;</a></h3>
<p>En una extensión de un protocolo es posible definir una restricción
indicando una condición que se debe cumplir para que la extensión se
pueda aplicar. Los métodos y propiedades de la extensión sólo estarán
disponibles en aquellos tipos que se ajusten al protocolo y cumplan el
requisito.</p>
<p>El requisito se definen usando una cláusula genérica <code>where</code> en la que
se indica una condición sobre algún <em>tipo asociado</em> definido en el
protocolo.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>No hemos visto el concepto de <a href="https://docs.swift.org/swift-book/LanguageGuide/Generics.html#ID189"><em>tipo
asociado</em></a>
en un protocolo. Es una especie de tipo genérico que se define en el
protocolo y que se convierte en un tipo concreto en la clase que se
ajusta al protocolo.</p>
</div>
<p>Por ejemplo, podemos definir una extensión al protocolo <code>Collection</code>
que se aplique a cualquier colección cuyos elementos cumplen el
protocolo <code>Equatable</code>. De esta forma nos aseguramos de que los
operadores <code>==</code> y <code>!=</code> están definidos y podemos usarlos en la
extensión:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">extension</span> <span class="nc">Collection</span> <span class="k">where</span> <span class="n">Element</span><span class="p">:</span> <span class="nb">Equatable</span> <span class="p">{</span>
    <span class="kd">func</span> <span class="nf">allEqual</span><span class="p">()</span> <span class="p">-&gt;</span> <span class="nb">Bool</span> <span class="p">{</span>
        <span class="k">for</span> <span class="n">element</span> <span class="k">in</span> <span class="kc">self</span> <span class="p">{</span>
            <span class="k">if</span> <span class="n">element</span> <span class="o">!=</span> <span class="kc">self</span><span class="p">.</span><span class="bp">first</span> <span class="p">{</span>
                <span class="k">return</span> <span class="kc">false</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="kc">true</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<p>El nombre <code>Element</code> es un nombre definido en el protocolo <code>Collection</code>
que se refiere al tipo de los elementos de la colección. Es un <em>tipo
asociado</em>.</p>
<p>El método <code>allEqual()</code> devuelve <code>true</code> si y sólo si todos los
elementos en la colección son iguales.</p>
<p>Un ejemplo:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">let</span> <span class="nv">numerosIguales</span> <span class="p">=</span> <span class="p">[</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">]</span>
<span class="kd">let</span> <span class="nv">numerosDiferentes</span> <span class="p">=</span> <span class="p">[</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">200</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">200</span><span class="p">]</span>
</pre></div>
</td></tr></table>

<p>Dado que ambos arrays cumplen el protocolo <code>Collection</code> y los enteros
cumplen el protocolo <code>Equatable</code> podemos usar el método <code>allEqual()</code>:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="err">print(numerosIguales.allEqual())</span>
<span class="err">// Prints &quot;true&quot;</span>
<span class="err">print(numerosDiferentes.allEqual())</span>
<span class="err">// Prints &quot;false&quot;</span>
</pre></div>
</td></tr></table>

<p>En una colección cuyos elementos no cumplen el protocolo <code>Equatable</code>
no se puede utilizar el método de la extensión:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">let</span> <span class="nv">tormenta</span> <span class="p">=</span> <span class="n">Persona</span><span class="p">(</span><span class="n">edad</span><span class="p">:</span> <span class="mi">32</span><span class="p">,</span> <span class="n">nombreCompleto</span><span class="p">:</span> <span class="s">&quot;Ororo Munroe&quot;</span><span class="p">)</span>
<span class="kd">let</span> <span class="nv">superHeroes</span> <span class="p">=</span> <span class="p">[</span><span class="n">tormenta</span><span class="p">,</span> <span class="n">peterParker</span><span class="p">,</span> <span class="n">reedRichards</span><span class="p">]</span>
<span class="bp">print</span><span class="p">(</span><span class="n">superHeroes</span><span class="p">.</span><span class="n">allEqual</span><span class="p">())</span>
<span class="c1">//error: type &#39;Persona&#39; does not conform to protocol &#39;Equatable&#39;</span>
</pre></div>
</td></tr></table>

<h2 id="bibliografia">Bibliografía<a class="headerlink" href="#bibliografia" title="Permanent link">&para;</a></h2>
<ul>
<li>Swift Language Guide<ul>
<li><a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/ClassesAndStructures.html#//apple_ref/doc/uid/TP40014097-CH13-ID82">Classes and Structures</a></li>
<li><a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Properties.html#//apple_ref/doc/uid/TP40014097-CH14-ID254">Properties</a></li>
<li><a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Methods.html#//apple_ref/doc/uid/TP40014097-CH15-ID234">Methods</a></li>
<li><a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Inheritance.html#//apple_ref/doc/uid/TP40014097-CH17-ID193=">Inheritance</a></li>
<li><a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Initialization.html#//apple_ref/doc/uid/TP40014097-CH18-ID203">Initialization</a></li>
<li><a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Protocols.html#//apple_ref/doc/uid/TP40014097-CH25-ID267">Protocolos</a></li>
<li><a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/TypeCasting.html#//apple_ref/doc/uid/TP40014097-CH22-ID338">Casting de tipos</a></li>
<li><a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Extensions.html#//apple_ref/doc/uid/TP40014097-CH24-ID151">Extensiones</a></li>
<li><a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/AdvancedOperators.html#//apple_ref/doc/uid/TP40014097-CH27-ID28">Funciones operador</a></li>
<li><a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Generics.html#//apple_ref/doc/uid/TP40014097-CH26-ID179">Genéricos</a></li>
</ul>
</li>
</ul>
<hr />
<p>Lenguajes y Paradigmas de Programación, curso 2018–19<br />
© Departamento Ciencia de la Computación e Inteligencia Artificial, Universidad de Alicante<br />
Domingo Gallardo, Cristina Pomares, Antonio Botía, Francisco Martínez</p>
                
                  
                
                
              
              
                


              
            </article>
          </div>
        </div>
      </main>
      
        
<footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-footer-copyright">
        
        powered by
        <a href="https://www.mkdocs.org">MkDocs</a>
        and
        <a href="https://squidfunk.github.io/mkdocs-material/">
          Material for MkDocs</a>
      </div>
      
    </div>
  </div>
</footer>
      
    </div>
    
      <script src="../../assets/javascripts/application.808e90bb.js"></script>
      
      <script>app.initialize({version:"1.0.4",url:{base:"../.."}})</script>
      
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML"></script>
      
    
  </body>
</html>