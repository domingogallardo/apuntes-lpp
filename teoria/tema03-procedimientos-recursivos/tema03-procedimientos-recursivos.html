
<!doctype html>
<html lang="es" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
        <link rel="prev" href="../tema02-programacion-funcional/tema02-programacion-funcional.html">
      
      
        <link rel="next" href="../tema04-estructuras-recursivas/tema04-estructuras-recursivas.html">
      
      
      <link rel="icon" href="../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.5.34">
    
    
      
        <title>Tema 3: Procedimientos recursivos - LPP</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/main.35f28582.min.css">
      
        
        <link rel="stylesheet" href="../../assets/stylesheets/palette.06af60db.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
    <script>__md_scope=new URL("../..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    
    
      
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="teal" data-md-color-accent="teal">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#tema-3-procedimientos-recursivos" class="md-skip">
          Saltar a contenido
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Cabecera">
    <a href="../.." title="LPP" class="md-header__button md-logo" aria-label="LPP" data-md-component="logo">
      
  <img src="../../imagenes/logo.png" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            LPP
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Tema 3: Procedimientos recursivos
            
          </span>
        </div>
      </div>
    </div>
    
      
        <form class="md-header__option" data-md-component="palette">
  
    
    
    
    <input class="md-option" data-md-color-media="" data-md-color-scheme="default" data-md-color-primary="teal" data-md-color-accent="teal"  aria-label="Switch to dark mode"  type="radio" name="__palette" id="__palette_0">
    
      <label class="md-header__button md-icon" title="Switch to dark mode" for="__palette_1" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a4 4 0 0 0-4 4 4 4 0 0 0 4 4 4 4 0 0 0 4-4 4 4 0 0 0-4-4m0 10a6 6 0 0 1-6-6 6 6 0 0 1 6-6 6 6 0 0 1 6 6 6 6 0 0 1-6 6m8-9.31V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12z"/></svg>
      </label>
    
  
    
    
    
    <input class="md-option" data-md-color-media="" data-md-color-scheme="slate" data-md-color-primary="black" data-md-color-accent="indigo"  aria-label="Switch to light mode"  type="radio" name="__palette" id="__palette_1">
    
      <label class="md-header__button md-icon" title="Switch to light mode" for="__palette_0" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 18c-.89 0-1.74-.2-2.5-.55C11.56 16.5 13 14.42 13 12s-1.44-4.5-3.5-5.45C10.26 6.2 11.11 6 12 6a6 6 0 0 1 6 6 6 6 0 0 1-6 6m8-9.31V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12z"/></svg>
      </label>
    
  
</form>
      
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Búsqueda" placeholder="Búsqueda" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Buscar">
        
        <button type="reset" class="md-search__icon md-icon" title="Limpiar" aria-label="Limpiar" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Inicializando búsqueda
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navegación" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../.." title="LPP" class="md-nav__button md-logo" aria-label="LPP" data-md-component="logo">
      
  <img src="../../imagenes/logo.png" alt="logo">

    </a>
    LPP
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
    
  
  
  
    
    
    
    
    <li class="md-nav__item md-nav__item--active md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_1" checked>
        
          
          <label class="md-nav__link" for="__nav_1" id="__nav_1_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Teoría
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_1_label" aria-expanded="true">
          <label class="md-nav__title" for="__nav_1">
            <span class="md-nav__icon md-icon"></span>
            Teoría
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../tema00-descripcion-asignatura/tema00-descripcion-asignatura.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Descripción de la asignatura
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../tema01-historia-lenguajes-programacion/tema01-historia-lenguajes-programacion.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Tema 1: Historia de los lenguajes de programación
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../tema02-programacion-funcional/tema02-programacion-funcional.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Tema 2: Programación funcional
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
    
  
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          
  
  <span class="md-ellipsis">
    Tema 3: Procedimientos recursivos
  </span>
  

          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="tema03-procedimientos-recursivos.html" class="md-nav__link md-nav__link--active">
        
  
  <span class="md-ellipsis">
    Tema 3: Procedimientos recursivos
  </span>
  

      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="Tabla de contenidos">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Tabla de contenidos
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#1-el-coste-de-la-recursion" class="md-nav__link">
    <span class="md-ellipsis">
      1. El coste de la recursión
    </span>
  </a>
  
    <nav class="md-nav" aria-label="1. El coste de la recursión">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#11-la-pila-de-la-recursion" class="md-nav__link">
    <span class="md-ellipsis">
      1.1. La pila de la recursión
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#12-coste-espacial-de-la-recursion" class="md-nav__link">
    <span class="md-ellipsis">
      1.2. Coste espacial de la recursión
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#13-el-coste-depende-del-numero-de-llamadas-a-la-recursion" class="md-nav__link">
    <span class="md-ellipsis">
      1.3. El coste depende del número de llamadas a la recursión
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#2-soluciones-al-coste-de-la-recursion-procesos-iterativos" class="md-nav__link">
    <span class="md-ellipsis">
      2. Soluciones al coste de la recursión: procesos iterativos
    </span>
  </a>
  
    <nav class="md-nav" aria-label="2. Soluciones al coste de la recursión: procesos iterativos">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#21-factorial-iterativo" class="md-nav__link">
    <span class="md-ellipsis">
      2.1. Factorial iterativo
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#22-version-iterativa-de-mi-length" class="md-nav__link">
    <span class="md-ellipsis">
      2.2. Versión iterativa de mi-length
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#23-funcion-suma-lista-usando-recursion-por-la-cola" class="md-nav__link">
    <span class="md-ellipsis">
      2.3. Función suma-lista usando recursión por la cola
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#24-caracteristicas-de-los-procesos-iterativos" class="md-nav__link">
    <span class="md-ellipsis">
      2.4. Características de los procesos iterativos
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#25-fibonacci-iterativo" class="md-nav__link">
    <span class="md-ellipsis">
      2.5. Fibonacci iterativo
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#26-triangulo-de-pascal" class="md-nav__link">
    <span class="md-ellipsis">
      2.6. Triángulo de Pascal
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#3-soluciones-al-coste-de-la-recursion-memoization" class="md-nav__link">
    <span class="md-ellipsis">
      3. Soluciones al coste de la recursión: memoization
    </span>
  </a>
  
    <nav class="md-nav" aria-label="3. Soluciones al coste de la recursión: memoization">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#31-fibonacci-con-memoization" class="md-nav__link">
    <span class="md-ellipsis">
      3.1. Fibonacci con memoization
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#4-figuras-recursivas" class="md-nav__link">
    <span class="md-ellipsis">
      4. Figuras recursivas
    </span>
  </a>
  
    <nav class="md-nav" aria-label="4. Figuras recursivas">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#41-libreria-de-imagenes-de-racket" class="md-nav__link">
    <span class="md-ellipsis">
      4.1. Librería de imágenes de Racket
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#42-triangulo-de-sierpinski" class="md-nav__link">
    <span class="md-ellipsis">
      4.2. Triángulo de Sierpinski
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#43-curva-de-hilbert" class="md-nav__link">
    <span class="md-ellipsis">
      4.3. Curva de Hilbert
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#5-bibliografia" class="md-nav__link">
    <span class="md-ellipsis">
      5. Bibliografía
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../tema04-estructuras-recursivas/tema04-estructuras-recursivas.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Tema 4: Estructuras recursivas
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2" >
        
          
          <label class="md-nav__link" for="__nav_2" id="__nav_2_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Seminarios
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2">
            <span class="md-nav__icon md-icon"></span>
            Seminarios
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../seminarios/seminario1-scheme/seminario1-scheme.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Seminario de Scheme
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3" >
        
          
          <label class="md-nav__link" for="__nav_3" id="__nav_3_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Prácticas
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3">
            <span class="md-nav__icon md-icon"></span>
            Prácticas
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../practicas/buenas-practicas-programacion-funcional.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Buenas prácticas de programación funcional
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../practicas/practica01/practica01.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Práctica 1
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../practicas/practica02/practica02.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Práctica 2
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../practicas/practica03/practica03.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Práctica 3
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../practicas/practica04/practica04.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Práctica 4
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../practicas/practica05/practica05.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Práctica 5
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../practicas/practica06/practica06.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Práctica 6
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Tabla de contenidos">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Tabla de contenidos
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#1-el-coste-de-la-recursion" class="md-nav__link">
    <span class="md-ellipsis">
      1. El coste de la recursión
    </span>
  </a>
  
    <nav class="md-nav" aria-label="1. El coste de la recursión">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#11-la-pila-de-la-recursion" class="md-nav__link">
    <span class="md-ellipsis">
      1.1. La pila de la recursión
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#12-coste-espacial-de-la-recursion" class="md-nav__link">
    <span class="md-ellipsis">
      1.2. Coste espacial de la recursión
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#13-el-coste-depende-del-numero-de-llamadas-a-la-recursion" class="md-nav__link">
    <span class="md-ellipsis">
      1.3. El coste depende del número de llamadas a la recursión
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#2-soluciones-al-coste-de-la-recursion-procesos-iterativos" class="md-nav__link">
    <span class="md-ellipsis">
      2. Soluciones al coste de la recursión: procesos iterativos
    </span>
  </a>
  
    <nav class="md-nav" aria-label="2. Soluciones al coste de la recursión: procesos iterativos">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#21-factorial-iterativo" class="md-nav__link">
    <span class="md-ellipsis">
      2.1. Factorial iterativo
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#22-version-iterativa-de-mi-length" class="md-nav__link">
    <span class="md-ellipsis">
      2.2. Versión iterativa de mi-length
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#23-funcion-suma-lista-usando-recursion-por-la-cola" class="md-nav__link">
    <span class="md-ellipsis">
      2.3. Función suma-lista usando recursión por la cola
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#24-caracteristicas-de-los-procesos-iterativos" class="md-nav__link">
    <span class="md-ellipsis">
      2.4. Características de los procesos iterativos
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#25-fibonacci-iterativo" class="md-nav__link">
    <span class="md-ellipsis">
      2.5. Fibonacci iterativo
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#26-triangulo-de-pascal" class="md-nav__link">
    <span class="md-ellipsis">
      2.6. Triángulo de Pascal
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#3-soluciones-al-coste-de-la-recursion-memoization" class="md-nav__link">
    <span class="md-ellipsis">
      3. Soluciones al coste de la recursión: memoization
    </span>
  </a>
  
    <nav class="md-nav" aria-label="3. Soluciones al coste de la recursión: memoization">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#31-fibonacci-con-memoization" class="md-nav__link">
    <span class="md-ellipsis">
      3.1. Fibonacci con memoization
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#4-figuras-recursivas" class="md-nav__link">
    <span class="md-ellipsis">
      4. Figuras recursivas
    </span>
  </a>
  
    <nav class="md-nav" aria-label="4. Figuras recursivas">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#41-libreria-de-imagenes-de-racket" class="md-nav__link">
    <span class="md-ellipsis">
      4.1. Librería de imágenes de Racket
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#42-triangulo-de-sierpinski" class="md-nav__link">
    <span class="md-ellipsis">
      4.2. Triángulo de Sierpinski
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#43-curva-de-hilbert" class="md-nav__link">
    <span class="md-ellipsis">
      4.3. Curva de Hilbert
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#5-bibliografia" class="md-nav__link">
    <span class="md-ellipsis">
      5. Bibliografía
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


<h1 id="tema-3-procedimientos-recursivos">Tema 3: Procedimientos recursivos<a class="headerlink" href="#tema-3-procedimientos-recursivos" title="Permanent link">&para;</a></h1>
<p>Ya hemos visto muchos ejemplos de funciones recursivas. Una
función es recursiva cuando se llama a si misma. Una vez que uno se
acostumbra a su uso, se comprueba que la recursión es una forma mucho
más natural que la iteración de expresar un gran número de funciones y
procedimientos.</p>
<p>La formulación matemática de la recursión es sencilla de entender,
pero su implementación en un lenguaje de programación no lo es
tanto. El primer lenguaje de programación que permitió el uso de
expresiones recursivas fue el Lisp. En el momento de su creación
existía ya el Fortran, que no permitía que una función se llamase a si
misma.</p>
<p>Ya hemos visto la utilidad de la recursión en muchos ejemplos para
recorrer listas, para filtrarlas, etc. En este tema veremos algunos
aspectos negativos de la recursión: su coste espacial y
temporal. Veremos que hay soluciones a estos problemas, cambiando el
estilo de la recursión y generando <em>procesos iterativos</em> o usando un
enfoque automático llamado <em>memoization</em> en el que se guardan los
resultados de cada llamada recursiva. Por último, veremos un último
ejemplo curioso e interesante de la recursión para realizar figuras
fractales con la librería gráfica de Racket.</p>
<h2 id="1-el-coste-de-la-recursion">1. El coste de la recursión<a class="headerlink" href="#1-el-coste-de-la-recursion" title="Permanent link">&para;</a></h2>
<p>Hasta ahora hemos estudiado el diseño de funciones recursivas. Vamos a
tratar por primera vez su coste. Veremos que hay casos en los que es
prohibitivo utilizar la recursión tal y como la hemos visto. Y veremos
también que existen soluciones para esos casos.</p>
<h3 id="11-la-pila-de-la-recursion">1.1. La pila de la recursión<a class="headerlink" href="#11-la-pila-de-la-recursion" title="Permanent link">&para;</a></h3>
<p>Vamos a estudiar el comportamiento de la evaluación de una llamada a
una función recursiva. Supongamos la función
<code>mi-length</code>:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">mi-length</span><span class="w"> </span><span class="n">items</span><span class="p">)</span>
<span class="w">   </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">null?</span><span class="w"> </span><span class="n">items</span><span class="p">)</span>
<span class="w">      </span><span class="mi">0</span>
<span class="w">      </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">(</span><span class="n">mi-length</span><span class="w"> </span><span class="p">(</span><span class="nb">rest</span><span class="w"> </span><span class="n">items</span><span class="p">)))))</span>
</code></pre></div>
<p>Examinamos cómo se evalúan las llamadas recursivas:</p>
<div class="highlight"><pre><span></span><code>(mi-length &#39;(a b c d))
(+ 1 (mi-length &#39;(b c d)))
(+ 1 (+ 1 (mi-length &#39;(c d))))
(+ 1 (+ 1 (+ 1 (mi-length &#39;(d)))))
(+ 1 (+ 1 (+ 1 (+ 1 (mi-length &#39;())))))
(+ 1 (+ 1 (+ 1 (+ 1 0))))
(+ 1 (+ 1 (+ 1 1)))
(+ 1 (+ 1 2))
(+ 1 3)
4
</code></pre></div>
<p>Cada llamada a la recursión deja una función <strong>en espera de ser
evaluada</strong> cuando la recursión devuelva un valor (en el caso anterior
las funciones suma). Estas llamadas en espera, junto con sus
argumentos, se almacenan en la <em>pila de la recursión</em>.</p>
<p>Cuando la recursión devuelve un valor, los valores se recuperan de la
pila, se realiza la llamada y se devuelve el valor a la anterior
llamada en espera. </p>
<p>Si la recursión está mal hecha y nunca termina se genera un <em>stack
overflow</em> porque la memoria que se almacena en la pila sobrepasa la
memoria reservada para el intérprete DrRacket.</p>
<h3 id="12-coste-espacial-de-la-recursion">1.2. Coste espacial de la recursión<a class="headerlink" href="#12-coste-espacial-de-la-recursion" title="Permanent link">&para;</a></h3>
<p>El coste espacial de un programa es una función que relaciona la
memoria consumida por una llamada para resolver un problema con alguna
variable que determina el tamaño del problema a resolver.</p>
<p>En el caso de la función <code>mi-length</code> el tamaño del problema viene dado
por la longitud de la lista. El coste espacial de <code>mi-lenght</code> es
<em>O(n)</em>, siendo <em>n</em> la longitud de la lista.</p>
<h3 id="13-el-coste-depende-del-numero-de-llamadas-a-la-recursion">1.3. El coste depende del número de llamadas a la recursión<a class="headerlink" href="#13-el-coste-depende-del-numero-de-llamadas-a-la-recursion" title="Permanent link">&para;</a></h3>
<p>Veamos con un ejemplo que el coste de las llamadas recursivas puede
dispararse. Supongamos la famosa <a href="http://en.wikipedia.org/wiki/Fibonacci_number">secuencia de Fibonacci</a>:
0,1,1,2,3,5,8,13,...</p>
<p>Formulación matemática de la secuencia de Fibonacci:</p>
<div class="highlight"><pre><span></span><code>Fibonacci(n) = Fibonacci(n-1) + Fibonacci(n-2)
Fibonacci(0) = 0
Fibonacci(1) = 1
</code></pre></div>
<p>Formulación recursiva en Scheme:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">fib</span><span class="w"> </span><span class="n">n</span><span class="p">)</span>
<span class="w">   </span><span class="p">(</span><span class="k">cond</span><span class="w"> </span><span class="p">((</span><span class="nb">=</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">      </span><span class="p">((</span><span class="nb">=</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>
<span class="w">      </span><span class="p">(</span><span class="k">else</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="p">(</span><span class="n">fib</span><span class="w"> </span><span class="p">(</span><span class="nb">-</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="mi">1</span><span class="p">))</span>
<span class="w">               </span><span class="p">(</span><span class="n">fib</span><span class="w"> </span><span class="p">(</span><span class="nb">-</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="mi">2</span><span class="p">))))))</span>
</code></pre></div>
<p>Evaluación de una llamada a Fibonacci:</p>
<p><img src="imagenes/fibonacci.png"/></p>
<p>Cada llamada a la recursión produce otras dos llamadas, por lo que el
número de llamadas finales es 2^n siendo n el número que se pasa a la
función.</p>
<p>El coste espacial y temporal es exponencial, O(2^n). Esto hace
inviable utilizar esta implementación para realizar el cálculo de la
función. Puedes comprobarlo intentando evaluar en el intérprete
<code>(fib 35)</code>.</p>
<h2 id="2-soluciones-al-coste-de-la-recursion-procesos-iterativos">2. Soluciones al coste de la recursión: procesos iterativos<a class="headerlink" href="#2-soluciones-al-coste-de-la-recursion-procesos-iterativos" title="Permanent link">&para;</a></h2>
<p>Diferenciamos entre procedimientos y procesos: un <strong>procedimiento</strong> es un
algoritmo y un <strong>proceso</strong> es la ejecución de ese algoritmo.</p>
<p>Es posible definir <em>procedimientos recursivos</em> que generen <em>procesos
iterativos</em> (como los bucles en programación imperativa) en los que <strong>no
se dejen llamadas recursivas en espera ni se incremente la pila de la
recursión</strong>. Para ello construimos la recursión de forma que en cada
llamada se haga un cálculo parcial y en el caso base se pueda devolver
directamente el resultado obtenido.</p>
<p>Este estilo de recursión se denomina <em>recursión por la cola</em>
(<a href="http://en.wikipedia.org/wiki/Tail_call">tail recursion</a>, en inglés).</p>
<p>Se puede realizar una implementación eficiente de la ejecución del
proceso, eliminando la pila de la recursión.</p>
<h3 id="21-factorial-iterativo">2.1. Factorial iterativo<a class="headerlink" href="#21-factorial-iterativo" title="Permanent link">&para;</a></h3>
<p>Empezamos a explicar la recursión por la cola con un ejemplo muy
sencillo: la versión iterativa de la típica función <code>factorial</code>. Le
pondremos de nombre a la función <code>factorial-iter</code>:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">factorial</span><span class="w"> </span><span class="n">n</span><span class="p">)</span>
<span class="w">   </span><span class="p">(</span><span class="n">fact-iter</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="n">n</span><span class="p">))</span>

<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">fact-iter</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="n">result</span><span class="p">)</span>
<span class="w">   </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>
<span class="w">      </span><span class="n">result</span>
<span class="w">      </span><span class="p">(</span><span class="n">fact-iter</span><span class="w"> </span><span class="p">(</span><span class="nb">-</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="p">(</span><span class="nb">-</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="mi">1</span><span class="p">))</span><span class="w">  </span><span class="p">)))</span>
</code></pre></div>
<p>La función <code>(fact-iter n result)</code> es la que define el proceso
iterativo. Su argumento <code>n</code> es el valor del que hay que calcular el
factorial y el argumento <code>result</code> es un parámetro adicional en el que
se van guardando los resultados intermedios.</p>
<p>En cada llamada recursiva, <code>n</code> se va haciendo cada vez más pequeño y
en <code>result</code> se va acumulando el cálculo del factorial. Al final de la
recursión el factorial debe estar calculado en <code>result</code> y se devuelve.</p>
<p>Veamos la secuencia de llamadas:</p>
<div class="highlight"><pre><span></span><code>(factorial 4)
(factorial-iter 4 4)
(factorial-iter 3 4*3=12)
(factorial-iter 2 12*2=24)
(factorial-iter 1 24*1=24)
24
</code></pre></div>
<p>Antes de realizar cada llamada recursiva se realiza el cálculo del
resultado parcial, que se guarda en el parámetro <code>result</code>. Después se
realiza la llamada con el nuevo valor calculado de <code>n</code> y de <code>result</code>.</p>
<p>Al final, cuando <code>n</code> vale <code>1</code> se devuelve el valor calculado de
<code>result</code>. Este valor es el resultado completo de la recursión, ya que
no hay que hacer ninguna operación más con él. A diferencia de los
procesos recursivos, en los que se quedan llamadas en espera en la
pila de la recursión, en los procesos iterativos no hay ninguna
llamada en espera. El resultado devuelto por el caso base es
directamente la solución de la recursión, no queda nada por hacer con
este resultado.</p>
<p>Es importante el valor inicial de <code>resultado</code>. La función <code>factorial</code>
se encarga de inicializar este parámetro. En este caso es el mismo
valor del número <code>n</code> a calcular el factorial. </p>
<p>La secuencia de llamadas recursivas acumula en la variable <code>result</code> el
valor del factorial:</p>
<div class="highlight"><pre><span></span><code>4 * 3 * 2 * 1 = 24
</code></pre></div>
<h3 id="22-version-iterativa-de-mi-length">2.2. Versión iterativa de mi-length<a class="headerlink" href="#22-version-iterativa-de-mi-length" title="Permanent link">&para;</a></h3>
<p>Veamos un segundo ejemplo. ¿Cómo sería la versión iterativa de
<code>mi-length</code>, la función que calcula la logitud de una lista?.</p>
<p>Tenemos que añadir un parámetro adicional en el que iremos acumulando
el resultado parcial. En este caso, cada vez que llamemos a la
recursión eliminado un elemento de la lista, incrementaremos en 1 el
valor del resultado. Para que funcione bien este enfoque, debemos
inicializar este resultado a 0.</p>
<p>La solución es la siguiente:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">mi-length</span><span class="w"> </span><span class="n">lista</span><span class="p">)</span>
<span class="w">   </span><span class="p">(</span><span class="n">mi-length-iter</span><span class="w"> </span><span class="n">lista</span><span class="w"> </span><span class="mi">0</span><span class="p">))</span>

<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">mi-length-iter</span><span class="w"> </span><span class="n">lista</span><span class="w"> </span><span class="n">result</span><span class="p">)</span>
<span class="w">   </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">null?</span><span class="w"> </span><span class="n">lista</span><span class="p">)</span>
<span class="w">      </span><span class="n">result</span>
<span class="w">      </span><span class="p">(</span><span class="n">mi-length-iter</span><span class="w"> </span><span class="p">(</span><span class="nb">rest</span><span class="w"> </span><span class="n">lista</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="mi">1</span><span class="p">))))</span>
</code></pre></div>
<p>Fijaros que, al igual que en la versión iterativa de factorial, no hay
ninguna llamada a ningúna función que recoja el resultado de la
llamada recursiva y haga algo con él. Directamente el resultado de la
llamada recursiva es el resultado final de la recursión.</p>
<h3 id="23-funcion-suma-lista-usando-recursion-por-la-cola">2.3. Función <code>suma-lista</code> usando recursión por la cola<a class="headerlink" href="#23-funcion-suma-lista-usando-recursion-por-la-cola" title="Permanent link">&para;</a></h3>
<p>Veamos otro ejemplo. Supongamos que queremos calcular usando recursión
por la cola la suma de los números de una lista.</p>
<p>Deberíamos añadir un parámetro adicional en el que vamos acumulando
esa suma. Inicializaremos a 0 ese parámetro e iremos en cada llamada
recursiva acumulando el primer elemento de la lista:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">suma-lista</span><span class="w"> </span><span class="n">lista</span><span class="p">)</span>
<span class="w">   </span><span class="p">(</span><span class="n">suma-lista-iter</span><span class="w"> </span><span class="n">lista</span><span class="w"> </span><span class="mi">0</span><span class="p">))</span>

<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">suma-lista-iter</span><span class="w"> </span><span class="n">lista</span><span class="w"> </span><span class="n">result</span><span class="p">)</span>
<span class="w">   </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">null?</span><span class="w"> </span><span class="n">lista</span><span class="p">)</span>
<span class="w">      </span><span class="n">result</span>
<span class="w">      </span><span class="p">(</span><span class="n">suma-lista-iter</span><span class="w"> </span><span class="p">(</span><span class="nb">rest</span><span class="w"> </span><span class="n">lista</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="n">lista</span><span class="p">)))))</span>
</code></pre></div>
<h3 id="24-caracteristicas-de-los-procesos-iterativos">2.4. Características de los procesos iterativos<a class="headerlink" href="#24-caracteristicas-de-los-procesos-iterativos" title="Permanent link">&para;</a></h3>
<p>Un resumen de las características de los procesos iterativos
resultantes de hacer una recursión por la cola:</p>
<ul>
<li>La recursión resultante es menos elegante.</li>
<li>Se necesita una parámetro adicional en el que se van acumulando los
  resultados parciales.</li>
<li>La última llamada a la recursión devuelve el valor acumulado.</li>
<li>El proceso resultante de la recursión es iterativo en el sentido de
  que no deja llamadas en espera ni incurre en coste espacial.</li>
</ul>
<h3 id="25-fibonacci-iterativo">2.5. Fibonacci iterativo<a class="headerlink" href="#25-fibonacci-iterativo" title="Permanent link">&para;</a></h3>
<p>Cualquier programa recursivo se puede transformar en otro que genera
un proceso iterativo.</p>
<p>En general, las versiones iterativas son menos intuitivas y más
difíciles de entender y depurar.</p>
<p>Veamos, por ejemplo, la formulación iterativa de Fibonacci:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">fib</span><span class="w"> </span><span class="n">n</span><span class="p">)</span>
<span class="w">   </span><span class="p">(</span><span class="n">fib-iter</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="n">n</span><span class="p">))</span>

<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">fib-iter</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="nb">count</span><span class="p">)</span>
<span class="w">   </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="nb">count</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">      </span><span class="n">b</span>
<span class="w">      </span><span class="p">(</span><span class="n">fib-iter</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="p">(</span><span class="nb">-</span><span class="w"> </span><span class="nb">count</span><span class="w"> </span><span class="mi">1</span><span class="p">))))</span>
</code></pre></div>
<p>La secuencia de llamadas recursivas sería la siguiente:</p>
<div class="highlight"><pre><span></span><code>(fib 6)
(fib-iter 1 0 6)
(fib-iter 1+0=1 1 5)
(fib-iter 1+1=2 1 4)
(fib-iter 2+1=3 2 3)
(fib-iter 3+2=5 3 2)
(fib-iter 5+3=8 5 1)
(fib-iter 8+5=13 8 0)
8
</code></pre></div>
<p>En la llamada recursiva <code>n</code>, el parámetro <code>a</code> guarda el valor de
fibonacci <code>n+1</code> y el parámetro <code>b</code> guarda el valor de fibonacci <code>n</code>,
que es el que se devuelve. Conseguimos <code>n</code> llamadas inicializando
<code>count</code> a n y decrementando el parámetro en 1 cada vez.</p>
<h3 id="26-triangulo-de-pascal">2.6. Triángulo de Pascal<a class="headerlink" href="#26-triangulo-de-pascal" title="Permanent link">&para;</a></h3>
<p>El <a href="https://en.wikipedia.org/wiki/Pascal's_triangle">triángulo de Pascal</a> es el siguiente triángulo de números.</p>
<div class="highlight"><pre><span></span><code>1
1   1
1   2   1
1   3   3   1
1   4   6   4   1
1   5  10   10  5   1
1   6  15  20   15  6   1
1   7  21  35   35  21  7   1
          ...
</code></pre></div>
<p>Si numeramos las filas y columnas empezando a contar por 0, la
expresión general del valor en una fila y columna determinada se puede
obtener con la siguiente definición recursiva:</p>
<div class="highlight"><pre><span></span><code>Pascal (n, 0) = 1
Pascal (n, n) = 1
Pascal (fila, columna) = 
    Pascal (fila-1,columna-1) + Pascal (fila-1, columna)
</code></pre></div>
<p>La función sólo está definida para valores de <code>columna</code> menores o
iguales que <code>fila</code>.</p>
<p>En Scheme es fácil escribir una función recursiva que implemente la
definición anterior:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">pascal</span><span class="w"> </span><span class="n">fila</span><span class="w"> </span><span class="n">col</span><span class="p">)</span>
<span class="w">   </span><span class="p">(</span><span class="k">cond</span><span class="w"> </span><span class="p">((</span><span class="nb">=</span><span class="w"> </span><span class="n">col</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>
<span class="w">         </span><span class="p">((</span><span class="nb">=</span><span class="w"> </span><span class="n">col</span><span class="w"> </span><span class="n">fila</span><span class="p">)</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>
<span class="w">         </span><span class="p">(</span><span class="k">else</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="p">(</span><span class="n">pascal</span><span class="w"> </span><span class="p">(</span><span class="nb">-</span><span class="w"> </span><span class="n">fila</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">-</span><span class="w"> </span><span class="n">col</span><span class="w"> </span><span class="mi">1</span><span class="p">))</span>
<span class="w">                  </span><span class="p">(</span><span class="n">pascal</span><span class="w"> </span><span class="p">(</span><span class="nb">-</span><span class="w"> </span><span class="n">fila</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="n">col</span><span class="p">)</span><span class="w"> </span><span class="p">))))</span>
<span class="p">(</span><span class="n">pascal</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span>
<span class="c1">; ⇒ 6</span>
<span class="p">(</span><span class="n">pascal</span><span class="w"> </span><span class="mi">8</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span>
<span class="c1">; ⇒ 70</span>
<span class="p">(</span><span class="n">pascal</span><span class="w"> </span><span class="mi">27</span><span class="w"> </span><span class="mi">13</span><span class="p">)</span>
<span class="c1">; ⇒ 20058300</span>
</code></pre></div>
<p>Hay que llamar a la función con un valor de <code>col</code> menor o igual que
<code>fila</code>. En el caso en que se pase un valor <code>col</code> mayor que <code>fila</code> la
recursión no termina y se entra en un bucle infinito.</p>
<p>La función tiene una formulación sencilla y funciona
correctamente. Sin embargo, el coste de esta recursión es también
exponencial, igual que pasaba en el caso de la secuencia de
fibonacci. Por ejemplo, la última expresión <code>(pascal 27 13)</code> tarda un
buen rato en devolver el resultado. Sería imposible calcular el valor
de números de Pascal un poco más grandes, como <code>(pascal 40 20)</code>.</p>
<p>Veamos cómo se puede conseguir una versión iterativa.</p>
<p>La idea es definir una función iterativa <code>pascal-fila</code> a la que le
pasamos el número de fila <code>n</code> y nos devuelve la lista de <code>n+1</code> números que
constituyen la fila <code>n</code> del triángulo de Pascal:</p>
<div class="highlight"><pre><span></span><code>fila 0 = (1)
fila 1 = (1 1)
fila 2 = (1 2 1)
fila 3 = (1 3 3 1)
fila 4 = (1 4 6 4 1)
...
</code></pre></div>
<p>Esta función necesitará un parámetro adicional (<code>lista-fila</code>) que se
inicializa con la lista <code>(1)</code> y en el que se va guardando cada fila
sucesiva. Esta fila va creciendo hasta que llegamos a la fila que
tenemos que devolver. Hay que hacer la iteración <code>n</code> veces, por lo que
vamos decrementando el parámetro <code>n</code> hasta que se llega a 0.</p>
<p>Para implementar esta función usamos otra llamada <code>(pascal-sig-fila
lista-fila)</code> que recibe una fila del triángulo y devuelve la
siguiente. </p>
<p>Por ejemplo:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="n">pascal-sig-fila</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">1</span><span class="p">))</span>
<span class="c1">; ⇒ (1 4 6 4 1)</span>
</code></pre></div>
<p>Esta función la implementamos con una función recursiva auxiliar (esta
es recursiva pura) llamada <code>(pascal-suma-dos-a-dos lista-fila)</code> que es
la que se encarga de realizar el cálculo de la nueva fila. No es
necesario convertir esta función a iterativa porque no genera un coste
exponencial.</p>
<p>El código completo es el siguiente:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">pascal</span><span class="w"> </span><span class="n">fila</span><span class="w"> </span><span class="n">col</span><span class="p">)</span>
<span class="w">   </span><span class="p">(</span><span class="nb">list-ref</span><span class="w"> </span><span class="p">(</span><span class="n">pascal-fila</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="n">fila</span><span class="p">)</span><span class="w"> </span><span class="n">col</span><span class="p">))</span>

<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">pascal-fila</span><span class="w"> </span><span class="n">lista-fila</span><span class="w"> </span><span class="n">n</span><span class="p">)</span>
<span class="w">   </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="n">n</span><span class="p">)</span>
<span class="w">      </span><span class="n">lista-fila</span>
<span class="w">      </span><span class="p">(</span><span class="n">pascal-fila</span><span class="w"> </span><span class="p">(</span><span class="n">pascal-sig-fila</span><span class="w"> </span><span class="n">lista-fila</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">-</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="mi">1</span><span class="p">))))</span>

<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">pascal-sig-fila</span><span class="w"> </span><span class="n">lista-fila</span><span class="p">)</span>
<span class="w">   </span><span class="p">(</span><span class="nb">append</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="w">           </span><span class="p">(</span><span class="n">pascal-suma-dos-a-dos</span><span class="w"> </span><span class="n">lista-fila</span><span class="p">)</span>
<span class="w">           </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span><span class="p">)))</span>

<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">pascal-suma-dos-a-dos</span><span class="w"> </span><span class="n">lista-fila</span><span class="p">)</span>
<span class="w">   </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">null?</span><span class="w"> </span><span class="p">(</span><span class="nb">rest</span><span class="w"> </span><span class="n">lista-fila</span><span class="p">))</span>
<span class="w">      </span><span class="o">&#39;</span><span class="p">()</span>
<span class="w">      </span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="n">lista-fila</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">second</span><span class="w"> </span><span class="n">lista-fila</span><span class="p">))</span>
<span class="w">            </span><span class="p">(</span><span class="n">pascal-suma-dos-a-dos</span><span class="w"> </span><span class="p">(</span><span class="nb">rest</span><span class="w"> </span><span class="n">lista-fila</span><span class="p">)))))</span>
</code></pre></div>
<p>Con esta implementación ya no se tiene un coste exponencial y se puede
calcular el valor de números como Pascal(40, 20):</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="n">pascal</span><span class="w"> </span><span class="mi">40</span><span class="w"> </span><span class="mi">20</span><span class="p">)</span>
<span class="c1">; ⇒ 137846528820</span>
</code></pre></div>
<h2 id="3-soluciones-al-coste-de-la-recursion-memoization">3. Soluciones al coste de la recursión: memoization<a class="headerlink" href="#3-soluciones-al-coste-de-la-recursion-memoization" title="Permanent link">&para;</a></h2>
<p>Una alternativa que mantiene la elegancia de los procesos recursivos y
la eficiencia de los iterativos es la
<a href="http://en.wikipedia.org/wiki/Memoization">memoization</a>. Si miramos la
traza de <code>(fib 4)</code> podemos ver que el coste está producido por
la repetición de llamadas; por ejemplo <code>(fib 3)</code> se evalúa 2
veces.</p>
<p>En programación funcional la llamada a <code>(fib 3)</code> siempre va a
devolver el mismo valor.</p>
<p>La idea de la <em>memoization</em> es guardar el valor devuelto por la
cada llamada en alguna estructura (una lista de asociación, por
ejemplo) y no volver a realizar la llamada a la recursión las
siguientes veces.</p>
<h3 id="31-fibonacci-con-memoization">3.1. Fibonacci con memoization<a class="headerlink" href="#31-fibonacci-con-memoization" title="Permanent link">&para;</a></h3>
<p>Para implementar la <em>memoization</em> necesitamos usar un diccionario con
los métodos <code>put</code> y <code>get</code> que actualizan su información con mutación.</p>
<ul>
<li>La función <code>(make-dic)</code> devuelve un diccionario vacío.</li>
<li>La función <code>(put key value dic)</code> asocia un valor a una clave, la
guarda en el diccionario (con mutación) y devuelve el valor.</li>
<li>La función <code>(get key dic)</code> devuelve el valor del diccionario asociado a
una clave (si no existe devuelve <code>#f</code>). </li>
<li>El predicado <code>(key-exists? key dic)</code> devuelve <code>#f</code> en que no exista la clave y <code>#t</code> si existe.</li>
</ul>
<p>Ejemplos:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">mi-dic</span><span class="w"> </span><span class="p">(</span><span class="n">make-dic</span><span class="p">))</span>
<span class="p">(</span><span class="n">put</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="n">mi-dic</span><span class="p">)</span><span class="w"> </span><span class="c1">; ⇒ 10</span>
<span class="p">(</span><span class="n">get</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="n">mi-dic</span><span class="p">)</span><span class="w"> </span><span class="c1">; ⇒ 10</span>
<span class="p">(</span><span class="n">key-exists?</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="n">dic</span><span class="p">)</span><span class="w"> </span><span class="c1">; ⇒ #f</span>
</code></pre></div>
<p>Estos métodos son imperativos porque modifican (mutan) la estructura
de datos que pasamos como parámetro (no pertenecen al paradigma funcional). La implementación de estas
funciones está incluidas en el <a href="https://raw.githubusercontent.com/domingogallardo/apuntes-lpp/master/src/lpp.rkt">fichero
<code>lpp.rkt</code></a>.</p>
<p>La función <code>fib-memo</code> realiza el cálculo de la serie de Fibonacci
utilizando exactamente la misma definición recursiva original, pero
añadiendo la técnica de <em>memoization</em>: lo primero que hacemos para
calcular el número de fibonacci <code>n</code>, antes de llamar a la recursión,
es comprobar si está ya guardado en la lista de asociación. En el caso
en que esté, lo devolvemos. Sólo cuando el número no está calculado
llamamos a la recursión para calcularlo.</p>
<p>La implementación se muestra a continuación. Vemos que para devolver
el número de fibonacci <code>n</code> se comprueba si ya está guardado en la
lista. Sólo en el caso en que no esté guardado se llama a la recursión
para calcularlo y guardarlo. La función <code>put</code> que guarda el nuevo
valor calculado también lo devuelve.</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">fib-memo</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="n">dic</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="k">cond</span><span class="w"> </span><span class="p">((</span><span class="nb">=</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">        </span><span class="p">((</span><span class="nb">=</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>
<span class="w">        </span><span class="p">((</span><span class="n">key-exists?</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="n">dic</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">get</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="n">dic</span><span class="p">))</span>
<span class="w">        </span><span class="p">(</span><span class="k">else</span><span class="w"> </span><span class="p">(</span><span class="n">put</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="p">(</span><span class="n">fib-memo</span><span class="w"> </span><span class="p">(</span><span class="nb">-</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="n">dic</span><span class="p">)</span>
<span class="w">                        </span><span class="p">(</span><span class="n">fib-memo</span><span class="w"> </span><span class="p">(</span><span class="nb">-</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="n">dic</span><span class="p">))</span><span class="w"> </span><span class="n">dic</span><span class="p">))))</span>
</code></pre></div>
<p>Podemos comprobar la diferencia de tiempos de ejecución entre esta
versión y la anterior. El coste de la función <em>memoizada</em> es
O(n). Frente al coste O(2^n) de la versión inicial que la hacía
imposible de utilizar.</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="n">fib-memo</span><span class="w"> </span><span class="mi">200</span><span class="w"> </span><span class="n">lista</span><span class="p">)</span>
<span class="n">⇒</span><span class="w"> </span><span class="mi">280571172992510140037611932413038677189525</span>
</code></pre></div>
<h2 id="4-figuras-recursivas">4. Figuras recursivas<a class="headerlink" href="#4-figuras-recursivas" title="Permanent link">&para;</a></h2>
<p>Vamos a terminar el apartado sobre procedimientos recursivos con un
último ejemplo algo distinto de los vistos hasta ahora. Usaremos la
recursión para dibujar figuras fractales usando la <a href="https://docs.racket-lang.org/teachpack/2htdpimage.html">librería de imágenes de
Racket <code>2htdp/image</code></a>.</p>
<h3 id="41-libreria-de-imagenes-de-racket">4.1. Librería de imágenes de Racket<a class="headerlink" href="#41-libreria-de-imagenes-de-racket" title="Permanent link">&para;</a></h3>
<p>Racket incluye una librería de imágenes en la que se proporcionan
funciones para construir imágenes. Con esta librería se pueden crear
imágenes sencillas como rectas, círculos, triángulos u otras figuras
geométricas. También se pueden modificar las imágenes creadas,
rotándolas o escalándolas, y formar otras imágenes mediante la
combinación de imagenes básicas.</p>
<h4 id="construccion-de-imagenes-basicas">Construcción de imágenes básicas<a class="headerlink" href="#construccion-de-imagenes-basicas" title="Permanent link">&para;</a></h4>
<p>Veamos algunos ejemplos de las primitivas de la librería para
construir imágenes básicas.</p>
<p>Podemos obtener un círculo, un cuadrado, un rectángulo y un triángulo
equilátero de la siguiente forma:</p>
<div class="highlight"><pre><span></span><code><span class="kn">#lang </span><span class="nn">racket</span>
<span class="p">(</span><span class="k">require</span><span class="w"> </span><span class="n">2htdp/image</span><span class="p">)</span>

<span class="p">(</span><span class="n">circle</span><span class="w"> </span><span class="mi">30</span><span class="w"> </span><span class="s2">&quot;solid&quot;</span><span class="w"> </span><span class="s2">&quot;blue&quot;</span><span class="p">)</span>
<span class="p">(</span><span class="n">square</span><span class="w"> </span><span class="mi">30</span><span class="w"> </span><span class="s2">&quot;outline&quot;</span><span class="w"> </span><span class="s2">&quot;black&quot;</span><span class="p">)</span>
<span class="p">(</span><span class="n">rectangle</span><span class="w"> </span><span class="mi">80</span><span class="w"> </span><span class="mi">40</span><span class="w"> </span><span class="s2">&quot;solid&quot;</span><span class="w"> </span><span class="s2">&quot;gray&quot;</span><span class="p">)</span>
<span class="p">(</span><span class="n">triangle</span><span class="w"> </span><span class="mi">40</span><span class="w"> </span><span class="s2">&quot;solid&quot;</span><span class="w"> </span><span class="s2">&quot;red&quot;</span><span class="p">)</span>
</code></pre></div>
<p>Cada instrucción construye la imagen correspondiente. Si lo ejecutamos
en el intérprete obtendremos lo siguiente:</p>
<p><img src="imagenes/imagenes-basicas.png" width="100px"/></p>
<p>Las imágenes son mapas de bits y su tamaño se expresa en píxeles. En
el caso del círculo se trata del radio, para el cuadrado indicamos su
lado, para el rectángulo la base y la altura y para el triángulo
equilátero su lado.</p>
<p>Debemos indicar también si queremos que la imagen se rellene de
forma sólida o se dibuje solo el borde. Y también su color, mediante
una cadena escogida de una <a href="https://docs.racket-lang.org/draw/color-database___.html">lista de colores permitidos</a>.</p>
<p>Podemos también construir un triángulo isósceles indicando la longitud
de sus lados iguales y el ángulo entre ellos:</p>
<div class="highlight"><pre><span></span><code><span class="w"> </span><span class="p">(</span><span class="n">isosceles-triangle</span><span class="w"> </span><span class="mi">60</span><span class="w"> </span><span class="mi">30</span><span class="w"> </span><span class="s2">&quot;outline&quot;</span><span class="w"> </span><span class="s2">&quot;black&quot;</span><span class="p">)</span><span class="w"> </span>
</code></pre></div>
<p><img src="imagenes/image-isosceles.png" width="360px"/></p>
<p>Por último, otra primitiva que vamos a utilizar más adelante es un
trazo de una línea:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="n">line</span><span class="w"> </span><span class="mi">30</span><span class="w"> </span><span class="mi">30</span><span class="w"> </span><span class="s2">&quot;black&quot;</span><span class="p">)</span>
</code></pre></div>
<p><img src="imagenes/image-line.png" width="30"/></p>
<p>Esta función construye una imagen con una línea hasta la posición
(30,30) (la coordenada <em>x</em> crece hacia la derecha y la <em>y</em> hacia
abajo).</p>
<p>Prueba a construir algunas imágenes usando los comandos anteriores y
cambiando sus parámetros.</p>
<h4 id="operaciones-y-combinaciones-de-imagenes">Operaciones y combinaciones de imágenes<a class="headerlink" href="#operaciones-y-combinaciones-de-imagenes" title="Permanent link">&para;</a></h4>
<p>En la librería de imágenes se definen también funciones que permiten
transformar y combinar imágenes. Vamos a ver algunos de ellas.</p>
<p>Podemos rotar una imagen un ángulo, expresado en grados sexagesimales
en el sentido contrario de las agujas del reloj.</p>
<p>Por ejemplo, podemos rotar el triángulo isósceles anterior:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">triangulo</span><span class="w"> </span><span class="p">(</span><span class="n">isosceles-triangle</span><span class="w"> </span><span class="mi">60</span><span class="w"> </span><span class="mi">30</span><span class="w"> </span><span class="s2">&quot;outline&quot;</span><span class="w"> </span><span class="s2">&quot;black&quot;</span><span class="p">))</span>
<span class="p">(</span><span class="n">rotate</span><span class="w"> </span><span class="mi">90</span><span class="w"> </span><span class="n">triangulo</span><span class="p">)</span><span class="w"> </span>
<span class="c1">; ⇒ imagen rotada 90 grados en sentido contrario a las agujas del reloj</span>
<span class="p">(</span><span class="n">rotate</span><span class="w"> </span><span class="mi">-90</span><span class="w"> </span><span class="n">triangulo</span><span class="p">)</span>
<span class="c1">; ⇒ imagen rotada 90 grados en sentido de las agujas del reloj</span>
</code></pre></div>
<p><img src="imagenes/imagen-rotada.png" width="500px"/></p>
<p>Podemos también combinar imágenes, agrupándolas con las funciones
<code>above</code> y <code>beside</code>. Las dos funciones reciben un número variable de
argumentos y devuelven una nueva imagen en la que las imágenes se han
colocado unas sobre otras o unas al lado de otras.</p>
<p>Por ejemplo:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="n">above</span><span class="w"> </span><span class="p">(</span><span class="n">ellipse</span><span class="w"> </span><span class="mi">70</span><span class="w"> </span><span class="mi">20</span><span class="w"> </span><span class="s2">&quot;solid&quot;</span><span class="w"> </span><span class="s2">&quot;gray&quot;</span><span class="p">)</span>
<span class="w">       </span><span class="p">(</span><span class="n">ellipse</span><span class="w"> </span><span class="mi">50</span><span class="w"> </span><span class="mi">20</span><span class="w"> </span><span class="s2">&quot;solid&quot;</span><span class="w"> </span><span class="s2">&quot;darkgray&quot;</span><span class="p">)</span>
<span class="w">       </span><span class="p">(</span><span class="n">ellipse</span><span class="w"> </span><span class="mi">30</span><span class="w"> </span><span class="mi">20</span><span class="w"> </span><span class="s2">&quot;solid&quot;</span><span class="w"> </span><span class="s2">&quot;dimgray&quot;</span><span class="p">)</span>
<span class="w">       </span><span class="p">(</span><span class="n">ellipse</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="mi">20</span><span class="w"> </span><span class="s2">&quot;solid&quot;</span><span class="w"> </span><span class="s2">&quot;black&quot;</span><span class="p">))</span>
</code></pre></div>
<p>La llamada anterior devuelve la siguiente imagen:</p>
<p><img src="imagenes/image-above.png" width="340px"/></p>
<p>Otro ejemplo:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="n">beside</span><span class="w"> </span><span class="p">(</span><span class="n">ellipse</span><span class="w"> </span><span class="mi">20</span><span class="w"> </span><span class="mi">70</span><span class="w"> </span><span class="s2">&quot;solid&quot;</span><span class="w"> </span><span class="s2">&quot;gray&quot;</span><span class="p">)</span>
<span class="w">        </span><span class="p">(</span><span class="n">ellipse</span><span class="w"> </span><span class="mi">20</span><span class="w"> </span><span class="mi">50</span><span class="w"> </span><span class="s2">&quot;solid&quot;</span><span class="w"> </span><span class="s2">&quot;darkgray&quot;</span><span class="p">)</span>
<span class="w">        </span><span class="p">(</span><span class="n">ellipse</span><span class="w"> </span><span class="mi">20</span><span class="w"> </span><span class="mi">30</span><span class="w"> </span><span class="s2">&quot;solid&quot;</span><span class="w"> </span><span class="s2">&quot;dimgray&quot;</span><span class="p">)</span>
<span class="w">        </span><span class="p">(</span><span class="n">ellipse</span><span class="w"> </span><span class="mi">20</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="s2">&quot;solid&quot;</span><span class="w"> </span><span class="s2">&quot;black&quot;</span><span class="p">))</span>
</code></pre></div>
<p>Que produce:</p>
<p><img src="imagenes/image-beside.png" width="340px"/></p>
<p>En los dos ejemplos anteriores las imágenes agrupadas se alinean en el
centro. Si queremos otra alineación podemos especificarla usando las
funciones <code>above/align</code> y <code>beside/align</code>. </p>
<p>En el caso de <code>above</code>, que acumula las imágenes unas sobre otras,
podremos especificar si queremos alinearlas a la izquierda o a la
derecha:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="n">above/align</span><span class="w"> </span><span class="s2">&quot;left&quot;</span>
<span class="w">               </span><span class="p">(</span><span class="n">ellipse</span><span class="w"> </span><span class="mi">70</span><span class="w"> </span><span class="mi">20</span><span class="w"> </span><span class="s2">&quot;solid&quot;</span><span class="w"> </span><span class="s2">&quot;yellowgreen&quot;</span><span class="p">)</span>
<span class="w">               </span><span class="p">(</span><span class="n">ellipse</span><span class="w"> </span><span class="mi">50</span><span class="w"> </span><span class="mi">20</span><span class="w"> </span><span class="s2">&quot;solid&quot;</span><span class="w"> </span><span class="s2">&quot;olivedrab&quot;</span><span class="p">)</span>
<span class="w">               </span><span class="p">(</span><span class="n">ellipse</span><span class="w"> </span><span class="mi">30</span><span class="w"> </span><span class="mi">20</span><span class="w"> </span><span class="s2">&quot;solid&quot;</span><span class="w"> </span><span class="s2">&quot;darkolivegreen&quot;</span><span class="p">)</span>
<span class="w">               </span><span class="p">(</span><span class="n">ellipse</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="mi">20</span><span class="w"> </span><span class="s2">&quot;solid&quot;</span><span class="w"> </span><span class="s2">&quot;darkgreen&quot;</span><span class="p">))</span>
</code></pre></div>
<p><img src="imagenes/image-above-left.png" width="100px"/></p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="n">above/align</span><span class="w"> </span><span class="s2">&quot;right&quot;</span>
<span class="w">               </span><span class="p">(</span><span class="n">ellipse</span><span class="w"> </span><span class="mi">70</span><span class="w"> </span><span class="mi">20</span><span class="w"> </span><span class="s2">&quot;solid&quot;</span><span class="w"> </span><span class="s2">&quot;gold&quot;</span><span class="p">)</span>
<span class="w">               </span><span class="p">(</span><span class="n">ellipse</span><span class="w"> </span><span class="mi">50</span><span class="w"> </span><span class="mi">20</span><span class="w"> </span><span class="s2">&quot;solid&quot;</span><span class="w"> </span><span class="s2">&quot;goldenrod&quot;</span><span class="p">)</span>
<span class="w">               </span><span class="p">(</span><span class="n">ellipse</span><span class="w"> </span><span class="mi">30</span><span class="w"> </span><span class="mi">20</span><span class="w"> </span><span class="s2">&quot;solid&quot;</span><span class="w"> </span><span class="s2">&quot;darkgoldenrod&quot;</span><span class="p">)</span>
<span class="w">               </span><span class="p">(</span><span class="n">ellipse</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="mi">20</span><span class="w"> </span><span class="s2">&quot;solid&quot;</span><span class="w"> </span><span class="s2">&quot;sienna&quot;</span><span class="p">))</span>
</code></pre></div>
<p><img src="imagenes/image-above-right.png" width="100px"/></p>
<p>En el caso de <code>beside</code>, que acumula las imágenes unas junto a otras,
podemos especificar si queremos alinearla arriba o abajo:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="n">beside/align</span><span class="w"> </span><span class="s2">&quot;top&quot;</span>
<span class="w">                </span><span class="p">(</span><span class="n">ellipse</span><span class="w"> </span><span class="mi">20</span><span class="w"> </span><span class="mi">70</span><span class="w"> </span><span class="s2">&quot;solid&quot;</span><span class="w"> </span><span class="s2">&quot;mediumorchid&quot;</span><span class="p">)</span>
<span class="w">                </span><span class="p">(</span><span class="n">ellipse</span><span class="w"> </span><span class="mi">20</span><span class="w"> </span><span class="mi">50</span><span class="w"> </span><span class="s2">&quot;solid&quot;</span><span class="w"> </span><span class="s2">&quot;darkorchid&quot;</span><span class="p">)</span>
<span class="w">                </span><span class="p">(</span><span class="n">ellipse</span><span class="w"> </span><span class="mi">20</span><span class="w"> </span><span class="mi">30</span><span class="w"> </span><span class="s2">&quot;solid&quot;</span><span class="w"> </span><span class="s2">&quot;purple&quot;</span><span class="p">)</span>
<span class="w">                </span><span class="p">(</span><span class="n">ellipse</span><span class="w"> </span><span class="mi">20</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="s2">&quot;solid&quot;</span><span class="w"> </span><span class="s2">&quot;indigo&quot;</span><span class="p">))</span>
</code></pre></div>
<p><img src="imagenes/image-beside-top.png" width="100px"/></p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="n">beside/align</span><span class="w"> </span><span class="s2">&quot;bottom&quot;</span>
<span class="w">                </span><span class="p">(</span><span class="n">ellipse</span><span class="w"> </span><span class="mi">20</span><span class="w"> </span><span class="mi">70</span><span class="w"> </span><span class="s2">&quot;solid&quot;</span><span class="w"> </span><span class="s2">&quot;lightsteelblue&quot;</span><span class="p">)</span>
<span class="w">                </span><span class="p">(</span><span class="n">ellipse</span><span class="w"> </span><span class="mi">20</span><span class="w"> </span><span class="mi">50</span><span class="w"> </span><span class="s2">&quot;solid&quot;</span><span class="w"> </span><span class="s2">&quot;mediumslateblue&quot;</span><span class="p">)</span>
<span class="w">                </span><span class="p">(</span><span class="n">ellipse</span><span class="w"> </span><span class="mi">20</span><span class="w"> </span><span class="mi">30</span><span class="w"> </span><span class="s2">&quot;solid&quot;</span><span class="w"> </span><span class="s2">&quot;slateblue&quot;</span><span class="p">)</span>
<span class="w">                </span><span class="p">(</span><span class="n">ellipse</span><span class="w"> </span><span class="mi">20</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="s2">&quot;solid&quot;</span><span class="w"> </span><span class="s2">&quot;navy&quot;</span><span class="p">))</span>
</code></pre></div>
<p><img src="imagenes/image-beside-bottom.png" width="100px"/></p>
<p>Podemos combinar todas las funciones anteriores para construir figuras
complejas. Por ejemplo:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="n">rotate</span><span class="w"> </span><span class="mi">45</span>
<span class="w">        </span><span class="p">(</span><span class="n">above</span><span class="w"> </span><span class="p">(</span><span class="n">triangle</span><span class="w"> </span><span class="mi">40</span><span class="w"> </span><span class="s2">&quot;solid&quot;</span><span class="w"> </span><span class="s2">&quot;orange&quot;</span><span class="p">)</span>
<span class="w">               </span><span class="p">(</span><span class="n">beside</span><span class="w"> </span><span class="p">(</span><span class="n">rectangle</span><span class="w"> </span><span class="mi">40</span><span class="w"> </span><span class="mi">30</span><span class="w"> </span><span class="s2">&quot;solid&quot;</span><span class="w"> </span><span class="s2">&quot;black&quot;</span><span class="p">)</span>
<span class="w">                       </span><span class="p">(</span><span class="n">rectangle</span><span class="w"> </span><span class="mi">40</span><span class="w"> </span><span class="mi">30</span><span class="w"> </span><span class="s2">&quot;solid&quot;</span><span class="w"> </span><span class="s2">&quot;olivedrab&quot;</span><span class="p">))))</span>
</code></pre></div>
<p><img src="imagenes/imagen-compleja.png" width="100px"/></p>
<p>Prueba a realizar algunas figuras combinando figuras básicas con las
funciones anteriores.</p>
<h3 id="42-triangulo-de-sierpinski">4.2. Triángulo de Sierpinski<a class="headerlink" href="#42-triangulo-de-sierpinski" title="Permanent link">&para;</a></h3>
<p>Vamos a utilizar las funciones anteriores que construyen imágenes para
construir una figura fractal, el denominado riángulo de Sierpinski,
usando la recursión.</p>
<p><img src="imagenes/sierpinski.png" width="400px"/></p>
<p><em>Triángulo de Sierpinski</em></p>
<ul>
<li>¿Ves alguna recursión en la figura?</li>
<li>¿Cuál podría ser el parámetro de la función que la dibujara? </li>
<li>¿Se te ocurre un algoritmo recursivo que la dibuje, usando las
  funciones de combinación de imágenes vistas?</li>
</ul>
<p>La figura es <em>autosimilar</em> (una característica de las figuras
fractales). Una parte de la figura es idéntica a la figura total, pero
reducida de escala. Esto nos da una pista de que es posible dibujar la
figura con un algoritmo recursivo.</p>
<p>Para intentar encontrar una forma de enfocar el problema, vamos a
pensarlo de la siguiente forma: supongamos que tenemos tres triángulos
de Sierpinski de anchura <em>x</em>. ¿Cómo podríamos construir el triángulo
de Sierpinski de anchura <em>2*x</em>?</p>
<p>Lo podríamos hacer combinando las tres imágenes de la siguiente forma:</p>
<ol>
<li>Juntamos 2 triángulos uno junto a otro.</li>
<li>Sobre la figura resultante colocamos (alineada en el centro) el
   triángulo restante.</li>
</ol>
<p>En la siguiente figura se muestra el esquema de esta combinación. Cada
rectángulo representa la imagen de sierpinski de anchura <em>x</em> y la
combinación representa la imagen de anchura <em>2*x</em>.</p>
<p><img src="imagenes/image-esquema-sierpinski.png" width="300px"/></p>
<p>El algoritmo recursivo se basa en la misma idea, pero <strong>hacia
atrás</strong>. Dibujamos un triángulo de anchura <em>x</em> basándonos en 3
llamadas recursivas a triángulos más pequeños (de anchura <em>x/2</em>).</p>
<p>En el caso base, cuando <em>x</em> sea menor que un umbral <em>h</em>, dibujaremos un
triángulo elemental de base <em>h</em>.</p>
<p>Veamos cómo hacerlo con la librería de imágenes de Racket.</p>
<h4 id="421-caso-base-de-la-recursion">4.2.1. Caso base de la recursión<a class="headerlink" href="#421-caso-base-de-la-recursion" title="Permanent link">&para;</a></h4>
<p>Para construir la imagen elemental del triángulo de Sierpinski
necesitamos un triángulo isósceles de ángulo 90 y base <em>h</em>. </p>
<p>Tal y como muestra la siguiente figura, podemos dividir este triángulo
en dos mitades. Si el ángulo superior es 90 grados, su mitad será de
45 grados, por lo que los dos subtriángulos serán triángulos
rectángulos cuyos catetos medirán <em>h/2</em>. La hipotenusa de esos
triángulos son los lados del triángulo isósceles original. La altura
del triángulo isósceles original será también <em>h/2</em>.</p>
<p><img src="imagenes/image-sierpinski-elemental.png" width="350px"/></p>
<p>La hipotenusa de un triángulo rectángulo con dos catetos de longitud
<em>x</em> se calcula con la siguiente expresión:</p>
<div class="arithmatex">
<div class="MathJax_Preview">hipot(x) = \sqrt{x^2+x^2} = x \sqrt{2}</div>
<script type="math/tex; mode=display">hipot(x) = \sqrt{x^2+x^2} = x \sqrt{2}</script>
</div>
<p>Lo podemos expresar en Racket:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">hipotenusa</span><span class="w"> </span><span class="n">x</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="p">(</span><span class="nb">sqrt</span><span class="w"> </span><span class="mi">2</span><span class="p">)))</span>
</code></pre></div>
<p>Una vez definida la función <code>hipotenusa</code> podemos dibujar el triángulo
de Sierpinski elemental de base <code>h</code>. Será un triángulo isósceles de
ángulo 90 grados y de longitud de lado <code>hipotenusa(h/2)</code>:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">sierpinski-elem</span><span class="w"> </span><span class="n">base</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="n">isosceles-triangle</span><span class="w"> </span><span class="p">(</span><span class="n">hipotenusa</span><span class="w"> </span><span class="p">(</span><span class="nb">/</span><span class="w"> </span><span class="n">base</span><span class="w"> </span><span class="mi">2</span><span class="p">))</span><span class="w"> </span><span class="mi">90</span><span class="w"> </span><span class="s2">&quot;outline&quot;</span><span class="w"> </span><span class="s2">&quot;black&quot;</span><span class="p">))</span>
</code></pre></div>
<p>Por ejemplo, la llamada a </p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="n">sierpinski-elem</span><span class="w"> </span><span class="mi">40</span><span class="p">)</span>
</code></pre></div>
<p>produce la siguiente imagen:</p>
<p><img src="imagenes/image-sierpinski-elem.png" width="180px"/></p>
<h4 id="422-caso-general-de-la-recursion">4.2.2. Caso general de la recursión<a class="headerlink" href="#422-caso-general-de-la-recursion" title="Permanent link">&para;</a></h4>
<p>El caso general de la recursión para dibujar el triángulo de
Sierpinski de ancho <em>x</em> se construye llamando a la recursión para que
construya el triángulo de ancho <em>x/2</em> y componiendo la imagen
resultante con el patrón visto anteriormente.</p>
<p>El código de la función completa es el siguiente:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">sierpinski</span><span class="w"> </span><span class="n">ancho</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">&lt;</span><span class="w"> </span><span class="n">ancho</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span>
<span class="w">      </span><span class="p">(</span><span class="n">sierpinski-elem</span><span class="w"> </span><span class="n">ancho</span><span class="p">)</span>
<span class="w">      </span><span class="p">(</span><span class="n">above</span><span class="w"> </span><span class="p">(</span><span class="n">sierpinski</span><span class="w"> </span><span class="p">(</span><span class="nb">/</span><span class="w"> </span><span class="n">ancho</span><span class="w"> </span><span class="mi">2</span><span class="p">))</span>
<span class="w">             </span><span class="p">(</span><span class="n">beside</span><span class="w"> </span><span class="p">(</span><span class="n">sierpinski</span><span class="w"> </span><span class="p">(</span><span class="nb">/</span><span class="w"> </span><span class="n">ancho</span><span class="w"> </span><span class="mi">2</span><span class="p">))</span>
<span class="w">                     </span><span class="p">(</span><span class="n">sierpinski</span><span class="w"> </span><span class="p">(</span><span class="nb">/</span><span class="w"> </span><span class="n">ancho</span><span class="w"> </span><span class="mi">2</span><span class="p">))))))</span>
</code></pre></div>
<ul>
<li>Si el ancho es menor que un umbral (10) se dibuja el triángulo elemental.</li>
<li>Si el ancho es mayor o igual a 10 se hacen tres llamadas recursivas a
  <code>sierpienski</code> con el <em>ancho / 2</em>. Cada llamada recursiva devolverá
  la imagen con el triángulo de sierpinski más pequeño.</li>
<li>La llamada a <code>beside</code> juntará las dos imágenes inferiores.</li>
<li>La llamada a <code>above</code> colocará el tercer triángulo sobre la composición
  anterior, centrado en el centro.</li>
</ul>
<p>Un ejemplo de la ejecución:</p>
<p><img src="imagenes/image-sierpinski.png" width="600px"/></p>
<p>El código anterior no es nada eficiente porque cada llamada recursiva
genera a su vez otras 3 llamadas, provocando un coste exponencial como
hemos visto al comienzo del tema.</p>
<p>En este caso es muy sencillo eliminar las tres llamadas porque las
tres son llamadas repetidas que van a devolver exactamente la misma
figura. Podemos entonces usar la técnica que ya hemos usado otras
veces de llamar a una función auxiliar con el resultado de la
recursión. Esta función auxiliar recogerá en su parámetro el valor
devuelto por la recursión y realizará con ese valor las operaciones
necesarias.</p>
<p>En este caso, el valor obtenido por la recursión es la figura de
Serpienski más pequeña. La función auxiliar recibirá entonces esa
figura y deberá combinarla tres veces para formar la figura de
Sierpinski mayor.</p>
<p>El código resultante es el siguiente:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">componer-sierpinski</span><span class="w"> </span><span class="n">figura</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="n">above</span><span class="w"> </span><span class="n">figura</span>
<span class="w">           </span><span class="p">(</span><span class="n">beside</span><span class="w"> </span><span class="n">figura</span><span class="w"> </span><span class="n">figura</span><span class="p">)))</span>

<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">sierpinski</span><span class="w"> </span><span class="n">ancho</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">&lt;</span><span class="w"> </span><span class="n">ancho</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span>
<span class="w">      </span><span class="p">(</span><span class="n">sierpinski-elem</span><span class="w"> </span><span class="n">ancho</span><span class="p">)</span>
<span class="w">      </span><span class="p">(</span><span class="n">componer-sierpinski</span><span class="w"> </span><span class="p">(</span><span class="n">sierpinski</span><span class="w"> </span><span class="p">(</span><span class="nb">/</span><span class="w"> </span><span class="n">ancho</span><span class="w"> </span><span class="mi">2</span><span class="p">)))))</span>
</code></pre></div>
<h3 id="43-curva-de-hilbert">4.3. Curva de Hilbert<a class="headerlink" href="#43-curva-de-hilbert" title="Permanent link">&para;</a></h3>
<p>La curva de Hilbert es una curva fractal que tiene la propiedad de
rellenar completamente el plano.</p>
<p><img src="imagenes/hilbert-scheme.png" width="300px"/></p>
<p>Su dibujo tiene una formulación recursiva:</p>
<p><img src="imagenes/hilbert.png" width="600px"/></p>
<p>La imagen H2 se puede componer a partir de cuatro imágenes H1
siguiendo un patrón. Es el mismo patrón con el que se puede componer
la imagen H3 a partir de cuatro imágenes H2.</p>
<p>El patrón se muestra en la siguiente función <code>(componer-hilbert imagen)</code>: </p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">trazo-horizontal</span><span class="w"> </span><span class="n">long</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="n">line</span><span class="w"> </span><span class="n">long</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="s2">&quot;black&quot;</span><span class="p">))</span>

<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">trazo-vertical</span><span class="w"> </span><span class="n">long</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="n">rotate</span><span class="w"> </span><span class="mi">90</span><span class="w"> </span><span class="p">(</span><span class="n">trazo-horizontal</span><span class="w"> </span><span class="n">long</span><span class="p">)))</span>

<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">componer-hilbert</span><span class="w"> </span><span class="n">imagen</span><span class="w"> </span><span class="n">long-trazo</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="n">beside</span><span class="w"> </span><span class="p">(</span><span class="n">above/align</span><span class="w"> </span><span class="s2">&quot;left&quot;</span>
<span class="w">                       </span><span class="p">(</span><span class="n">beside/align</span><span class="w"> </span><span class="s2">&quot;bottom&quot;</span><span class="w"> </span><span class="n">imagen</span><span class="w"> </span><span class="p">(</span><span class="n">trazo-horizontal</span><span class="w"> </span><span class="n">long-trazo</span><span class="p">))</span>
<span class="w">                       </span><span class="p">(</span><span class="n">trazo-vertical</span><span class="w"> </span><span class="n">long-trazo</span><span class="p">)</span>
<span class="w">                       </span><span class="p">(</span><span class="n">rotate</span><span class="w"> </span><span class="mi">-90</span><span class="w"> </span><span class="n">imagen</span><span class="p">))</span>
<span class="w">          </span><span class="p">(</span><span class="n">above/align</span><span class="w"> </span><span class="s2">&quot;right&quot;</span>
<span class="w">                       </span><span class="n">imagen</span>
<span class="w">                       </span><span class="p">(</span><span class="n">trazo-vertical</span><span class="w"> </span><span class="n">long-trazo</span><span class="p">)</span>
<span class="w">                       </span><span class="p">(</span><span class="n">rotate</span><span class="w"> </span><span class="mi">90</span><span class="w"> </span><span class="n">imagen</span><span class="p">))))</span>
</code></pre></div>
<ul>
<li>La primera llamada a <code>above/align</code> compone una imagen juntando la
  imagen original con un trazo horizontal y apilando (con una
  alineación a la izquierda) esta imagen sobre un trazo vertical
  y sobre la imagen original girada 90 grados en el sentido de
  las agujas del reloj.</li>
<li>La segunda llamada a <code>above/align</code> construye otra imagen apilando
  (con una alineación a la derecha) la imagen original, un trazo
  vertical y la imagen rotada 90 grados en sentido contrario a las
  agujas del reloj.</li>
<li>Por último la llamada a <code>beside</code> junta las dos imágenes anteriores.</li>
</ul>
<p>Podemos ver un ejemplo del funcionamiento de esta composición usando
una imagen base formada por un cuadrado con un triángulo dentro.</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="n">overlay</span><span class="w"> </span><span class="p">(</span><span class="n">triangle</span><span class="w"> </span><span class="mi">20</span><span class="w"> </span><span class="s2">&quot;solid&quot;</span><span class="w"> </span><span class="s2">&quot;green&quot;</span><span class="p">)</span>
<span class="w">         </span><span class="p">(</span><span class="n">rectangle</span><span class="w"> </span><span class="mi">20</span><span class="w"> </span><span class="mi">20</span><span class="w"> </span><span class="s2">&quot;solid&quot;</span><span class="w"> </span><span class="s2">&quot;black&quot;</span><span class="p">))</span><span class="err">)</span>
</code></pre></div>
<p><img src="imagenes/imagen-ejemplo-componer.png" width="30px"/></p>
<p>Si llamamos a <code>componer-hilbert</code> con la imagen anterior, usando una longitud
de trazo de 16 píxeles, podemos ver que se construye el patrón básico
de la curva de Hilbert, el que construye la imagen H2 a partir de H1.</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">imagen</span><span class="w"> </span><span class="p">(</span><span class="n">overlay</span><span class="w"> </span><span class="p">(</span><span class="n">triangle</span><span class="w"> </span><span class="mi">20</span><span class="w"> </span><span class="s2">&quot;solid&quot;</span><span class="w"> </span><span class="s2">&quot;green&quot;</span><span class="p">)</span>
<span class="w">                        </span><span class="p">(</span><span class="n">rectangle</span><span class="w"> </span><span class="mi">20</span><span class="w"> </span><span class="mi">20</span><span class="w"> </span><span class="s2">&quot;solid&quot;</span><span class="w"> </span><span class="s2">&quot;black&quot;</span><span class="p">)))</span>
<span class="n">imagen</span><span class="w"> </span>
<span class="p">(</span><span class="n">componer-hilbert</span><span class="w"> </span><span class="n">imagen</span><span class="w"> </span><span class="mi">16</span><span class="p">)</span>
</code></pre></div>
<p><img src="imagenes/imagen-componer.png" width="500px"/></p>
<p>Una vez entendido este patrón de composición, podemos ya formular el
algoritmo recursivo:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">hilbert</span><span class="w"> </span><span class="n">nivel</span><span class="w"> </span><span class="n">long-trazo</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="n">nivel</span><span class="p">)</span>
<span class="w">      </span><span class="p">(</span><span class="n">beside/align</span><span class="w"> </span><span class="s2">&quot;top&quot;</span>
<span class="w">                    </span><span class="p">(</span><span class="n">trazo-vertical</span><span class="w"> </span><span class="n">long-trazo</span><span class="p">)</span>
<span class="w">                    </span><span class="p">(</span><span class="n">trazo-horizontal</span><span class="w"> </span><span class="n">long-trazo</span><span class="p">)</span>
<span class="w">                    </span><span class="p">(</span><span class="n">trazo-vertical</span><span class="w"> </span><span class="n">long-trazo</span><span class="p">))</span>
<span class="w">      </span><span class="p">(</span><span class="n">componer-hilbert</span><span class="w"> </span><span class="p">(</span><span class="n">hilbert</span><span class="w"> </span><span class="p">(</span><span class="nb">-</span><span class="w"> </span><span class="n">nivel</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="n">long-trazo</span><span class="p">)</span><span class="w"> </span><span class="n">long-trazo</span><span class="p">)))</span>
</code></pre></div>
<ul>
<li>El caso base es el nivel 1, en el que se construye el trazo básico
  de la curva de Hilbert con la longitud de trazo que se pasa como
  parámetro.</li>
<li>Para cualquier nivel <em>n</em>  mayor que 1, se llama a la recursión para
  formar la curva de Hilbert de nivel <em>n-1</em> y, con la imagen
  resultante, se llama a la función <code>componer-hilbert</code>.</li>
</ul>
<p>En la siguiente imagen se muestran distintas llamadas a la función <code>hilbert</code>:</p>
<p><img src="imagenes/image-hilbert.png" width="600px"/></p>
<h2 id="5-bibliografia">5. Bibliografía<a class="headerlink" href="#5-bibliografia" title="Permanent link">&para;</a></h2>
<p>Capítulos del libro <em>Structure and Intepretation of Computer Programs</em>:</p>
<ul>
<li><a href="https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book-Z-H-11.html#%_sec_1.2">1.2 - Procedures and the Processes They Generate</a></li>
<li><a href="https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book-Z-H-11.html#%_sec_1.2.1">1.2.1 - Linear Recursion and Iteration</a></li>
<li><a href="https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book-Z-H-11.html#%_sec_1.2.2">1.2.2 - Tree Recursion</a></li>
</ul>
<p>Manual de Racket:</p>
<ul>
<li><a href="https://docs.racket-lang.org/teachpack/2htdpimage.html">Librería
  image.rkt</a></li>
<li><a href="https://docs.racket-lang.org/teachpack/2htdpimage-guide.html">Image Guide</a></li>
</ul>
<hr />
<p>Lenguajes y Paradigmas de Programación, curso 2024-25<br />
© Departamento Ciencia de la Computación e Inteligencia Artificial, Universidad de Alicante<br />
Domingo Gallardo, Cristina Pomares, Antonio Botía, Francisco Martínez</p>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "../..", "features": ["content.code.copy"], "search": "../../assets/javascripts/workers/search.07f07601.min.js", "translations": {"clipboard.copied": "Copiado al portapapeles", "clipboard.copy": "Copiar al portapapeles", "search.result.more.one": "1 m\u00e1s en esta p\u00e1gina", "search.result.more.other": "# m\u00e1s en esta p\u00e1gina", "search.result.none": "No se encontraron documentos", "search.result.one": "1 documento encontrado", "search.result.other": "# documentos encontrados", "search.result.placeholder": "Teclee para comenzar b\u00fasqueda", "search.result.term.missing": "Falta", "select.version": "Seleccionar versi\u00f3n"}}</script>
    
    
      <script src="../../assets/javascripts/bundle.56dfad97.min.js"></script>
      
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML"></script>
      
    
  </body>
</html>