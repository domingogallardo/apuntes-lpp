



<!doctype html>
<html lang="es" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      <meta http-equiv="x-ua-compatible" content="ie=edge">
      
      
      
      
        <meta name="lang:clipboard.copy" content="Copiar al portapapeles">
      
        <meta name="lang:clipboard.copied" content="Copiado al portapapeles">
      
        <meta name="lang:search.language" content="en">
      
        <meta name="lang:search.pipeline.stopwords" content="True">
      
        <meta name="lang:search.pipeline.trimmer" content="True">
      
        <meta name="lang:search.result.none" content="No se encontraron documentos">
      
        <meta name="lang:search.result.one" content="1 documento encontrado">
      
        <meta name="lang:search.result.other" content="# documentos encontrados">
      
        <meta name="lang:search.tokenizer" content="[\s\-]+">
      
      <link rel="shortcut icon" href="../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.0.4, mkdocs-material-4.6.0">
    
    
      
        <title>Tema 3: Procedimientos recursivos - LPP</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/application.1b62728e.css">
      
        <link rel="stylesheet" href="../../assets/stylesheets/application-palette.a8b3c06d.css">
      
      
        
        
        <meta name="theme-color" content="#009688">
      
    
    
      <script src="../../assets/javascripts/modernizr.268332fc.js"></script>
    
    
      
        <link href="https://fonts.gstatic.com" rel="preconnect" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Ubuntu:300,400,400i,700%7CRoboto+Mono&display=fallback">
        <style>body,input{font-family:"Ubuntu","Helvetica Neue",Helvetica,Arial,sans-serif}code,kbd,pre{font-family:"Roboto Mono","Courier New",Courier,monospace}</style>
      
    
    <link rel="stylesheet" href="../../assets/fonts/material-icons.css">
    
    
    
      
    
    
  </head>
  
    
    
    <body dir="ltr" data-md-color-primary="teal" data-md-color-accent="teal">
  
    <svg class="md-svg">
      <defs>
        
        
      </defs>
    </svg>
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" data-md-component="overlay" for="__drawer"></label>
    
      <a href="#tema-3-procedimientos-recursivos" tabindex="1" class="md-skip">
        Saltar a contenido
      </a>
    
    
      <header class="md-header" data-md-component="header">
  <nav class="md-header-nav md-grid">
    <div class="md-flex">
      <div class="md-flex__cell md-flex__cell--shrink">
        <a href="../.." title="LPP" class="md-header-nav__button md-logo">
          
            <img src="../../imagenes/logo.png" width="24" height="24">
          
        </a>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        <label class="md-icon md-icon--menu md-header-nav__button" for="__drawer"></label>
      </div>
      <div class="md-flex__cell md-flex__cell--stretch">
        <div class="md-flex__ellipsis md-header-nav__title" data-md-component="title">
          
            <span class="md-header-nav__topic">
              LPP
            </span>
            <span class="md-header-nav__topic">
              
                Tema 3: Procedimientos recursivos
              
            </span>
          
        </div>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        
          <label class="md-icon md-icon--search md-header-nav__button" for="__search"></label>
          
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" placeholder="Búsqueda" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="query" data-md-state="active">
      <label class="md-icon md-search__icon" for="__search"></label>
      <button type="reset" class="md-icon md-search__icon" data-md-component="reset" tabindex="-1">
        &#xE5CD;
      </button>
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="result">
          <div class="md-search-result__meta">
            Teclee para comenzar búsqueda
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
        
      </div>
      
    </div>
  </nav>
</header>
    
    <div class="md-container">
      
        
      
      
      <main class="md-main" role="main">
        <div class="md-main__inner md-grid" data-md-component="container">
          
            
              <div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    <nav class="md-nav md-nav--primary" data-md-level="0">
  <label class="md-nav__title md-nav__title--site" for="__drawer">
    <a href="../.." title="LPP" class="md-nav__button md-logo">
      
        <img src="../../imagenes/logo.png" width="48" height="48">
      
    </a>
    LPP
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-1" type="checkbox" id="nav-1">
    
    <label class="md-nav__link" for="nav-1">
      Teoría
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-1">
        Teoría
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../tema00-descripcion-asignatura/tema00-descripcion-asignatura.html" title="Descripción de la asignatura" class="md-nav__link">
      Descripción de la asignatura
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../tema01-historia-lenguajes-programacion/tema01-historia-lenguajes-programacion.html" title="Tema 1: Historia de los lenguajes de programación" class="md-nav__link">
      Tema 1: Historia de los lenguajes de programación
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../tema02-programacion-funcional/tema02-programacion-funcional.html" title="Tema 2: Programación funcional" class="md-nav__link">
      Tema 2: Programación funcional
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-2" type="checkbox" id="nav-2">
    
    <label class="md-nav__link" for="nav-2">
      Seminarios
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-2">
        Seminarios
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../seminarios/seminario1-scheme/seminario1-scheme.html" title="Seminario de Scheme" class="md-nav__link">
      Seminario de Scheme
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              <div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    
<nav class="md-nav md-nav--secondary">
  
  
    
  
  
    <label class="md-nav__title" for="__toc">Tabla de contenidos</label>
    <ul class="md-nav__list" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#pensando-recursivamente" class="md-nav__link">
    Pensando recursivamente
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#el-coste-de-la-recursion" class="md-nav__link">
    El coste de la recursión
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#la-pila-de-la-recursion" class="md-nav__link">
    La pila de la recursión
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#coste-espacial-de-la-recursion" class="md-nav__link">
    Coste espacial de la recursión
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#el-coste-depende-del-numero-de-llamadas-a-la-recursion" class="md-nav__link">
    El coste depende del número de llamadas a la recursión
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#soluciones-al-coste-de-la-recursion-procesos-iterativos" class="md-nav__link">
    Soluciones al coste de la recursión: procesos iterativos
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#factorial-iterativo" class="md-nav__link">
    Factorial iterativo
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#version-iterativa-de-mi-length" class="md-nav__link">
    Versión iterativa de mi-length
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#funcion-suma-lista-usando-recursion-por-la-cola" class="md-nav__link">
    Función suma-lista usando recursión por la cola
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#procesos-iterativos" class="md-nav__link">
    Procesos iterativos
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#fibonacci-iterativo" class="md-nav__link">
    Fibonacci iterativo
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#triangulo-de-pascal" class="md-nav__link">
    Triángulo de Pascal
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#soluciones-al-coste-de-la-recursion-memoization" class="md-nav__link">
    Soluciones al coste de la recursión: memoization
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#fibonacci-con-memoization" class="md-nav__link">
    Fibonacci con memoization
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#recursion-y-graficos-de-tortuga" class="md-nav__link">
    Recursión y gráficos de tortuga
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#graficos-de-tortuga-en-racket" class="md-nav__link">
    Gráficos de tortuga en Racket
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#triangulo-de-sierpinski" class="md-nav__link">
    Triángulo de Sierpinski
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#sierpinski-en-racket" class="md-nav__link">
    Sierpinski en Racket
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#recursion-mutua" class="md-nav__link">
    Recursión mutua
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ejemplo-avanzado-curvas-de-hilbert" class="md-nav__link">
    Ejemplo avanzado: curvas de Hilbert
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#bibliografia-sicp" class="md-nav__link">
    Bibliografía - SICP
  </a>
  
</li>
      
      
      
      
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content">
            <article class="md-content__inner md-typeset">
              
                
                
                <h1 id="tema-3-procedimientos-recursivos">Tema 3: Procedimientos recursivos<a class="headerlink" href="#tema-3-procedimientos-recursivos" title="Permanent link">&para;</a></h1>
<p>Ya hemos visto algunos muchos ejemplos de funciones recursivas. Una
función es recursiva cuando se llama a si misma. Una vez que uno se
acostumbra a su uso, se comprueba que la recursión es una forma mucho
más natural que la iteración de expresar un gran número de funciones y
procedimientos.</p>
<p>La formulación matemática de la recursión es sencilla de entender,
pero su implementación en un lenguaje de programación no lo es
tanto. El primer lenguaje de programación que permitió el uso de
expresiones recursivas fue el Lisp. En el momento de su creación
existía ya el Fortran, que no permitía que una función se llamase a si
misma.</p>
<p>Ya hemos visto la utilidad de la recursión en muchos ejemplos para
recorrer listas, para filtrarlas, etc. En este tema veremos algunos
aspectos negativos de la recursión: su coste espacial y
temporal. Veremos que hay soluciones a estos problemas, cambiando el
estilo de la recursión y generando <em>procesos iterativos</em> o usando un
enfoque automático llamado <em>memoization</em> en el que se guardan los
resultados de cada llamada recursiva. Por último, veremos un último
ejemplo curioso e interesante de la recursión para realizar figuras
fractales con gráficos de tortuga.</p>
<h2 id="pensando-recursivamente">Pensando recursivamente<a class="headerlink" href="#pensando-recursivamente" title="Permanent link">&para;</a></h2>
<p>Para diseñar procedimientos recursivos no funciona el método de
<em>prueba y error</em>. Hay que diseñar la solución recursiva desde el
principio. Debemos fijarnos en <em>lo que devuelve la función</em> y debemos
preguntarnos cómo sería posible descomponer el problema de forma que
podamos lanzar la recursión sobre una versión más sencilla del
mismo. Supondremos que la llamada recursiva funciona correctamente y
devuelve el resultado correcto. Y después debemos transformar este
resultado correcto de la versión más pequeña en el resultado de la
solución completa.</p>
<p>Es muy importante escribir y pensar en las funciones de forma
declarativa, teniendo en cuenta lo que hacen y no cómo lo hacen.</p>
<p>Debes <strong>confiar en que la llamada recursiva va a hacer su trabajo y
devolver el resultado correcto</strong>, sin preocuparte de cómo lo va a
hacer. Después tendrás que utilizar lo que la llamada recursiva ha
devuelto para componer la solución definitiva al problema.</p>
<p>Para diseñar un algoritmo recursivo es útil no ponerse a programar
directamente, sino reflexionar sobre la solución recursiva con algún
ejemplo. El objetivo es obtener una formulación abstracta del caso
general de la recursión antes de programarlo. Una vez que encontramos
esta formulación, pasarlo a un lenguaje de programación es muy
sencillo.</p>
<p>Por último, deberemos reflexionar en el caso base. Debe ser el caso
más sencillo que puede recibir como parámetro la recursión. Debe
devolver un valor compatible con la definición de la función. Por
ejemplo, si la función debe construir una lista, el caso base debe
devolver también una lista. Si la función construye una pareja, el
caso base también devolverá una pareja. No debemos olvidar que el caso
base es también un ejemplo de invocación de la función.</p>
<p>Ya hemos usado todos estos consejos en el tema anterior y en las
prácticas realizadas hasta ahora.</p>
<p>Veamos ejemplo más. ¿cómo definimos una lista palíndroma de forma
recursiva?. Por ejemplo, las siguientes listas son palíndromas:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="err">{1 2 3 3 2 1}</span>
<span class="err">{1 2 1}</span>
<span class="err">{1}</span>
<span class="err">&#39;()</span>
</pre></div>
</td></tr></table>

<p>Comenzamos con una definición <strong>no recursiva</strong>:</p>
<blockquote>
<p>Una lista es palíndroma cuando es igual a su inversa. </p>
</blockquote>
<p>Esta definición no es recursiva porque no llamamos a la recursión con
un caso más sencillo.</p>
<p>La definición <strong>recursiva</strong> del caso general es la siguiente:</p>
<blockquote>
<p>Una lista es palíndroma cuando su primer elemento es igual que el
último y la lista resultante de quitar el primer y el último
elemento también es palíndroma</p>
</blockquote>
<p>En el caso base debemos buscar el caso más pequeño no contemplado por
la definición anterior. En este caso, una lista de un elemento y una
lista vacía también las consideraremos palíndromas.</p>
<blockquote>
<p>palindroma(lista) &lt;=&gt; (primer-elemento(lista) == ultimo-elemento(lista))  y palindroma(quitar-primero-ultimo(lista)) <br />
palindroma(lista) &lt;=&gt; un-elemento(lista) o vacía(lista) </p>
</blockquote>
<p>Podemos escribir la definición en Scheme, usando la función <code>or</code> para
indicar que la lista es palíndroma si sucede una de las tres condiciones:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">palindroma?</span> <span class="nv">lista</span><span class="p">)</span>
   <span class="p">(</span><span class="k">or </span><span class="p">(</span><span class="nb">null? </span><span class="nv">lista</span><span class="p">)</span>
       <span class="p">(</span><span class="nb">null? </span><span class="p">(</span><span class="nb">cdr </span><span class="nv">lista</span><span class="p">))</span>
       <span class="p">(</span><span class="k">and </span><span class="p">(</span><span class="nb">equal? </span><span class="p">(</span><span class="nb">car </span><span class="nv">lista</span><span class="p">)</span> <span class="p">(</span><span class="nf">ultimo</span> <span class="nv">lista</span><span class="p">))</span>
            <span class="p">(</span><span class="nf">palindroma?</span> <span class="p">(</span><span class="nf">quitar-primero-ultimo</span> <span class="nv">lista</span><span class="p">)))))</span>
</pre></div>
</td></tr></table>

<p>La función auxiliar <code>quitar-primero-ultimo</code> la podemos definir así:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">quitar-ultimo</span> <span class="nv">lista</span><span class="p">)</span>
   <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">null? </span><span class="p">(</span><span class="nb">cdr </span><span class="nv">lista</span><span class="p">))</span>
      <span class="o">&#39;</span><span class="p">()</span>
      <span class="p">(</span><span class="nb">cons </span><span class="p">(</span><span class="nb">car </span><span class="nv">lista</span><span class="p">)</span>
            <span class="p">(</span><span class="nf">quitar-ultimo</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">lista</span><span class="p">)))))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">quitar-primero-ultimo</span> <span class="nv">lista</span><span class="p">)</span>
   <span class="p">(</span><span class="nb">cdr </span><span class="p">(</span><span class="nf">quitar-ultimo</span> <span class="nv">lista</span><span class="p">)))</span>
</pre></div>
</td></tr></table>

<h2 id="el-coste-de-la-recursion">El coste de la recursión<a class="headerlink" href="#el-coste-de-la-recursion" title="Permanent link">&para;</a></h2>
<p>Hasta ahora hemos estudiado el diseño de funciones recursivas. Vamos a
tratar por primera vez su coste. Veremos que hay casos en los que es
prohibitivo utilizar la recursión tal y como la hemos visto. Y veremos
también que existen soluciones para esos casos.</p>
<h3 id="la-pila-de-la-recursion">La pila de la recursión<a class="headerlink" href="#la-pila-de-la-recursion" title="Permanent link">&para;</a></h3>
<p>Vamos a estudiar el comportamiento de la evaluación de una llamada a
una función recursiva. Supongamos la función
<code>mi-length</code>:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">mi-length</span> <span class="nv">items</span><span class="p">)</span>
   <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">null? </span><span class="nv">items</span><span class="p">)</span>
      <span class="mi">0</span>
      <span class="p">(</span><span class="nb">+ </span><span class="mi">1</span> <span class="p">(</span><span class="nf">mi-length</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">items</span><span class="p">)))))</span>
</pre></div>
</td></tr></table>

<p>Examinamos cómo se evalúan las llamadas recursivas:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="err">(mi-length &#39;(a b c d))</span>
<span class="err">(+ 1 (mi-length &#39;(b c d)))</span>
<span class="err">(+ 1 (+ 1 (mi-length &#39;(c d))))</span>
<span class="err">(+ 1 (+ 1 (+ 1 (mi-length &#39;(d)))))</span>
<span class="err">(+ 1 (+ 1 (+ 1 (+ 1 (mi-length &#39;())))))</span>
<span class="err">(+ 1 (+ 1 (+ 1 (+ 1 0))))</span>
<span class="err">(+ 1 (+ 1 (+ 1 1)))</span>
<span class="err">(+ 1 (+ 1 2))</span>
<span class="err">(+ 1 3)</span>
<span class="err">4</span>
</pre></div>
</td></tr></table>

<p>Cada llamada a la recursión deja una función <strong>en espera de ser
evaluada</strong> cuando la recursión devuelva un valor (en el caso anterior
las funciones suma). Estas llamadas en espera, junto con sus
argumentos, se almacenan en la <em>pila de la recursión</em>.</p>
<p>Cuando la recursión devuelve un valor, los valores se recuperan de la
pila, se realiza la llamada y se devuelve el valor a la anterior
llamada en espera. </p>
<p>Si la recursión está mal hecha y nunca termina se genera un <em>stack
overflow</em> porque la memoria que se almacena en la pila sobrepasa la
memoria reservada para el intérprete DrRacket.</p>
<h3 id="coste-espacial-de-la-recursion">Coste espacial de la recursión<a class="headerlink" href="#coste-espacial-de-la-recursion" title="Permanent link">&para;</a></h3>
<p>El coste espacial de un programa es una función que relaciona la
memoria consumida por una llamada para resolver un problema con alguna
variable que determina el tamaño del problema a resolver.</p>
<p>En el caso de la función <code>mi-length</code> el tamaño del problema viene dado
por la longitud de la lista. El coste espacial de <code>mi-lenght</code> es
<em>O(n)</em>, siendo <em>n</em> la longitud de la lista.</p>
<h3 id="el-coste-depende-del-numero-de-llamadas-a-la-recursion">El coste depende del número de llamadas a la recursión<a class="headerlink" href="#el-coste-depende-del-numero-de-llamadas-a-la-recursion" title="Permanent link">&para;</a></h3>
<p>Veamos con un ejemplo que el coste de las llamadas recursivas puede
dispararse. Supongamos la famosa <a href="http://en.wikipedia.org/wiki/Fibonacci_number">secuencia de Fibonacci</a>:
0,1,1,2,3,5,8,13,...</p>
<p>Formulación matemática de la secuencia de Fibonacci:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="err">Fibonacci(n) = Fibonacci(n-1) + Fibonacci(n-2)  </span>
<span class="err">Fibonacci(0) = 0  </span>
<span class="err">Fibonacci(1) = 1</span>
</pre></div>
</td></tr></table>

<p>Formulación recursiva en Scheme:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">fib</span> <span class="nv">n</span><span class="p">)</span>
   <span class="p">(</span><span class="k">cond </span><span class="p">((</span><span class="nb">= </span><span class="nv">n</span> <span class="mi">0</span><span class="p">)</span> <span class="mi">0</span><span class="p">)</span>
      <span class="p">((</span><span class="nb">= </span><span class="nv">n</span> <span class="mi">1</span><span class="p">)</span> <span class="mi">1</span><span class="p">)</span>
      <span class="p">(</span><span class="k">else </span><span class="p">(</span><span class="nb">+ </span><span class="p">(</span><span class="nf">fib</span> <span class="p">(</span><span class="nb">- </span><span class="nv">n</span> <span class="mi">1</span><span class="p">))</span>
               <span class="p">(</span><span class="nf">fib</span> <span class="p">(</span><span class="nb">- </span><span class="nv">n</span> <span class="mi">2</span><span class="p">))))))</span>
</pre></div>
</td></tr></table>

<p>Evaluación de una llamada a Fibonacci:</p>
<p><img src="imagenes/fibonacci.png"/></p>
<p>Cada llamada a la recursión produce otras dos llamadas, por lo que el
número de llamadas finales es 2^n siendo n el número que se pasa a la
función.</p>
<p>El coste espacial y temporal es exponencial, O(2^n). Esto hace
inviable utilizar esta implementación para realizar el cálculo de la
función. Puedes comprobarlo intentando evaluar en el intérprete
<code>(fib 35)</code>.</p>
<h2 id="soluciones-al-coste-de-la-recursion-procesos-iterativos">Soluciones al coste de la recursión: procesos iterativos<a class="headerlink" href="#soluciones-al-coste-de-la-recursion-procesos-iterativos" title="Permanent link">&para;</a></h2>
<p>Diferenciamos entre procedimientos y procesos: un <strong>procedimiento</strong> es un
algoritmo y un <strong>proceso</strong> es la ejecución de ese algoritmo.</p>
<p>Es posible definir <em>procedimientos recursivos</em> que generen <em>procesos
iterativos</em> (como los bucles en programación imperativa) en los que <strong>no
se dejen llamadas recursivas en espera ni se incremente la pila de la
recursión</strong>. Para ello construimos la recursión de forma que en cada
llamada se haga un cálculo parcial y en el caso base se pueda devolver
directamente el resultado obtenido.</p>
<p>Este estilo de recursión se denomina <em>recursión por la cola</em>
(<a href="http://en.wikipedia.org/wiki/Tail_call">tail recursion</a>, en inglés).</p>
<p>Se puede realizar una implementación eficiente de la ejecución del
proceso, eliminando la pila de la recursión.</p>
<h3 id="factorial-iterativo">Factorial iterativo<a class="headerlink" href="#factorial-iterativo" title="Permanent link">&para;</a></h3>
<p>Empezamos a explicar la recursión por la cola con un ejemplo muy
sencillo: la versión iterativa de la típica función <code>factorial</code>. Le
pondremos de nombre a la función <code>factorial-iter</code>:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">factorial</span> <span class="nv">n</span><span class="p">)</span>
   <span class="p">(</span><span class="nf">fact-iter</span> <span class="nv">n</span> <span class="nv">n</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">fact-iter</span> <span class="nv">n</span> <span class="nv">result</span><span class="p">)</span>
   <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="nv">n</span> <span class="mi">1</span><span class="p">)</span>
      <span class="nv">result</span>
      <span class="p">(</span><span class="nf">fact-iter</span> <span class="p">(</span><span class="nb">- </span><span class="nv">n</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nb">* </span><span class="nv">result</span> <span class="p">(</span><span class="nb">- </span><span class="nv">n</span> <span class="mi">1</span><span class="p">))</span>  <span class="p">)))</span>
</pre></div>
</td></tr></table>

<p>La función <code>(fact-iter n result)</code> es la que define el proceso
iterativo. Su argumento <code>n</code> es el valor del que hay que calcular el
factorial y el argumento <code>result</code> es un parámetro adicional en el que
se van guardando los resultados intermedios.</p>
<p>En cada llamada recursiva, <code>n</code> se va haciendo cada vez más pequeño y
en <code>result</code> se va acumulando el cálculo del factorial. Al final de la
recursión el factorial debe estar calculado en <code>result</code> y se devuelve.</p>
<p>Veamos la secuencia de llamadas:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="err">(factorial 4)</span>
<span class="err">(factorial-iter 4 4)</span>
<span class="err">(factorial-iter 3 4*3=12)</span>
<span class="err">(factorial-iter 2 12*2=24)</span>
<span class="err">(factorial-iter 1 24*1=24)</span>
<span class="err">24</span>
</pre></div>
</td></tr></table>

<p>Antes de realizar cada llamada recursiva se realiza el cálculo del
resultado parcial, que se guarda en el parámetro <code>result</code>. Después se
realiza la llamada con el nuevo valor calculado de <code>n</code> y de <code>result</code>.</p>
<p>Al final, cuando <code>n</code> vale <code>1</code> se devuelve el valor calculado de
<code>result</code>. Este valor es el resultado completo de la recursión, ya que
no hay que hacer ninguna operación más con él. A diferencia de los
procesos recursivos, en los que se quedan llamadas en espera en la
pila de la recursión, en los procesos iterativos no hay ninguna
llamada en espera. El resultado devuelto por el caso base es
directamente la solución de la recursión, no queda nada por hacer con
este resultado.</p>
<p>Es importante el valor inicial de <code>resultado</code>. La función <code>factorial</code>
se encarga de inicializar este parámetro. En este caso es el mismo
valor del número <code>n</code> a calcular el factorial. </p>
<p>La secuencia de llamadas recursivas acumula en la variable <code>result</code> el
valor del factorial:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="err">4 * 3 * 2 * 1 = 24</span>
</pre></div>
</td></tr></table>

<h3 id="version-iterativa-de-mi-length">Versión iterativa de mi-length<a class="headerlink" href="#version-iterativa-de-mi-length" title="Permanent link">&para;</a></h3>
<p>Veamos un segundo ejemplo. ¿Cómo sería la versión iterativa de
<code>mi-length</code>, la función que calcula la logitud de una lista?.</p>
<p>Tenemos que añadir un parámetro adicional en el que iremos acumulando
el resultado parcial. En este caso, cada vez que llamemos a la
recursión eliminado un elemento de la lista, incrementaremos en 1 el
valor del resultado. Para que funcione bien este enfoque, debemos
inicializar este resultado a 0.</p>
<p>La solución es la siguiente:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">mi-length</span> <span class="nv">lista</span><span class="p">)</span>
   <span class="p">(</span><span class="nf">mi-length-iter</span> <span class="nv">lista</span> <span class="mi">0</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">mi-length-iter</span> <span class="nv">lista</span> <span class="nv">result</span><span class="p">)</span>
   <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">null? </span><span class="nv">lista</span><span class="p">)</span>
      <span class="nv">result</span>
      <span class="p">(</span><span class="nf">mi-length-iter</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">lista</span><span class="p">)</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">result</span> <span class="mi">1</span><span class="p">))))</span>
</pre></div>
</td></tr></table>

<p>Fijaros que, al igual que en la versión iterativa de factorial, no hay
ninguna llamada a ningúna función que recoja el resultado de la
llamada recursiva y haga algo con él. Directamente el resultado de la
llamada recursiva es el resultado final de la recursión.</p>
<h3 id="funcion-suma-lista-usando-recursion-por-la-cola">Función <code>suma-lista</code> usando recursión por la cola<a class="headerlink" href="#funcion-suma-lista-usando-recursion-por-la-cola" title="Permanent link">&para;</a></h3>
<p>Veamos otro ejemplo. Supongamos que queremos calcular usando recursión
por la cola la suma de los números de una lista.</p>
<p>Deberíamos añadir un parámetro adicional en el que vamos acumulando
esa suma. Inicializaremos a 0 ese parámetro e iremos en cada llamada
recursiva acumulando el primer elemento de la lista:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">suma-lista</span> <span class="nv">lista</span><span class="p">)</span>
   <span class="p">(</span><span class="nf">suma-lista-iter</span> <span class="nv">lista</span> <span class="mi">0</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">suma-lista-iter</span> <span class="nv">lista</span> <span class="nv">result</span><span class="p">)</span>
   <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">null? </span><span class="nv">lista</span><span class="p">)</span>
      <span class="nv">result</span>
      <span class="p">(</span><span class="nf">suma-lista-iter</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">lista</span><span class="p">)</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">result</span> <span class="p">(</span><span class="nb">car </span><span class="nv">lista</span><span class="p">)))))</span>
</pre></div>
</td></tr></table>

<h3 id="procesos-iterativos">Procesos iterativos<a class="headerlink" href="#procesos-iterativos" title="Permanent link">&para;</a></h3>
<p>Un resumen de las características de los procesos iterativos
resultantes de hacer una recursión por la cola:</p>
<ul>
<li>La recursión resultante es menos elegante.</li>
<li>Se necesita una parámetro adicional en el que se van acumulando los
  resultados parciales.</li>
<li>La última llamada a la recursión devuelve el valor acumulado.</li>
<li>El proceso resultante de la recursión es iterativo en el sentido de
  que no deja llamadas en espera ni incurre en coste espacial.</li>
</ul>
<h3 id="fibonacci-iterativo">Fibonacci iterativo<a class="headerlink" href="#fibonacci-iterativo" title="Permanent link">&para;</a></h3>
<p>Cualquier programa recursivo se puede transformar en otro que genera
un proceso iterativo.</p>
<p>En general, las versiones iterativas son menos intuitivas y más
difíciles de entender y depurar.</p>
<p>Veamos, por ejemplo, la formulación iterativa de Fibonacci:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">fib</span> <span class="nv">n</span><span class="p">)</span>
   <span class="p">(</span><span class="nf">fib-iter</span> <span class="mi">1</span> <span class="mi">0</span> <span class="nv">n</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">fib-iter</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">count</span><span class="p">)</span>
   <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="nv">count</span> <span class="mi">0</span><span class="p">)</span>
      <span class="nv">b</span>
      <span class="p">(</span><span class="nf">fib-iter</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">a</span> <span class="nv">b</span><span class="p">)</span> <span class="nv">a</span> <span class="p">(</span><span class="nb">- </span><span class="nv">count</span> <span class="mi">1</span><span class="p">))))</span>
</pre></div>
</td></tr></table>

<p>La secuencia de llamadas recursivas sería la siguiente:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="err">(fib 6)</span>
<span class="err">(fib-iter 1 0 6)</span>
<span class="err">(fib-iter 1+0=1 1 5)</span>
<span class="err">(fib-iter 1+1=2 1 4)</span>
<span class="err">(fib-iter 2+1=3 2 3)</span>
<span class="err">(fib-iter 3+2=5 3 2)</span>
<span class="err">(fib-iter 5+3=8 5 1)</span>
<span class="err">(fib-iter 8+5=13 8 0)</span>
<span class="err">8</span>
</pre></div>
</td></tr></table>

<p>En la llamada recursiva <code>n</code>, el parámetro <code>a</code> guarda el valor de
fibonacci <code>n+1</code> y el parámetro <code>b</code> guarda el valor de fibonacci <code>n</code>,
que es el que se devuelve. Conseguimos <code>n</code> llamadas inicializando
<code>count</code> a n y decrementando el parámetro en 1 cada vez.</p>
<h3 id="triangulo-de-pascal">Triángulo de Pascal<a class="headerlink" href="#triangulo-de-pascal" title="Permanent link">&para;</a></h3>
<p>El <a href="https://en.wikipedia.org/wiki/Pascal's_triangle">triángulo de Pascal</a> es el siguiente triángulo de números.</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="err">1</span>
<span class="err">1   1</span>
<span class="err">1   2   1</span>
<span class="err">1   3   3   1</span>
<span class="err">1   4   6   4   1</span>
<span class="err">1   5  10   10  5   1</span>
<span class="err">1   6  15  20   15  6   1</span>
<span class="err">1   7  21  35   35  21  7   1</span>
<span class="err">          ...</span>
</pre></div>
</td></tr></table>

<p>Si numeramos las filas y columnas empezando a contar por 0, la
expresión general del valor en una fila y columna determinada se puede
obtener con la siguiente definición recursiva:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="err">Pascal (n, 0) = 1  </span>
<span class="err">Pascal (n, n) = 1  </span>
<span class="err">Pascal (fila, columna) = Pascal (fila-1,columna-1) + Pascal (fila-1, columna)</span>
</pre></div>
</td></tr></table>

<p>La función sólo está definida para valores de <code>columna</code> menores o
iguales que <code>fila</code>.</p>
<p>En Scheme es fácil escribir una función recursiva que implemente la
definición anterior:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">pascal</span> <span class="nv">fila</span> <span class="nv">col</span><span class="p">)</span>
   <span class="p">(</span><span class="k">cond </span><span class="p">((</span><span class="nb">= </span><span class="nv">col</span> <span class="mi">0</span><span class="p">)</span> <span class="mi">1</span><span class="p">)</span>
         <span class="p">((</span><span class="nb">= </span><span class="nv">col</span> <span class="nv">fila</span><span class="p">)</span> <span class="mi">1</span><span class="p">)</span>
         <span class="p">(</span><span class="k">else </span><span class="p">(</span><span class="nb">+ </span><span class="p">(</span><span class="nf">pascal</span> <span class="p">(</span><span class="nb">- </span><span class="nv">fila</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nb">- </span><span class="nv">col</span> <span class="mi">1</span><span class="p">))</span>
                  <span class="p">(</span><span class="nf">pascal</span> <span class="p">(</span><span class="nb">- </span><span class="nv">fila</span> <span class="mi">1</span><span class="p">)</span> <span class="nv">col</span><span class="p">)</span> <span class="p">))))</span>
<span class="p">(</span><span class="nf">pascal</span> <span class="mi">4</span> <span class="mi">2</span><span class="p">)</span>
<span class="c1">; ⇒ 6</span>
<span class="p">(</span><span class="nf">pascal</span> <span class="mi">8</span> <span class="mi">4</span><span class="p">)</span>
<span class="c1">; ⇒ 70</span>
<span class="p">(</span><span class="nf">pascal</span> <span class="mi">27</span> <span class="mi">13</span><span class="p">)</span>
<span class="c1">; ⇒ 20058300</span>
</pre></div>
</td></tr></table>

<p>Hay que llamar a la función con un valor de <code>col</code> menor o igual que
<code>fila</code>. En el caso en que se pase un valor <code>col</code> mayor que <code>fila</code> la
recursión no termina y se entra en un bucle infinito.</p>
<p>La función tiene una formulación sencilla y funciona
correctamente. Sin embargo, el coste de esta recursión es también
exponencial, igual que pasaba en el caso de la secuencia de
fibonacci. Por ejemplo, la última expresión <code>(pascal 27 13)</code> tarda un
buen rato en devolver el resultado. Sería imposible calcular el valor
de números de Pascal un poco más grandes, como <code>(pascal 40 20)</code>.</p>
<p>Veamos cómo se puede conseguir una versión iterativa.</p>
<p>La idea es definir una función iterativa <code>pascal-fila</code> a la que le
pasamos el número de fila <code>n</code> y nos devuelve la lista de <code>n+1</code> números que
constituyen la fila <code>n</code> del triángulo de Pascal:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="err">fila 0 = {1}</span>
<span class="err">fila 1 = {1 1}</span>
<span class="err">fila 2 = {1 2 1}</span>
<span class="err">fila 3 = {1 3 3 1}</span>
<span class="err">fila 4 = {1 4 6 4 1}</span>
<span class="err">...</span>
</pre></div>
</td></tr></table>

<p>Esta función necesitará un parámetro adicional (<code>lista-fila</code>) que se
inicializa con la lista <code>{1}</code> y en el que se va guardando cada fila
sucesiva. Esta fila va creciendo hasta que llegamos a la fila que
tenemos que devolver. Hay que hacer la iteración <code>n</code> veces, por lo que
vamos decrementando el parámetro <code>n</code> hasta que se llega a 0.</p>
<p>Para implementar esta función usamos otra llamada <code>(pascal-sig-fila
lista-fila)</code> que recibe una fila del triángulo y devuelve la
siguiente. </p>
<p>Por ejemplo:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="nf">pascal-sig-fila</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">3</span> <span class="mi">3</span> <span class="mi">1</span><span class="p">))</span>
<span class="c1">; ⇒ {1 4 6 4 1}</span>
</pre></div>
</td></tr></table>

<p>Esta función la implementamos con una función recursiva auxiliar (esta
es recursiva pura) llamada <code>(pascal-suma-dos-a-dos lista-fila)</code> que es
la que se encarga de realizar el cálculo de la nueva fila.</p>
<p>El código completo es el siguiente:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">pascal</span> <span class="nv">fila</span> <span class="nv">col</span><span class="p">)</span>
   <span class="p">(</span><span class="nb">list-ref </span><span class="p">(</span><span class="nf">pascal-fila</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="nv">fila</span><span class="p">)</span> <span class="nv">col</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">pascal-fila</span> <span class="nv">lista-fila</span> <span class="nv">n</span><span class="p">)</span>
   <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="mi">0</span> <span class="nv">n</span><span class="p">)</span>
      <span class="nv">lista-fila</span>
      <span class="p">(</span><span class="nf">pascal-fila</span> <span class="p">(</span><span class="nf">pascal-sig-fila</span> <span class="nv">lista-fila</span><span class="p">)</span> <span class="p">(</span><span class="nb">- </span><span class="nv">n</span> <span class="mi">1</span><span class="p">))))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">pascal-sig-fila</span> <span class="nv">lista-fila</span><span class="p">)</span>
   <span class="p">(</span><span class="nb">append </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
           <span class="p">(</span><span class="nf">pascal-suma-dos-a-dos</span> <span class="nv">lista-fila</span><span class="p">)</span>
           <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span><span class="p">)))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">pascal-suma-dos-a-dos</span> <span class="nv">lista-fila</span><span class="p">)</span>
   <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">null? </span><span class="p">(</span><span class="nb">cdr </span><span class="nv">lista-fila</span><span class="p">))</span>
      <span class="o">&#39;</span><span class="p">()</span>
      <span class="p">(</span><span class="nb">cons </span><span class="p">(</span><span class="nb">+ </span><span class="p">(</span><span class="nb">car </span><span class="nv">lista-fila</span><span class="p">)</span> <span class="p">(</span><span class="nb">car </span><span class="p">(</span><span class="nb">cdr </span><span class="nv">lista-fila</span><span class="p">)))</span>
            <span class="p">(</span><span class="nf">pascal-suma-dos-a-dos</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">lista-fila</span><span class="p">)))))</span>
</pre></div>
</td></tr></table>

<p>Con esta implementación ya no se tiene un coste exponencial y se puede
calcular el valor de números como Pascal(40, 20):</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="nf">pascal</span> <span class="mi">40</span> <span class="mi">20</span><span class="p">)</span>
<span class="c1">; ⇒ 137846528820</span>
</pre></div>
</td></tr></table>

<h2 id="soluciones-al-coste-de-la-recursion-memoization">Soluciones al coste de la recursión: memoization<a class="headerlink" href="#soluciones-al-coste-de-la-recursion-memoization" title="Permanent link">&para;</a></h2>
<p>Una alternativa que mantiene la elegancia de los procesos recursivos y
la eficiencia de los iterativos es la
<a href="http://en.wikipedia.org/wiki/Memoization">memoization</a>. Si miramos la
traza de <code>(fibonacci 4)</code> podemos ver que el coste está producido por
la repetición de llamadas; por ejemplo <code>(fibonacci 3)</code> se evalúa 2
veces.</p>
<p>En programación funcional la llamada a <code>(fibonacci 3)</code> siempre va a
devolver el mismo valor.</p>
<p>La idea de la <em>memoization</em> es guardar el valor devuelto por la
cada llamada en alguna estructura (una lista de asociación, por
ejemplo) y no volver a realizar la llamada a la recursión las
siguientes veces.</p>
<h3 id="fibonacci-con-memoization">Fibonacci con memoization<a class="headerlink" href="#fibonacci-con-memoization" title="Permanent link">&para;</a></h3>
<p>Para implementar la <em>memoization</em> necesitamos dos métodos imperativos 
<code>put</code> y <code>get</code> que implementan un diccionario <em>clave-valor</em>.</p>
<ul>
<li>La función <code>(put key value lista)</code> asocia un valor a una clave, la
guarda en la lista (con mutación) y devuelve el valor.</li>
<li>La función <code>(get key lista)</code> devuelve el valor de la lista asociado a
una clave. En el caso en que no exista ningún valor se devuelve la
lista vacía.</li>
</ul>
<p>Inicialmente la lista debe tener un símbolo cualquiera al comienzo. </p>
<p>Ejemplos:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="err">(define mi-lista (list &#39;lista-asoc))</span>
<span class="err">(put 1 10 mi-lista) ; ⇒ 10</span>
<span class="err">(get 1 mi-lista) ; ⇒ 10</span>
<span class="err">(get 2 mi-lista) ; ⇒ &#39;()</span>
</pre></div>
</td></tr></table>

<p>Estos métodos son imperativos porque modifican (mutan) los datos de la
lista de asociación que pasamos como parámetro. Para implementarlos
tenemos que salirnos del paradigma funcional, importando una librería
de Scheme que permite mutar las parejas.</p>
<p>No es importante la implementación, la dejamos aquí como referencia y
para poder probar la <em>memoization</em>. </p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="nf">import</span> <span class="p">(</span><span class="nf">rnrs</span><span class="p">)</span>
        <span class="p">(</span><span class="nf">rnrs</span> <span class="nv">mutable-pairs</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="nv">lista</span> <span class="p">(</span><span class="nb">list </span><span class="ss">&#39;lista-asoc</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">buscar</span> <span class="nv">key</span> <span class="nv">lista</span><span class="p">)</span>
   <span class="p">(</span><span class="k">cond </span><span class="p">((</span><span class="nb">null? </span><span class="nv">lista</span><span class="p">)</span> <span class="no">#f</span><span class="p">)</span>
         <span class="p">((</span><span class="nb">equal? </span><span class="p">(</span><span class="nb">caar </span><span class="nv">lista</span><span class="p">)</span> <span class="nv">key</span><span class="p">)</span> <span class="p">(</span><span class="nb">car </span><span class="nv">lista</span><span class="p">))</span>
         <span class="p">(</span><span class="k">else </span><span class="p">(</span><span class="nf">buscar</span> <span class="nv">key</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">lista</span><span class="p">)))))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">get</span> <span class="nv">key</span> <span class="nv">lista</span><span class="p">)</span>
   <span class="p">(</span><span class="k">define </span><span class="nv">record</span> <span class="p">(</span><span class="nf">buscar</span> <span class="nv">key</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">lista</span><span class="p">)))</span>
   <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">not </span><span class="nv">record</span><span class="p">)</span>
      <span class="o">&#39;</span><span class="p">()</span>
      <span class="p">(</span><span class="nb">cdr </span><span class="nv">record</span><span class="p">)))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">put</span> <span class="nv">key</span> <span class="nv">value</span> <span class="nv">lista</span><span class="p">)</span>
   <span class="p">(</span><span class="k">define </span><span class="nv">record</span> <span class="p">(</span><span class="nf">buscar</span> <span class="nv">key</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">lista</span><span class="p">)))</span>
   <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">not </span><span class="nv">record</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">set-cdr! </span><span class="nv">lista</span>
         <span class="p">(</span><span class="nb">cons </span><span class="p">(</span><span class="nb">cons </span><span class="nv">key</span> <span class="nv">value</span><span class="p">)</span>
               <span class="p">(</span><span class="nb">cdr </span><span class="nv">lista</span><span class="p">)))</span>
      <span class="p">(</span><span class="nb">set-cdr! </span><span class="nv">record</span> <span class="nv">value</span><span class="p">))</span>
   <span class="nv">value</span><span class="p">)</span>
</pre></div>
</td></tr></table>

<p>La función <code>fib-memo</code> realiza el cálculo de la serie de Fibonacci
utilizando exactamente la misma definición recursiva original, pero
añadiendo la técnica de <em>memoization</em>: lo primero que hacemos para
calcular el número de fibonacci <code>n</code>, antes de llamar a la recursión,
es comprobar si está ya guardado en la lista de asociación. En el caso
en que esté, lo devolvemos. Sólo cuando el número no está calculado
llamamos a la recursión para calcularlo.</p>
<p>La implementación se muestra a continuación. Vemos que para devolver
el número de fibonacci <code>n</code> se comprueba si ya está guardado en la
lista. Sólo en el caso en que no esté guardado se llama a la recursión
para calcularlo y guardarlo. La función <code>put</code> que guarda el nuevo
valor calculado también lo devuelve.</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">fib-memo</span> <span class="nv">n</span> <span class="nv">lista</span><span class="p">)</span>
  <span class="p">(</span><span class="k">cond </span><span class="p">((</span><span class="nb">= </span><span class="nv">n</span> <span class="mi">0</span><span class="p">)</span> <span class="mi">0</span><span class="p">)</span>
        <span class="p">((</span><span class="nb">= </span><span class="nv">n</span> <span class="mi">1</span><span class="p">)</span> <span class="mi">1</span><span class="p">)</span>
        <span class="p">((</span><span class="nb">not </span><span class="p">(</span><span class="nb">null? </span><span class="p">(</span><span class="nf">get</span> <span class="nv">n</span> <span class="nv">lista</span><span class="p">)))</span>
         <span class="p">(</span><span class="nf">get</span> <span class="nv">n</span> <span class="nv">lista</span><span class="p">))</span>
        <span class="p">(</span><span class="k">else </span><span class="p">(</span><span class="nf">put</span> <span class="nv">n</span> <span class="p">(</span><span class="nb">+ </span><span class="p">(</span><span class="nf">fib-memo</span> <span class="p">(</span><span class="nb">- </span><span class="nv">n</span> <span class="mi">1</span><span class="p">)</span> <span class="nv">lista</span><span class="p">)</span>
                        <span class="p">(</span><span class="nf">fib-memo</span> <span class="p">(</span><span class="nb">- </span><span class="nv">n</span> <span class="mi">2</span><span class="p">)</span> <span class="nv">lista</span><span class="p">))</span> <span class="nv">lista</span><span class="p">))))</span>
</pre></div>
</td></tr></table>

<p>Podemos comprobar la diferencia de tiempos de ejecución entre esta
versión y la anterior. El coste de la función <em>memoizada</em> es
O(n). Frente al coste O(2^n) de la versión inicial que la hacía
imposible de utilizar.</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="nf">fib-memo</span> <span class="mi">200</span> <span class="nv">lista</span><span class="p">)</span>
<span class="err">⇒</span> <span class="mi">280571172992510140037611932413038677189525</span>
</pre></div>
</td></tr></table>

<h2 id="recursion-y-graficos-de-tortuga">Recursión y gráficos de tortuga<a class="headerlink" href="#recursion-y-graficos-de-tortuga" title="Permanent link">&para;</a></h2>
<p>Vamos a terminar el apartado sobre procedimientos recursivos con un
último ejemplo algo distinto de los vistos hasta ahora. Usaremos la
recursión para dibujar figuras fractales usando los denominados
<em>gráficos de tortuga</em>. Para dibujar las figuras tendremos que utilizar
un estilo de programación no funcional, dibujando los distintos trazos
de las figuras con pasos de ejecución secuenciales. Para ello usaremos
una primitiva imperativa de Scheme: la forma especial <code>begin</code> que
permite realizar un grupo de pasos de ejecución de forma secuencial.</p>
<p>Ten cuidado con la forma especial <code>begin</code>, es una forma especial
imperativa. No debes usarla en la implementación de ninguna función
cuando estemos usando el paradigma funcional.</p>
<h3 id="graficos-de-tortuga-en-racket">Gráficos de tortuga en Racket<a class="headerlink" href="#graficos-de-tortuga-en-racket" title="Permanent link">&para;</a></h3>
<p>Se pueden utilizar los
<a href="http://en.wikipedia.org/wiki/Turtle_graphics">gráficos de tortuga</a> en
Racket cargando la librería <code>(graphics turtles)</code>:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="c1">#lang r6rs</span>
<span class="p">(</span><span class="kn">import</span> <span class="p">(</span><span class="n">rnrs</span><span class="p">)</span>
      <span class="p">(</span><span class="n">graphics</span> <span class="n">turtles</span><span class="p">))</span>
</pre></div>
</td></tr></table>

<p>Los comandos más importantes de esta librería son:</p>
<ul>
<li><code>(turtles #t)</code>: abre una ventana y coloca la tortuga en el centro,
  mirando hacia el eje X (derecha)</li>
<li><code>(clear)</code>: borra la ventana y coloca la tortuga en el centro</li>
<li><code>(draw d)</code>: avanza la tortuga dibujando <em>d</em> píxeles </li>
<li><code>(move d)</code>: mueve la tortuga <em>d</em> píxeles hacia adelante (sin dibujar)</li>
<li><code>(turn g)</code>: gira la tortuga <em>g</em> grados (positivos: en el sentido
  contrario a las agujas del reloj)</li>
</ul>
<p>Prueba a realizar algunas figuras con los comandos de tortuga, antes
de escribir el algoritmo en Scheme del triángulo de Sierpinski.</p>
<p>Por ejemplo, podemos definir una función que dibuja un triángulo
rectángulo con catetos de longitud <code>x</code>:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">hipot</span> <span class="nv">x</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">* </span><span class="nv">x</span> <span class="p">(</span><span class="nb">sqrt </span><span class="mi">2</span><span class="p">)))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">triangulo-rectangulo</span> <span class="nv">x</span><span class="p">)</span>
   <span class="p">(</span><span class="nf">begin</span>
      <span class="p">(</span><span class="nf">draw</span> <span class="nv">x</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">turn</span> <span class="mi">90</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">draw</span> <span class="nv">x</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">turn</span> <span class="mi">135</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">draw</span> <span class="p">(</span><span class="nf">hipot</span> <span class="nv">x</span><span class="p">))</span>
      <span class="p">(</span><span class="nf">turn</span> <span class="mi">135</span><span class="p">)))</span>

<span class="p">(</span><span class="nf">triangulo-rectangulo</span> <span class="mi">100</span><span class="p">)</span>
</pre></div>
</td></tr></table>

<p>La función <code>(hipot x)</code> devuelve la longitud de la hipotenusa de un
triángulo rectángulo con dos lados de longitud <code>x</code>. O sea, la
expresión:</p>
<p><img src="imagenes/hipot.png" width="250px"/></p>
<p>Como puedes comprobar, el código es imperativo. La forma especial
<code>begin</code> permite realizar una serie de pasos de ejecución que modifican
el estado (posición y orientación) de la <em>tortuga</em> y dibujan los
trazos de la figura.</p>
<p>El siguiente código es una variante del anterior que dibuja un
triángulo rectángulo de base <code>w</code> y lados <code>w/2</code>. Va a ser la figura
base del triángulo de Sierpinski.</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">triangle</span> <span class="nv">w</span><span class="p">)</span>
   <span class="p">(</span><span class="nf">begin</span>
      <span class="p">(</span><span class="nf">draw</span> <span class="nv">w</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">turn</span> <span class="mi">135</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">draw</span> <span class="p">(</span><span class="nf">hipot</span> <span class="p">(</span><span class="nb">/ </span><span class="nv">w</span> <span class="mi">2</span><span class="p">)))</span>
      <span class="p">(</span><span class="nf">turn</span> <span class="mi">90</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">draw</span> <span class="p">(</span><span class="nf">hipot</span> <span class="p">(</span><span class="nb">/ </span><span class="nv">w</span> <span class="mi">2</span><span class="p">)))</span>
      <span class="p">(</span><span class="nf">turn</span> <span class="mi">135</span><span class="p">)))</span>
</pre></div>
</td></tr></table>

<h3 id="triangulo-de-sierpinski">Triángulo de Sierpinski<a class="headerlink" href="#triangulo-de-sierpinski" title="Permanent link">&para;</a></h3>
<p><img src="imagenes/sierpinski.png" width="400px"/></p>
<p><em>Triángulo de Sierpinski</em></p>
<ul>
<li>¿Ves alguna recursión en la figura?</li>
<li>¿Cuál podría ser el parámetro de la función que la dibujara? </li>
<li>¿Se te ocurre un algoritmo recursivo que la dibuje?</li>
</ul>
<p>La figura es <em>autosimilar</em> (una característica de las figuras
fractales). Una parte de la figura es idéntica a la figura total, pero
reducida de escala. Esto nos da una pista de que es posible dibujar la
figura con un algoritmo recursivo.</p>
<p>Para intentar encontrar una forma de enfocar el problema, vamos a
pensarlo de la siguiente forma: supongamos que tenemos un triángulo de
Sierpinski de anchura <em>h</em> y altura <em>h/2</em> con su esquina inferior
izquierda en la posición 0,0. ¿Cómo podríamos construir <strong>el
siguiente</strong> triángulo de Sierpinski?.</p>
<p>Podríamos construir un triángulo de Sierpinski más grande dibujando 3
veces el mismo triángulo, pero en distintas posiciones:</p>
<ol>
<li>Triángulo 1 en la posición (0,0)</li>
<li>Triángulo 2 en la posición (h/2,h/2)</li>
<li>Triángulo 3 en la posición (h,0)</li>
</ol>
<p>El algoritmo recursivo se basa en la misma idea, pero <em>hacia
atrás</em>. Debemos intentar dibujar un triángulo de altura <em>h</em> situado en
la posición <em>x</em>, <em>y</em> basándonos en 3 llamadas recursivas a triángulos
más pequeños. En el caso base, cuando <em>h</em> sea menor que un umbral,
dibujaremos un triángulo de lado <em>h</em> y altura <em>h/2</em>:</p>
<p>O sea, que para dibujar un triángulo de Sierpinski de base <em>h</em> y
altura <em>h/2</em> debemos:</p>
<ul>
<li>Dibujar tres triángulos de Sierpinsky de la mitad del tamaño del
  original (<em>h/2</em>) situadas en las posiciones <em>(x,y)</em>, <em>(x+h/4,
  y+h/4)</em> y <em>(x+h/2,y)</em></li>
<li>En el caso base de la recursión, en el que <em>h</em> es menor que una
  constante, se dibuja un triángulo de base <em>h</em> y altura <em>h/2</em>.</li>
</ul>
<p>Una versión del algoritmo en <em>pseudocódigo</em>:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="err">Sierpinsky (x, y, h):</span>
<span class="err">   if (h &gt; MIN) {</span>
<span class="err">      Sierpinsky (x, y, h/2)</span>
<span class="err">      Sierpinsky (x+h/4, y+h/4, h/2)</span>
<span class="err">      Sierpinsky (x+h/2, y, h/2)</span>
<span class="err">   } else dibujaTriangulo (x, y, h)</span>
</pre></div>
</td></tr></table>

<h3 id="sierpinski-en-racket">Sierpinski en Racket<a class="headerlink" href="#sierpinski-en-racket" title="Permanent link">&para;</a></h3>
<p>La siguiente es una versión imperativa del algoritmo que dibuja el
triángulo de Sierpinski. No es funcional porque se realizan <em>pasos de
ejecución</em>, usando la forma especial <code>begin</code> o múltiples instrucciones
en una misma función (por ejemplo la función <code>triangle</code>).</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="o">#</span><span class="nv">lang</span> <span class="nv">r6rs</span>
<span class="p">(</span><span class="nf">import</span> <span class="p">(</span><span class="nf">rnrs</span><span class="p">)</span>
        <span class="p">(</span><span class="nf">graphics</span> <span class="nv">turtles</span><span class="p">))</span>

<span class="p">(</span><span class="nf">turtles</span> <span class="no">#t</span><span class="p">)</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">hipot</span> <span class="nv">x</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">* </span><span class="nv">x</span> <span class="p">(</span><span class="nb">sqrt </span><span class="mi">2</span><span class="p">)))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">triangle</span> <span class="nv">w</span><span class="p">)</span>
   <span class="p">(</span><span class="nf">begin</span>
      <span class="p">(</span><span class="nf">draw</span> <span class="nv">w</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">turn</span> <span class="mi">135</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">draw</span> <span class="p">(</span><span class="nf">hipot</span> <span class="p">(</span><span class="nb">/ </span><span class="nv">w</span> <span class="mi">2</span><span class="p">)))</span>
      <span class="p">(</span><span class="nf">turn</span> <span class="mi">90</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">draw</span> <span class="p">(</span><span class="nf">hipot</span> <span class="p">(</span><span class="nb">/ </span><span class="nv">w</span> <span class="mi">2</span><span class="p">)))</span>
      <span class="p">(</span><span class="nf">turn</span> <span class="mi">135</span><span class="p">)))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">sierpinski</span> <span class="nv">w</span><span class="p">)</span>
   <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&gt; </span><span class="nv">w</span> <span class="mi">20</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">begin</span>
         <span class="p">(</span><span class="nf">sierpinski</span> <span class="p">(</span><span class="nb">/ </span><span class="nv">w</span> <span class="mi">2</span><span class="p">))</span>
         <span class="p">(</span><span class="nf">move</span> <span class="p">(</span><span class="nb">/ </span><span class="nv">w</span> <span class="mi">4</span><span class="p">))</span> <span class="p">(</span><span class="nf">turn</span> <span class="mi">90</span><span class="p">)</span> <span class="p">(</span><span class="nf">move</span> <span class="p">(</span><span class="nb">/ </span><span class="nv">w</span> <span class="mi">4</span><span class="p">))</span> <span class="p">(</span><span class="nf">turn</span> <span class="mi">-90</span><span class="p">)</span>
         <span class="p">(</span><span class="nf">sierpinski</span> <span class="p">(</span><span class="nb">/ </span><span class="nv">w</span> <span class="mi">2</span><span class="p">))</span>
         <span class="p">(</span><span class="nf">turn</span> <span class="mi">-90</span><span class="p">)</span> <span class="p">(</span><span class="nf">move</span> <span class="p">(</span><span class="nb">/ </span><span class="nv">w</span> <span class="mi">4</span><span class="p">))</span> <span class="p">(</span><span class="nf">turn</span> <span class="mi">90</span><span class="p">)</span> <span class="p">(</span><span class="nf">move</span> <span class="p">(</span><span class="nb">/ </span><span class="nv">w</span> <span class="mi">4</span><span class="p">))</span>
         <span class="p">(</span><span class="nf">sierpinski</span> <span class="p">(</span><span class="nb">/ </span><span class="nv">w</span> <span class="mi">2</span><span class="p">))</span>
         <span class="p">(</span><span class="nf">turn</span> <span class="mi">180</span><span class="p">)</span> <span class="p">(</span><span class="nf">move</span> <span class="p">(</span><span class="nb">/ </span><span class="nv">w</span> <span class="mi">2</span><span class="p">))</span> <span class="p">(</span><span class="nf">turn</span> <span class="mi">-180</span><span class="p">))</span> <span class="c1">;; volvemos a la posición original</span>
      <span class="p">(</span><span class="nf">triangle</span> <span class="nv">w</span><span class="p">)))</span>
</pre></div>
</td></tr></table>

<p>La llamada a</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="nf">sierpinski</span> <span class="mi">40</span><span class="p">)</span>
</pre></div>
</td></tr></table>

<p>produce la siguiente figura:</p>
<p><img src="imagenes/sierpinski-40.png"/></p>
<p>La llamada a</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="nf">sierpinski</span> <span class="mi">700</span><span class="p">)</span>
</pre></div>
</td></tr></table>

<p>Produce la figura que vimos al principio del apartado:</p>
<p><img src="imagenes/sierpinski.png" width="400px"/></p>
<p>Para ocupar la venta completa debemos desplazar la tortuga hacia atrás
antes de invocar a <code>sierpinski</code>:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="nf">clear</span><span class="p">)</span>
<span class="p">(</span><span class="nf">move</span> <span class="mi">-350</span><span class="p">)</span>
<span class="p">(</span><span class="nf">sierpinski</span> <span class="mi">700</span><span class="p">)</span>
</pre></div>
</td></tr></table>

<h3 id="recursion-mutua">Recursión mutua<a class="headerlink" href="#recursion-mutua" title="Permanent link">&para;</a></h3>
<p>En la recursión mutua definimos una función en base a una segunda, que
a su vez se define en base a la primera.</p>
<p>También debe haber un caso base que termine la recursión</p>
<p>Por ejemplo:</p>
<ul>
<li>x es par si x-1 es impar</li>
<li>x es impar si x-1 es par</li>
<li>0 es par</li>
</ul>
<p>Programas en Scheme:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">par?</span> <span class="nv">x</span><span class="p">)</span>
   <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="mi">0</span> <span class="nv">x</span><span class="p">)</span>
      <span class="no">#t</span>
      <span class="p">(</span><span class="nf">impar?</span> <span class="p">(</span><span class="nb">- </span><span class="nv">x</span> <span class="mi">1</span><span class="p">))))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">impar?</span> <span class="nv">x</span><span class="p">)</span>
   <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="mi">0</span> <span class="nv">x</span><span class="p">)</span>
      <span class="no">#f</span>
      <span class="p">(</span><span class="nf">par?</span> <span class="p">(</span><span class="nb">- </span><span class="nv">x</span> <span class="mi">1</span><span class="p">))))</span>
</pre></div>
</td></tr></table>

<h3 id="ejemplo-avanzado-curvas-de-hilbert">Ejemplo avanzado: curvas de Hilbert<a class="headerlink" href="#ejemplo-avanzado-curvas-de-hilbert" title="Permanent link">&para;</a></h3>
<p>La curva de Hilbert es una curva fractal que tiene la propiedad de
rellenar completamente el espacio</p>
<p>Su dibujo tiene una formulación recursiva:</p>
<p><img src="imagenes/hilbert.png" width="600px"/></p>
<p>La curva H3 se puede construir a partir de la curva H2. El algoritmo
recursivo se formula dibujando la curva i-ésima a partir de la curva
i-1.</p>
<p>Para dibujar una curva de Hilbert de orden i a la <em>derecha</em> de la tortuga:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="err">1. Gira la tortuga -90</span>
<span class="err">2. Dibuja una curva de orden i-1 a la izquierda</span>
<span class="err">3. Avanza long dibujando</span>
<span class="err">4. Gira 90</span>
<span class="err">5. Dibuja una curva de orden i-1 a la derecha</span>
<span class="err">6. Avanza long dibujando</span>
<span class="err">7. Dibuja una curva de orden i-1 a la derecha</span>
<span class="err">8. Gira 90</span>
<span class="err">9. Avanza long dibujando</span>
<span class="err">10. Dibuja una curva de orden i-1 a la izquierda</span>
<span class="err">11. Gira -90</span>
</pre></div>
</td></tr></table>

<p>El algoritmo para dibujar a la izquierda es simétrico.</p>
<p>Como en la curva de Sierpinsky, utilizamos la librería
<code>graphics/turtles</code>, que permite usar la tortuga de Logo con los
comandos de Logo <code>draw</code> y <code>turn</code>. Definimos dos funciones simétricas,
la función <code>(h-der i long)</code> que dibuja una curva de Hilbert de orden
<code>i</code> con una longitud de trazo <code>long</code> a la <em>derecha</em> de la tortuga y la
función <code>(h-izq i w)</code> que dibuja una curva de Hilbert de orden <code>i</code> con
una longitud de trazo <code>long</code> a la <em>izquierda</em> de la tortuga.</p>
<p>El algoritmo en Scheme:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="o">#</span><span class="nv">lang</span> <span class="nv">r6rs</span>
<span class="p">(</span><span class="nf">import</span> <span class="p">(</span><span class="nf">rnrs</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">graphics</span> <span class="nv">turtles</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">h-der</span> <span class="nv">i</span> <span class="nv">long</span><span class="p">)</span>
   <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&gt; </span><span class="nv">i</span> <span class="mi">0</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">begin</span>
        <span class="p">(</span><span class="nf">turn</span> <span class="mi">-90</span><span class="p">)</span>
        <span class="p">(</span><span class="nf">h-izq</span> <span class="p">(</span><span class="nb">- </span><span class="nv">i</span> <span class="mi">1</span><span class="p">)</span> <span class="nv">long</span><span class="p">)</span>
        <span class="p">(</span><span class="nf">draw</span>  <span class="nv">long</span><span class="p">)</span>
        <span class="p">(</span><span class="nf">turn</span> <span class="mi">90</span><span class="p">)</span>
        <span class="p">(</span><span class="nf">h-der</span> <span class="p">(</span><span class="nb">- </span><span class="nv">i</span> <span class="mi">1</span><span class="p">)</span> <span class="nv">long</span><span class="p">)</span>
        <span class="p">(</span><span class="nf">draw</span> <span class="nv">long</span><span class="p">)</span>
        <span class="p">(</span><span class="nf">h-der</span> <span class="p">(</span><span class="nb">- </span><span class="nv">i</span> <span class="mi">1</span><span class="p">)</span> <span class="nv">long</span><span class="p">)</span>
        <span class="p">(</span><span class="nf">turn</span> <span class="mi">90</span><span class="p">)</span>
        <span class="p">(</span><span class="nf">draw</span> <span class="nv">long</span><span class="p">)</span>
        <span class="p">(</span><span class="nf">h-izq</span> <span class="p">(</span><span class="nb">- </span><span class="nv">i</span> <span class="mi">1</span><span class="p">)</span> <span class="nv">long</span><span class="p">)</span>
        <span class="p">(</span><span class="nf">turn</span> <span class="mi">-90</span><span class="p">))))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">h-izq</span> <span class="nv">i</span> <span class="nv">long</span><span class="p">)</span>
   <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&gt; </span><span class="nv">i</span> <span class="mi">0</span><span class="p">)</span>
     <span class="p">(</span><span class="nf">begin</span>
      <span class="p">(</span><span class="nf">turn</span> <span class="mi">90</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">h-der</span> <span class="p">(</span><span class="nb">- </span><span class="nv">i</span> <span class="mi">1</span><span class="p">)</span> <span class="nv">long</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">draw</span>  <span class="nv">long</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">turn</span> <span class="mi">-90</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">h-izq</span> <span class="p">(</span><span class="nb">- </span><span class="nv">i</span> <span class="mi">1</span><span class="p">)</span> <span class="nv">long</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">draw</span> <span class="nv">long</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">h-izq</span> <span class="p">(</span><span class="nb">- </span><span class="nv">i</span> <span class="mi">1</span><span class="p">)</span> <span class="nv">long</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">turn</span> <span class="mi">-90</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">draw</span> <span class="nv">long</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">h-der</span> <span class="p">(</span><span class="nb">- </span><span class="nv">i</span> <span class="mi">1</span><span class="p">)</span> <span class="nv">long</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">turn</span> <span class="mi">90</span><span class="p">))))</span>
</pre></div>
</td></tr></table>

<p>Podemos probarlo con distintos parámetros de grado de curva y longitud
de trazo.</p>
<p>Curva de Hilbert de nivel 3 con trazo de longitud 20:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="nf">clear</span><span class="p">)</span>
<span class="p">(</span><span class="nf">move</span> <span class="mi">-350</span><span class="p">)</span>
<span class="p">(</span><span class="nf">turn</span> <span class="mi">-90</span><span class="p">)</span>
<span class="p">(</span><span class="nf">move</span> <span class="mi">350</span><span class="p">)</span>
<span class="p">(</span><span class="nf">turn</span> <span class="mi">90</span><span class="p">)</span>
<span class="p">(</span><span class="nf">h-izq</span> <span class="mi">3</span> <span class="mi">20</span><span class="p">)</span>
</pre></div>
</td></tr></table>

<p>Curva de Hilbert de nivel 6 con trazo de longitud 10:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="nf">clear</span><span class="p">)</span>
<span class="p">(</span><span class="nf">move</span> <span class="mi">-350</span><span class="p">)</span>
<span class="p">(</span><span class="nf">turn</span> <span class="mi">-90</span><span class="p">)</span>
<span class="p">(</span><span class="nf">move</span> <span class="mi">350</span><span class="p">)</span>
<span class="p">(</span><span class="nf">turn</span> <span class="mi">90</span><span class="p">)</span>
<span class="p">(</span><span class="nf">h-izq</span> <span class="mi">6</span> <span class="mi">10</span><span class="p">)</span>
</pre></div>
</td></tr></table>

<p>Curva de Hilbert de nivel 7 con trazo de longitud 5:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="nf">clear</span><span class="p">)</span>
<span class="p">(</span><span class="nf">move</span> <span class="mi">-350</span><span class="p">)</span>
<span class="p">(</span><span class="nf">turn</span> <span class="mi">-90</span><span class="p">)</span>
<span class="p">(</span><span class="nf">move</span> <span class="mi">350</span><span class="p">)</span>
<span class="p">(</span><span class="nf">turn</span> <span class="mi">90</span><span class="p">)</span>
<span class="p">(</span><span class="nf">h-izq</span> <span class="mi">7</span> <span class="mi">5</span><span class="p">)</span>
</pre></div>
</td></tr></table>

<p><img src="imagenes/hilbert-scheme.png"/></p>
<h2 id="bibliografia-sicp">Bibliografía - SICP<a class="headerlink" href="#bibliografia-sicp" title="Permanent link">&para;</a></h2>
<p>En este tema explicamos conceptos de los siguientes capítulos del libro <em>Structure and Intepretation of Computer Programs</em>:</p>
<ul>
<li><a href="https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book-Z-H-11.html#%_sec_1.2">1.2 - Procedures and the Processes They Generate</a></li>
<li><a href="https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book-Z-H-11.html#%_sec_1.2.1">1.2.1 - Linear Recursion and Iteration</a></li>
<li><a href="https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book-Z-H-11.html#%_sec_1.2.2">1.2.2 - Tree Recursion</a></li>
</ul>
<hr />
<p>Lenguajes y Paradigmas de Programación, curso 2018-19<br />
© Departamento Ciencia de la Computación e Inteligencia Artificial, Universidad de Alicante<br />
Domingo Gallardo, Cristina Pomares, Antonio Botía, Francisco Martínez</p>
                
                  
                
                
              
              
                


              
            </article>
          </div>
        </div>
      </main>
      
        
<footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-footer-copyright">
        
        powered by
        <a href="https://www.mkdocs.org">MkDocs</a>
        and
        <a href="https://squidfunk.github.io/mkdocs-material/">
          Material for MkDocs</a>
      </div>
      
    </div>
  </div>
</footer>
      
    </div>
    
      <script src="../../assets/javascripts/application.808e90bb.js"></script>
      
      <script>app.initialize({version:"1.0.4",url:{base:"../.."}})</script>
      
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML"></script>
      
    
  </body>
</html>