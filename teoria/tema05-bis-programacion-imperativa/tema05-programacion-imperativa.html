



<!doctype html>
<html lang="es" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      <meta http-equiv="x-ua-compatible" content="ie=edge">
      
      
      
      
        <meta name="lang:clipboard.copy" content="Copiar al portapapeles">
      
        <meta name="lang:clipboard.copied" content="Copiado al portapapeles">
      
        <meta name="lang:search.language" content="en">
      
        <meta name="lang:search.pipeline.stopwords" content="True">
      
        <meta name="lang:search.pipeline.trimmer" content="True">
      
        <meta name="lang:search.result.none" content="No se encontraron documentos">
      
        <meta name="lang:search.result.one" content="1 documento encontrado">
      
        <meta name="lang:search.result.other" content="# documentos encontrados">
      
        <meta name="lang:search.tokenizer" content="[\s\-]+">
      
      <link rel="shortcut icon" href="../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.0.4, mkdocs-material-4.6.0">
    
    
      
        <title>Tema 5: Programación imperativa - LPP</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/application.1b62728e.css">
      
        <link rel="stylesheet" href="../../assets/stylesheets/application-palette.a8b3c06d.css">
      
      
        
        
        <meta name="theme-color" content="#009688">
      
    
    
      <script src="../../assets/javascripts/modernizr.268332fc.js"></script>
    
    
      
        <link href="https://fonts.gstatic.com" rel="preconnect" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Ubuntu:300,400,400i,700%7CRoboto+Mono&display=fallback">
        <style>body,input{font-family:"Ubuntu","Helvetica Neue",Helvetica,Arial,sans-serif}code,kbd,pre{font-family:"Roboto Mono","Courier New",Courier,monospace}</style>
      
    
    <link rel="stylesheet" href="../../assets/fonts/material-icons.css">
    
    
    
      
    
    
  </head>
  
    
    
    <body dir="ltr" data-md-color-primary="teal" data-md-color-accent="teal">
  
    <svg class="md-svg">
      <defs>
        
        
      </defs>
    </svg>
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" data-md-component="overlay" for="__drawer"></label>
    
      <a href="#tema-5-programacion-imperativa" tabindex="1" class="md-skip">
        Saltar a contenido
      </a>
    
    
      <header class="md-header" data-md-component="header">
  <nav class="md-header-nav md-grid">
    <div class="md-flex">
      <div class="md-flex__cell md-flex__cell--shrink">
        <a href="../.." title="LPP" class="md-header-nav__button md-logo">
          
            <img src="../../imagenes/logo.png" width="24" height="24">
          
        </a>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        <label class="md-icon md-icon--menu md-header-nav__button" for="__drawer"></label>
      </div>
      <div class="md-flex__cell md-flex__cell--stretch">
        <div class="md-flex__ellipsis md-header-nav__title" data-md-component="title">
          
            <span class="md-header-nav__topic">
              LPP
            </span>
            <span class="md-header-nav__topic">
              
                Tema 5: Programación imperativa
              
            </span>
          
        </div>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        
          <label class="md-icon md-icon--search md-header-nav__button" for="__search"></label>
          
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" placeholder="Búsqueda" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="query" data-md-state="active">
      <label class="md-icon md-search__icon" for="__search"></label>
      <button type="reset" class="md-icon md-search__icon" data-md-component="reset" tabindex="-1">
        &#xE5CD;
      </button>
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="result">
          <div class="md-search-result__meta">
            Teclee para comenzar búsqueda
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
        
      </div>
      
    </div>
  </nav>
</header>
    
    <div class="md-container">
      
        
      
      
      <main class="md-main" role="main">
        <div class="md-main__inner md-grid" data-md-component="container">
          
            
              <div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    <nav class="md-nav md-nav--primary" data-md-level="0">
  <label class="md-nav__title md-nav__title--site" for="__drawer">
    <a href="../.." title="LPP" class="md-nav__button md-logo">
      
        <img src="../../imagenes/logo.png" width="48" height="48">
      
    </a>
    LPP
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-1" type="checkbox" id="nav-1">
    
    <label class="md-nav__link" for="nav-1">
      Teoría
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-1">
        Teoría
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../tema00-descripcion-asignatura/tema00-descripcion-asignatura.html" title="Descripción de la asignatura" class="md-nav__link">
      Descripción de la asignatura
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../tema01-historia-lenguajes-programacion/tema01-historia-lenguajes-programacion.html" title="Tema 1: Historia de los lenguajes de programación" class="md-nav__link">
      Tema 1: Historia de los lenguajes de programación
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../tema02-programacion-funcional/tema02-programacion-funcional.html" title="Tema 2: Programación funcional" class="md-nav__link">
      Tema 2: Programación funcional
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-2" type="checkbox" id="nav-2">
    
    <label class="md-nav__link" for="nav-2">
      Seminarios
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-2">
        Seminarios
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../seminarios/seminario1-scheme/seminario1-scheme.html" title="Seminario de Scheme" class="md-nav__link">
      Seminario de Scheme
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              <div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    
<nav class="md-nav md-nav--secondary">
  
  
    
  
  
    <label class="md-nav__title" for="__toc">Tabla de contenidos</label>
    <ul class="md-nav__list" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#contenidos" class="md-nav__link">
    Contenidos
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#bibliografia" class="md-nav__link">
    Bibliografía
  </a>
  
</li>
      
      
      
      
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content">
            <article class="md-content__inner md-typeset">
              
                
                
                <h1 id="tema-5-programacion-imperativa">Tema 5: Programación imperativa<a class="headerlink" href="#tema-5-programacion-imperativa" title="Permanent link">&para;</a></h1>
<h2 id="contenidos">Contenidos<a class="headerlink" href="#contenidos" title="Permanent link">&para;</a></h2>
<ul>
<li><a href="#1">1. Historia y características de la programación imperativa</a><ul>
<li><a href="#1-1">1.1. Historia de la programación imperativa</a></li>
<li><a href="#1-2">1.2. Características principales de la programación imperativa</a></li>
</ul>
</li>
<li><a href="#2">2. Programación imperativa en Scheme</a><ul>
<li><a href="#2-1">2.1. Pasos de ejecución</a></li>
<li><a href="#2-2">2.2. Mutación con formas especiales <em>set!</em></a></li>
<li><a href="#2-3">2.3. Igualdad de referencia y de valor</a></li>
</ul>
</li>
<li><a href="#3">3. Estructuras de datos mutables</a><ul>
<li><a href="#3-1">3.1. Mutación de elementos</a></li>
<li><a href="#3-2">3.2. Funciones mutadoras: <code>make-ciclo!</code>, <code>append!</code> y <code>intercambia!</code></a></li>
<li><a href="#3-3">3.3. Lista ordenada mutable</a></li>
<li><a href="#3-4">3.4. Diccionario mutable</a></li>
<li><a href="#3-5">3.5. Ejemplo de mutación con listas de asociación</a></li>
</ul>
</li>
<li><a href="#4">4. Ámbitos de variables y clausuras</a><ul>
<li><a href="#4-1">4.1. Variables de ámbito global</a></li>
<li><a href="#4-2">4.2. Variables de ámbito local</a></li>
<li><a href="#4-3">4.3. Clausuras y estado local</a></li>
</ul>
</li>
<li><a href="#5">5. Clausuras con mutación = estado local mutable</a><ul>
<li><a href="#5-1">5.1. Estado local mutable</a></li>
<li><a href="#4-2">5.2. Paso de mensajes</a></li>
</ul>
</li>
</ul>
<h2 id="bibliografia">Bibliografía<a class="headerlink" href="#bibliografia" title="Permanent link">&para;</a></h2>
<p>En este tema explicamos conceptos de los siguientes capítulos del libro <em>Structure and Intepretation of Computer Programs</em>:</p>
<ul>
<li><a href="https://mitpress.mit.edu/sicp/full-text/book/book-Z-H-22.html#%_sec_3.3.1">3.3.1 Mutable List Structure</a></li>
<li><a href="https://mitpress.mit.edu/sicp/full-text/book/book-Z-H-22.html#%_sec_3.3.2">3.3.2 Representing Queues</a></li>
<li><a href="https://mitpress.mit.edu/sicp/full-text/book/book-Z-H-22.html#%_sec_3.3.3">3.3.3 Representing tables</a></li>
<li><a href="https://mitpress.mit.edu/sicp/full-text/book/book-Z-H-20.html#%_sec_3.1.1">3.1.1 Local State Variables</a></li>
<li><a href="https://mitpress.mit.edu/sicp/full-text/book/book-Z-H-20.html#%_sec_3.1.3">3.1.3 The Cost of Introducing Assignment</a></li>
</ul>
<h2 id="1-historia-y-caracteristicas-de-la-programacion-imperativa"><a name="1"></a> 1. Historia y características de la programación imperativa<a class="headerlink" href="#1-historia-y-caracteristicas-de-la-programacion-imperativa" title="Permanent link">&para;</a></h2>
<h3 id="11-historia-de-la-programacion-imperativa"><a name="1-1"></a>1.1. Historia de la programación imperativa<a class="headerlink" href="#11-historia-de-la-programacion-imperativa" title="Permanent link">&para;</a></h3>
<h4>1.1.1. Orígenes de la programación imperativa</h4>
<ul>
<li>La programación imperativa es la forma natural de programar un
  computador, es el estilo de programación que se utiliza en el
  ensamblador, el estilo más cercano a la arquitectura del computador</li>
<li>Características de la arquitectura
  <a href="http://en.wikipedia.org/wiki/Von_Neumann_architecture">arquitectura clásica de Von Newmann</a>:<ul>
<li>memoria donde se almacenan los datos (referenciables por su
  dirección de memoria) y el programa</li>
<li>unidad de control que ejecuta las instrucciones del programa
  (contador del programa)</li>
<li>Los primeros lenguajes de programación (como el Fortran) son
  abstracciones del ensamblador y de esta arquitectura. Lenguajes
  más modernos como el BASIC o el C han continuado con esta idea.</li>
</ul>
</li>
</ul>
<h4>1.1.2. Programación procedural</h4>
<ul>
<li>Uso de procedimientos y subrutinas</li>
<li>Los cambios de estado se localizan en estos procedimientos</li>
<li>Los procedimientos especifican parámetros y valores devueltos (un
  primer paso hacia la abstracción y los modelos funcionales y
  declarativos)</li>
<li>Primer lenguaje con estas ideas: ALGOL</li>
</ul>
<h4>1.1.3. Programación estructurada</h4>
<ul>
<li>Artículo a finales de los 60 de Edsger W. Dijkstra:
  <a href="http://www.cs.utexas.edu/users/EWD/ewd02xx/EWD215.PDF">GOTO statement considered harmful</a>
  en el que se arremete contra la sentencia GOTO de muchos lenguajes
  de programación de la época</li>
<li>La programación estructurada mantiene la programación imperativa,
  pero haciendo énfasis en la necesidad de que los programas sean
  correctos (debe ser posible de comprobar formalmente los programas),
  modulares y mantenibles.</li>
<li>Lenguajes: Pascal, ALGOL 68, Ada</li>
</ul>
<h4>1.1.4. Programación Orientada a Objetos</h4>
<ul>
<li>La POO también utiliza la programación imperativa, aunque extiende
  los conceptos de modularidad, mantenibilidad y estado local</li>
<li>Se populariza a finales de los 70 y principios de los 80</li>
</ul>
<h3 id="12-caracteristicas-principales-de-la-programacion-imperativa"><a name="1-2"></a> 1.2. Características principales de la programación imperativa<a class="headerlink" href="#12-caracteristicas-principales-de-la-programacion-imperativa" title="Permanent link">&para;</a></h3>
<ul>
<li>Idea principal de la programación imperativa: la computación se
  realiza cambiando el estado del programa por medio de sentencias que
  definen pasos de ejecución del computador</li>
<li>Estado del programa modificable</li>
<li>Sentencias de control que definen pasos de ejecución</li>
</ul>
<p>Vamos a ver unos ejemplos de estas características usando el lenguaje
de programación Java.</p>
<h4>1.2.1. Modificación de datos</h4>
<ul>
<li>Uno de los elementos de la arquitectura de Von Newmann es la
  existencia de celdas de memoria referenciables y modificables</li>
</ul>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</pre></div>
</td></tr></table>

<ul>
<li>Otro ejemplo típico de este concepto en los lenguajes de
  programación es el array: una estructura de datos que se almacena
  directamente en memoria y que puede ser accedido y modificado.</li>
<li>En Java los arrays son tipeados, mutables y de tamaño fijo</li>
</ul>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">String</span><span class="o">[]</span> <span class="n">unoDosTres</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;uno&quot;</span><span class="p">,</span><span class="s">&quot;dos&quot;</span><span class="p">,</span><span class="s">&quot;tres&quot;</span><span class="p">};</span>
<span class="n">unoDosTres</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">unoDosTres</span><span class="o">[</span><span class="mi">2</span><span class="o">]</span><span class="p">;</span>
</pre></div>
</td></tr></table>

<ul>
<li>Un ejemplo de un método que recibe un parámetro de tipo array en
  Java. El parámetro se pasa por referencia:</li>
</ul>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">public</span> <span class="kt">void</span> <span class="nf">llenaCadenas</span><span class="p">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">cadenas</span><span class="p">,</span> <span class="n">String</span> <span class="n">cadena</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">cadenas</span><span class="p">.</span><span class="na">length</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">cadenas</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">cadena</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<ul>
<li>Todos los ejemplos anteriores en un programa <code>main</code> Java:</li>
</ul>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="p">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;x: &quot;</span> <span class="o">+</span> <span class="n">x</span><span class="p">);</span>
        <span class="n">String</span><span class="o">[]</span> <span class="n">unoDosTres</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;uno&quot;</span><span class="p">,</span><span class="s">&quot;dos&quot;</span><span class="p">,</span><span class="s">&quot;tres&quot;</span><span class="p">};</span>
        <span class="n">unoDosTres</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">unoDosTres</span><span class="o">[</span><span class="mi">2</span><span class="o">]</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">String</span> <span class="n">valor</span> <span class="p">:</span> <span class="n">unoDosTres</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">valor</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">llenaCadenas</span><span class="p">(</span><span class="n">unoDosTres</span><span class="p">,</span> <span class="s">&quot;uno&quot;</span><span class="p">);</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">String</span> <span class="n">valor</span> <span class="p">:</span> <span class="n">unoDosTres</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">valor</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">llenaCadenas</span><span class="p">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">cadenas</span><span class="p">,</span> <span class="n">String</span> <span class="n">cadena</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">cadenas</span><span class="p">.</span><span class="na">length</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">cadenas</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">cadena</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<h4>1.2.2. Almacenamiento de datos en variables</h4>
<ul>
<li>Todos los lenguajes de programación definen variables que contienen
  datos</li>
<li>Las variables pueden mantener valores (tipos de valor o value types)
  o referencias (tipos de referencia o reference types)</li>
<li>En C, C++ o Java, los datos primitivos como int o char son de tipo
  valor y los objetos y datos compuestos son de tipo referencia</li>
<li>La asignación de un valor a una variable tiene implicaciones
  distintas si el tipo es de valor (se copia el valor) o de referencia
  (se copia la referencia)</li>
</ul>
<p>Copia de valor (datos primitivos en Java):</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
<span class="n">x</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
<span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">y</span><span class="p">);</span> <span class="c1">// Sigue siendo 10</span>
</pre></div>
</td></tr></table>

<p>Copia de referencia (objetos en Java):</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="c1">// import java.awt.geom.Point2D;</span>
<span class="n">Point2D</span> <span class="n">p1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Point2D</span><span class="p">.</span><span class="na">Double</span><span class="p">(</span><span class="mf">2.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">);</span>
<span class="n">Point2D</span> <span class="n">p2</span> <span class="o">=</span> <span class="n">p1</span><span class="p">;</span>
<span class="n">p1</span><span class="p">.</span><span class="na">setLocation</span><span class="p">(</span><span class="mf">12.0</span><span class="p">,</span> <span class="mf">13.0</span><span class="p">);</span>
<span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;p2.x = &quot;</span> <span class="o">+</span> <span class="n">p2</span><span class="p">.</span><span class="na">getX</span><span class="p">());</span> <span class="c1">// 12.0</span>
<span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;p2.y = &quot;</span> <span class="o">+</span> <span class="n">p2</span><span class="p">.</span><span class="na">getY</span><span class="p">());</span> <span class="c1">// 13.0</span>
</pre></div>
</td></tr></table>

<ul>
<li>El uso de las referencias para los objetos de clases y para los
  tipos compuestos está generalizado en la mayoría de lenguajes de
  programación</li>
<li>Tiene efectos laterales pero permite obtener estructuras de datos
  eficientes</li>
</ul>
<h4>1.2.3. Igualdad de valor y de referencia</h4>
<ul>
<li>Todos los lenguajes de programación imperativos que permite la
  distinción entre valores y referencias implementan dos tipos de
  igualdad entre variables</li>
<li>Igualdad de valor (el contenido de los datos de las variables es el
  mismo)</li>
<li>Igualdad de referencia (las variables tienen la misma referencia)</li>
<li>
<p>Igualdad de referencia =&gt; Igualdad de valor (pero al revés no)</p>
</li>
<li>
<p>En Java la igualdad de referencia se define con <code>==</code> y la de valor
  con el método <code>equals</code>:</p>
</li>
</ul>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">Point2D</span> <span class="n">p1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Point2D</span><span class="p">.</span><span class="na">Double</span><span class="p">(</span><span class="mf">2.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">);</span>
<span class="n">Point2D</span> <span class="n">p2</span> <span class="o">=</span> <span class="n">p1</span><span class="p">;</span>
<span class="n">Point2D</span> <span class="n">p3</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Point2D</span><span class="p">.</span><span class="na">Double</span><span class="p">(</span><span class="mf">2.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">);</span>
<span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">p1</span><span class="o">==</span><span class="n">p2</span><span class="p">);</span>           <span class="c1">// true</span>
<span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">p1</span><span class="o">==</span><span class="n">p3</span><span class="p">);</span>           <span class="c1">// false</span>
<span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">p1</span><span class="p">.</span><span class="na">equals</span><span class="p">(</span><span class="n">p3</span><span class="p">));</span>    <span class="c1">// true</span>
</pre></div>
</td></tr></table>

<h4>1.2.4. Sentencias de control</h4>
<ul>
<li>También tiene su origen en la arquitectura de Von Newmann</li>
<li>Sentencia que modifica el contador de programa y determina cuál será
  la siguiente instrucción a ejecutar</li>
<li>Tipos de sentencias de control en programación estructurada:<ul>
<li>Las sentencias de secuencia definen instrucciones que son ejecutados una detrás de otra de 
forma síncrona. Una instrucción no comienza hasta que la anterior ha terminado.</li>
<li>Las sentencias de selección definen una o más condiciones que determinan las instrucciones 
que se deberán ejecutar.</li>
<li>Las sentencias de iteración definen instrucciones que se ejecutan de forma repetitiva hasta 
que se cumple una determinada condición.</li>
</ul>
</li>
</ul>
<p><strong>Bucles y variables</strong></p>
<p>Ejemplo imperativo que imprime en Java una tabla con los productos de
los números del 1 al 9:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">9</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;Tabla del &quot;</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>
    <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;-----------&quot;</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="mi">9</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="s">&quot; * &quot;</span> <span class="o">+</span> <span class="n">j</span> <span class="o">+</span> <span class="s">&quot; = &quot;</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="n">j</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<h2 id="2-programacion-imperativa-en-scheme"><a name="2"></a> 2. Programación imperativa en Scheme<a class="headerlink" href="#2-programacion-imperativa-en-scheme" title="Permanent link">&para;</a></h2>
<ul>
<li>Al igual que LISP, Scheme tiene características imperativas</li>
<li>Vamos a ver algunas de ellas<ul>
<li>Pasos de ejecución</li>
<li>Asignación con la forma especial <code>set!</code></li>
<li>Datos mutables con las formas especiales <code>set-car!</code> y <code>set-cdr!</code></li>
</ul>
</li>
<li>Una nota importante: todos los ejemplos que hay a continuación
  necesitan importar la librería <code>mutable-pairs</code>:</li>
</ul>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="o">#</span><span class="nv">lang</span> <span class="nv">r6rs</span>
<span class="p">(</span><span class="nf">import</span> <span class="p">(</span><span class="nf">rnrs</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">rnrs</span> <span class="nv">mutable-pairs</span><span class="p">))</span>
</pre></div>
</td></tr></table>

<h3 id="21-pasos-de-ejecucion"><a name="2-1"></a> 2.1. Pasos de ejecución<a class="headerlink" href="#21-pasos-de-ejecucion" title="Permanent link">&para;</a></h3>
<ul>
<li>Es posible definir pasos de ejecución con la forma especial <code>begin</code></li>
<li>Todas las sentencias de la forma especial se ejecutan de forma
  secuencial, una tras otra</li>
<li>Tanto en la definición de funciones como en <code>lambda</code> es
  posible definir cuerpos de función con múltiples sentencias que se
  ejecutan también de forma secuencial. Hasta ahora no hemos usado
  esta característica porque hemos utilizado Scheme de forma
  funcional.</li>
</ul>
<p>Ejemplo <code>begin</code>:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="nf">begin</span>
    <span class="p">(</span><span class="nb">display </span><span class="s">&quot;Escribe un número: &quot;</span><span class="p">)</span>
    <span class="p">(</span><span class="k">define </span><span class="nv">x</span> <span class="p">(</span><span class="nf">read</span><span class="p">))</span>
    <span class="p">(</span><span class="nb">display </span><span class="s">&quot;Escribe otro: &quot;</span><span class="p">)</span>
    <span class="p">(</span><span class="k">define </span><span class="nv">y</span> <span class="p">(</span><span class="nf">read</span><span class="p">))</span>
    <span class="p">(</span><span class="k">define </span><span class="nv">maximo</span> <span class="p">(</span><span class="nb">max </span><span class="nv">x</span> <span class="nv">y</span><span class="p">))</span>
    <span class="p">(</span><span class="nb">display </span><span class="p">(</span><span class="nb">string-append </span><span class="s">&quot;El máximo de &quot;</span>
                        <span class="p">(</span><span class="nb">number-&gt;string </span><span class="nv">x</span><span class="p">)</span>
                        <span class="s">&quot; y &quot;</span>
                        <span class="p">(</span><span class="nb">number-&gt;string </span><span class="nv">y</span><span class="p">)</span>
                        <span class="s">&quot; es &quot;</span>
                       <span class="p">(</span><span class="nb">number-&gt;string </span><span class="nv">maximo</span><span class="p">))))</span>
</pre></div>
</td></tr></table>

<p>Ejemplo de pasos de ejecución en la definición de una función:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">display-tres-valores</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">display </span><span class="nv">a</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">newline</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">display </span><span class="nv">b</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">newline</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">display </span><span class="nv">c</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">newline</span><span class="p">))</span>
</pre></div>
</td></tr></table>

<h3 id="22-mutacion-con-formas-especiales-set"><a name="2-2"></a> 2.2. Mutación con formas especiales <em>set!</em><a class="headerlink" href="#22-mutacion-con-formas-especiales-set" title="Permanent link">&para;</a></h3>
<h4>2.2.1. Forma especial <code>set!</code></h4>
<ul>
<li>La forma especial <code>set!</code> permite asignar un nuevo valor a una
  variable</li>
<li>La variable debe haber sido previamente creada con <code>define</code></li>
<li>La forma especial no devuelve ningún valor, modifica el valor de la
  variable usada</li>
</ul>
<p>Sintaxis:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span>(set! &lt;variable&gt; &lt;nuevo-valor&gt;)
</pre></div>
</td></tr></table>

<p>Por ejemplo, la típica asignación de los lenguajes imperativos se
puede realizar de esta forma en Scheme:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="nv">a</span> <span class="mi">10</span><span class="p">)</span>
<span class="p">(</span><span class="k">set! </span><span class="nv">a</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">a</span> <span class="mi">1</span><span class="p">))</span>
<span class="nv">a</span>  <span class="c1">; ⇒ 11</span>
</pre></div>
</td></tr></table>

<p>La forma especial <code>set!</code> funciona con cualquier tipo de datos. Por
ejemplo, utilizando la característica de que Scheme es débilmente
tipeado, puede incluso asignar un nuevo tipo de valor a una variable:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="nv">a</span> <span class="s">&quot;Hola&quot;</span><span class="p">)</span>
<span class="nv">a</span> <span class="c1">; ⇒ &quot;Hola&quot;</span>
<span class="p">(</span><span class="k">set! </span><span class="nv">a</span> <span class="p">(</span><span class="nb">cons </span><span class="mi">1</span> <span class="mi">2</span><span class="p">))</span>
<span class="nv">a</span> <span class="c1">; ⇒ {1 . 2}</span>
</pre></div>
</td></tr></table>

<h4>2.2.2. Datos mutables</h4>
<ul>
<li>En Scheme se definen las formas especiales <code>set-car!</code> y <code>set-cdr!</code>
  que permite modificar (mutar) la parte izquierda o derecha de una
  pareja una vez creada</li>
<li>Al igual que <code>set!</code>, no devuelven ningún valor</li>
</ul>
<p>Sintaxis:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span>(set-car! &lt;pareja&gt; &lt;nuevo-valor&gt;)
(set-cdr! &lt;pareja&gt; &lt;nuevo-valor&gt;)
</pre></div>
</td></tr></table>

<p>Ejemplo</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="nv">p</span> <span class="p">(</span><span class="nb">cons </span><span class="mi">1</span> <span class="mi">2</span><span class="p">))</span>
<span class="p">(</span><span class="nb">set-car! </span><span class="nv">p</span> <span class="mi">10</span><span class="p">)</span>
<span class="p">(</span><span class="nb">set-cdr! </span><span class="nv">p</span> <span class="mi">20</span><span class="p">)</span>
<span class="nv">p</span>   <span class="c1">; ⇒ (10 . 20)</span>
</pre></div>
</td></tr></table>

<h4>2.2.3. Efectos laterales</h4>
<ul>
<li>La introducción de la asignación y los datos mutables hace posible
  que Scheme se comporte como un lenguaje imperativo en el que más de
  una variable apunta a un mismo valor y se producen efectos laterales</li>
<li>Un efecto lateral se produce cuando el valor de una variable cambia
  debido a una sentencia en la que no aparece la variable</li>
<li>Podemos comprobar ahora que las parejas son datos que se copian por
  referencia</li>
</ul>
<p>Ejemplo:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="nv">p1</span> <span class="p">(</span><span class="nb">cons </span><span class="mi">1</span> <span class="mi">2</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">p2</span> <span class="nv">p1</span><span class="p">)</span>
<span class="nv">p1</span> <span class="c1">; ⇒ (1 . 2)</span>
<span class="nv">p2</span> <span class="c1">; ⇒ (1 . 2)</span>
<span class="p">(</span><span class="nb">set-car! </span><span class="nv">p1</span> <span class="mi">20</span><span class="p">)</span>
<span class="nv">p1</span> <span class="c1">; ⇒ (20 . 2)</span>
<span class="nv">p2</span> <span class="c1">; ⇒ (20 . 2)</span>
</pre></div>
</td></tr></table>

<h3 id="23-igualdad-de-referencia-y-de-valor"><a name="2-3"></a> 2.3. Igualdad de referencia y de valor<a class="headerlink" href="#23-igualdad-de-referencia-y-de-valor" title="Permanent link">&para;</a></h3>
<ul>
<li>La utilización de referencias, la mutación y los efectos laterales
  hace también necesario definir dos tipos de igualdades: igualdad de
  referencia e igualdad de valor.</li>
<li>Igualdad de referencia: dos variables son iguales cuando apuntan al
  mismo valor</li>
<li>Igualdad de valor: dos variables son iguales cuando contienen el
  mismo valor</li>
<li>En Scheme la función <code>eq?</code> comprueba la igualdad de referencia y
  <code>equal?</code> la igualdad de valor</li>
<li>Igualdad de referencia implica igualdad de valor, pero no al revés</li>
</ul>
<p>Ejemplo:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="nv">p1</span> <span class="p">(</span><span class="nb">cons </span><span class="mi">10</span> <span class="mi">20</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">p2</span> <span class="nv">p1</span><span class="p">)</span>
<span class="p">(</span><span class="k">define </span><span class="nv">p3</span> <span class="p">(</span><span class="nb">cons </span><span class="mi">10</span> <span class="mi">20</span><span class="p">))</span>
<span class="p">(</span><span class="nb">equal? </span><span class="nv">p3</span> <span class="nv">p1</span><span class="p">)</span>  <span class="c1">; ⇒ #t</span>
<span class="p">(</span><span class="nb">eq? </span><span class="nv">p3</span> <span class="nv">p1</span><span class="p">)</span> <span class="c1">; ⇒ #f</span>
<span class="p">(</span><span class="nb">eq? </span><span class="nv">p2</span> <span class="nv">p1</span><span class="p">)</span> <span class="c1">; ⇒ #t</span>
<span class="p">(</span><span class="k">set! </span><span class="nv">p3</span> <span class="nv">p1</span><span class="p">)</span> <span class="c1">;; La asignación copia referencias</span>
<span class="p">(</span><span class="nb">eq? </span><span class="nv">p3</span> <span class="nv">p1</span><span class="p">)</span> <span class="c1">; ⇒ #t</span>
</pre></div>
</td></tr></table>

<h2 id="3-estructuras-de-datos-mutables"><a name="3"></a> 3. Estructuras de datos mutables<a class="headerlink" href="#3-estructuras-de-datos-mutables" title="Permanent link">&para;</a></h2>
<ul>
<li>La utilización de las formas especiales <code>set-car!</code> y <code>set-cdr!</code>
  permite un estilo nuevo de manejo de las estructuras de datos ya
  vistas (listas o árboles)</li>
<li>Es posible implementar funciones más eficientes que actualizan la
  estructura modificando directamente las referencias de unas celdas a
  otras</li>
<li>Las operaciones no construyen estructuras nuevas, sino que modifican
  la ya existente</li>
</ul>
<h3 id="31-mutacion-de-elementos"><a name="3-1"></a> 3.1. Mutación de elementos<a class="headerlink" href="#31-mutacion-de-elementos" title="Permanent link">&para;</a></h3>
<p><strong>Ejemplo 1</strong></p>
<p>Vamos a empezar con un ejemplo sencillo en el que vamos a mutar un
elemento de una estructura de datos formada por parejas. Supongamos la
siguiente estructura:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="nv">datos</span> <span class="p">(</span><span class="nb">cons </span><span class="mi">2</span>
                    <span class="p">(</span><span class="nb">cons </span><span class="p">(</span><span class="nb">cons </span><span class="mi">5</span>
                                <span class="p">(</span><span class="nb">cons </span><span class="mi">8</span> <span class="mi">9</span><span class="p">))</span>
                          <span class="p">(</span><span class="nb">cons </span><span class="mi">3</span> <span class="mi">4</span><span class="p">))))</span>
</pre></div>
</td></tr></table>

<p>El diagrama <em>box-and-pointer</em> es el siguiente. Fíjate que hay
elementos de las parejas que son datos atómicos y otros que son
referencias a otras parejas.</p>
<p><img src="imagenes/datos.png" width="250px"></p>
<p>Vamos ahora a <em>mutar</em> la estructura utilizando las sentencias
<code>set-car!</code> y <code>set-cdr!</code>. Para mutar una pareja acceder a la pareja y
modificar su parte derecha o su parte izquierda con las sentencias
anteriores.</p>
<p>Por ejemplo, ¿cómo cambiaríamos el <code>8</code> por un <code>18</code>? Deberíamos obtener
la pareja <code>(8 . 9)</code> que está al final de la estructura y modificar su
parte izquierda:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="nb">set-car! </span><span class="p">(</span><span class="nb">cdr </span><span class="p">(</span><span class="nb">car </span><span class="p">(</span><span class="nb">cdr </span><span class="nv">datos</span><span class="p">)))</span> <span class="mi">18</span><span class="p">)</span>
</pre></div>
</td></tr></table>

<p>La expresión <code>(cdr (car (cdr datos)))</code> devuelve la pareja que queremos
modificar y la sentencia <code>set-car!</code> modifica su parte izquierda.</p>
<p>Si ahora vemos qué hay en <code>datos</code> veremos que se ha modificado la
estructura:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="nf">print-pareja</span> <span class="nv">datos</span><span class="p">)</span>
<span class="c1">; ⇒ (2 . ((5 . (18 . 9)) . (3 . 4)))</span>
</pre></div>
</td></tr></table>

<p>Recuerda que <code>print-pareja</code> es una función que vimos anteriormente.</p>
<p>Hemos mutado un dato por otro. También podemos mutar las referencias a
las parejas. Por ejemplo, podríamos modificar la parte derecha de la
pareja que contiene el 5 para que apunte a la pareja <code>(3 . 4)</code>:</p>
<p><img src="imagenes/datos-mutados.png" width="250px"></p>
<p>Para ello habría que obtener la pareja que contiene el 5 con la
expresión <code>(car (cdr datos))</code> y mutar su parte derecha (<code>set-cdr!</code>)
con la referencia a la pareja <code>(3 . 4)</code> que se obtiene con la
expresión <code>(cdr (cdr datos))</code>:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="nb">set-cdr! </span><span class="p">(</span><span class="nb">car </span><span class="p">(</span><span class="nb">cdr </span><span class="nv">datos</span><span class="p">))</span> <span class="p">(</span><span class="nb">cdr </span><span class="p">(</span><span class="nb">cdr </span><span class="nv">datos</span><span class="p">)))</span>
</pre></div>
</td></tr></table>

<p><strong>Ejemplo 2</strong></p>
<p>Veamos un segundo ejemplo. </p>
<p>Supongamos las siguientes sentencias. ¿Cuál sería el <em>box-and-pointer</em>
resultante? </p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="nv">x</span> <span class="o">&#39;</span><span class="p">((</span><span class="nf">a</span> <span class="nv">b</span><span class="p">)</span> <span class="nv">c</span> <span class="nv">d</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">y</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">e</span> <span class="nv">f</span><span class="p">))</span>
<span class="p">(</span><span class="nb">set-car! </span><span class="nv">x</span> <span class="nv">y</span><span class="p">)</span>
<span class="p">(</span><span class="k">define </span><span class="nv">z</span> <span class="p">(</span><span class="nb">cons </span><span class="nv">y</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">x</span><span class="p">)))</span>
<span class="p">(</span><span class="nb">set-cdr! </span><span class="nv">x</span> <span class="nv">y</span><span class="p">)</span>
<span class="p">(</span><span class="nb">set-car! </span><span class="nv">z</span> <span class="p">(</span><span class="nb">caar </span><span class="nv">x</span><span class="p">))</span>
</pre></div>
</td></tr></table>

<p>Debemos ir paso a paso ejecutando cada instrucción y dibujando cómo
cambia el diagrama. El diagrama representa el <strong>estado del programa</strong>,
y es un conjunto de parejas que contienen valores y referencias entre
ellas. </p>
<p>Es muy importante considerar cuándo la sentencia copia un valor y cuando
copia una referencia. Las parejas siempre tienen semántica de
referencia.</p>
<p>El diagrama resultante después de las dos primeras sentencias es:</p>
<p><img src="imagenes/x-y-z-1.png" width="400px"/></p>
<p>Y el diagrama después de todas las sentencias es:</p>
<p><img src="imagenes/x-y-z-2.png" width="400px"/></p>
<p>Los valores de las variables después de todas las sentencias son los siguientes:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="nv">x</span> <span class="c1">; ⇒ {{e f} e f}</span>
<span class="nv">y</span> <span class="c1">; ⇒ {e f}</span>
<span class="nv">z</span> <span class="c1">; ⇒ {e c d}</span>
</pre></div>
</td></tr></table>

<p><strong>Ejemplo 3</strong></p>
<p>En este ejemplo vamos a usar una nueva forma especial de Scheme que
permite crear variables locales y ejecutar expresiones en las que se
utilicen esas variables. </p>
<p>Se trata de la forma especial <code>let</code>. Veremos algo más de esta forma
especial más adelante, cuando hablemos de ámbitos de variables. Por
ahora es suficiente saber que permite crear variables locales y
ejecutar un cuerpo (que puede tener más de una sentencia) con esas
variables.</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">x</span> <span class="p">(</span><span class="nb">+ </span><span class="mi">2</span> <span class="mi">3</span><span class="p">))</span>
      <span class="p">(</span><span class="nf">y</span> <span class="p">(</span><span class="nb">* </span><span class="mi">2</span> <span class="mi">10</span><span class="p">))</span>
    <span class="p">(</span><span class="nb">+ </span><span class="nv">x</span> <span class="nv">y</span><span class="p">))</span>
<span class="c1">; ⇒ 25</span>
</pre></div>
</td></tr></table>

<p>En este caso <code>let</code> permite crear dos variables locales <code>x</code> e <code>y</code> y
asignarles los valores <code>5</code> y <code>20</code> respectivamente. Las sentencias del
cuerpo del <code>let</code> (en este caso la sentencia <code>(+ x y)</code>) se evalúan con
estos valores recién creados.</p>
<p>Vamos a usar esta forma especial en ocasiones para guardar valores o
referencias que después necesitamos asignar.</p>
<p>Por ejemplo, ¿cómo podríamos definir una función que mute <strong>las
referencias</strong> de una lista para intercambiar sus posiciones segunda y
tercera (sin crear nuevas parejas)?</p>
<p>Si llamamos a la función <code>intercambia!</code> debería hacer lo siguiente:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="nv">lista</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span><span class="p">))</span>
<span class="p">(</span><span class="nf">intercambia!</span> <span class="nv">lista</span><span class="p">)</span>
<span class="nv">lista</span> <span class="c1">; ⇒ {1 3 2 4 5 6}</span>
</pre></div>
</td></tr></table>

<p>Dibujando el diagrama <em>box-and-pointer</em> podemos ver las mutaciones que
tenemos que hacer:</p>
<p><img src="imagenes/intercambia.png" width="600px"/></p>
<p>La función es la siguiente:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">intercambia!</span> <span class="nv">lista</span><span class="p">)</span>
    <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">segundo</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">lista</span><span class="p">))</span>
          <span class="p">(</span><span class="nf">tercero</span> <span class="p">(</span><span class="nb">cddr </span><span class="nv">lista</span><span class="p">)))</span>
        <span class="p">(</span><span class="nb">set-cdr! </span><span class="nv">lista</span> <span class="nv">tercero</span><span class="p">)</span>
        <span class="p">(</span><span class="nb">set-cdr! </span><span class="nv">segundo</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">tercero</span><span class="p">))</span>
        <span class="p">(</span><span class="nb">set-cdr! </span><span class="nv">tercero</span> <span class="nv">segundo</span><span class="p">)))</span>
</pre></div>
</td></tr></table>

<h3 id="32-funciones-mutadoras-make-ciclo-append-e-intercambia-lista"><a name="3-2"></a> 3.2. Funciones mutadoras: <code>make-ciclo!</code>, <code>append!</code> e <code>intercambia-lista!</code><a class="headerlink" href="#32-funciones-mutadoras-make-ciclo-append-e-intercambia-lista" title="Permanent link">&para;</a></h3>
<p>Veamos ahora varios ejemplos de funciones recursivas que recorren
listas y realizan mutaciones en ellas.</p>
<p>Normalmente las funciones mutadoras no devuelven una estructura, sino
que modifican la que se pasa como parámetro.</p>
<p>Por convenio, indicaremos que una función es mutadora terminando su
nombre con un signo de admiración.</p>
<p><strong>make-ciclo!</strong></p>
<p>Empecemos con una función muta una lista, haciendo que la parte
derecha de la última pareja apunte a la pareja inicial de la misma.</p>
<p><img src="imagenes/ciclo.png" width="600px"/></p>
<p>Para conseguirlo, necesitamos guardar la referencia a la pareja
inicial de la lista en el primer parámetro de la función. Y el segundo
parámetro irá avanzando hasta encontrar el final de la lista:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">make-ciclo!</span> <span class="nv">lista</span> <span class="nv">ref</span><span class="p">)</span>
    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">null? </span><span class="p">(</span><span class="nb">cdr </span><span class="nv">ref</span><span class="p">))</span>
        <span class="p">(</span><span class="nb">set-cdr! </span><span class="nv">ref</span> <span class="nv">lista</span><span class="p">)</span>
        <span class="p">(</span><span class="nf">make-ciclo!</span> <span class="nv">lista</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">ref</span><span class="p">))))</span>
</pre></div>
</td></tr></table>

<p>Si probamos la función con una lista, podemos comprobar que DrRacket
detecta el ciclo que se produce al final de la misma:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="nv">lista</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span><span class="p">))</span>
<span class="p">(</span><span class="nf">make-ciclo!</span> <span class="nv">lista</span> <span class="nv">lista</span><span class="p">)</span>
<span class="nv">lista</span> <span class="c1">; ⇒ #0={1 2 3 4 5 6 . #0#}</span>
</pre></div>
</td></tr></table>

<p>Una forma alternativa de implementar esta función es mediante una
función que devuelva la referencia de la última pareja de la lista:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">ultima-pareja</span> <span class="nv">lista</span><span class="p">)</span>
    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">null? </span><span class="p">(</span><span class="nb">cdr </span><span class="nv">lista</span><span class="p">))</span>
        <span class="nv">lista</span>
        <span class="p">(</span><span class="nf">ultima-pareja</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">lista</span><span class="p">))))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">make-ciclo2!</span> <span class="nv">lista</span><span class="p">)</span>
    <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">ultima-pareja</span> <span class="p">(</span><span class="nf">ultima-pareja</span> <span class="nv">lista</span><span class="p">)))</span>
        <span class="p">(</span><span class="nb">set-cdr! </span><span class="nv">ultima-pareja</span> <span class="nv">lista</span><span class="p">)))</span>
</pre></div>
</td></tr></table>

<p><strong>append!</strong></p>
<p>Y vemos a continuación una versión mutadora de <code>append</code> que llamamos
<code>append!</code> y que mejora la eficiencia de la original, copiando al final
de la primera lista una referencia a la segunda:</p>
<p><img src="imagenes/append.png" width="400px"></p>
<p>La implementación es la siguiente:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">append!</span> <span class="nv">l1</span> <span class="nv">l2</span><span class="p">)</span>
    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">null? </span><span class="p">(</span><span class="nb">cdr </span><span class="nv">l1</span><span class="p">))</span>
        <span class="p">(</span><span class="nb">set-cdr! </span><span class="nv">l1</span> <span class="nv">l2</span><span class="p">)</span>
        <span class="p">(</span><span class="nf">append!</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">l1</span><span class="p">)</span> <span class="nv">l2</span><span class="p">)))</span>
</pre></div>
</td></tr></table>

<p>Ejemplo:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="nv">a</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">b</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">5</span> <span class="mi">6</span> <span class="mi">7</span><span class="p">))</span>
<span class="p">(</span><span class="nf">append!</span> <span class="nv">a</span> <span class="nv">b</span><span class="p">)</span>
<span class="nv">a</span> <span class="c1">; ⇒ {1 2 3 4 5 6 7}</span>
</pre></div>
</td></tr></table>

<p>Algunas puntualizaciones:</p>
<ul>
<li>Al igual que <code>set!</code>, <code>set-car!</code> o <code>set-cdr!</code>, la función <code>append!</code>
  no devuelve ningún valor, sino que modifica directamente la lista
  que se pasa como primer parámetro.</li>
<li>Al modificarse la lista, todas las referencias que apuntan a ellas
  quedan también modificadas.</li>
<li>La función daría un error en el caso en que la llamáramos con una
  lista vacía como primer argumento.</li>
</ul>
<p><strong>intercambia-lista!</strong></p>
<p>Un último ejemplo de función recursiva que muta una lista. Queremos
definir una función que intercambie todas las parejas excepto la
primera de una lista con un número de datos impar, pero <strong>sin usar
set-car!</strong>.</p>
<p>Llamamos a la función <code>(intercambia-lista! lista)</code> y debería hacer lo
siguiente:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="nv">lista</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span> <span class="mi">7</span><span class="p">))</span>
<span class="p">(</span><span class="nf">intercambia-lista!</span> <span class="nv">lista</span><span class="p">)</span>
<span class="nv">lista</span> <span class="c1">; ⇒ {1 3 2 5 4 7 6}</span>
</pre></div>
</td></tr></table>

<p>La forma de implementar esta función va a ser llamando a la función
<code>intercambia!</code> (la que hemos definido anteriormente que intercambia el
segundo y el tercer elemento) hasta que lleguemos al final de la
lista. Lo hacemos con una recursión:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">intercambia-lista!</span> <span class="nv">lista</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">not </span><span class="p">(</span><span class="nb">null? </span><span class="p">(</span><span class="nb">cdr </span><span class="nv">lista</span><span class="p">)))</span>
           <span class="p">(</span><span class="nf">begin</span>
             <span class="p">(</span><span class="nf">intercambia!</span> <span class="nv">lista</span><span class="p">)</span>
             <span class="p">(</span><span class="nf">intercambia-lista!</span> <span class="p">(</span><span class="nb">cddr </span><span class="nv">lista</span><span class="p">)))))</span>
</pre></div>
</td></tr></table>

<p>La función termina cuando llegamos a la pareja final de la lista, la
que tiene la lista vacía en su parte derecha. </p>
<p>Si no estamos en el final de la lista llamamos a la función
<code>intercambia!</code> para intercambiar la siguiente pareja con su siguiente
y llamamos a la recursión con la variable <code>lista</code> apuntando a la
tercera pareja de la lista.</p>
<h3 id="33-lista-ordenada-mutable"><a name="3-3"></a> 3.3. Lista ordenada mutable<a class="headerlink" href="#33-lista-ordenada-mutable" title="Permanent link">&para;</a></h3>
<p>Veamos ahora una lista ordenada mutable de números, en la que insertaremos
elementos de forma ordenada.</p>
<p>Definiremos las siguientes funciones:</p>
<ul>
<li><code>(make-olist)</code>: construye una lista ordenada vacía</li>
<li><code>(borra-primero-olist! olist)</code>: función mutadora que elimina (con
  mutación) el primer elemento de la lista</li>
<li><code>(inserta-olist! olist n)</code>: función mutadora que inserta (con
  mutación) de forma ordenada un número en la lista</li>
</ul>
<p>Implementamos el tipo de datos con una lista normal con una pareja
adicional en cabeza. Esta pareja adicional funcionará de <strong>cabecera de
la lista</strong> y será la referencia inmutable a la que apuntará cualquier
variable que apunte a la lista. De esta forma podremos insertar
elementos en primera posición de la lista. En la cabecera usaremos por
convenio el símbolo <code>'*olist*'</code>.</p>
<p><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="nv">lista</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">*olist*</span> <span class="mi">10</span> <span class="mi">20</span> <span class="mi">30</span><span class="p">))</span>
</pre></div>
</td></tr></table>
<img src="imagenes/olist.png" width="600px"></p>
<p><strong>Constructor</strong></p>
<p>El constructor <code>(make-olist)</code> devuelve una lista sólo con la cabecera.</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">make-olist</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">list </span><span class="ss">&#39;*olist*</span><span class="p">))</span>
</pre></div>
</td></tr></table>

<p><strong>Mutadores</strong></p>
<p>Las funciones mutadoras modifican la estructura de datos.</p>
<p>Comenzamos con la función <code>(borra-primero-olist! olist)</code> que elimina
con mutación el primer elemento de la lista ordenada:</p>
<p><img src="imagenes/olist2.png" width="600px"></p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">borra-primero-olist!</span> <span class="nv">olist</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">set-cdr! </span><span class="nv">olist</span> <span class="p">(</span><span class="nb">cddr </span><span class="nv">olist</span><span class="p">)))</span>
</pre></div>
</td></tr></table>

<p>Definimos la función mutadora <code>inserta-olist!</code> que modifica la lista
ordenada añadiendo una nueva pareja, insertándola en la posición
correcta modificando las referencias.</p>
<p>La función <code>(add-item! item ref)</code> es la función clave que crea una
nueva pareja con el <code>item</code> y la añade en el <code>cdr</code> de la pareja a la
que apunta <code>ref</code>.</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">add-item!</span> <span class="nv">ref</span> <span class="nv">item</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">set-cdr! </span><span class="nv">ref</span> <span class="p">(</span><span class="nb">cons </span><span class="nv">item</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">ref</span><span class="p">))))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">inserta-olist!</span> <span class="nv">olist</span> <span class="nv">n</span><span class="p">)</span>
    <span class="p">(</span><span class="k">cond </span>
        <span class="p">((</span><span class="nb">null? </span><span class="p">(</span><span class="nb">cdr </span><span class="nv">olist</span><span class="p">))</span> <span class="p">(</span><span class="nf">add-item!</span> <span class="nv">olist</span> <span class="nv">n</span><span class="p">))</span>
        <span class="p">((</span><span class="nb">&lt; </span><span class="nv">n</span> <span class="p">(</span><span class="nb">cadr </span><span class="nv">olist</span><span class="p">))</span> <span class="p">(</span><span class="nf">add-item!</span> <span class="nv">olist</span> <span class="nv">n</span><span class="p">))</span>
        <span class="p">((</span><span class="nb">= </span><span class="nv">n</span> <span class="p">(</span><span class="nb">cadr </span><span class="nv">olist</span><span class="p">))</span> <span class="no">#f</span><span class="p">)</span>   <span class="c1">; el valor devuelto no importa</span>
        <span class="p">(</span><span class="k">else </span><span class="p">(</span><span class="nf">inserta-olist!</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">olist</span><span class="p">)</span> <span class="nv">n</span><span class="p">))))</span>
</pre></div>
</td></tr></table>

<p><img src="imagenes/olist3.png" width="600px"></p>
<p>Ejemplo de uso:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="nv">c</span> <span class="p">(</span><span class="nf">make-olist</span><span class="p">))</span>
<span class="p">(</span><span class="nf">inserta-olist!</span> <span class="nv">c</span> <span class="mi">5</span><span class="p">)</span>
<span class="p">(</span><span class="nf">inserta-olist!</span> <span class="nv">c</span> <span class="mi">10</span><span class="p">)</span>
<span class="p">(</span><span class="nf">inserta-olist!</span> <span class="nv">c</span> <span class="mi">-10</span><span class="p">)</span>
<span class="nv">c</span> <span class="c1">; ⇒ {*olist* -10 5 10}</span>
</pre></div>
</td></tr></table>

<h3 id="34-diccionario-mutable"><a name="3-4"></a> 3.4. Diccionario mutable<a class="headerlink" href="#34-diccionario-mutable" title="Permanent link">&para;</a></h3>
<ul>
<li>Veamos ahora un ejemplo más: un <em>diccionario</em> mutable definido
  mediante una lista de asociación formada por parejas de clave y
  valor</li>
</ul>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="nv">l-assoc</span> <span class="p">(</span><span class="nb">list </span><span class="p">(</span><span class="nb">cons </span><span class="ss">&#39;a</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nb">cons </span><span class="ss">&#39;b</span> <span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="nb">cons </span><span class="ss">&#39;c</span> <span class="mi">3</span><span class="p">)))</span>
</pre></div>
</td></tr></table>

<ul>
<li>La función de Scheme <code>assq</code> recorre la lista de asociación y
  devuelve la tupla que contiene el dato que se pasa como parámetro
  como clave</li>
</ul>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="nb">assq </span><span class="ss">&#39;a</span> <span class="nv">l-assoc</span><span class="p">)</span> <span class="c1">; ⇒ (a.1)</span>
<span class="p">(</span><span class="nb">assq </span><span class="ss">&#39;b</span> <span class="nv">l-assoc</span><span class="p">)</span> <span class="c1">; ⇒ (b.2)</span>
<span class="p">(</span><span class="nb">assq </span><span class="ss">&#39;c</span> <span class="nv">l-assoc</span><span class="p">)</span> <span class="c1">; ⇒ (c.3)</span>
<span class="p">(</span><span class="nb">assq </span><span class="ss">&#39;d</span> <span class="nv">l-assoc</span><span class="p">)</span> <span class="c1">; ⇒  #f</span>
<span class="p">(</span><span class="nb">cdr </span><span class="p">(</span><span class="nb">assq </span><span class="ss">&#39;c</span> <span class="nv">l-assoc</span><span class="p">))</span> <span class="c1">; ⇒ 3</span>
</pre></div>
</td></tr></table>

<ul>
<li>La función <code>assq</code> busca en la lista de asociación usando la igualdad
  de referencia <code>eq?</code></li>
</ul>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="nv">p</span> <span class="p">(</span><span class="nb">cons </span><span class="mi">1</span> <span class="mi">2</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">l-assoc</span> <span class="p">(</span><span class="nb">list </span><span class="p">(</span><span class="nb">cons </span><span class="ss">&#39;a</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nb">cons </span><span class="nv">p</span> <span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="nb">cons </span><span class="ss">&#39;c</span> <span class="mi">3</span><span class="p">)))</span>
<span class="p">(</span><span class="nb">assq </span><span class="p">(</span><span class="nb">cons </span><span class="mi">1</span> <span class="mi">2</span><span class="p">)</span> <span class="nv">l-assoc</span><span class="p">)</span> <span class="c1">; ⇒ #f</span>
<span class="p">(</span><span class="nb">assq </span><span class="nv">p</span> <span class="nv">l-assoc</span><span class="p">)</span> <span class="c1">; ⇒ {{1 . 2} . 2}</span>
</pre></div>
</td></tr></table>

<p>Las funciones que vamos a implementar del diccionario son las siguientes:</p>
<ul>
<li><code>(make-dic)</code>: construye un diccionario vacío</li>
<li><code>(put-dic! dic clave valor)</code>: inserta en el diccionario un nuevo
  valor asociado a una clave</li>
<li><code>(get-dic dic clave)</code>: devuelve el valor asociado a una clave en un
  diccionario</li>
</ul>
<p>Al igual que la lista ordenada mutable, el diccionario necesita una
cabecera:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">make-dic</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">list </span><span class="ss">&#39;*dic*</span><span class="p">))</span>
</pre></div>
</td></tr></table>

<p>La función <code>(get-dic dic clave)</code> usa la función <code>assq</code> para buscar la pareja que
contiene una clave determinada en la lista de asociación (el <code>cdr</code> de
dic). Y después devuelve el <code>cdr</code> de esa pareja (el valor guardado
junto con la clave:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">get-dic</span> <span class="nv">dic</span> <span class="nv">clave</span><span class="p">)</span>
    <span class="p">(</span><span class="k">let </span><span class="p">(</span><span class="nf">pareja</span> <span class="p">(</span><span class="nb">assq </span><span class="nv">clave</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">dic</span><span class="p">)))</span>
        <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">not </span><span class="nv">pareja</span><span class="p">)</span>
            <span class="no">#f</span>
            <span class="p">(</span><span class="nb">cdr </span><span class="nv">pareja</span><span class="p">))))</span>
</pre></div>
</td></tr></table>

<p>La función <code>(put-dic! dic clave valor)</code> usa igual que antes la función
<code>assq</code> para comprobar si la clave ya está en la lista de
asociación. Si existe, sustituye el valor por el nuevo. Si no existe,
crea una pareja con la clave y el valor y la inserta al comienzo del
diccionario (después de la cabecera):</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">put-dic!</span> <span class="nv">dic</span> <span class="nv">clave</span> <span class="nv">valor</span><span class="p">)</span>
    <span class="p">(</span><span class="k">let </span><span class="p">(</span><span class="nf">pareja</span> <span class="p">(</span><span class="nb">assq </span><span class="nv">clave</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">dic</span><span class="p">)))</span>
        <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">not </span><span class="nv">pareja</span><span class="p">)</span>
            <span class="p">(</span><span class="nb">set-cdr! </span><span class="nv">dic</span>
                  <span class="p">(</span><span class="nb">cons </span><span class="p">(</span><span class="nb">cons </span><span class="nv">clave</span> <span class="nv">valor</span><span class="p">)</span>
                        <span class="p">(</span><span class="nb">cdr </span><span class="nv">dic</span><span class="p">)))</span>
        <span class="p">(</span><span class="nb">set-cdr! </span><span class="nv">pareja</span> <span class="nv">valor</span><span class="p">)))</span>
    <span class="ss">&#39;ok</span><span class="p">)</span>
</pre></div>
</td></tr></table>

<p>En las funciones anteriores volvemos a usar la forma especial <code>let</code>.</p>
<p>Ejemplos de uso:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="nv">dic</span> <span class="p">(</span><span class="nf">make-dic</span><span class="p">))</span>
<span class="p">(</span><span class="nf">put-dic!</span> <span class="nv">dic</span> <span class="ss">&#39;a</span> <span class="mi">10</span><span class="p">)</span> <span class="c1">; ⇒ ok</span>
<span class="p">(</span><span class="nf">get-dic</span> <span class="nv">dic</span> <span class="ss">&#39;a</span><span class="p">)</span> <span class="c1">; ⇒ 10</span>
<span class="p">(</span><span class="nf">put-dic!</span> <span class="nv">dic</span> <span class="ss">&#39;b</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span><span class="p">))</span> <span class="c1">; ⇒ ok</span>
<span class="p">(</span><span class="nf">get-dic</span> <span class="nv">dic</span> <span class="ss">&#39;b</span><span class="p">)</span> <span class="c1">; ⇒ {a b c}</span>
<span class="p">(</span><span class="nf">put-dic!</span> <span class="nv">dic</span> <span class="ss">&#39;a</span> <span class="ss">&#39;ardilla</span><span class="p">)</span> <span class="c1">; ⇒ ok</span>
<span class="p">(</span><span class="nf">get-dic</span> <span class="nv">dic</span> <span class="ss">&#39;a</span><span class="p">)</span> <span class="c1">; ⇒ ardilla</span>
</pre></div>
</td></tr></table>

<h3 id="35-ejemplo-de-mutacion-con-listas-de-asociacion"><a name="3-5"></a> 3.5. Ejemplo de mutación con listas de asociación<a class="headerlink" href="#35-ejemplo-de-mutacion-con-listas-de-asociacion" title="Permanent link">&para;</a></h3>
<p>Una vez introducidos distintas estructuras de datos mutables,
incluyendo listas de asociación, vamos a terminar estos ejemplos con
un ejemplo práctico en el que intervienen las listas y las listas de
asociación. Se trata de escribir un procedimiento <code>regular-&gt;assoc!</code>
que transforme una lista regular en una lista de asociación sin crear
nuevas parejas. La lista regular <code>(k1 v1 k2 v2 k3 v3 ...)</code> deberá
convertirse en la lista de asociación <code>((k1 . v1) (k2 . v2) (k3 . v3)
...)</code>.</p>
<p>Ejemplo:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="nv">my-list</span> <span class="p">(</span><span class="nb">list </span><span class="ss">&#39;a</span> <span class="mi">1</span> <span class="ss">&#39;b</span> <span class="mi">2</span> <span class="ss">&#39;c</span> <span class="mi">3</span><span class="p">))</span>
<span class="nv">lista</span> <span class="c1">; ⇒ (a 1 b 2 c 3)</span>
<span class="p">(</span><span class="nf">regular-&gt;assoc!</span> <span class="nv">my-list</span><span class="p">)</span>
<span class="nv">lista</span> <span class="c1">; ⇒ ((a . 1) (b . 2) (c . 3))</span>
</pre></div>
</td></tr></table>

<p>Una posible solución a este problema sería la siguiente (no es la
única solución):</p>
<p>Cuando trabajamos con este tipo de problemas, es muy útil ayudarse con
los diagramas caja y puntero. Vamos a crear los diagramas caja y
puntero para el ejemplo anterior:</p>
<p>Antes de llamar a regular-&gt;assoc!:</p>
<p><img src="imagenes/mutable1.png" width="750px"></p>
<p>Después de llamar a regular-&gt;assoc!:</p>
<p><img src="imagenes/mutable2.png" width="400px"></p>
<p>Queremos hacer la transformación sin crear nuevas parejas, por lo que
cada pareja en el primer diagrama corresponde a una pareja particular
en el segundo diagrama. No podemos modificar la primera pareja de la
lista (porque perderíamos la ligadura de la variable <code>lista</code>), por
lo que es primera pareja tiene que permanecer en el primer lugar. Por
otra parte, <code>a</code> y <code>1</code> van a formar parte del mismo par en la lista de
asociación, por lo que vamos a considerar el siguiente cambio de las
dos primeras parejas.</p>
<p>Diagrama inicial:</p>
<p><img src="imagenes/mutable3.png" width="750px"></p>
<p>Después del cambio de las dos primeras parejas:</p>
<p><img src="imagenes/mutable4.png" width="650px"></p>
<p>La siguiente función <code>manejar-dos-parejas!</code> es la encargada de hacer
esta mutación:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">manejar-dos-parejas!</span> <span class="nv">p</span><span class="p">)</span>
    <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">key</span> <span class="p">(</span><span class="nb">car </span><span class="nv">p</span><span class="p">)))</span>            <span class="c1">;; 1</span>
        <span class="p">(</span><span class="nb">set-car! </span><span class="nv">p</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">p</span><span class="p">))</span>        <span class="c1">;; 2</span>
        <span class="p">(</span><span class="nb">set-cdr! </span><span class="nv">p</span> <span class="p">(</span><span class="nb">cdar </span><span class="nv">p</span><span class="p">))</span>       <span class="c1">;; 3</span>
        <span class="p">(</span><span class="nb">set-cdr! </span><span class="p">(</span><span class="nb">car </span><span class="nv">p</span><span class="p">)</span> <span class="p">(</span><span class="nb">caar </span><span class="nv">p</span><span class="p">))</span> <span class="c1">;; 4</span>
        <span class="p">(</span><span class="nb">set-car! </span><span class="p">(</span><span class="nb">car </span><span class="nv">p</span><span class="p">)</span> <span class="nv">key</span><span class="p">)))</span>    <span class="c1">;; 5</span>
</pre></div>
</td></tr></table>

<p>Se han numerado las líneas para una mejor explicación. En la línea 1,
<code>(define key (car p))</code>, creamos una variable local <code>key</code> que guarda el
valor actual del <code>(car p)</code>, ese valor será la clave de la primera
pareja de la lista de asociación; necesitamos almacenarlo para no
perderlo.</p>
<p>En la línea 2, <code>(set-car! p (cdr p))</code>, cambiamos el <code>car</code> de <code>p</code> para
que apunte a la siguiente pareja (la azul):</p>
<p><img src="imagenes/mutable6.png" width="300px"></p>
<p>En la línea 3, <code>(set-cdr! p (cdar p))</code>, copiamos en el <code>cdr</code> de <code>p</code>
el <code>cdr</code> de la pareja en azul para que ambos apunten a la siguiente
pareja:</p>
<p><img src="imagenes/mutable7.png" width="300px"></p>
<p>En la línea 4, <code>(set-cdr! (car p) (caar p))</code>, cambiamos el <code>cdr</code>
de la pareja en azul al <code>car</code> de la misma pareja. Hacemos ésto porque
en una lista de asociación, los valores se guardan en los <code>cdrs</code> y las
claves en los <code>cars</code>:</p>
<p><img src="imagenes/mutable8.png" width="300px"></p>
<p>Por último, en la línea 5 <code>(set-car! (car p) key)</code>, completamos el
problema poniendo la clave que habíamos guardado, en el <code>car</code> de la
pareja azul:</p>
<p><img src="imagenes/mutable9.png" width="300px"></p>
<p>Reordenamos el diagrama para verlo más claro:</p>
<p><img src="imagenes/mutable10.png" width="220px"></p>
<p>Hemos definido un procedimiento que maneja un subproblema (dos
parejas) del problema. Ahora sólo nos queda definir la función que
maneja toda la lista:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">regular-&gt;assoc!</span> <span class="nv">lista</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">null? </span><span class="nv">lista</span><span class="p">)</span> 
     <span class="ss">&#39;ok</span>
     <span class="p">(</span><span class="k">begin </span><span class="p">(</span><span class="nf">manejar-dos-parejas!</span> <span class="nv">lista</span><span class="p">)</span>
            <span class="p">(</span><span class="nf">regular-&gt;assoc!</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">lista</span><span class="p">)))))</span>
</pre></div>
</td></tr></table>

<h2 id="4-ambitos-de-variables-y-clausuras"><a name="4"></a> 4. Ámbitos de variables y clausuras<a class="headerlink" href="#4-ambitos-de-variables-y-clausuras" title="Permanent link">&para;</a></h2>
<p>El concepto del <strong>ámbito</strong> de vida de las variables es un concepto
fundamental en los lenguajes de programación. Utilizaremos las
palabras <em>ámbito</em> y <em>entorno</em> como sinónimos. En inglés se utiliza el
término
<em><a href="https://en.wikipedia.org/wiki/Scope_(computer_science)">scope</a></em>.</p>
<p>Cuando se define una variable, asociándole un valor, esta asociación
tiene una extensión determinada, ya sea en términos de tiempo de
compilación (<strong>ámbito léxico</strong>) como en términos de tiempo de
ejecución (<strong>ámbito dinámico</strong>). El ámbito de una variable determina
cuándo podemos referirnos a ella para recuperar el valor asociado.</p>
<p>Al conjunto de variables disponibles en una parte del programa o en
una parte de su ejecución se denomina <strong>contexto</strong> o <strong>entorno</strong>
(<em>context</em> o <em>environment</em>).</p>
<h3 id="41-variables-de-ambito-global"><a name="4-1"></a> 4.1. Variables de ámbito global<a class="headerlink" href="#41-variables-de-ambito-global" title="Permanent link">&para;</a></h3>
<p>Una variable definida en el programa con la instrucción <code>define</code> tiene
un ámbito global.</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="nv">a</span> <span class="s">&quot;hola&quot;</span><span class="p">)</span>
<span class="p">(</span><span class="k">define </span><span class="nv">b</span> <span class="p">(</span><span class="nb">string-append </span><span class="s">&quot;adios&quot;</span> <span class="nv">a</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">cuadrado</span> <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">* </span><span class="nv">x</span> <span class="nv">x</span><span class="p">)))</span>
</pre></div>
</td></tr></table>

<p>Todas las variables definidas fuera de funciones forman parte del
<strong>entorno global</strong> del programa.</p>
<h3 id="42-variables-de-ambito-local"><a name="4-2"></a> 4.2. Variables de ámbito local<a class="headerlink" href="#42-variables-de-ambito-local" title="Permanent link">&para;</a></h3>
<p>En Scheme existen dos formas de definir variables de ámbito local: la
forma especial <code>define</code> dentro de una función y la forma especial
<code>let</code>.</p>
<h4>4.2.1 Variables locales con <code>define</code></h4>
<p>Como en la mayoría de lenguajes de programación, en Scheme se crea un
<strong>entorno o ámbito local</strong> (memoria local de la invocación de la
función) cada vez que se invoca a una función.</p>
<p>En este entorno local toman valor los parámetros y las variables
locales de la función. Es posible definir variables locales en una
función utilizando la forma especial <code>define</code> dentro de la propia
función. Esto no lo hacíamos dentro del paradigma funcional, para
evitar realizar pasos de ejecución. Pero ahora que estamos en el
paradigma imperativo podemos utilizarlo.</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">distancia</span> <span class="nv">x1</span> <span class="nv">y1</span> <span class="nv">x2</span> <span class="nv">y2</span><span class="p">)</span>
   <span class="p">(</span><span class="k">define </span><span class="nv">distancia-x</span> <span class="p">(</span><span class="nb">- </span><span class="nv">x2</span> <span class="nv">x1</span><span class="p">))</span>
   <span class="p">(</span><span class="k">define </span><span class="nv">distancia-y</span> <span class="p">(</span><span class="nb">- </span><span class="nv">y2</span> <span class="nv">y1</span><span class="p">))</span>
   <span class="p">(</span><span class="nb">sqrt </span><span class="p">(</span><span class="nb">+ </span><span class="p">(</span><span class="nf">cuadrado</span> <span class="nv">distancia-x</span><span class="p">)</span>
            <span class="p">(</span><span class="nf">cuadrado</span> <span class="nv">distancia-y</span><span class="p">))))</span>
</pre></div>
</td></tr></table>

<p>Podemos usar en un entorno local una variable con el mismo nombre que
en el entorno global. Cuando se ejecute el código de la función se
utilizará el valor local.</p>
<p>Por ejemplo, supongamos las siguientes expresiones:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="nv">x</span> <span class="mi">5</span><span class="p">)</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">suma-10</span> <span class="nv">y</span><span class="p">)</span>
  <span class="p">(</span><span class="k">define </span><span class="nv">x</span> <span class="mi">10</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">+ </span><span class="nv">x</span> <span class="nv">y</span><span class="p">))</span>

<span class="p">(</span><span class="nf">suma-10</span> <span class="mi">3</span><span class="p">)</span> <span class="c1">; ⇒ 13</span>
</pre></div>
</td></tr></table>

<p>La primera sentencia de la función <code>(suma y)</code> define una variable
local <code>x</code> a la que se asigna un valor inicial de 10. </p>
<p>Cuando se ejecuta la expresión <code>(+ x y)</code>, en la invocación a <code>(suma
3)</code> el valor de <code>x</code> es entonces 10 (el valor local que hemos definido
en la sentencia anterior), no es 5, devolviéndose 15.</p>
<p>Sucede igual si un parámetro tiene el mismo nombre que una variable global:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="nv">x</span> <span class="mi">5</span><span class="p">)</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">suma-3</span> <span class="nv">x</span><span class="p">)</span>
   <span class="p">(</span><span class="nb">+ </span><span class="nv">x</span> <span class="mi">3</span><span class="p">))</span>

<span class="p">(</span><span class="nf">suma-3</span> <span class="mi">12</span><span class="p">)</span> <span class="c1">; ⇒ 15</span>
</pre></div>
</td></tr></table>

<p>Cuando se ejecuta la expresión <code>(+ x 3)</code> en la invocación a <code>(suma-3
12)</code> el valor de <code>x</code> es 12, no es 5, devolviéndose 15.</p>
<p>En el entorno local también se pueden utilizar variables definidas en
el entorno global. Por ejemplo:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="nv">z</span> <span class="mi">12</span><span class="p">)</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">foo</span> <span class="nv">y</span><span class="p">)</span>
   <span class="p">(</span><span class="k">define </span><span class="nv">x</span> <span class="mi">10</span><span class="p">)</span>
   <span class="p">(</span><span class="nb">+ </span><span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span><span class="p">))</span>

<span class="p">(</span><span class="nf">foo</span> <span class="mi">5</span><span class="p">)</span> <span class="c1">; ⇒ 27</span>
</pre></div>
</td></tr></table>

<p>La expresión <code>(+ x y z)</code> se evalúa en el entorno local en el que <code>x</code>
vale 10 e <code>y</code> vale 5. Al no estar definida la variable <code>z</code> en este
entorno local, se usa su definición de ámbito global.</p>
<p>Una vez realizada la invocación, desparece el entorno local junto con
las variables locales definidas en él, y se recupera el contexto
global. Por ejemplo, en la siguiente expresión, una vez realizada la
invocación a <code>(suma-10 2)</code> se devuelve el número 12 y se evalúa en el
entorno global la expresión <code>(+ 12 x)</code>. En este contexto la variable
<code>x</code> vale 5 por lo que la expresión devuelve 17.</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="nv">x</span> <span class="mi">5</span><span class="p">)</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">suma-10</span> <span class="nv">y</span><span class="p">)</span>
   <span class="p">(</span><span class="k">define </span><span class="nv">x</span> <span class="mi">10</span><span class="p">)</span>
   <span class="p">(</span><span class="nb">+ </span><span class="nv">x</span> <span class="nv">y</span><span class="p">))</span>

<span class="p">(</span><span class="nb">+ </span><span class="p">(</span><span class="nf">suma-10</span> <span class="mi">2</span><span class="p">)</span> <span class="nv">x</span><span class="p">)</span> <span class="c1">; ⇒ 17</span>
</pre></div>
</td></tr></table>

<p>Otro ejemplo:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="nv">x</span> <span class="mi">10</span><span class="p">)</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">foo2</span> <span class="nv">y</span><span class="p">)</span>
   <span class="p">(</span><span class="k">define </span><span class="nv">z</span> <span class="mi">5</span><span class="p">)</span>
   <span class="p">(</span><span class="nb">+ </span><span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span><span class="p">))</span>

<span class="p">(</span><span class="nf">foo2</span> <span class="mi">2</span><span class="p">)</span> <span class="c1">; ⇒ 17</span>
<span class="nv">x</span> <span class="c1">; ⇒ 10</span>
<span class="nv">z</span> <span class="c1">; ⇒ error, no definida</span>
<span class="nv">y</span> <span class="c1">; ⇒ error, no definida</span>
</pre></div>
</td></tr></table>

<p><strong>Define en el cuerpo de una función</strong></p>
<p>La forma especial <code>define</code> para crear variables locales sólo puede
utilizarse al comienzo de la definición de una función. Si intentamos
utilizarla a mitad del código de la función tendremos un error:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">suma-10-si-mayor-que-0</span> <span class="nv">x</span><span class="p">)</span>
   <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&gt; </span><span class="nv">x</span> <span class="mi">0</span><span class="p">)</span>
      <span class="p">(</span><span class="k">begin </span>
         <span class="c1">;; ERROR:</span>
         <span class="c1">;; no es posible usar define a mitad del código</span>
         <span class="c1">;; de una función</span>
         <span class="p">(</span><span class="k">define </span><span class="nv">y</span> <span class="mi">10</span><span class="p">)</span>
         <span class="p">(</span><span class="nb">+ </span><span class="nv">x</span> <span class="nv">y</span><span class="p">))</span>
     <span class="nv">x</span><span class="p">))</span>
</pre></div>
</td></tr></table>

<h4>4.2.1 Variables locales con <code>let</code></h4>
<p>La otra forma de definir variables locales en Scheme es con la forma
especial <code>let</code>.</p>
<p>La forma especial <code>let</code> permite crear un ámbito local en el que se da
valor a variables y se evalúan expresiones.</p>
<p>Sintaxis:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">&lt;var1&gt;</span> <span class="nv">&lt;exp-1&gt;</span><span class="p">)</span>
        <span class="o">...</span>
      <span class="p">(</span><span class="nf">&lt;varn&gt;</span> <span class="nv">&lt;exp-n&gt;</span><span class="p">))</span>
    <span class="nv">&lt;cuerpo&gt;</span><span class="p">)</span>
</pre></div>
</td></tr></table>

<p>Las variables <code>var1</code>, … <code>varn</code> toman los valores devueltos por las
expresiones <code>exp1</code>, … <code>expn</code> y el cuerpo se evalúa con esos
valores. Esas variables sólo tienen valor en el ámbito de la forma
especial.</p>
<p>Por ejemplo:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="nv">x</span> <span class="mi">10</span><span class="p">)</span>
<span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">x</span> <span class="p">(</span><span class="nb">+ </span><span class="mi">1</span> <span class="mi">2</span><span class="p">))</span>
      <span class="p">(</span><span class="nf">y</span> <span class="p">(</span><span class="nb">* </span><span class="mi">10</span> <span class="mi">2</span><span class="p">))</span>
    <span class="p">(</span><span class="nb">+ </span><span class="nv">x</span> <span class="nv">y</span><span class="p">))</span> <span class="c1">; ⇒ 23</span>
<span class="nv">x</span> <span class="c1">; ⇒ 10</span>
<span class="nv">y</span> <span class="c1">; ⇒ error, no definida</span>
</pre></div>
</td></tr></table>

<p>Cuando ha terminado la evaluación del <code>let</code> el ámbito local desaparece
y quedan los valores definidos en el ámbito anterior.</p>
<p>Las expresiones que dan valor a las variables del let se evalúan antes
de crear el ámbito local. Por ejemplo, en el siguiente código, las
expresiones <code>(+ x 3)</code> y <code>(+ y 2)</code> devuelven 4 y 7 respectivamente:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="nv">x</span> <span class="mi">1</span><span class="p">)</span>
<span class="p">(</span><span class="k">define </span><span class="nv">y</span> <span class="mi">5</span><span class="p">)</span>
<span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">w</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">x</span> <span class="mi">3</span><span class="p">))</span>
      <span class="p">(</span><span class="nf">z</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">y</span> <span class="mi">2</span><span class="p">)))</span>
    <span class="p">(</span><span class="nb">+ </span><span class="nv">w</span> <span class="nv">z</span><span class="p">))</span> <span class="c1">; ⇒ 11</span>
</pre></div>
</td></tr></table>

<p>En el cuerpo del <code>let</code> puede haber más de una expresión:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">x</span> <span class="mi">10</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">y</span> <span class="mi">20</span><span class="p">))</span>
    <span class="p">(</span><span class="nb">display </span><span class="s">&quot;x: &quot;</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">display </span><span class="nv">x</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">display </span><span class="s">&quot;\ny: &quot;</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">display </span><span class="nv">y</span><span class="p">))</span>
</pre></div>
</td></tr></table>

<p><strong>Let en el cuerpo de una función</strong></p>
<p>A diferencia de <code>define</code> sí que es posible usar <code>let</code> en cualquier
expresión de Scheme, por ejemplo, en un <code>if</code>:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">suma-10-si-mayor-que-0</span> <span class="nv">x</span><span class="p">)</span>
   <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&gt; </span><span class="nv">x</span> <span class="mi">0</span><span class="p">)</span>
      <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">y</span> <span class="mi">10</span><span class="p">))</span>
         <span class="p">(</span><span class="nb">+ </span><span class="nv">x</span> <span class="nv">y</span><span class="p">))</span>
      <span class="nv">x</span><span class="p">))</span>
</pre></div>
</td></tr></table>

<h3 id="43-clausuras-y-estado-local"><a name="4-3"></a> 4.3. Clausuras y estado local<a class="headerlink" href="#43-clausuras-y-estado-local" title="Permanent link">&para;</a></h3>
<p>Recordemos que la forma especial <code>lambda</code> permite crear funciones
anónimas en tiempo de ejecución. Si ejecutamos una forma especial
lambda como último paso de una función, se devolverá la
función recién creada.</p>
<p>¿Qué sucede si utilizamos en el cuerpo de esta función anónima una
variable local definida en la función principal?</p>
<p>Vamos a verlo:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">make-sumador</span><span class="p">)</span>
   <span class="p">(</span><span class="k">define </span><span class="nv">z</span> <span class="mi">10</span><span class="p">)</span>
   <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">x</span> <span class="nv">z</span><span class="p">)))</span>
</pre></div>
</td></tr></table>

<p>La función <code>make-sumador</code> define una variable local <code>z</code> con el valor
de 10. Y después construye una función con la expresión <code>lambda</code>. Al
ser la última expresión de la función <code>make-sumador</code>, esta función
construida en tiempo de ejecución es lo que se devuelve. </p>
<p>Si invocamos a <code>make-sumador</code> vemos que devuelve un procedimiento:</p>
<p><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="nf">make-sumador</span><span class="p">)</span> <span class="c1">; ⇒ #&lt;procedure&gt;</span>
</pre></div>
</td></tr></table>
Si guardamos el procedimiento en una variable y después lo invocamos,
tendremos que pasarle un parámetro (correspondiente al argumento <code>x</code>
de la expresión <code>lambda</code>). ¿Qué devolverá esa invocación?</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="nv">f</span> <span class="p">(</span><span class="nf">make-sumador</span><span class="p">))</span>
<span class="p">(</span><span class="nf">f</span> <span class="mi">5</span><span class="p">)</span> <span class="c1">; ⇒ ???</span>
</pre></div>
</td></tr></table>

<p>Al invocar a <code>f</code> se ejecutará el cuerpo del procedimiento, esto es, la
expresión <code>(+ x z)</code>. La variable <code>x</code> valdrá 5 (el valor del
parámetro). Pero, ¿cuál es el valor de la variable z?. Podemos
comprobar que es 10, porque la invocación devuelve devuelve 15:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="nf">f</span> <span class="mi">5</span><span class="p">)</span> <span class="c1">; ⇒ 15</span>
</pre></div>
</td></tr></table>

<p>¿Por qué? Lo que está pasando es que la función anónima que crea la
expresión lambda <strong>captura las variables locales</strong> definidas en el
ámbito en el que se crea. Por eso recibe el nombre de <strong>clausura</strong>,
porque encierra los valores que tienen esas variables en el momento de
su creación y esos valores son los que usa en las variables libres
cuando posteriormente la invoquemos.</p>
<p>En el ejemplo anterior se está capturando la variable <code>z</code> con su
valor 10. Cuando después invocamos a <code>(f 5)</code> se evalúa el cuerpo <code>(+ x
z)</code> con <code>x</code> valiendo <code>5</code> y <code>z</code> valiendo el valor capturado (10).</p>
<p>También podemos utilizar como estado local el valor de un
parámetro. Por ejemplo:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">make-sumador</span> <span class="nv">k</span><span class="p">)</span>
    <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">x</span> <span class="nv">k</span><span class="p">)))</span>

<span class="p">(</span><span class="k">define </span><span class="nv">f</span> <span class="p">(</span><span class="nf">make-sumador</span> <span class="mi">10</span><span class="p">))</span>
<span class="p">(</span><span class="nf">f</span> <span class="mi">2</span><span class="p">)</span>
<span class="c1">; ⇒ 12</span>
</pre></div>
</td></tr></table>

<p>En la función <code>(make-sumador k)</code> se llama a la forma especial lambda
para crear una clausura. La clausura captura la variable local <code>k</code> (el
parámetro de <code>make-sumador</code>) y usará su valor cuando posteriormente se
evalúe. En este caso, la clausura se ha creado con <code>k</code> valiendo 10,
y captura este valor. </p>
<p>Cuando después se invoca a <code>(f 2)</code> se ejecuta la clausura en un nuevo
ámbito local con las siguientes variables y valores:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">x</span><span class="o">:</span> <span class="mi">2</span> <span class="o">(</span><span class="n">variable</span> <span class="n">local</span> <span class="n">de</span> <span class="n">la</span> <span class="n">clausura</span><span class="o">)</span>
<span class="n">k</span><span class="o">:</span> <span class="mi">10</span> <span class="o">(</span><span class="n">valor</span> <span class="n">capturado</span> <span class="n">del</span> <span class="n">entorno</span> <span class="n">local</span> <span class="n">en</span> <span class="n">el</span> <span class="n">que</span> <span class="n">se</span> <span class="n">creó</span> <span class="n">la</span> <span class="n">clausura</span>
</pre></div>
</td></tr></table>

<p>En este ámbito se ejecuta la expresión <code>(+ x k)</code>, devolviéndose el
valor 12.</p>
<p>Por último, también es posible crear la clausura dentro de un estado
local definido con un <code>let</code> y usar en el cuerpo del <code>lambda</code> variables
locales definidas en el <code>let</code>:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">make-sumador-cuadrado</span> <span class="nv">k</span><span class="p">)</span>
    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&gt; </span><span class="nv">k</span> <span class="mi">0</span><span class="p">)</span>
        <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">y</span> <span class="p">(</span><span class="nf">cuadrado</span> <span class="nv">k</span><span class="p">)))</span>
          <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">x</span><span class="p">)</span>
            <span class="p">(</span><span class="nb">+ </span><span class="nv">x</span> <span class="nv">y</span><span class="p">)))</span>
        <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">x</span><span class="p">)</span>
          <span class="nv">x</span><span class="p">)))</span>
</pre></div>
</td></tr></table>

<p>La función anterior tiene un condicional en el que se comprueba si <code>k</code>
es mayor que 0. Si lo es, se devuelve una clausura creada en el ámbito
del <code>let</code> con la variable <code>y</code> capturada con el valor del cuadrado de
<code>k</code>. Esta clausura suma a su entrada el valor de <code>y</code>.</p>
<p>Por ejemplo:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="nv">f</span> <span class="p">(</span><span class="nf">make-sumador-cuadrado</span> <span class="mi">4</span><span class="p">))</span>
<span class="p">(</span><span class="nf">f</span> <span class="mi">3</span><span class="p">)</span> <span class="c1">; ⇒ 19</span>
</pre></div>
</td></tr></table>

<p>En el caso en que <code>k</code> menor o igual que 0, se devuelve una clausura
que devuelve siempre el valor que recibe:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="nv">f</span> <span class="p">(</span><span class="nf">make-sumador-cuadrado</span> <span class="mi">-8</span><span class="p">))</span>
<span class="p">(</span><span class="nf">f</span> <span class="mi">3</span><span class="p">)</span> <span class="c1">; ⇒ 3</span>
</pre></div>
</td></tr></table>

<p>La definición de clausuras con un estado local inicializado a un valor
creado en tiempo de ejecución es una característica muy
potente. Permite no sólo crear funciones en tiempo de ejecución para
utilizarlas posteriormente, sino configurarlas con el estado local que
nos interese.</p>
<p>Veremos en el apartado siguiente que la combinación de clausuras y
mutación permite crear funciones con estado local mutable,
algo equivalente a objetos que encapsulan código y estado.</p>
<h2 id="5-clausuras-con-mutacion-estado-local-mutable"><a name="5"></a> 5. Clausuras con mutación = estado local mutable<a class="headerlink" href="#5-clausuras-con-mutacion-estado-local-mutable" title="Permanent link">&para;</a></h2>
<h3 id="51-estado-local-mutable"><a name="5-1"></a> 5.1. Estado local mutable<a class="headerlink" href="#51-estado-local-mutable" title="Permanent link">&para;</a></h3>
<p>Si combinamos una clausura con la posibilidad de mutar las variables
capturadas por la clausura obtenemos un estado local mutable asociado
a funciones creadas en tiempo de ejecución.</p>
<p>Veamos, por ejemplo, la siguiente función <code>(make-contador i)</code>:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">make-contador</span> <span class="nv">i</span><span class="p">)</span>
  <span class="p">(</span><span class="k">define </span><span class="nv">x</span> <span class="nv">i</span><span class="p">)</span>
  <span class="p">(</span><span class="k">lambda </span><span class="p">()</span>
     <span class="p">(</span><span class="k">set! </span><span class="nv">x</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">x</span> <span class="mi">1</span><span class="p">))</span>
     <span class="nv">x</span><span class="p">)))</span>
</pre></div>
</td></tr></table>

<p>La función <code>make-contador</code> define una clausura que captura la variable
local <code>x</code> inicializada a <code>i</code>. En cada invocación a la clausura se
ejecuta una sentencia <code>set</code> que modifica el valor de la variable
capturada. Y después se devuelve el nuevo valor de la
variable. Estamos implementando un contador asociado a la clausura.</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="nv">f</span> <span class="p">(</span><span class="nf">make-contador</span> <span class="mi">10</span><span class="p">))</span>
<span class="p">(</span><span class="nf">f</span><span class="p">)</span> <span class="err">⇒</span> <span class="mi">11</span>
<span class="p">(</span><span class="nf">f</span><span class="p">)</span> <span class="err">⇒</span> <span class="mi">12</span>
</pre></div>
</td></tr></table>

<p>El estado (el valor del contador) se mantiene y se modifica entre
distintas invocaciones a <code>f</code>. A diferencia del paradigma funcional
podemos comprobar que distintas invocaciones a la misma función
devuelven valores distintos (dependiente del estado de la clausura).</p>
<p>Podemos crear distintas clausuras, cada una con su variable capturada,
en distintas invocaciones a <code>make-contador</code>:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="nv">h</span> <span class="p">(</span><span class="nf">make-contador</span> <span class="mi">10</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">g</span> <span class="p">(</span><span class="nf">make-contador</span> <span class="mi">100</span><span class="p">))</span>
<span class="p">(</span><span class="nf">h</span><span class="p">)</span> <span class="err">⇒</span> <span class="mi">11</span>
<span class="p">(</span><span class="nf">h</span><span class="p">)</span> <span class="err">⇒</span> <span class="mi">12</span>
<span class="p">(</span><span class="nf">g</span><span class="p">)</span> <span class="err">⇒</span> <span class="mi">101</span>
<span class="p">(</span><span class="nf">g</span><span class="p">)</span> <span class="err">⇒</span> <span class="mi">102</span>
</pre></div>
</td></tr></table>

<p>Una forma alternativa de crear la clausura, sin usar la forma especial
<code>lambda</code> es definiéndola con un <code>define</code> en el cuerpo de
<code>make-contador</code>. Después de los dos <code>define</code> la última sentencia
devuelve la función <code>incrementa</code> (la clausura).</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">make-contador</span> <span class="nv">i</span><span class="p">)</span>
  <span class="p">(</span><span class="k">define </span><span class="nv">x</span> <span class="nv">i</span><span class="p">)</span>
  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">incrementa</span><span class="p">)</span>
    <span class="p">(</span><span class="k">set! </span><span class="nv">x</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">x</span> <span class="mi">1</span><span class="p">))</span>
    <span class="nv">x</span><span class="p">)</span>
  <span class="nv">incrementa</span><span class="p">)</span>
</pre></div>
</td></tr></table>

<h3 id="52-paso-de-mensajes"><a name="5-2"></a> 5.2. Paso de mensajes<a class="headerlink" href="#52-paso-de-mensajes" title="Permanent link">&para;</a></h3>
<p>En el ejemplo anterior creamos una clausura que siempre incrementa el
valor del contador. ¿Cómo podríamos crear una clausura que permitiera
hacer distintas cosas con el valor capturado?</p>
<p>Una forma de hacerlo es definir en la clausura un parámetro adicional
(un símbolo que llamamos <em>mensaje</em>) y devolver distintas clausuras en
función del valor de ese parámetro adicional:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">make-contador</span> <span class="nv">i</span><span class="p">)</span>
  <span class="p">(</span><span class="k">define </span><span class="nv">x</span> <span class="nv">i</span><span class="p">)</span>
  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">get</span><span class="p">)</span>
    <span class="nv">x</span><span class="p">)</span>
  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">inc-1</span><span class="p">)</span>
    <span class="p">(</span><span class="k">set! </span><span class="nv">x</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">x</span> <span class="mi">1</span><span class="p">))</span>
    <span class="nv">x</span><span class="p">)</span>
  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">inc</span> <span class="nv">y</span><span class="p">)</span>
    <span class="p">(</span><span class="k">set! </span><span class="nv">x</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">x</span> <span class="nv">y</span><span class="p">))</span>
    <span class="nv">x</span><span class="p">)</span>

  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">dispatcher</span> <span class="nv">mensaje</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">cond</span>
      <span class="p">((</span><span class="nb">equal? </span><span class="nv">mensaje</span> <span class="ss">&#39;get</span><span class="p">)</span> <span class="nv">get</span><span class="p">)</span>
      <span class="p">((</span><span class="nb">equal? </span><span class="nv">mensaje</span> <span class="ss">&#39;inc-1</span><span class="p">)</span> <span class="nv">inc-1</span><span class="p">)</span>
      <span class="p">((</span><span class="nb">equal? </span><span class="nv">mensaje</span> <span class="ss">&#39;inc</span><span class="p">)</span> <span class="nv">inc</span><span class="p">)</span>
      <span class="p">(</span><span class="k">else </span><span class="s">&quot;Error: mensaje desconocido&quot;</span><span class="p">)))</span>
  <span class="nv">dispatcher</span><span class="p">)</span>
</pre></div>
</td></tr></table>

<p>La función <code>make-contador</code> devuelve la clausura <code>dispatcher</code> que se
encarga de procesar el mensaje y devolver la clausura asociada a ese
mensaje. Cuando invoquemos al <em>dispatcher</em> con un símbolo, devuelve
otro procedimiento que hay que volver a invocar con los parámetros
adecuados (sin parámetros en los dos primeros casos y con el valor a
incrementar en el último caso):</p>
<ul>
<li>Si recibe el símbolo <code>'get</code> devuelve la clausura que devuelve el valor del contador</li>
<li>Si recibe el símbolo <code>'inc-1</code> devuelve la clausura que incrementa el valor del contador en 1</li>
<li>Si recibe el símbolo <code>'inc</code> devuelve la clausura que incrementa el valor del contador una cantidad determinada</li>
</ul>
<p>Por ejemplo:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="nv">c</span> <span class="p">(</span><span class="nf">make-contador</span> <span class="mi">100</span><span class="p">))</span>
<span class="p">((</span><span class="nf">c</span> <span class="ss">&#39;get</span><span class="p">))</span> <span class="err">⇒</span> <span class="mi">100</span>
<span class="p">((</span><span class="nf">c</span> <span class="ss">&#39;inc-1</span><span class="p">))</span> <span class="err">⇒</span> <span class="mi">101</span>
<span class="p">((</span><span class="nf">c</span> <span class="ss">&#39;inc</span><span class="p">)</span> <span class="mi">10</span><span class="p">)</span> <span class="err">⇒</span> <span class="mi">111</span>
</pre></div>
</td></tr></table>

<hr />
<p>Lenguajes y Paradigmas de Programación, curso 2016-17<br />
© Departamento Ciencia de la Computación e Inteligencia Artificial, Universidad de Alicante<br />
Domingo Gallardo, Cristina Pomares</p>
                
                  
                
                
              
              
                


              
            </article>
          </div>
        </div>
      </main>
      
        
<footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-footer-copyright">
        
        powered by
        <a href="https://www.mkdocs.org">MkDocs</a>
        and
        <a href="https://squidfunk.github.io/mkdocs-material/">
          Material for MkDocs</a>
      </div>
      
    </div>
  </div>
</footer>
      
    </div>
    
      <script src="../../assets/javascripts/application.808e90bb.js"></script>
      
      <script>app.initialize({version:"1.0.4",url:{base:"../.."}})</script>
      
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML"></script>
      
    
  </body>
</html>