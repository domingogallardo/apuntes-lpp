
<!doctype html>
<html lang="es" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
        <link rel="prev" href="../tema01-historia-lenguajes-programacion/tema01-historia-lenguajes-programacion.html">
      
      
        <link rel="next" href="../../seminarios/seminario1-scheme/seminario1-scheme.html">
      
      
      <link rel="icon" href="../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.5.34">
    
    
      
        <title>Tema 2: Programación funcional - LPP</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/main.35f28582.min.css">
      
        
        <link rel="stylesheet" href="../../assets/stylesheets/palette.06af60db.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
    <script>__md_scope=new URL("../..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    
    
      
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="teal" data-md-color-accent="teal">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#tema-2-programacion-funcional" class="md-skip">
          Saltar a contenido
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Cabecera">
    <a href="../.." title="LPP" class="md-header__button md-logo" aria-label="LPP" data-md-component="logo">
      
  <img src="../../imagenes/logo.png" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            LPP
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Tema 2: Programación funcional
            
          </span>
        </div>
      </div>
    </div>
    
      
        <form class="md-header__option" data-md-component="palette">
  
    
    
    
    <input class="md-option" data-md-color-media="" data-md-color-scheme="default" data-md-color-primary="teal" data-md-color-accent="teal"  aria-label="Switch to dark mode"  type="radio" name="__palette" id="__palette_0">
    
      <label class="md-header__button md-icon" title="Switch to dark mode" for="__palette_1" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a4 4 0 0 0-4 4 4 4 0 0 0 4 4 4 4 0 0 0 4-4 4 4 0 0 0-4-4m0 10a6 6 0 0 1-6-6 6 6 0 0 1 6-6 6 6 0 0 1 6 6 6 6 0 0 1-6 6m8-9.31V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12z"/></svg>
      </label>
    
  
    
    
    
    <input class="md-option" data-md-color-media="" data-md-color-scheme="slate" data-md-color-primary="black" data-md-color-accent="indigo"  aria-label="Switch to light mode"  type="radio" name="__palette" id="__palette_1">
    
      <label class="md-header__button md-icon" title="Switch to light mode" for="__palette_0" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 18c-.89 0-1.74-.2-2.5-.55C11.56 16.5 13 14.42 13 12s-1.44-4.5-3.5-5.45C10.26 6.2 11.11 6 12 6a6 6 0 0 1 6 6 6 6 0 0 1-6 6m8-9.31V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12z"/></svg>
      </label>
    
  
</form>
      
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Búsqueda" placeholder="Búsqueda" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Buscar">
        
        <button type="reset" class="md-search__icon md-icon" title="Limpiar" aria-label="Limpiar" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Inicializando búsqueda
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navegación" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../.." title="LPP" class="md-nav__button md-logo" aria-label="LPP" data-md-component="logo">
      
  <img src="../../imagenes/logo.png" alt="logo">

    </a>
    LPP
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
    
  
  
  
    
    
    
    
    <li class="md-nav__item md-nav__item--active md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_1" checked>
        
          
          <label class="md-nav__link" for="__nav_1" id="__nav_1_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Teoría
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_1_label" aria-expanded="true">
          <label class="md-nav__title" for="__nav_1">
            <span class="md-nav__icon md-icon"></span>
            Teoría
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../tema00-descripcion-asignatura/tema00-descripcion-asignatura.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Descripción de la asignatura
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../tema01-historia-lenguajes-programacion/tema01-historia-lenguajes-programacion.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Tema 1: Historia de los lenguajes de programación
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
    
  
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          
  
  <span class="md-ellipsis">
    Tema 2: Programación funcional
  </span>
  

          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="tema02-programacion-funcional.html" class="md-nav__link md-nav__link--active">
        
  
  <span class="md-ellipsis">
    Tema 2: Programación funcional
  </span>
  

      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="Tabla de contenidos">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Tabla de contenidos
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#1-el-paradigma-de-programacion-funcional" class="md-nav__link">
    <span class="md-ellipsis">
      1. El paradigma de Programación Funcional
    </span>
  </a>
  
    <nav class="md-nav" aria-label="1. El paradigma de Programación Funcional">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#11-pasado-y-presente-del-paradigma-funcional" class="md-nav__link">
    <span class="md-ellipsis">
      1.1. Pasado y presente del paradigma funcional
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#12-evaluacion-de-expresiones-y-definicion-de-funciones" class="md-nav__link">
    <span class="md-ellipsis">
      1.2. Evaluación de expresiones y definición de funciones
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#13-programacion-declarativa-vs-imperativa" class="md-nav__link">
    <span class="md-ellipsis">
      1.3. Programación declarativa vs. imperativa
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#14-modelo-de-computacion-de-sustitucion" class="md-nav__link">
    <span class="md-ellipsis">
      1.4. Modelo de computación de sustitución
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#2-scheme-como-lenguaje-de-programacion-funcional" class="md-nav__link">
    <span class="md-ellipsis">
      2. Scheme como lenguaje de programación funcional
    </span>
  </a>
  
    <nav class="md-nav" aria-label="2. Scheme como lenguaje de programación funcional">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#21-funciones-y-formas-especiales" class="md-nav__link">
    <span class="md-ellipsis">
      2.1. Funciones y formas especiales
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#22-formas-especiales-en-scheme" class="md-nav__link">
    <span class="md-ellipsis">
      2.2. Formas especiales en Scheme
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#23-forma-especial-quote-y-simbolos" class="md-nav__link">
    <span class="md-ellipsis">
      2.3. Forma especial quote y símbolos
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#24-forma-expecial-quote-con-expresiones" class="md-nav__link">
    <span class="md-ellipsis">
      2.4. Forma expecial quote con expresiones
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#25-funcion-eval" class="md-nav__link">
    <span class="md-ellipsis">
      2.5. Función eval
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#26-listas" class="md-nav__link">
    <span class="md-ellipsis">
      2.6. Listas
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#27-recursion" class="md-nav__link">
    <span class="md-ellipsis">
      2.7. Recursión
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#28-recursion-y-listas" class="md-nav__link">
    <span class="md-ellipsis">
      2.8. Recursión y listas
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#3-tipos-de-datos-compuestos-en-scheme" class="md-nav__link">
    <span class="md-ellipsis">
      3. Tipos de datos compuestos en Scheme
    </span>
  </a>
  
    <nav class="md-nav" aria-label="3. Tipos de datos compuestos en Scheme">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#31-el-tipo-de-dato-pareja" class="md-nav__link">
    <span class="md-ellipsis">
      3.1. El tipo de dato pareja
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#32-las-parejas-son-objetos-de-primera-clase" class="md-nav__link">
    <span class="md-ellipsis">
      3.2. Las parejas son objetos de primera clase
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#33-diagramas-caja-y-puntero" class="md-nav__link">
    <span class="md-ellipsis">
      3.3. Diagramas caja-y-puntero
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#4-listas-en-scheme" class="md-nav__link">
    <span class="md-ellipsis">
      4. Listas en Scheme
    </span>
  </a>
  
    <nav class="md-nav" aria-label="4. Listas en Scheme">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#41-implementacion-de-listas-en-scheme" class="md-nav__link">
    <span class="md-ellipsis">
      4.1. Implementación de listas en Scheme
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#42-listas-con-elementos-compuestos" class="md-nav__link">
    <span class="md-ellipsis">
      4.2. Listas con elementos compuestos
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#6-bibliografia" class="md-nav__link">
    <span class="md-ellipsis">
      6. Bibliografía
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2" >
        
          
          <label class="md-nav__link" for="__nav_2" id="__nav_2_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Seminarios
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2">
            <span class="md-nav__icon md-icon"></span>
            Seminarios
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../seminarios/seminario1-scheme/seminario1-scheme.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Seminario de Scheme
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3" >
        
          
          <label class="md-nav__link" for="__nav_3" id="__nav_3_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Prácticas
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3">
            <span class="md-nav__icon md-icon"></span>
            Prácticas
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../practicas/buenas-practicas-programacion-funcional.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Buenas prácticas de programación funcional
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../practicas/practica01/practica01.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Práctica 1
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../practicas/practica02/practica02.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Práctica 2
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Tabla de contenidos">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Tabla de contenidos
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#1-el-paradigma-de-programacion-funcional" class="md-nav__link">
    <span class="md-ellipsis">
      1. El paradigma de Programación Funcional
    </span>
  </a>
  
    <nav class="md-nav" aria-label="1. El paradigma de Programación Funcional">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#11-pasado-y-presente-del-paradigma-funcional" class="md-nav__link">
    <span class="md-ellipsis">
      1.1. Pasado y presente del paradigma funcional
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#12-evaluacion-de-expresiones-y-definicion-de-funciones" class="md-nav__link">
    <span class="md-ellipsis">
      1.2. Evaluación de expresiones y definición de funciones
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#13-programacion-declarativa-vs-imperativa" class="md-nav__link">
    <span class="md-ellipsis">
      1.3. Programación declarativa vs. imperativa
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#14-modelo-de-computacion-de-sustitucion" class="md-nav__link">
    <span class="md-ellipsis">
      1.4. Modelo de computación de sustitución
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#2-scheme-como-lenguaje-de-programacion-funcional" class="md-nav__link">
    <span class="md-ellipsis">
      2. Scheme como lenguaje de programación funcional
    </span>
  </a>
  
    <nav class="md-nav" aria-label="2. Scheme como lenguaje de programación funcional">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#21-funciones-y-formas-especiales" class="md-nav__link">
    <span class="md-ellipsis">
      2.1. Funciones y formas especiales
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#22-formas-especiales-en-scheme" class="md-nav__link">
    <span class="md-ellipsis">
      2.2. Formas especiales en Scheme
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#23-forma-especial-quote-y-simbolos" class="md-nav__link">
    <span class="md-ellipsis">
      2.3. Forma especial quote y símbolos
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#24-forma-expecial-quote-con-expresiones" class="md-nav__link">
    <span class="md-ellipsis">
      2.4. Forma expecial quote con expresiones
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#25-funcion-eval" class="md-nav__link">
    <span class="md-ellipsis">
      2.5. Función eval
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#26-listas" class="md-nav__link">
    <span class="md-ellipsis">
      2.6. Listas
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#27-recursion" class="md-nav__link">
    <span class="md-ellipsis">
      2.7. Recursión
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#28-recursion-y-listas" class="md-nav__link">
    <span class="md-ellipsis">
      2.8. Recursión y listas
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#3-tipos-de-datos-compuestos-en-scheme" class="md-nav__link">
    <span class="md-ellipsis">
      3. Tipos de datos compuestos en Scheme
    </span>
  </a>
  
    <nav class="md-nav" aria-label="3. Tipos de datos compuestos en Scheme">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#31-el-tipo-de-dato-pareja" class="md-nav__link">
    <span class="md-ellipsis">
      3.1. El tipo de dato pareja
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#32-las-parejas-son-objetos-de-primera-clase" class="md-nav__link">
    <span class="md-ellipsis">
      3.2. Las parejas son objetos de primera clase
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#33-diagramas-caja-y-puntero" class="md-nav__link">
    <span class="md-ellipsis">
      3.3. Diagramas caja-y-puntero
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#4-listas-en-scheme" class="md-nav__link">
    <span class="md-ellipsis">
      4. Listas en Scheme
    </span>
  </a>
  
    <nav class="md-nav" aria-label="4. Listas en Scheme">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#41-implementacion-de-listas-en-scheme" class="md-nav__link">
    <span class="md-ellipsis">
      4.1. Implementación de listas en Scheme
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#42-listas-con-elementos-compuestos" class="md-nav__link">
    <span class="md-ellipsis">
      4.2. Listas con elementos compuestos
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#6-bibliografia" class="md-nav__link">
    <span class="md-ellipsis">
      6. Bibliografía
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


<h1 id="tema-2-programacion-funcional">Tema 2: Programación funcional<a class="headerlink" href="#tema-2-programacion-funcional" title="Permanent link">&para;</a></h1>
<h2 id="1-el-paradigma-de-programacion-funcional">1. El paradigma de Programación Funcional<a class="headerlink" href="#1-el-paradigma-de-programacion-funcional" title="Permanent link">&para;</a></h2>
<h3 id="11-pasado-y-presente-del-paradigma-funcional">1.1. Pasado y presente del paradigma funcional<a class="headerlink" href="#11-pasado-y-presente-del-paradigma-funcional" title="Permanent link">&para;</a></h3>
<h4 id="111-definicion-y-caracteristicas">1.1.1. Definición y características<a class="headerlink" href="#111-definicion-y-caracteristicas" title="Permanent link">&para;</a></h4>
<p>En una definición muy breve y concisa la programación funcional define
un <strong>programa</strong> de la siguiente forma:</p>
<div class="admonition quote">
<p class="admonition-title">Definición de programa funcional</p>
<p>En programación funcional un programa es un conjunto de
funciones matemáticas que convierten unas entradas en unas
salidas, sin ningún estado interno y ningún efecto lateral.</p>
</div>
<p>Hablaremos más adelante de la no existencia de estado interno
(variables en las que se guardan y se modifican valores) y de la
ausencia de efectos laterales. Avancemos que estas son también
características de la <strong>programación declarativa</strong> (frente a la
programación tradicional imperativa que es la que se utiliza en
lenguajes como C o Java). En este sentido, la programación funcional
es un tipo concreto de programación declarativa.</p>
<p>Las características principales del paradigma funcional son:</p>
<ul>
<li>Definiciones de funciones matemáticas puras, sin estado interno ni
  efectos laterales</li>
<li>Valores inmutables</li>
<li>Uso profuso de la recursión en la definición de las funciones</li>
<li>Uso de listas como estructuras de datos fundamentales</li>
<li>Funciones como tipos de datos primitivos: expresiones lambda y
  funciones de orden superior</li>
</ul>
<p>Explicaremos estas propiedades a continuación.</p>
<h4 id="112-origenes-historicos">1.1.2. Orígenes históricos<a class="headerlink" href="#112-origenes-historicos" title="Permanent link">&para;</a></h4>
<p>En los años 30, junto con la máquina de Turing, se propusieron
distintos modelos computacionales equivalentes que formalizaban el
concepto de <em>algoritmo</em>. Uno de estos modelos fue el denominado
<a href="https://en.wikipedia.org/wiki/Lambda_calculus"><em>Cálculo lambda</em></a>
propuesto por Alonzo Church en los años 30 y basado en la evaluación
de expresiones matemáticas. En este formalismo los algoritmos se
expresan mediante funciones matemáticas en las que puede ser usada la
recursión. Una función matemática recibe parámetros de entrada y
devuelve un valor. La evaluación de la función se realiza evaluando
sus expresiones matemáticas mediante la sustitución de los parámetros
formales por los valores reales que se utilizan en la invocación (el
denominado <strong>modelo de sustitución</strong> que veremos más adelante).</p>
<p>El cálculo lambda es un formalismo matemático, basado en operaciones
abstractas. Dos décadas después, cuando los primeros computadores
electrónicos estaban empezando a utilizarse en grandes empresas y en
universidades, este formalismo dio origen a algo mucho más tangible y
práctico: un lenguaje de alto nivel, mucho más expresivo que el
ensamblador, con el que expresar operaciones y funciones <strong>que pueden
ser definidas y evaluadas en el computador</strong>, el lenguaje de
programación Lisp.</p>
<h4 id="113-historia-y-caracteristicas-del-lisp">1.1.3. Historia y características del Lisp<a class="headerlink" href="#113-historia-y-caracteristicas-del-lisp" title="Permanent link">&para;</a></h4>
<ul>
<li><a href="http://en.wikipedia.org/wiki/Lisp_(programming_language)">Lisp</a> es
  el primer lenguaje de programación de alto nivel basado en el
  paradigma funcional.</li>
<li>Creado en 1958 por John McCarthy.</li>
<li>Lisp fue en su época un lenguaje revolucionario que introdujo nuevos
  conceptos de programación no existentes entonces: funciones como
  objetos primitivos, funciones de orden superior, polimorfismo,
  listas, recursión, símbolos, homogeneidad de datos y programas,
  bucle REPL (<em>Read-Eval-Print Loop</em>)</li>
<li>La herencia del Lisp llega a lenguajes derivados de él (Scheme,
  Golden Common Lisp) y a nuevos lenguajes de paradigmas no
  estrictamente funcionales, como C#, Python, Ruby, Objective-C o
  Scala.</li>
</ul>
<p>Lisp fue el primer lenguaje de programación interpretado, con muchas
características dinámicas que se ejecutan en tiempo de ejecución
(<em>run-time</em>). Entre estas características podemos destacar la gestión
de la memoria (creación y destrucción <strong>automática</strong> de memoria reservada
para datos), la detección de excepciones y errores en tiempo de
ejecución o la creación en tiempo de ejecución de funciones anónimas
(expresiones <em>lambda</em>). Todas estas características se ejecutan
mediante un <em>sistema de tiempo de ejecución</em> (<em>runtime system</em>)
presente en la ejecución de los programas. A partir del Lisp
muchos otros lenguajes han usado estas características de
interpretación o de sistemas de tiempo de ejecución. Por ejemplo,
lenguajes como BASIC, Python, Ruby o JavaScript son lenguajes
interpretados. Y lenguajes como Java o C# tienen una avanzada
plataforma de tiempo de ejecución con soporte para la gestión de la
memoria dinámica (<em>recolección de basura</em>,
<a href="https://en.wikipedia.org/wiki/Garbage_collection_(computer_science)"><em>garbage collection</em></a>)
o la
<a href="https://en.wikipedia.org/wiki/Just-in-time_compilation">compilación <em>just in time</em></a>.</p>
<p>Lisp no es un lenguaje exclusivamente funcional. Lisp se diseñó con el
objetivo de ser un lenguaje de alto nivel capaz de resolver problemas
prácticos de Inteligencia Artificial, no con la idea de ser un
lenguaje formal basado un único modelo de computación. Por ello en
Lisp (y en Scheme) existen primitivas que se salen del paradigma
funcional puro y permiten programar de formar imperativa (no
declarativa), usando mutación de estado y pasos de ejecución. </p>
<p>Sin embargo, durante la primera parte de la asignatura en la que
estudiaremos la programación funcional, no utilizaremos las
instrucciones imperativas de Scheme sino que escribiremos código
exclusivamente funcional.</p>
<h4 id="114-lenguajes-de-programacion-funcional">1.1.4. Lenguajes de programación funcional<a class="headerlink" href="#114-lenguajes-de-programacion-funcional" title="Permanent link">&para;</a></h4>
<p>En los años 60 la programación funcional definida por el Lisp fue
dominante en departamentos de investigación en Inteligencia Artificial
(MIT por ejemplo). En los años 70, 80 y 90 se fue relegando cada vez
más a los nichos académicos y de investigación; en la empresa se
impusieron los lenguajes imperativos y orientados a objetos.</p>
<p>En la primera década del 2000 han aparecido lenguajes que evolucionan
de Lisp y que resaltan sus aspectos funcionales, aunque actualizando
su sintaxis. Destacamos entre ellos:</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Clojure">Clojure</a></li>
<li><a href="https://en.wikipedia.org/wiki/Erlang_(programming_language)">Erlang</a></li>
</ul>
<p>También hay una tendencia desde mediados de la década de 2000 de
incluir aspectos funcionales como las <em>expresiones lambda</em> o las
funciones de orden superior en lenguajes imperativos orientados a
objetos, dando lugar a lenguajes <em>multi-paradigma</em>:</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Ruby_(programming_language)">Ruby</a></li>
<li><a href="https://en.wikipedia.org/wiki/Python_(programming_language)">Python</a></li>
<li><a href="https://en.wikipedia.org/wiki/Groovy_(programming_language)">Groovy</a></li>
<li><a href="https://en.wikipedia.org/wiki/Scala_(programming_language)">Scala</a></li>
<li><a href="https://en.wikipedia.org/wiki/Swift_(programming_language)">Swift</a></li>
</ul>
<p>Por último, en la década del 2010 también se ha hecho popular un
lenguaje <strong>exclusivamente funcional</strong> como
<a href="https://en.wikipedia.org/wiki/Haskell_(programming_language)">Haskell</a>. Este
lenguaje, a diferencia de Scheme y de otros lenguajes multi-paradigma,
no tienen ningún elemento imperativo y consigue que todas sus
expresiones sean puramente funcionales.</p>
<h4 id="115-aplicaciones-practicas-de-la-programacion-funcional">1.1.5. Aplicaciones prácticas de la programación funcional<a class="headerlink" href="#115-aplicaciones-practicas-de-la-programacion-funcional" title="Permanent link">&para;</a></h4>
<p>En la actualidad el paradigma funcional es un <strong>paradigma de moda</strong>,
como se puede comprobar observando la cantidad de artículos, charlas y
blogs en los que se habla de él, así como la cantidad de lenguajes que
están aplicando sus conceptos. Por ejemplo, solo como muestra, a
continuación puedes encontrar algunos enlaces a charlas y artículos
interesantes publicados recientemente sobre programación funcional:</p>
<ul>
<li>Lupo Montero - <a href="https://medium.com/laboratoria-how-to/introducción-a-la-programación-funcional-en-javascript-parte-1-e0b1d0b2142e">Introducción a la programación funcional en
  JavaScript</a> (Blog)</li>
<li>Andrés Marzal - <a href="https://www.youtube.com/watch?v=jG4QuREv5fE">Por qué deberías aprender programación funcional ya
  mismo</a> (Charla en YouTube)</li>
<li>Mary Rose Cook - <a href="https://maryrosecook.com/blog/post/a-practical-introduction-to-functional-programming">A practical introduction to functional
programming</a> (Blog)</li>
<li>Ben Christensen - <a href="https://www.infoq.com/presentations/Netflix-API-rxjava-hystrix">Functional Reactive Programming in the Netflix
  API</a>
  (Charla en InfoQ)</li>
</ul>
<p>El auge reciente de estos lenguajes y del paradigma funcional se debe
a varios factores, entre ellos que es un paradigma que facilita:</p>
<ul>
<li>la programación de sistemas concurrentes, con múltiples hilos de
  ejecución o con múltiples computadores ejecutando procesos
  conectados concurrentes.</li>
<li>la definición y composición de múltiples operaciones sobre <em>streams</em>
  de forma muy concisa y compacta, aplicable a la programación de
  sistemas distribuidos en Internet.</li>
<li>la programación interactiva y evolutiva.</li>
</ul>
<h5 id="1151-programacion-de-sistemas-concurrentes">1.1.5.1. Programación de sistemas concurrentes<a class="headerlink" href="#1151-programacion-de-sistemas-concurrentes" title="Permanent link">&para;</a></h5>
<p>Veremos más adelante que una de las características principales de la
programación funcional es que no se usa la <em>mutación</em> (no se modifican
los valores asignados a variables ni parámetros). Esta propiedad lo
hace un paradigma excelente para implementar programas concurrentes,
en los que existen múltiples hilos de ejecución. La programación de
sistemas concurrentes es muy complicada con el paradigma imperativo
tradicional, en el que la modificación del estado de una variable
compartida por más de un hilo puede provocar <em>condiciones de carrera</em>
y errores difícilmente localizables y reproducibles.</p>
<p>Como dice <a href="https://twitter.com/BartoszMilewski">Bartosz Milewski</a>,
investigador y teórico de ciencia de computación, en su
<a href="https://www.quora.com/Why-do-software-engineers-like-functional-programming/answer/Bartosz-Milewski">respuesta en Quora</a>
a la pregunta <em>¿por qué a los ingenieros de software les gusta la
programación funcional?</em>:</p>
<div class="admonition quote">
<p class="admonition-title">Bartosz Milewski: ¿Por qué es popular la programación funcional?</p>
<p>Porque es la única forma práctica de escribir programas
concurrentes. Intentar escribir programas concurrentes en
lenguajes imperativos, no sólo es difícil, sino que lleva a <em>bugs</em> que son
muy difíciles de descubrir, reproducir y arreglar. En los
lenguajes imperativos y, en particular, en los lenguajes orientados a
objetos se ocultan las mutaciones y se comparten datos sin darse cuenta,
por lo que son extremadamente propensos a los errores de concurrencia
producidos por las condiciones de carrera.</p>
</div>
<h5 id="1152-definicion-y-composicion-de-operaciones-sobre-streams">1.1.5.2. Definición y composición de operaciones sobre streams<a class="headerlink" href="#1152-definicion-y-composicion-de-operaciones-sobre-streams" title="Permanent link">&para;</a></h5>
<p>El paradigma funcional ha originado un estilo de programación sobre
<em>streams</em> de datos, en el que se concatenan operaciones como <code>filter</code>
o <code>map</code> para definir de forma sencilla procesos y transformaciones
asíncronas aplicables a los elementos del <em>stream</em>. Este estilo de
programación ha hecho posible nuevas ideas de programación, como la
programación <em>reactiva</em>, basada en eventos, o los <em>futuros</em> o
<em>promesas</em> muy utilizados en lenguajes muy populares como JavaScript
para realizar peticiones asíncronas a servicios web.</p>
<p>Por ejemplo, en el artículo
<a href="http://zeroturnaround.com/rebellabs/exploring-the-virtues-of-microservices-with-play-and-akka/">Exploring the virtues of microservices with Play and Akka</a>
se explica con detalle las ventajas del uso de lenguajes y primitivas
para trabajar con sistemas asíncronos basados en eventos en servicios
como Tumblr o Netflix.</p>
<p>Otro ejemplo es el
<a href="http://highscalability.com/blog/2012/2/13/tumblr-architecture-15-billion-page-views-a-month-and-harder.html">uso de Scala en Tumblr</a>
con el que se consigue crear código que no tiene estado compartido y
que es fácilmente paralelizable entre los más de 800 servidores
necesarios para atender picos de más de 40.000 peticiones por segundo:</p>
<div class="admonition quote">
<p class="admonition-title">Uso de Scala en Tumblr</p>
<p>Scala promueve que no haya estado compartido. El estado mutable se
evita usando sentencias en Scala. No se usan máquinas de estado de
larga duración. El estado se saca de la base de datos, se usa, y se
escribe de nuevo en la base de datos. La ventaja principal es que
los desarrolladores no tienen que preocuparse sobre hilos o
bloqueos.</p>
</div>
<h5 id="1153-programacion-evolutiva">1.1.5.3. Programación evolutiva<a class="headerlink" href="#1153-programacion-evolutiva" title="Permanent link">&para;</a></h5>
<p>En la metodología de programación denominada <em>programación evolutiva</em>
o <em>iterativa</em> los programas complejos se construyen a base de ir
definiendo y probando elementos computacionales cada vez más
complicados. Los lenguajes de programación funcional encajan
perfectamente en esta forma de construir programas.</p>
<p>Como Abelson y Sussman comentan en el libro <em>Structure and
Implementation of Computer Programs</em> (SICP):</p>
<div class="admonition quote">
<p class="admonition-title">Abelson y Sussman sobre la programación incremental</p>
<p>En general, los objetos computacionales pueden tener estructuras muy
complejas, y sería extremadamente inconveniente tener que recordar y
repetir sus detalles cada vez que queremos usarlas. En lugar de
ello, se construyen programas complejos componiendo, paso a paso,
objetos computacionales de creciente complejidad.</p>
<p>El intérprete hace esta construcción paso-a-paso de los programas
particularmente conveniente porque las asociaciones nombre-objeto se
pueden crear de forma incremental en interacciones sucesivas. Esta
característica favorece el desarrollo y prueba incremental de
programas, y es en gran medida responsable del hecho de que un
programa Lisp consiste normalmente de un gran número de
procedimientos relativamente simples.</p>
</div>
<p>No hay que confundir una metodología de programación con un paradigma
de programación. Una metodología de programación proporciona
sugerencias sobre cómo debemos diseñar, desarrollar y mantener una
aplicación que va a ser usada por usuarios finales. La programación
funcional se puede usar con múltiples metodologías de
programación, debido a que los programas resultantes son muy claros,
expresivos y fáciles de probar.</p>
<h3 id="12-evaluacion-de-expresiones-y-definicion-de-funciones">1.2. Evaluación de expresiones y definición de funciones<a class="headerlink" href="#12-evaluacion-de-expresiones-y-definicion-de-funciones" title="Permanent link">&para;</a></h3>
<p>En la asignatura usaremos Scheme como primer lenguaje en el que
exploraremos la programación funcional.</p>
<p>En el seminario de Scheme que se imparte en prácticas se estudian en
más profundidad los conceptos más importantes del lenguaje: tipos de
datos, operadores, estructuras de control, intérprete, etc.</p>
<h4 id="121-evaluacion-de-expresiones">1.2.1 Evaluación de expresiones<a class="headerlink" href="#121-evaluacion-de-expresiones" title="Permanent link">&para;</a></h4>
<p>Empezamos este apartado viendo cómo se definen y evalúan expresiones
Scheme. Y después veremos cómo construir nuevas funciones.</p>
<p>Scheme es un lenguaje que viene del Lisp. Una de sus características
principales es que las expresiones se construyen utilizando
paréntesis.</p>
<p>Ejemplos de expresiones en Scheme, junto con el resultado de su
ejecución:</p>
<div class="highlight"><pre><span></span><code><span class="mi">2</span><span class="w"> </span><span class="c1">; ⇒ 2</span>
<span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="c1">; ⇒ 5</span>
<span class="p">(</span><span class="nb">+</span><span class="p">)</span><span class="w"> </span><span class="c1">; ⇒ 0</span>
<span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="mi">6</span><span class="p">)</span><span class="w"> </span><span class="c1">; ⇒ 17</span>
<span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">-</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">1</span><span class="p">))</span><span class="w"> </span><span class="c1">; ⇒ 8</span>
</code></pre></div>
<p>En programación funcional en lugar de decir "ejecutar una expresión"
se dice "<strong>evaluar una expresión</strong>", para reforzar la idea de que se
tratan de expresiones matemáticas que <strong>siempre devuelven uno y sólo un
resultado</strong>.</p>
<p>Las expresiones se definen con una notación prefija: el primer
elemento después del paréntesis de apertura es el <strong>operador</strong> de la
expresión y el resto de elementos (hasta el paréntesis de cierre) son
sus operandos.</p>
<ul>
<li>
<p>Por ejemplo, en la expresión <code>(+ 2 4 5 6)</code> el operador es el símbolo
<code>+</code> que representa función <em>suma</em> y los operandos son los números 2,
4, 5 y 6.</p>
</li>
<li>
<p>Puede haber expresiones que no tengan operandos, como el ejemplo
<code>(+)</code>, cuya evaluación devuelve 0.</p>
</li>
</ul>
<p>Una idea fundamental de Lisp y Scheme es que los paréntesis se evalúan
de dentro a fuera. Por ejemplo, la expresión </p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">-</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="p">(</span><span class="nb">/</span><span class="w"> </span><span class="mi">12</span><span class="w"> </span><span class="mi">3</span><span class="p">)))</span>
</code></pre></div>
<p>que devuelve 5, se evalúa así:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">-</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="p">(</span><span class="nb">/</span><span class="w"> </span><span class="mi">12</span><span class="w"> </span><span class="mi">3</span><span class="p">)))</span><span class="w"> </span><span class="n">⇒</span>
<span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="mi">6</span><span class="w"> </span><span class="p">(</span><span class="nb">-</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="p">(</span><span class="nb">/</span><span class="w"> </span><span class="mi">12</span><span class="w"> </span><span class="mi">3</span><span class="p">)))</span><span class="w"> </span><span class="n">⇒</span>
<span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="mi">6</span><span class="w"> </span><span class="p">(</span><span class="nb">-</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="p">))</span><span class="w"> </span><span class="n">⇒</span>
<span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="mi">6</span><span class="w"> </span><span class="mi">-1</span><span class="p">)</span><span class="w"> </span><span class="n">⇒</span>
<span class="mi">5</span>
</code></pre></div>
<p>La evaluación de cada expresión devuelve un valor que se utiliza para
continuar calculando la expresión exterior. En el caso anterior</p>
<ul>
<li>primero se evalúa la expresión <code>(* 2 3)</code> que devuelve 6,</li>
<li>después se evalúa <code>(/ 12 3)</code> que devuelve 4,</li>
<li>después se evalúa <code>(- 3 4)</code> que devuelve -1</li>
<li>y por último se evalúa <code>(+ 6 -1)</code> que devuelve 5</li>
</ul>
<p>Cuando se evalúa una expresión en el intérprete de Scheme el 
resultado aparece en la siguiente línea. </p>
<h4 id="122-definicion-de-funciones">1.2.2. Definición de funciones<a class="headerlink" href="#122-definicion-de-funciones" title="Permanent link">&para;</a></h4>
<p>En programación funcional las funciones son similares a las funciones
matemáticas: reciben parámetros y devuelven siempre un único resultado
de operar con esos parámetros.</p>
<p>Por ejemplo, podemos definir la función <code>(cuadrado x)</code> que devuelve el
cuadrado de un número que pasamos como parámetro:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">cuadrado</span><span class="w"> </span><span class="n">x</span><span class="p">)</span>
<span class="w">   </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">x</span><span class="p">))</span>
</code></pre></div>
<p>Después del nombre de la función se declaran sus argumentos. El número
de argumentos de una función se denomina <strong>aridad de la función</strong>. Por
ejemplo, la función <code>cuadrado</code> es una función de aridad 1, o <em>unaria</em>.</p>
<p>Después de declarar los parámetros, se define el cuerpo de la
función. Es una expresión que se evaluará con el valor que se pase
como parámetro. En el caso anterior la expresión es <code>(* x x)</code> y
multiplicará el parámetro por si mismo.</p>
<p>Hay que hacer notar que en Scheme no existe la palabra clave <code>return</code>,
sino que las funciones siempre se definen con una única expresión cuya
evaluación es el resultado que se devuelve.</p>
<p>Una vez definida la función <code>cuadrado</code> podemos usarla de la misma
forma que las funciones primitivas de Scheme:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="n">cuadrado</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span><span class="w"> </span><span class="c1">; ⇒ 100</span>
<span class="p">(</span><span class="n">cuadrado</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="p">(</span><span class="n">cuadrado</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">4</span><span class="p">))))</span><span class="w"> </span><span class="c1">; ⇒ 2116</span>
</code></pre></div>
<p>La evaluación de la última expresión se hace de la siguiente forma:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="n">cuadrado</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="p">(</span><span class="n">cuadrado</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">4</span><span class="p">))))</span><span class="w"> </span><span class="n">⇒</span>
<span class="p">(</span><span class="n">cuadrado</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="p">(</span><span class="n">cuadrado</span><span class="w"> </span><span class="mi">6</span><span class="p">)))</span><span class="w"> </span><span class="n">⇒</span>
<span class="p">(</span><span class="n">cuadrado</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="mi">36</span><span class="p">))</span><span class="w"> </span><span class="n">⇒</span>
<span class="p">(</span><span class="n">cuadrado</span><span class="w"> </span><span class="mi">46</span><span class="p">)</span><span class="w"> </span><span class="n">⇒</span>
<span class="mi">2116</span>
</code></pre></div>
<h4 id="123-definicion-de-funciones-auxiliares">1.2.3. Definición de funciones auxiliares<a class="headerlink" href="#123-definicion-de-funciones-auxiliares" title="Permanent link">&para;</a></h4>
<p>Las funciones definidas se pueden utilizar a su vez para construir
otras funciones.</p>
<p>Lo habitual en programación funcional es definir funciones muy
pequeñas e ir construyendo funciones cada vez de mayor nivel usando
las anteriores.</p>
<h5 id="1231-ejemplo-suma-de-cuadrados">1.2.3.1. Ejemplo: suma de cuadrados<a class="headerlink" href="#1231-ejemplo-suma-de-cuadrados" title="Permanent link">&para;</a></h5>
<p>Por ejemplo, supongamos que tenemos que definir una función que
devuelva la suma del cuadrado de dos números. Podríamos definirla
escribiendo la expresión completa, pero queda una definición poco
legible.</p>
<div class="highlight"><pre><span></span><code><span class="c1">; Definición poco legible de la suma de cuadrados</span>

<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">suma-cuadrados</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">x</span><span class="p">)</span>
<span class="w">       </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="n">y</span><span class="p">)))</span>
</code></pre></div>
<p>Podemos hacer una definición mucho más legible si usamos la función
<code>cuadrado</code> definida anteriormente:</p>
<div class="highlight"><pre><span></span><code><span class="c1">; Definición de suma de cuadrados más legible.</span>
<span class="c1">; Usamos la función auxiliar &#39;cuadrado&#39;</span>

<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">cuadrado</span><span class="w"> </span><span class="n">x</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">x</span><span class="p">))</span>

<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">suma-cuadrados</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="p">(</span><span class="n">cuadrado</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span>
<span class="w">       </span><span class="p">(</span><span class="n">cuadrado</span><span class="w"> </span><span class="n">y</span><span class="p">)))</span>
</code></pre></div>
<p>Esta segunda definición es mucho más expresiva. Leyendo el código queda
muy claro qué es lo que queremos hacer.</p>
<h5 id="1232-ejemplo-tiempo-de-impacto">1.2.3.2. Ejemplo: tiempo de impacto<a class="headerlink" href="#1232-ejemplo-tiempo-de-impacto" title="Permanent link">&para;</a></h5>
<p>Veamos otro ejemplo de uso de funciones auxiliares. Supongamos que
estamos programando un juego de guerra de barcos y submarinos, en el
que utilizamos las coordenadas del plano para situar todos los
elementos de nuestra flota.</p>
<p>Supongamos que necesitamos calcular el tiempo que tarda un torpedo en
llegar desde una posición <code>(x1, y1)</code> a otra <code>(x2, y2)</code>. Suponemos que
la velocidad del torpedo es otro parámetro <code>v</code>. </p>
<p>¿Cómo calcularíamos este tiempo de impacto?</p>
<p>La forma menos correcta de hacerlo es definir todo el cálculo en una
única expresión. Como en programación funcional las funciones deben
definirse con una única expresión debemos realizar todo el cálculo en
forma de expresiones anidadas, unas dentro de otras. Esto construye
una función que calcula bien el resultado. El problema que tiene es
que es muy difícil de leer y entender para un compañero (o para
nosotros mismos, cuando pasen unos meses):</p>
<div class="highlight"><pre><span></span><code><span class="c1">;</span>
<span class="c1">; Definición incorrecta: muy poco legible</span>
<span class="c1">;</span>
<span class="c1">; La función tiempo-impacto devuelve el tiempo que tarda</span>
<span class="c1">; en llegar un torpedo a la velocidad v desde la posición</span>
<span class="c1">; (x1, y1) a la posición (x2, y2)</span>
<span class="c1">;</span>

<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">tiempo-impacto</span><span class="w"> </span><span class="n">x1</span><span class="w"> </span><span class="n">y1</span><span class="w"> </span><span class="n">x2</span><span class="w"> </span><span class="n">y2</span><span class="w"> </span><span class="n">v</span><span class="p">)</span>
<span class="w">   </span><span class="p">(</span><span class="nb">/</span><span class="w"> </span><span class="p">(</span><span class="nb">sqrt</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="p">(</span><span class="nb">-</span><span class="w"> </span><span class="n">x2</span><span class="w"> </span><span class="n">x1</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">-</span><span class="w"> </span><span class="n">x2</span><span class="w"> </span><span class="n">x1</span><span class="p">))</span>
<span class="w">               </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="p">(</span><span class="nb">-</span><span class="w"> </span><span class="n">y2</span><span class="w"> </span><span class="n">y1</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">-</span><span class="w"> </span><span class="n">y2</span><span class="w"> </span><span class="n">y1</span><span class="p">))))</span>
<span class="w">    </span><span class="n">v</span><span class="p">))</span>
</code></pre></div>
<p>La función anterior hace bien el cálculo pero es muy complicada de
modificar y de entender.</p>
<p>La forma más correcta de definir la función sería usando varias
funciones auxiliares. Fíjate que es muy importante también poner los
nombres correctos a cada función, para entender qué hace. Scheme es un
lenguaje débilmente tipado y no tenemos la ayuda de los tipos que nos
dan más contexto de qué es cada parámetro y qué devuelve la función.</p>
<div class="highlight"><pre><span></span><code><span class="c1">; Definición correcta, modular y legible de la función tiempo-impacto</span>

<span class="c1">;</span>
<span class="c1">; La función &#39;cuadrado&#39; devuelve el cuadrado de un número</span>
<span class="c1">;</span>

<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">cuadrado</span><span class="w"> </span><span class="n">x</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">x</span><span class="p">))</span>

<span class="c1">;</span>
<span class="c1">; La función &#39;distancia&#39; devuelve la distancia entre dos</span>
<span class="c1">; coordenadas (x1, y1) y (x2, y2)</span>
<span class="c1">;</span>

<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">distancia</span><span class="w"> </span><span class="n">x1</span><span class="w"> </span><span class="n">y1</span><span class="w"> </span><span class="n">x2</span><span class="w"> </span><span class="n">y2</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="nb">sqrt</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="p">(</span><span class="n">cuadrado</span><span class="w"> </span><span class="p">(</span><span class="nb">-</span><span class="w"> </span><span class="n">x2</span><span class="w"> </span><span class="n">x1</span><span class="p">))</span>
<span class="w">             </span><span class="p">(</span><span class="n">cuadrado</span><span class="w"> </span><span class="p">(</span><span class="nb">-</span><span class="w"> </span><span class="n">y2</span><span class="w"> </span><span class="n">y1</span><span class="p">)))))</span>

<span class="c1">;</span>
<span class="c1">; La función &#39;tiempo&#39; devuelve el tiempo que </span>
<span class="c1">; tarda en recorrer un móvil una distancia d a un velocidad v</span>
<span class="c1">;</span>

<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">tiempo</span><span class="w"> </span><span class="n">distancia</span><span class="w"> </span><span class="n">velocidad</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="nb">/</span><span class="w"> </span><span class="n">distancia</span><span class="w"> </span><span class="n">velocidad</span><span class="p">))</span>

<span class="c1">;</span>
<span class="c1">; La función &#39;tiempo-impacto&#39; devuelve el tiempo que tarda</span>
<span class="c1">; en llegar un torpedo a la velocidad v desde la posición</span>
<span class="c1">; (x1, y1) a la posición (x2, y2)</span>
<span class="c1">;</span>

<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">tiempo-impacto</span><span class="w"> </span><span class="n">x1</span><span class="w"> </span><span class="n">y1</span><span class="w"> </span><span class="n">x2</span><span class="w"> </span><span class="n">y2</span><span class="w"> </span><span class="n">velocidad</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="n">tiempo</span><span class="w"> </span><span class="p">(</span><span class="n">distancia</span><span class="w"> </span><span class="n">x1</span><span class="w"> </span><span class="n">y1</span><span class="w"> </span><span class="n">x2</span><span class="w"> </span><span class="n">y2</span><span class="p">)</span><span class="w"> </span><span class="n">velocidad</span><span class="p">))</span>
</code></pre></div>
<p>En esta segunda versión definimos más funciones, pero cada una es
mucho más legible. Además las funciones como <code>cuadrado</code>, <code>distancia</code> o
<code>tiempo</code> las vamos a poder reutilizar para otros cálculos.</p>
<h4 id="124-funciones-puras">1.2.4. Funciones puras<a class="headerlink" href="#124-funciones-puras" title="Permanent link">&para;</a></h4>
<p>A diferencia de lo que hemos visto en programación imperativa, en
programación funcional no es posible definir funciones con estado
local. Las funciones que se definen son funciones matemáticas puras,
que cumplen las siguientes condiciones:</p>
<ul>
<li>No modifican los parámetros que se les pasa</li>
<li>Devuelven un único resultado</li>
<li>No tienen estado local ni el resultado depende de un estado exterior mutable</li>
</ul>
<p>Esta última propiedad es muy importante y quiere decir que la función
siempre devuelve el mismo valor cuando se le pasan los mismos
parámetros.</p>
<p>Las funciones puras son muy fáciles de entender porque no es necesario
tener en cuenta ningún contexto a la hora de describir su
funcionamiento. El valor devuelto únicamente depende de los parámetros
de entrada.</p>
<p>Por ejemplo, funciones matemáticas como suma, resta, cuadrado, sin,
cos, etc. cumplen esta propiedad.</p>
<h4 id="125-composicion-de-funciones">1.2.5. Composición de funciones<a class="headerlink" href="#125-composicion-de-funciones" title="Permanent link">&para;</a></h4>
<p>Una idea fundamental de la programación funcional es la composición de
funciones que transforman unos datos de entrada en otros de salida. Es
una idea muy actual, porque es la forma en la que están planteados
muchos algoritmos de procesamiento de datos en inteligencia
artificial.</p>
<p>Por ejemplo, podemos representar de la siguiente forma el algoritmo
que maneja un vehículo autónomo:</p>
<p><img src="imagenes/composicion-funciones.png" width="700px"/></p>
<p>Las cajas representa funciones que transforman los datos de entrada
(imágenes tomadas por las cámaras del vehículo) en los datos de salida
(acciones a realizar sobre la dirección y el motor del vehículo). Las
funciones intermedias representan transformaciones que se realizan
sobre los datos de entrada y obtienen los datos de salida.</p>
<p>En un lenguaje de programación funcional como Scheme el diagrama
anterior se escribiría con el siguiente código:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">conduce-vehiculo</span><span class="w"> </span><span class="n">imagenes</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="n">obten-acciones</span><span class="w"> </span>
<span class="w">        </span><span class="p">(</span><span class="n">reconoce</span><span class="w"> </span>
<span class="w">            </span><span class="p">(</span><span class="n">filtra</span><span class="w"> </span>
<span class="w">                </span><span class="p">(</span><span class="n">obten-caracteristicas</span><span class="w"> </span><span class="n">imagenes</span><span class="p">)))))</span>
</code></pre></div>
<p>Veremos más adelante que las expresiones en Scheme se evalúan de
dentro a fuera y que tienen notación prefija. El resultado de cada
función constituye la entrada de la siguiente. </p>
<p>En el caso de la función <code>conduce-vehiculo</code> primero se obtienen las
características de las imágenes, después se filtran, después se
reconoce la escena y, por último, se obtienen las acciones para
conducir el vehículo.</p>
<h3 id="13-programacion-declarativa-vs-imperativa">1.3. Programación declarativa vs. imperativa<a class="headerlink" href="#13-programacion-declarativa-vs-imperativa" title="Permanent link">&para;</a></h3>
<p>Hemos dicho que la programación funcional es un estilo de programación
declarativa, frente a la programación tradicional de los lenguajes
denominados imperativos. Vamos a explicar esto un poco más.</p>
<h4 id="131-programacion-declarativa">1.3.1. Programación declarativa<a class="headerlink" href="#131-programacion-declarativa" title="Permanent link">&para;</a></h4>
<p>Empecemos con lo que conocemos todos: un <strong>programa imperativo</strong>. Se trata
de un conjunto de instrucciones que se ejecutan una tras otra (pasos
de ejecución) de forma secuencial. En la ejecución de estas
instrucciones se van cambiando los valores de las variables y,
dependiendo de estos valores, se modifica el flujo de control de la
ejecución del programa. </p>
<p>Para entender el funcionamiento de un programa imperativo debemos
imaginar toda la evolución del programa, los pasos que se ejecutan y
cuál es el flujo de control en función de los cambios de los valores
en las variables.</p>
<p>En la <strong>programación declarativa</strong>, sin embargo, utilizamos un
paradigma totalmente distinto. Hablamos de <em>programación declarativa</em>
para referirnos a lenguajes de programación (o sentencias de código)
en los que se <em>declaran</em> los valores, objetivos o características de
los elementos del programa y en cuya ejecución no existe mutación
(modificación de valores de variables) ni secuencias de pasos de
ejecución.</p>
<p>De esta forma, la ejecución de un programa declarativo tiene que ver
más con algún modelo formal o matemático que con un programa
tradicional imperativo.  Define un conjunto de reglas y definiciones
<em>de estilo matemático</em>. </p>
<p>La programación declarativa no es exclusiva de los lenguajes
funcionales. Existen muchos lenguajes no funcionales con
características declarativas. Por ejemplo Prolog, en el que un
programa se define como un conjunto de reglas lógicas y su ejecución
realiza una deducción lógica matemática que devuelve un resultado. En
dicha ejecución no son relevantes los pasos internos que realiza el
sistema sino las relaciones lógicas entre los datos y los resultados
finales.</p>
<p>Un ejemplo claro de programación declarativa es una <strong>hoja de
cálculo</strong>. Las celdas contiene valores o expresiones matemáticas que se
actualizan automáticamente cuando cambiamos los valores de entrada. La
relación entre valores y resultados es totalmente matemática y para su
cálculo no tenemos que tener en cuenta pasos de ejecución. Evidente,
por debajo de la hoja de cálculo existe un programa que realiza el
su cálculo de la hoja, pero cuando estamos usándola no nos
preocupa esa implementación. Podemos no preocuparnos de ella y usar
únicamente el modelo matemático definido en la hoja.</p>
<p>Otro ejemplo muy actual de programación declarativa es SwiftUI, el
nuevo API creado por Apple para definir las interfaces de usuario de
las aplicaciones iOS.</p>
<p><img src="imagenes/swiftui.png" width="700px"/></p>
<p>En el código de la imagen vemos una descripción de cómo está definida
la aplicación: una lista de lugares (<em>landmarks</em>) apilada
verticalmente. Para cada lugar se define su imagen, su texto, y
una estrella si el lugar es favorito.</p>
<p>El código es declarativo porque no hay pasos de ejecución para definir
la interfaz. No existe un bucle que va añadiendo elementos a la
interfaz. Vemos una declaración de cómo la interfaz va estar
definida. El compilador del lenguaje y el API son los responsables de
construir esa declaración y mostrar la interfaz tal y como nosotros
queremos.</p>
<h5 id="1311-declaracion-de-funciones">1.3.1.1. Declaración de funciones<a class="headerlink" href="#1311-declaracion-de-funciones" title="Permanent link">&para;</a></h5>
<p>La programación funcional utiliza un estilo de programación
declarativo. Declaramos funciones en las que se transforman unos datos
de entrada en unos datos de salida. Veremos que esta transformación se
realiza mediante la evaluación de expresiones, sin definir valores
intermedios, ni variables auxiliares, ni pasos de
ejecución. Únicamente se van componiendo llamadas a funciones
auxiliares que construyen el valor resultante.</p>
<p>Tal y como ya hemos visto, el siguiente ejemplo es una <strong>declaración</strong>
en Scheme de una función que toma como entrada un número y devuelve su
cuadrado:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">cuadrado</span><span class="w"> </span><span class="n">x</span><span class="p">)</span>
<span class="w">   </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">x</span><span class="p">))</span>
</code></pre></div>
<p>En el cuerpo de la función <code>cuadrado</code> vemos que no se utiliza ninguna
variable auxiliar, sino que únicamente se llama a la función <code>*</code>
(multiplicación) pasando el valor de <code>x</code>. El valor resultante es el
que se devuelve.</p>
<p>Por ejemplo, si llamamos a la función pasándole el parámetro <code>4</code>
devuelve el resultado de multiplicar 4 por si mismo, 16.</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="n">cuadrado</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="w"> </span><span class="c1">; ⇒ 16</span>
</code></pre></div>
<h4 id="132-programacion-imperativa">1.3.2. Programación imperativa<a class="headerlink" href="#132-programacion-imperativa" title="Permanent link">&para;</a></h4>
<p>Repasemos un algunas características propias de la programación
imperativa <strong>que no existen en la programación funcional</strong>. Son
características a las que estamos muy habituados porque son propias de
los lenguajes más populares y con los que hemos aprendido a
programar (C, C++, Java, python, etc.)</p>
<ul>
<li>Pasos de ejecución</li>
<li>Mutación</li>
<li>Efectos laterales</li>
<li>Estado local mutable en las funciones</li>
</ul>
<p>Veremos que, aunque parece imposible, es posible programar sin
utilizar estas características. Lo demuestran lenguajes de
programación funcional como Haskell, Clojure o el propio Scheme.</p>
<h5 id="1321-pasos-de-ejecucion">1.3.2.1. Pasos de ejecución<a class="headerlink" href="#1321-pasos-de-ejecucion" title="Permanent link">&para;</a></h5>
<p>Una de las características básicas de la programación imperativa es
la utilización de pasos de ejecución. Por ejemplo, en C podemos
realizar los siguientes pasos de ejecución:</p>
<div class="highlight"><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cuadrado</span><span class="p">(</span><span class="mi">8</span><span class="p">);</span>
<span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">doble</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
<span class="kt">int</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cuadrado</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
<span class="k">return</span><span class="w"> </span><span class="n">c</span>
</code></pre></div>
<p>O, por ejemplo, si queremos filtrar y procesar una lista de pedidos en Swift
podemos hacerlo en dos sentencias:</p>
<div class="highlight"><pre><span></span><code><span class="n">filtrados</span> <span class="p">=</span> <span class="n">filtra</span><span class="p">(</span><span class="n">pedidos</span><span class="p">);</span>
<span class="n">procesados</span> <span class="p">=</span> <span class="n">procesa</span><span class="p">(</span><span class="n">filtrados</span><span class="p">);</span>
<span class="k">return</span> <span class="n">procesados</span><span class="p">;</span>
</code></pre></div>
<p>Sin embargo, en programación funcional (por ejemplo, Scheme) no
existen pasos de ejecución separados por sentencias. Como hemos visto
antes, la forma típica de expresar las instrucciones anteriores es
componer todas las operaciones en una única instrucción:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="n">cuadrado</span><span class="w"> </span><span class="p">(</span><span class="n">doble</span><span class="w"> </span><span class="p">(</span><span class="n">cuadrado</span><span class="w"> </span><span class="mi">8</span><span class="p">)))</span><span class="w"> </span><span class="c1">; ⇒ 16384</span>
</code></pre></div>
<p>El segundo ejemplo lo podemos componer de la misma forma:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="n">procesa</span><span class="w"> </span><span class="p">(</span><span class="n">filtra</span><span class="w"> </span><span class="n">pedidos</span><span class="p">))</span>
</code></pre></div>
<h5 id="1322-mutacion">1.3.2.2. Mutación<a class="headerlink" href="#1322-mutacion" title="Permanent link">&para;</a></h5>
<p>En los lenguajes imperativos es común modificar el valor de las
variables en los pasos de ejecución:</p>
<div class="highlight"><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span>
<span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
</code></pre></div>
<p>La expresión <code>x = x + 1</code> es una expresión de
<a href="https://en.wikipedia.org/w/index.php?title=Assignment_(computer_science)&amp;redirect=no">asignación</a>
que modifica el valor anterior de una variable por un nuevo valor. El
<em>estado</em> de las variables (su valor) cambia con la ejecución de los
pasos del programa.</p>
<p>A esta asignación que modifica un valor ya existente se le denomina
<em>asignación destructiva</em> o <strong>mutación</strong>.</p>
<p>En programación imperativa también se puede modificar (mutar) el valor
de componentes de estructuras de datos, como posiciones de un array,
de una lista o de un diccionario.</p>
<p>En programación funcional, por contra, <strong>las definiciones son
inmutables</strong>, y una vez asignado un valor a un identificador no se
puede modificar éste. En programación funcional <strong>no existe sentencia
de asignación</strong> que pueda modificar un valor ya definido. Se entienden
las variables como variables matemáticas, no como referencias a una
posiciones de memoria que puede ser modificada.</p>
<p>Por ejemplo, la forma especial <code>define</code> en Scheme crea un nuevo
identificador y le da el valor definido de forma permanente. Si
escribimos el siguiente código en un programa en Scheme:</p>
<div class="highlight"><pre><span></span><code><span class="kn">#lang </span><span class="nn">racket</span>

<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="mi">12</span><span class="p">)</span>
<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="mi">200</span><span class="p">)</span>
</code></pre></div>
<p>tendremos el siguiente error:</p>
<div class="highlight"><pre><span></span><code>module: identifier already defined in: a
</code></pre></div>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>En el intérprete REPL del DrRacket sí que podemos definir más
de una vez la misma función o identificador. Se ha diseñado así para
facilitar el uso del intérprete para la prueba de expresiones en
Scheme.</p>
</div>
<p>En los lenguajes de programación imperativos es habitual introducir
también sentencias declarativas. Por ejemplo, en el siguiente
código Java las líneas 1 y 3 las podríamos considerar declarativas y
las 2 y 4 imperativas:</p>
<div class="highlight"><pre><span></span><code>1. int x = 1;
2. x = x+1;
3. int y = x+1;
4. y = x;
</code></pre></div>
<h5 id="1323-mutacion-y-efectos-laterales">1.3.2.3. Mutación y efectos laterales<a class="headerlink" href="#1323-mutacion-y-efectos-laterales" title="Permanent link">&para;</a></h5>
<p>En programación imperativa es habitual también trabajar con
referencias y hacer que más de un identificador referencie el mismo
valor. Esto produce la posibilidad de que la mutación del valor a
través de uno de los identificadores produzca un <strong>efecto lateral</strong>
(<em>side effect</em> en inglés) en el que el valor de un identificador
cambia sin ejecutar ninguna expresión en la que se utilice
explícitamente el propio identificador.</p>
<p>Por ejemplo, en la mayoría de lenguajes orientados a objetos los
identificadores guardan referencias a objetos. De forma que si
asignamos un objeto a más de un identificador, todos los
identificadores están accediendo al mismo objeto. Si mutamos algún valor
del objeto a través de un identificador provocamos un efecto lateral
en los otros identificadores.</p>
<p>Por ejemplo, lo siguiente es un ejemplo de una mutación en
programación imperativa, en la que se modifican los atributos de un
objeto en Java:</p>
<div class="highlight"><pre><span></span><code><span class="n">Point2D</span><span class="w"> </span><span class="n">p1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Point2D</span><span class="p">(</span><span class="mf">3.0</span><span class="p">,</span><span class="w"> </span><span class="mf">2.0</span><span class="p">);</span><span class="w"> </span><span class="c1">// creamos un punto 2D con coordX=3.0 y coordY=2.0</span>
<span class="n">p1</span><span class="p">.</span><span class="na">getCoordX</span><span class="p">();</span><span class="w"> </span><span class="c1">// la coord x de p2 es 3.0</span>
<span class="n">p1</span><span class="p">.</span><span class="na">setCoordX</span><span class="p">(</span><span class="mf">10.0</span><span class="p">);</span>
<span class="n">p1</span><span class="p">.</span><span class="na">getCoordX</span><span class="p">();</span><span class="w"> </span><span class="c1">// la coord x de p1 es 10.0</span>
</code></pre></div>
<p>Si el objeto está asignado a más de una variable tendremos el <strong>efecto
lateral</strong>
(<em><a href="https://en.wikipedia.org/wiki/Side_effect_(computer_science)">side effect</a></em>)
en el que el dato guardado en una variable cambia después de una
sentencia en la que no se ha usado esa variable:</p>
<div class="highlight"><pre><span></span><code><span class="n">Point2D</span><span class="w"> </span><span class="n">p1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Point2D</span><span class="p">(</span><span class="mf">3.0</span><span class="p">,</span><span class="w"> </span><span class="mf">2.0</span><span class="p">);</span><span class="w"> </span><span class="c1">// la coord x de p1 es 3.0</span>
<span class="n">p1</span><span class="p">.</span><span class="na">getCoordX</span><span class="p">();</span><span class="w"> </span><span class="c1">// la coord x de p1 es 3.0</span>
<span class="n">Point2D</span><span class="w"> </span><span class="n">p2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p1</span><span class="p">;</span>
<span class="n">p2</span><span class="p">.</span><span class="na">setCoordX</span><span class="p">(</span><span class="mf">10.0</span><span class="p">);</span>
<span class="n">p1</span><span class="p">.</span><span class="na">getCoordX</span><span class="p">();</span><span class="w"> </span><span class="c1">// la coord x de p1 es 10.0, sin que ninguna sentencia haya modificado directamente p1</span>
</code></pre></div>
<p>El mismo ejemplo anterior, en C:</p>
<div class="highlight"><pre><span></span><code><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">float</span><span class="w"> </span><span class="n">x</span><span class="p">;</span>
<span class="w">  </span><span class="kt">float</span><span class="w"> </span><span class="n">y</span><span class="p">;</span>
<span class="p">}</span><span class="n">TPunto</span><span class="p">;</span><span class="w"> </span>

<span class="n">TPunto</span><span class="w"> </span><span class="n">p1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mf">3.0</span><span class="p">,</span><span class="w"> </span><span class="mf">2.0</span><span class="p">};</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;Coordenada x: %f&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">p1</span><span class="p">.</span><span class="n">x</span><span class="p">);</span><span class="w">  </span><span class="c1">// 3.0</span>
<span class="n">TPunto</span><span class="w"> </span><span class="o">*</span><span class="n">p2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">p1</span><span class="p">;</span>
<span class="n">p2</span><span class="o">-&gt;</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">10.0</span><span class="p">;</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;Coordenada x: %f&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">p1</span><span class="p">.</span><span class="n">x</span><span class="p">);</span><span class="w">  </span><span class="c1">// 10.0 Efecto lateral</span>
</code></pre></div>
<p>Los efectos laterales son los responsables de muchos <em>bugs</em> y hay que
ser muy consciente de su uso. Son especialmente complicados de depurar
los <em>bugs</em> debidos a efectos laterales en programas concurrentes con
múltiples hilos de ejecución, en los que varios hilos pueden acceder a
las mismas referencias y <a href="https://en.wikipedia.org/wiki/Race_condition">provocar condiciones de carrera</a>.</p>
<p>Por otro lado, también existen situaciones en las que su utilización
permite ganar mucha eficiencia porque podemos definir estructuras de
datos en el que los valores son compartidos por varias referencias y
modificando un único valor se actualizan de forma instantánea esas
referencias.</p>
<p>En los lenguajes en los que no existe la mutación no se producen
efectos laterales, ya que no es posible modificar el valor de una
variable una vez establecido. Los programas que escribamos en estos
lenguajes van a estar libres de este tipo de <em>bugs</em> y van a poder ser
ejecutado sin problemas en hilos de ejecución concurrente.</p>
<p>Por otro lado, la ausencia de mutación hace que sean algo más costosas
ciertas operaciones, como la construcción de estructuras de datos
nuevas a partir de estructuras ya existentes. Veremos, por ejemplo,
que la única forma de añadir un elemento al final de una lista será
construir una lista nueva con todos los elementos de la lista original
y el nuevo elemento. Esta operación tiene un coste lineal con el
número de elementos de la lista. Sin embargo, en una lista en la que
pudiéramos utilizar la mutación podríamos implementar esta operación
con coste constante.</p>
<h5 id="1324-estado-local-mutable">1.3.2.4. Estado local mutable<a class="headerlink" href="#1324-estado-local-mutable" title="Permanent link">&para;</a></h5>
<p>Otra característica de la programación imperativa es lo que se
denomina <strong>estado local mutable</strong> en funciones, procedimientos o
métodos. Se trata la posibilidad de que una invocación a un método o
una función modifique un cierto estado, de forma que la siguiente
invocación devuelva un valor distinto. Es una característica básica de
la programación orientada a objetos, donde los objetos guardan valores
que se modifican con la invocaciones a sus métodos.</p>
<p>Por ejemplo, en Java, podemos definir un contador que incrementa su
valor: </p>
<div class="highlight"><pre><span></span><code><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">Contador</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">c</span><span class="p">;</span>

<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="nf">Contador</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">valorInicial</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">valorInicial</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">valor</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">c</span><span class="o">++</span><span class="p">;</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">c</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>Cada llamada al método <code>valor()</code> devolverá un valor distinto:</p>
<div class="highlight"><pre><span></span><code><span class="n">Contador</span><span class="w"> </span><span class="n">cont</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Contador</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
<span class="n">cont</span><span class="p">.</span><span class="na">valor</span><span class="p">();</span><span class="w"> </span><span class="c1">// 11</span>
<span class="n">cont</span><span class="p">.</span><span class="na">valor</span><span class="p">();</span><span class="w"> </span><span class="c1">// 12</span>
<span class="n">cont</span><span class="p">.</span><span class="na">valor</span><span class="p">();</span><span class="w"> </span><span class="c1">// 13</span>
</code></pre></div>
<p>También se pueden definir funciones con estado local mutable en C:</p>
<div class="highlight"><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="n">function</span><span class="w"> </span><span class="nf">contador</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="w">    </span><span class="n">c</span><span class="o">++</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">c</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>Cada llamada a la función <code>contador()</code> devolverá un valor distinto:</p>
<div class="highlight"><pre><span></span><code><span class="n">contador</span><span class="p">();</span><span class="w"> </span><span class="c1">// 1</span>
<span class="n">contador</span><span class="p">();</span><span class="w"> </span><span class="c1">// 2</span>
<span class="n">contador</span><span class="p">();</span><span class="w"> </span><span class="c1">// 3</span>
</code></pre></div>
<p>Por el contrario, los lenguajes funcionales tienen la propiedad de
<strong>transparencia referencial</strong>: es posible sustituir cualquier
aparición de una expresión por su resultado sin que cambie el
resultado final del programa. Dicho de otra forma, en programación
funcional, <strong>una función siempre devuelve el mismo valor cuando se le
llama con los mismos parámetros</strong>. Las funciones no modifican ningún
estado, no acceden a ninguna variable ni objeto global y modifican su
valor.</p>
<h5 id="1325-resumen">1.3.2.5. Resumen<a class="headerlink" href="#1325-resumen" title="Permanent link">&para;</a></h5>
<p>Un resumen de las características fundamentales de la programación
declarativa frente a la programación imperativa. En los siguientes
apartados explicaremos más estas características.</p>
<p><strong>Características de la programación declarativa</strong></p>
<ul>
<li>Variable = nombre dado a un valor (declaración)</li>
<li>En lugar de pasos de ejecución se utiliza la composición de funciones</li>
<li>No existe asignación ni cambio de estado</li>
<li>No existe mutación, se cumple la <em>transferencia referencial</em>: dentro
  de un mismo ámbito todas las ocurrencias de una variable y las
  llamadas a funciones devuelven el mismo valor</li>
</ul>
<p><strong>Características de la programación imperativa</strong></p>
<ul>
<li>Variable = nombre de una zona de memoria</li>
<li>Asignación</li>
<li>Referencias</li>
<li>Pasos de ejecución</li>
</ul>
<h3 id="14-modelo-de-computacion-de-sustitucion">1.4. Modelo de computación de sustitución<a class="headerlink" href="#14-modelo-de-computacion-de-sustitucion" title="Permanent link">&para;</a></h3>
<p>Un modelo computacional es un formalismo (conjunto de reglas) que
definen el funcionamiento de un programa. En el caso de los lenguajes
funcionales basados en la evaluación de expresiones, el modelo
computacional define cuál será el resultado de evaluar una expresión.</p>
<p>El <strong>modelo de sustitución</strong> es un modelo muy sencillo que permite
definir la semántica de la evaluación de expresiones en lenguajes
funcionales como Scheme. Se basa en una versión simplificada de la
regla de reducción del cálculo lambda.</p>
<p>Es un modelo basado en la reescritura de unos términos por
otros. Aunque se trata de un modelo abstracto, sería posible escribir
un intérprete que, basándose en este modelo, evalúe expresiones
funcionales.</p>
<p>Supongamos un conjunto de definiciones en Scheme:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">doble</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span>
<span class="w">    </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">x</span><span class="p">))</span>

<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">cuadrado</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span>
<span class="w">    </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="n">y</span><span class="p">))</span>

<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="n">z</span><span class="p">)</span><span class="w"> </span>
<span class="w">    </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="p">(</span><span class="n">cuadrado</span><span class="w"> </span><span class="p">(</span><span class="n">doble</span><span class="w"> </span><span class="n">z</span><span class="p">))</span><span class="w"> </span><span class="mi">1</span><span class="p">))</span>

<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span>
</code></pre></div>
<p>Supongamos que, una vez realizadas esas definiciones, se evalúa la
siguiente expresión:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="mi">1</span><span class="p">))</span>
</code></pre></div>
<p>¿Cuál será su resultado? Si lo hacemos de forma intuitiva podemos
pensar que <code>37</code>. Si lo comprobamos en el intérprete de Scheme veremos
que devuelve 37. ¿Hemos seguido algunas reglas específicas? ¿Qué
reglas son las que sigue el intérprete? ¿Podríamos implementar
nosotros un intérprete similar? Sí, usando las reglas del modelo de
sustitución.</p>
<p>El modelo de sustitución define cuatro reglas sencillas para evaluar
una expresión. Llamemos a la expresión <em>e</em>. Las reglas son las
siguientes:</p>
<ol>
<li>Si <em>e</em> es un valor primitivo (por ejemplo, un número), devolvemos ese
   mismo valor.</li>
<li>Si <em>e</em> es un identificador, devolvemos su valor asociado con un
   <code>define</code> (se lanzará un error si no existe ese valor).</li>
<li>Si <em>e</em> es una expresión del tipo <em>(f arg1 ... argn)</em>, donde <em>f</em> es
   el nombre de una función primitiva (<code>+</code>, <code>-</code>, ...), evaluamos uno a
   uno los argumentos <em>arg1</em> ... <em>argn</em> (con estas mismas reglas) y
   evaluamos la función primitiva con los resultados.</li>
</ol>
<p>La regla 4 tiene dos variantes, dependiendo del orden de
evaluación que utilizamos.</p>
<p><strong>Orden aplicativo</strong></p>
<ol start="4">
<li>Si <em>e</em> es una expresión del tipo <em>(f arg1 ... argn)</em>, donde <em>f</em> es
   el nombre de una función definida con un <code>define</code>, tenemos que
   evaluar primero los argumentos <em>arg1</em> ... <em>argn</em> y después
   <strong>sustituir <em>f</em> por su cuerpo</strong>, reemplazando cada parámetro formal
   de la función por el correspondiente <strong>argumento evaluado</strong>. Después
   evaluaremos la expresión resultante usando estas mismas reglas.</li>
</ol>
<p><strong>Orden normal</strong></p>
<ol start="4">
<li>Si <em>e</em> es una expresión del tipo <em>(f arg1 ... argn)</em>, donde <em>f</em> es
   el nombre de una función definida con un <code>define</code>, tenemos que
   <strong>sustituir <em>f</em> por su cuerpo</strong>, reemplazando cada parámetro formal
   de la función por el correspondiente <strong>argumento sin evaluar</strong>. Después
   evaluar la expresión resultante usando estas mismas reglas.</li>
</ol>
<p>En el orden aplicativo se realizan las evaluaciones antes de realizar
las sustituciones, lo que define una evaluación de <em>dentro a fuera</em> de
los paréntesis. Cuando se llega a una expresión primitiva se
evalúa.</p>
<p>En el orden normal se realizan todas las sustituciones hasta que se
tiene una larga expresión formada por expresiones primitivas; se
evalúa entonces.</p>
<p>Ambas formas de evaluación darán el mismo resultado en programación
funcional. Scheme utiliza el orden aplicativo.</p>
<h4 id="141-ejemplo-1">1.4.1. Ejemplo 1<a class="headerlink" href="#141-ejemplo-1" title="Permanent link">&para;</a></h4>
<p>Vamos a empezar con un ejemplo sencillo para comprobar cómo se evalúa
una misma expresión utilizando ambos modelos de
sustitución. Supongamos las siguientes definiciones:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">doble</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span>
<span class="w">    </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">x</span><span class="p">))</span>

<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">cuadrado</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span>
<span class="w">    </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="n">y</span><span class="p">))</span>

<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span>
</code></pre></div>
<p>Queremos evaluar la siguiente expresión:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="n">doble</span><span class="w"> </span><span class="p">(</span><span class="n">cuadrado</span><span class="w"> </span><span class="n">a</span><span class="p">))</span>
</code></pre></div>
<p>La evaluación utilizando el <strong>modelo de sustitución aplicativo</strong>,
usando paso a paso las reglas anteriores, es la siguiente (en cada
línea se indica entre paréntesis la regla usada):</p>
<div class="highlight"><pre><span></span><code>(doble (cuadrado a)) ⇒       ; Sustituimos a por su valor (R2)
(doble (cuadrado 2)) ⇒       ; Sustitumos cuadrado por su cuerpo (R4)
(doble (* 2 2)) ⇒            ; Evaluamos (* 2 2) (R3)
(doble 4) ⇒                  ; Sustituimos doble por su cuerpo (R4)
(+ 4 4) ⇒                    ; Evaluamos (+ 4 4) (R3)
8
</code></pre></div>
<p>Podemos comprobar que en el modelo aplicativo se intercalan las
sustituciones de una función por su cuerpo (regla 4) y las evaluaciones de
expresiones (regla 3). </p>
<p>Por el contrario, la evaluación usando el <strong>modelo de sustitución
normal</strong> es:</p>
<div class="highlight"><pre><span></span><code>(doble (cuadrado a)) ⇒            ; Sustituimos doble por su cuerpo (R4)
(+ (cuadrado a) (cuadrado a) ⇒    ; Sustituimos cuadrado por su cuerpo (R4)
(+ (* a a) (* a a))  ⇒             ; Sustitumos a por su valor (R2)
(+ (* 2 2) (* 2 2))  ⇒             ; Evaluamos (* 2 2) (R3)
(+ 4 (* 2 2))  ⇒                  ; Evaluamos (* 2 2) (R3)
(+ 4 4)  ⇒                        ; Evaluamos (+ 4 4) (R3)
8
</code></pre></div>
<p>Al usar este modelo de evaluación primero se realizan todas las
sustituciones (regla 4) y después todas las evaluaciones (regla
3). </p>
<p>Las sustituciones se hacen de izquierda a derecha (de fuera a dentro
de los paréntesis). Primero se sustituye <code>doble</code> por su cuerpo y
después <code>cuadrado</code>.</p>
<h4 id="142-ejemplo-2">1.4.2. Ejemplo 2<a class="headerlink" href="#142-ejemplo-2" title="Permanent link">&para;</a></h4>
<p>Veamos la evaluación del ejemplo algo más complicado que hemos
planteado al comienzo:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">doble</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span>
<span class="w">    </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">x</span><span class="p">))</span>

<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">cuadrado</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span>
<span class="w">    </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="n">y</span><span class="p">))</span>

<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="n">z</span><span class="p">)</span><span class="w"> </span>
<span class="w">    </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="p">(</span><span class="n">cuadrado</span><span class="w"> </span><span class="p">(</span><span class="n">doble</span><span class="w"> </span><span class="n">z</span><span class="p">))</span><span class="w"> </span><span class="mi">1</span><span class="p">))</span>

<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span>
</code></pre></div>
<p>Expresión a evaluar:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="mi">1</span><span class="p">))</span>
</code></pre></div>
<p>Resultado de la evaluación usando el <strong>modelo de sustitución
aplicativo</strong>:</p>
<div class="highlight"><pre><span></span><code>(f (+ a 1)) ⇒                ; Para evaluar f, evaluamos primero su argumento (+ a 1) (R4)
                             ; y sustituimos a por 2 (R2) 
(f (+ 2 1)) ⇒                ; Evaluamos (+ 2 1) (R3)
(f 3) ⇒                      ; (R4)
(+ (cuadrado (doble 3)) 1) ⇒ ; Sustituimos (doble 3) (R4)
(+ (cuadrado (+ 3 3)) 1) ⇒   ; Evaluamos (+ 3 3) (R3)
(+ (cuadrado 6) 1) ⇒         ; Sustitumos (cuadrado 6) (R4)
(+ (* 6 6) 1) ⇒              ; Evaluamos (* 6 6) (R3)
(+ 36 1) ⇒                   ; Evaluamos (+ 36 1) (R3)
37
</code></pre></div>
<p>Y veamos el resultado de usar el <strong>modelo de sustitución normal</strong>:</p>
<div class="highlight"><pre><span></span><code>(f (+ a 1)) ⇒                      ; Sustituimos (f (+ a 1)) 
                                   ; por su definición, con z = (+ a 1) (R4)
(+ (cuadrado (doble (+ a 1))) 1) ⇒ ; Sustituimos (cuadrado ...) (R4)
(+ (* (doble (+ a 1))
      (doble (+ a 1))) 1)          ; Sustituimos (doble  ...) (R4)
(+ (* (+ (+ a 1) (+ a 1))
      (+ (+ a 1) (+ a 1))) 1) ⇒    ; Evaluamos a (R2)
(+ (* (+ (+ 2 1) (+ 2 1))
      (+ (+ 2 1) (+ 2 1))) 1) ⇒    ; Evaluamos (+ 2 1) (R3)
(+ (* (+ 3 3)
      (+ 3 3)) 1) ⇒                ; Evaluamos (+ 3 3) (R3)
(+ (* 6 6) 1) ⇒                    ; Evaluamos (* 6 6) (R3)
(+ 36 1) ⇒                         ; Evaluamos (+ 36 1) (R3)
37
</code></pre></div>
<p>En programación funcional el resultado de evaluar una expresión es el
mismo independientemente del tipo de orden. Pero si estamos fuera del
paradigma funcional y las funciones tienen estado y cambian de valor
entre distintas invocaciones sí que importan si escogemos un orden.</p>
<p>Por ejemplo, supongamos una función <code>(random x)</code> que devuelve un
entero aleatorio entre 0 y <em>x</em>. Esta función no cumpliría el paradigma
funcional, porque devuelve un valor distinto con el mismo parámetro de
entrada.</p>
<p>Evaluamos las siguientes expresiones con orden aplicativo y normal,
para comprobar que el resultado es distinto.</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">zero</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">-</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">x</span><span class="p">))</span>
<span class="p">(</span><span class="n">zero</span><span class="w"> </span><span class="p">(</span><span class="nb">random</span><span class="w"> </span><span class="mi">10</span><span class="p">))</span>
</code></pre></div>
<p>Si evaluamos la última expresión en orden aplicativo:</p>
<div class="highlight"><pre><span></span><code>(zero (random 10)) ⇒ ; Evaluamos (random 10) (R3)
(zero 3) ⇒           ; Sustituimos (zero ...) (R4)
(- 3 3) ⇒            ; Evaluamos - (R3)
0
</code></pre></div>
<p>Si lo evaluamos en orden normal:</p>
<div class="highlight"><pre><span></span><code>(zero (random 10)) ⇒            ; Sustituimos (zero ...) (R4)
(- (random 10) (random 10)) ⇒   ; Evaluamos (random 10) (R3)
(- 5 3) ⇒                       ; Evaluamos - (R3)
2
</code></pre></div>
<h2 id="2-scheme-como-lenguaje-de-programacion-funcional">2. Scheme como lenguaje de programación funcional<a class="headerlink" href="#2-scheme-como-lenguaje-de-programacion-funcional" title="Permanent link">&para;</a></h2>
<p>Ya hemos visto cómo definir funciones y evaluar expresiones en
Scheme. Vamos continuar con ejemplos concretos de otras
características funcionales características funcionales de Scheme.</p>
<p>En concreto, veremos:</p>
<ul>
<li>Símbolos y primitiva <code>quote</code></li>
<li>Uso de listas</li>
<li>Definición de funciones recursivas en Scheme</li>
</ul>
<h3 id="21-funciones-y-formas-especiales">2.1. Funciones y formas especiales<a class="headerlink" href="#21-funciones-y-formas-especiales" title="Permanent link">&para;</a></h3>
<p>En el seminario de Scheme hemos visto un conjunto de primitivas que
podemos utilizar en Scheme.</p>
<p>Podemos clasificar las primitivas en <strong>funciones</strong> y <strong>formas
especiales</strong>. Las funciones se evalúan usando el modelo de sustitución
aplicativo ya visto:</p>
<ul>
<li>Primero se evalúan los argumentos y después se sustituye la llamada
  a la función por su cuerpo y se vuelve a evaluar la expresión
  resultante.</li>
<li>Las expresiones siempre se evalúan desde los paréntesis interiores a
  los exteriores.</li>
</ul>
<p>Las <em>formas especiales</em> son expresiones primitivas de Scheme que
tienen una forma de evaluarse propia, distinta de las funciones. </p>
<h3 id="22-formas-especiales-en-scheme">2.2. Formas especiales en Scheme<a class="headerlink" href="#22-formas-especiales-en-scheme" title="Permanent link">&para;</a></h3>
<p>Veamos la forma de evaluar las distintas formas especiales en
Scheme. En estas formas especiales no se aplica el modelo de
sustitución, al no ser invocaciones de funciones, sino que cada una se
evalúa de una forma diferente.</p>
<h4 id="221-forma-especial-define">2.2.1. Forma especial <code>define</code><a class="headerlink" href="#221-forma-especial-define" title="Permanent link">&para;</a></h4>
<p><strong>Sintaxis</strong></p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">&lt;identificador&gt;</span><span class="w"> </span><span class="n">&lt;expresión&gt;</span><span class="p">)</span>
</code></pre></div>
<p><strong>Evaluación</strong></p>
<ol>
<li>Evaluar <em>expresión</em></li>
<li>Asociar el valor resultante con el <em>identificador</em></li>
</ol>
<p><strong>Ejemplo</strong></p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">base</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span><span class="w">   </span><span class="c1">; Asociamos a &#39;base&#39; el valor 10</span>
<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">altura</span><span class="w"> </span><span class="mi">12</span><span class="p">)</span><span class="w"> </span><span class="c1">; Asociamos a &#39;altura&#39; el valor 12</span>
<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">area</span><span class="w"> </span><span class="p">(</span><span class="nb">/</span><span class="w"> </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="n">base</span><span class="w"> </span><span class="n">altura</span><span class="p">)</span><span class="w"> </span><span class="mi">2</span><span class="p">))</span><span class="w"> </span><span class="c1">; Asociamos a &#39;area&#39; el valor 60</span>
</code></pre></div>
<h4 id="222-forma-especial-define-para-definir-funciones">2.2.2. Forma especial <code>define</code> para definir funciones<a class="headerlink" href="#222-forma-especial-define-para-definir-funciones" title="Permanent link">&para;</a></h4>
<p><strong>Sintaxis</strong></p>
<div class="highlight"><pre><span></span><code>(define (&lt;nombre-funcion&gt; &lt;argumentos&gt;)
    &lt;cuerpo&gt;)
</code></pre></div>
<p><strong>Evaluación</strong></p>
<p>La semana que viene veremos con más detalle la semántica, y
explicaremos la forma especial <code>lambda</code> que es la que realmente crea
la función. Hoy nos quedamos en la siguiente descripción de alto nivel
de la semántica:</p>
<ol>
<li>Crear la función con el <em>cuerpo</em></li>
<li>Dar a la función el nombre <em>nombre-función</em></li>
</ol>
<p><strong>Ejemplo</strong></p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">factorial</span><span class="w"> </span><span class="n">x</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">        </span><span class="mi">1</span>
<span class="w">        </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="p">(</span><span class="n">factorial</span><span class="w"> </span><span class="p">(</span><span class="nb">-</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="mi">1</span><span class="p">)))))</span>
</code></pre></div>
<h4 id="223-forma-especial-if">2.2.3. Forma especial <code>if</code><a class="headerlink" href="#223-forma-especial-if" title="Permanent link">&para;</a></h4>
<p><strong>Sintaxis</strong></p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="n">&lt;condición&gt;</span><span class="w"> </span><span class="n">&lt;expresión-true&gt;</span><span class="w"> </span><span class="n">&lt;expresión-false&gt;</span><span class="p">)</span>
</code></pre></div>
<p><strong>Evaluación</strong></p>
<ol>
<li>Evaluar <em>condición</em></li>
<li>Si el resultado es <code>#t</code> evaluar la <em>expresión-true</em>, en otro
   caso, evaluar la <em>expresión-false</em></li>
</ol>
<p><strong>Ejemplo</strong></p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">&gt;</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="mi">5</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">substring</span><span class="w"> </span><span class="s2">&quot;Hola qué tal&quot;</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">/</span><span class="w"> </span><span class="mi">12</span><span class="w"> </span><span class="mi">0</span><span class="p">))</span>

<span class="c1">;; Evaluamos (&gt; 10 5). Como el resultado es #t, evaluamos </span>
<span class="c1">;; (substring &quot;Hola qué tal&quot; (+ 1 1) 4), que devuelve &quot;la&quot;</span>
</code></pre></div>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Al ser <code>if</code> una forma especial, no se evalúa utilizando el modelo de
sustitución, sino usando las reglas propias de la forma especial. </p>
<p>Por ejemplo, veamos la siguiente expresión:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">&gt;</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">/</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">0</span><span class="p">))</span><span class="w"> </span><span class="c1">; ⇒ 5</span>
</code></pre></div>
<p>Si se evaluara con el modelo
de sustitución se lanzaría un error de división por 
cero al intentar evaluar <code>(/ 1 0)</code>. Sin embargo, esa expresión no
llega a evaluarse, porque la condición <code>(&gt; 3 0)</code> es cierta y sólo se evalúa
la suma <code>(+ 2 3)</code>.</p>
</div>
<h4 id="224-forma-especial-cond">2.2.4. Forma especial <code>cond</code><a class="headerlink" href="#224-forma-especial-cond" title="Permanent link">&para;</a></h4>
<p><strong>Sintaxis</strong></p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">cond</span><span class="w"> </span>
<span class="w">    </span><span class="p">(</span><span class="n">&lt;exp-cond-1&gt;</span><span class="w"> </span><span class="n">&lt;exp-consec-1&gt;</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="n">&lt;exp-cond-2&gt;</span><span class="w"> </span><span class="n">&lt;exp-consec-2&gt;</span><span class="p">)</span>
<span class="w">    </span><span class="k">...</span>
<span class="w">    </span><span class="p">(</span><span class="k">else</span><span class="w"> </span><span class="n">&lt;exp-consec-else&gt;</span><span class="p">))</span>
</code></pre></div>
<p><strong>Evaluación</strong></p>
<ol>
<li>Se evalúan de forma ordenada todas las <em>exp-cond-i</em> hasta que una de
   ellas devuelva <code>#t</code></li>
<li>Si alguna <em>exp-cond-i</em> devuelve <code>#t</code>, se devuelve el valor de la
   <em>exp-consec-i</em>.</li>
<li>Si ninguna <em>exp-cond-i</em> es cierta, se devuelve el valor resultante de
   evaluar <em>exp-consec-else</em>.</li>
</ol>
<p><strong>Ejemplo</strong></p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">cond</span>
<span class="w">   </span><span class="p">((</span><span class="nb">&gt;</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="w"> </span><span class="s2">&quot;3 es mayor que 4&quot;</span><span class="p">)</span>
<span class="w">   </span><span class="p">((</span><span class="nb">&lt;</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="s2">&quot;2 es menor que 1&quot;</span><span class="p">)</span>
<span class="w">   </span><span class="p">((</span><span class="nb">=</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="s2">&quot;3 es igual que 1&quot;</span><span class="p">)</span>
<span class="w">   </span><span class="p">((</span><span class="nb">&gt;</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">5</span><span class="p">)</span><span class="w"> </span><span class="s2">&quot;3 es mayor que 2&quot;</span><span class="p">)</span>
<span class="w">   </span><span class="p">(</span><span class="k">else</span><span class="w"> </span><span class="s2">&quot;ninguna condición es cierta&quot;</span><span class="p">))</span>

<span class="c1">;; Se evalúan una a una las expresiones (&gt; 3 4),</span>
<span class="c1">;; (&lt; 2 1), (= 3 1) y (&gt; 3 5). Como ninguna de ella</span>
<span class="c1">;; es cierta se devuelve la cadena &quot;ninguna condición es cierta&quot;.</span>
</code></pre></div>
<h4 id="2241-formas-especiales-and-y-or">2.2.4.1. Formas especiales <code>and</code> y <code>or</code><a class="headerlink" href="#2241-formas-especiales-and-y-or" title="Permanent link">&para;</a></h4>
<p>Las expresiones lógicas <code>and</code> y <code>or</code> no son funciones, sino formas
especiales. Lo podemos comprobar con el siguiente ejemplo:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">and</span><span class="w"> </span><span class="no">#f</span><span class="w"> </span><span class="p">(</span><span class="nb">/</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">0</span><span class="p">))</span><span class="w"> </span><span class="c1">; ⇒ #f</span>
<span class="p">(</span><span class="k">or</span><span class="w"> </span><span class="no">#t</span><span class="w"> </span><span class="p">(</span><span class="nb">/</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">0</span><span class="p">))</span><span class="w">  </span><span class="c1">; ⇒ #t</span>
</code></pre></div>
<p>Si <code>and</code> y <code>or</code> fueran funciones, seguirían la regla que hemos visto
de evaluar primero los argumentos y después invocar a la función con
los resultados. Esto produciría un error al evaluar la expresión <code>(/ 3
0)</code>, al ser una división por 0.</p>
<p>Sin embargo, vemos que las expresiones no dan error y devuelven un
valor booleano. ¿Por qué? Porque <code>and</code> y <code>or</code> no son funciones, sino
formas especiales que se evalúan de forma diferente a las funciones.</p>
<p>En concreto, <code>and</code> y <code>or</code> van evaluando los argumentos hasta que
encuentran un valor que hace que ya no sea necesario evaluar el resto.</p>
<p><strong>Sintaxis</strong></p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">and</span><span class="w"> </span><span class="n">exp1</span><span class="w"> </span><span class="k">...</span><span class="w"> </span><span class="n">expn</span><span class="p">)</span>
<span class="p">(</span><span class="k">or</span><span class="w"> </span><span class="n">exp1</span><span class="w"> </span><span class="k">...</span><span class="w"> </span><span class="n">expn</span><span class="p">)</span>
</code></pre></div>
<p><strong>Evaluación <code>and</code></strong></p>
<ul>
<li>Se evalúa la expresión 1. Si el resultado es <code>#f</code>, se devuelve <code>#f</code>, en
otro caso, se evalúa la siguiente expresión.</li>
<li>Se repite hasta la última expresión, cuyo resultado se devuelve.</li>
</ul>
<p><strong>Ejemplos <code>and</code></strong></p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">and</span><span class="w"> </span><span class="no">#f</span><span class="w"> </span><span class="p">(</span><span class="nb">/</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">0</span><span class="p">))</span><span class="w"> </span><span class="c1">; ⇒ #f</span>
<span class="p">(</span><span class="k">and</span><span class="w"> </span><span class="no">#t</span><span class="w"> </span><span class="p">(</span><span class="nb">&gt;</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">&lt;</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="mi">10</span><span class="p">))</span><span class="w"> </span><span class="c1">; ⇒ #t</span>
<span class="p">(</span><span class="k">and</span><span class="w"> </span><span class="no">#t</span><span class="w"> </span><span class="p">(</span><span class="nb">&gt;</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">&lt;</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">))</span><span class="w"> </span><span class="c1">; ⇒ 5</span>
</code></pre></div>
<p>La regla de evaluación de <code>and</code> hace que sea posible que devuelva
resultados no booleanos, como el último ejemplo. Sin embargo, no es
recomendable usarlo de esta forma y en la asignatura no lo vamos a
hacer nunca.</p>
<p><strong>Evaluación <code>or</code></strong></p>
<ul>
<li>Se evalúa la expresión 1. Si el resultado es distinto de <code>#f</code> se
  devuelve ese resultado. Si el resultado es <code>#f</code> se evalúa la
  siguiente expresión.</li>
<li>Se repite hasta la última expresión, cuyo resultado se devuelve.</li>
</ul>
<p><strong>Ejemplos <code>or</code></strong></p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">or</span><span class="w"> </span><span class="no">#t</span><span class="w"> </span><span class="p">(</span><span class="nb">/</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">0</span><span class="p">))</span><span class="w"> </span><span class="c1">; ⇒ #t</span>
<span class="p">(</span><span class="k">or</span><span class="w"> </span><span class="no">#f</span><span class="w"> </span><span class="p">(</span><span class="nb">&lt;</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">&gt;</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="mi">10</span><span class="p">))</span><span class="w"> </span><span class="c1">; ⇒ #t</span>
<span class="p">(</span><span class="k">or</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">&gt;</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="mi">10</span><span class="p">))</span><span class="w"> </span><span class="c1">; ⇒ 5</span>
</code></pre></div>
<p>Al igual que <code>and</code>, la regla de evaluación de <code>or</code> hace que sea
posible que devuelva resultados no booleanos, como el último
ejemplo. Tampoco es recomendable usarlo de esta forma.</p>
<h3 id="23-forma-especial-quote-y-simbolos">2.3. Forma especial <code>quote</code> y símbolos<a class="headerlink" href="#23-forma-especial-quote-y-simbolos" title="Permanent link">&para;</a></h3>
<p><strong>Sintaxis</strong></p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">quote</span><span class="w"> </span><span class="ss">&lt;identificador&gt;</span><span class="p">)</span>
</code></pre></div>
<p><strong>Evaluación</strong></p>
<ul>
<li>Se devuelve el identificador sin evaluar (un símbolo).</li>
<li>Se abrevia en con el carácter <code>'</code>.</li>
</ul>
<p><strong>Ejemplos</strong></p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">quote</span><span class="w"> </span><span class="ss">x</span><span class="p">)</span><span class="w"> </span><span class="c1">; el símbolo x</span>
<span class="o">&#39;</span><span class="ss">hola</span><span class="w"> </span><span class="c1">; el símbolo hola</span>
</code></pre></div>
<p>A diferencia de los lenguajes imperativos, Scheme trata a los
<em>identificadores</em> (nombres que se les da a las variables) como datos
del lenguaje de tipo <strong>symbol</strong>. En el paradigma funcional a los
identificadores se les denomina <em>símbolos</em>.</p>
<p>Los símbolos son distintos de las cadenas. Una cadena es un tipo de
dato <strong>compuesto</strong> y se guardan en memoria todos y cada uno de los
caracteres que la forman. Sin embargo, los símbolos son tipos
atómicos, que se representan en memoria con un único valor determinado
por el <em>código hash</em> del identificador.</p>
<p>Ejemplos de funciones Scheme con símbolos:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="mi">12</span><span class="p">)</span>
<span class="p">(</span><span class="nb">symbol?</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">x</span><span class="p">)</span><span class="w"> </span><span class="c1">; ⇒ #t</span>
<span class="p">(</span><span class="nb">symbol?</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="c1">; ⇒ #f ¿Por qué?</span>
<span class="p">(</span><span class="nb">symbol?</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">hola-que&lt;&gt;</span><span class="p">)</span>
<span class="p">(</span><span class="nb">symbol-&gt;string</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">hola-que&lt;&gt;</span><span class="p">)</span>
<span class="o">&#39;</span><span class="ss">mañana</span>
<span class="o">&#39;</span><span class="ss">lápiz</span><span class="w"> </span><span class="c1">; aunque sea posible, no vamos a usar acentos en los símbolos</span>
<span class="c1">; pero sí en los comentarios</span>
<span class="p">(</span><span class="nb">symbol?</span><span class="w"> </span><span class="s2">&quot;hola&quot;</span><span class="p">)</span><span class="w"> </span><span class="c1">; #f</span>
<span class="p">(</span><span class="nb">symbol?</span><span class="w">  </span><span class="no">#f</span><span class="p">)</span><span class="w"> </span><span class="c1">; #f</span>
<span class="p">(</span><span class="nb">symbol?</span><span class="w"> </span><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="ss">hola</span><span class="w"> </span><span class="ss">cómo</span><span class="w"> </span><span class="ss">estás</span><span class="p">)))</span><span class="w"> </span><span class="c1">; #t</span>
<span class="p">(</span><span class="nb">equal?</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">hola</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">hola</span><span class="p">)</span>
<span class="p">(</span><span class="nb">equal?</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">hola</span><span class="w"> </span><span class="s2">&quot;hola&quot;</span><span class="p">)</span>
</code></pre></div>
<p>Como hemos visto anteriormente, un símbolo puede asociarse o ligarse
(<em>bind</em>) a un valor (cualquier dato <em>de primera clase</em>) con la forma
especial <code>define</code>.</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="mf">2.71828</span><span class="p">)</span>
</code></pre></div>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>No es correcto escribir <code>(define 'e 2.71828)</code> porque la forma especial <code>define</code> debe recibir un identificador <em>sin quote</em>.</p>
</div>
<p>Cuando escribimos un símbolo en el prompt de Scheme el intérprete lo
evalúa y devuelve su valor:</p>
<div class="highlight"><pre><span></span><code>&gt; e 
2.71828
</code></pre></div>
<p>Los nombres de las funciones (<code>equal?</code>, <code>sin</code>, <code>+</code>, ...) son también
símbolos y Scheme también los evalúa (en un par de semanas hablaremos
de las funciones como objetos primitivos en Scheme):</p>
<div class="highlight"><pre><span></span><code>&gt; sin
#&lt;procedure:sin&gt;
&gt; +
#&lt;procedure:+&gt;
&gt; (define (cuadrado x) (* x x)) 
&gt; cuadrado
#&lt;procedure:cuadrado&gt;
</code></pre></div>
<p>Los símbolos son tipos primitivos del lenguaje: pueden pasarse como
parámetros o ligarse a variables.</p>
<div class="highlight"><pre><span></span><code>&gt; (define x &#39;hola)
&gt; x
hola
</code></pre></div>
<h3 id="24-forma-expecial-quote-con-expresiones">2.4. Forma expecial <code>quote</code> con expresiones<a class="headerlink" href="#24-forma-expecial-quote-con-expresiones" title="Permanent link">&para;</a></h3>
<p><strong>Sintaxis</strong></p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">quote</span><span class="w"> </span><span class="ss">&lt;expresión&gt;</span><span class="p">)</span>
</code></pre></div>
<p><strong>Evaluación</strong></p>
<p>Si <code>quote</code> recibe una expresión correcta de Scheme (una expresión
entre paréntesis) se devuelve la lista o pareja definida por la
expresión (sin evaluar sus elementos).</p>
<p><strong>Ejemplos</strong></p>
<div class="highlight"><pre><span></span><code><span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="c1">; ⇒ (1 2 3) Una lista</span>
<span class="o">&#39;</span><span class="p">(</span><span class="ss">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="w"> </span><span class="c1">; La lista formada por el símbolo + y los números 1 2 3 4</span>
<span class="p">(</span><span class="k">quote</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="p">))</span><span class="w"> </span><span class="c1">; La lista formada por los números 1 2 3 4</span>
<span class="o">&#39;</span><span class="p">(</span><span class="ss">a</span><span class="w"> </span><span class="ss">b</span><span class="w"> </span><span class="ss">c</span><span class="p">)</span><span class="w"> </span><span class="c1">; ⇒ La lista con los símbolos a, b, y c</span>
<span class="o">&#39;</span><span class="p">(</span><span class="ss">*</span><span class="w"> </span><span class="p">(</span><span class="ss">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">(</span><span class="ss">+</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">))</span><span class="w"> </span><span class="mi">5</span><span class="p">)</span><span class="w"> </span><span class="c1">; Una lista con 3 elementos, el segundo de ellos otra lista</span>
<span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="c1">; ⇒ La pareja (1 . 2)</span>
<span class="o">&#39;</span><span class="p">((</span><span class="mi">1</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="mi">2</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="mi">3</span><span class="p">))</span><span class="w"> </span><span class="c1">; ⇒ Una lista con las parejas (1 . 2) y (2 . 3)</span>
</code></pre></div>
<h3 id="25-funcion-eval">2.5. Función <code>eval</code><a class="headerlink" href="#25-funcion-eval" title="Permanent link">&para;</a></h3>
<div class="admonition info">
<p class="admonition-title">Curiosidad del lenguaje: <code>eval</code></p>
<p>Racket dispone de la función <code>eval</code>, que permite evaluar expresiones construidas dinámicamente en tiempo de ejecución.</p>
<p><strong>Sintaxis</strong></p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="nb">eval</span><span class="w"> </span><span class="n">&lt;expresión&gt;</span><span class="p">)</span>
</code></pre></div>
<p><strong>Evaluación</strong></p>
<p>La función <code>eval</code> invoca al intérprete para realizar la evaluación de la expresión que se le pasa como parámetro y devuelve el resultado de
dicha evaluación.</p>
<p><strong>Ejemplos</strong></p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span>
<span class="p">(</span><span class="nb">eval</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">a</span><span class="p">)</span><span class="w"> </span><span class="c1">; ⇒ 10</span>

<span class="p">(</span><span class="nb">eval</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="ss">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">))</span><span class="w"> </span><span class="c1">; ⇒ 6</span>

<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">lista</span><span class="w"> </span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">))</span>
<span class="p">(</span><span class="nb">eval</span><span class="w"> </span><span class="n">lista</span><span class="p">)</span><span class="w"> </span><span class="c1">; ⇒ 6</span>
</code></pre></div>
</div>
<!--    
    (define a 10)
    (define x 'a)
    (eval 'x) ; ⇒ a
    (eval x) ; ⇒ 10
    (eval (eval 'x)) ; ⇒ 10
    ```

**Una nota sobre la evaluación de eval**

Al ser `eval` una función, la expresión que se le pasa como parámetro se
evalúa previamente, antes de ser procesada por `eval`. En el caso de
ser una expresión con `quote`, el resultado de la evaluación es la
propia expresión (una lista), que es procesada por `eval`.

Por ejemplo, en la siguiente expresión

<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="nb">eval</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">))</span><span class="w"> </span><span class="c1">; ⇒ 5</span>
</code></pre></div>

primero se evaluaría la expresión `(+ 2 3)` y lo que se le pasaría a
`eval` sería un `5`. El resultado de evaluar un `5` sería un `5`.

Sin embargo, en la siguiente expresión:

<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="nb">eval</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="ss">+</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">))</span>
</code></pre></div>

el resultado de evaluar `'(+ 2 3)` devolvería la lista `(+ 2 3)` que
es la que se pasaría a `eval`. El resultado de evaluar esa expresión
también sería `5`.
-->

<h3 id="26-listas">2.6. Listas<a class="headerlink" href="#26-listas" title="Permanent link">&para;</a></h3>
<p>Otra de las características fundamentales del paradigma funcional es
la utilización de listas. Ya hemos visto en el seminario de Scheme las
funciones más importantes para trabajar con ellas. Vamos a repasarlas
de nuevo en este apartado, antes de ver algún ejemplo de cómo usar la
recursión con listas.</p>
<p>Ya hemos visto en dicho seminario que Scheme es un lenguaje débilmente
tipado. Una variable o parámetro no se declara de un tipo y puede
contener cualquier valor. Sucede igual con las listas: una lista en
Scheme puede contener cualquier valor, incluyendo otras listas.</p>
<h4 id="261-diferencia-entre-la-funcion-list-y-la-forma-especial-quote">2.6.1. Diferencia entre la función <code>list</code> y la forma especial <code>quote</code><a class="headerlink" href="#261-diferencia-entre-la-funcion-list-y-la-forma-especial-quote" title="Permanent link">&para;</a></h4>
<p>En el seminario de Scheme explicamos que podemos crear listas de forma
dinámica, llamando a la función <code>list</code> y pasándole un número variable
de parámetros que son los elementos que se incluirán en la lista:</p>
<p><div class="highlight"><pre><span></span><code><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="mi">5</span><span class="p">)</span><span class="w"> </span><span class="c1">; ⇒ (1 2 3 4)</span>
<span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">a</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">b</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">c</span><span class="p">)</span><span class="w"> </span><span class="c1">; ⇒ (a b c)</span>
<span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">a</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">b</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">c</span><span class="w"> </span><span class="no">#t</span><span class="p">)</span><span class="w"> </span><span class="c1">; ⇒ (1 a 2 b 3 c #t)</span>
<span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="p">)))</span><span class="w"> </span><span class="c1">; ⇒ (1 2 6)</span>
</code></pre></div>
Las expresiones interiores se evalúan y se llama a la función <code>list</code>
con los valores resultantes.</p>
<p>Otro ejemplo:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>
<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span>
<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span>
<span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="c1">; ⇒ (1 2 3)</span>
</code></pre></div>
<p>Como hemos visto cuando hemos hablado de <code>quote</code>, esta forma especial
también puede construir una lista. Pero lo hace sin evaluar sus
elementos.</p>
<p>Por ejemplo:</p>
<div class="highlight"><pre><span></span><code><span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="w"> </span><span class="c1">; ⇒ (1 2 3 4)</span>
<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>
<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span>
<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span>
<span class="o">&#39;</span><span class="p">(</span><span class="ss">a</span><span class="w"> </span><span class="ss">b</span><span class="w"> </span><span class="ss">c</span><span class="p">)</span><span class="w"> </span><span class="c1">; ⇒ (a b c)</span>
<span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="p">(</span><span class="ss">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="ss">*</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="p">(</span><span class="ss">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="p">)))</span><span class="w"> </span><span class="c1">; ⇒ (1 (+ 1 1) (* 2 (+ 1 2)))</span>
</code></pre></div>
<p>La última lista tiene 3 elementos:</p>
<ul>
<li>El número 1</li>
<li>La lista <code>(+ 1 1)</code></li>
<li>La lista <code>(* 2 (+ 1 2))</code></li>
</ul>
<p>Es posible definir una lista vacía (sin elementos) realizando una
llamada sin argumentos a la función <code>list</code> o utilizando el símbolo `():</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="nb">list</span><span class="p">)</span><span class="w"> </span><span class="c1">; ⇒ ()</span>
<span class="o">`</span><span class="p">()</span><span class="w"> </span><span class="c1">; ⇒ ()</span>
</code></pre></div>
<p>La diferencia entre creación de listas con la función <code>list</code> y con la
forma especial <code>quote</code> se puede comprobar en los ejemplos.</p>
<p>La evaluación de la función <code>list</code> funciona como cualquier función,
primero se evalúan los argumentos y después se invoca a la
función con los argumentos evaluados. Por ejemplo, en la
siguiente invocación se obtiene una lista con cuatro elementos
resultantes de las invocaciones de las funciones dentro del
paréntesis:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">(</span><span class="nb">/</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">))</span><span class="w"> </span><span class="c1">; ⇒ (1 2/3 5)</span>
</code></pre></div>
<p>Sin embargo, usamos <code>quote</code> obtenemos una lista con sublistas
con símbolos en sus primeras posiciones:</p>
<div class="highlight"><pre><span></span><code><span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="p">(</span><span class="ss">/</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="ss">+</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">))</span><span class="w"> </span><span class="c1">; ⇒ (1 (/ 2 3) (+ 2 3))</span>
</code></pre></div>
<h4 id="262-seleccion-de-elementos-de-una-lista-first-y-rest">2.6.2. Selección de elementos de una lista: <code>first</code> y <code>rest</code><a class="headerlink" href="#262-seleccion-de-elementos-de-una-lista-first-y-rest" title="Permanent link">&para;</a></h4>
<p>En el seminario vimos también cómo obtener los elementos de una lista.</p>
<ul>
<li>Primer elemento: función <code>first</code></li>
<li>Resto de elementos: función <code>rest</code> (los devuelve en forma de lista)</li>
</ul>
<p>Ejemplos:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">lista1</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="p">))</span>
<span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="n">lista1</span><span class="p">)</span><span class="w"> </span><span class="c1">; ⇒ 1</span>
<span class="p">(</span><span class="nb">rest</span><span class="w"> </span><span class="n">lista1</span><span class="p">)</span><span class="w"> </span><span class="c1">; ⇒ (2 3 4)</span>
<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">lista2</span><span class="w"> </span><span class="o">&#39;</span><span class="p">((</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="p">))</span>
<span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="n">lista2</span><span class="p">)</span><span class="w"> </span><span class="n">⇒</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span>
<span class="p">(</span><span class="nb">rest</span><span class="w"> </span><span class="n">lista2</span><span class="p">)</span><span class="w"> </span><span class="n">⇒</span><span class="w"> </span><span class="p">(</span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span>
</code></pre></div>
<h4 id="263-funciones-cons-y-append">2.6.3. Funciones <code>cons</code> y <code>append</code><a class="headerlink" href="#263-funciones-cons-y-append" title="Permanent link">&para;</a></h4>
<p>Por último, en el seminario vimos también cómo construir nuevas listas a
partir de ya existentes con las funciones <code>cons</code> y <code>append</code>.</p>
<p>La función <code>cons</code> crea una lista nueva resultante de añadir un elemento
al comienzo de la lista. Esta función es la forma habitual de
construir nuevas listas a partir de una lista ya existente y un
nuevo elemento.</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="p">))</span><span class="w"> </span><span class="c1">; ⇒ (1 1 2 3 4)</span>
<span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">hola</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="ss">como</span><span class="w"> </span><span class="ss">estás</span><span class="p">))</span><span class="w"> </span><span class="c1">; ⇒ (hola como estás)</span>
<span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="p">))</span><span class="w">  </span><span class="c1">; ⇒ ((1 2) 1 2 3 4)</span>
</code></pre></div>
<p>La función <code>append</code> se usa para crear una lista nueva resultado de
concatenar dos o más listas</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">list1</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="p">))</span>
<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">list2</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="ss">hola</span><span class="w"> </span><span class="ss">como</span><span class="w"> </span><span class="ss">estás</span><span class="p">))</span>
<span class="p">(</span><span class="nb">append</span><span class="w"> </span><span class="n">list1</span><span class="w"> </span><span class="n">list2</span><span class="p">)</span><span class="w"> </span><span class="c1">; ⇒ (1 2 3 4 hola como estás)</span>
</code></pre></div>
<div class="admonition note">
<p class="admonition-title">Diferencias entre <code>cons</code> y <code>append</code></p>
<p>Es muy importante diferenciar <code>cons</code> y <code>append</code>. En ambos
casos el resultado es una lista y ambas funciones tienen dos parámetros,
siendo el segundo la lista en la que se añade el primero. La diferencia
entre ambas funciones es el tipo del primer parámetro. En <code>cons</code> es un
elemento que se añade a la lista, mientras que en <code>append</code> es otra lista que
se concatena con la segunda.</p>
</div>
<h3 id="27-recursion">2.7. Recursión<a class="headerlink" href="#27-recursion" title="Permanent link">&para;</a></h3>
<p>Otra característica fundamental de la programación funcional es la no
existencia de bucles. Un bucle implica la utilización de pasos de
ejecución en el programa y esto es característico de la programación
imperativa. </p>
<p>En programación funcional las iteraciones se realizan con recursión.</p>
<h4 id="271-funcion-suma-hasta-x">2.7.1. Función <code>(suma-hasta x)</code><a class="headerlink" href="#271-funcion-suma-hasta-x" title="Permanent link">&para;</a></h4>
<p>Por ejemplo, podemos definir la función <code>(suma-hasta x)</code> que devuelve
la suma de los números naturales hasta el parámetro <code>x</code> cuyo valor pasamos en la
invocación de la función.</p>
<p>Por ejemplo, <code>(suma-hasta 5)</code> devolverá <code>0+1+2+3+4+5 = 15</code>.</p>
<p>La definición de la función es la siguiente:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">suma-hasta</span><span class="w"> </span><span class="n">x</span><span class="p">)</span>
<span class="w">   </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="n">x</span><span class="p">)</span>
<span class="w">      </span><span class="mi">0</span>
<span class="w">      </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="p">(</span><span class="n">suma-hasta</span><span class="w"> </span><span class="p">(</span><span class="nb">-</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="mi">1</span><span class="p">))</span><span class="w"> </span><span class="n">x</span><span class="p">)))</span>
</code></pre></div>
<p>En una definición recursiva siempre tenemos un <strong>caso general</strong> y un <strong>caso
base</strong>. El caso base define el valor que devuelve la función en el caso
elemental en el que no hay que hacer ningún cálculo. El caso general
define una expresión que contiene una llamada a la propia función que
estamos definiendo.</p>
<p>El <strong>caso base</strong> es el caso en el que <code>x</code> vale 0. En este caso devolvemos
el propio 0, no hay que realizar ningún cálculo.</p>
<p>El <strong>caso general</strong> es en el que se realiza la llamada recursiva. Esta
llamada devuelve un valor que se utiliza para cálculo final evaluando
la expresión del caso general con valores concretos. </p>
<p>En programación funcional, al no existir efectos laterales, lo único
que importa cuando realizamos una recursión es el valor devuelto por
la llamada recursiva. Ese valor devuelto se combina con el resto de la
expresión del caso general para construir el valor resultante.</p>
<div class="admonition important">
<p class="admonition-title">Importante</p>
<p>Para entender la recursión no es conveniente utilizar el depurador, ni
hacer trazas, ni <em>entrar en la recursión</em>, sino que hay que
suponer que <strong>la llamada recursiva se ejecuta y devuelve el valor
que debería. ¡Debemos confiar en la recursión!</strong>.</p>
</div>
<p>El caso general del ejemplo anterior indica lo siguiente:</p>
<div class="highlight"><pre><span></span><code>Para calcular la suma hasta x: 
    Llamamos a la recursión para que calcule la suma hasta x-1 
    (confiamos en que la implementación funciona bien y esta llamada 
    nos devolverá el resultado hasta x-1) y a ese resultado le sumamos
    el propio número x.
</code></pre></div>
<p>Siempre es aconsejable usar un ejemplo concreto para probar el caso
general. Por ejemplo, el caso general de la suma hasta 5 se calculará
de la siguiente forma:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="p">(</span><span class="n">suma-hasta</span><span class="w"> </span><span class="p">(</span><span class="nb">-</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="mi">1</span><span class="p">))</span><span class="w"> </span><span class="mi">5</span><span class="p">)</span><span class="w"> </span><span class="c1">; ⇒</span>
<span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="p">(</span><span class="n">suma-hasta</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="w"> </span><span class="mi">5</span><span class="p">)</span><span class="w"> </span><span class="c1">;  ⇒ confiamos en la recursión: </span>
<span class="w">                     </span><span class="c1">;    (suma-hasta 4) = 4+3+2+1 = 10  ⇒</span>
<span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="mi">5</span><span class="p">)</span><span class="w"> </span><span class="c1">; ⇒</span>
<span class="mi">15</span>
</code></pre></div>
<p>La evaluación de esta función calculará la llamada recursiva
<code>(suma-hasta 4)</code>. Ahí es donde debemos <strong>confiar en que la recursión
hace bien su trabajo</strong> y que esa llamada devuelve el valor
resultante de 0+1+2+3+4, o sea, 10. Una vez obtenido ese valor hay que
terminar el cálculo sumándole el propio número 5.</p>
<p>Otra característica necesaria del caso general en una definición
recursiva, que también vemos en este ejemplo, es que <strong>la llamada
recursiva debe trabajar sobre un caso más sencillo que la llamada
general</strong>. De esta forma la recursión va descomponiendo el problema
hasta llegar al caso base y construye la solución a partir de ahí.</p>
<p>En nuestro caso, la llamada recursiva para calcular la suma hasta 5 se
hace calculando la suma hasta 4 (un caso más sencillo).</p>
<h4 id="272-diseno-de-la-funcion-suma-hasta-x">2.7.2. Diseño de la función <code>(suma-hasta x)</code><a class="headerlink" href="#272-diseno-de-la-funcion-suma-hasta-x" title="Permanent link">&para;</a></h4>
<p>¿Cómo hemos diseñado esta función? ¿Cómo hemos llegado a la solución?</p>
<p>Debemos empezar teniendo claro qué es lo que queremos calcular. Lo
mejor es utilizar un ejemplo. </p>
<p>Por ejemplo, <code>(suma-hasta 5)</code> devolverá <code>0+1+2+3+4+5 = 15</code>. </p>
<p>Una vez que tenemos esta expresión de un ejemplo concreto debemos
diseñar el caso general de la recursión. Para ello tenemos que
encontrar una expresión para el cálculo de <code>(suma-hasta 5)</code> que
<strong>use una llamada recursiva</strong> a un problema más pequeño.</p>
<p>O, lo que es lo mismo, ¿podemos obtener el resultado 15 con lo que nos
devuelve una llamada recursiva que obtenga la suma hasta un número más
pequeño y haciendo algo más?</p>
<p>Pues sí: para calcular la suma hasta 5, esto es, para obtener 15,
podemos llamar a la recursión para calcular la suma hasta 4 (devuelve
10) y a este resultado sumarle el propio 5.</p>
<p>Lo podemos expresar con el siguiente dibujo:</p>
<p><img src="imagenes/suma-hasta.png" width="600px"/></p>
<p>Generalizamos este ejemplo y lo expresamos en Scheme de la siguiente
forma:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">suma-hasta</span><span class="w"> </span><span class="n">x</span><span class="p">)</span>
<span class="w">   </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="p">(</span><span class="n">suma-hasta</span><span class="w"> </span><span class="p">(</span><span class="nb">-</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="mi">1</span><span class="p">))</span><span class="w"> </span><span class="n">x</span><span class="p">))</span>
</code></pre></div>
<p>Nos falta el caso base de la recursión. Debemos preguntarnos <strong>¿cuál
es el caso más sencillo del problema, que podemos calcular sin hacer
ninguna llamada recursiva?</strong>. En este caso podría ser el caso en el
que <code>x</code> es 0, en el que devolveríamos 0.</p>
<p>Podemos ya escribirlo todo en Scheme:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">suma-hasta</span><span class="w"> </span><span class="n">x</span><span class="p">)</span>
<span class="w">   </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="n">x</span><span class="p">)</span>
<span class="w">      </span><span class="mi">0</span>
<span class="w">      </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="p">(</span><span class="n">suma-hasta</span><span class="w"> </span><span class="p">(</span><span class="nb">-</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="mi">1</span><span class="p">))</span><span class="w"> </span><span class="n">x</span><span class="p">)))</span>
</code></pre></div>
<p>Una aclaración sobre el caso general. En la implementación anterior la
llamada recursiva a <code>suma-hasta</code> se realiza en el primer argumento de
la suma:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="p">(</span><span class="n">suma-hasta</span><span class="w"> </span><span class="p">(</span><span class="nb">-</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="mi">1</span><span class="p">))</span><span class="w"> </span><span class="n">x</span><span class="p">)</span>
</code></pre></div>
<p>La expresión anterior es totalmente equivalente a la siguiente
en la que la llamada recursiva aparece como segundo argumento</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="p">(</span><span class="n">suma-hasta</span><span class="w"> </span><span class="p">(</span><span class="nb">-</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="mi">1</span><span class="p">)))</span>
</code></pre></div>
<p>Ambas expresiones son equivalentes porque en programación funcional no
importa el orden en el que se evalúan los argumentos. Da lo mismo
evaluarlos de derecha a izquierda que de izquierda a derecha. La
transparencia referencial garantiza que el resultado es el mismo.</p>
<h4 id="273-funcion-alfabeto-hasta-char">2.7.3. Función <code>(alfabeto-hasta char)</code><a class="headerlink" href="#273-funcion-alfabeto-hasta-char" title="Permanent link">&para;</a></h4>
<p>Vamos con otro ejemplo. Queremos diseñar una función <code>(alfabeto-hasta
char)</code> que devuelva una cadena que empieza en la letra <code>a</code> y termina
en el carácter que le pasamos como parámetro.</p>
<p>Por ejemplo:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="n">alfabeto-hasta</span><span class="w"> </span><span class="sc">#\h</span><span class="p">)</span><span class="w"> </span><span class="c1">; ⇒ &quot;abcdefgh&quot;</span>
<span class="p">(</span><span class="n">alfabeto-hasta</span><span class="w"> </span><span class="sc">#\z</span><span class="p">)</span><span class="w"> </span><span class="c1">; ⇒ &quot;abcdefghijklmnopqrstuvwxyz&quot;</span>
</code></pre></div>
<p>Pensamos en el caso general: ¿cómo podríamos invocar a la propia
función <code>alfabeto-hasta</code> para que (confiando en la recursión) nos haga
gran parte del trabajo (construya casi toda la cadena con el
alfabeto)?</p>
<p>Podríamos hacer que la llamada recursiva devolviera el alfabeto hasta
el carácter previo al que nos pasan como parámetro y después nosotros
añadir ese carácter a la cadena que devuelve la recursión.</p>
<p>Veamos un ejemplo concreto:</p>
<div class="highlight"><pre><span></span><code>(alfabeto-hasta #\h) = (alfabeto-hasta #\g) + \#h
</code></pre></div>
<p>La llamada recursiva <code>(alfabeto-hasta #\g)</code> devolvería la cadena
<code>"abcdefg"</code> (confiando en la recursión) y sólo faltaría añadir la
última letra.</p>
<p>Para implementar esta idea en Scheme lo único que necesitamos es usar
la función <code>string-append</code> para concatenar cadenas y una función
auxiliar <code>(anterior char)</code> que devuelve el carácter anterior a uno
dado.</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">anterior</span><span class="w"> </span><span class="n">char</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nb">integer-&gt;char</span><span class="w"> </span><span class="p">(</span><span class="nb">-</span><span class="w"> </span><span class="p">(</span><span class="nb">char-&gt;integer</span><span class="w"> </span><span class="n">char</span><span class="p">)</span><span class="w"> </span><span class="mi">1</span><span class="p">)))</span>
</code></pre></div>
<p>El caso general quedaría como sigue:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">alfabeto-hasta</span><span class="w"> </span><span class="n">char</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="nb">string-append</span><span class="w"> </span><span class="p">(</span><span class="n">alfabeto-hasta</span><span class="w"> </span><span class="p">(</span><span class="n">anterior</span><span class="w"> </span><span class="n">char</span><span class="p">))</span><span class="w"> </span><span class="p">(</span><span class="nb">string</span><span class="w"> </span><span class="n">char</span><span class="p">)))</span>
</code></pre></div>
<p>Faltaría el caso base. ¿Cuál es el caso más sencillo posible que nos
pueden pedir? El caso del alfabeto hasta la <code>#\a</code>. En ese caso basta
con devolver la cadena <code>"a"</code>.</p>
<p>La función completa quedaría así:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">alfabeto-hasta</span><span class="w"> </span><span class="n">char</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">equal?</span><span class="w"> </span><span class="n">char</span><span class="w"> </span><span class="sc">#\a</span><span class="p">)</span>
<span class="w">      </span><span class="s2">&quot;a&quot;</span>
<span class="w">      </span><span class="p">(</span><span class="nb">string-append</span><span class="w"> </span><span class="p">(</span><span class="n">alfabeto-hasta</span><span class="w"> </span><span class="p">(</span><span class="n">anterior</span><span class="w"> </span><span class="n">char</span><span class="p">))</span><span class="w"> </span><span class="p">(</span><span class="nb">string</span><span class="w"> </span><span class="n">char</span><span class="p">))))</span>
</code></pre></div>
<h3 id="28-recursion-y-listas">2.8. Recursión y listas<a class="headerlink" href="#28-recursion-y-listas" title="Permanent link">&para;</a></h3>
<p>La utilización de la recursión es muy útil para trabajar con
estructuras secuenciales, como listas. Vamos a empezar viendo unos
sencillos ejemplos y más adelante veremos algunos más complicadas.</p>
<h4 id="281-funcion-recursiva-suma-lista">2.8.1. Función recursiva <code>suma-lista</code><a class="headerlink" href="#281-funcion-recursiva-suma-lista" title="Permanent link">&para;</a></h4>
<p>Veamos un primer ejemplo, la función <code>(suma-lista
lista-nums)</code> que recibe como parámetro una lista de números y devuelve
la suma de todos ellos.</p>
<p>Siempre debemos empezar escribiendo un ejemplo de la función, para
entenderla bien:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="n">suma-lista</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">12</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">8</span><span class="p">))</span><span class="w"> </span><span class="c1">; ⇒ 29</span>
</code></pre></div>
<p>Para diseñar una implementación recursiva de la función tenemos que
pensar en cómo descomponer el ejemplo en una llamada recursiva a un
problema más pequeño y en cómo tratar el valor devuelto por la
recursión para obtener el valor esperado.</p>
<p>Por ejemplo, en este caso podemos pensar que para sumar la lista de
números <code>(12 3 5 1 8)</code> podemos obtener un problema más sencillo (una
lista más pequeña) haciendo el <code>rest</code> de la lista de números y llamando
a la recursión con el resultado. La llamada recursiva devolverá la
suma de esos números (confiamos en la recursión) y a ese valor basta
con sumarle el primer número de la lista. Lo podemos representar en el
siguiente dibujo:</p>
<p><img src="imagenes/suma-lista.png" width="600px"/></p>
<p>Podemos generalizar este ejemplo y expresarlo en Scheme de la siguiente forma:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">suma-lista</span><span class="w"> </span><span class="n">lista</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="n">lista</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">suma-lista</span><span class="w"> </span><span class="p">(</span><span class="nb">rest</span><span class="w"> </span><span class="n">lista</span><span class="p">))))</span>
</code></pre></div>
<p>Falta el caso base. ¿Cuál es la lista más sencilla con la que podemos
calcular la suma de sus elementos sin llamar a la recursión?. La lista más sencilla es una lista sin elementos, y devolvemos 0. </p>
<p>Con todo junto, la recursión quedaría como sigue:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">suma-lista</span><span class="w"> </span><span class="n">lista</span><span class="p">)</span>
<span class="w">   </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">null?</span><span class="w"> </span><span class="n">lista</span><span class="p">)</span>
<span class="w">       </span><span class="mi">0</span>
<span class="w">       </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="n">lista</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">suma-lista</span><span class="w"> </span><span class="p">(</span><span class="nb">rest</span><span class="w"> </span><span class="n">lista</span><span class="p">)))))</span>
</code></pre></div>
<h4 id="282-funcion-recursiva-longitud">2.8.2. Función recursiva <code>longitud</code><a class="headerlink" href="#282-funcion-recursiva-longitud" title="Permanent link">&para;</a></h4>
<p>Veamos cómo definir la función recursiva que devuelve la longitud de
una lista, el número de elementos que contiene.</p>
<p>Comencemos como siempre con un ejemplo:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="n">longitud</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="ss">a</span><span class="w"> </span><span class="ss">b</span><span class="w"> </span><span class="ss">c</span><span class="w"> </span><span class="ss">d</span><span class="w"> </span><span class="ss">e</span><span class="p">))</span><span class="w"> </span><span class="c1">; ⇒ 5</span>
</code></pre></div>
<p>Suponiendo que la función <code>longitud</code> funciona correctamente, ¿cómo
podríamos formular el caso general de la recursión? ¿cómo podríamos
llamar a la recursión con un problema más pequeño y cómo podemos
aprovechar el resultado de esta llamada para obtener el resultado
final?</p>
<p>En este caso es bastante sencillo. Si a la lista le quitamos un
elemento, cuando llamemos a la recursión nos va a devolver la longitud
original menos uno. En este caso:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="n">longitud</span><span class="w"> </span><span class="p">(</span><span class="nb">rest</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="ss">a</span><span class="w"> </span><span class="ss">b</span><span class="w"> </span><span class="ss">c</span><span class="w"> </span><span class="ss">d</span><span class="w"> </span><span class="ss">e</span><span class="p">)))</span><span class="w"> </span><span class="c1">; ⇒</span>
<span class="p">(</span><span class="n">longitud</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="ss">b</span><span class="w"> </span><span class="ss">c</span><span class="w"> </span><span class="ss">d</span><span class="w"> </span><span class="ss">e</span><span class="w"> </span><span class="p">))</span><span class="w"> </span><span class="n">⇒</span><span class="w"> </span><span class="p">(</span><span class="n">confiamos</span><span class="w"> </span><span class="n">en</span><span class="w"> </span><span class="n">la</span><span class="w"> </span><span class="n">recursión</span><span class="p">)</span><span class="w"> </span><span class="mi">4</span>
</code></pre></div>
<p>De esta forma, para conseguir la longitud de la lista inicial, sólo
habría que sumarle 1 a lo que nos devuelve la llamada
recursiva. </p>
<p>Si expresamos en Scheme este caso general:</p>
<div class="highlight"><pre><span></span><code><span class="c1">; Sólo se define el caso general, falta el caso base</span>
<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">longitud</span><span class="w"> </span><span class="n">lista</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="p">(</span><span class="n">longitud</span><span class="w"> </span><span class="p">(</span><span class="nb">rest</span><span class="w"> </span><span class="n">lista</span><span class="p">))</span><span class="w"> </span><span class="mi">1</span><span class="p">))</span>
</code></pre></div>
<p>Para definir el caso base debemos preguntarnos cuál es el caso más
simple que le podemos pasar a la función. Si en cada llamada recursiva
vamos reduciendo la longitud de la lista, el caso base recibirá la
lista vacía. ¿Cuál es la longitud de una lista vacía? Una lista vacía
no tiene elementos, por lo que es 0. </p>
<p>De esta forma completamos la definición de la función:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">longitud</span><span class="w"> </span><span class="n">lista</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">null?</span><span class="w"> </span><span class="n">lista</span><span class="p">)</span>
<span class="w">        </span><span class="mi">0</span>
<span class="w">        </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="p">(</span><span class="n">longitud</span><span class="w"> </span><span class="p">(</span><span class="nb">rest</span><span class="w"> </span><span class="n">lista</span><span class="p">))</span><span class="w"> </span><span class="mi">1</span><span class="p">)))</span>
</code></pre></div>
<p>En Scheme existe la función <code>length</code> que hace lo mismo. Devuelve la
longitud de una lista:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="nb">length</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="ss">a</span><span class="w"> </span><span class="ss">b</span><span class="w"> </span><span class="ss">c</span><span class="w"> </span><span class="ss">d</span><span class="w"> </span><span class="ss">e</span><span class="p">))</span><span class="w"> </span><span class="c1">; ⇒ 5</span>
</code></pre></div>
<h4 id="283-como-comprobar-si-una-lista-tiene-un-unico-elemento">2.8.3. Cómo comprobar si una lista tiene un único elemento<a class="headerlink" href="#283-como-comprobar-si-una-lista-tiene-un-unico-elemento" title="Permanent link">&para;</a></h4>
<p>En el caso base de algunas funciones recursivas es necesario comprobar
que la lista que se pasa como parámetro tiene un único elemento. Al estar
definida la función <code>length</code> en Scheme la primera idea que se 
nos puede ocurrir es comprobar si la longitud de la lista es 1. Sin
embargo es una mala idea.</p>
<div class="highlight"><pre><span></span><code><span class="c1">; Ejemplo de función recursiva con un caso </span>
<span class="c1">; base en el que se comprueba si la lista tienen</span>
<span class="c1">; un único elemento</span>
<span class="c1">; ¡¡MALA IDEA, NO HACERLO ASÍ!!</span>
<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">foo</span><span class="w"> </span><span class="n">lista</span><span class="p">)</span>
<span class="w">   </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="p">(</span><span class="nb">length</span><span class="w"> </span><span class="n">lista</span><span class="p">)</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>
<span class="w">       </span><span class="c1">; devuelve caso base</span>
<span class="w">       </span><span class="c1">; caso general</span>
<span class="w">       </span><span class="p">))</span>
</code></pre></div>
<p>El problema de la implementación anterior es que el coste de la
función <code>length</code> es lineal. Tal y como hemos visto en el apartado
anterior, para calcular la longitud de la lista es necesario recorrer
todos sus elementos. Además, la función recursiva hace esa
comprobación en cada llamada recursiva. El coste resultante de la
función <code>foo</code>, por tanto, es cuadrático.</p>
<p>¿Cómo mejorar el coste? Hay que tener en cuenta que la comprobación
anterior está haciendo cosas de más. Realmente no queremos saber la
longitud de la lista sino únicamente si esa longitud es mayor que
uno. Esta comprobación sí que puede hacerse en tiempo
constante. Lo único que debemos hacer es comprobar si el <code>rest</code> de la
lista es la lista vacía. Si lo es, ya sabemos que la lista original
tenía un único elemento.</p>
<p>Por tanto, la versión correcto del código anterior sería la siguiente:</p>
<div class="highlight"><pre><span></span><code><span class="c1">; Versión correcta para comprobar si una lista tiene</span>
<span class="c1">; un único elemento</span>
<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">foo</span><span class="w"> </span><span class="n">lista</span><span class="p">)</span>
<span class="w">   </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">null?</span><span class="w"> </span><span class="p">(</span><span class="nb">rest</span><span class="w"> </span><span class="n">lista</span><span class="p">))</span>
<span class="w">       </span><span class="c1">; devuelve caso base</span>
<span class="w">       </span><span class="c1">; caso general</span>
<span class="w">       </span><span class="p">))</span>
</code></pre></div>
<p>El coste de la comprobación <code>(null? (rest lista))</code> es constante. No
depende de la longitud de la lista.</p>
<h4 id="284-funcion-recursiva-veces">2.8.4. Función recursiva <code>veces</code><a class="headerlink" href="#284-funcion-recursiva-veces" title="Permanent link">&para;</a></h4>
<p>Como último ejemplo vamos a definir la función </p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="n">veces</span><span class="w"> </span><span class="n">lista</span><span class="w"> </span><span class="n">id</span><span class="p">)</span>
</code></pre></div>
<p>que cuenta el número de veces que aparece un identificador en una
lista.</p>
<p>Por ejemplo,</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="n">veces</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="ss">a</span><span class="w"> </span><span class="ss">b</span><span class="w"> </span><span class="ss">c</span><span class="w"> </span><span class="ss">a</span><span class="w"> </span><span class="ss">d</span><span class="w"> </span><span class="ss">a</span><span class="p">)</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">a</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="c1">; ⇒ 3</span>
</code></pre></div>
<p>¿Cómo planteamos el caso general? Llamaremos a la recursión con el
resto de la lista. Esta llamada nos devolverá el número de veces que
aparece el identificador en este resto de la lista. Y sumaremos
al valor devuelto 1 si el primer elemento de la lista coincide con el
identificador.</p>
<p>En Scheme hay que definir este caso general en una única expresión:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">equal?</span><span class="w"> </span><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="n">lista</span><span class="p">)</span><span class="w"> </span><span class="n">id</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">(</span><span class="n">veces</span><span class="w"> </span><span class="p">(</span><span class="nb">rest</span><span class="w"> </span><span class="n">lista</span><span class="p">)</span><span class="w"> </span><span class="n">id</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="n">veces</span><span class="w"> </span><span class="p">(</span><span class="nb">rest</span><span class="w"> </span><span class="n">lista</span><span class="p">)</span><span class="w"> </span><span class="n">id</span><span class="p">))</span>
</code></pre></div>
<p>Como caso base, si la lista es vacía devolvemos 0.</p>
<p>La versión completa:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">veces</span><span class="w"> </span><span class="n">lista</span><span class="w"> </span><span class="n">id</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="k">cond</span>
<span class="w">    </span><span class="p">((</span><span class="nb">null?</span><span class="w"> </span><span class="n">lista</span><span class="p">)</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">    </span><span class="p">((</span><span class="nb">equal?</span><span class="w"> </span><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="n">lista</span><span class="p">)</span><span class="w"> </span><span class="n">id</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">(</span><span class="n">veces</span><span class="w"> </span><span class="p">(</span><span class="nb">rest</span><span class="w"> </span><span class="n">lista</span><span class="p">)</span><span class="w"> </span><span class="n">id</span><span class="p">)))</span>
<span class="w">    </span><span class="p">(</span><span class="k">else</span><span class="w"> </span><span class="p">(</span><span class="n">veces</span><span class="w"> </span><span class="p">(</span><span class="nb">rest</span><span class="w"> </span><span class="n">lista</span><span class="p">)</span><span class="w"> </span><span class="n">id</span><span class="p">))))</span>

<span class="p">(</span><span class="n">veces</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="ss">a</span><span class="w"> </span><span class="ss">b</span><span class="w"> </span><span class="ss">a</span><span class="w"> </span><span class="ss">a</span><span class="w"> </span><span class="ss">b</span><span class="w"> </span><span class="ss">b</span><span class="p">)</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">a</span><span class="p">)</span><span class="w"> </span><span class="c1">; ⇒ 3 </span>
</code></pre></div>
<h2 id="3-tipos-de-datos-compuestos-en-scheme">3. Tipos de datos compuestos en Scheme<a class="headerlink" href="#3-tipos-de-datos-compuestos-en-scheme" title="Permanent link">&para;</a></h2>
<h3 id="31-el-tipo-de-dato-pareja">3.1. El tipo de dato pareja<a class="headerlink" href="#31-el-tipo-de-dato-pareja" title="Permanent link">&para;</a></h3>
<h4 id="311-funcion-de-construccion-de-parejas-cons">3.1.1. Función de construcción de parejas <code>cons</code><a class="headerlink" href="#311-funcion-de-construccion-de-parejas-cons" title="Permanent link">&para;</a></h4>
<p>Ya hemos visto en el seminario de Scheme que el tipo de dato compuesto
más simple es la pareja: una entidad formada por dos elementos. Se
utiliza la función <code>cons</code> para construirla:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="c1">; ⇒ (1 . 2)</span>
<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="p">))</span>
</code></pre></div>
<p>Dibujamos la pareja anterior y la variable <code>c</code> que la referencia de la
siguiente forma:</p>
<p><img src="imagenes/pareja.png" width="200px"/></p>
<p><em>Tipo compuesto pareja</em></p>
<p>La instrucción <code>cons</code> construye un dato compuesto a partir de otros
dos datos (que llamaremos izquierdo y derecho). La expresión <code>(1 . 2)</code>
es la forma que el intérprete tiene de imprimir las parejas.</p>
<h4 id="312-construccion-de-parejas-con-quote">3.1.2. Construcción de parejas con <code>quote</code><a class="headerlink" href="#312-construccion-de-parejas-con-quote" title="Permanent link">&para;</a></h4>
<p>Al igual que las listas, es posible construir parejas con la forma
especial <code>quote</code>, definiendo la pareja entre paréntesis y separando su
parte izquierda y derecha con un punto:</p>
<div class="highlight"><pre><span></span><code><span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="c1">; ⇒ (1 . 2)</span>
</code></pre></div>
<p>Utilizaremos a veces <code>cons</code> y otras veces <code>quote</code> para definir
parejas. Pero hay que tener en cuenta que, al igual que con las
listas, <code>quote</code> no evalúa sus parámetros, por lo que no lo deberemos
utilizar por ejemplo dentro de una función en la que queremos
construir una pareja con los resultados de evaluar expresiones.</p>
<p>Por ejemplo:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>
<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span>
<span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="c1">; ⇒ (1 . 2)</span>
<span class="o">&#39;</span><span class="p">(</span><span class="ss">a</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="ss">b</span><span class="p">)</span><span class="w"> </span><span class="c1">; ⇒ (a . b)</span>
</code></pre></div>
<h4 id="313-funciones-de-acceso-car-y-cdr">3.1.3. Funciones de acceso <code>car</code> y <code>cdr</code><a class="headerlink" href="#313-funciones-de-acceso-car-y-cdr" title="Permanent link">&para;</a></h4>
<p>Una vez construida una pareja, podemos obtener el elemento
correspondiente a su parte izquierda con la función <code>car</code> y su parte
derecha con la función <code>cdr</code>:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="p">))</span>
<span class="p">(</span><span class="nb">car</span><span class="w"> </span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="c1">; ⇒ 1</span>
<span class="p">(</span><span class="nb">cdr</span><span class="w"> </span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="c1">; ⇒ 2</span>
</code></pre></div>
<h5 id="3131-definicion-declarativa">3.1.3.1. Definición declarativa<a class="headerlink" href="#3131-definicion-declarativa" title="Permanent link">&para;</a></h5>
<p>Las funciones <code>cons</code>, <code>car</code> y <code>cdr</code> quedan perfectamente definidas con
las siguientes ecuaciones algebraicas:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="nb">car</span><span class="w"> </span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="p">))</span><span class="w"> </span><span class="nb">=</span><span class="w"> </span><span class="n">x</span>
<span class="p">(</span><span class="nb">cdr</span><span class="w"> </span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="p">))</span><span class="w"> </span><span class="nb">=</span><span class="w"> </span><span class="n">y</span>
</code></pre></div>
<div class="admonition note">
<p class="admonition-title">¿De dónde vienen los nombres <code>car</code> y <code>cdr</code>?</p>
<p>Inicialmente los nombres eran CAR y CDR (en mayúsculas). La
historia se remonta al año 1959, en los orígenes del Lisp y tiene
que ver con el nombre que se les daba a ciertos registros de la
memoria del IBM 709.</p>
<p>Podemos leer la explicación completa en
<a href="http://www.iwriteiam.nl/HaCAR_CDR.html">The origin of CAR and CDR in LISP</a>.</p>
</div>
<h4 id="314-funcion-pair">3.1.4. Función pair?<a class="headerlink" href="#314-funcion-pair" title="Permanent link">&para;</a></h4>
<p>La función <code>pair?</code> nos dice si un objeto es atómico o es una pareja:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="nb">pair?</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="c1">; ⇒ #f</span>
<span class="p">(</span><span class="nb">pair?</span><span class="w"> </span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="p">))</span><span class="w"> </span><span class="c1">; ⇒ #t</span>
</code></pre></div>
<h4 id="315-las-parejas-pueden-contener-cualquier-tipo-de-dato">3.1.5. Las parejas pueden contener cualquier tipo de dato<a class="headerlink" href="#315-las-parejas-pueden-contener-cualquier-tipo-de-dato" title="Permanent link">&para;</a></h4>
<p>Ya hemos comprobado que Scheme es un lenguaje <em>débilmente
tipado</em>. Las funciones pueden devolver y recibir distintos tipos de
datos.</p>
<p>Por ejemplo, podríamos definir la siguiente función <code>suma</code> que sume
tanto números como cadenas:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">suma</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="k">cond</span><span class="w"> </span>
<span class="w">    </span><span class="p">((</span><span class="k">and</span><span class="w"> </span><span class="p">(</span><span class="nb">number?</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">number?</span><span class="w"> </span><span class="n">y</span><span class="p">))</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="p">))</span>
<span class="w">    </span><span class="p">((</span><span class="k">and</span><span class="w"> </span><span class="p">(</span><span class="nb">string?</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">string?</span><span class="w"> </span><span class="n">y</span><span class="p">))</span><span class="w"> </span><span class="p">(</span><span class="nb">string-append</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="k">else</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">error</span><span class="p">)))</span>
</code></pre></div>
<p>En la función anterior los parámetros <code>x</code> e <code>y</code> pueden ser números o
cadenas (o incluso de cualquier otro tipo). Y el valor devuelto por la
función será un número, una cadena o el símbolo <code>'error</code>.</p>
<p>Sucede lo mismo con el contenido de las parejas. Es posible guardar en
las parejas cualquier tipo de dato y combinar distintos tipos. Por
ejemplo:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">hola</span><span class="w"> </span><span class="no">#f</span><span class="p">))</span>
<span class="p">(</span><span class="nb">car</span><span class="w"> </span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="c1">; ⇒ &#39;hola</span>
<span class="p">(</span><span class="nb">cdr</span><span class="w"> </span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="c1">; ⇒ #f</span>
</code></pre></div>
<h4 id="316-las-parejas-son-objetos-inmutables">3.1.6. Las parejas son objetos inmutables<a class="headerlink" href="#316-las-parejas-son-objetos-inmutables" title="Permanent link">&para;</a></h4>
<p>Recordemos que en los paradigmas de programación declarativa y
funcional no existe el <em>estado mutable</em>. Una vez declarado un valor,
no se puede modificar. Esto debe suceder también con las parejas: una
vez creada una pareja no se puede modificar su contenido.</p>
<p>En Lisp y Scheme estándar las parejas sí que pueden ser
mutadas. Pero durante toda esta primera parte de la asignatura no lo
contemplaremos, para no salirnos del paradigma funcional.</p>
<p>En Swift y otros lenguajes de programación es posible definir
<strong>estructuras de datos inmutables</strong> que no pueden ser modificadas una
vez creadas. Lo veremos también más adelante.</p>
<h3 id="32-las-parejas-son-objetos-de-primera-clase">3.2. Las parejas son objetos de primera clase<a class="headerlink" href="#32-las-parejas-son-objetos-de-primera-clase" title="Permanent link">&para;</a></h3>
<p>En un lenguaje de programación un elemento es de primera clase cuando puede:</p>
<ul>
<li>Asignarse a variables</li>
<li>Pasarse como argumento</li>
<li>Devolverse por una función</li>
<li>Guardarse en una estructura de datos mayor</li>
</ul>
<p>Las parejas son objetos de primera clase.</p>
<p>Una pareja puede asignarse a una variable:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">p1</span><span class="w"> </span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="p">))</span>
<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">p2</span><span class="w"> </span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="no">#f</span><span class="w"> </span><span class="s2">&quot;hola&quot;</span><span class="p">))</span>
</code></pre></div>
<p>Una pareja puede pasarse como argumento y devolverse en una función:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">suma-parejas</span><span class="w"> </span><span class="n">p1</span><span class="w"> </span><span class="n">p2</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="p">(</span><span class="nb">car</span><span class="w"> </span><span class="n">p1</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">car</span><span class="w"> </span><span class="n">p2</span><span class="p">))</span>
<span class="w">          </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="p">(</span><span class="nb">cdr</span><span class="w"> </span><span class="n">p1</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">cdr</span><span class="w"> </span><span class="n">p2</span><span class="p">))))</span>

<span class="p">(</span><span class="n">suma-parejas</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="mi">5</span><span class="p">)</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">4</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="mi">12</span><span class="p">))</span><span class="w"> </span><span class="c1">; ⇒ (5 . 17)</span>
</code></pre></div>
<p>Una vez definida esta función <code>suma-parejas</code> podríamos ampliar la
función <code>suma</code> que vimos previamente con este nuevo tipo de datos:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">suma</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="k">cond</span><span class="w"> </span>
<span class="w">    </span><span class="p">((</span><span class="k">and</span><span class="w"> </span><span class="p">(</span><span class="nb">number?</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">number?</span><span class="w"> </span><span class="n">y</span><span class="p">))</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="p">))</span>
<span class="w">    </span><span class="p">((</span><span class="k">and</span><span class="w"> </span><span class="p">(</span><span class="nb">string?</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">string?</span><span class="w"> </span><span class="n">y</span><span class="p">))</span><span class="w"> </span><span class="p">(</span><span class="nb">string-append</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="p">))</span>
<span class="w">    </span><span class="p">((</span><span class="k">and</span><span class="w"> </span><span class="p">(</span><span class="nb">pair?</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">pair?</span><span class="w"> </span><span class="n">y</span><span class="p">))</span><span class="w"> </span><span class="p">(</span><span class="n">suma-parejas</span><span class="w"> </span><span class="n">p1</span><span class="w"> </span><span class="n">p2</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="k">else</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">error</span><span class="p">)))</span>
</code></pre></div>
<p>Y, por último, las parejas <em>pueden formar parte de otras parejas</em>. </p>
<p>Es lo que se denomina la <strong>propiedad de clausura de la función
<code>cons</code></strong>: el resultado de un <code>cons</code> puede usarse como parámetro de
nuevas llamadas a <code>cons</code>.</p>
<p>Ejemplo:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">p1</span><span class="w"> </span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="p">))</span>
<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">p2</span><span class="w"> </span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="p">))</span>
<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="n">p1</span><span class="w"> </span><span class="n">p2</span><span class="p">))</span>
</code></pre></div>
<p>Expresión equivalente:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span>
<span class="w">                </span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="p">)))</span>
</code></pre></div>
<p>Podríamos representar esta estructura así:</p>
<p><img src="imagenes/pareja-pareja.png" width="300px"/></p>
<p><em>Propiedad de clausura: las parejas pueden contener parejas</em></p>
<p>Pero se haría muy complicado representar muchos niveles de
anidamiento. Por eso utilizamos la siguiente representación:</p>
<p><img src="imagenes/pareja-pareja2.png" width="250px"/></p>
<p>Llamamos a estos diagramas <em>diagramas caja-y-puntero</em>
(<em>box-and-pointer</em> en inglés).</p>
<h3 id="33-diagramas-caja-y-puntero">3.3. Diagramas <em>caja-y-puntero</em><a class="headerlink" href="#33-diagramas-caja-y-puntero" title="Permanent link">&para;</a></h3>
<p>Al escribir expresiones complicadas con <code>cons</code> anidados es conveniente
para mejorar su legibilidad utilizar el siguiente formato:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="mi">1</span>
<span class="w">                      </span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="p">))</span>
<span class="w">                </span><span class="mi">2</span><span class="p">))</span>
</code></pre></div>
<p>Para entender la construcción de estas estructuras es importante
recordar que las expresiones se evalúan <em>de dentro a afuera</em>.</p>
<p>¿Qué figura representaría la estructura anterior?</p>
<p>Solución:</p>
<p><img src="imagenes/pareja-pareja3.png" width="200px"/></p>
<p>Es importante tener en cuenta que cada caja del diagrama representa
una pareja creada en la memoria del intérprete con la instrucción
<code>cons</code> y que el resultado de evaluar una variable en la que se ha
guardado una pareja devuelve la pareja recién creada. Por ejemplo, si
el intérprete evalúa <code>p</code> después de haber hecho la sentencia anterior
devuelve la pareja contenida en <code>p</code>, no se crea una pareja nueva.</p>
<p>Por ejemplo, si después de haber evaluado la sentencia anterior
evaluamos la siguiente:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">p2</span><span class="w"> </span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="mi">6</span><span class="p">)))</span>
</code></pre></div>
<p>El diagrama caja y puntero resultante sería el siguiente:</p>
<p><img src="imagenes/box-and-pointer2.png" width="250px"/></p>
<p>Vemos que en la pareja que se crea con <code>(cons p 6)</code> se guarda en la
parte izquierda <strong>la misma pareja que hay en <code>p</code></strong>. Lo representamos
con una flecha que apunta a la misma pareja que <code>p</code>.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>El funcionamiento de la evaluación de variables que contienen parejas es
similar al de las variables que contienen objetos en lenguajes
orientados a objetos como Java. Cuando se evalúa una variable que
contiene una pareja se devuelve la propia pareja, no una copia. </p>
<p>En programación funcional, como el contenido de las parejas es
inmutable, no hay problemas de <em>efectos laterales</em> por el hecho de
que una pareja esté compartida. </p>
</div>
<p>Es conveniente que pruebes a crear distintas estructuras de parejas
con parejas y a dibujar su diagrama caja y puntero. Y también a
recuperar un determinado dato (pareja o dato atómico) una vez creada
la estructura.</p>
<p>La siguiente función <code>print-pareja</code> puede ser útil a la hora de
mostrar por pantalla los elementos de una pareja</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">print-pareja</span><span class="w"> </span><span class="n">pareja</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">pair?</span><span class="w"> </span><span class="n">pareja</span><span class="p">)</span>
<span class="w">        </span><span class="p">(</span><span class="k">begin</span><span class="w"> </span>
<span class="w">            </span><span class="p">(</span><span class="nb">display</span><span class="w"> </span><span class="s2">&quot;(&quot;</span><span class="p">)</span>
<span class="w">            </span><span class="p">(</span><span class="n">print-dato</span><span class="w"> </span><span class="p">(</span><span class="nb">car</span><span class="w"> </span><span class="n">pareja</span><span class="p">))</span>
<span class="w">            </span><span class="p">(</span><span class="nb">display</span><span class="w"> </span><span class="s2">&quot; . &quot;</span><span class="p">)</span>
<span class="w">            </span><span class="p">(</span><span class="n">print-dato</span><span class="w"> </span><span class="p">(</span><span class="nb">cdr</span><span class="w"> </span><span class="n">pareja</span><span class="p">))</span>
<span class="w">            </span><span class="p">(</span><span class="nb">display</span><span class="w"> </span><span class="s2">&quot;)&quot;</span><span class="p">))</span>
<span class="w">        </span><span class="p">(</span><span class="nb">display</span><span class="w"> </span><span class="s2">&quot;&quot;</span><span class="p">)))</span>

<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">print-dato</span><span class="w"> </span><span class="n">dato</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">pair?</span><span class="w"> </span><span class="n">dato</span><span class="p">)</span>
<span class="w">        </span><span class="p">(</span><span class="n">print-pareja</span><span class="w"> </span><span class="n">dato</span><span class="p">)</span>
<span class="w">        </span><span class="p">(</span><span class="nb">display</span><span class="w"> </span><span class="n">dato</span><span class="p">)))</span>
</code></pre></div>
<div class="admonition warning">
<p class="admonition-title">¡Cuidado!</p>
<p>La función anterior contiene pasos de ejecución con sentencias como <code>begin</code> y
llamadas a <code>display</code> dentro del código de la función. Estas sentencias son
propias de la programación imperativa. <strong>No hacerlo en programación
funcional</strong>.</p>
</div>
<h4 id="331-funciones-cr">3.3.1. Funciones c????r<a class="headerlink" href="#331-funciones-cr" title="Permanent link">&para;</a></h4>
<p>Al trabajar con estructuras de parejas anidades es muy habitual
realizar llamadas del tipo:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="nb">cdr</span><span class="w"> </span><span class="p">(</span><span class="nb">cdr</span><span class="w"> </span><span class="p">(</span><span class="nb">car</span><span class="w"> </span><span class="n">p</span><span class="p">)))</span><span class="w"> </span><span class="c1">; ⇒ 4</span>
</code></pre></div>
<p>Es equivalente a la función <code>cadar</code> de Scheme:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="nb">cddar</span><span class="w"> </span><span class="n">p</span><span class="p">)</span><span class="w"> </span><span class="c1">; ⇒ 4</span>
</code></pre></div>
<p>El nombre de la función se obtiene concatenando a la letra "c", las
letras "a" o "d" según hagamos un car o un cdr y terminando con la
letra "r".</p>
<p>Hay definidas 2^4 funciones de este tipo: <code>caaaar</code>, <code>caaadr</code>, …,
<code>cddddr</code>.</p>
<p>Además de las combinaciones de 4 letras, también hay combinaciones de 3, 2 y 1 letra. En total hay 30 funciones de este tipo: 2^1 + 2^2 + 2^3 + 2^4 = 2 + 4 + 8 + 16 = 30 </p>
<h2 id="4-listas-en-scheme">4. Listas en Scheme<a class="headerlink" href="#4-listas-en-scheme" title="Permanent link">&para;</a></h2>
<h3 id="41-implementacion-de-listas-en-scheme">4.1. Implementación de listas en Scheme<a class="headerlink" href="#41-implementacion-de-listas-en-scheme" title="Permanent link">&para;</a></h3>
<p>Recordemos que Scheme permite manejar listas como un tipo de datos
básico. Hemos visto funciones para crear, añadir y recorrer listas.</p>
<p>En Scheme las listas se implementan usando parejas, por lo que las
funciones <code>car</code> y <code>cdr</code> también funcionan sobre listas.</p>
<p>¿Qué devuelven cuando se aplican a una lista? ¿Cómo se implementan las
listas con parejas? Vamos a investigarlo haciendo unas pruebas.</p>
<p>En primer lugar, vamos a usar las funciones <code>list?</code> y <code>pair?</code> para
comprobar si algo es una lista y/o una pareja.</p>
<p>Por ejemplo, una pareja formada por dos números es una pareja, pero no
es una lista:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">p1</span><span class="w"> </span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="p">))</span>
<span class="p">(</span><span class="nb">pair?</span><span class="w"> </span><span class="n">p1</span><span class="p">)</span><span class="w"> </span><span class="c1">; ⇒ #t</span>
<span class="p">(</span><span class="nb">list?</span><span class="w"> </span><span class="n">p1</span><span class="p">)</span><span class="w"> </span><span class="c1">; ⇒ #f</span>
</code></pre></div>
<p>Si preguntamos si una lista es una pareja, nos llevaremos la sorpresa
de que sí. Una lista es una lista (evidentemente) pero también es una pareja:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">lista</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">))</span>
<span class="p">(</span><span class="nb">list?</span><span class="w"> </span><span class="n">lista</span><span class="p">)</span><span class="c1">; ⇒ #t</span>
<span class="p">(</span><span class="nb">pair?</span><span class="w"> </span><span class="n">lista</span><span class="p">)</span><span class="c1">; ⇒ #t</span>
</code></pre></div>
<p>Si una lista es también una pareja también podemos aplicar las
funciones <code>car</code> y <code>cdr</code> con ellas. ¿Qué devuelven? Vamos a verlo:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">lista</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">))</span>
<span class="p">(</span><span class="nb">car</span><span class="w"> </span><span class="n">lista</span><span class="p">)</span><span class="w"> </span><span class="c1">; ⇒  1</span>
<span class="p">(</span><span class="nb">cdr</span><span class="w"> </span><span class="n">lista</span><span class="p">)</span><span class="w"> </span><span class="c1">; ⇒  (2 3)</span>
</code></pre></div>
<p>Resulta que en la pareja que representa la lista, en la parte
izquierda se guarda el primer el elemento de la lista y en la parte
derecha se guarda el resto de la lista.</p>
<p>También podemos explicar entonces por qué la llamada a <code>cons</code> con un
dato y una lista construye otra lista:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">lista</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">))</span>
<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">p1</span><span class="w"> </span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="n">lista</span><span class="p">))</span>
<span class="p">(</span><span class="nb">list?</span><span class="w"> </span><span class="n">p1</span><span class="p">)</span><span class="w"> </span><span class="c1">; ⇒  #t</span>
<span class="n">p1</span><span class="w"> </span><span class="c1">; ⇒ (1 1 2 3)</span>
</code></pre></div>
<p>¿Una pareja con una lista vacía como parte derecha es una lista?
Lo probamos:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">p1</span><span class="w"> </span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&#39;</span><span class="p">()))</span>
<span class="p">(</span><span class="nb">pair?</span><span class="w"> </span><span class="n">p1</span><span class="p">)</span><span class="w"> </span><span class="c1">; ⇒  #t</span>
<span class="p">(</span><span class="nb">list?</span><span class="w"> </span><span class="n">p1</span><span class="p">)</span><span class="w"> </span><span class="c1">; ⇒  #t</span>
</code></pre></div>
<p>Con estos ejemplos ya tenemos pistas para deducir la relación entre
listas y parejas en Scheme (y Lisp). Vamos a explicarlo.</p>
<h4 id="411-definicion-de-listas-con-parejas">4.1.1. Definición de listas con parejas<a class="headerlink" href="#411-definicion-de-listas-con-parejas" title="Permanent link">&para;</a></h4>
<p>Una lista es:</p>
<ul>
<li>Una pareja que contiene en su parte izquierda el primer elemento de
  la lista y en su parte derecha el resto de la lista</li>
<li>Un símbolo especial <code>'()</code> que denota la lista vacía</li>
</ul>
<p>Hay que notar que la definición anterior es una definición recursiva.</p>
<p>Por ejemplo, una lista muy sencilla con un solo elemento, <code>(1)</code>, se
define con la siguiente pareja:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&#39;</span><span class="p">())</span>
</code></pre></div>
<p>La pareja cumple las condiciones anteriores: </p>
<ul>
<li>La parte izquierda de la pareja es el primer elemento de la lista
  (el número 1)</li>
<li>La parte derecha es el resto de la lista (la lista vacía)</li>
</ul>
<p><img src="imagenes/pareja-lista.png" width="150px"/></p>
<p><em>La lista (1)</em></p>
<p>El objeto es al mismo tiempo una pareja y una lista. La función
<code>list?</code> permite comprobar si un objeto es una lista:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&#39;</span><span class="p">()))</span>
<span class="p">(</span><span class="nb">pair?</span><span class="w"> </span><span class="n">l</span><span class="p">)</span>
<span class="p">(</span><span class="nb">list?</span><span class="w"> </span><span class="n">l</span><span class="p">)</span>
</code></pre></div>
<p>Por ejemplo, la lista '(1 2 3) se construye con la siguiente
secuencia de parejas:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="mi">1</span>
<span class="w">      </span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="mi">2</span>
<span class="w">            </span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span>
<span class="w">                  </span><span class="o">&#39;</span><span class="p">())))</span>
</code></pre></div>
<p>La primera pareja cumple las condiciones de ser una lista:</p>
<ul>
<li>Su primer elemento es el 1</li>
<li>Su parte derecha es la lista '(2 3)</li>
</ul>
<p><img src="imagenes/lista.png" width="400px"/></p>
<p><em>Parejas formando una lista</em></p>
<p>Al comprobar la implementación de las listas en Scheme, entendemos por
qué las funciones <code>car</code> y <code>cdr</code> nos devuelven el primer elemento y el
resto de la lista. De hecho, las funciones <code>first</code> y <code>rest</code> se
implementan usando las funciones <code>car</code> y <code>cdr</code>. Cuando trabajemos con listas usaremos siempre las funciones <code>first</code>y <code>rest</code> que son las funciones. de la barrera de abstracción de las listas.</p>
<h4 id="412-lista-vacia">4.1.2. Lista vacía<a class="headerlink" href="#412-lista-vacia" title="Permanent link">&para;</a></h4>
<p>La lista vacía es una lista:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="nb">list?</span><span class="w"> </span><span class="o">&#39;</span><span class="p">())</span><span class="w"> </span><span class="c1">; ⇒ #t</span>
</code></pre></div>
<p>Y no es un símbolo ni una pareja:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="nb">symbol?</span><span class="w"> </span><span class="o">&#39;</span><span class="p">())</span><span class="w"> </span><span class="c1">; ⇒ #f</span>
<span class="p">(</span><span class="nb">pair?</span><span class="w"> </span><span class="o">&#39;</span><span class="p">())</span><span class="w"> </span><span class="c1">; ⇒ #f</span>
</code></pre></div>
<p>Para saber si un objeto es la lista vacía, podemos utilizar la función
<code>null?</code>:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="nb">null?</span><span class="w"> </span><span class="o">&#39;</span><span class="p">())</span><span class="w"> </span><span class="c1">; ⇒ #t</span>
</code></pre></div>
<p>En Racket está predefinido el símbolo <code>null</code> que tiene como valor la
lista vacía:</p>
<div class="highlight"><pre><span></span><code><span class="nb">null</span><span class="w"> </span><span class="c1">; ⇒ ()</span>
</code></pre></div>
<h3 id="42-listas-con-elementos-compuestos">4.2. Listas con elementos compuestos<a class="headerlink" href="#42-listas-con-elementos-compuestos" title="Permanent link">&para;</a></h3>
<p>Las listas pueden contener cualquier tipo de elementos, incluyendo
otras parejas.</p>
<p>La siguiente estructura se denomina <em>lista de asociación</em>. Son listas
cuyos elementos son parejas (<em>clave</em>, <em>valor</em>):</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">a</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>
<span class="w">      </span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">b</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span>
<span class="w">      </span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">c</span><span class="w"> </span><span class="mi">3</span><span class="p">))</span><span class="w"> </span><span class="c1">; ⇒ ((a . 1) (b . 2) (c . 2))</span>
</code></pre></div>
<p>¿Cuál sería el diagrama <em>box and pointer</em> de la estructura anterior?</p>
<p><img src="imagenes/lista-parejas.png" width="400px"/></p>
<p>La expresión equivalente utilizando conses es:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">a</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>
<span class="w">      </span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">b</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span>
<span class="w">            </span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">c</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span>
<span class="w">                  </span><span class="o">&#39;</span><span class="p">())))</span>
</code></pre></div>
<h4 id="421-listas-de-listas">4.2.1. Listas de listas<a class="headerlink" href="#421-listas-de-listas" title="Permanent link">&para;</a></h4>
<p>Hemos visto que podemos construir listas que contienen otras listas:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">lista</span><span class="w"> </span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="mi">3</span><span class="p">))</span>
</code></pre></div>
<p>La lista anterior también se puede definir con quote:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">lista</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="mi">3</span><span class="p">))</span>
</code></pre></div>
<p>La lista resultante contiene tres elementos: el primero y el último
son elementos atómicos (números) y el segundo es otra lista.</p>
<p>Si preguntamos por la longitud de la lista Scheme nos dirá que es una
lista de 3 elementos:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="nb">length</span><span class="w"> </span><span class="n">lista</span><span class="p">)</span><span class="w"> </span><span class="c1">; ⇒ 3</span>
</code></pre></div>
<p>Y el segundo elemento de la lista es otra lista:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="nb">second</span><span class="w"> </span><span class="n">lista</span><span class="p">)</span><span class="w"> </span><span class="c1">; ⇒ (1 2 3)</span>
</code></pre></div>
<div class="admonition note">
<p class="admonition-title">Funciones second, third, ..., tenth</p>
<p>En Racket existen funciones que devuelven el segundo, tercer,
... y así hasta el décimo elemento de una lista. Son las funciones
<code>second</code>, <code>third</code>, ..., <code>tenth</code>. Se pueden consultar en el <a href="https://docs.racket-lang.org/reference/pairs.html#%28part._.Additional_.List_.Functions_and_.Synonyms%29">manual
de referencia del lenguaje</a>.</p>
</div>
<p>¿Cómo implementa Scheme esta lista usando parejas?</p>
<p>Al ser una lista de tres elementos lo hará con tres parejas enlazadas
que terminan en una lista vacía en la parte derecha de la última
pareja. En las partes izquierdas de esas tres parejas tendremos los
elementos de la lista propiamente dichos: un 1 y un 3 en la primera y
última pareja y una lista en la segunda pareja.</p>
<p>El diagrama <em>box and pointer</em>:</p>
<p><img src="imagenes/lista-lista.png" width="500px"/></p>
<p><em>Lista que contiene otra lista como segundo elemento</em></p>
<h4 id="422-impresion-de-listas-y-parejas-por-el-interprete-de-scheme">4.2.2. Impresión de listas y parejas por el intérprete de Scheme<a class="headerlink" href="#422-impresion-de-listas-y-parejas-por-el-interprete-de-scheme" title="Permanent link">&para;</a></h4>
<p>El intérprete de Scheme siempre intenta mostrar una lista cuando
encuentra una pareja cuyo siguiente elemento es otra pareja.</p>
<p>Por ejemplo, si tenemos la siguiente estructura:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">)))</span>
</code></pre></div>
<p>Cuando se evalúe <code>p</code> el intérprete imprimirá por pantalla lo
siguiente:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span>
</code></pre></div>
<p>¿Por qué? Porque el intérprete va construyendo la salida conforme
recorre la pareja <code>p</code>. Como encuentra una pareja cuya parte derecha es
otra pareja, lo interpreta como el comienzo de una lista, y por eso
escribe <code>(1 2</code> en lugar de <code>(1 . 2</code>. Pero inmediatamente después se
encuentra con el <code>3</code> en lugar de una lista vacía. En ese momento el
intérprete "se da cuenta" de que no tenemos una lista y termina la
expresión escribiendo el <code>. 3</code> y el paréntesis final.</p>
<p>Si queremos comprobar la estructura de parejas podemos utilizar la
función <code>print-pareja</code> definida anteriormente, que imprimiría lo
siguiente:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="n">print-pareja</span><span class="w"> </span><span class="n">p</span><span class="p">)</span><span class="w"> </span><span class="c1">; ⇒ (1 . (2 . 3))</span>
</code></pre></div>
<h4 id="423-funciones-de-alto-nivel-sobre-listas">4.2.3. Funciones de alto nivel sobre listas<a class="headerlink" href="#423-funciones-de-alto-nivel-sobre-listas" title="Permanent link">&para;</a></h4>
<p>Es importante conocer cómo se implementan las listas usando parejas y
su representación con diagramas caja y puntero para definir funciones
de alto nivel. </p>
<p>Una vez conocidos los detalles de implementación, podemos volver a
usar las funciones que tienen un nivel de abstracción mayor como
<code>first</code> y <code>rest</code>. Son funciones que tienen un nombre entendible y que
comunican perfectamente lo que hacen (devolver el primer elemento y el
resto).</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="ss">a</span><span class="w"> </span><span class="ss">b</span><span class="w"> </span><span class="ss">c</span><span class="w"> </span><span class="ss">d</span><span class="p">))</span><span class="w"> </span><span class="c1">; ⇒ a</span>
<span class="p">(</span><span class="nb">rest</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="ss">a</span><span class="w"> </span><span class="ss">b</span><span class="w"> </span><span class="ss">c</span><span class="w"> </span><span class="ss">d</span><span class="p">))</span><span class="w"> </span><span class="c1">; ⇒ (b c d)</span>
</code></pre></div>
<p>Existen otras funciones de alto nivel que trabajan sobre
listas. Algunas ya las conocemos, pero otras no:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="nb">append</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="ss">a</span><span class="w"> </span><span class="p">(</span><span class="ss">b</span><span class="p">)</span><span class="w"> </span><span class="ss">c</span><span class="p">)</span><span class="w"> </span><span class="o">&#39;</span><span class="p">((</span><span class="ss">d</span><span class="p">)</span><span class="w"> </span><span class="ss">e</span><span class="w"> </span><span class="ss">f</span><span class="p">))</span><span class="w"> </span><span class="c1">; ⇒ (a (b) c (d) e f)</span>
<span class="p">(</span><span class="nb">list-ref</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="ss">a</span><span class="w"> </span><span class="p">(</span><span class="ss">b</span><span class="p">)</span><span class="w"> </span><span class="ss">c</span><span class="w"> </span><span class="ss">d</span><span class="p">)</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="c1">; ⇒ c</span>
<span class="p">(</span><span class="nb">length</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="ss">a</span><span class="w"> </span><span class="p">(</span><span class="ss">b</span><span class="w"> </span><span class="p">(</span><span class="ss">c</span><span class="p">)))</span><span class="w"> </span><span class="c1">; ⇒ 2</span>
<span class="p">(</span><span class="nb">reverse</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="ss">a</span><span class="w"> </span><span class="ss">b</span><span class="w"> </span><span class="ss">c</span><span class="p">))</span><span class="w">  </span><span class="c1">; ‌⇒ (c b a)</span>
<span class="p">(</span><span class="nb">list-tail</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="ss">a</span><span class="w"> </span><span class="ss">b</span><span class="w"> </span><span class="ss">c</span><span class="w"> </span><span class="ss">d</span><span class="p">)</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="c1">; ‌⇒ (c d)</span>
</code></pre></div>
<!--
En los siguientes apartados veremos cómo están implementadas.

### 4.3. Funciones recursivas que construyen listas

Para terminar el apartado sobre las listas en Scheme vamos a ver
ejemplos adicionales de funciones recursivas que trabajan con
listas. Veremos alguna función que recibe una lista y, como antes, usa
la recursión para recorrerla. Pero veremos también funciones que usan
la recursión para **construir nuevas listas**.

Algunas de las funciones que presentamos son implementaciones de las
ya existentes en Scheme. Para no solapar con las definiciones de
Scheme pondremos el prefijo `mi-` en todas ellas.

Vamos a ver las siguientes funciones:

- `mi-list-ref`: implementación de la función `list-ref`
- `mi-list-tail`: implementación de la función `list-tail`
- `mi-append`: implementación de la funión `append` 
- `mi-reverse`: implementación de la función `reverse`
- `cuadrados-hasta`: devuelve la lista de cuadrados hasta uno dado
- `filtra-pares`: devuelve la lista de los números pares de la lista que se recibe
- `primo?`: comprueba si un número es o no primo


#### 4.3.1. Función `mi-list-ref`

La función `(mi-list-ref n lista)` devuelve el elemento `n` de una
lista (empezando a contar por 0):

<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">lista</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="ss">a</span><span class="w"> </span><span class="ss">b</span><span class="w"> </span><span class="ss">c</span><span class="w"> </span><span class="ss">d</span><span class="w"> </span><span class="ss">e</span><span class="w"> </span><span class="ss">f</span><span class="w"> </span><span class="ss">g</span><span class="p">))</span>
<span class="p">(</span><span class="n">mi-list-ref</span><span class="w"> </span><span class="n">lista</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="c1">; ⇒ c</span>
</code></pre></div>

Veamos con el ejemplo anterior cómo hacer la formulación recursiva.

Hemos visto que, en general, cuando queremos resolver un problema de
forma recursiva tenemos que hacer una llamada recursiva a un problema
más sencillo, **confiar en que la llamada nos devuelva el resultado
correcto** y usar ese resultado para resolver el problema original.

En este caso nuestro problema es obtener el número que está en la
posición 2 de la lista `(a b c d e f g)`. Suponemos que la función que
nos devuelve una posición de la lista ya la tenemos implementada y que
la llamada recursiva nos va a devolver el resultado correcto. ¿Cómo
podemos simplificar el problema original? Veamos la solución para este
caso concreto:

<div class="highlight"><pre><span></span><code>Para devolver el elemento 2 de la lista (a b c d e f g):
   Obtenemos el resto de la lista (b c d e f g)
   y devolvemos su elemento 1. Será el valor c (empezamos 
   a contar por 0).
</code></pre></div>


Generalizamos el ejemplo anterior, para cualquier `n` y cualquier lista:


<div class="highlight"><pre><span></span><code>Para devolver el elemento que está en la posición `n` de una lista,
devuelvo el elemento n-1 de su resto.
</code></pre></div>

Y, por último, formulamos el caso base de la recursión, el problema
más sencillo que se puede resolver directamente, sin hacer una llamada
recursiva:

<div class="highlight"><pre><span></span><code>Para devolver el elemento que está en la posición 0 de una lista,
devuelvo el `first` de la lista.
</code></pre></div>

La implementación de todo esto en Scheme sería la siguiente:

<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">mi-list-ref</span><span class="w"> </span><span class="n">lista</span><span class="w"> </span><span class="n">n</span><span class="p">)</span>
<span class="w">   </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span>
<span class="w">      </span><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="n">lista</span><span class="p">)</span>
<span class="w">      </span><span class="p">(</span><span class="n">mi-list-ref</span><span class="w"> </span><span class="p">(</span><span class="nb">rest</span><span class="w"> </span><span class="n">lista</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">-</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="mi">1</span><span class="p">))))</span>
</code></pre></div>

#### 4.3.2. Función `mi-list-tail`

La función `(mi-list-tail lista n)` devuelve la lista resultante de
quitar n elementos de la cabeza de la lista original:

<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="n">mi-list-tail</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="mi">6</span><span class="w"> </span><span class="mi">7</span><span class="p">)</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="c1">; ⇒ (3 4 5 6 7)</span>
</code></pre></div>

Piensa en cómo se implementaría de forma recursiva. Esta vez vamos a
mostrar directamente la implementación, sin dar explicaciones de cómo
se ha llegado a ella:

<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">mi-list-tail</span><span class="w"> </span><span class="n">lista</span><span class="w"> </span><span class="n">n</span><span class="p">)</span>
<span class="w">   </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span>
<span class="w">       </span><span class="n">lista</span>
<span class="w">       </span><span class="p">(</span><span class="n">mi-list-tail</span><span class="w"> </span><span class="p">(</span><span class="nb">rest</span><span class="w"> </span><span class="n">lista</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">-</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="mi">1</span><span class="p">))))</span>
</code></pre></div>

#### 4.3.3. Función `mi-append` 

Veamos ahora cómo podríamos implementar de forma recursiva la función
`append` que une dos listas. La llamaremos `(mi-append lista1
lista2)`.

Por ejemplo:

<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="n">mi-append</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="ss">a</span><span class="w"> </span><span class="ss">b</span><span class="w"> </span><span class="ss">c</span><span class="p">)</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="ss">d</span><span class="w"> </span><span class="ss">e</span><span class="w"> </span><span class="ss">f</span><span class="p">))</span><span class="w"> </span><span class="c1">; ⇒ (a b c d e f)</span>
</code></pre></div>

Para resolver el problema de forma recursiva, debemos confiar en la
recursión para que resuelva un problema más sencillo y después
terminar de arreglar el resultado devuelto por la recursión.

En este caso, podemos pasarle a la recursión un problema más sencillo
quitando el primer elemento de la primera lista (con la función
`rest`) y llamando a la recursión para que concatene esta lista más pequeña
con la segunda. Confiamos en que la recursión funciona correctamente y
nos devuelve la concatenación de ambas listas

<div class="highlight"><pre><span></span><code>(mi-append (rest &#39;(a b c)) &#39;(d e f)) =&gt; (b c d e f)
</code></pre></div>

Y añadiremos el primer elemento a la lista resultante usando un `cons`:

<div class="highlight"><pre><span></span><code>(mi-append &#39;(a b c) &#39;(d e f)) = 
(cons &#39;a (mi-append &#39;(b c)) &#39;(d e f)) =
(cons &#39;a &#39;(b c d e f)) = 
(a b c d e f)
</code></pre></div>

En general:

<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">mi-append</span><span class="w"> </span><span class="n">lista1</span><span class="w"> </span><span class="n">lista2</span><span class="p">)</span><span class="w"> </span>
<span class="w">   </span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="n">lista1</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">mi-append</span><span class="w"> </span><span class="p">(</span><span class="nb">rest</span><span class="w"> </span><span class="n">lista1</span><span class="p">)</span><span class="w"> </span><span class="n">lista2</span><span class="p">)))</span>
</code></pre></div>

El caso base, el caso en el que la función puede devolver un valor
directamente sin llamar a la recursión, es aquel en el que `lista1` es
`null?`. En ese caso devolvemos `lista2`:

<div class="highlight"><pre><span></span><code>(mi-append &#39;() &#39;(a b c)) =&gt; &#39;(a b c)
</code></pre></div>

La formulación recursiva completa queda como sigue:

<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">mi-append</span><span class="w"> </span><span class="n">l1</span><span class="w"> </span><span class="n">l2</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">null?</span><span class="w"> </span><span class="n">l1</span><span class="p">)</span>
<span class="w">        </span><span class="n">l2</span>
<span class="w">        </span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="n">l1</span><span class="p">)</span>
<span class="w">              </span><span class="p">(</span><span class="n">mi-append</span><span class="w"> </span><span class="p">(</span><span class="nb">rest</span><span class="w"> </span><span class="n">l1</span><span class="p">)</span><span class="w"> </span><span class="n">l2</span><span class="p">))))</span>
</code></pre></div>

#### 4.3.4. Función `mi-reverse`

Veamos cómo implementar de forma recursiva la función `mi-reverse` que
invierte una lista

<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="n">mi-reverse</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="mi">6</span><span class="p">))</span><span class="w"> </span><span class="c1">; ⇒ (6 5 4 3 2 1)</span>
</code></pre></div>

La idea es sencilla: llamamos a la recursión para hacer la inversa del
`rest` de la lista y añadimos el primer elemento a la lista resultante
que devuelve ya invertida la llamada recursiva.

Podemos definir una función auxiliar `(añade-al-final dato lista)` que
añade un dato al final de una lista usando `append`:

Veamos directamente su implementación, usando `mi-append` para añadir
un elemento al final de la lista:

<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">añade-al-final</span><span class="w"> </span><span class="n">dato</span><span class="w"> </span><span class="n">lista</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="nb">append</span><span class="w"> </span><span class="n">lista</span><span class="w"> </span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="n">dato</span><span class="p">)))</span>
</code></pre></div>

La función `mi-reverse` quedaría entonces como sigue:

<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">mi-reverse</span><span class="w"> </span><span class="n">lista</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">null?</span><span class="w"> </span><span class="n">lista</span><span class="p">)</span><span class="w"> </span><span class="o">&#39;</span><span class="p">()</span>
<span class="w">        </span><span class="p">(</span><span class="n">añade-al-final</span><span class="w"> </span><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="n">lista</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">mi-reverse</span><span class="w"> </span><span class="p">(</span><span class="nb">rest</span><span class="w"> </span><span class="n">lista</span><span class="p">)))))</span>
</code></pre></div>

#### 4.3.5. Función `cuadrados-hasta`

La función `(cuadrados-hasta x)` devuelve una lista con los cuadrados
de los números hasta `x`:

<div class="highlight"><pre><span></span><code>Para construir una lista de los cuadrados hasta x:
   construyo la lista de los cuadrados hasta x-1 y le añado el cuadrado de x
</code></pre></div>

El caso base de la recursión es el caso en el que `x` es 1, entonces
devolvemos una lista formada por el 1.

En Scheme:

<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">cuadrados-hasta</span><span class="w"> </span><span class="n">x</span><span class="p">)</span>
<span class="w">   </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>
<span class="w">      </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="w">      </span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="p">(</span><span class="n">cuadrado</span><span class="w"> </span><span class="n">x</span><span class="p">)</span>
<span class="w">            </span><span class="p">(</span><span class="n">cuadrados-hasta</span><span class="w"> </span><span class="p">(</span><span class="nb">-</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="mi">1</span><span class="p">)))))</span>
</code></pre></div>

Ejemplo:

<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="n">cuadrados-hasta</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span><span class="w"> </span><span class="c1">; ⇒ (100 81 64 49 36 25 16 9 4 1)</span>
</code></pre></div>

#### 4.3.6. Función `filtra-pares`

Es muy habitual recorrer una lista y comprobar condiciones de sus
elementos, construyendo una lista con los que cumplan una determinada
condición.

Por ejemplo, la siguiente función `filtra-pares` construye una lista
con los números pares de la lista que le pasamos como parámetro:

<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">filtra-pares</span><span class="w"> </span><span class="n">lista</span><span class="p">)</span>
<span class="w">   </span><span class="p">(</span><span class="k">cond</span>
<span class="w">      </span><span class="p">((</span><span class="nb">null?</span><span class="w"> </span><span class="n">lista</span><span class="p">)</span><span class="w"> </span><span class="o">&#39;</span><span class="p">())</span>
<span class="w">      </span><span class="p">((</span><span class="nb">even?</span><span class="w"> </span><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="n">lista</span><span class="p">))</span><span class="w"> </span>
<span class="w">       </span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="n">lista</span><span class="p">)</span>
<span class="w">          </span><span class="p">(</span><span class="n">filtra-pares</span><span class="w"> </span><span class="p">(</span><span class="nb">rest</span><span class="w"> </span><span class="n">lista</span><span class="p">))))</span>
<span class="w">      </span><span class="p">(</span><span class="k">else</span><span class="w"> </span><span class="p">(</span><span class="n">filtra-pares</span><span class="w"> </span><span class="p">(</span><span class="nb">rest</span><span class="w"> </span><span class="n">lista</span><span class="p">)))))</span>
</code></pre></div>

En el caso general, llamamos de forma recursiva a la función para que
filtre el `rest` de la lista. Y le añadimos el primer elemento si es
par.

Cada vez llamaremos a la recursión con una lista más pequeña, por lo
que en el caso base tendremos que comprobar si la lista que
recibimos. En ese caso devolvemos la lista vacía.

Ejemplo:

<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="n">filtra-pares</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="mi">6</span><span class="p">))</span><span class="w"> </span><span class="c1">; ⇒ (2 4 6)</span>
</code></pre></div>

#### 4.3.7. Función `primo?`

El uso de listas es uno de los elementos fundamentales de la
programación funcional.

Como ejemplo, vamos a ver cómo trabajar con listas para construir una
función que calcula si un número es primo. La forma de hacerlo será
calcular la lista de divisores del número y comprobar si su longitud
es dos. En ese caso será primo.

Por ejemplo:

<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="n">divisores</span><span class="w"> </span><span class="mi">8</span><span class="p">)</span><span class="w"> </span><span class="c1">; ⇒ (1 2 4 8) longitud = 4, no primo</span>
<span class="p">(</span><span class="n">divisores</span><span class="w"> </span><span class="mi">9</span><span class="p">)</span><span class="w"> </span><span class="c1">; ⇒ (1 3 9) longitud = 3, no primo</span>
<span class="p">(</span><span class="n">divisores</span><span class="w"> </span><span class="mi">11</span><span class="p">)</span><span class="w"> </span><span class="c1">; ⇒ (1 11) longitud = 2, primo</span>
</code></pre></div>

Podemos definir entonces la función `(primo? x)` de la siguiente forma:

<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">primo?</span><span class="w"> </span><span class="n">x</span><span class="p">)</span>
<span class="w">   </span><span class="p">(</span><span class="nb">=</span><span class="w">  </span><span class="mi">2</span><span class="w"> </span>
<span class="w">      </span><span class="p">(</span><span class="nb">length</span><span class="w"> </span><span class="p">(</span><span class="n">divisores</span><span class="w"> </span><span class="n">x</span><span class="p">))))</span>
</code></pre></div>

¿Cómo implementamos la función `(divisores x)` que nos devuelve la
lista de los divisores de un número `x`. Vamos a construirla de la
siguiente forma:

1. Creamos una lista de todos los números del 1 a x
2. Filtramos la lista para dejar los divisores de x

La función `(lista-desde x)` devuelve una lista de números x..1:

<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">lista-desde</span><span class="w"> </span><span class="n">x</span><span class="p">)</span>
<span class="w">   </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">      </span><span class="o">&#39;</span><span class="p">()</span>
<span class="w">      </span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="p">(</span><span class="n">lista-desde</span><span class="w"> </span><span class="p">(</span><span class="nb">-</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="mi">1</span><span class="p">)))))</span>
</code></pre></div>

Ejemplos:

<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="n">lista-desde</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="c1">; ⇒ (2 1)</span>
<span class="p">(</span><span class="n">lista-desde</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span><span class="w"> </span><span class="c1">; ⇒ (10 9 8 7 6 5 4 3 2 1)</span>
</code></pre></div>

Definimos la función `(divisor? x y)` que nos diga si x es divisor de
y:

<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">divisor?</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="p">)</span>
<span class="w">      </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">(</span><span class="nb">remainder</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="n">x</span><span class="p">)))</span>
</code></pre></div>

Ejemplos:

<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="n">divisor</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span><span class="w"> </span><span class="c1">; ⇒ #t</span>
<span class="p">(</span><span class="n">divisor</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span><span class="w"> </span><span class="c1">; ⇒ #f</span>
</code></pre></div>

Una vez que hemos definido La función `divisor?` podemos utilizarla
para definir la función recursiva `(filtra-divisores lista x)` que
devuelve una lista con los números de `lista` que son divisores de
`x`:

<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">filtra-divisores</span><span class="w"> </span><span class="n">lista</span><span class="w"> </span><span class="n">x</span><span class="p">)</span>
<span class="w">   </span><span class="p">(</span><span class="k">cond</span>
<span class="w">      </span><span class="p">((</span><span class="nb">null?</span><span class="w"> </span><span class="n">lista</span><span class="p">)</span><span class="w"> </span><span class="o">&#39;</span><span class="p">())</span>
<span class="w">      </span><span class="p">((</span><span class="n">divisor?</span><span class="w"> </span><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="n">lista</span><span class="p">)</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span>
<span class="w">       </span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="n">lista</span><span class="p">)</span>
<span class="w">             </span><span class="p">(</span><span class="n">filtra-divisores</span><span class="w"> </span><span class="p">(</span><span class="nb">rest</span><span class="w"> </span><span class="n">lista</span><span class="p">)</span><span class="w"> </span><span class="n">x</span><span class="p">)))</span>
<span class="w">      </span><span class="p">(</span><span class="k">else</span><span class="w"> </span><span class="p">(</span><span class="n">filtra-divisores</span><span class="w"> </span><span class="p">(</span><span class="nb">rest</span><span class="w"> </span><span class="n">lista</span><span class="p">)</span><span class="w"> </span><span class="n">x</span><span class="p">))))</span>
</code></pre></div>

Ya podemos implementar la función que devuelve los divisores de un
número `x` generando los números hasta `x` y filtrando los divisores
de ese número. Por ejemplo, para calcular los divisores de 10:

<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="n">filtra-divisores</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="mi">6</span><span class="w"> </span><span class="mi">7</span><span class="w"> </span><span class="mi">8</span><span class="w"> </span><span class="mi">9</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span><span class="w"> </span><span class="c1">; ⇒ (1 2 5 10)</span>
</code></pre></div>

Se puede implementar de una forma muy sencilla:

<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">divisores</span><span class="w"> </span><span class="n">x</span><span class="p">)</span>
<span class="w">   </span><span class="p">(</span><span class="n">filtra-divisores</span><span class="w"> </span><span class="p">(</span><span class="n">lista-desde</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="n">x</span><span class="p">))</span>
</code></pre></div>

Y una vez definida esta función, ya puede funcionar correctamente la
función `primo?`.


### 4.4. Funciones con número variable de argumentos

Hemos visto algunas funciones primitivas de Scheme, como `+` o `max`
que admiten un número variable de argumentos. ¿Podemos hacerlo también
en funciones definidas por nosotros?

La respuesta es sí, utilizando lo que se denomina notación
*dotted-tail* (punto-cola) para definir los parámetros de la
función. En esta notación se coloca un punto antes del último
parámetro. Los parámetros antes del punto (si existen) tendrán como
valores los argumentos usados en la llamada y el resto de argumentos
se pasarán en forma de lista en el último parámetro.

Por ejemplo, si tenemos la definición

<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">funcion-dos-o-mas-args</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="n">lista-args</span><span class="p">)</span><span class="w"> </span>
<span class="w">    </span><span class="n">&lt;cuerpo&gt;</span><span class="p">)</span>
</code></pre></div>

podemos llamar a la función anterior con dos o más argumentos:

<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="n">funcion-dos-o-mas-args</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="mi">6</span><span class="p">)</span>
</code></pre></div>

En la llamada, los parámetros `x` e `y` tomarán los valores 1 y 2. El
parámetro `lista-args` tomará como valor una lista con los argumentos
restantes `(3 4 5 6)`.

También es posible permitir que todos los argumentos sean opcionales
no poniendo ningún argumento antes del punto::

<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">funcion-cualquier-numero-args</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="n">lista-args</span><span class="p">)</span><span class="w"> </span>
<span class="w">    </span><span class="n">&lt;cuerpo&gt;</span><span class="p">)</span>
</code></pre></div>

Si hacemos la llamada

<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="n">funcion-cualquier-numero-args</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="mi">6</span><span class="p">)</span>
</code></pre></div>

el parámetro `lista-args` tomará como valor la lista `(1 2 3 4 5 6)`.

Veamos un sencillo ejemplo.

Podemos implementar una función `mi-suma` que tome al menos dos
argumentos y después un número variable de argumentos y devuelva la
suma de todos ellos. Es muy sencillo: recogemos todos los argumentos
en la lista de argumentos variables y llamamos a la función
`suma-lista` que suma una lista de números:

<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">mi-suma</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="n">lista-nums</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">null?</span><span class="w"> </span><span class="n">lista-nums</span><span class="p">)</span>
<span class="w">        </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="p">)</span>
<span class="w">        </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="p">(</span><span class="n">suma-lista</span><span class="w"> </span><span class="n">lista-nums</span><span class="p">)))))</span>
</code></pre></div>

## 5. Funciones como tipos de datos de primera clase

Hemos visto que la característica fundamental de la programación
funcional es la definición de funciones. Hemos visto también que no
producen efectos laterales y no tienen estado. Una función toma unos
datos como entrada y produce un resultado como salida.

Una de las características fundamentales de la programación funcional
es considerar a las funciones como *objetos de primera
clase*. Recordemos que un tipo de primera clase es aquel que:

1. Puede ser asignado a una variable
2. Puede ser pasado como argumento a una función
3. Puede ser devuelto como resultado de una invocación a una función
4. Puede ser parte de un tipo mayor

Vamos a ver que las funciones son ejemplos de todos los casos
anteriores: vamos a poder crear funciones sin nombre y asignarlas a
variables, pasarlas como parámetro de otras funciones, devolverlas
como resultado de invocar a otra función y guardarlas en
tipos de datos compuestos como listas.

La posibilidad de usar funciones como objetos de primera clase es una
característica fundamental de los lenguajes funcionales. Es una
característica de muchos lenguajes multi-paradigma con características
funcionales como
[JavaScript](http://helephant.com/2008/08/19/functions-are-first-class-objects-in-javascript/),
[Python](https://thenewcircle.com/static/bookshelf/python_fundamentals_tutorial/functional_programming.html),
[Swift](https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Closures.html)
o a partir de la versión 8 de Java,
[Java 8](http://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html),
(donde se denominan *expresiones lambda*).

### 5.1. Forma especial `lambda`

Vamos a empezar explicando la forma especial `lambda` de Scheme, que
nos permite crear funciones anónimas en tiempo de ejecución.

De la misma forma que podemos usar cadenas o enteros sin darles un
nombre, en Scheme es posible usar una función sin darle un
nombre mediante esta forma especial.

#### 5.1.1. Sintaxis de la forma especial `lambda`

La sintaxis de la forma especial `lambda` es:

<div class="highlight"><pre><span></span><code>(lambda (&lt;arg1&gt; ... &lt;argn&gt;) 
    &lt;cuerpo&gt;)
</code></pre></div>

El cuerpo del lambda define un *bloque de código* y sus argumentos son
los parámetros necesarios para ejecutar ese bloque de código. Llamamos
a la función resultante una *función anónima*.

Algunos ejemplos:

Una función anónima que suma dos parejas:

<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">lambda</span><span class="w"> </span><span class="p">(</span><span class="n">p1</span><span class="w"> </span><span class="n">p2</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="p">(</span><span class="nb">car</span><span class="w"> </span><span class="n">p1</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">car</span><span class="w"> </span><span class="n">p2</span><span class="p">))</span>
<span class="w">          </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="p">(</span><span class="nb">cdr</span><span class="w"> </span><span class="n">p1</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">cdr</span><span class="w"> </span><span class="n">p2</span><span class="p">))))</span>
</code></pre></div>

Una función anónima que devuelve el mayor de dos números:

<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">lambda</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="p">)</span>
<span class="w">        </span><span class="n">a</span>
<span class="w">        </span><span class="n">b</span><span class="p">))</span>
</code></pre></div>

#### 5.1.2. Semántica de la forma especial `lambda`

La invocación a la forma especial `lambda` construye una función
anónima en tiempo de ejecución.

Por ejemplo, si ejecutamos una expresión lambda en el intérprete
veremos que devuelve un procedimiento:

<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">lambda</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">x</span><span class="p">))</span><span class="w"> </span><span class="c1">; ⇒ #&lt;procedure&gt;</span>
</code></pre></div>

El procedimiento construido es un bloque de código que devuelve el
cuadrado de un número.

¿Qué podemos hacer con este procedimiento? 

Podemos asignarlo a un identificador. Por ejemplo, en la siguiente
expresión, primero se evalúa la *expresión lambda* y el procedimiento
resultante se asocia al identificador `f`.

<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="p">(</span><span class="k">lambda</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">x</span><span class="p">)))</span>
</code></pre></div>

El ejemplo anterior funciona de una forma idéntica al siguiente:

<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">))</span>
</code></pre></div>

En ambos casos se evalúa la expresión derecha y el resultado se guarda
en un identificador. En el primer caso la expresión que se evalúa
devuelve un procedimiento, que se guarda en la variable `f` y en el
segundo un número, que se guarda en la variable `x`.

Si escribimos los identificadores `f` y `x` en el intérprete Scheme los
evalúa y muestra los valores guardados:

<div class="highlight"><pre><span></span><code><span class="n">f</span><span class="w"> </span><span class="c1">; ⇒ #&lt;procedure:f&gt;</span>
<span class="n">x</span><span class="w"> </span><span class="c1">; ⇒ 5</span>
</code></pre></div>

En el primer caso se devuelve un procedimiento y en el segundo un
número. Fíjate que Scheme trata a los procedimientos y a los números
de la misma forma; son lo que se denominan datos de primera clase.

Una vez asignado un procedimiento a un identificador, lo podemos
utilizar como de la misma forma que invocamos habitualmente a una
función:

<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="c1">; ⇒ 9</span>
</code></pre></div>

No es necesario un identificador para invocar a una función; podemos
crear la función con una expresión lambda e invocar a la función
anónima recién creada:

<div class="highlight"><pre><span></span><code><span class="p">((</span><span class="k">lambda</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">x</span><span class="p">))</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="c1">; ⇒ 9</span>
</code></pre></div>

La llamada a `lambda` crea un procedimiento y el paréntesis a su
izquierda lo invoca con el parámetro 3:

<div class="highlight"><pre><span></span><code><span class="p">((</span><span class="k">lambda</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">x</span><span class="p">))</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="c1">; ⇒ (#&lt;procedure&gt; 3) ⇒ 9</span>
</code></pre></div>

Es importante remarcar que con `lambda` estamos creando una función en
*tiempo de ejecución*. Es código que creamos para su posterior
invocación.

Cada lenguaje de programación tiene su sintaxis propia de expresiones
lambda. Por ejemplo, las siguientes expresiones crean una función que
devuelve el cuadrado de un número:

**Java 8**

<div class="highlight"><pre><span></span><code><span class="n">Integer</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="p">{</span><span class="n">x</span><span class="o">*</span><span class="n">x</span><span class="p">}</span>
</code></pre></div>

**Scala**

<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="nc">Int</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="n">x</span><span class="o">*</span><span class="n">x</span><span class="p">}</span>
</code></pre></div>

**Objective C**

<div class="highlight"><pre><span></span><code><span class="o">^</span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">   </span><span class="n">x</span><span class="o">*</span><span class="n">x</span>
<span class="p">};</span>
</code></pre></div>

**Swift**

<div class="highlight"><pre><span></span><code><span class="p">{</span> <span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Int</span> <span class="k">in</span> <span class="k">return</span> <span class="n">x</span><span class="o">*</span><span class="n">x</span> <span class="p">}</span>
</code></pre></div>

#### 5.1.3. Identificadores y funciones

Tras conocer `lambda` ya podemos explicarnos por qué cuando escribimos
en el intérprete de Scheme el nombre de cualquier función, se evalúa a un
*procedure*:

<div class="highlight"><pre><span></span><code><span class="nb">+</span><span class="w"> </span><span class="c1">; ⇒ &lt;procedure:+&gt;</span>
<span class="nb">append</span><span class="w"> </span><span class="c1">; ⇒ #&lt;procedure:append&gt;</span>
</code></pre></div>

El identificador se evalúa y devuelve el *objeto función* al que está
ligado. En Scheme los nombres de las funciones son realmente símbolos
a los que están ligados *objetos de tipo función*.

Podemos comprobar también de esta manera que `and` y `or` no son
funciones. Si escribimos `and` o `or` e intentamos evaluar cualquiera
de los dos símbolos, veremos que Scheme devuelve un error:

<div class="highlight"><pre><span></span><code><span class="k">and</span>
<span class="c1">; and: bad syntax in: and</span>
<span class="k">or</span><span class="w"> </span>
<span class="c1">; or: bad syntax in: or</span>
</code></pre></div>

Podemos asignar funciones ya existentes a nuevos identificadores
usando `define`, como en el ejemplo siguiente:

<div class="highlight"><pre><span></span><code><span class="nb">+</span><span class="w"> </span><span class="c1">; ⇒ &lt;procedure:+&gt;</span>
<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">suma</span><span class="w"> </span><span class="nb">+</span><span class="p">)</span>
<span class="p">(</span><span class="n">suma</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="w"> </span><span class="c1">; ⇒ 10</span>
</code></pre></div>

Es muy importante darse cuenta que la expresión `(define suma +)` se
evalúa de forma idéntica a `(define y x)`. Primero se evalúa el
identificador `+`, que devuelve el *objeto función* suma, que se
asigna a la variable `suma`. El resultado final es que tanto `+` como
`suma` tienen como valor el mismo procedimiento:

<img src="imagenes/suma.png" width="100px"/>

La forma especial `define` para definir una función no es más que
*azucar sintáctico*.

<div class="highlight"><pre><span></span><code>(define (&lt;nombre&gt; &lt;args&gt;)
    &lt;cuerpo&gt;)
</code></pre></div>

siempre se convierte internamente en:

<div class="highlight"><pre><span></span><code>(define &lt;nombre&gt; 
    (lambda (&lt;args&gt;)
        &lt;cuerpo&gt;))
</code></pre></div>

Por ejemplo

<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">cuadrado</span><span class="w"> </span><span class="n">x</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">x</span><span class="p">))</span>
</code></pre></div>

es equivalente a:

<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">cuadrado</span><span class="w"> </span>
<span class="w">    </span><span class="p">(</span><span class="k">lambda</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">x</span><span class="p">)))</span>
</code></pre></div>

#### 5.1.4. Predicado `procedure?`

Podemos comprobar si algo es una función utilizando el predicado de
Scheme `procedure?`.

Por ejemplo:

<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="nb">procedure?</span><span class="w"> </span><span class="p">(</span><span class="k">lambda</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">x</span><span class="p">)))</span><span class="w"> </span><span class="c1">; ⇒ #t</span>
<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">suma</span><span class="w"> </span><span class="nb">+</span><span class="p">)</span>
<span class="p">(</span><span class="nb">procedure?</span><span class="w"> </span><span class="n">suma</span><span class="p">)</span><span class="w"> </span><span class="c1">; ⇒ #t</span>
<span class="p">(</span><span class="nb">procedure?</span><span class="w"> </span><span class="o">&#39;</span><span class="ss">+</span><span class="p">)</span><span class="w"> </span><span class="c1">; ⇒ #f</span>
</code></pre></div>

Hemos visto que las funciones pueden asignarse a variables. También
cumplen las otras condiciones necesarias para ser consideradas objetos
de primera clase.

### 5.2. Funciones argumentos de otras funciones 

Hemos visto ya un ejemplo de cómo pasar una función como parámetro de
otra. Veamos algún otro.

Por ejemplo, podemos definir la función `aplica` que recibe una
función en el parámetro `func` y dos valores en los parámetros `x` e
`y` y devuelve el resultado de invocar a la función que pasamos como
parámetro con `x` e `y`. La función que se pase como parámetro debe
tener dos argumentos

Para realizar la invocación a la función que se pasa como parámetro
basta con usar `func` como su nombre. La función se ha ligado al
nombre `func` en el momento de la invocación a `aplica`, de la misma
forma que los argumentos se ligan a los parámetros `x` e `y`:

<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">aplica</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="p">)</span>
<span class="w">   </span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="p">))</span>
</code></pre></div>

Algunos ejemplos de invocación, usando funciones primitivas, funciones
definidas y expresiones lambda:

<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="n">aplica</span><span class="w"> </span><span class="nb">+</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="c1">; ⇒ 5</span>
<span class="p">(</span><span class="n">aplica</span><span class="w"> </span><span class="nb">*</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="mi">5</span><span class="p">)</span><span class="w"> </span><span class="c1">; ⇒ 10</span>
<span class="p">(</span><span class="n">aplica</span><span class="w"> </span><span class="nb">string-append</span><span class="w"> </span><span class="s2">&quot;hola&quot;</span><span class="w"> </span><span class="s2">&quot;adios&quot;</span><span class="p">)</span><span class="w"> </span><span class="c1">; ⇒ &quot;holaadios&quot;</span>

<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">string-append-con-guion</span><span class="w"> </span><span class="n">s1</span><span class="w"> </span><span class="n">s2</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="nb">string-append</span><span class="w"> </span><span class="n">s1</span><span class="w"> </span><span class="s2">&quot;-&quot;</span><span class="w"> </span><span class="n">s2</span><span class="p">))</span>

<span class="p">(</span><span class="n">aplica</span><span class="w"> </span><span class="n">string-append-con-guion</span><span class="w"> </span><span class="s2">&quot;hola&quot;</span><span class="w"> </span><span class="s2">&quot;adios&quot;</span><span class="p">)</span><span class="w"> </span><span class="c1">; ⇒ &quot;hola-adios&quot;</span>

<span class="p">(</span><span class="n">aplica</span><span class="w"> </span><span class="p">(</span><span class="k">lambda</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">sqrt</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="n">y</span><span class="p">))))</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="w"> </span><span class="c1">; ⇒ 5</span>
</code></pre></div>

Otro ejemplo, la función `aplica-2` que toma dos funciones `f` y `g` y
un argumento `x` y devuelve el resultado de aplicar `f` a lo que
devuelve la invocación de `g` con `x`:

<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">aplica-2</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">g</span><span class="w"> </span><span class="n">x</span><span class="p">)</span>
<span class="w">   </span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="p">(</span><span class="n">g</span><span class="w"> </span><span class="n">x</span><span class="p">)))</span>

<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">suma-5</span><span class="w"> </span><span class="n">x</span><span class="p">)</span>
<span class="w">   </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="mi">5</span><span class="p">))</span>
<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">doble</span><span class="w"> </span><span class="n">x</span><span class="p">)</span>
<span class="w">   </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">x</span><span class="p">))</span>
<span class="p">(</span><span class="n">aplica-2</span><span class="w"> </span><span class="n">suma-5</span><span class="w"> </span><span class="n">doble</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="c1">; ⇒ 11</span>
</code></pre></div>

### 5.3. Función `apply` ###

La función `(apply funcion lista)` de Scheme permite aplicar una
función de aridad `n` a una lista de datos de n datos, haciendo que
cada uno de los datos se pasen a la función en orden como parámetros.

La función `apply` recibe una función y una lista y devuelve el
resultado de aplicar la función a los datos de la lista, tomándolos
como parámetros.

Por ejemplo, podemos aplicar la función suma a una lista de números:

<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="nb">apply</span><span class="w"> </span><span class="nb">+</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="p">))</span><span class="w"> </span><span class="c1">; ⇒ 10</span>
</code></pre></div>

Podemos pasar a `apply` una expresión lambda:

<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="nb">apply</span><span class="w"> </span><span class="p">(</span><span class="k">lambda</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="n">y</span><span class="p">)))</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">2</span><span class="w"> </span><span class="mi">5</span><span class="p">))</span><span class="w"> </span><span class="c1">; ⇒ 12</span>
</code></pre></div>

La lista que pasamos como argumento de `apply` debe tener tantos
elementos como parámetros tenga la función que aplicamos. En caso
contrario, se produce un error:

<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="nb">apply</span><span class="w"> </span><span class="nb">cons</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="ss">a</span><span class="w"> </span><span class="ss">b</span><span class="w"> </span><span class="ss">c</span><span class="p">))</span><span class="w"> </span><span class="c1">; ⇒ error</span>
<span class="n">cons:</span><span class="w"> </span><span class="n">arity</span><span class="w"> </span><span class="n">mismatch</span><span class="c1">;</span>
<span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">expected</span><span class="w"> </span><span class="n">number</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">arguments</span><span class="w"> </span><span class="n">does</span><span class="w"> </span><span class="nb">not</span><span class="w"> </span><span class="k">match</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">given</span><span class="w"> </span><span class="n">number</span>
<span class="w">  </span><span class="n">expected:</span><span class="w"> </span><span class="mi">2</span>
<span class="w">  </span><span class="n">given:</span><span class="w"> </span><span class="mi">3</span>
<span class="w">  </span><span class="n">arguments...:</span>
</code></pre></div>

La forma correcta de hacerlo:

<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="nb">apply</span><span class="w"> </span><span class="nb">cons</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="ss">a</span><span class="w"> </span><span class="ss">b</span><span class="p">))</span><span class="w"> </span><span class="c1">; ⇒ (a . b)</span>
</code></pre></div>

#### 5.3.1. Función `apply` y funciones recursivas ####

Usando `apply` podemos definir funciones recursivas con número
variable de argumentos.

##### Ejemplo `suma-nums` #####

Por ejemplo, supongamos que queremos definir la función `suma-nums` que suma un
número variable de argumentos:

<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="n">suma-nums</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="c1">; ⇒ 18</span>
</code></pre></div>

¿Podríamos definir `suma-nums` de forma recursiva? Debería tener la siguiente
forma:

<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">suma-nums</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="n">args</span><span class="p">)</span>
<span class="w">   </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">null?</span><span class="w"> </span><span class="n">args</span><span class="p">)</span>
<span class="w">       </span><span class="mi">0</span>
<span class="w">       </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">suma-nums</span><span class="w"> </span><span class="n">....</span><span class="p">))))</span>
</code></pre></div>

La cuestión está en cómo hacer la llamada recursiva. Supongamos que llamamos a
la función principal con el ejemplo anterior. Al ser `suma-nums` una función con
número variable de argumentos, la llamada recursiva habría que hacerla con los
números 5, 10, 1 como argumentos.

<div class="highlight"><pre><span></span><code>(suma-nums 2 5 10 1) =&gt;
(+ 2 (suma-nums 5 10 1))
</code></pre></div>

Y, sin embargo, lo que tenemos en `args` es una lista de números. No podemos
hacer la llamada recursiva con `(rest args)` porque `suma-nums` no recibe una
lista como argumento, sino un número variable de argumentos. 

Tenemos que conseguir "desempaquetar" los números de la lista `(5 10 1)` para
llamar a la recursión poniéndolos como argumentos de `suma-nums`: `(suma-nums 5
10 1)`.

La solución es usar `apply`:

<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">suma-nums</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="n">args</span><span class="p">)</span>
<span class="w">   </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">null?</span><span class="w"> </span><span class="n">args</span><span class="p">)</span>
<span class="w">       </span><span class="mi">0</span>
<span class="w">       </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">apply</span><span class="w"> </span><span class="n">suma-nums</span><span class="w"> </span><span class="p">(</span><span class="nb">rest</span><span class="w"> </span><span class="n">args</span><span class="p">)))))</span>
</code></pre></div>

El uso de `apply` consigue hacer la llamada recursiva colocando como argumentos
de `suma-nums` todos los elementos del resto de la lista original.


##### Ejemplo `suma-parejas` #####

Otro ejemplo similar, supongamos que queremos definir la función `suma-parejas`
que suma un número variable de parejas:

<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="n">suma-parejas</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">3</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">5</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="mi">6</span><span class="p">))</span><span class="w"> </span><span class="c1">; ⇒ &#39;(9 . 12)</span>
</code></pre></div>

Recordemos la definición de la función que suma dos parejas:

<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">suma-pareja</span><span class="w"> </span><span class="n">p1</span><span class="w"> </span><span class="n">p2</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="p">(</span><span class="nb">car</span><span class="w"> </span><span class="n">p1</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">car</span><span class="w"> </span><span class="n">p2</span><span class="p">))</span>
<span class="w">        </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="p">(</span><span class="nb">cdr</span><span class="w"> </span><span class="n">p1</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">cdr</span><span class="w"> </span><span class="n">p2</span><span class="p">))))</span>
</code></pre></div>

Podemos entonces construir la función `suma-parejas` que recibe una
lista de parejas (número variable de argumentos) llamando a `apply`
para que sume todas las parejas del resto de la lista. Y sumar
la pareja resultante con la primera pareja de la lista:

<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">suma-parejas</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="n">parejas</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">null?</span><span class="w"> </span><span class="n">parejas</span><span class="p">)</span>
<span class="w">      </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">0</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">      </span><span class="p">(</span><span class="n">suma-pareja</span><span class="w"> </span><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="n">parejas</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">apply</span><span class="w"> </span><span class="n">suma-parejas</span><span class="w"> </span><span class="p">(</span><span class="nb">rest</span><span class="w"> </span><span class="n">parejas</span><span class="p">)))))</span>
</code></pre></div>

Al igual que antes, se trata de una llamada recursiva indirecta, porque se
invoca a la propia función `suma-parejas` no directamente, sino a través de
`apply`. Y `apply` consigue "desempaquetar" las parejas del resto de parejas y
pasárselas como argumentos a `suma-parejas`.

La siguiente imagen muestra una representación gráfica del
funcionamiento de esta recursión:

<img src="imagenes/suma-parejas-apply.png" width="600px"/>


### 5.4. Generalización ###

La posibilidad de pasar funciones como parámetros de otras es una
poderosa herramienta de abstracción. Nos va a permitir diseñar
funciones más genéricas. 

Veamos un ejemplo. Supongamos que queremos calcular el sumatorio de
`a` hasta `b`:

<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">sum-x</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="p">)</span>
<span class="w">        </span><span class="mi">0</span>
<span class="w">        </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="p">(</span><span class="n">sum-x</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="n">b</span><span class="p">))))</span>

<span class="p">(</span><span class="n">sum-x</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span><span class="w"> </span><span class="c1">; ⇒ 55</span>
</code></pre></div>

Supongamos ahora que queremos calcular el sumatorio de `a` hasta `b`
sumando los números al cuadrado:

<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">sum-cuadrado-x</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="p">)</span>
<span class="w">        </span><span class="mi">0</span>
<span class="w">        </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">sum-cuadrado-x</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="n">b</span><span class="p">))))</span>

<span class="p">(</span><span class="n">sum-cuadrado-x</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span><span class="w"> </span><span class="c1">; ⇒ 385</span>
</code></pre></div>

Y el sumatorio de `a` hasta `b` sumando los cubos:

<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">sum-cubo-x</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="p">)</span>
<span class="w">        </span><span class="mi">0</span>
<span class="w">        </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">sum-cubo-x</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="n">b</span><span class="p">))))</span>

<span class="p">(</span><span class="n">sum-cubo-x</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span><span class="w"> </span><span class="c1">; ⇒ 3025</span>
</code></pre></div>

Vemos que el código de las tres funciones anteriores es muy similar,
cada función la podemos obtener haciendo un *copy-paste* de otra
previa. Lo único que cambia es la función a aplicar a cada número de
la serie.

Siempre que hagamos *copy-paste* al programar tenemos que empezar a
sospechar que no estamos generalizando suficientemente el código. Un
*copy-paste* arrastra también *bugs* y obliga a realizar múltiples
modificaciones del código cuando en el futuro tengamos que cambiar
cosas.

La posibilidad de pasar una función como parámetro viene a nuestra
ayuda para generalizar el código anterior. En este caso, lo único que
cambia en las tres funciones anteriores es la función a aplicar a los
números de la serie. En primer caso no se hace nada, en el segundo se
eleva al cuadrado y en el tercer caso al cubo.

Podemos tomar esa función como un parámetro adicional y definir una
función genérica `sum-f-x` que generaliza las tres funciones
anteriores. Tendríamos el sumatorio desde `a` hasta `b` de `f(x)`:

<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">sum-f-x</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="p">)</span>
<span class="w">        </span><span class="mi">0</span>
<span class="w">        </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">sum-f-x</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="n">b</span><span class="p">))))</span>
</code></pre></div>

Las funciones anteriores son casos particulares de esta función que
las generaliza. Por ejemplo, para calcular el sumatorio desde 1 hasta
10 de `x` al cubo:

<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">cubo</span><span class="w"> </span><span class="n">x</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">x</span><span class="p">))</span>

<span class="p">(</span><span class="n">sum-f-x</span><span class="w"> </span><span class="n">cubo</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span><span class="w"> </span><span class="c1">; ⇒ 3025</span>
</code></pre></div>


También podemos utilizar una expresión lambda en la invocación a
`sum-f` que construya la función que queremos aplicar a cada
número. Por ejemplo, podemos sumar la expresión (n/(n-1)) para todos
los números del 2 al 100:

<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="n">sum-f-x</span><span class="w"> </span><span class="p">(</span><span class="k">lambda</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">/</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="p">(</span><span class="nb">-</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="mi">1</span><span class="p">)))</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">100</span><span class="p">)</span>
</code></pre></div>

Veremos más adelante muchos más ejemplos de funciones pasadas como
parámetros y de la generalidad que permite este patrón, cuando
estudiemos las funciones de orden superior.

### 5.5. Funciones que devuelven funciones

Cualquier objeto de primera clase puede ser devuelto por una
función; enteros, booleanos, parejas, etc. son objetos primitivos y
podemos definir funciones que los devuelven.

En el paradigma funcional lo mismo sucede con las funciones. Podemos
definir una función que cuando se invoque construya otra función y la
devuelva como resultado. 

Esta es una de la características más importantes que diferencia los
lenguajes de programación funcionales de otros que no lo
son. En lenguajes como C, C++ o Java (antes de Java 8) no es posible
hacer esto.

Para devolver una función en Scheme debemos usar la forma especial
`lambda` en el cuerpo de una función. Así, cuando se invoca a esta
función se evalúa `lambda` y se devuelve la función resultante. Es una
función que creamos en tiempo de ejecución, durante la evaluación de
la función principal.

La función que se devuelve se denomina **clausura**
([Wikipedia](https://es.wikipedia.org/wiki/Clausura_(informática))). Y
decimos que la función que ha construido la clausura es una **función
constructora**.


#### 5.5.1. Función `construye-sumador`

Vamos a empezar con un ejemplo muy sencillo. Definimos una función
constructora que crea en su ejecución una función que suma
`k` a un número:

<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">construye-sumador</span><span class="w"> </span><span class="n">k</span><span class="p">)</span>
<span class="w">   </span><span class="p">(</span><span class="k">lambda</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="w">       </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">k</span><span class="p">)))</span>
</code></pre></div>

El cuerpo de la función `(construye-sumador k)` está formado por una
expresión lambda. Cuando se invoca a `construye-sumador` se evalúa
esta expresión lambda y se devuelve el procedimiento creado. 

En este caso se construye otra función de 1 argumento que suma `k` al
argumento. 

Por ejemplo, podemos invocar a `construye-sumador` pasando 10 como parámetro:

<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="n">construye-sumador</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span><span class="w"> </span><span class="c1">; ⇒ #&lt;procedure&gt;</span>
</code></pre></div>

Como hemos dicho, se devuelve un procedimiento, una función. Esta
función devuelta debe invocarse con un argumento y devolverá el
resultado de sumar 10 a ese argumento:

<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="p">(</span><span class="n">construye-sumador</span><span class="w"> </span><span class="mi">10</span><span class="p">))</span>
<span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="c1">; ⇒ 13</span>
</code></pre></div>

También podemos invocar directamente a la función que devuelve la
función constructora, sin guardarla en una variable:

<div class="highlight"><pre><span></span><code><span class="p">((</span><span class="n">construye-sumador</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="c1">; ⇒ 13</span>
</code></pre></div>

Dependiendo del parámetro que le pasemos a la función constructora
obtendremos una función sumadora que sume un número u otro. Por
ejemplo para obtener una función sumadora que suma 100:

<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">g</span><span class="w"> </span><span class="p">(</span><span class="n">construye-sumador</span><span class="w"> </span><span class="mi">100</span><span class="p">))</span>
<span class="p">(</span><span class="n">g</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="c1">; ⇒ 103</span>
</code></pre></div>

¿Cómo funciona la clausura? ¿Por qué la invocación a `(g 3)`
devuelve 103?.

Aquí hay que apartarse bastante del modelo de evaluación de
sustitución que hemos visto y utilizar un nuevo modelo en el que se
tiene en cuenta los ámbitos de las variables.

No vamos a explicar en detalle este modelo, pero sí dar unas breves
pinceladas.

Recordemos la definición de `construye-sumador`:

<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">construye-sumador</span><span class="w"> </span><span class="n">k</span><span class="p">)</span>
<span class="w">   </span><span class="p">(</span><span class="k">lambda</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="w">       </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">k</span><span class="p">)))</span>
</code></pre></div>

Y supongamos que realizamos las siguientes invocaciones:

<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">g</span><span class="w"> </span><span class="p">(</span><span class="n">construye-sumador</span><span class="w"> </span><span class="mi">100</span><span class="p">))</span>
<span class="p">(</span><span class="n">g</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="c1">; ⇒ 103</span>
<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="p">(</span><span class="n">construye-sumador</span><span class="w"> </span><span class="mi">50</span><span class="p">))</span>
<span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="c1">; ⇒ 53</span>
</code></pre></div>

Podemos explicar lo que sucede en la evaluación de estas funciones de
la siguiente forma:

- Cuando invocamos a `construye-sumador` con un valor concreto para
  `k` (por  ejemplo 100), queda vinculado el valor de 100 al parámetro
  `k` en el ámbito local de la función.
- En este ámbito local la expresión lambda crea una función. Esta
  función creada en el ámbito local **captura** este ámbito local, con
  sus variables y sus valores (en este caso la variable `k` y su valor
  100).
- Cuando se invoca a la función desde fuera (cuando llamamos a `g` en
  el ejemplo) se ejecuta el cuerpo de la función `(+ x k)` con `x`
  valiendo el parámetro (3) y el valor de `k` se obtiene del ámbito
  capturado (100).
- En el caso de la segunda invocación a `construye-sumador` el valor
  del parámetro es 50 y se crea otro ámbito local en el que `k`
  vale 50. Ese valor es el capturado por la nueva clausura que crea la
  expresión lambda, que es devuelta por la función y guardada en la
  variable `f`.

La siguiente imagen muestra gráficamente la explicación anterior. Se
ve a la izquierda la ejecución del código y a la derecha el efecto que
esta ejecución tiene en la memoria, incluyendo los valores asociados a
las variables y los ámbitos locales creados en las distintas
invocaciones a las funciones.

<img src="imagenes/clausuras.png" width="700px"/>

El hecho de que función creada en el ámbito local capture este ámbito
es lo que hace que se denomine una **clausura** (del inglés
**closure**). La función _se cierra_ sobre el ámbito capturado y puede
utilizar sus variables.


#### 5.5.2. Función `construye-composicion` 

Otro ejemplo de una función que devuelve otra función es la función
siguiente `(construye-composicion f g)` que recibe dos funciones de un argumento
y devuelve otra función que realiza la composición de ambas:

<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">construye-composicion</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">g</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="k">lambda</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="w">        </span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="p">(</span><span class="n">g</span><span class="w"> </span><span class="n">x</span><span class="p">))))</span>
</code></pre></div>

La función devuelta invoca primero a `g` y el resultado se lo pasa a
`f`. Veamos un ejemplo. Supongamos que tenemos definidas la función
`cuadrado` y `doble` que calculan el cuadrado y el doble de un número
respectivamente. Podremos entonces llamar a `construye-composicion` con esas dos
funciones para construir otra función que primero calcule el cuadrado y
después el doble de una número:

<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">h</span><span class="w"> </span><span class="p">(</span><span class="n">construye-composicion</span><span class="w"> </span><span class="n">doble</span><span class="w"> </span><span class="n">cuadrado</span><span class="p">))</span>
</code></pre></div>

La variable `h` contiene la función devuelta por `construye-composicion`. Una
función de un argumento que devuelve el doble del cuadrado de un
número:

<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="n">h</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="w"> </span><span class="c1">; ⇒ 32</span>
</code></pre></div>


#### 5.5.3. Función `construye-segura`

Vamos a ver un último ejemplo en el que definimos una función
constructora que extiende funciones ya existentes.

Recordemos la función `lista-desde`:

<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">lista-desde</span><span class="w"> </span><span class="n">x</span><span class="p">)</span>
<span class="w">   </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">      </span><span class="o">&#39;</span><span class="p">()</span>
<span class="w">      </span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="p">(</span><span class="n">lista-desde</span><span class="w"> </span><span class="p">(</span><span class="nb">-</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="mi">1</span><span class="p">)))))</span>
</code></pre></div>

Un problema de la función anterior es que si le pasamos un
número negativo entra en un bucle infinito.

Definimos la función `(construye-segura condicion f) ` que recibe dos
funciones: un predicado y otra función, ambos de 1 argumento. Devuelve
otra función en la que sólo se llamará a `f` si el argumento cumple la
`condicion`.

<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">construye-segura</span><span class="w"> </span><span class="n">condicion</span><span class="w"> </span><span class="n">f</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="k">lambda</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">condicion</span><span class="w"> </span><span class="n">x</span><span class="p">)</span>
<span class="w">        </span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="n">x</span><span class="p">)</span>
<span class="w">        </span><span class="o">&#39;</span><span class="ss">error</span><span class="p">)))</span>
</code></pre></div>

La función construye una función anónima de un argumento `x` (igual
que `f`) en cuyo cuerpo se comprueba si el argumento cumple la
condición y sólo en ese caso se llama a `f`.

Podemos entonces construir una función segura a partir de la función
`lista-desde` en la que se devuelva `error` si el argumento es un
número negativo:

<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">lista-desde-segura</span>
<span class="w">   </span><span class="p">(</span><span class="n">construye-segura</span><span class="w"> </span><span class="p">(</span><span class="k">lambda</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">&gt;=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="mi">0</span><span class="p">))</span><span class="w"> </span><span class="n">lista-desde</span><span class="p">))</span>
<span class="p">(</span><span class="n">lista-desde-segura</span><span class="w"> </span><span class="mi">8</span><span class="p">)</span><span class="w"> </span><span class="c1">; ⇒ (8 7 6 5 4 3 2 1)</span>
<span class="p">(</span><span class="n">lista-desde-segura</span><span class="w"> </span><span class="mi">-1</span><span class="p">)</span><span class="w"> </span><span class="c1">; ⇒ error</span>
</code></pre></div>

Podríamos usar `construye-segura` con cualquier función de 1 argumento
que queramos hacer segura. Por ejemplo, la función `sqrt`:

<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">sqrt-segura</span><span class="w"> </span><span class="p">(</span><span class="n">construye-segura</span><span class="w"> </span><span class="p">(</span><span class="k">lambda</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">&gt;=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="mi">0</span><span class="p">))</span><span class="w"> </span><span class="nb">sqrt</span><span class="p">))</span>
<span class="p">(</span><span class="n">sqrt-segura</span><span class="w"> </span><span class="mi">100</span><span class="p">)</span><span class="w"> </span><span class="c1">; ⇒ 10</span>
<span class="p">(</span><span class="n">sqrt-segura</span><span class="w"> </span><span class="mi">-100</span><span class="p">)</span><span class="w"> </span><span class="c1">; ⇒ error</span>
</code></pre></div>

La potencia de las funciones constructoras viene del hecho de que es
posible crear nuevas funciones en tiempo de ejecución. No es necesario
conocer las condiciones y las características de estas nuevas
funciones a priori, cuando estamos compilando nuestro programa. Sino
que pueden depender de datos obtenidos del usuario o de otros módulos
del programa en tiempo de ejecución.

Por ejemplo, la condición de `construye-segura` podría contener
valores obtenidos en tiempo de ejecución, de forma que solo se llamara
a la función que queremos hacer segura si el número está en un rango
definido esos valores:

<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="n">construye-segura</span><span class="w"> </span><span class="p">(</span><span class="k">lambda</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">and</span><span class="w"> </span><span class="p">(</span><span class="nb">&gt;=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">limite-inf</span><span class="p">)</span>
<span class="w">                                   </span><span class="p">(</span><span class="nb">&lt;=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">limite-sup</span><span class="p">)))</span><span class="w"> </span><span class="n">f</span><span class="p">)</span><span class="err">)</span>
</code></pre></div>


### 5.6. Funciones en estructuras de datos

La última característica de los tipos de primera clase es que pueden
formar parte de tipos de datos compuestos, como listas.

Para construir una lista de funciones debemos llamar a `list` con las
funciones:

<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">cuadrado</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">x</span><span class="p">))</span>
<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">suma-1</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="mi">1</span><span class="p">))</span>
<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">doble</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="mi">2</span><span class="p">))</span>

<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">lista</span><span class="w"> </span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="n">cuadrado</span><span class="w"> </span><span class="n">suma-1</span><span class="w"> </span><span class="n">doble</span><span class="p">))</span>
<span class="n">lista</span><span class="w"> </span>
<span class="c1">; ⇒ (#&lt;procedure:cuadrado&gt;  #&lt;procedure:suma-1&gt;  #&lt;procedure:doble&gt;)</span>
</code></pre></div>

También podemos definir las funciones con expresiones lambda. Por
ejemplo, podemos añadir a la lista una función que suma 5 a un número:


<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">lista2</span><span class="w"> </span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="p">(</span><span class="k">lambda</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="mi">5</span><span class="p">))</span><span class="w"> </span><span class="n">lista</span><span class="p">))</span>
<span class="n">lista2</span><span class="w"> </span>
<span class="c1">; ⇒ (#&lt;procedure&gt; #&lt;procedure:cuadrado&gt; #&lt;procedure:suma-1&gt; #&lt;procedure:doble&gt;)</span>
</code></pre></div>

Una vez creada una lista con funciones, ¿cómo podemos invocar a alguna
de ellas?. Debemos tratarlas de la misma forma que tratamos cualquier
otro dato guardado en la lista, las recuperamos con las funciones
`first` o `list-ref` y las invocamos. 

Por ejemplo, para invocar a la primera función de `lista2`:

<div class="highlight"><pre><span></span><code><span class="p">((</span><span class="nb">first</span><span class="w"> </span><span class="n">lista2</span><span class="p">)</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span><span class="w"> </span><span class="c1">; ⇒ 15</span>
</code></pre></div>

O a la tercera:

<div class="highlight"><pre><span></span><code><span class="p">((</span><span class="nb">list-ref</span><span class="w"> </span><span class="n">lista2</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span><span class="w"> </span><span class="c1">; ⇒ 11</span>
</code></pre></div>

#### 5.6.1. Funciones que trabajan con listas de funciones

Veamos un ejemplo de una función `(aplica-funcs lista-funcs x)` que
recibe una lista de funciones en el parámetro `lista-funcs` y las
aplica todas **de derecha a izquierda** al número que pasamos en el
parámetro `x`.

Por ejemplo, supongamos la lista anterior, que contiene las funciones
`cuadrado`, `cubo` y `suma-1`:

<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">lista</span><span class="w"> </span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="n">cuadrado</span><span class="w"> </span><span class="n">cubo</span><span class="w"> </span><span class="n">suma-1</span><span class="p">))</span>
</code></pre></div>

la llamada a `(aplica-funcs lista 5)` debería devolver el resultado de
aplicar primero `suma-1` a 5, después `cubo` al resultado y después
`cuadrado`:

<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="n">cuadrado</span><span class="w"> </span><span class="p">(</span><span class="n">cubo</span><span class="w"> </span><span class="p">(</span><span class="n">suma-1</span><span class="w"> </span><span class="mi">5</span><span class="p">))</span><span class="w"> </span><span class="c1">; ⇒ 46656</span>
</code></pre></div>

Para implementar `aplica-funcs` tenemos que usar una recursión. Si
vemos el ejemplo, podemos comprobar que es sencillo definir el caso
general:

<div class="highlight"><pre><span></span><code>(aplica-funcs (cuadrado cubo suma-1) 5) = 
(cuadrado (aplica-funcs (cubo suma-1) 5)) =
(cuadrado 216) = 46656
</code></pre></div>

El caso general de la recursión de la función `aplica-funcs` se define
entonces como:

<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">aplica-funcs</span><span class="w"> </span><span class="n">lista-funcs</span><span class="w"> </span><span class="n">x</span><span class="p">)</span>
<span class="w">    </span><span class="c1">; falta el caso base</span>
<span class="w">    </span><span class="p">((</span><span class="nb">first</span><span class="w"> </span><span class="n">lista-funcs</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">aplica-funcs</span><span class="w"> </span><span class="p">(</span><span class="nb">rest</span><span class="w"> </span><span class="n">lista-funcs</span><span class="p">)</span><span class="w"> </span><span class="n">x</span><span class="p">)))</span>
</code></pre></div>

El caso base sería en el que la lista de funciones es vacía, en cuyo
caso se devuelve el propio número:

<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">null?</span><span class="w"> </span><span class="n">lista-funcs</span><span class="p">)</span><span class="w"> </span><span class="c1">; la lista de funciones está vacía</span>
<span class="w">    </span><span class="n">x</span><span class="w"> </span><span class="c1">; devolvemos el propio número</span>
<span class="w">    </span><span class="k">...</span>
</code></pre></div>

La implementación completa es:

<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">aplica-funcs</span><span class="w"> </span><span class="n">lista-funcs</span><span class="w"> </span><span class="n">x</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">null?</span><span class="w"> </span><span class="n">lista-funcs</span><span class="p">)</span>
<span class="w">        </span><span class="n">x</span>
<span class="w">        </span><span class="p">((</span><span class="nb">first</span><span class="w"> </span><span class="n">lista-funcs</span><span class="p">)</span>
<span class="w">            </span><span class="p">(</span><span class="n">aplica-funcs</span><span class="w"> </span><span class="p">(</span><span class="nb">rest</span><span class="w"> </span><span class="n">lista-funcs</span><span class="p">)</span><span class="w"> </span><span class="n">x</span><span class="p">))))</span>
</code></pre></div>

Un ejemplo de uso:

<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">lista-funcs</span><span class="w"> </span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="p">(</span><span class="k">lambda</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">x</span><span class="p">))</span>
<span class="w">                          </span><span class="p">(</span><span class="k">lambda</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">x</span><span class="p">))</span>
<span class="w">                          </span><span class="p">(</span><span class="k">lambda</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="mi">1</span><span class="p">))))</span>
<span class="p">(</span><span class="n">aplica-funcs</span><span class="w"> </span><span class="n">lista-funcs</span><span class="w"> </span><span class="mi">5</span><span class="p">)</span><span class="w"> </span><span class="c1">; ⇒ 46656</span>
</code></pre></div>


### 5.7. Funciones de orden superior

Llamamos funciones de orden superior (*higher order functions* en
inglés) a las funciones que toman otras como parámetro o devuelven
otra función. Permiten generalizar soluciones con un alto grado de
abstracción.

Ya hemos visto algunas funciones de orden superior, unas construidas
por nostros y otras propias de Scheme, como `apply`.

Además de `apply`, los lenguajes de programación funcional como
Scheme, Scala o Java 8 tienen ya predefinidas algunas otras funciones
de orden superior que trabajan con listas. Estas funciones permiten
definir operaciones sobre las listas de una forma muy concisa y
compacta. Son muy usadas, porque también se pueden utilizar sobre
_streams_ de datos obtenidos en operaciones de entrada/salida (por
ejemplo, datos JSON resultantes de una petición HTTP).

Vamos a ver las funciones más importantes, su uso y su implementación.

- `map`
- `filter`
- `exists?` 
- `for-all?` 
- `foldr` y `foldl`

Después de explicar estas funciones terminaremos con un ejemplo de su
aplicación en el que comprobaremos cómo la utilización de funciones de
orden superior es una excelente herramienta de la programación
funcional que permite hacer código muy conciso y expresivo.

La combinación de funciones de nivel superior con listas es una de las
características más potentes de la programación funcional.

#### 5.7.1. Función `map`

Comenzamos con la función `map`. La palabra `map` viene del inglés
`mapping` o transformación. Se trata de una función que **transforma**
una lista aplicando a todos sus elementos una función de
transformación que se pasa como parámetro.

En concreto, la función recibe otra función y una lista:

<div class="highlight"><pre><span></span><code>(map transforma lista) -&gt; lista
</code></pre></div>

Y devuelve la lista resultante de aplicar la función a todos los
elementos de la lista.

La función de transformación recibe como argumentos elementos de la
lista y devuelve el resultado de transformar ese elemento.

<div class="highlight"><pre><span></span><code>(transforma elemento) -&gt; elemento
</code></pre></div>


Por ejemplo:

<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="n">cuadrado</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="mi">5</span><span class="p">))</span><span class="w"> </span><span class="c1">; ⇒ (1 4 9 16 25)</span>
</code></pre></div>

La lista resultante es el resultado de construir una lista nueva
aplicando la función `cuadrado` a todos los elementos de la lista
original.

La función de transformación debe ser compatible con los elementos de
la lista original. Por ejemplo, si la lista es una lista de parejas,
la función de transformación debe recibir una pareja. Veamos un
ejemplo de este caso, en el que a partir de una lista de parejas
obtenemos una lista con las sumas de cada pareja:

<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">suma-pareja</span><span class="w"> </span><span class="n">pareja</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="p">(</span><span class="nb">car</span><span class="w"> </span><span class="n">pareja</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">cdr</span><span class="w"> </span><span class="n">pareja</span><span class="p">)))</span>

<span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="n">suma-pareja</span><span class="w"> </span><span class="o">&#39;</span><span class="p">((</span><span class="mi">2</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="mi">3</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="mi">6</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="mi">5</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="mi">3</span><span class="p">)))</span><span class="w"> </span><span class="c1">; ⇒ (6 9 8)</span>
</code></pre></div>

También podríamos hacerlo con una expresión lambda:

<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="p">(</span><span class="k">lambda</span><span class="w"> </span><span class="p">(</span><span class="n">pareja</span><span class="p">)</span>
<span class="w">         </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="p">(</span><span class="nb">car</span><span class="w"> </span><span class="n">pareja</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">cdr</span><span class="w"> </span><span class="n">pareja</span><span class="p">)))</span><span class="w"> </span><span class="o">&#39;</span><span class="p">((</span><span class="mi">2</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="mi">3</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="mi">6</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="mi">5</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="mi">3</span><span class="p">)))</span><span class="w"> </span>
<span class="c1">; ⇒ (6 9 8)</span>
</code></pre></div>


Un último ejemplo, en el que usamos `map` para transformar una lista
de símbolos en una lista con sus longitudes:

<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="p">(</span><span class="k">lambda</span><span class="w"> </span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="w"> </span>
<span class="w">        </span><span class="p">(</span><span class="nb">string-length</span><span class="w"> </span><span class="p">(</span><span class="nb">symbol-&gt;string</span><span class="w"> </span><span class="n">s</span><span class="p">)))</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="ss">Esta</span><span class="w"> </span><span class="ss">es</span><span class="w"> </span><span class="ss">una</span><span class="w"> </span><span class="ss">lista</span><span class="w"> </span><span class="ss">de</span><span class="w"> </span><span class="ss">símbolos</span><span class="p">))</span>
<span class="c1">; ⇒ (4 2 3 5 2 8)</span>
</code></pre></div>

##### 5.7.1.1. Implementación de `map`

¿Cómo se podría implementar `map` de forma recursiva?
Definimos la función `mi-map`. La implementación es la siguiente:

<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">mi-map</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">lista</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">null?</span><span class="w"> </span><span class="n">lista</span><span class="p">)</span>
<span class="w">        </span><span class="o">&#39;</span><span class="p">()</span>
<span class="w">        </span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="n">lista</span><span class="p">))</span>
<span class="w">              </span><span class="p">(</span><span class="n">mi-map</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="p">(</span><span class="nb">rest</span><span class="w"> </span><span class="n">lista</span><span class="p">)))))</span>
</code></pre></div>


##### 5.7.1.2. Función `map` con más de una lista


La función `map` puede recibir un número variable de listas, todas
ellas de la misma longitud:

<div class="highlight"><pre><span></span><code>(map transforma lista_1 ... lista_n) -&gt; lista
</code></pre></div>

En este caso la función de transforma debe recibir tantos argumentos
como listas recibe `map`:

<div class="highlight"><pre><span></span><code>(transforma dato_1 ... dato_n) -&gt; dato
</code></pre></div>

La función `map` aplica `transforma` a los elementos cogidos de las n
listas y construye así la lista resultante.

Ejemplos:

<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="nb">+</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">10</span><span class="w"> </span><span class="mi">20</span><span class="w"> </span><span class="mi">30</span><span class="p">))</span><span class="w"> </span><span class="c1">; ⇒ (11 22 33)</span>
<span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="nb">cons</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">10</span><span class="w"> </span><span class="mi">20</span><span class="w"> </span><span class="mi">30</span><span class="p">))</span><span class="w"> </span><span class="c1">; ⇒ ((1 . 10) (2 . 20) (3 . 30))</span>
<span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="nb">&gt;</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">12</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">40</span><span class="p">)</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">20</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="mi">10</span><span class="p">))</span><span class="w"> </span><span class="c1">; ⇒ (#f #t #t)</span>

<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">mayor</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="p">))</span>
<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">mayor-de-tres</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">c</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="n">mayor</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="p">(</span><span class="n">mayor</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">c</span><span class="p">)))</span>

<span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="n">mayor-de-tres</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">10</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">20</span><span class="w"> </span><span class="mi">-1</span><span class="w"> </span><span class="mi">34</span><span class="p">)</span><span class="w"> </span>
<span class="w">                   </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">12</span><span class="w"> </span><span class="mi">89</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span>
<span class="w">                   </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">100</span><span class="w"> </span><span class="mi">-10</span><span class="w"> </span><span class="mi">23</span><span class="w"> </span><span class="mi">45</span><span class="w"> </span><span class="mi">8</span><span class="p">))</span>
<span class="c1">; ⇒ (100 3 23 89 34)</span>
</code></pre></div>

!!! Tip "Consejo"
    La función `map` recibe una lista de *n* elementos y devuelve otra
    de *n* elementos transformados.


#### 5.7.2. Función `filter`

Veamos otra función de orden superior que trabaja sobre listas.

La función `(filter predicado lista)` toma como parámetro un predicado
y una lista y devuelve como resultado los elementos de la lista que
cumplen el predicado.

<div class="highlight"><pre><span></span><code>(filter predicado lista) -&gt; lista
</code></pre></div>

La función `(predicado elem)` que usa `filter` recibe elementos de
la lista y devuelve `#t` o `#f`.

<div class="highlight"><pre><span></span><code>(predicado elem) -&gt; boolean
</code></pre></div>

Un ejemplo de uso:

<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="nb">filter</span><span class="w"> </span><span class="nb">even?</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="mi">6</span><span class="w"> </span><span class="mi">7</span><span class="w"> </span><span class="mi">8</span><span class="p">))</span><span class="w"> </span><span class="c1">; ⇒ (2 4 6 8)</span>
</code></pre></div>

Otro ejemplo: supongamos que queremos filtrar una lista de parejas de
números, devolviendo aquellas que parejas que cumplen que su parte
izquierda es mayor o igual que la derecha. Lo podríamos hacer con la
siguiente expresión:

<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="nb">filter</span><span class="w"> </span><span class="p">(</span><span class="k">lambda</span><span class="w"> </span><span class="p">(</span><span class="n">pareja</span><span class="p">)</span>
<span class="w">            </span><span class="p">(</span><span class="nb">&gt;=</span><span class="w"> </span><span class="p">(</span><span class="nb">car</span><span class="w"> </span><span class="n">pareja</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">cdr</span><span class="w"> </span><span class="n">pareja</span><span class="p">)))</span><span class="w"> </span>
<span class="w">        </span><span class="o">&#39;</span><span class="p">((</span><span class="mi">10</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="mi">2</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="mi">8</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="mi">10</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="mi">20</span><span class="p">)))</span>
<span class="c1">; ⇒ ((10 . 4) (8 . 8))</span>
</code></pre></div>

Y un último ejemplo: filtramos todos los símbolos con longitud menor
de 4.

<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="nb">filter</span><span class="w"> </span><span class="p">(</span><span class="k">lambda</span><span class="w"> </span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="w"> </span>
<span class="w">           </span><span class="p">(</span><span class="nb">&gt;=</span><span class="w"> </span><span class="p">(</span><span class="nb">string-length</span><span class="w"> </span><span class="p">(</span><span class="nb">symbol-&gt;string</span><span class="w"> </span><span class="n">s</span><span class="p">))</span><span class="w"> </span><span class="mi">4</span><span class="p">))</span>
<span class="w">           </span><span class="o">&#39;</span><span class="p">(</span><span class="ss">Esta</span><span class="w"> </span><span class="ss">es</span><span class="w"> </span><span class="ss">una</span><span class="w"> </span><span class="ss">lista</span><span class="w"> </span><span class="ss">de</span><span class="w"> </span><span class="ss">símbolos</span><span class="p">))</span>
<span class="c1">; ⇒ (Esta lista símbolos)</span>
</code></pre></div>


!!! Tip "Consejo"
    La función `filter` recibe una lista de *n* elementos y devuelve
    otra de con *n* o menos elementos originales filtrados por una
    condición.


##### 5.7.2.1. Implementación de `filter`

Podemos implementar la función `filter` de forma recursiva:

<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">mi-filter</span><span class="w"> </span><span class="n">pred</span><span class="w"> </span><span class="n">lista</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="k">cond</span>
<span class="w">    </span><span class="p">((</span><span class="nb">null?</span><span class="w"> </span><span class="n">lista</span><span class="p">)</span><span class="w"> </span><span class="o">&#39;</span><span class="p">())</span>
<span class="w">    </span><span class="p">((</span><span class="n">pred</span><span class="w"> </span><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="n">lista</span><span class="p">))</span><span class="w"> </span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="n">lista</span><span class="p">)</span>
<span class="w">                              </span><span class="p">(</span><span class="n">mi-filter</span><span class="w"> </span><span class="n">pred</span><span class="w"> </span><span class="p">(</span><span class="nb">rest</span><span class="w"> </span><span class="n">lista</span><span class="p">))))</span>
<span class="w">    </span><span class="p">(</span><span class="k">else</span><span class="w"> </span><span class="p">(</span><span class="n">mi-filter</span><span class="w"> </span><span class="n">pred</span><span class="w"> </span><span class="p">(</span><span class="nb">rest</span><span class="w"> </span><span class="n">lista</span><span class="p">)))))</span>
</code></pre></div>

#### 5.7.3. Función `exists?` 

La función de orden superior `exists?` recibe un predicado y una lista
y comprueba si algún elemento de la lista cumple ese predicado.

<div class="highlight"><pre><span></span><code>(exists? predicado lista) -&gt; boolean
</code></pre></div>

Igual que en `filter` el `predicado` recibe elementos de la lista y
devuelve `#t` o `#f`.

<div class="highlight"><pre><span></span><code>(predicado elem) -&gt; boolean
</code></pre></div>

La función `exists?` no está definida con este nombre en Racket,
aunque sí en Scheme. En Racket se llama `ormap`. Incorporamos su
definición al [fichero
`lpp.rkt`](https://raw.githubusercontent.com/domingogallardo/apuntes-lpp/master/src/lpp.rkt)
para poder usarla en las prácticas.

Ejemplo de uso:

<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="n">exists?</span><span class="w"> </span><span class="nb">even?</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="mi">6</span><span class="p">))</span><span class="w"> </span><span class="c1">; ⇒ #t</span>
<span class="p">(</span><span class="n">exists?</span><span class="w"> </span><span class="p">(</span><span class="k">lambda</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="w">             </span><span class="p">(</span><span class="nb">&gt;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="mi">10</span><span class="p">))</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="mi">8</span><span class="p">))</span><span class="w"> </span><span class="c1">; ⇒ #f</span>
</code></pre></div>

La implementación recursiva de `exists?` es la siguiente:

<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">exists?</span><span class="w"> </span><span class="n">predicado</span><span class="w"> </span><span class="n">lista</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">null?</span><span class="w"> </span><span class="n">lista</span><span class="p">)</span>
<span class="w">      </span><span class="no">#f</span>
<span class="w">      </span><span class="p">(</span><span class="k">or</span><span class="w"> </span><span class="p">(</span><span class="n">predicado</span><span class="w"> </span><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="n">lista</span><span class="p">))</span>
<span class="w">          </span><span class="p">(</span><span class="n">exists?</span><span class="w"> </span><span class="n">predicado</span><span class="w"> </span><span class="p">(</span><span class="nb">rest</span><span class="w"> </span><span class="n">lista</span><span class="p">)))))</span>
</code></pre></div>

#### 5.7.4. Función `for-all?`

La función de orden superior `for-all?` recibe un predicado y una lista
y comprueba que todos los elementos de la lista cumplen ese predicado.

La función tampoco está definida con este nombre en Racket, aunque
sí en Scheme. Al igual que `exists?`, incluimos su definición en el
[fichero `lpp.rkt`](https://raw.githubusercontent.com/domingogallardo/apuntes-lpp/master/src/lpp.rkt).

En Racket existe una función equivalente que se llama `andmap`.

Ejemplo de uso:

<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="n">for-all?</span><span class="w"> </span><span class="nb">even?</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">2</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="mi">6</span><span class="p">))</span><span class="w"> </span><span class="c1">; ⇒ #t</span>
<span class="p">(</span><span class="n">for-all?</span><span class="w"> </span><span class="p">(</span><span class="k">lambda</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="w">             </span><span class="p">(</span><span class="nb">&gt;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="mi">10</span><span class="p">))</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">12</span><span class="w"> </span><span class="mi">30</span><span class="w"> </span><span class="mi">50</span><span class="w"> </span><span class="mi">80</span><span class="p">))</span><span class="w"> </span><span class="c1">; ⇒ #t</span>
</code></pre></div>

La implementación recursiva de `for-all?` es la siguiente:

<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">for-all?</span><span class="w"> </span><span class="n">predicado</span><span class="w"> </span><span class="n">lista</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="k">or</span><span class="w"> </span><span class="p">(</span><span class="nb">null?</span><span class="w"> </span><span class="n">lista</span><span class="p">)</span>
<span class="w">      </span><span class="p">(</span><span class="k">and</span><span class="w"> </span><span class="p">(</span><span class="n">predicado</span><span class="w"> </span><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="n">lista</span><span class="p">))</span>
<span class="w">           </span><span class="p">(</span><span class="n">for-all?</span><span class="w"> </span><span class="n">predicado</span><span class="w"> </span><span class="p">(</span><span class="nb">rest</span><span class="w"> </span><span class="n">lista</span><span class="p">)))))</span>
</code></pre></div>

La llamada recursiva comprueba que todos los elementos del resto de la
lista cumplen el predicado y también lo debe cumplir el primer
elemento. Una lista vacía cumple siempre devuelve `#t` (al no tener
elementos, podemos decir que todos sus elementos cumplen el predicado).


#### 5.7.5. Función `foldr`

Veamos ahora la función `(foldr combina base lista)` que permite
recorrer una lista aplicando una función binaria de forma acumulativa
a sus elementos y devolviendo un único valor como resultado.

<div class="highlight"><pre><span></span><code>(foldr combina base lista) -&gt; valor
</code></pre></div>

El nombre `fold` significa *plegado*, indicando que la lista a la que
se aplica se va "plegando" y al final se devuelve un único
resultado. El plegado lo realiza la **función de plegado** `(combina
dato resultado)`, que recibe un dato de la lista y lo acumula con el
otro parámetro `resultado` (al que debemos dar un valor inicial y es
el parámetro `base` de la función `foldr`).

<div class="highlight"><pre><span></span><code>(combina dato resultado) -&gt; resultado
</code></pre></div>

La función `combina` se aplica a los elementos de la lista **de
derecha a izquierda**, empezando por el último elemento de la lista y
el valor inicial `base` y aplicándose sucesivamente a los resultados
que se van obteniendo.

Veamos un ejemplo. Supongamos que la función de plegado es una función
que suma el dato que viene de la lista con el valor acumulado:


<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">suma</span><span class="w"> </span><span class="n">dato</span><span class="w"> </span><span class="n">resultado</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="n">dato</span><span class="w"> </span><span class="n">resultado</span><span class="p">))</span>
</code></pre></div>

Llamamos a los parámetros `dato` y `resultado` para remarcar que el
primer parámetro se va a coger de la lista y el segundo del resultado
calculado.

Veamos qué pasa cuando hacemos un `foldr` con esta función suma y
la lista '(1 2 3) y con el número 0 como base:

<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="nb">foldr</span><span class="w"> </span><span class="n">suma</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">))</span><span class="w"> </span><span class="c1">; ⇒ 6</span>
</code></pre></div>

La función `suma` se va a ir aplicando a todos los elementos de la
lista de **derecha a izquierda**, empezando por el valor base (0) y el
último elemento de la lista (3) y cogiendo el resultado obtenido y
utilizándolo como nuevo parámetro `resultado` en la siguiente llamada.

En concreto, la secuencia de llamadas a la función `suma` serán las
siguientes:

<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="n">suma</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="c1">; ⇒ 3</span>
<span class="p">(</span><span class="n">suma</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="c1">; ⇒ 5</span>
<span class="p">(</span><span class="n">suma</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">5</span><span class="p">)</span><span class="w"> </span><span class="c1">; ⇒ 6</span>
</code></pre></div>

Otro ejemplo de uso:

<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="nb">foldr</span><span class="w"> </span><span class="nb">string-append</span><span class="w"> </span><span class="s2">&quot;****&quot;</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="s2">&quot;hola&quot;</span><span class="w"> </span><span class="s2">&quot;que&quot;</span><span class="w"> </span><span class="s2">&quot;tal&quot;</span><span class="p">))</span><span class="w"> </span><span class="c1">; ⇒ &quot;holaquetal****&quot;</span>
</code></pre></div>

En este caso la secuencia de llamadas a `string-append` que se van a
producir son:

<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="nb">string-append</span><span class="w"> </span><span class="s2">&quot;tal&quot;</span><span class="w"> </span><span class="s2">&quot;****&quot;</span><span class="p">)</span><span class="w"> </span><span class="c1">; ⇒ &quot;tal****&quot;</span>
<span class="p">(</span><span class="nb">string-append</span><span class="w"> </span><span class="s2">&quot;que&quot;</span><span class="w"> </span><span class="s2">&quot;tal****&quot;</span><span class="p">)</span><span class="w"> </span><span class="c1">; ⇒ &quot;quetal****&quot;</span>
<span class="p">(</span><span class="nb">string-append</span><span class="w"> </span><span class="s2">&quot;hola&quot;</span><span class="w"> </span><span class="s2">&quot;quetal****&quot;</span><span class="p">)</span><span class="w"> </span><span class="c1">; ⇒ &quot;holaquetal****&quot;</span>
</code></pre></div>

Otros ejemplos:

<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="nb">foldr</span><span class="w"> </span><span class="p">(</span><span class="k">lambda</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="p">))</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="mi">6</span><span class="w"> </span><span class="mi">7</span><span class="w"> </span><span class="mi">8</span><span class="p">))</span><span class="w"> </span><span class="c1">; ⇒ 40320</span>
<span class="p">(</span><span class="nb">foldr</span><span class="w"> </span><span class="nb">cons</span><span class="w"> </span><span class="o">&#39;</span><span class="p">()</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="p">))</span><span class="w"> </span><span class="c1">; ⇒ (1 2 3 4)</span>
</code></pre></div>

Un último ejemplo:

<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">suma-parejas</span><span class="w"> </span><span class="n">lista-parejas</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="nb">foldr</span><span class="w"> </span><span class="p">(</span><span class="k">lambda</span><span class="w"> </span><span class="p">(</span><span class="n">pareja</span><span class="w"> </span><span class="n">resultado</span><span class="p">)</span>
<span class="w">                   </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="p">(</span><span class="nb">car</span><span class="w"> </span><span class="n">pareja</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">cdr</span><span class="w"> </span><span class="n">pareja</span><span class="p">)</span><span class="w"> </span><span class="n">resultado</span><span class="p">))</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="n">lista-parejas</span><span class="p">))</span>

<span class="p">(</span><span class="n">suma-parejas</span><span class="w"> </span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">6</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">9</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="mi">-1</span><span class="w"> </span><span class="mi">8</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="mi">9</span><span class="w"> </span><span class="mi">3</span><span class="p">)))</span><span class="w"> </span><span class="c1">; ⇒ 39</span>
</code></pre></div>


##### 5.7.5.1. Implementación de `foldr` 

Podemos implementar de forma recursiva la función `foldr`:

<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">mi-foldr</span><span class="w"> </span><span class="n">func</span><span class="w"> </span><span class="n">base</span><span class="w"> </span><span class="n">lista</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">null?</span><span class="w"> </span><span class="n">lista</span><span class="p">)</span>
<span class="w">      </span><span class="n">base</span>
<span class="w">      </span><span class="p">(</span><span class="n">func</span><span class="w"> </span><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="n">lista</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">mi-foldr</span><span class="w"> </span><span class="n">func</span><span class="w"> </span><span class="n">base</span><span class="w"> </span><span class="p">(</span><span class="nb">rest</span><span class="w"> </span><span class="n">lista</span><span class="p">)))))</span>
</code></pre></div>


#### 5.7.6. Función `foldl` ####

La función `(foldl combina base lista)` (_fold left_) es similar a
`foldr` con la diferencia de que la secuencia de aplicaciones de la
función de plegado se hace **de izquierda a derecha** en lugar de
derecha a izquierda.

El perfil de la función de plegado es el mismo que en `foldr`:

<div class="highlight"><pre><span></span><code>(func dato resultado) -&gt; resultado
</code></pre></div>

Por ejemplo, si la función de combinación es `string-append`:

<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="nb">foldl</span><span class="w"> </span><span class="nb">string-append</span><span class="w"> </span><span class="s2">&quot;****&quot;</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="s2">&quot;hola&quot;</span><span class="w"> </span><span class="s2">&quot;que&quot;</span><span class="w"> </span><span class="s2">&quot;tal&quot;</span><span class="p">))</span><span class="w"> </span>
<span class="c1">; ⇒ &quot;talquehola****&quot;</span>
</code></pre></div>

La secuencia de llamadas a `string-append` es:

<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="nb">string-append</span><span class="w"> </span><span class="s2">&quot;hola&quot;</span><span class="w"> </span><span class="s2">&quot;****&quot;</span><span class="p">)</span><span class="w"> </span><span class="c1">; ⇒ &quot;hola****&quot;</span>
<span class="p">(</span><span class="nb">string-append</span><span class="w"> </span><span class="s2">&quot;que&quot;</span><span class="w"> </span><span class="s2">&quot;hola****&quot;</span><span class="p">)</span><span class="w"> </span><span class="c1">; ⇒ &quot;quehola****&quot;</span>
<span class="p">(</span><span class="nb">string-append</span><span class="w"> </span><span class="s2">&quot;tal&quot;</span><span class="w"> </span><span class="s2">&quot;quehola****&quot;</span><span class="p">)</span><span class="w"> </span><span class="c1">; ⇒ &quot;talquehola****&quot;</span>
</code></pre></div>

Otro ejemplo:

<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="nb">foldl</span><span class="w"> </span><span class="nb">cons</span><span class="w"> </span><span class="o">&#39;</span><span class="p">()</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="p">))</span><span class="w"> </span><span class="c1">; ⇒ (4 3 2 1)</span>
</code></pre></div>

La implementación de `foldl` la veremos cuando hablemos de
recursión por la cola (_tail recursion_) en el próximo tema.


!!! Tip "Consejo" 
    Las funciones `foldr` o `foldl` reciben una lista de
    datos y devuelven un único resultado.


#### 5.7.7. Uso de `and` y `or` con FOS ####

Hemos visto que las primitivas `and` y `or` no son funciones, sino
formas especiales. Debido a esto, no podemos usarlas como funciones
que se pasan a otra función de orden superior.

Por ejemplo, la siguiente expresión es incorrecta:

<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="nb">foldr</span><span class="w"> </span><span class="k">and</span><span class="w"> </span><span class="no">#t</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="no">#t</span><span class="w"> </span><span class="no">#f</span><span class="w"> </span><span class="no">#f</span><span class="p">))</span>
<span class="c1">; and: bad syntax in: and</span>
</code></pre></div>

Para comprobar expresiones booleanas en una lista podemos
usar `foldr` con una expresión lambda:

<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="nb">foldr</span><span class="w"> </span><span class="p">(</span><span class="k">lambda</span><span class="w"> </span><span class="p">(</span><span class="n">dato</span><span class="w"> </span><span class="n">result</span><span class="p">)</span>
<span class="w">           </span><span class="p">(</span><span class="k">and</span><span class="w"> </span><span class="n">dato</span><span class="w"> </span><span class="n">result</span><span class="p">))</span><span class="w"> </span><span class="no">#t</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="no">#t</span><span class="w"> </span><span class="no">#f</span><span class="w"> </span><span class="no">#f</span><span class="p">))</span>
<span class="c1">; ⇒ #f</span>
</code></pre></div>

O, mejor aún, es posible usar `for-all?` o `exists?` (o las funciones
equivalentes de Racket `andmap` o `ormap`).

Por ejemplo, para comprobar si algún booleano de una lista es `#t`
podríamos hacer:

<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="n">exists?</span><span class="w"> </span><span class="p">(</span><span class="k">lambda</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="no">#f</span><span class="w"> </span><span class="no">#f</span><span class="w"> </span><span class="no">#t</span><span class="w"> </span><span class="no">#f</span><span class="p">))</span><span class="w"> </span><span class="c1">; ⇒ #t</span>
<span class="p">(</span><span class="nb">ormap</span><span class="w"> </span><span class="p">(</span><span class="k">lambda</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="no">#f</span><span class="w"> </span><span class="no">#f</span><span class="w"> </span><span class="no">#t</span><span class="w"> </span><span class="no">#f</span><span class="p">))</span><span class="w"> </span><span class="c1">; ⇒ #t</span>
</code></pre></div>


#### 5.7.8. Funciones con FOS y expresiones lambda

El uso de funciones de orden superior (FOS) y expresiones lambda
proporciona muchísima expresividad en un lenguaje de programación. Es
posible escribir código muy conciso y construir funciones iterativas
que recorren listas y operan sobre sus elementos sin usar la recursividad. 

##### 5.7.8.1. Función `(suma-n n lista)`

Supongamos que queremos definir una función `(suma-n n lista)` que
devuelve la lista resultante el resultado de sumar un número `n` a
todos los elementos de una lista.

Podemos hacerlo de forma recursiva:

<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">suma-n</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="n">lista</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">null?</span><span class="w"> </span><span class="n">lista</span><span class="p">)</span>
<span class="w">        </span><span class="o">&#39;</span><span class="p">()</span>
<span class="w">        </span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="n">lista</span><span class="p">)</span><span class="w"> </span><span class="n">n</span><span class="p">)</span>
<span class="w">              </span><span class="p">(</span><span class="n">suma-n</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="p">(</span><span class="nb">rest</span><span class="w"> </span><span class="n">lista</span><span class="p">)))))</span>
</code></pre></div>

Funciona de la siguiente manera:

<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="n">suma-n</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="p">))</span><span class="w"> </span><span class="c1">; ⇒ (11 12 13 14)</span>
</code></pre></div>

**Implementacion con `map`**

Pero si utilizamos funciones de orden superior, podemos implementar la
misma función de una forma mucho más concisa y expresiva. 

Lo podemos hacer utilizando la función de orden superior `map` y una
expresión lambda que sume el número `n` a los elementos de la lista:

<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">suma-n</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="n">lista</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="p">(</span><span class="k">lambda</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">n</span><span class="p">))</span><span class="w"> </span><span class="n">lista</span><span class="p">))</span>
</code></pre></div>

Vemos que utilizamos el parámetro `n` en el cuerpo de la expresión
lambda. De esta forma la función que se aplica a los elementos de la
lista es una función que suma este número a cada elemento. La variable
`x` en el parámetro de la expresión lambda es la que va tomando el
valor de los elementos de la lista.

<div class="highlight"><pre><span></span><code>(suma-n 10 &#39;(1 2 3 4) 10) =&gt; 
(map #&lt;prodedure-que-suma-10-a-x&gt; (1 2 3 4)) =  (11 12 13 14)
</code></pre></div>

##### 5.7.8.2. Composición de funciones de orden superior

Dado que muchas de las anteriores funciones de orden superior
devuelven listas, es muy común componer las llamadas, de forma que la
salida de función se utilice como entrada de otra.

Por ejemplo, podemos implementar una función que sume un número
`n` a todos los elementos de una lista (igual que la anterior) y
después que sume todos los elementos resultantes.

Lo podríamos hacer reutilizando el código del ejemplo anterior, y
añadiendo una llamada a `foldr` para que haga la suma:

<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">suma-n-total</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="n">lista</span><span class="p">)</span>
<span class="w">   </span><span class="p">(</span><span class="nb">foldr</span><span class="w"> </span><span class="nb">+</span><span class="w"> </span><span class="mi">0</span>
<span class="w">       </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="p">(</span><span class="k">lambda</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">n</span><span class="p">))</span><span class="w"> </span><span class="n">lista</span><span class="p">)))</span>
</code></pre></div>

Funcionaría de la siguiente forma:

<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="n">suma-n-total</span><span class="w"> </span><span class="mi">100</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="p">))</span><span class="w"> </span><span class="c1">; ⇒ 410</span>
</code></pre></div>

Otro ejemplo. Supongamos que tenemos una lista de parejas de números y
queremos contar aquellas parejas cuya suma de ambos números es mayor
que un umbral (por ejemplo, 10).

<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">lista-parejas</span><span class="w"> </span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span>
<span class="w">                            </span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">8</span><span class="p">)</span><span class="w"> </span>
<span class="w">                            </span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"> </span>
<span class="w">                            </span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="mi">9</span><span class="w"> </span><span class="mi">6</span><span class="p">)))</span>
<span class="p">(</span><span class="n">cuenta-mayores-que</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="n">lista-parejas</span><span class="p">)</span><span class="w"> </span><span class="c1">; ⇒ 2</span>
</code></pre></div>

Se podría implementar de una forma muy concisa componiendo una llamada
a `map` para realizar la suma de cada pareja junto con una llamada a
`filter` que compruebe que el resultado sea mayor de `n`. Y al final
llamamos a `length` para contar la longitud de la lista resultante:

<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">cuenta-mayores-que</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="n">lista-parejas</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nb">length</span>
<span class="w">   </span><span class="p">(</span><span class="nb">filter</span><span class="w"> </span><span class="p">(</span><span class="k">lambda</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="w">             </span><span class="p">(</span><span class="nb">&gt;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">n</span><span class="p">))</span><span class="w"> </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="p">(</span><span class="k">lambda</span><span class="w"> </span><span class="p">(</span><span class="n">pareja</span><span class="p">)</span>
<span class="w">                             </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="p">(</span><span class="nb">car</span><span class="w"> </span><span class="n">pareja</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">cdr</span><span class="w"> </span><span class="n">pareja</span><span class="p">)))</span><span class="w"> </span><span class="n">lista-parejas</span><span class="p">))))</span>
</code></pre></div>


##### 5.7.8.3. Función `(contienen-letra caracter lista-pal)`

Veamos otro ejemplo. Supongamos que queremos definir la función
`(contienen-letra caracter lista-pal)` que devuelve las palabras de
una lista que contienen un determinado carácter.

Por ejemplo:

<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="n">contienen-letra</span><span class="w"> </span><span class="sc">#\a</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="s2">&quot;En&quot;</span><span class="w"> </span><span class="s2">&quot;un&quot;</span><span class="w"> </span><span class="s2">&quot;lugar&quot;</span><span class="w"> </span><span class="s2">&quot;de&quot;</span><span class="w"> </span><span class="s2">&quot;la&quot;</span><span class="w"> </span><span class="s2">&quot;Mancha&quot;</span><span class="p">))</span>
<span class="c1">; ⇒ (&quot;lugar&quot; &quot;la&quot; &quot;Mancha&quot;)</span>
</code></pre></div>

Podemos implementar `contienen-letra` usando la función de orden
superior `filter`, con una expresión lambda que se aplicará a cada una
de las palabras de la lista para comprobar si la palabra contiene el
carácter:

<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">contienen-letra</span><span class="w"> </span><span class="n">caracter</span><span class="w"> </span><span class="n">lista-pal</span><span class="p">)</span>
<span class="w">   </span><span class="p">(</span><span class="nb">filter</span><span class="w"> </span><span class="p">(</span><span class="k">lambda</span><span class="w"> </span><span class="p">(</span><span class="n">pal</span><span class="p">)</span>
<span class="w">              </span><span class="p">(</span><span class="n">letra-en-pal?</span><span class="w"> </span><span class="n">caracter</span><span class="w"> </span><span class="n">pal</span><span class="p">))</span><span class="w"> </span><span class="n">lista-pal</span><span class="p">))</span>
</code></pre></div>

El parámetro `pal` de la expresión lambda irá cogiendo el valor de
todas las palabras de `lista-pal` y la función `(letra-en-pal?
caracter pal)` comprobará si la cadena contiene el carácter.

La función `(letra-en-pal? caracter pal)` es una función auxiliar que
tenemos que implementar.

Por ejemplo:

<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="n">letra-en-pal?</span><span class="w"> </span><span class="sc">#\a</span><span class="w"> </span><span class="s2">&quot;Hola&quot;</span><span class="p">)</span><span class="w"> </span><span class="c1">; ⇒ #t</span>
<span class="p">(</span><span class="n">letra-en-pal?</span><span class="w"> </span><span class="sc">#\a</span><span class="w"> </span><span class="s2">&quot;Pepe&quot;</span><span class="p">)</span><span class="w"> </span><span class="c1">; ⇒ #f</span>
</code></pre></div>

La podemos implementar de una forma muy elegante obteniendo una lista
de caracteres a partir de la cadena y usando la función de orden
superior `exists?`:

<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">letra-en-pal?</span><span class="w"> </span><span class="n">caracter</span><span class="w"> </span><span class="n">palabra</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="n">exists?</span><span class="w"> </span><span class="p">(</span><span class="k">lambda</span><span class="w"> </span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
<span class="w">            </span><span class="p">(</span><span class="nb">equal?</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="n">caracter</span><span class="p">))</span><span class="w"> </span><span class="p">(</span><span class="nb">string-&gt;list</span><span class="w"> </span><span class="n">palabra</span><span class="p">)))</span>
</code></pre></div>


##### 5.7.8.4. Función divisores #####

Un último ejemplo en el que implementamos la función `(divisores n)`
utilizando una función de orden superior.

Suponemos que tenemos definidas las funciones `(numeros-hasta n)` y
`(divisor? x n)`:

<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">numeros-hasta</span><span class="w"> </span><span class="n">n</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="n">n</span><span class="p">)</span>
<span class="w">      </span><span class="o">&#39;</span><span class="p">()</span>
<span class="w">      </span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="p">(</span><span class="n">numeros-hasta</span><span class="w"> </span><span class="p">(</span><span class="nb">-</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="mi">1</span><span class="p">)))))</span>

<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">divisor?</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">n</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">(</span><span class="n">mod</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="n">x</span><span class="p">)))</span>
</code></pre></div>

Entonces la función `(divisores n)` se implementaría de la siguiente forma:


<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">divisores</span><span class="w"> </span><span class="n">n</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nb">filter</span><span class="w"> </span><span class="p">(</span><span class="k">lambda</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="w">            </span><span class="p">(</span><span class="n">divisor?</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">n</span><span class="p">))</span><span class="w"> </span><span class="p">(</span><span class="n">numeros-hasta</span><span class="w"> </span><span class="n">n</span><span class="p">)))</span>
</code></pre></div>
-->
<h2 id="6-bibliografia">6. Bibliografía<a class="headerlink" href="#6-bibliografia" title="Permanent link">&para;</a></h2>
<p>Capítulos del libro <em>Structure and Intepretation of Computer Programs</em>:</p>
<ul>
<li><a href="https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book-Z-H-10.html#%_sec_1.1">1.1  The Elements of Programming</a></li>
<li><a href="https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book-Z-H-12.html#%_sec_1.3">1.3  Formulating Abstractions with Higher-Order Procedures</a></li>
<li><a href="https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book-Z-H-15.html#%_sec_2.2.1">2.2.1  Representing Sequences</a></li>
</ul>
<hr />
<p>Lenguajes y Paradigmas de Programación, curso 2025-26<br />
© Departamento Ciencia de la Computación e Inteligencia Artificial, Universidad de Alicante<br />
Domingo Gallardo, Cristina Pomares, Antonio Botía, Francisco Martínez</p>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "../..", "features": ["content.code.copy"], "search": "../../assets/javascripts/workers/search.07f07601.min.js", "translations": {"clipboard.copied": "Copiado al portapapeles", "clipboard.copy": "Copiar al portapapeles", "search.result.more.one": "1 m\u00e1s en esta p\u00e1gina", "search.result.more.other": "# m\u00e1s en esta p\u00e1gina", "search.result.none": "No se encontraron documentos", "search.result.one": "1 documento encontrado", "search.result.other": "# documentos encontrados", "search.result.placeholder": "Teclee para comenzar b\u00fasqueda", "search.result.term.missing": "Falta", "select.version": "Seleccionar versi\u00f3n"}}</script>
    
    
      <script src="../../assets/javascripts/bundle.56dfad97.min.js"></script>
      
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML"></script>
      
    
  </body>
</html>