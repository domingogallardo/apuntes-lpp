<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
<style type="text/css">

/* Admonition */

.admonition {
    padding-left: 15px;
    padding-right: 15px;
    margin-bottom: 10px;
    border: 1px solid transparent;
    border-radius: 4px;
    text-align: left;
}

.admonition.note { /* csslint allow: adjoining-classes */
    color: black;
    background-color: #d9edf7;
    border-color: #bce8f1;
}

.admonition.quote { /* csslint allow: adjoining-classes */
    color: black;
    background-color: #cecece;
    border-color: #cccccc;
}

.admonition.warning { /* csslint allow: adjoining-classes */
    color: black;
    background-color: #FCC8BE;
    border-color: #FCC8BE;
}

.admonition.hint { /* csslint allow: adjoining-classes */
    color: black;
    background-color: #E9F9F6;
    border-color: #AFEEEE;
}

.admonition.danger { /* csslint allow: adjoining-classes */
    color: black;
    background-color: #F7B2A4;
    border-color: #F7B2A4;
}

.admonition-title {
    font-weight: bold;
    text-align: left;
}


/* Codehilite */

.hll { background-color: #ffffcc }
.c { color: #408080; font-style: italic } /* Comment */
.err { border: 1px solid #FF0000 } /* Error */
.k { color: #008000; font-weight: bold } /* Keyword */
.o { color: #666666 } /* Operator */
.ch { color: #408080; font-style: italic } /* Comment.Hashbang */
.cm { color: #408080; font-style: italic } /* Comment.Multiline */
.cp { color: #BC7A00 } /* Comment.Preproc */
.cpf { color: #408080; font-style: italic } /* Comment.PreprocFile */
.c1 { color: #408080; font-style: italic } /* Comment.Single */
.cs { color: #408080; font-style: italic } /* Comment.Special */
.gd { color: #A00000 } /* Generic.Deleted */
.ge { font-style: italic } /* Generic.Emph */
.gr { color: #FF0000 } /* Generic.Error */
.gh { color: #000080; font-weight: bold } /* Generic.Heading */
.gi { color: #00A000 } /* Generic.Inserted */
.go { color: #888888 } /* Generic.Output */
.gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.gs { font-weight: bold } /* Generic.Strong */
.gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.gt { color: #0044DD } /* Generic.Traceback */
.kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.kp { color: #008000 } /* Keyword.Pseudo */
.kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.kt { color: #B00040 } /* Keyword.Type */
.m { color: #666666 } /* Literal.Number */
.s { color: #BA2121 } /* Literal.String */
.na { color: #7D9029 } /* Name.Attribute */
.nb { color: #008000 } /* Name.Builtin */
.nc { color: #0000FF; font-weight: bold } /* Name.Class */
.no { color: #880000 } /* Name.Constant */
.nd { color: #AA22FF } /* Name.Decorator */
.ni { color: #999999; font-weight: bold } /* Name.Entity */
.ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.nf { color: #0000FF } /* Name.Function */
.nl { color: #A0A000 } /* Name.Label */
.nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.nt { color: #008000; font-weight: bold } /* Name.Tag */
.nv { color: #19177C } /* Name.Variable */
.ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.w { color: #bbbbbb } /* Text.Whitespace */
.mb { color: #666666 } /* Literal.Number.Bin */
.mf { color: #666666 } /* Literal.Number.Float */
.mh { color: #666666 } /* Literal.Number.Hex */
.mi { color: #666666 } /* Literal.Number.Integer */
.mo { color: #666666 } /* Literal.Number.Oct */
.sa { color: #BA2121 } /* Literal.String.Affix */
.sb { color: #BA2121 } /* Literal.String.Backtick */
.sc { color: #BA2121 } /* Literal.String.Char */
.dl { color: #BA2121 } /* Literal.String.Delimiter */
.sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.s2 { color: #BA2121 } /* Literal.String.Double */
.se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.sh { color: #BA2121 } /* Literal.String.Heredoc */
.si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.sx { color: #008000 } /* Literal.String.Other */
.sr { color: #BB6688 } /* Literal.String.Regex */
.s1 { color: #BA2121 } /* Literal.String.Single */
.ss { color: #19177C } /* Literal.String.Symbol */
.bp { color: #008000 } /* Name.Builtin.Pseudo */
.fm { color: #0000FF } /* Name.Function.Magic */
.vc { color: #19177C } /* Name.Variable.Class */
.vg { color: #19177C } /* Name.Variable.Global */
.vi { color: #19177C } /* Name.Variable.Instance */
.vm { color: #19177C } /* Name.Variable.Magic */
.il { color: #666666 } /* Literal.Number.Integer.Long */

/* Estilo LPP */

body {
  font-family: Helvetica, arial, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  background-color: white;
  padding: 60px;
}

pre {
  background-color: #f8f8f8;
  border: 1px solid #cccccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px;
}

table {
  padding: 0;border-collapse: collapse; }
  table tr {
    border-top: 1px solid #cccccc;
    background-color: white;
    margin: 0;
    padding: 0; }
    table tr:nth-child(2n) {
      background-color: #f8f8f8; }
    table tr th {
      font-weight: bold;
      border: 1px solid #cccccc;
      margin: 0;
      padding: 6px 13px; }
    table tr td {
      border: 1px solid #cccccc;
      margin: 0;
      padding: 6px 13px; }
    table tr th :first-child, table tr td :first-child {
      margin-top: 0; }
    table tr th :last-child, table tr td :last-child {
      margin-bottom: 0; }

</style>

</head>

<body>
<h2>Semana 6</h2>
<p>Notas de clase de la semana 6 de LPP. </p>
<h2>Tema 4: Estructuras de datos recursivas</h2>
<ul>
<li><strong>1 Listas estructuradas</strong><ul>
<li><strong>1.1. Definición y ejemplos</strong></li>
<li><strong>1.2. Funciones recursivas sobre listas estructuradas</strong></li>
</ul>
</li>
<li>2 Árboles<ul>
<li>2.1. Definición de árboles en Scheme</li>
<li>2.2. Funciones recursivas sobre árboles</li>
</ul>
</li>
<li>3 Árboles binarios<ul>
<li>3.1. Definición de árboles binarios en Scheme</li>
<li>3.2. Funciones recursivas sobre árboles binarios</li>
</ul>
</li>
</ul>
<hr />
<h3>Listas estructuradas</h3>
<ul>
<li>
<p>Funciones para trabajar con listas:</p>
<ul>
<li><code>(first lista)</code> para obtener el primer elemento de una lista</li>
<li><code>(rest lista)</code> para obtener el resto de la lista</li>
<li><code>(cons dato lista)</code> para construir una nueva lista con el dato
  como primer elemento</li>
</ul>
</li>
<li>
<p>En este apartado vamos a estudiar cómo trabajar con <em>listas que
  contienen otras listas</em>. Los elementos de las listas pueden ser
  elementos atómicos u otras listas.</p>
</li>
<li>
<p>La función <code>(first lista)</code> puede devolver un elemento u otra lista.</p>
</li>
</ul>
<hr />
<h3>Definición y ejemplos</h3>
<ul>
<li>
<p>Llamaremos <strong>lista estructurada</strong> a una lista que contiene otras
  sublistas. Lo contrario de lista estructurada es una <strong>lista
  plana</strong>, una lista formada por elementos que no son
  listas. Llamaremos <strong>hojas</strong> a los elementos de una lista que no son
  sublistas.</p>
</li>
<li>
<p>A las listas estructuradas cuyas hojas son símbolos se les denomina
  en el contexto de la programación funcional <em>expresiones-S</em>
  (<a href="http://en.wikipedia.org/wiki/S-expression">S-expression</a>).</p>
</li>
<li>
<p>Por ejemplo, la lista estructurada:</p>
</li>
</ul>
<pre class="highlight"><code class="language-racket">    (a b (c d e) (f (g h)))</code></pre>
<pre class="codehilite"><code>es una lista estructurada con 4 elementos:

- El elemento `'a`, una hoja
- El elemento `'b`, otra hoja
- La lista plana `'(c d e)`
- La lista estructurada `'(f (g h))`
</code></pre>

<ul>
<li>Una lista formada por parejas la consideraremos una lista plana, ya
  que no contiene ninguna sublista. Por ejemplo, la lista</li>
</ul>
<pre class="highlight"><code class="language-racket">    ((a . 3) (b . 5) (c . 12))</code></pre>
<pre class="codehilite"><code>es una lista plana de tres elementos (hojas) que son parejas.
</code></pre>

<hr />
<h3>Función <code>(hoja? dato)</code></h3>
<ul>
<li>Un dato es una hoja si no es una lista:</li>
</ul>
<pre class="highlight"><code class="language-racket">    (define (hoja? dato)
        (not (list? dato)))</code></pre>
<ul>
<li>Por ejemplo, supongamos la siguiente lista:</li>
</ul>
<pre class="highlight"><code class="language-racket">    ((1 2) 3 4 (5 6))</code></pre>
<pre class="codehilite"><code>Es una lista de 4 elementos, siendo el primero y el último otras
sublistas y el segundo y el tercero hojas. Podemos comprobar si
son o no hojas sus elementos:
</code></pre>

<pre class="highlight"><code class="language-racket">    (define lista '((1 2) 3 4 (5 6)))
    (hoja? (first lista)) ; ⇒ #f
    (hoja? (second lista)) ; ⇒ #t
    (hoja? (third lista)) ; ⇒ #t
    (hoja? (fourth lista)) ; ⇒ #f</code></pre>
<ul>
<li>La lista vacía no es una hoja</li>
</ul>
<pre class="highlight"><code class="language-racket">    (hoja? '()) ; ⇒ #f</code></pre>
<hr />
<h3>Función <code>(plana? lista)</code></h3>
<ul>
<li>Una lista es plana cuando todos sus elementos son hojas.</li>
</ul>
<pre class="highlight"><code class="language-racket">    (plana? '(a b c d e f)) ; ⇒ #t
    (plana? (list (cons 'a 1) "Hola" #f)) ; ⇒ #t
    (plana? '(a (b c) d)) ; ⇒ #f
    (plana? '(a () b)) ; ⇒ #f</code></pre>
<ul>
<li>Una definición recursiva de lista plana:</li>
</ul>
<blockquote>
<p>Una lista es plana si y solo si el primer elemento es una hoja y el
resto es plana.</p>
</blockquote>
<ul>
<li>Y el caso base:</li>
</ul>
<blockquote>
<p>Una lista vacía es plana.</p>
</blockquote>
<ul>
<li>Usando esta definición recursiva, podemos implementar en Scheme la
  función <code>(plana? lista)</code> que comprueba si una lista es plana:</li>
</ul>
<pre class="highlight"><code class="language-racket">    (define (plana? lista)
       (or (null? lista)
           (and (hoja? (first lista))
                (plana? (rest lista)))))</code></pre>
<p>¿Cómo sería la definición de <code>plana?</code> utilizando funciones de orden superior?</p>
<p style="margin-bottom:3cm;"></p>

<pre class="highlight"><code class="language-racket">(define (plana-fos? lista)
  (for-all? hoja? lista))</code></pre>
<hr />
<h3>Función <code>(estructurada? lista)</code></h3>
<ul>
<li>Ejemplos:</li>
</ul>
<pre class="highlight"><code class="language-racket">    (estructurada? '(1 2 3 4)) ; ⇒ #f
    (estructurada? (list (cons 'a 1) (cons 'b 2) (cons 'c 3))) ; ⇒ #f
    (estructurada? '(a () b)) ; ⇒ #t
    (estructurada? '(a (b c) d)) ; ⇒ #t</code></pre>
<ul>
<li>Una lista es estructurada cuando alguno de sus elementos es otra
  lista:</li>
</ul>
<pre class="highlight"><code class="language-racket">    (define (estructurada? lista)
       (and (not (null? lista))
            (or (list? (first lista))
                (estructurada? (rest lista)))))</code></pre>
<p>¿Cómo sería la definición de <code>estructurada?</code> utilizando funciones de orden superior?</p>
<p style="margin-bottom:3cm;"></p>

<pre class="highlight"><code class="language-racket">(define (estructurada-fos? lista)
  (exists? list? lista))</code></pre>
<ul>
<li>Realmente bastaría con haber hecho una de las dos definiciones y
escribir la otra como la negación de la primera:</li>
</ul>
<pre class="highlight"><code class="language-racket">    (define (estructurada? lista)
       (not (plana? lista)))</code></pre>
<hr />
<h3>Ejemplos de listas estructuradas</h3>
<ul>
<li>
<p>Las listas estructuradas son muy útiles para representar información
  jerárquica en donde queremos representar elementos que contienen
  otros elementos.</p>
</li>
<li>
<p>Por ejemplo, las expresiones de Scheme son listas estructuradas:</p>
</li>
</ul>
<pre class="highlight"><code class="language-racket">    (= 4 (+ 2 2))
    (if (= x y) (* x y) (+ (/ x y) 45))
    (define (factorial x) (if (= x 0) 1 (* x (factorial (- x 1)))))</code></pre>
<ul>
<li>El análisis sintáctico de una oración puede generar una lista
  estructurada de símbolos, en donde se agrupan los distintos
  elementos de la oración:</li>
</ul>
<pre class="highlight"><code class="language-racket">    ((Juan) (compró) (la entrada (de los Miserables)) (el viernes por la tarde))</code></pre>
<hr />
<h3><em>Pseudo árboles</em> con niveles</h3>
<ul>
<li>
<p>Las listas estructuradas definen una estructura de niveles, donde la
  lista inicial representa el primer nivel, y cada sublista representa
  un nivel inferior. Los datos de las listas representan las hojas.</p>
</li>
<li>
<p>Por ejemplo, la representación en forma de niveles de la lista <code>((a
  b c) d e)</code> es la siguiente:</p>
<p><img src="imagenes/expresion-e-1.png" width="350px"/></p>
<p>Las hojas <code>d</code> y <code>e</code> están en el nivel 1 y en las posiciones 2 y 3 de
la lista y las hojas <code>a</code>, <code>b</code> y <code>c</code> en el nivel 2 y en la posición 1
de la lista.</p>
</li>
</ul>
<div class="admonition warning">
<p class="admonition-title">Una lista estructurada no es un árbol</p>
<p>Una lista estructurada no es un árbol propiamente dicho, porque
un árbol tiene datos en todos los nodos, mientras que en la lista 
estructurada los datos están sólo en las hojas.</p>
</div>
<ul>
<li>
<p>Las listas estructuradas sirven para agrupar de forma jerárquica
  un conjunto de datos en distintos niveles. </p>
</li>
<li>
<p>A pesar de ser distintas de los árboles, ambas son estructuras de
  datos jerárquicas (con niveles) que se pueden definir de forma
  recursiva y sobre las que se pueden definir algoritmos recursivos.</p>
</li>
<li>
<p>Veremos los árboles en la próxima clase.</p>
</li>
</ul>
<p>Otro ejemplo. ¿Cuál sería la representación en niveles de la
siguiente lista estructurada?:</p>
<pre class="highlight"><code class="language-racket">(map (lambda (x) (+ x 10)) (quote (1 2 3 4)))</code></pre>
<p style="margin-bottom:3cm;"></p>

<hr />
<h3>Funciones recursivas sobre listas estructuradas</h3>
<ul>
<li><code>(num-hojas lista)</code>: número de hojas de una lista estructurada</li>
<li>
<p><code>(aplana lista)</code>: devuelve una lista plana con todas las hojas de la
  lista estructurada</p>
</li>
<li>
<p>Como hemos dicho antes, la cuestión clave en este tipo de listas es
  que el <code>first</code> puede ser a su vez otra lista.</p>
</li>
</ul>
<hr />
<h3>Número de hojas</h3>
<pre class="highlight"><code class="language-racket">(num-hojas '((1 2) (3 4 (5) 6) (7))) ⇒ 7</code></pre>
<p><img src="imagenes/num-hojas-estructurada.png" width="400px"/></p>
<ul>
<li>Podemos definir la función obteniendo el primer elemento y el resto
  de la lista, y contando recursivamente el número de hojas del primer
  elemento y del resto.</li>
<li>Al ser una lista estructurada, <strong>el primer elemento puede ser a su
  vez otra lista, por lo que llamamos a la recursión para contar sus
  hojas</strong>.</li>
<li>La definición de este caso general usando <em>pseudocódigo</em> es:</li>
</ul>
<div class="admonition hint">
<p class="admonition-title">Caso general de num-hojas</p>
<p>El número de hojas de una lista estructurada es: 
la suma del número de hojas de su primer elemento (que puede ser otra lista) y del
número de hojas del resto.</p>
</div>
<ul>
<li>La recursión tiene dos llamadas recursivas. Una que recibe el
  elemento de la cabeza de la lista y otra que recibe el resto de la
  lista. </li>
</ul>
<pre class="highlight"><code class="language-racket">    ;Caso general num-hojas
    (define (num-hojas lisdat)
      ; Falta caso base
      (+ (num-hojas (first lisdat))
         (num-hojas (rest lisdat))))</code></pre>
<div class="admonition warning">
<p class="admonition-title">No hay coste exponencial</p>
<ul>
<li>A pesar de haber dos llamadas recursivas, no pasa lo mismo que en
Fibonacci o Pascal. </li>
<li>No se van a repetir llamadas a la recursión
con los mismos datos. </li>
<li>La recursión recorre la lista estructurada y su coste será el
número de elementos de la lista.</li>
</ul>
</div>
<ul>
<li>
<p>Para considerar el <strong>caso base</strong>, veamos cómo las llamadas recursivas
  reciben cada vez un problema más pequeño. </p>
</li>
<li>
<p>La llamada recursiva sobre el resto de la lista recibe cada vez una
  lista con 1 elemento menos. Al final se llamará a la función con una
  lista vacía. Ese será un caso base. El número de elementos de una
  lista vacía es 0.</p>
</li>
<li>
<p>La llamada recursiva sobre la cabeza de la lista es algo
  distinta. Recibe una lista en la que se ha descendido un nivel y
  tiene, por tanto, un nivel menos. Al final se llamará a la función
  con una hoja (un dato). Ese será el otro caso base y habrá que
  devolver 1.</p>
</li>
<li>
<p>Definición completa de la función:</p>
</li>
</ul>
<pre class="highlight"><code class="language-racket">    (define (num-hojas lisdat)
       (cond
          ((null? lisdat) 0)
          ((hoja? lisdat) 1)
          (else (+ (num-hojas (first lisdat))
                   (num-hojas (rest lisdat))))))</code></pre>
<div class="admonition warning">
<p class="admonition-title">Importante</p>
<p>Hay que hacer notar que el parámetro <code>lisdat</code> puede ser tanto una lista
como un dato atómico. En ese caso la función <code>(hoja? lista)</code>
devuelve <code>#t</code>.</p>
<p>En lenguajes de programación fuertemente tipados esto no
sería posible, porque la lista y el dato serían de distinto
tipo. En ese caso el código debería ser un poco más largo y antes
de llamar a la recursión habría que comprobar si el elemento es un
dato o es otra lista. En el caso de Scheme, podemos aprovecharnos
de su característica de ser débilmente tipado y podemos hacer el
código más conciso, llamando siempre a la recursión con el <code>first</code>
de la lista, independientemente de si es un dato u otra lista.</p>
</div>
<hr />
<h3>Versión con funciones de orden superior</h3>
<ul>
<li>Podemos usar también las funciones de orden superior <code>map</code> y
  <code>foldr</code> para obtener una versión más concisa.</li>
<li>Una lista estructurada tiene como elementos hojas o listas. </li>
<li>Podemos entonces mapear una expresión lambda con <em>la propia función
  que estamos definiendo</em> sobre sus elementos, poniendo como caso
  especial el hecho de que la lista sea una hoja.</li>
<li>El resultado será una lista de números (el número de hojas de cada
  componente), que podemos sumar haciendo un <code>foldr</code> con la
  función <code>+</code>:</li>
</ul>
<pre class="highlight"><code class="language-racket">(define (num-hojas-fos ld)
    (if (hoja? ld)
        1
        (foldr + 0 (map num-hojas-fos ld))))</code></pre>
<p><img src="imagenes/map-lista.png" width="600px"/></p>
<ul>
<li>Sería equivalente hacer un <code>apply</code> de la suma para sumar los números
de la lista devuelta por el <code>map</code>:</li>
</ul>
<pre class="highlight"><code class="language-racket">(define (num-hojas-fos ld)
    (if (hoja? ld)
        1
        (apply + (map num-hojas-fos ld))))</code></pre>
<hr />
<h3><code>(aplana lista)</code></h3>
<ul>
<li>Devuelve una lista plana con todas las hojas de la lista.</li>
</ul>
<pre class="highlight"><code class="language-racket">    (aplana '(1 2 (3 (4 (5))) (((6)))))
    ; ⇒ (1 2 3 4 5 6)</code></pre>
<ul>
<li>Solución recursiva:</li>
</ul>
<pre class="highlight"><code class="language-racket">(define (aplana ld)
  (cond
    ((null? ld) '())
    ((hoja? ld) (list ld))
    (else 
     (append (aplana (first ld))
             (aplana (rest ld))))))</code></pre>
<ul>
<li>Solución con funciones de orden superior:</li>
</ul>
<pre class="highlight"><code class="language-racket">(define (aplana-fos ld)
  (if (hoja? ld)
    (list ld)
    (foldr append '() (map aplana-fos ld))))</code></pre>
<ul>
<li>Usando <code>apply</code>:</li>
</ul>
<pre class="highlight"><code class="language-racket">(define (aplana-fos ld)
  (if (hoja? ld)
    (list ld)
    (apply append (map aplana-fos ld))))</code></pre>
<hr />
<h3>Otras funciones recursivas</h3>
<p>Vamos a diseñar otras funciones recursivas que trabajan con la
estructura jerárquica de las listas estructuradas.</p>
<ul>
<li><code>(pertenece-lista? dato lista)</code>: busca una hoja en una lista
  estructurada</li>
<li><code>(cuadrado-estruct lista)</code>: eleva todas las hojas al cuadrado
  (suponemos que la lista estructurada contiene números)</li>
<li><code>(map-estruct f lista)</code>: similar a map, aplica una función a todas las
  hojas de la lista estructurada y devuelve el resultado (otra lista
  estructurada)</li>
<li><code>(altura lista)</code>: devuelve el número de niveles de una lista
  estructurada.</li>
<li><code>(nivel-lista dato lista)</code>: devuelve el nivel en el que se encuentra
  un dato en una lista</li>
</ul>
<hr />
<h3><code>(pertenece-lista? dato lista)</code></h3>
<ul>
<li>Comprueba si el dato <code>dato</code> aparece en la lista estructurada. </li>
</ul>
<pre class="highlight"><code class="language-racket">    (pertenece-lista? 'a '(b c (d (a)))) ⇒ #t
    (pertenece-lista? 'a '(b c (d e (f)) g)) ⇒ #f</code></pre>
<ul>
<li>Solución recursiva:</li>
</ul>
<pre class="highlight"><code class="language-racket">(define (pertenece-lista? dato ld)
  (cond 
    ((null? ld) #f)
    ((hoja? ld) (equal? dato ld))
    (else (or (pertenece-lista? dato (first ld))
              (pertenece-lista? dato (rest ld))))))</code></pre>
<ul>
<li>Solución con funciones de orden superior:</li>
</ul>
<pre class="highlight"><code class="language-racket">(define (pertenece-fos? dato ld)
  (if (hoja? ld)
    (equal? dato ld)
    (exists? (lambda (elem)
               (pertenece-fos? dato elem)) ld)))</code></pre>
<hr />
<h3><code>(cuadrado-estruct lista)</code></h3>
<ul>
<li>Devuelve una lista estructurada con la misma estructura y sus
números elevados al cuadrado.</li>
</ul>
<pre class="highlight"><code class="language-racket">    (cuadrado-estruct '(2 3 (4 (5)))) ⇒ (4 9 (16 (25))</code></pre>
<ul>
<li>Solución recursiva:</li>
</ul>
<pre class="highlight"><code class="language-racket">(define (cuadrado-estruct ld)
  (cond ((null? ld) '())
        ((hoja? ld) (* ld ld ))
        (else (cons (cuadrado-estruct (first ld))
                    (cuadrado-estruct (rest ld))))))</code></pre>
<ul>
<li>Solución con <code>map</code>:</li>
</ul>
<pre class="highlight"><code class="language-racket">(define (cuadrado-estruct-fos ld)
  (if (hoja? ld)
      (* ld ld)
      (map cuadrado-estruct-fos ld)))</code></pre>
<hr />
<h3><code>(map-estruct f lista)</code></h3>
<ul>
<li>Devuelve una lista estructurada igual que la original con el
resultado de aplicar a cada uno de sus hojas la función <code>f</code></li>
</ul>
<pre class="highlight"><code class="language-racket">    (map-estruct (lambda (x) (* x x)) '(2 3 (4 (5)))) 
    ; ⇒ (4 9 (16 (25))</code></pre>
<ul>
<li>Solución recursiva:</li>
</ul>
<pre class="highlight"><code class="language-racket">(define (map-estruct f ld)
  (cond ((null? ld) '())
        ((hoja? ld) (f ld))
        (else (cons (map-estruct f (first ld))
                    (map-estruct f (rest ld))))))</code></pre>
<ul>
<li>Solución con <code>map</code>:</li>
</ul>
<pre class="highlight"><code class="language-racket">(define (map-estruct-fos f ld)
  (if (hoja? ld)
      (f ld)
      (map (lambda (elem)
             (map-estruct-fos f elem)) ld)))</code></pre>
<hr />
<h3><code>(altura lista)</code></h3>
<ul>
<li>La <em>altura</em> de una lista estructurada viene dada por su número de
  niveles</li>
<li>Una lista plana tiene una altura de 1, la lista <code>((1 2 3) 4 5)</code>
  tiene una altura de 2.</li>
</ul>
<pre class="highlight"><code class="language-racket">    (altura '(1 (2 3) 4)) ⇒ 2
    (altura '(((1)) (2 3) 4)) ⇒ 3</code></pre>
<p><img src="imagenes/altura-estructurada.png" width="300"/></p>
<div class="admonition hint">
<p class="admonition-title">Caso general altura</p>
<p>Para calcular la altura de una lista estructurada tenemos que
obtener (de forma recursiva) la altura de su primer elemento, y la
altura del resto de la lista, sumarle 1 a la altura del primer
elemento y devolver el máximo de los dos números.</p>
</div>
<ul>
<li>Caso base: la altura de una lista vacía y de una hoja es 0.
<pre class="highlight"><code>- En Scheme:

```racket
(define (altura ld)
   (cond 
      ((null? ld) 0)
      ((hoja? ld) 0)
      (else (max (+ 1 (altura (first ld)))
                 (altura (rest ld))))))</code></pre></li>
</ul>
<hr />
<ul>
<li>La segunda versión, usando las funciones de orden superior <code>map</code>
para obtener la altura de las sublistas y <code>foldr</code> para quedarse
con el máximo.</li>
</ul>
<pre class="highlight"><code class="language-racket">(define (altura-fos ld)
   (if (hoja? ld)
       0
       (+ 1 (foldr max 0 (map altura-fos ld)))))</code></pre>
<hr />
<h3><code>(nivel-hoja dato lista)</code></h3>
<ul>
<li>Recorre la lista buscando el dato y devuelve el nivel en que se
encuentra. Si el dato no se encuentra en la lista, se devolverá -1. Si
el dato se encuentra en más de un lugar de la lista se devolverá el
nivel mayor.</li>
</ul>
<pre class="highlight"><code class="language-racket">    (nivel-hoja 'b '(a b (c))) ; ⇒ 1
    (nivel-hoja 'b '(a (b) c)) ; ⇒ 2
    (nivel-hoja 'b '(a (b) d ((b)))) ; ⇒ 3
    (nivel-hoja 'b '(a c d ((e)))) ; ⇒ -1</code></pre>
<ul>
<li>Solución recursiva:</li>
</ul>
<pre class="highlight"><code class="language-racket">(define (nivel-hoja dato ld)
  (cond
    ((null? ld) -1)
    ((hoja? ld) (if (equal? ld dato) 0 -1))
    (else (max (suma-1-si-mayor-igual-que-0 
                    (nivel-hoja dato (first ld)))
               (nivel-hoja dato (rest ld))))))</code></pre>
<ul>
<li>La función auxiliar se define de la siguiente forma:</li>
</ul>
<pre class="highlight"><code class="language-racket">    (define (suma-1-si-mayor-igual-que-0 x)
      (if (&gt;= x 0)
          (+ x 1)
          x))</code></pre>
<ul>
<li>Solución con funciones de orden superior:</li>
</ul>
<pre class="highlight"><code class="language-racket">(define (nivel-hoja-fos dato ld)
  (if (hoja? ld)
      (if (equal? ld dato) 0 -1)
      (suma-1-si-mayor-igual-que-0
       (foldr max -1 (map (lambda (elem)
                           (nivel-hoja-fos dato elem)) ld)))))</code></pre>
<hr /></body>

</html>
