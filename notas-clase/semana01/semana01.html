<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
<style type="text/css">

/* Admonition */

.admonition {
    padding-left: 15px;
    padding-right: 15px;
    margin-bottom: 10px;
    border: 1px solid transparent;
    border-radius: 4px;
    text-align: left;
}

.admonition.note { /* csslint allow: adjoining-classes */
    color: black;
    background-color: #d9edf7;
    border-color: #bce8f1;
}

.admonition.quote { /* csslint allow: adjoining-classes */
    color: black;
    background-color: #cecece;
    border-color: #cccccc;
}

.admonition.warning { /* csslint allow: adjoining-classes */
    color: black;
    background-color: #fcf8e3;
    border-color: #fbeed5;
}

.admonition.hint { /* csslint allow: adjoining-classes */
    color: black;
    background-color: #E9F9F6;
    border-color: #AFEEEE;
}

.admonition.danger { /* csslint allow: adjoining-classes */
    color: black;
    background-color: #f2dede;
    border-color: #eed3d7;
}

.admonition-title {
    font-weight: bold;
    text-align: left;
}


/* Codehilite */

.hll { background-color: #ffffcc }
.c { color: #408080; font-style: italic } /* Comment */
.err { border: 1px solid #FF0000 } /* Error */
.k { color: #008000; font-weight: bold } /* Keyword */
.o { color: #666666 } /* Operator */
.ch { color: #408080; font-style: italic } /* Comment.Hashbang */
.cm { color: #408080; font-style: italic } /* Comment.Multiline */
.cp { color: #BC7A00 } /* Comment.Preproc */
.cpf { color: #408080; font-style: italic } /* Comment.PreprocFile */
.c1 { color: #408080; font-style: italic } /* Comment.Single */
.cs { color: #408080; font-style: italic } /* Comment.Special */
.gd { color: #A00000 } /* Generic.Deleted */
.ge { font-style: italic } /* Generic.Emph */
.gr { color: #FF0000 } /* Generic.Error */
.gh { color: #000080; font-weight: bold } /* Generic.Heading */
.gi { color: #00A000 } /* Generic.Inserted */
.go { color: #888888 } /* Generic.Output */
.gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.gs { font-weight: bold } /* Generic.Strong */
.gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.gt { color: #0044DD } /* Generic.Traceback */
.kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.kp { color: #008000 } /* Keyword.Pseudo */
.kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.kt { color: #B00040 } /* Keyword.Type */
.m { color: #666666 } /* Literal.Number */
.s { color: #BA2121 } /* Literal.String */
.na { color: #7D9029 } /* Name.Attribute */
.nb { color: #008000 } /* Name.Builtin */
.nc { color: #0000FF; font-weight: bold } /* Name.Class */
.no { color: #880000 } /* Name.Constant */
.nd { color: #AA22FF } /* Name.Decorator */
.ni { color: #999999; font-weight: bold } /* Name.Entity */
.ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.nf { color: #0000FF } /* Name.Function */
.nl { color: #A0A000 } /* Name.Label */
.nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.nt { color: #008000; font-weight: bold } /* Name.Tag */
.nv { color: #19177C } /* Name.Variable */
.ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.w { color: #bbbbbb } /* Text.Whitespace */
.mb { color: #666666 } /* Literal.Number.Bin */
.mf { color: #666666 } /* Literal.Number.Float */
.mh { color: #666666 } /* Literal.Number.Hex */
.mi { color: #666666 } /* Literal.Number.Integer */
.mo { color: #666666 } /* Literal.Number.Oct */
.sa { color: #BA2121 } /* Literal.String.Affix */
.sb { color: #BA2121 } /* Literal.String.Backtick */
.sc { color: #BA2121 } /* Literal.String.Char */
.dl { color: #BA2121 } /* Literal.String.Delimiter */
.sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.s2 { color: #BA2121 } /* Literal.String.Double */
.se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.sh { color: #BA2121 } /* Literal.String.Heredoc */
.si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.sx { color: #008000 } /* Literal.String.Other */
.sr { color: #BB6688 } /* Literal.String.Regex */
.s1 { color: #BA2121 } /* Literal.String.Single */
.ss { color: #19177C } /* Literal.String.Symbol */
.bp { color: #008000 } /* Name.Builtin.Pseudo */
.fm { color: #0000FF } /* Name.Function.Magic */
.vc { color: #19177C } /* Name.Variable.Class */
.vg { color: #19177C } /* Name.Variable.Global */
.vi { color: #19177C } /* Name.Variable.Instance */
.vm { color: #19177C } /* Name.Variable.Magic */
.il { color: #666666 } /* Literal.Number.Integer.Long */

/* Estilo LPP */

body {
  font-family: Helvetica, arial, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  background-color: white;
  padding: 60px;
}

pre {
  background-color: #f8f8f8;
  border: 1px solid #cccccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px;
}

table {
  padding: 0;border-collapse: collapse; }
  table tr {
    border-top: 1px solid #cccccc;
    background-color: white;
    margin: 0;
    padding: 0; }
    table tr:nth-child(2n) {
      background-color: #f8f8f8; }
    table tr th {
      font-weight: bold;
      border: 1px solid #cccccc;
      margin: 0;
      padding: 6px 13px; }
    table tr td {
      border: 1px solid #cccccc;
      margin: 0;
      padding: 6px 13px; }
    table tr th :first-child, table tr td :first-child {
      margin-top: 0; }
    table tr th :last-child, table tr td :last-child {
      margin-bottom: 0; }

</style>

</head>

<body>
<h1>Semana 1</h1>
<p>Notas de clase de la semana 1 de LPP.</p>
<hr />
<h1>Tema 0: Presentación de la asignatura</h1>
<hr />
<p style="margin-bottom:2cm;"></p>

<ul>
<li>Usamos
  <a href="https://moodle2020-21.ua.es/moodle/course/view.php?id=8242">Moodle</a>
  para mostrar la planificación semanal, subir prácticas,
  etc. </li>
<li>Utilizaremos el foro para enviar avisos. También lo podéis usar
  vosotros para plantear dudas, consultas, etc. Así todos nos
  enteremos de las contestaciones.</li>
<li>Los apuntes y prácticas están en la web de apuntes de la asignatura: <a href="https://domingogallardo.github.io/apuntes-lpp/">https://domingogallardo.github.io/apuntes-lpp/</a>.</li>
</ul>
<p style="margin-bottom:2cm;"></p>

<h3>Temario</h3>
<ul>
<li>
<p>3 bloques temáticos:</p>
<ol>
<li>Programación funcional (Scheme): temas 1 y 2</li>
<li>Procesos y estructuras recursivas (Scheme): temas 3 y 4</li>
<li>Programación funcional en Swift y programación orientada a
   objetos avanzada (Swift): temas 5 y 6</li>
</ol>
</li>
<li>
<p>Temas:</p>
<ul>
<li>T1. Lenguajes de programación</li>
<li>T2. Programación Funcional</li>
<li>T3. Procedimientos recursivos</li>
<li>T4. Estructuras recursivas</li>
<li>T5. Programación funcional en Swift</li>
<li>T6. Programación Orientada a Objetos Avanzada en Swift</li>
</ul>
</li>
</ul>
<p style="margin-bottom:2cm;"></p>

<h3>Planificación</h3>
<p><img src="imagenes/planificacion.png" width="800px"/></p>
<p style="margin-bottom:2cm;"></p>

<h3>Horarios</h3>
<p><img src="imagenes/horario.png" width="800px"/></p>
<p>En los turnos de teoría es posible, de forma excepcional, asistir a un
grupo distinto del asignado. Los enlaces a las aulas online en las que se impartirán las clases son los
siguientes:</p>
<ul>
<li><a href="https://cvnet.cpd.ua.es/Docenciadual/AulaVirtual?eje=382&amp;vac=113472&amp;gac=331683&amp;ts=1611139908">Grupo 1</a> (jueves de 9:00 a 11:00 h.)</li>
<li><a href="https://cvnet.cpd.ua.es/Docenciadual/AulaVirtual?eje=382&amp;vac=113472&amp;gac=331684&amp;ts=1611139908">Grupo 2</a> (lunes de 9:00 a 11:00 h.)</li>
<li><a href="https://cvnet.cpd.ua.es/Docenciadual/AulaVirtual?eje=382&amp;vac=113472&amp;gac=331685&amp;ts=1611141615">Grupo 3</a> (lunes de 15:00 a 17:00 h.)</li>
<li><a href="https://cvnet.cpd.ua.es/Docenciadual/AulaVirtual?eje=382&amp;vac=113472&amp;gac=331686&amp;ts=1611141615">Grupo 4</a> (jueves de 17:00 a 19:00 h.)</li>
<li><a href="https://cvnet.cpd.ua.es/Docenciadual/AulaVirtual?eje=382&amp;vac=113472&amp;gac=1221840&amp;ts=1611141615">Grupo I2ADE</a>
  (lunes de 13:00 a 15:00 h.)</li>
</ul>
<p>En los turnos de prácticas se debe asistir al grupo al que se ha
asignado. El cambio de turno deberá solicitarse en la Secretaría de la EPS.</p>
<p style="margin-bottom:2cm;"></p>

<h3>Prácticas</h3>
<ul>
<li>2 seminarios: Scheme y Swift</li>
<li>12 hojas de ejercicios semanales en Scheme (temas 1-4) y Swift
  (temas 5-6).</li>
<li>Disponibles al comienzo de la semana y se realizarán en las sesiones
  de prácticas y en casa. Al final de la semana se entregarán en
  Moodle y se publicará la solución.</li>
</ul>
<div class="admonition danger">
<p class="admonition-title">No sirve de nada mirar las soluciones si no has trabajado</p>
<p>El objetivo de publicar la solución de los ejercicios es
que corrijas tú propia solución comparándola con la publicada.
En la clase de prácticas podrás preguntar a tu profesor cualquier
duda que te pueda surgir de esta revisión. Esta es la forma
correcta de aprender a programar. No sirve de nada aprender de
memoria las soluciones si no has trabajado previamente los
ejercicios.</p>
</div>
<p style="margin-bottom:2cm;"></p>

<h3>Evaluación</h3>
<p>La asignatura se divide en 3 bloques temáticos, todos ellos de igual
duración, en los que se utilizará el lenguaje de programación que
aparece entre paréntesis: </p>
<ul>
<li>Programación funcional (temas 1 y 2, Scheme)</li>
<li>Recursión y estructuras de datos recursivas (temas 3 y 4, Scheme)</li>
<li>Programación funcional en Swift y programación orientada a objetos (temas 5 y 6, Swift)</li>
</ul>
<p>Se realizarán tres exámenes parciales escritos sobre los conceptos de
cada uno de los bloques temáticos (teoría y práctica). Los parciales
tendrán la siguiente ponderación en la nota final: </p>
<ul>
<li>Parcial 1: 35%</li>
<li>Parcial 2: 30%</li>
<li>Parcial 3: 35%</li>
</ul>
<p>No se exige nota mínima en ninguno de los parciales. Los parciales 1 y
2 se realizarán durante el curso. El parcial 3 se realizará en la
fecha del examen oficial de la convocatoria ordinaria de la
asignatura. </p>
<div class="admonition danger">
<p class="admonition-title">Sobre los dispositivos móviles</p>
<p>Durante la realización de los exámenes no está permitido que llevéis encima
ningún dispositivo con conexión a internet (smartphones, smart
watches, tablets, etc). Antes de empezar la prueba, se deberán
dejar dentro de las mochilas, y éstas en el suelo. En caso de no
cumplir alguna esta norma, la prueba queda invalidada con
calificación de 0. </p>
</div>
<p style="margin-bottom:2cm;"></p>

<h3>Consejos para aprender con éxito</h3>
<ul>
<li>
<p>Consejos:</p>
<ul>
<li>Trabajar todas las semanas y seguir el ritmo de la asignatura.</li>
<li>Trabajar todos los ejemplos de teoría, probándolos en el
   ordenador y entendiéndolos (no aprenderlos de memoria)</li>
<li>Usar lápiz y papel para enfrentarse con los problemas</li>
</ul>
</li>
<li>
<p>Algunos comentarios:</p>
</li>
</ul>
<div class="admonition quote">
<p class="admonition-title">Cómo dominar los conceptos</p>
<p>Para superar la asignatura lo que hice fue estudiar mucho. Hay que practicar y sobre todo
entender los ejercicios y no sabérselos de memoria. Una vez
dominados los ejercicios yo mismo me propuse variantes de los
mismos. Así es como se domina.</p>
</div>
<div class="admonition quote">
<p class="admonition-title">No copiar las prácticas</p>
<p>El mayor problema que creo que existe es que muchas personas se
relajan y se copian las prácticas en cuanto les resultan un poco
difíciles o les lleva algo mas del tiempo que les gustaría. Esta
asignatura si no haces tu los ejercicios y te peleas con ellos es
prácticamente imposible de sacar.</p>
</div>
<div class="admonition quote">
<p class="admonition-title">No memorizar</p>
<p>Otra de las cosas es que tienes que cambiar la forma de estudiar,
no vale memorizar, ni hacer muchos ejercicios sin más. Tienes que
entender bien el funcionamiento de la recursión para luego poder
practicar con ejercicios, sino no sirve. [...] En mi opinión el
problema de LPP para mucha gente es que para los exámenes se
memorizan los ejercicios de prácticas de las soluciones que se dan
en clase.</p>
</div>
<p style="margin-bottom:2cm;"></p>

<hr />
<h1>Tema 1: Lenguajes de programación.</h1>
<p>Tema no presencial para estudiar en casa.</p>
<hr />
<p style="margin-bottom:2cm;"></p>

<h3>Algunos lenguajes importantes y su fecha de creación</h3>
<table>
<thead>
<tr>
<th align="center">1950-1960</th>
<th align="center">1970</th>
<th align="center">1980</th>
<th align="center">1990</th>
<th align="center">2000</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">1957 FORTRAN</td>
<td align="center">1970 Pascal</td>
<td align="center">1980 Smalltalk-80</td>
<td align="center">1990 Haskell</td>
<td align="center">2000 C#</td>
</tr>
<tr>
<td align="center">1958 ALGOL</td>
<td align="center">1972 Prolog</td>
<td align="center">1983 Objective-C</td>
<td align="center">1991 Python</td>
<td align="center">2003 Scala</td>
</tr>
<tr>
<td align="center">1960 Lisp</td>
<td align="center">1972 C</td>
<td align="center">1983 Ada</td>
<td align="center">1993 Ruby</td>
<td align="center">2003 Groovy</td>
</tr>
<tr>
<td align="center">1960 COBOL</td>
<td align="center">1975 Scheme</td>
<td align="center">1986 C++</td>
<td align="center">1995 Java</td>
<td align="center">2009 Go</td>
</tr>
<tr>
<td align="center">1962 APL</td>
<td align="center">1975 Modula</td>
<td align="center">1986 Eiffel</td>
<td align="center">1995 Racket</td>
<td align="center">2014 Swift</td>
</tr>
<tr>
<td align="center">1964 BASIC</td>
<td align="center"></td>
<td align="center">1987 Perl</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">1967 SIMULA</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody>
</table>
<p style="margin-bottom:2cm;"></p>

<h3>Genealogía de los lenguajes de programación</h3>
<p><img src="imagenes/genealogia-de-los-lp.png" width="600px"/></p>
<p style="margin-bottom:2cm;"></p>

<h3>Lista TIOBE</h3>
<p>La <a href="http://www.tiobe.com/index.php/content/paperinfo/tpci/index.html">lista
TIOBE</a>
se publica cada año indicando los lenguajes de programación más
populares.</p>
<p><img src="imagenes/lista-tiobe.png" width="800px"/></p>
<p><img src="imagenes/tpci_trends.png" width="800px"/></p>
<p style="margin-bottom:2cm;"></p>

<h3>Paradigmas de programación</h3>
<ul>
<li>Paradigmas más importantes de programación:<ul>
<li>Paradigma funcional (Lisp, Scheme, Haskell, Racket)</li>
<li>Paradigma lógico (Prolog)</li>
<li>Paradigma imperativo o procedural (FORTRAN, BASIC, C, JavaScript)</li>
<li>Paradigma orientado a objetos (Modula, Java, C++)</li>
</ul>
</li>
</ul>
<hr />
<h1>Tema 2: Programación funcional</h1>
<h3>Veremos hoy</h3>
<ol>
<li>El paradigma de Programación Funcional<ul>
<li>1.1 Pasado y presente del paradigma funcional</li>
<li>1.2. Programación declarativa vs. imperativa</li>
<li>1.3. Evaluación de expresiones</li>
<li>1.4. Modelo de computación de sustitución</li>
</ul>
</li>
<li>Scheme como lenguaje de programación funcional<ul>
<li>2.1. Funciones y formas especiales</li>
<li>2.2. Formas especiales en Scheme: define, if, cond</li>
<li>2.3. Forma especial quote y símbolos</li>
<li>2.4. Listas</li>
</ul>
</li>
</ol>
<hr />
<p style="margin-bottom:2cm;"></p>

<h3>Definición de programación funcional</h3>
<div class="admonition note">
<p class="admonition-title">Un programa funcional es</p>
<p>Un conjunto de funciones matemáticas que convierten
unas entradas en unas salidas, sin ningún estado interno y ningún
efecto lateral.</p>
</div>
<ul>
<li>Es posible utilizar este paradigma en muchos lenguajes de
  programación, aunque no sean estrictamente funcionales.</li>
</ul>
<p style="margin-bottom:2cm;"></p>

<h3>Principales características del paradigma funcional</h3>
<ul>
<li>Definiciones de funciones matemáticas puras, sin estado interno ni
  efectos laterales</li>
<li>Valores inmutables</li>
<li>Uso profuso de la recursión en la definición de las funciones</li>
<li>Uso de listas como estructuras de datos fundamentales</li>
<li>Funciones como tipos de datos primitivos: expresiones lambda y
  funciones de orden superior</li>
</ul>
<p style="margin-bottom:2cm;"></p>

<h3>Lenguajes de programación funcional</h3>
<p>Lenguajes modernos principalmente funcionales:</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Clojure">Clojure</a></li>
<li><a href="https://en.wikipedia.org/wiki/Erlang_(programming_language)">Erlang</a></li>
</ul>
<p>Lenguajes multi-paradigma en los que se puede usar POO y PF:</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Ruby_(programming_language)">Ruby</a></li>
<li><a href="https://en.wikipedia.org/wiki/Python_(programming_language)">Python</a></li>
<li><a href="https://en.wikipedia.org/wiki/Groovy_(programming_language)">Groovy</a></li>
<li><a href="https://en.wikipedia.org/wiki/Scala_(programming_language)">Scala</a></li>
<li><a href="https://en.wikipedia.org/wiki/Swift_(programming_language)">Swift</a></li>
</ul>
<p>Lenguaje funcional puro más importante:</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Haskell_(programming_language)">Haskell</a></li>
</ul>
<p style="margin-bottom:2cm;"></p>

<h3>Aplicaciones prácticas de la programación funcional</h3>
<ul>
<li>Paradigma muy popular en la actualidad</li>
<li>
<p>Algunos artículos y charlas:</p>
<ul>
<li>Lupo Montero - <a href="https://medium.com/laboratoria-how-to/introducción-a-la-programación-funcional-en-javascript-parte-1-e0b1d0b2142e">Introducción a la programación funcional en JavaScript</a> (Blog)</li>
<li>Andrés Marzal - <a href="https://www.youtube.com/watch?v=YU2i3L-euB0">Por qué deberías aprender programación funcional ya mismo</a> (Charla en YouTube)</li>
<li>Mary Rose Cook - <a href="https://maryrosecook.com/blog/post/a-practical-introduction-to-functional-programming">A practical introduction to functional programming</a> (Blog)</li>
<li>Ben Christensen - <a href="https://www.infoq.com/presentations/Netflix-API-rxjava-hystrix">Functional Reactive Programming in the Netflix API</a> (Charla en InfoQ)</li>
</ul>
</li>
<li>
<p>El paradigma funcional facilita:</p>
<ul>
<li>la programación de sistemas concurrentes, con múltiples hilos de
  ejecución o con múltiples computadores ejecutando procesos
  conectados concurrentes.</li>
<li>la definición y composición de múltiples operaciones sobre
  <em>streams</em> de forma muy concisa y compacta, aplicable a la
  programación de sistemas distribuidos en Internet.</li>
<li>la programación interactiva y evolutiva.</li>
</ul>
</li>
</ul>
<p style="margin-bottom:2cm;"></p>

<h3>Evaluación de expresiones y definición de funciones</h3>
<ul>
<li>
<p>En la asignatura usaremos Scheme como primer lenguaje en el que
  exploraremos la programación funcional.</p>
</li>
<li>
<p>En el seminario de Scheme que se imparte en prácticas se estudiará
  en más profundidad los conceptos más importantes del lenguaje: tipos
  de datos, operadores, estructuras de control, intérprete, etc.</p>
</li>
<li>
<p>Vamos a empezar a ver ejemplo concretos de programación funcional
  viendo cómo se evalúan expresiones y cómo se definen funciones en Scheme.</p>
</li>
</ul>
<p style="margin-bottom:2cm;"></p>

<h3>Evaluación de expresiones</h3>
<div class="highlight"><pre><span></span><code><span class="mi">2</span> <span class="n">⇒</span> <span class="mi">2</span>
<span class="p">(</span><span class="nb">+</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">)</span> <span class="n">⇒</span> <span class="mi">5</span>
<span class="p">(</span><span class="nb">+</span><span class="p">)</span> <span class="n">⇒</span> <span class="mi">0</span>
<span class="p">(</span><span class="nb">+</span> <span class="mi">2</span> <span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span><span class="p">)</span> <span class="n">⇒</span> <span class="mi">17</span>
<span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="nb">*</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">)</span> <span class="p">(</span><span class="nb">-</span> <span class="mi">3</span> <span class="mi">1</span><span class="p">))</span> <span class="n">⇒</span> <span class="mi">8</span>
</code></pre></div>
<p>Se dice "<strong>evaluar una expresión</strong>" en lugar de "<strong>ejecutar una expresión</strong>".</p>
<p>Partes de una expresión:</p>
<ul>
<li>Operador</li>
<li>Operandos</li>
<li>Evaluación de dentro a fuera</li>
</ul>
<p>Por ejemplo, ¿cuál es la evaluación de la siguiente expresión?:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="nb">*</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">)</span> <span class="p">(</span><span class="nb">-</span> <span class="mi">3</span> <span class="p">(</span><span class="nb">/</span> <span class="mi">12</span> <span class="mi">3</span><span class="p">)))</span>
</code></pre></div>
<p style="margin-bottom:3cm;"></p>

<h3>Definición de funciones</h3>
<p>Definición</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="n">cuadrado</span> <span class="n">x</span><span class="p">)</span>
   <span class="p">(</span><span class="nb">*</span> <span class="n">x</span> <span class="n">x</span><span class="p">))</span>
</code></pre></div>
<p>Uso y evaluación:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="n">cuadrado</span> <span class="mi">10</span><span class="p">)</span> <span class="n">⇒</span> <span class="mi">100</span>
<span class="p">(</span><span class="n">cuadrado</span> <span class="p">(</span><span class="nb">+</span> <span class="mi">10</span> <span class="p">(</span><span class="n">cuadrado</span> <span class="p">(</span><span class="nb">+</span> <span class="mi">2</span> <span class="mi">4</span><span class="p">))))</span> <span class="n">⇒</span> <span class="mi">2116</span>
</code></pre></div>
<p style="margin-bottom:2cm;"></p>

<h3>Definición de funciones auxiliares</h3>
<ul>
<li>
<p>Lo habitual en programación funcional es definir funciones muy
pequeñas e ir construyendo funciones cada vez de mayor nivel usando
las anteriores.</p>
</li>
<li>
<p>No demasiado bien:</p>
</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="n">suma-cuadrados</span> <span class="n">x</span> <span class="n">y</span><span class="p">)</span>
   <span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="nb">*</span> <span class="n">x</span> <span class="n">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">*</span> <span class="n">y</span> <span class="n">y</span><span class="p">)))</span>
</code></pre></div>
<ul>
<li>Mucho más correcto:</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="n">cuadrado</span> <span class="n">x</span><span class="p">)</span>
   <span class="p">(</span><span class="nb">*</span> <span class="n">x</span> <span class="n">x</span><span class="p">))</span>

<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="n">suma-cuadrados</span> <span class="n">x</span> <span class="n">y</span><span class="p">)</span>
   <span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="n">cuadrado</span> <span class="n">x</span><span class="p">)</span> <span class="p">(</span><span class="n">cuadrado</span> <span class="n">y</span><span class="p">)))</span>
</code></pre></div>
<p style="margin-bottom:2cm;"></p>

<h3>Funciones puras</h3>
<ul>
<li>No modifican los parámetros que se les pasa</li>
<li>Devuelven un único resultado</li>
<li>No tienen estado local ni el resultado depende de un estado exterior mutable</li>
</ul>
<p style="margin-bottom:2cm;"></p>

<h3>Composición de funciones</h3>
<ul>
<li>Una idea fundamental de la programación funcional es la composición de
funciones que transforman unos datos de entrada en otros de salida. </li>
<li>Ejemplo: procesamiento de imágenes en vehículos autónomos:</li>
</ul>
<p><img src="imagenes/composicion-funciones.png" width="700px"/></p>
<ul>
<li>En un lenguaje de programación funcional como Scheme (cuidado: la evaluación
  se hace de dentro a afuera):</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="n">conduce-vehiculo</span> <span class="n">imagenes</span><span class="p">)</span>
    <span class="p">(</span><span class="n">obten-acciones</span> 
        <span class="p">(</span><span class="n">reconoce</span> 
            <span class="p">(</span><span class="n">filtra</span> 
                <span class="p">(</span><span class="n">obten-caracteristicas</span> <span class="n">imagenes</span><span class="p">)))))</span>
</code></pre></div>
<p style="margin-bottom:2cm;"></p>

<h3>Programación declarativa</h3>
<ul>
<li>La PF es un estilo de <strong>programación declarativa</strong>, frente a la
  programación tradicional imperativa.</li>
<li>Frente a programación imperativa, basada en pasos de ejecución y
  cambio de estado de variables, la programación declarativa es un
  estilo de programación matemático.</li>
<li>Se <strong>declaran</strong> valores y objetivos o características de los
  elementos de programa.</li>
<li>La ejecución del programa es "instantánea", sin que haya que
  considerar los pasos de ejecución.</li>
<li>Ejemplo: hoja de cálculo.</li>
<li>La programación funcional es un ejemplo de programación declarativa:
  se declaran funciones y se evalúan matemáticamente expresiones.</li>
<li>La programación lógica (Prolog) es otro ejemplo de programación declarativa.</li>
</ul>
<p>Otro ejemplo de programación declarativa: SwiftUI.</p>
<p><img src="imagenes/swiftui.png" width="700px"/></p>
<ul>
<li>Como hemos visto, en programación funcional <strong>declaramos funciones</strong>
que transforman datos de entrada en datos de salida.</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="n">cuadrado</span> <span class="n">x</span><span class="p">)</span>
   <span class="p">(</span><span class="nb">*</span> <span class="n">x</span> <span class="n">x</span><span class="p">))</span>
</code></pre></div>
<ul>
<li>La llamada a la función con el parámetro 4 devuelve 16:</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="n">cuadrado</span> <span class="mi">4</span><span class="p">)</span> <span class="c1">; devuelve 16</span>
</code></pre></div>
<p style="margin-bottom:2cm;"></p>

<h3>Programación imperativa</h3>
<ul>
<li>Lenguajes tradicionales (C, C++, Java, Python, etc.)</li>
</ul>
<p>Características:</p>
<ul>
<li>Pasos de ejecución</li>
<li>Mutación</li>
<li>Efectos laterales</li>
<li>Estado local mutable en las funciones</li>
</ul>
<p style="margin-bottom:2cm;"></p>

<h3>Pasos de ejecución</h3>
<p>Pasos de ejecución en C:</p>
<div class="highlight"><pre><span></span><code><span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="n">cuadrado</span><span class="p">(</span><span class="mi">8</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="n">doble</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="n">cuadrado</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
<span class="k">return</span> <span class="n">c</span>
</code></pre></div>
<p>En Swift:</p>
<div class="highlight"><pre><span></span><code><span class="n">filtrados</span> <span class="p">=</span> <span class="n">filtra</span><span class="p">(</span><span class="n">pedidos</span><span class="p">);</span>
<span class="n">procesados</span> <span class="p">=</span> <span class="n">procesa</span><span class="p">(</span><span class="n">filtrados</span><span class="p">);</span>
<span class="k">return</span> <span class="n">procesados</span><span class="p">;</span>
</code></pre></div>
<p>En programación funcional, en lugar de pasos de ejecución se utiliza
como hemos visto la composición de funciones. Los ejemplos anteriores
se expresan de la siguiente forma en programación funcional:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="n">cuadrado</span> <span class="p">(</span><span class="n">doble</span> <span class="p">(</span><span class="n">cuadrado</span> <span class="mi">8</span><span class="p">)))</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="n">procesa</span> <span class="p">(</span><span class="n">filtra</span> <span class="n">pedidos</span><span class="p">))</span>
</code></pre></div>
<p style="margin-bottom:2cm;"></p>

<h3>Mutación</h3>
<p>Asignación destructiva o mutación:</p>
<div class="highlight"><pre><span></span><code><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</code></pre></div>
<p>En programación funcional los valores definidos son inmutables:</p>
<div class="highlight"><pre><span></span><code><span class="kn">#lang </span><span class="nn">racket</span>

<span class="p">(</span><span class="k">define</span> <span class="n">a</span> <span class="mi">12</span><span class="p">)</span>
<span class="p">(</span><span class="k">define</span> <span class="n">a</span> <span class="mi">200</span><span class="p">)</span>
</code></pre></div>
<p>tendremos el siguiente error:</p>
<div class="highlight"><pre><span></span><code>module: identifier already defined in: a
</code></pre></div>
<p>En lenguajes imperativos también hay sentencias declarativas:</p>
<div class="highlight"><pre><span></span><code>1. int x = 1;   // declarativa
2. x = x+1;     // imperativa
3. int y = x+1; // declarativa
4. y = x;       // imperativa
</code></pre></div>
<p style="margin-bottom:2cm;"></p>

<h3>Mutación y efectos laterales</h3>
<ul>
<li>Referencias + mutación = efectos laterales (<em>side effect</em> en inglés)</li>
</ul>
<p>Ejemplo de mutación:</p>
<div class="highlight"><pre><span></span><code><span class="n">Point2D</span> <span class="n">p1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Point2D</span><span class="p">(</span><span class="mf">3.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">);</span> <span class="c1">// la coord x de p1 es 3.0</span>
<span class="n">p1</span><span class="p">.</span><span class="na">getCoordX</span><span class="p">();</span> <span class="c1">// la coord x de p1 es 3.0</span>
<span class="n">p1</span><span class="p">.</span><span class="na">setCoordX</span><span class="p">(</span><span class="mf">10.0</span><span class="p">);</span>
<span class="n">p1</span><span class="p">.</span><span class="na">getCoordX</span><span class="p">();</span> <span class="c1">// la coord x de p1 es 10.0</span>
</code></pre></div>
<p>Ejemplo de efecto lateral:</p>
<div class="highlight"><pre><span></span><code><span class="n">Point2D</span> <span class="n">p1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Point2D</span><span class="p">(</span><span class="mf">3.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">);</span> <span class="c1">// la coord x de p1 es 3.0</span>
<span class="n">p1</span><span class="p">.</span><span class="na">getCoordX</span><span class="p">();</span> <span class="c1">// la coord x de p1 es 3.0</span>
<span class="n">Point2D</span> <span class="n">p2</span> <span class="o">=</span> <span class="n">p1</span><span class="p">;</span>
<span class="n">p2</span><span class="p">.</span><span class="na">setCoordX</span><span class="p">(</span><span class="mf">10.0</span><span class="p">);</span>
<span class="n">p1</span><span class="p">.</span><span class="na">getCoordX</span><span class="p">();</span> <span class="c1">// la coord x de p1 es 10.0, sin que ninguna sentencia haya modificado directamente p1</span>
</code></pre></div>
<ul>
<li>Los efectos laterales permiten definir estructuras de datos más
  eficientes, pero también generan <em>bugs</em> complicados de
  depurar. Sobre todo cuando se están programando sistemas
  concurrentes con múltiples hilos de ejecución.</li>
</ul>
<p style="margin-bottom:2cm;"></p>

<h3>Estado local mutable</h3>
<p>Función con estado local mutable en lenguaje imperativo (Java):</p>
<div class="highlight"><pre><span></span><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Contador</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">c</span><span class="p">;</span>

    <span class="kd">public</span> <span class="nf">Contador</span><span class="p">(</span><span class="kt">int</span> <span class="n">valorInicial</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">valorInicial</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">valor</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">c</span><span class="o">++</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">c</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="n">Contador</span> <span class="n">cont</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Contador</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
<span class="n">cont</span><span class="p">.</span><span class="na">valor</span><span class="p">();</span> <span class="c1">// 11</span>
<span class="n">cont</span><span class="p">.</span><span class="na">valor</span><span class="p">();</span> <span class="c1">// 12</span>
<span class="n">cont</span><span class="p">.</span><span class="na">valor</span><span class="p">();</span> <span class="c1">// 13</span>
</code></pre></div>
<p>En C:</p>
<div class="highlight"><pre><span></span><code><span class="kt">int</span> <span class="n">function</span> <span class="n">contador</span> <span class="p">()</span> <span class="p">{</span>
    <span class="k">static</span> <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="n">c</span><span class="o">++</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">c</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">contador</span><span class="p">()</span> <span class="p">;;</span> <span class="mi">1</span>
<span class="n">contador</span><span class="p">()</span> <span class="p">;;</span> <span class="mi">2</span>
<span class="n">contador</span><span class="p">()</span> <span class="p">;;</span> <span class="mi">3</span>
</code></pre></div>
<p><strong>Por el contrario</strong>, los lenguajes funcionales puros tienen la propiedad
de <em>transparencia referencial</em>: si se sustituye una expresión por su
valor el resultado final no debe cambiar. -&gt; funciones no modifican estado.</p>
<p style="margin-bottom:2cm;"></p>

<h3>Resumen</h3>
<p><strong>Características de la programación declarativa</strong></p>
<ul>
<li>Variable = nombre dado a un valor (declaración)</li>
<li>No existe asignación ni cambio de estado</li>
<li>No existe mutación, se cumple la <em>transferencia referencial</em>: dentro
  de un mismo ámbito todas las ocurrencias de una variable y las
  llamadas a funciones devuelven el mismo valor</li>
</ul>
<p><strong>Características de la programación imperativa</strong></p>
<ul>
<li>Variable = nombre de una zona de memoria</li>
<li>Asignación</li>
<li>Referencias</li>
<li>Pasos de ejecución</li>
</ul>
<p style="margin-bottom:2cm;"></p>

<h3>Modelo de computación de sustitución</h3>
<ul>
<li>
<p>El <strong>modelo de sustitución</strong> es un modelo muy sencillo que permite
definir la semántica de la evaluación de expresiones en lenguajes
funcionales como Scheme. </p>
</li>
<li>
<p>Basado en la reescritura de unos términos por otros</p>
</li>
</ul>
<div class="admonition note">
<p class="admonition-title">Reglas del modelo de sustitución</p>
<ol>
<li>Si <em>e</em> es un valor primitivo (por ejemplo, un número), devolvemos ese
   mismo valor.</li>
<li>Si <em>e</em> es un identificador, devolvemos su valor asociado con un
   <code>define</code> (se lanzará un error si no existe ese valor).</li>
<li>Si <em>e</em> es una expresión del tipo <em>(f arg1 ... argn)</em>, donde <em>f</em> es
   el nombre de una función primitiva (<code>+</code>, <code>-</code>, ...), evaluamos uno a
   uno los argumentos <em>arg1</em> ... <em>argn</em> (con estas mismas reglas) y
   evaluamos la función primitiva con los resultados.</li>
</ol>
</div>
<p>La regla 4 tiene dos variantes, dependiendo del orden de
evaluación que utilizamos.</p>
<div class="admonition note">
<p class="admonition-title">Orden aplicativo</p>
<ol start="4">
<li>Si <em>e</em> es una expresión del tipo <em>(f arg1 ... argn)</em>, donde <em>f</em>
   es el nombre de una función definida con un <code>define</code>, tenemos
   que evaluar primero los argumentos <em>arg1</em> ... <em>argn</em> y después
   <strong>sustituir <em>f</em> por su cuerpo</strong>, reemplazando cada parámetro
   formal de la función por el correspondiente <strong>argumento
   evaluado</strong>. Después evaluaremos la expresión resultante usando
   estas mismas reglas.</li>
</ol>
</div>
<div class="admonition note">
<p class="admonition-title">Orden normal</p>
<ol start="4">
<li>Si <em>e</em> es una expresión del tipo <em>(f arg1 ... argn)</em>, donde <em>f</em>
   es el nombre de una función definida con un <code>define</code>, tenemos
   que <strong>sustituir <em>f</em> por su cuerpo</strong>, reemplazando cada
   parámetro formal de la función por el correspondiente
   <strong>argumento sin evaluar</strong>. Después evaluar la expresión
   resultante usando estas mismas reglas.</li>
</ol>
</div>
<ul>
<li>
<p>Ambas formas de evaluación darán el mismo resultado en programación
funcional. Scheme utiliza el orden aplicativo.</p>
</li>
<li>
<p>En el orden aplicativo se realizan las evaluaciones antes de realizar
las sustituciones, lo que define una evaluación de <em>dentro a fuera</em> de
los paréntesis. Cuando se llega a una expresión primitiva se
evalúa.</p>
</li>
<li>
<p>En el orden normal se realizan todas las sustituciones hasta que se
tiene una larga expresión formada por expresiones primitivas; se
evalúa entonces.</p>
</li>
<li>
<p>Comprobamos las sustituciones en cada tipo de orden.</p>
</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="n">doble</span> <span class="n">x</span><span class="p">)</span> 
    <span class="p">(</span><span class="nb">+</span> <span class="n">x</span> <span class="n">x</span><span class="p">))</span>

<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="n">cuadrado</span> <span class="n">y</span><span class="p">)</span> 
    <span class="p">(</span><span class="nb">*</span> <span class="n">y</span> <span class="n">y</span><span class="p">))</span>

<span class="p">(</span><span class="k">define</span> <span class="n">a</span> <span class="mi">2</span><span class="p">)</span>

<span class="p">(</span><span class="n">doble</span> <span class="p">(</span><span class="n">cuadrado</span> <span class="n">a</span><span class="p">))</span>
</code></pre></div>
<p>Orden aplicativo:</p>
<div class="highlight"><pre><span></span><code>(doble (cuadrado a)) ⇒       ; Sustituimos a por su valor (R2)
(doble (cuadrado 2)) ⇒       ; Sustitumos cuadrado por su cuerpo (R4)
(doble (* 2 2)) ⇒            ; Evaluamos (* 2 2) (R3)
(doble 4) ⇒                  ; Sustituimos doble por su cuerpo (R4)
(+ 4 4) ⇒                    ; Evaluamos (+ 4 4) (R3)
8
</code></pre></div>
<p>Orden normal:</p>
<div class="highlight"><pre><span></span><code>(doble (cuadrado a)) ⇒            ; Sustituimos doble por su cuerpo (R4)
(+ (cuadrado a) (cuadrado a) ⇒    ; Sustituimos cuadrado por su cuerpo (R4)
(+ (* a a) (* a a)  ⇒             ; Sustitumos a por su valor (R2)
(+ (* 2 2) (* 2 2)  ⇒             ; Evaluamos (* 2 2) (R3)
(+ 4 (* 2 2))  ⇒                  ; Evaluamos (* 2 2) (R3)
(+ 4 4)  ⇒                        ; Evaluamos (+ 4 4) (R3)
8
</code></pre></div>
<ul>
<li>Scheme utiliza orden aplicativo.</li>
<li>Repasar un ejemplo algo más complicado en los apuntes.</li>
<li>El resultado es el mismo, siempre que no se definan funciones no puras.</li>
</ul>
<p>Ejemplo de resultado distinto con funciones no puras:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="n">zero</span> <span class="n">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">-</span> <span class="n">x</span> <span class="n">x</span><span class="p">))</span>
<span class="p">(</span><span class="n">zero</span> <span class="p">(</span><span class="nb">random</span> <span class="mi">10</span><span class="p">))</span>
</code></pre></div>
<p style="margin-bottom:2cm;"></p>

<h3>Funciones y formas especiales en Scheme</h3>
<ul>
<li>Primitivas de Scheme: funciones y formas especiales</li>
<li>Las funciones se evalúan con el modelo de evaluación visto. </li>
<li>Las <em>formas especiales</em> son expresiones primitivas de Scheme que
tienen una forma de evaluarse propia, distinta de las funciones.</li>
</ul>
<p style="margin-bottom:2cm;"></p>

<h3>Forma especial <code>define</code></h3>
<p><strong>Sintaxis</strong></p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span> <span class="n">&lt;identificador&gt;</span> <span class="n">&lt;expresión&gt;</span><span class="p">)</span>
</code></pre></div>
<p><strong>Evaluación</strong></p>
<ol>
<li>Evaluar <em>expresión</em></li>
<li>Asociar el valor resultante con el <em>identificador</em></li>
</ol>
<p><strong>Ejemplo</strong></p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span> <span class="n">base</span> <span class="mi">10</span><span class="p">)</span>   <span class="c1">; Asociamos a &#39;base&#39; el valor 10</span>
<span class="p">(</span><span class="k">define</span> <span class="n">altura</span> <span class="mi">12</span><span class="p">)</span> <span class="c1">; Asociamos a &#39;altura&#39; el valor 12</span>
<span class="p">(</span><span class="k">define</span> <span class="n">area</span> <span class="p">(</span><span class="nb">/</span> <span class="p">(</span><span class="nb">*</span> <span class="n">base</span> <span class="n">altura</span><span class="p">)</span> <span class="mi">2</span><span class="p">))</span> <span class="c1">; Asociamos a &#39;area&#39; el valor 60</span>
</code></pre></div>
<p style="margin-bottom:2cm;"></p>

<h3>Forma especial <code>define</code> para definir funciones</h3>
<p><strong>Sintaxis</strong></p>
<div class="highlight"><pre><span></span><code>(define (&lt;nombre-funcion&gt; &lt;argumentos&gt;)
    &lt;cuerpo&gt;)
</code></pre></div>
<p><strong>Evaluación</strong></p>
<ol>
<li>Crear la función con el <em>cuerpo</em></li>
<li>Dar a la función el nombre <em>nombre-función</em></li>
</ol>
<p><strong>Ejemplo</strong></p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="n">factorial</span> <span class="n">x</span><span class="p">)</span>
    <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">=</span> <span class="n">x</span> <span class="mi">0</span><span class="p">)</span>
        <span class="mi">1</span>
        <span class="p">(</span><span class="nb">*</span> <span class="n">x</span> <span class="p">(</span><span class="n">factorial</span> <span class="p">(</span><span class="nb">-</span> <span class="n">x</span> <span class="mi">1</span><span class="p">)))))</span>
</code></pre></div>
<p style="margin-bottom:2cm;"></p>

<h3>Forma especial <code>if</code></h3>
<p><strong>Sintaxis</strong></p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">if</span> <span class="n">&lt;condición&gt;</span> <span class="n">&lt;expresión-true&gt;</span> <span class="n">&lt;expresión-false&gt;</span><span class="p">)</span>
</code></pre></div>
<p><strong>Evaluación</strong></p>
<ol>
<li>Evaluar <em>condición</em></li>
<li>Si el resultado es <code>#t</code> evaluar la <em>expresión-true</em>, en otro
   caso, evaluar la <em>expresión-false</em></li>
</ol>
<p><strong>Ejemplo</strong></p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">&gt;</span> <span class="mi">10</span> <span class="mi">5</span><span class="p">)</span> <span class="p">(</span><span class="nb">substring</span> <span class="s2">&quot;Hola qué tal&quot;</span> <span class="p">(</span><span class="nb">+</span> <span class="mi">1</span> <span class="mi">1</span><span class="p">)</span> <span class="mi">4</span><span class="p">)</span> <span class="p">(</span><span class="nb">/</span> <span class="mi">12</span> <span class="mi">0</span><span class="p">))</span>

<span class="c1">;; Evaluamos (&gt; 10 5). Como el resultado es #t, evaluamos </span>
<span class="c1">;; (substring &quot;Hola qué tal&quot; (+ 1 1) 4), que devuelve &quot;la&quot;</span>
</code></pre></div>
<p style="margin-bottom:2cm;"></p>

<h3>Forma especial <code>cond</code></h3>
<p><strong>Sintaxis</strong></p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">cond</span> 
    <span class="p">(</span><span class="n">&lt;exp-cond-1&gt;</span> <span class="n">&lt;exp-consec-1&gt;</span><span class="p">)</span>
    <span class="p">(</span><span class="n">&lt;exp-cond-2&gt;</span> <span class="n">&lt;exp-consec-2&gt;</span><span class="p">)</span>
    <span class="k">...</span>
    <span class="p">(</span><span class="k">else</span> <span class="n">&lt;exp-consec-else&gt;</span><span class="p">))</span>
</code></pre></div>
<p><strong>Evaluación</strong></p>
<ol>
<li>Se evalúan de forma ordenada todas las expresiones hasta que una de
   ellas devuelva <code>#t</code></li>
<li>Si alguna expresión devuelve <code>#t</code>, se devuelve el valor del
   consecuente de esa expresión</li>
<li>Si ninguna expresión es cierta, se devuelve el valor resultante de
   evaluar el consecuente del <code>else</code></li>
</ol>
<p><strong>Ejemplo</strong></p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">cond</span>
   <span class="p">((</span><span class="nb">&gt;</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">)</span> <span class="s2">&quot;3 es mayor que 4&quot;</span><span class="p">)</span>
   <span class="p">((</span><span class="nb">&lt;</span> <span class="mi">2</span> <span class="mi">1</span><span class="p">)</span> <span class="s2">&quot;2 es menor que 1&quot;</span><span class="p">)</span>
   <span class="p">((</span><span class="nb">=</span> <span class="mi">3</span> <span class="mi">1</span><span class="p">)</span> <span class="s2">&quot;3 es igual que 1&quot;</span><span class="p">)</span>
   <span class="p">((</span><span class="nb">&gt;</span> <span class="mi">3</span> <span class="mi">5</span><span class="p">)</span> <span class="s2">&quot;3 es mayor que 2&quot;</span><span class="p">)</span>
   <span class="p">(</span><span class="k">else</span> <span class="s2">&quot;ninguna condición es cierta&quot;</span><span class="p">))</span>

<span class="c1">;; Se evalúan una a una las expresiones (&gt; 3 4),</span>
<span class="c1">;; (&lt; 2 1), (= 3 1) y (&gt; 3 5). Como ninguna de ella</span>
<span class="c1">;; es cierta se devuelve la cadena &quot;ninguna condición es cierta&quot;</span>
</code></pre></div>
<p style="margin-bottom:2cm;"></p>

<h3>Forma especial <code>quote</code> y símbolos</h3>
<p><strong>Sintaxis</strong></p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">quote</span> <span class="ss">&lt;identificador&gt;</span><span class="p">)</span>
</code></pre></div>
<p><strong>Evaluación</strong></p>
<ul>
<li>Se devuelve el identificador sin evaluar (un símbolo). </li>
<li>Se abrevia en con el carácter <code>'</code>.</li>
</ul>
<p><strong>Ejemplo</strong></p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">quote</span> <span class="ss">x</span><span class="p">)</span> <span class="c1">; el símbolo x</span>
<span class="o">&#39;</span><span class="ss">hola</span> <span class="c1">; el símbolo hola</span>
</code></pre></div>
<ul>
<li>
<p>En Scheme los <em>identificadores</em> (nombres que se les da a las
variables) son datos del lenguaje de tipo <strong>symbol</strong>. </p>
</li>
<li>
<p>Los símbolos son distintos de las cadenas. Una cadena es un tipo de
dato compuesto formado por caracteres que podemos concatenar, dividir
en subcadenas, etc. Nada de esto lo podemos hacer con un símbolo. Un
símbolo es un tipo atómico, es sólo un identificador.</p>
</li>
</ul>
<p>Ejemplos de funciones Scheme con símbolos:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span> <span class="n">x</span> <span class="mi">12</span><span class="p">)</span>
<span class="p">(</span><span class="nb">symbol?</span> <span class="o">&#39;</span><span class="ss">x</span><span class="p">)</span> <span class="c1">; ⇒ #t</span>
<span class="p">(</span><span class="nb">symbol?</span> <span class="n">x</span><span class="p">)</span> <span class="c1">; ⇒ #f ¿Por qué?</span>
<span class="p">(</span><span class="nb">symbol?</span> <span class="o">&#39;</span><span class="ss">hola-que&lt;&gt;</span><span class="p">)</span>
<span class="p">(</span><span class="nb">symbol-&gt;string</span> <span class="o">&#39;</span><span class="ss">hola-que&lt;&gt;</span><span class="p">)</span>
<span class="o">&#39;</span><span class="ss">mañana</span>
<span class="o">&#39;</span><span class="ss">lápiz</span> <span class="c1">; aunque sea posible, no vamos a usar acentos en los símbolos</span>
<span class="c1">; pero sí en los comentarios</span>
<span class="p">(</span><span class="nb">symbol?</span> <span class="s2">&quot;hola&quot;</span><span class="p">)</span> <span class="c1">; #f</span>
<span class="p">(</span><span class="nb">symbol?</span>  <span class="no">#f</span><span class="p">)</span> <span class="c1">; #f</span>
<span class="p">(</span><span class="nb">symbol?</span> <span class="p">(</span><span class="nb">car</span> <span class="o">&#39;</span><span class="p">(</span><span class="ss">hola</span> <span class="ss">cómo</span> <span class="ss">estás</span><span class="p">)))</span> <span class="c1">; #t</span>
<span class="p">(</span><span class="nb">equal?</span> <span class="o">&#39;</span><span class="ss">hola</span> <span class="o">&#39;</span><span class="ss">hola</span><span class="p">)</span>
<span class="p">(</span><span class="nb">equal?</span> <span class="o">&#39;</span><span class="ss">hola</span> <span class="s2">&quot;hola&quot;</span><span class="p">)</span>
</code></pre></div>
<p>Un símbolo es un identificador que puede asociarse o ligarse (<em>bind</em>)
a un valor (cualquier dato <em>de primera clase</em>).</p>
<p>Cuando escribimos un símbolo en el prompt de Scheme el intérprete lo
evalúa y devuelve su valor:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span> <span class="nb">pi</span> <span class="mf">3.14159</span><span class="p">)</span>
<span class="nb">pi</span>
<span class="n">⇒3.14159</span>
</code></pre></div>
<p>Los nombres de las funciones (<code>equal?,</code>sin, `+, ...) son también
símbolos (los de las macros no) y Scheme también los evalúa (en un par
de semanas hablaremos de las funciones como objetos primitivos en
Scheme):</p>
<div class="highlight"><pre><span></span><code><span class="nb">sin</span>
<span class="n">⇒</span> <span class="n">#&lt;procedure:sin&gt;</span>
<span class="nb">+</span>
<span class="n">⇒</span> <span class="n">#&lt;procedure:+&gt;</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="n">cuadrado</span> <span class="n">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">*</span> <span class="n">x</span> <span class="n">x</span><span class="p">))</span>
<span class="n">⇒</span> <span class="n">#&lt;procedure:cuadrado&gt;</span>
</code></pre></div>
<p style="margin-bottom:2cm;"></p>

<h3>Símbolos como tipos primitivos</h3>
<p>Los símbolos son tipos primitivos del lenguaje: pueden pasarse como
parámetros o ligarse a variables.</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span> <span class="n">x</span> <span class="o">&#39;</span><span class="ss">hola</span><span class="p">)</span>
<span class="n">x</span>
<span class="n">⇒</span> <span class="n">hola</span>
</code></pre></div>
<p style="margin-bottom:2cm;"></p>

<h3>Forma especial <code>quote</code> y expresiones</h3>
<p><strong>Sintaxis</strong></p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">quote</span> <span class="ss">&lt;expresión&gt;</span><span class="p">)</span>
</code></pre></div>
<p><strong>Evaluación</strong></p>
<p>Si <code>quote</code> recibe una expresión correcta de Scheme (una expresión
entre paréntesis) se devuelve la lista o pareja pareja definida por la
expresión (sin evaluar sus elementos).</p>
<p><strong>Ejemplos</strong></p>
<div class="highlight"><pre><span></span><code><span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">)</span> <span class="c1">; ⇒ (1 2 3) Una lista</span>
<span class="o">&#39;</span><span class="p">(</span><span class="ss">+</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">)</span> <span class="c1">; La lista formada por el símbolo + y los números 1 2 3 4</span>
<span class="p">(</span><span class="k">quote</span> <span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">))</span> <span class="c1">; La lista formada por los números 1 2 3 4</span>
<span class="o">&#39;</span><span class="p">(</span><span class="ss">a</span> <span class="ss">b</span> <span class="ss">c</span><span class="p">)</span> <span class="c1">; ⇒ La lista con los símbolos a, b, y c</span>
<span class="o">&#39;</span><span class="p">(</span><span class="ss">*</span> <span class="p">(</span><span class="ss">+</span> <span class="mi">1</span> <span class="p">(</span><span class="ss">+</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">))</span> <span class="mi">5</span><span class="p">)</span> <span class="c1">; Una lista con 3 elementos, el segundo de ellos otra lista</span>
<span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="o">.</span> <span class="mi">2</span><span class="p">)</span> <span class="c1">; ⇒ La pareja (1 . 2)</span>
<span class="o">&#39;</span><span class="p">((</span><span class="mi">1</span> <span class="o">.</span> <span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="mi">2</span> <span class="o">.</span> <span class="mi">3</span><span class="p">))</span> <span class="c1">; ⇒ Una lista con las parejas (1 . 2) y (2 . 3)</span>
</code></pre></div>
<p style="margin-bottom:2cm;"></p>

<h3>Listas</h3>
<ul>
<li>
<p>En el seminario de Scheme hemos visto que una de sus características
principales es el uso de listas. </p>
</li>
<li>
<p>Repasamos las funciones más importantes y explicamos el uso de la
  forma especial <code>quote</code> para construir listas.</p>
</li>
</ul>
<p style="margin-bottom:2cm;"></p>

<h3>Función <code>list</code> y forma especial <code>quote</code></h3>
<ul>
<li>Función <code>list</code></li>
</ul>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="nb">list</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span><span class="p">)</span> <span class="n">⇒</span> <span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">)</span>
<span class="p">(</span><span class="nb">list</span> <span class="o">&#39;</span><span class="ss">a</span> <span class="o">&#39;</span><span class="ss">b</span> <span class="o">&#39;</span><span class="ss">c</span><span class="p">)</span> <span class="n">⇒</span> <span class="p">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span><span class="p">)</span>
<span class="p">(</span><span class="nb">list</span> <span class="mi">1</span> <span class="o">&#39;</span><span class="ss">a</span> <span class="mi">2</span> <span class="o">&#39;</span><span class="ss">b</span> <span class="mi">3</span> <span class="o">&#39;</span><span class="ss">c</span> <span class="no">#t</span><span class="p">)</span> <span class="n">⇒</span> <span class="p">(</span><span class="mi">1</span> <span class="n">a</span> <span class="mi">2</span> <span class="n">b</span> <span class="mi">3</span> <span class="n">c</span> <span class="no">#t</span><span class="p">)</span>
<span class="p">(</span><span class="nb">list</span> <span class="mi">1</span> <span class="p">(</span><span class="nb">+</span> <span class="mi">1</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nb">*</span> <span class="mi">2</span> <span class="p">(</span><span class="nb">+</span> <span class="mi">1</span> <span class="mi">2</span><span class="p">)))</span> <span class="n">⇒</span> <span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">6</span><span class="p">)</span>
</code></pre></div>
<p>Otro ejemplo:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span> <span class="n">a</span> <span class="mi">1</span><span class="p">)</span>
<span class="p">(</span><span class="k">define</span> <span class="n">b</span> <span class="mi">2</span><span class="p">)</span>
<span class="p">(</span><span class="k">define</span> <span class="n">c</span> <span class="mi">3</span><span class="p">)</span>
<span class="p">(</span><span class="nb">list</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span><span class="p">)</span> <span class="c1">; ⇒ (1 2 3)</span>
</code></pre></div>
<ul>
<li>La forma especial <code>quote</code> delante de una expresión entre paréntesis
  convierte la expresión en una lista y la devuelve:</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">)</span> <span class="c1">; ⇒ (1 2 3 4)</span>
<span class="p">(</span><span class="k">define</span> <span class="n">a</span> <span class="mi">1</span><span class="p">)</span>
<span class="p">(</span><span class="k">define</span> <span class="n">b</span> <span class="mi">2</span><span class="p">)</span>
<span class="p">(</span><span class="k">define</span> <span class="n">c</span> <span class="mi">3</span><span class="p">)</span>
<span class="o">&#39;</span><span class="p">(</span><span class="ss">a</span> <span class="ss">b</span> <span class="ss">c</span><span class="p">)</span> <span class="c1">; ⇒ (a b c)</span>
<span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="p">(</span><span class="ss">+</span> <span class="mi">1</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="ss">*</span> <span class="mi">2</span> <span class="p">(</span><span class="ss">+</span> <span class="mi">1</span> <span class="mi">2</span><span class="p">)))</span> <span class="c1">; ⇒ (1 (+ 1 1) (* 2 (+ 1 2)))</span>
</code></pre></div>
<p>La última lista tiene 3 elementos:</p>
<ul>
<li>El número 1</li>
<li>La lista (+ 1 1)</li>
<li>
<p>La lista (* 2 (+ 1 2))</p>
</li>
<li>
<p>Otro ejemplo sobre la diferencia entre <code>list</code> y <code>quote</code>:</p>
</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="nb">list</span> <span class="mi">1</span> <span class="p">(</span><span class="nb">/</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">)</span> <span class="p">(</span><span class="nb">+</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">))</span> <span class="c1">; ⇒ (1 2/3 5)</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="p">(</span><span class="ss">/</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">)</span> <span class="p">(</span><span class="ss">+</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">))</span> <span class="c1">; ⇒ (1 (/ 2 3) (+ 2 3))</span>
</code></pre></div>
<p style="margin-bottom:2cm;"></p>

<h3>Selección de elementos de una lista: <code>car</code> y <code>cdr</code></h3>
<ul>
<li>Primer elemento: función <code>car</code></li>
<li>Resto de elementos: función <code>cdr</code></li>
</ul>
<p>Ejemplos:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span> <span class="n">lista1</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">))</span>
<span class="p">(</span><span class="nb">car</span> <span class="n">lista1</span><span class="p">)</span> <span class="c1">; ⇒ 1</span>
<span class="p">(</span><span class="nb">cdr</span> <span class="n">lista1</span><span class="p">)</span> <span class="c1">; ⇒ (2 3 4)</span>
<span class="p">(</span><span class="k">define</span> <span class="n">lista2</span> <span class="o">&#39;</span><span class="p">((</span><span class="mi">1</span> <span class="mi">2</span><span class="p">)</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">))</span>
<span class="p">(</span><span class="nb">car</span> <span class="n">lista2</span><span class="p">)</span> <span class="c1">; ⇒ (1 2)</span>
<span class="p">(</span><span class="nb">cdr</span> <span class="n">lista2</span><span class="p">)</span> <span class="c1">; ⇒ (3 4)</span>
</code></pre></div>
<p style="margin-bottom:2cm;"></p>

<h3>Composición de listas: <code>cons</code> y <code>append</code></h3>
<ul>
<li>La función <code>cons</code> añade un elemento a la cabeza de una lista</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="nb">cons</span> <span class="mi">1</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">))</span> <span class="c1">; ⇒ (1 1 2 3 4)</span>
<span class="p">(</span><span class="nb">cons</span> <span class="o">&#39;</span><span class="ss">hola</span> <span class="o">&#39;</span><span class="p">(</span><span class="ss">como</span> <span class="ss">estás</span><span class="p">))</span> <span class="c1">; ⇒ (hola como estás)</span>
<span class="p">(</span><span class="nb">cons</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">))</span>  <span class="c1">; ⇒ ((1 2) 1 2 3 4)</span>
</code></pre></div>
<ul>
<li>La función <code>append</code> concatena dos o más listas</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="k">define</span> <span class="n">list1</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">))</span>
<span class="p">(</span><span class="k">define</span> <span class="n">list2</span> <span class="o">&#39;</span><span class="p">(</span><span class="ss">hola</span> <span class="ss">como</span> <span class="ss">estás</span><span class="p">))</span>
<span class="p">(</span><span class="nb">append</span> <span class="n">list1</span> <span class="n">list2</span><span class="p">)</span> <span class="c1">; ⇒ (1 2 3 4 hola como estás)</span>
</code></pre></div></body>

</html>
