<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
<style type="text/css">

/* Admonition */

.admonition {
    padding-left: 15px;
    padding-right: 15px;
    margin-bottom: 10px;
    border: 1px solid transparent;
    border-radius: 4px;
    text-align: left;
}

.admonition.note { /* csslint allow: adjoining-classes */
    color: black;
    background-color: #d9edf7;
    border-color: #bce8f1;
}

.admonition.quote { /* csslint allow: adjoining-classes */
    color: black;
    background-color: #cecece;
    border-color: #cccccc;
}

.admonition.warning { /* csslint allow: adjoining-classes */
    color: black;
    background-color: #FCC8BE;
    border-color: #FCC8BE;
}

.admonition.hint { /* csslint allow: adjoining-classes */
    color: black;
    background-color: #E9F9F6;
    border-color: #AFEEEE;
}

.admonition.danger { /* csslint allow: adjoining-classes */
    color: black;
    background-color: #F7B2A4;
    border-color: #F7B2A4;
}

.admonition-title {
    font-weight: bold;
    text-align: left;
}


/* Codehilite */

.hll { background-color: #ffffcc }
.c { color: #408080; font-style: italic } /* Comment */
.err { border: 1px solid #FF0000 } /* Error */
.k { color: #008000; font-weight: bold } /* Keyword */
.o { color: #666666 } /* Operator */
.ch { color: #408080; font-style: italic } /* Comment.Hashbang */
.cm { color: #408080; font-style: italic } /* Comment.Multiline */
.cp { color: #BC7A00 } /* Comment.Preproc */
.cpf { color: #408080; font-style: italic } /* Comment.PreprocFile */
.c1 { color: #408080; font-style: italic } /* Comment.Single */
.cs { color: #408080; font-style: italic } /* Comment.Special */
.gd { color: #A00000 } /* Generic.Deleted */
.ge { font-style: italic } /* Generic.Emph */
.gr { color: #FF0000 } /* Generic.Error */
.gh { color: #000080; font-weight: bold } /* Generic.Heading */
.gi { color: #00A000 } /* Generic.Inserted */
.go { color: #888888 } /* Generic.Output */
.gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.gs { font-weight: bold } /* Generic.Strong */
.gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.gt { color: #0044DD } /* Generic.Traceback */
.kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.kp { color: #008000 } /* Keyword.Pseudo */
.kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.kt { color: #B00040 } /* Keyword.Type */
.m { color: #666666 } /* Literal.Number */
.s { color: #BA2121 } /* Literal.String */
.na { color: #7D9029 } /* Name.Attribute */
.nb { color: #008000 } /* Name.Builtin */
.nc { color: #0000FF; font-weight: bold } /* Name.Class */
.no { color: #880000 } /* Name.Constant */
.nd { color: #AA22FF } /* Name.Decorator */
.ni { color: #999999; font-weight: bold } /* Name.Entity */
.ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.nf { color: #0000FF } /* Name.Function */
.nl { color: #A0A000 } /* Name.Label */
.nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.nt { color: #008000; font-weight: bold } /* Name.Tag */
.nv { color: #19177C } /* Name.Variable */
.ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.w { color: #bbbbbb } /* Text.Whitespace */
.mb { color: #666666 } /* Literal.Number.Bin */
.mf { color: #666666 } /* Literal.Number.Float */
.mh { color: #666666 } /* Literal.Number.Hex */
.mi { color: #666666 } /* Literal.Number.Integer */
.mo { color: #666666 } /* Literal.Number.Oct */
.sa { color: #BA2121 } /* Literal.String.Affix */
.sb { color: #BA2121 } /* Literal.String.Backtick */
.sc { color: #BA2121 } /* Literal.String.Char */
.dl { color: #BA2121 } /* Literal.String.Delimiter */
.sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.s2 { color: #BA2121 } /* Literal.String.Double */
.se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.sh { color: #BA2121 } /* Literal.String.Heredoc */
.si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.sx { color: #008000 } /* Literal.String.Other */
.sr { color: #BB6688 } /* Literal.String.Regex */
.s1 { color: #BA2121 } /* Literal.String.Single */
.ss { color: #19177C } /* Literal.String.Symbol */
.bp { color: #008000 } /* Name.Builtin.Pseudo */
.fm { color: #0000FF } /* Name.Function.Magic */
.vc { color: #19177C } /* Name.Variable.Class */
.vg { color: #19177C } /* Name.Variable.Global */
.vi { color: #19177C } /* Name.Variable.Instance */
.vm { color: #19177C } /* Name.Variable.Magic */
.il { color: #666666 } /* Literal.Number.Integer.Long */

/* Estilo LPP */

body {
  font-family: Helvetica, arial, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  background-color: white;
  padding: 60px;
}

pre {
  background-color: #f8f8f8;
  border: 1px solid #cccccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px;
}

table {
  padding: 0;border-collapse: collapse; }
  table tr {
    border-top: 1px solid #cccccc;
    background-color: white;
    margin: 0;
    padding: 0; }
    table tr:nth-child(2n) {
      background-color: #f8f8f8; }
    table tr th {
      font-weight: bold;
      border: 1px solid #cccccc;
      margin: 0;
      padding: 6px 13px; }
    table tr td {
      border: 1px solid #cccccc;
      margin: 0;
      padding: 6px 13px; }
    table tr th :first-child, table tr td :first-child {
      margin-top: 0; }
    table tr th :last-child, table tr td :last-child {
      margin-bottom: 0; }

</style>

</head>

<body>
<h2>Semana 3</h2>
<p>Notas de clase de la semana 3 de LPP.</p>
<h2>Tema 2: Programación funcional</h2>
<h3>Veremos hoy</h3>
<ul>
<li>
<ol>
<li>El paradigma de Programación Funcional</li>
</ol>
</li>
<li>
<ol start="2">
<li>Scheme como lenguaje de programación funcional</li>
</ol>
</li>
<li>
<ol start="3">
<li>Tipos de datos compuestos en Scheme</li>
</ol>
</li>
<li>
<ol start="4">
<li>Listas en Scheme</li>
<li>4.1 Implementación de listas en Scheme</li>
<li>4.2 Listas con elementos compuestos</li>
<li><strong>4.3. Funciones recursivas para construir listas</strong></li>
<li><strong>4.4. Funciones con número variable de argumentos</strong></li>
</ol>
</li>
<li><strong>5. Funciones como tipos de datos de primera clase</strong><ul>
<li><strong>5.1. Forma especial <code>lambda</code></strong></li>
<li><strong>5.2. Funciones como argumentos de otras funciones</strong></li>
<li>5.3. Funciones que devuelven otras funciones</li>
<li>5.4. Funciones en estructuras de datos</li>
<li>5.5. Generalización</li>
<li>5.6. Funciones de orden superior</li>
</ul>
</li>
</ul>
<h3>Funciones recursivas para construir listas</h3>
<p>Vamos a ver cómo se implementan de forma recursiva:</p>
<ul>
<li>Funciones de Scheme que trabajan con listas (para no solapar con las
  definiciones de Scheme pondremos el prefijo <code>mi-</code> en todas ellas):<ul>
<li>Función <code>mi-append</code></li>
<li>Función <code>mi-reverse</code></li>
</ul>
</li>
<li>Otras funciones recursivas<ul>
<li>Función <code>lista-desde</code></li>
<li>Función <code>filtra-pares</code></li>
</ul>
</li>
<li>Ejemplo completo: usamos las funciones anteriores para comprobar si
  un número es primo<ul>
<li>Función <code>primo?</code></li>
</ul>
</li>
</ul>
<h3>Recordatorio: Diseño de funciones recursivas</h3>
<p>¿Cómo diseñamos una <em>definición recursiva</em> de una función? </p>
<ul>
<li>Es recomendable comenzar por el <strong>caso general</strong>.</li>
<li>Debemos buscar una forma de resolver el problema principal haciendo
  una llamada a la recursión con una versión más pequeña del problema,
  <strong>confiar en que la recursión funciona correctamente</strong> devolviendo
  lo que tiene que devolver y obtener con este valor devuelto la
  solución al problema principal. Es recomendable probar con un
  <strong>ejemplo concreto</strong>.</li>
<li>Una vez formulado el caso general, buscamos el <strong>caso base de la
  recursión</strong>: el caso más sencillo posible en el que no es necesario
  hacer una llamada recursiva para devolver la solución.</li>
</ul>
<h3>Función <code>mi-append</code></h3>
<ul>
<li>
<p>Queremos conseguir una implementación recursiva de la función
  <code>append</code> que construye una lista resultante de la unión de dos. Por
  ejemplo:</p>
<pre class="highlight"><code class="language-racket">(mi-append '(a b c) '(d e f)) ; ⇒ (a b c d e f)</code></pre>
</li>
<li>
<p>¿Cómo formulamos el ejemplo de forma recursiva? </p>
</li>
</ul>
<p style="margin-bottom: 1cm;"></p>

<ul>
<li>
<p>¿Funcionaría si llamamos a la recursión con el resto de la primera
lista y el resto de la segunda lista? ¿Podríamos conseguir a partir de
la lista a resultante de esa llamada recursiva la lista que queremos?
Vamos a probarlo:</p>
<p><p style="margin-bottom: 1cm;"></p></p>
<pre class="highlight"><code class="language-racket">(mi-append '(b c) '(e f)) =&gt; '(b c e f)</code></pre>
<p><p style="margin-bottom: 1cm;"></p></p>
<p>¿Podemos conseguir la lista <code>(a b c d e f)</code> a partir de la lista <code>(b c
e f)</code> y de <code>a</code> y <code>d</code>? No, no hay una forma fácil de hacerlo.</p>
</li>
</ul>
<p style="margin-bottom: 1cm;"></p>

<ul>
<li>
<p>¿Funcionaría si llamamos a la recursión con la primera lista y el
  resto de la segunda? </p>
<p><p style="margin-bottom: 1cm;"></p></p>
<p>Vamos a probarlo:</p>
<pre class="highlight"><code class="language-text">(mi-append '(a b c) '(e f)) =&gt; '(a b c e f)</code></pre>
<p><p style="margin-bottom: 1cm;"></p></p>
<p>¿Podemos conseguir la lista <code>(a b c d e f)</code> a partir de la lista <code>(a
b c e f)</code> y <code>d</code>? No, no hay una forma fácil de hacerlo.</p>
</li>
</ul>
<p style="margin-bottom: 1cm;"></p>

<ul>
<li>
<p>¿Cuál es la forma correcta de hacerlo? </p>
<p><p style="margin-bottom: 1cm;"></p></p>
<pre class="highlight"><code class="language-text">(mi-append '(b c) '(d e f)) =&gt; '(b c d e f)</code></pre>
<p><p style="margin-bottom: 1cm;"></p></p>
<p>Y después hacer un <code>cons</code> de <code>a</code> y la lista resultante de la llamada a
la recursión:</p>
<pre class="highlight"><code class="language-text">(cons 'a (mi-append '(b c) '(d e f))) = 
(cons 'a (b c d e f)) = 
(a b c d e f)</code></pre>
</li>
</ul>
<p style="margin-bottom: 1cm;"></p>

<ul>
<li>
<p>En general:</p>
<pre class="highlight"><code class="language-racket">(define (mi-append lista1 lista2) 
    (cons (first lista1) (mi-append (rest lista1) lista2)))</code></pre>
</li>
<li>
<p>El caso base es aquel en el que <code>lista1</code> es <code>null?</code>. En ese caso
  devolvemos <code>lista2</code>:</p>
<pre class="highlight"><code class="language-racket">(mi-append '() '(a b c)) ;⇒ '(a b c)</code></pre>
</li>
<li>
<p>La formulación recursiva completa queda como sigue:</p>
<pre class="highlight"><code class="language-racket">(define (mi-append l1 l2)
    (if (null? l1)
        l2
        (cons (first l1)
              (mi-append (rest l1) l2))))</code></pre>
</li>
</ul>
<h3>Función <code>mi-reverse</code></h3>
<ul>
<li>
<p>Ejemplo</p>
<pre class="highlight"><code class="language-racket">(mi-reverse '(1 2 3 4 5 6)) ; ⇒ (6 5 4 3 2 1)</code></pre>
</li>
<li>
<p>La idea es sencilla: llamamos a la recursión para hacer la inversa
  del <code>rest</code> de la lista y añadimos el primer elemento a la lista
  resultante.</p>
</li>
<li>
<p>Podemos definir una función auxiliar <code>(añade-al-final dato lista)</code>
  que añade un dato al final de una lista usando <code>append</code>:</p>
<pre class="highlight"><code class="language-racket">(define (añade-al-final dato lista)
    (append lista (list dato)))</code></pre>
</li>
<li>
<p>La función <code>mi-reverse</code> quedaría entonces como sigue:</p>
<pre class="highlight"><code class="language-racket">(define (mi-reverse lista)
    (if (null? lista) '()
        (añade-al-final (first lista) (mi-reverse (rest lista)))))</code></pre>
</li>
</ul>
<h3>Función <code>lista-desde</code></h3>
<ul>
<li>
<p>La función <code>(lista-desde x)</code> devuelve una lista con los
  números desde x hasta 1:</p>
<pre class="highlight"><code class="language-racket">(lista-desde 5) ; ⇒ (5 4 3 2 1)</code></pre>
</li>
<li>
<p>¿Cómo formulamos el ejemplo de forma recursiva?</p>
</li>
</ul>
<p style="margin-bottom: 3cm;"></p>

<ul>
<li>
<p>Solución:</p>
<pre class="highlight"><code class="language-text">(lista-desde 5) = 
(cons 5 (lista-desde 4) =
(cons 5 (4 3 2 1)) = 
(5 4 3 2 1)</code></pre>
</li>
<li>
<p>En general:</p>
<pre class="highlight"><code class="language-text">Para construir una lista desde x hasta 1:
   construyo la lista desde x-1 hasta 1 y le añado 
   en cabeza el número x</code></pre>
</li>
<li>
<p>El caso base de la recursión es el caso en el que x es 1, entonces
  devolvemos '(1)</p>
</li>
<li>
<p>Ya podemos realizar la definición Scheme:</p>
<pre class="highlight"><code class="language-racket">(define (lista-desde x)
    (if (= x 1)
        '(1)
        (cons x
              (lista-desde (- x 1)))))</code></pre>
</li>
</ul>
<h3>Función <code>filtra-pares</code></h3>
<ul>
<li>
<p>Es muy habitual recorrer una lista y comprobar condiciones de sus
  elementos, construyendo una lista con los que cumplan una
  determinada condición.</p>
</li>
<li>
<p>La función <code>filtra-pares</code> construye una lista con los números pares
  de la lista que le pasamos como parámetro:</p>
<pre class="highlight"><code class="language-racket">(filtra-pares '(1 2 3 4 5 6)) ;⇒ (2 4 6)</code></pre>
</li>
<li>
<p>¿Cómo la definimos de forma recursiva?</p>
</li>
</ul>
<p style="margin-bottom:3cm;"></p>

<ul>
<li>
<p>Solución en Scheme</p>
<pre class="highlight"><code class="language-racket">(define (filtra-pares lista)
    (cond
        ((null? lista) '())
        ((even? (first lista))
            (cons (first lista) (filtra-pares (rest lista))))
        (else (filtra-pares (rest lista)))))</code></pre>
</li>
</ul>
<h3>Ejemplo final: Función <code>primo?</code></h3>
<ul>
<li>
<p>El uso de listas es uno de los elementos fundamentales de la
  programación funcional.</p>
</li>
<li>
<p>Veamos un algoritmo sencillo que permite calcular si un número es
  primo, usando alguna de las funciones anteriores sobre
  listas. Calcularemos la lista de divisores del número y
  comprobaremos si su longitud es dos:</p>
<pre class="highlight"><code class="language-racket">(divisores 8) ;⇒ (1 2 4 8) longitud = 4, no primo
(divisores 9) ;⇒ (1 3 9) longitud = 3, no primo
(divisores 11) ;⇒ (1 11) longitud = 2, primo</code></pre>
</li>
<li>
<p>En Scheme:</p>
<pre class="highlight"><code class="language-racket">(define (primo? x)
    (=  2 
    (length (divisores x))))</code></pre>
</li>
</ul>
<h3>Función <code>(divisor? x y)</code></h3>
<pre class="highlight"><code class="language-racket">(define (divisor? x y)
      (= 0 (remainder y x)))</code></pre>
<h3>Función recursiva <code>(filtra-divisores lista x)</code></h3>
<ul>
<li>
<p>Función que filtra aquellos números <code>lista</code> que son divisores del número <code>x</code></p>
<pre class="highlight"><code class="language-racket">(define (filtra-divisores lista x)
   (cond
      ((null? lista) '())
      ((divisor? (first lista) x)
         (cons (first lista)
               (filtra-divisores (rest lista) x)))
      (else (filtra-divisores (rest lista) x))))</code></pre>
</li>
</ul>
<h3>Función <code>(divisores x)</code></h3>
<ul>
<li>
<p>Una vez definidas las funciones auxiliares anteriores, se puede
  implementar de una forma muy sencilla una función <code>(divisores x)</code>
  que devuelve una lista de todos los divisores del número <code>x</code>:</p>
<pre class="highlight"><code class="language-racket">(define (divisores x)
    (filtra-divisores (lista-desde x) x))</code></pre>
</li>
<li>
<p>Por ejemplo, para calcular los divisores de 10:</p>
<pre class="highlight"><code class="language-racket">(filtra-divisores '(10 9 8 7 6 5 4 3 2 1) 10) ;⇒ (10 5 2 1)</code></pre>
</li>
<li>
<p>Y, una vez definida esta función, ya funciona correctamente la
  función <code>primo?</code> con la primera definición que vimos:</p>
<pre class="highlight"><code class="language-racket">(define (primo? x)
    (=  2 
    (length (divisores x))))</code></pre>
</li>
</ul>
<p style="margin-bottom:1cm;"></p>
<hr />
<p style="margin-bottom:1cm;"></p>

<h3>Funciones con número variable de argumentos</h3>
<ul>
<li>
<p>Definición de número variable de argumentos con la notación de
  punto:</p>
<pre class="highlight"><code class="language-racket">(define (funcion-dos-o-mas-args x y . lista-args) 
    &lt;cuerpo&gt;)</code></pre>
</li>
<li>
<p>Podemos llamar a la función anterior con dos o más argumentos:</p>
<pre class="highlight"><code class="language-racket">(funcion-dos-o-mas-args 1 2 3 4 5 6)</code></pre>
</li>
<li>
<p>En la llamada, los parámetros <code>x</code> e <code>y</code> tomarán los valores 1 y 2.</p>
</li>
<li>El parámetro <code>lista-args</code> tomará como valor una lista con los
  argumentos restantes <code>(3 4 5 6)</code>.</li>
<li>
<p>También es posible permitir que todos los argumentos sean opcionales
  no poniendo ningún argumento antes del punto:</p>
<pre class="highlight"><code class="language-racket">(define (funcion-cualquier-numero-args . lista-args) 
    &lt;cuerpo&gt;)</code></pre>
</li>
<li>
<p>Ejemplo:</p>
<p><pre class="highlight"><code class="language-racket">(define (mi-suma x y . lista-nums)
    (if (null? lista-nums)
        (+ x y)
        (+ x (+ y (suma-lista lista-nums)))))</code></pre>
¿Las funciones con número variable de argumentos pueden ser recursivas? </p>
</li>
</ul>
<p style="margin-bottom:1cm;"></p>
<hr />
<p style="margin-bottom:1cm;"></p>

<h3>Funciones como tipos de datos de primera clase</h3>
<p>Recordemos que un tipo de primera clase es aquel que:</p>
<ol>
<li>Puede ser asignado a una variable</li>
<li>Puede ser pasado como argumento a una función</li>
<li>Puede ser devuelto como resultado de una invocación a una función</li>
<li>Puede ser parte de un tipo mayor</li>
</ol>
<p>Con funciones:</p>
<ol>
<li>Una función se puede asignar a una variable</li>
<li>Una función se puede pasar como parámetro de otras funciones </li>
<li>Una función se puede devolver como resultado de una invocación a otra función</li>
<li>Una función se puede guardar en tipos de datos compuestos como listas</li>
</ol>
<ul>
<li>Las funciones son objetos de primera clase en lenguajes funcionales
  y en muchos lenguajes multi-paradigma con características funcionales como
  <a href="http://helephant.com/2008/08/19/functions-are-first-class-objects-in-javascript/">JavaScript</a>,
  <a href="https://thenewcircle.com/static/bookshelf/python_fundamentals_tutorial/functional_programming.html">Python</a>,
  <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Closures.html">Swift</a>
  o incluso en la última versión de Java, <a href="http://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html">Java
  8</a>,
  (donde se denominan <em>expresiones lambda</em>).</li>
</ul>
<h3>Forma especial <code>lambda</code></h3>
<ul>
<li>
<p>Cualquier objeto de primera clase de un lenguaje debe poderse
  crear de forma anónima, sin asignarle un nombre. Por ejemplo, en la
  expresión:</p>
<pre class="highlight"><code class="language-racket">(string-append "hola" "adiós")</code></pre>
<p>las cadenas <code>"hola"</code> y <code>"adiós"</code> se han creado directamente,
sin darles nombre, y se han pasado como parámetros a la función
<code>string-append</code>.</p>
</li>
<li>
<p>La forma especial <code>lambda</code> permite hacer lo mismo con las funciones:
  crear funciones anónimas en tiempo de ejecución.</p>
</li>
</ul>
<h3>Sintaxis de la forma especial <code>lambda</code></h3>
<ul>
<li>
<p>La sintaxis de la forma especial <code>lambda</code> es:</p>
<pre class="highlight"><code class="language-text">(lambda (&lt;arg1&gt; ... &lt;argn&gt;) 
    &lt;cuerpo&gt;)</code></pre>
</li>
<li>
<p>El cuerpo del lambda define un <em>bloque de código</em> y sus argumentos
  son los parámetros necesarios para ejecutar ese bloque de
  código. Llamamos a la función resultante una <em>función anónima</em>.</p>
</li>
<li>
<p>Una función anónima que suma dos parejas:</p>
<pre class="highlight"><code class="language-racket">(lambda (p1 p2)
    (cons (+ (car p1) (car p2))
          (+ (cdr p1) (cdr p2))))</code></pre>
</li>
<li>
<p>Una función anónima que devuelve el mayor de dos números:</p>
<pre class="highlight"><code class="language-racket">(lambda (a b)
    (if (&gt; a b)
        a
        b))</code></pre>
</li>
</ul>
<h3>Semántica de la forma especial <code>lambda</code></h3>
<ul>
<li>
<p>La invocación a la forma especial <code>lambda</code> construye una función
  anónima en tiempo de ejecución.</p>
<pre class="highlight"><code class="language-racket">(lambda (x) (* x x)) ; ⇒ #&lt;procedure&gt;</code></pre>
</li>
<li>
<p>El procedimiento construido es un bloque de código que devuelve el
  cuadrado de un número.</p>
</li>
<li>
<p>¿Qué podemos hacer con este procedimiento? </p>
</li>
</ul>
<h3>Podemos asignar el procedimiento a un identificador (símbolo)</h3>
<pre class="highlight"><code class="language-racket">(define f (lambda (x) (* x x)))</code></pre>
<ul>
<li>Se evalúa la expresión lambda y el resultado (un procedimiento) se
  guarda en <code>f</code></li>
<li>
<p>Si escribimos <code>f</code> en el intérprete, Scheme lo evalúa y muestra el
  procedimiento:</p>
<pre class="highlight"><code class="language-racket">f ; ⇒ #&lt;procedure:f&gt;</code></pre>
</li>
<li>
<p>Podemos usar el identificador <code>f</code> de la forma que habitualmente
  invocamos a una función:</p>
<pre class="highlight"><code class="language-racket">(f 3) ; ⇒ 9</code></pre>
</li>
</ul>
<h3>Podemos invocar a la función anónima directamente</h3>
<pre class="highlight"><code class="language-racket">((lambda (x) (* x x)) 3) ; ⇒ 9</code></pre>
<ul>
<li>
<p>La llamada a <code>lambda</code> crea un procedimiento y el paréntesis a su
izquierda lo invoca con el parámetro 3:</p>
<pre class="highlight"><code class="language-racket">((lambda (x) (* x x)) 3) ; =&gt; (#&lt;procedure&gt; 3) ⇒ 9</code></pre>
</li>
<li>
<p>Es importante remarcar que con <code>lambda</code> estamos creando una función
  en <em>tiempo de ejecución</em>.</p>
</li>
</ul>
<h3>Expresiones lambda en distintos lenguajes de programación</h3>
<p><strong>Java 8</strong></p>
<pre class="highlight"><code class="language-java">Integer x -&gt; {x*x}</code></pre>
<p><strong>Scala</strong></p>
<pre class="highlight"><code class="language-scala">(x:Int) =&gt; {x*x}</code></pre>
<p><strong>Objective C</strong></p>
<pre class="highlight"><code class="language-objective-c">^int (int x)
{
   x*x
};</code></pre>
<p><strong>Swift</strong></p>
<pre class="highlight"><code class="language-swift">{ (x: Int) -&gt; Int in return x*x }</code></pre>
<h3>Identificadores y funciones</h3>
<ul>
<li>
<p>En Scheme una función está ligada al símbolo que define su nombre:</p>
<pre class="highlight"><code class="language-racket">+ ; ⇒ &lt;procedure:+&gt;</code></pre>
</li>
<li>
<p>Podemos asignar funciones ya existentes a nuevos identificadores
  usando <code>define</code>, como en el ejemplo siguiente:</p>
<pre class="highlight"><code class="language-racket">+ ;⇒ &lt;procedure:+&gt;
(define suma +)
(suma 1 2 3 4) ; ⇒ 10</code></pre>
</li>
</ul>
<p><img src="./imagenes/suma.png" style="width:100px;"/></p>
<h3>La forma especial <code>define</code> para definir una función no es más que azucar sintáctico</h3>
<ul>
<li>
<p>La forma especial <code>define</code> para definir funciones siempre se
  convierte internamente en una llamada a <code>lambda</code> y una asociación de
  la función a su nombre:</p>
<pre class="highlight"><code class="language-text">(define (&lt;nombre&gt; &lt;args&gt;)
    &lt;cuerpo&gt;)</code></pre>
<pre class="highlight"><code class="language-text">(define &lt;nombre&gt; 
    (lambda (&lt;args&gt;)
        &lt;cuerpo&gt;))</code></pre>
</li>
<li>
<p>Ejemplo:</p>
<pre class="highlight"><code class="language-racket">(define (cuadrado x)
    (* x x))</code></pre>
<pre class="highlight"><code class="language-racket">(define cuadrado 
    (lambda (x) (* x x)))</code></pre>
</li>
</ul>
<h3>Predicado <code>procedure?</code></h3>
<ul>
<li>
<p>Podemos comprobar si algo es una función utilizando el predicado de
  Scheme <code>procedure?</code>.</p>
<pre class="highlight"><code class="language-racket">(procedure? (lambda (x) (* x x)))
; ⇒ #t
(define suma +)
(procedure? suma)
; ⇒ #t
(procedure? '+)
; ⇒ #f</code></pre>
</li>
</ul>
<h3>Funciones argumentos de otras funciones</h3>
<ul>
<li>Ya hemos visto que una función se pueda asignar a una variable. Para
  seguir comprobando que es un objeto de primera clase, vamos a
  comprobar que se puede pasar como parámetro de otra función.</li>
</ul>
<h3>Función <code>(aplica f x y)</code></h3>
<ul>
<li>
<p>La función <code>(aplica f x y)</code> recibe una función como argumento y dos
  parámetros. Devuelve el resultado de evaluar la función <code>f</code> con los
  argumentos <code>x</code> e <code>y</code></p>
<pre class="highlight"><code class="language-racket">(define (aplica f x y)
   (f x y))</code></pre>
</li>
<li>
<p>Ejemplos:</p>
<pre class="highlight"><code class="language-racket">(aplica + 2 3) ; ⇒ 5
(aplica * 4 5) ; ⇒ 10
(aplica string-append "hola" "adios") ; ⇒ "holaadios"

(define (string-append-con-guion s1 s2)
    (string-append s1 "-" s2))

(aplica string-append-con-guion "hola" "adios") ; ⇒ "hola-adios"</code></pre>
</li>
<li>
<p>Podemos pasar la función creándola con una expresión lambda:</p>
<pre class="highlight"><code class="language-racket">(aplica (lambda (x y) (sqrt (+ (* x x) (* y y)))) 3 4) ; ⇒ 5</code></pre>
</li>
</ul>
<h3>Función <code>aplica-2</code></h3>
<ul>
<li>
<p>La función <code>aplica-2</code> toma dos funciones <code>f</code> y <code>g</code> y un argumento
  <code>x</code> y devuelve el resultado de aplicar <code>f</code> a lo que devuelve la
  invocación de <code>g</code> con <code>x</code>:</p>
<pre class="highlight"><code class="language-racket">(define (aplica-2 f g x)
   (f (g x)))</code></pre>
</li>
<li>
<p>Ejemplos de invocación</p>
<pre class="highlight"><code class="language-racket">(define (suma-5 x)
   (+ x 5))
(define (doble x)
   (+ x x))
(aplica-2 suma-5 doble 3) ; ⇒ 11

(aplica-2 (lambda (x) (* x 2))
          (lambda (x) (+ x 5)) 10) ; ⇒ 30</code></pre>
</li>
</ul>
<h3>Función <code>apply</code></h3>
<p>La función <code>(apply funcion lista)</code> de Scheme permite aplicar una función de
aridad <code>n</code> a una lista de datos de n datos, haciendo que cada uno de
los datos se pasen a la función en orden como parámetros.</p>
<p>La función <code>apply</code> recibe una función y una lista y devuelve el
resultado de aplicar la función a los datos de la lista, tomándolos
como parámetros.</p>
<p>Ejemplo:</p>
<pre class="highlight"><code class="language-racket">(apply + '(1 2 3 4)) ; ⇒ 10</code></pre>
<p>Podemos pasar a <code>apply</code> una expresión lambda:</p>
<pre class="highlight"><code class="language-racket">(apply (lambda (x y) (+ x (* 2 y))) '(2 5)) ; ⇒ 12</code></pre>
<p>La lista que pasamos como argumento de <code>apply</code> debe tener tantos
elementos como parámetros tenga la función que aplicamos. En caso
contrario, se produce un error:</p>
<pre class="highlight"><code class="language-racket">(apply cons '(a b c)) ; ⇒ error
cons: arity mismatch;
 the expected number of arguments does not match the given number
  expected: 2
  given: 3
  arguments...:</code></pre>
<p>La forma correcta de hacerlo:</p>
<pre class="highlight"><code class="language-racket">(apply cons '(a b)) ; ⇒ (a . b)</code></pre>
<h3>Función <code>apply</code> y funciones recursivas</h3>
<p>Usando <code>apply</code> podemos definir funciones recursivas con número
variable de argumentos.</p>
<p>Por ejemplo, supongamos que queremos definir la función <code>suma-parejas</code>
que suma un número variable de parejas:</p>
<pre class="highlight"><code class="language-racket">(suma-parejas '(1 . 2) '(3 . 4) '(5 . 6)) ; ⇒ '(9 . 12)</code></pre>
<p>Recordemos la definición de la función que suma dos parejas:</p>
<pre class="highlight"><code class="language-racket">(define (suma-pareja p1 p2)
  (cons (+ (car p1) (car p2))
        (+ (cdr p1) (cdr p2))))</code></pre>
<p>¿Cómo podríamos, usando <code>apply</code>, resolver el problema de sumar un
número variable de parejas?</p>
<pre class="highlight"><code class="language-racket">(define (suma-parejas . parejas)
  (if (null? parejas)
      '(0 . 0)
      (suma-pareja ???  (apply ???))))</code></pre>
<p style="margin-bottom:3cm;"></p>

<p>Solución:</p>
<pre class="highlight"><code class="language-racket">(define (suma-parejas . parejas)
  (if (null? parejas)
      '(0 . 0)
      (suma-pareja (first parejas) (apply suma-parejas (rest parejas)))))</code></pre>
<p>Una representación gráfica de cómo funciona la recursión:</p>
<p><img src="imagenes/suma-parejas-apply.png" width="600px"/></p></body>

</html>
