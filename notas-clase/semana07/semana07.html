<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
<style type="text/css">

/* Admonition */

.admonition {
    padding-left: 15px;
    padding-right: 15px;
    margin-bottom: 10px;
    border: 1px solid transparent;
    border-radius: 4px;
    text-align: left;
}

.admonition.note { /* csslint allow: adjoining-classes */
    color: black;
    background-color: #d9edf7;
    border-color: #bce8f1;
}

.admonition.quote { /* csslint allow: adjoining-classes */
    color: black;
    background-color: #cecece;
    border-color: #cccccc;
}

.admonition.warning { /* csslint allow: adjoining-classes */
    color: black;
    background-color: #FCC8BE;
    border-color: #FCC8BE;
}

.admonition.hint { /* csslint allow: adjoining-classes */
    color: black;
    background-color: #E9F9F6;
    border-color: #AFEEEE;
}

.admonition.danger { /* csslint allow: adjoining-classes */
    color: black;
    background-color: #F7B2A4;
    border-color: #F7B2A4;
}

.admonition-title {
    font-weight: bold;
    text-align: left;
}


/* Codehilite */

.hll { background-color: #ffffcc }
.c { color: #408080; font-style: italic } /* Comment */
.err { border: 1px solid #FF0000 } /* Error */
.k { color: #008000; font-weight: bold } /* Keyword */
.o { color: #666666 } /* Operator */
.ch { color: #408080; font-style: italic } /* Comment.Hashbang */
.cm { color: #408080; font-style: italic } /* Comment.Multiline */
.cp { color: #BC7A00 } /* Comment.Preproc */
.cpf { color: #408080; font-style: italic } /* Comment.PreprocFile */
.c1 { color: #408080; font-style: italic } /* Comment.Single */
.cs { color: #408080; font-style: italic } /* Comment.Special */
.gd { color: #A00000 } /* Generic.Deleted */
.ge { font-style: italic } /* Generic.Emph */
.gr { color: #FF0000 } /* Generic.Error */
.gh { color: #000080; font-weight: bold } /* Generic.Heading */
.gi { color: #00A000 } /* Generic.Inserted */
.go { color: #888888 } /* Generic.Output */
.gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.gs { font-weight: bold } /* Generic.Strong */
.gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.gt { color: #0044DD } /* Generic.Traceback */
.kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.kp { color: #008000 } /* Keyword.Pseudo */
.kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.kt { color: #B00040 } /* Keyword.Type */
.m { color: #666666 } /* Literal.Number */
.s { color: #BA2121 } /* Literal.String */
.na { color: #7D9029 } /* Name.Attribute */
.nb { color: #008000 } /* Name.Builtin */
.nc { color: #0000FF; font-weight: bold } /* Name.Class */
.no { color: #880000 } /* Name.Constant */
.nd { color: #AA22FF } /* Name.Decorator */
.ni { color: #999999; font-weight: bold } /* Name.Entity */
.ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.nf { color: #0000FF } /* Name.Function */
.nl { color: #A0A000 } /* Name.Label */
.nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.nt { color: #008000; font-weight: bold } /* Name.Tag */
.nv { color: #19177C } /* Name.Variable */
.ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.w { color: #bbbbbb } /* Text.Whitespace */
.mb { color: #666666 } /* Literal.Number.Bin */
.mf { color: #666666 } /* Literal.Number.Float */
.mh { color: #666666 } /* Literal.Number.Hex */
.mi { color: #666666 } /* Literal.Number.Integer */
.mo { color: #666666 } /* Literal.Number.Oct */
.sa { color: #BA2121 } /* Literal.String.Affix */
.sb { color: #BA2121 } /* Literal.String.Backtick */
.sc { color: #BA2121 } /* Literal.String.Char */
.dl { color: #BA2121 } /* Literal.String.Delimiter */
.sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.s2 { color: #BA2121 } /* Literal.String.Double */
.se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.sh { color: #BA2121 } /* Literal.String.Heredoc */
.si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.sx { color: #008000 } /* Literal.String.Other */
.sr { color: #BB6688 } /* Literal.String.Regex */
.s1 { color: #BA2121 } /* Literal.String.Single */
.ss { color: #19177C } /* Literal.String.Symbol */
.bp { color: #008000 } /* Name.Builtin.Pseudo */
.fm { color: #0000FF } /* Name.Function.Magic */
.vc { color: #19177C } /* Name.Variable.Class */
.vg { color: #19177C } /* Name.Variable.Global */
.vi { color: #19177C } /* Name.Variable.Instance */
.vm { color: #19177C } /* Name.Variable.Magic */
.il { color: #666666 } /* Literal.Number.Integer.Long */

/* Estilo LPP */

body {
  font-family: Helvetica, arial, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  background-color: white;
  padding: 60px;
}

pre {
  background-color: #f8f8f8;
  border: 1px solid #cccccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px;
}

table {
  padding: 0;border-collapse: collapse; }
  table tr {
    border-top: 1px solid #cccccc;
    background-color: white;
    margin: 0;
    padding: 0; }
    table tr:nth-child(2n) {
      background-color: #f8f8f8; }
    table tr th {
      font-weight: bold;
      border: 1px solid #cccccc;
      margin: 0;
      padding: 6px 13px; }
    table tr td {
      border: 1px solid #cccccc;
      margin: 0;
      padding: 6px 13px; }
    table tr th :first-child, table tr td :first-child {
      margin-top: 0; }
    table tr th :last-child, table tr td :last-child {
      margin-bottom: 0; }

</style>

</head>

<body>
<h2>Semana 7</h2>
<p>Notas de clase de la semana 7 de LPP. </p>
<h2>Tema 4: Estructuras de datos recursivas</h2>
<ul>
<li>1 Listas estructuradas<ul>
<li>1.1. Definición y ejemplos</li>
<li>1.2. Funciones recursivas sobre listas estructuradas</li>
</ul>
</li>
<li>2 <strong>Árboles</strong><ul>
<li><strong>2.1. Definición de árboles en Scheme</strong></li>
<li><strong>2.2. Funciones recursivas sobre árboles</strong></li>
</ul>
</li>
<li>3 <strong>Árboles binarios</strong><ul>
<li><strong>3.1. Definición de árboles binarios en Scheme</strong></li>
<li><strong>3.2. Funciones recursivas sobre árboles binarios</strong></li>
</ul>
</li>
</ul>
<hr />
<h3>Definición de árbol</h3>
<ul>
<li>Un <strong>árbol</strong> es una estructura de datos definida por un valor raíz,
  que es el padre de toda la estructura, del que salen otros
  subárboles hijos
  (<a href="https://en.wikipedia.org/wiki/Tree_(data_structure)">Wikipedia</a>).</li>
<li>Un <strong>árbol</strong> se puede definir recursivamente de la siguiente forma:<ul>
<li>Una colección de un <strong>dato</strong> (el valor de la raíz del árbol) y
  una <strong>lista de hijos</strong> que también son árboles.</li>
<li>Una <strong>hoja</strong> será un árbol sin hijos (un dato con una lista de
  hijos vacía).</li>
</ul>
</li>
</ul>
<p>Un ejemplo de árbol:</p>
<p><img src="imagenes/arbol-sencillo.png" width="600px"/></p>
<p>El árbol anterior tiene como dato raíz el número 30 y tiene 3 árboles
hijos:</p>
<ul>
<li>El primer hijo es un árbol con raíz 15 y con dos hijos hoja, el 10 y
  el 12</li>
<li>El segundo hijo es un árbol hoja, con valor 18</li>
<li>El tercer hijo es un árbol con raíz 25 y con tres hijos hoja, el 19,
  21 y 22.</li>
</ul>
<hr />
<h3>Representación de árboles con listas</h3>
<ul>
<li>En Scheme la lista es la estructura de datos principal.</li>
<li>¿Cómo construimos un árbol usando listas? Tenemos que guardar en la
  lista: el dato de la raíz y los hijos.</li>
</ul>
<p style="margin-bottom:3cm;"/>

<ul>
<li>Podemos hacerlo de varias formas, pero escogemos la siguiente: usar
  <strong>una lista de <em>n+1</em> elementos</strong> para representar un árbol con n
  hijos:<ul>
<li>el primer elemento la lista será el dato de la raíz</li>
<li>el resto serán los árboles hijos</li>
</ul>
</li>
</ul>
<pre class="highlight"><code class="language-text">arbol -&gt; (dato hijo-1 hijo-2 ... hijo-n)</code></pre>
<ul>
<li>Los nodos hoja (datos al final del árbol que no tienen ningún hijo)
son también árboles. Al no tener hijos se representan como listas con un único
elemento, el propio dato:</li>
</ul>
<pre class="highlight"><code class="language-text">Nodo hoja -&gt; (dato)</code></pre>
<ul>
<li>¿Cómo representaríamos de esta forma el árbol anterior?</li>
</ul>
<p><img src="imagenes/arbol-sencillo2.png" width="400px"/></p>
<p style="margin-bottom:4cm;"/>

<pre class="highlight"><code class="language-racket">(30 (15 (10) (12)) (18) (25 (19) (21) (22)))</code></pre>
<p><img src="imagenes/lista-arbol.png" width="600px"/></p>
<p>Los elementos de esta lista son:</p>
<ul>
<li>El primer elemento es el número <code>30</code>, el dato valor de la raíz del
  árbol</li>
<li>El segundo elemento es la lista <code>(15 (10) (12))</code>, que representa el
  árbol con dato <code>15</code> y dos hijos</li>
<li>El tercer elemento es la lista <code>(18)</code> que representa el árbol hoja
  formado por un 18</li>
<li>El tercer elemento es la lista <code>(15 (19) (21) (22))</code>, que representa el
  árbol con un dato <code>15</code> y tres hijos</li>
</ul>
<p>Podríamos definir el árbol con la siguiente sentencia:</p>
<pre class="highlight"><code class="language-racket">(define arbol1 '(30 (15 (10) (12)) (18) (25 (19) (21) (22))))</code></pre>
<p style="margin-bottom:3cm;"/>

<p>Otro ejemplo más. ¿Cómo se implementa en Scheme el árbol de la siguiente figura?</p>
<p><img src="imagenes/arbol2.png" width="300px"/></p>
<p style="margin-bottom:4cm;"/>

<p>Se haría con la lista de la siguiente sentencia:</p>
<pre class="highlight"><code class="language-racket">(define arbol2 '(40 (18 (3) (23 (29))) (52 (47))))</code></pre>
<hr />
<h3>Barrera de abstracción</h3>
<ul>
<li>Definimos las funciones básicas para trabajar con árboles,
  las funciones para obtener el dato y los hijos a partir de la
  lista que define el árbol.</li>
<li>Estas funciones proporcionan lo que se denomina <strong>barrera de
  abstracción</strong> del tipo datos <em>árbol</em>.</li>
<li>Una <strong>barrera de abstracción</strong> es un conjunto de funciones que
  permiten trabajar con un tipo de datos escondiendo su
  implementación.</li>
<li>Por convenio, en todas las funciones ponemos el mismo sufijo, el
  nombre del tipo de dato, en este caso <strong>arbol</strong>.</li>
<li>Definimos dos conjuntos de funciones: <strong>constructores</strong> para construir un
  nuevo árbol y <strong>selectores</strong> para obtener los elementos del árbol. Vamos a
  empezar por los selectores.</li>
</ul>
<hr />
<h3>Selectores</h3>
<p>Funciones que obtienen los elementos de un árbol:</p>
<pre class="highlight"><code class="language-racket">(define (dato-arbol arbol) 
    (first arbol))

(define (hijos-arbol arbol) 
    (rest arbol))

(define (hoja-arbol? arbol) 
   (null? (hijos-arbol arbol)))</code></pre>
<p>Es importante tener claro los tipos devueltos por las dos primeras funciones:</p>
<ul>
<li><code>(dato-arbol arbol)</code>: devuelve <strong>el dato</strong> de la raíz del árbol.</li>
<li><code>(hijos-arbol arbol)</code>: devuelve <strong>una lista de árboles</strong> hijos. En
  algunas ocasiones llamaremos <em>bosque</em> a una lista de árboles.</li>
</ul>
<hr />
<h3>Ejemplo de selectores</h3>
<p>Por ejemplo, si usamos el árbol <code>arbol1</code> </p>
<p><img src="imagenes/arbol-sencillo2.png" width="400px"/></p>
<p>Las funciones anteriores devuelven los siguientes valores:</p>
<pre class="highlight"><code class="language-racket">(dato-arbol arbol1) ; ⇒ 30
(hijos-arbol arbol1) ; ⇒ ((15 (10) (12)) (18) (25 (19) (21) (22)))
(hoja-arbol? (first (hijos-arbol arbol1))) ; ⇒ #f
(hoja-arbol? (second (hijos-arbol arbol1))) ; ⇒ #t</code></pre>
<hr />
<h3>Tipos devueltos por las funciones</h3>
<p>Es muy importante considerar en cada caso con qué tipo de dato estamos
trabajando y usar la barrera de abstracción adecuada en cada caso:</p>
<ul>
<li>La función <code>hijos-arbol</code> siempre devuelve una lista de árboles, que
  podemos recorrer usando <code>first</code> y <code>rest</code>.</li>
<li>El <code>first</code> de una lista de árboles (devuelta por <code>hijos-arbol</code>) siempre
  es un árbol y debemos de usar las funciones de su barrera de
  abstracción: <code>dato-arbol</code> e <code>hijos-arbol</code>.</li>
<li>La función <code>dato-arbol</code> devuelve un dato de árbol, del tipo que
  guardemos en el árbol.</li>
</ul>
<div class="admonition warning">
<p class="admonition-title">¡Cuidado!</p>
<p>Para remarcar el uso correcto de la barrera de abstracción
usaremos siempre <code>first</code> y <code>rest</code> cuando trabajemos con listas y
<code>dato-arbol</code> y <code>hijos-arbol</code> cuando lo hagamos con árboles. Aunque
la implementación de las funciones sea la misma, el hecho de
darles nombres distintos nos permite entender mejor sobre qué tipo
de datos estamos trabajando, una lista o un árbol.</p>
</div>
<ul>
<li>Ejemplo: ¿cómo obtendríamos el número 12 del <code>arbol1</code>?</li>
</ul>
<p style="margin-bottom:4cm;"/>

<pre class="highlight"><code class="language-racket">(dato-arbol (second (hijos-arbol (first (hijos-arbol arbol1)))))
; ⇒ 12</code></pre>
<hr />
<h3>Barreras de abstracción de árboles y listas estructuradas</h3>
<ul>
<li>Es importante diferenciar la barrera de abstracción de los árboles
  de la de las listas estructuradas.</li>
<li>Aunque un árbol se implementa en Scheme con una lista estructurada,
  a la hora de trabajar con árboles usaremos su barrera de abstracción
  propia, para resaltar trabajar con el nivel de abstracción correcto
  y esconder la implementación.</li>
<li>El siguiente esquema resumen las características de la barrera de
  abstracción de listas y árboles:</li>
</ul>
<p><img src="imagenes/barrera-abstraccion.png" width="550px"></p>
<ul>
<li>Es muy importante usar la barrera de abstracción al trabajar con
  árboles porque así separamos nuestro código de la implementación
  subyacente del tipo de dato.</li>
</ul>
<hr />
<p><strong>Constructores</strong></p>
<ul>
<li>Función constructora para construir un nuevo árbol:</li>
</ul>
<pre class="highlight"><code class="language-racket">(define (construye-arbol dato lista-arboles)
   (cons dato lista-arboles))</code></pre>
<ul>
<li>La función <code>(construye-arbol dato lista-arboles)</code> recibe un dato y una
  lista de árboles y devuelve un árbol formado por el dato en su raíz
  y la lista de hijos.</li>
<li>Si queremos construir un nodo hoja pasamos una lista vacía como
  <code>lista-arboles</code>. </li>
</ul>
<p>Por ejemplo, para definir un nodo hoja con el dato 2:</p>
<pre class="highlight"><code class="language-racket">(define arbol3 (construye-arbol 2 '()))</code></pre>
<p>Y para definir un árbol con 3 hijos:</p>
<pre class="highlight"><code class="language-racket">(define arbol4 (construye-arbol 10 (list (construye-arbol 2 '())
                                         (construye-arbol 5 '()) 
                                         (construye-arbol 9 '())))</code></pre>
<p>El <code>arbol1</code></p>
<p><img src="imagenes/arbol-sencillo2.png" width="400px"/></p>
<p>Se puede construir con las siguientes llamadas a los constructores:</p>
<pre class="highlight"><code class="language-racket">(define arbol-15 (construye-arbol 15 (list (construye-arbol 10 '())
                                           (construye-arbol 12 '()))))
(define arbol-18 (construye-arbol 18 '()))                                             
(define arbol-25 (construye-arbol 25 (list (construye-arbol 19 '())
                                           (construye-arbol 21 '())
                                           (construye-arbol 22 '()))))
(define arbol1b (construye-arbol 30 (list arbol-15 arbol-18 arbol-25)))
arbol1b ; ⇒ (30 (15 (10) (12)) (18) (25 (19) (21) (22)))</code></pre>
<hr />
<h3>Funciones recursivas sobre árboles</h3>
<p>Vamos a diseñar las siguientes funciones recursivas:</p>
<ul>
<li><code>(suma-datos-arbol arbol)</code>: devuelve la suma de todos los nodos</li>
<li><code>(to-list-arbol arbol)</code>: devuelve una lista con los datos del árbol</li>
<li><code>(cuadrado-arbol arbol)</code>: eleva al cuadrado todos los datos de un
  árbol manteniendo la estructura del árbol original</li>
<li><code>(map-arbol f arbol)</code>: devuelve un árbol con la estructura del árbol
  original aplicando la función f a subdatos.</li>
<li><code>(altura-arbol arbol)</code>: devuelve la altura de un árbol</li>
</ul>
<p>Todas comparten un patrón similar de recursión mutua.</p>
<hr />
<h3>Función <code>(suma-datos-arbol arbol)</code></h3>
<ul>
<li>Vamos a implementar una función recursiva que sume todos los datos
  de un árbol.</li>
<li>Un árbol siempre va a tener un dato y una lista de hijos (que puede
  ser vacía) que obtenemos con las funciones <code>dato-arbol</code> e
  <code>hijos-arbol</code>.</li>
</ul>
<p>Ejemplo:</p>
<pre class="highlight"><code class="language-racket">(define arbol2 '(40 (18 (3) (23 (29))) (52 (47))))
(suma-datos-arbol arbol2) ; ⇒ 212</code></pre>
<ul>
<li>Podemos plantear entonces el problema de sumar los datos de un árbol
  como:</li>
</ul>
<blockquote>
<p>Para sumar los datos de un árbol sumamos el dato de su raíz a la
suma que devuelva la llamada a una función auxiliar que sume los
datos de su lista de hijos (un bosque):</p>
</blockquote>
<pre class="highlight"><code class="language-racket">(define (suma-datos-arbol arbol)
    (+ (dato-arbol arbol)
       (suma-datos-bosque (hijos-arbol arbol))))</code></pre>
<ul>
<li>Esta función suma los datos de <strong>un</strong> árbol.</li>
<li>La podemos utilizar para construir la función auxiliar que suma una
  lista de árboles:</li>
</ul>
<blockquote>
<p>Para sumar los datos de una lista de árboles sumamos los datos del
primero (con la función anterior) y añado lo que me devuelve la
llamada recursiva que suma el resto de árboles:</p>
</blockquote>
<pre class="highlight"><code class="language-racket">(define (suma-datos-bosque bosque)
   (if (null? bosque)
       0
       (+ (suma-datos-arbol (first bosque)) 
          (suma-datos-bosque (rest bosque)))))</code></pre>
<p style="margin-bottom:4cm;"/>

<p><img src="imagenes/suma-datos-bosque.png" width="600px"/></p>
<ul>
<li>Tenemos una recursión mutua: para sumar los datos de una lista de
  árboles llamamos a la suma de un árbol individual que a su vez llama
  a la suma de sus hijos, etc. La recursión termina cuando calculamos
  la suma de un árbol hoja. Entonces se pasa a <code>suma-datos-bosque</code> una
  lista vacía y ésta devolverá 0.</li>
</ul>
<hr />
<h3>Versión alternativa con funciones de orden superior</h3>
<ul>
<li>Al igual que hacíamos con las listas estructuradas, es posible
  conseguir una versión más concisa y elegante utilizando funciones de
  orden superior:</li>
</ul>
<pre class="highlight"><code class="language-racket">(define (suma-datos-arbol-fos arbol)
    (foldr + (dato-arbol arbol) 
        (map suma-datos-arbol-fos (hijos-arbol arbol))))</code></pre>
<p style="margin-bottom:4cm;"/>

<p><img src="imagenes/suma-datos-bosque-fos.png" width="500px"/></p>
<ul>
<li>Una traza de su funcionamiento sería la siguiente:</li>
</ul>
<pre class="highlight"><code class="language-racket">(suma-datos-arbol-fos '(1 (2 (3) (4)) (5) (6 (7)))) ;⇒
(foldr + 1 (map suma-datos-arbol-fos '((2 (3) (4)) 
                                                (5)
                                                (6 (7))))) ; ⇒
(foldr + 1 '(9 5 13)) ;⇒
28</code></pre>
<hr />
<h3>Función <code>(to-list-arbol arbol)</code></h3>
<ul>
<li>Queremos diseñar una función <code>(to-list-arbol arbol)</code> que devuelva una
  lista con los datos del árbol en un recorrido <strong>preorden</strong>.</li>
<li>¿Podríamos hacerlo usando el patrón anterior?</li>
</ul>
<p>Ejemplo:</p>
<pre class="highlight"><code class="language-racket">(to-list-arbol '(* (+ (5) (* (2) (3)) (10)) (- (12)))) 
; ⇒ (* + 5 * 2 3 10 - 12)</code></pre>
<p style="margin-bottom:4cm;"/>

<pre class="highlight"><code class="language-racket">(define (to-list-arbol arbol)
   (cons (dato-arbol arbol)
         (to-list-bosque (hijos-arbol arbol))))

(define (to-list-bosque bosque)
   (if (null? bosque)
       '()
       (append (to-list-arbol (first bosque))
               (to-list-bosque (rest bosque)))))</code></pre>
<hr />
<h3>Versión con funciones de orden superior:</h3>
<p>Una definición alternativa usando funciones de orden superior:</p>
<pre class="highlight"><code class="language-racket">(define (to-list-arbol-fos arbol)
    (cons (dato-arbol arbol)
          (foldr append '() 
               (map to-list-arbol-fos (hijos-arbol arbol)))))</code></pre>
<hr />
<h3>Función <code>(cuadrado-arbol arbol)</code></h3>
<ul>
<li>La función <code>(cuadrado-arbol arbol)</code> que toma un árbol de números y
  devuelve un árbol con la misma estructura y sus datos elevados al
  cuadrado.</li>
<li>También usamos el patrón de recursión mutua, pero ahora para
  <strong>construir</strong> un árbol nuevo:</li>
</ul>
<p>Ejemplo:</p>
<pre class="highlight"><code class="language-racket">(cuadrado-arbol '(2 (3 (4) (5)) (6))) 
; ⇒ (4 (9 (16) (25)) (36))</code></pre>
<pre class="highlight"><code class="language-racket">; Construye un árbol nuevo elevado al cuadrado el que se pasa como parámetro
(define (cuadrado-arbol arbol) 
   (construye-arbol (cuadrado (dato-arbol arbol))
              (cuadrado-bosque (hijos-arbol arbol))))  

; Devuelve una lista de árboles elevados al cuadrado
(define (cuadrado-bosque bosque) 
   (if (null? bosque)
       '()
       (cons (cuadrado-arbol (first bosque))
             (cuadrado-bosque (rest bosque)))))</code></pre>
<hr />
<h3>Versión con funciones de orden superior:</h3>
<pre class="highlight"><code class="language-racket">(define (cuadrado-arbol-fos arbol)
   (construye-arbol (cuadrado (dato-arbol arbol))
              (map cuadrado-arbol-fos (hijos-arbol arbol))))</code></pre>
<hr />
<h3><code>(map-arbol f arbol)</code></h3>
<p>La función <code>map-arbol</code> es una función de orden superior que generaliza
la función anterior. Definimos un parámetro adicional en el que se
pasa la función a aplicar a los elementos del árbol.</p>
<p>Ejemplos:</p>
<pre class="highlight"><code class="language-racket">(map-arbol cuadrado '(2 (3 (4) (5)) (6)))
; ⇒ (4 (9 (16) (25)) (36))
(map-arbol (lambda (x) (+ x 1)) '(2 (3 (4) (5)) (6)))
; ⇒ (3 (4 (5) (6)) (7))</code></pre>
<pre class="highlight"><code class="language-racket">(define (map-arbol f arbol)
   (construye-arbol (f (dato-arbol arbol))
              (map-bosque f (hijos-arbol arbol))))  

(define (map-bosque f bosque)
   (if (null? bosque)
       '()
       (cons (map-arbol f (first bosque))
             (map-bosque f (rest bosque)))))</code></pre>
<hr />
<h3>Versión con funciones de orden superior:</h3>
<pre class="highlight"><code class="language-racket">(define (map-arbol-fos f arbol)
  (construye-arbol (f (dato-arbol arbol))
             (map (lambda (x)
                    (map-arbol-fos f x)) (hijos-arbol arbol))))</code></pre>
<hr />
<h3>Función <code>(altura-arbol arbol)</code></h3>
<p>Vamos por último a definir una función que devuelve la altura de un
árbol (el nivel del nodo de mayor nivel). Un nodo hoja tiene de altura
0.</p>
<p>Ejemplos:</p>
<pre class="highlight"><code class="language-racket">(altura-arbol '(2)) ;  ⇒ 0
(altura-arbol '(4 (9 (16) (25)) (36))) ; ⇒ 2</code></pre>
<pre class="highlight"><code class="language-racket">(define (altura-arbol arbol)
   (if (hoja-arbol? arbol)
       0
       (+ 1 (altura-bosque (hijos-arbol arbol)))))  

(define (altura-bosque bosque)
    (if (null? bosque)
        0
        (max (altura-arbol (first bosque))
             (altura-bosque (rest bosque)))))</code></pre>
<hr />
<h3>Versión con funciones de orden superior:</h3>
<p>La implementación con funciones de orden superior es similar a la que
vimos con listas estructuradas:</p>
<pre class="highlight"><code class="language-racket">(define (altura-arbol-fos arbol)
  (if (hoja-arbol? arbol)
      0
      (+ 1 (foldr max 0
                  (map altura-arbol-fos (hijos-arbol arbol))))))</code></pre>
<hr />
<h3>Árboles binarios</h3>
<p>Los árboles binarios son árboles cuyos nodos tienen 0, 1 o 2
hijos. Por ejemplo, el árbol mostrado en la siguiente figura es un
árbol binario.</p>
<p><img src="imagenes/binario-2.png" width="300px"/></p>
<p>A diferencia de los árboles genéricos vistos anteriormente un árbol
binario no puede tener más de dos hijos.</p>
<hr />
<h3>Árboles binarios en Scheme</h3>
<p>Representamos un árbol binario en Scheme utilizando una lista de tres elementos:</p>
<ul>
<li>Dato</li>
<li>Hijo izquierdo (otro árbol binario)</li>
<li>Hijo derecho (otro árbol binario)</li>
</ul>
<p>En el caso en que no exista el hijo izquierdo o el derecho (o ambos)
utilizaremos una lista vacía para indicar un nodo vacío.</p>
<p>Ejemplo, nodo hoja con el dato 10:</p>
<pre class="highlight"><code class="language-racket">'(10 () ())</code></pre>
<p>Otro ejemplo, el árbol de la figura anterior:</p>
<pre class="highlight"><code class="language-racket">'(40 (18 (3 () ())
         (23 ()
             (29 () ())))
     (52 (47 () ())
         ()))</code></pre>
<p><img src="imagenes/binario-3.png" width="350px"/></p>
<hr />
<h3>Barrera de abstracción</h3>
<p>Definimos la siguiente barrera de abstracción para los árboles
binarios. Terminamos todos los nombres de las funciones con el sufijo
<code>-arbolb</code> (árbol binario).</p>
<p><strong>Selectores</strong></p>
<pre class="highlight"><code class="language-racket">(define (dato-arbolb arbol)
   (first arbol))

(define (hijo-izq-arbolb arbol)
   (second arbol))

(define (hijo-der-arbolb arbol)
   (third arbol))

(define (vacio-arbolb? x)
   (null? x))

(define arbolb-vacio '())</code></pre>
<p><strong>Constructor</strong></p>
<pre class="highlight"><code class="language-racket">(define (construye-arbolb dato hijo-izq hijo-der)
    (list dato hijo-izq hijo-der))</code></pre>
<p>Por ejemplo, para construir un árbol con 10 en la raíz y 8 en su hijo
izquierdo y 15 en su derecho utilizando el constructor de la barrera
de abstracción:</p>
<pre class="highlight"><code class="language-racket">(define arbolb1
   (construye-arbolb 10 (construye-arbolb 8 arbolb-vacio arbolb-vacio)
                        (construye-arbolb 15 arbolb-vacio arbolb-vacio)))</code></pre>
<p>Otro ejemplo, el árbol binario de la figura anterior utilizando el
constructor de la barrera de abstracción:</p>
<pre class="highlight"><code class="language-racket">(define arbolb2
   (construye-arbolb 40 
                    (construye-arbolb 18
                                      (construye-arbolb 3 arbolb-vacio arbolb-vacio)
                                      (construye-arbolb 23 
                                                        arbolb-vacio
                                                        (construye-arbolb 29 
                                                                          arbolb-vacio
                                                                          arbolb-vacio)))
                    (construye-arbolb 52
                                      (construye-arbolb 47 arbolb-vacio arbolb-vacio)
                                      arbolb-vacio)))</code></pre>
<hr />
<h3>Funciones recursivas sobre árboles binarios</h3>
<p>Veamos las siguientes funciones recursivas sobre árboles binarios:</p>
<ul>
<li><code>(suma-datos-arbolb arbol)</code>: devuelve la suma de todos los nodos</li>
<li><code>(to-list-arbolb arbol)</code>: devuelve una lista con los datos del árbol</li>
<li><code>(cuadrado-arbolb arbol)</code>: eleva al cuadrado todos los datos de un
  árbol manteniendo la estructura del árbol original</li>
</ul>
<p><strong>suma-datos-arbolb</strong></p>
<pre class="highlight"><code class="language-racket">(define (suma-datos-arbolb arbol)
   (if (vacio-arbolb? arbol)
      0
      (+ (dato-arbolb arbol)
         (suma-datos-arbolb (hijo-izq-arbolb arbol))
         (suma-datos-arbolb (hijo-der-arbolb arbol)))))

(suma-datos-arbolb arbolb2) ; ⇒ 212</code></pre>
<p><img src="imagenes/suma-datos-binario.png" width="500px"/></p>
<p><strong>to-list-arbolb</strong></p>
<pre class="highlight"><code class="language-racket">(define (to-list-arbolb arbol)
   (if (vacio-arbolb? arbol)
      '()
      (cons (dato-arbolb arbol)
            (append (to-list-arbolb (hijo-izq-arbolb arbol))
                    (to-list-arbolb (hijo-der-arbolb arbol))))))

(to-list-arbolb arbolb2) ; ⇒ (40 18 3 23 29 52 47)</code></pre>
<p><strong>cuadrado-arbolb</strong></p>
<pre class="highlight"><code class="language-racket">(define (cuadrado-arbolb arbol)
   (if (vacio-arbolb? arbol)
      arbolb-vacio
      (construye-arbolb (cuadrado (dato-arbolb arbol))
                        (cuadrado-arbolb (hijo-izq-arbolb arbol))
                        (cuadrado-arbolb (hijo-der-arbolb arbol)))))

(cuadrado-arbolb arbolb1) ; ⇒ (100 (64 () ()) (225 () ()))</code></pre>
<hr /></body>

</html>
