<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
<style type="text/css">

/* Admonition */

.admonition {
    padding-left: 15px;
    padding-right: 15px;
    margin-bottom: 10px;
    border: 1px solid transparent;
    border-radius: 4px;
    text-align: left;
}

.admonition.note { /* csslint allow: adjoining-classes */
    color: black;
    background-color: #d9edf7;
    border-color: #bce8f1;
}

.admonition.quote { /* csslint allow: adjoining-classes */
    color: black;
    background-color: #cecece;
    border-color: #cccccc;
}

.admonition.warning { /* csslint allow: adjoining-classes */
    color: black;
    background-color: #FCC8BE;
    border-color: #FCC8BE;
}

.admonition.hint { /* csslint allow: adjoining-classes */
    color: black;
    background-color: #E9F9F6;
    border-color: #AFEEEE;
}

.admonition.danger { /* csslint allow: adjoining-classes */
    color: black;
    background-color: #F7B2A4;
    border-color: #F7B2A4;
}

.admonition-title {
    font-weight: bold;
    text-align: left;
}


/* Codehilite */

.hll { background-color: #ffffcc }
.c { color: #408080; font-style: italic } /* Comment */
.err { border: 1px solid #FF0000 } /* Error */
.k { color: #008000; font-weight: bold } /* Keyword */
.o { color: #666666 } /* Operator */
.ch { color: #408080; font-style: italic } /* Comment.Hashbang */
.cm { color: #408080; font-style: italic } /* Comment.Multiline */
.cp { color: #BC7A00 } /* Comment.Preproc */
.cpf { color: #408080; font-style: italic } /* Comment.PreprocFile */
.c1 { color: #408080; font-style: italic } /* Comment.Single */
.cs { color: #408080; font-style: italic } /* Comment.Special */
.gd { color: #A00000 } /* Generic.Deleted */
.ge { font-style: italic } /* Generic.Emph */
.gr { color: #FF0000 } /* Generic.Error */
.gh { color: #000080; font-weight: bold } /* Generic.Heading */
.gi { color: #00A000 } /* Generic.Inserted */
.go { color: #888888 } /* Generic.Output */
.gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.gs { font-weight: bold } /* Generic.Strong */
.gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.gt { color: #0044DD } /* Generic.Traceback */
.kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.kp { color: #008000 } /* Keyword.Pseudo */
.kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.kt { color: #B00040 } /* Keyword.Type */
.m { color: #666666 } /* Literal.Number */
.s { color: #BA2121 } /* Literal.String */
.na { color: #7D9029 } /* Name.Attribute */
.nb { color: #008000 } /* Name.Builtin */
.nc { color: #0000FF; font-weight: bold } /* Name.Class */
.no { color: #880000 } /* Name.Constant */
.nd { color: #AA22FF } /* Name.Decorator */
.ni { color: #999999; font-weight: bold } /* Name.Entity */
.ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.nf { color: #0000FF } /* Name.Function */
.nl { color: #A0A000 } /* Name.Label */
.nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.nt { color: #008000; font-weight: bold } /* Name.Tag */
.nv { color: #19177C } /* Name.Variable */
.ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.w { color: #bbbbbb } /* Text.Whitespace */
.mb { color: #666666 } /* Literal.Number.Bin */
.mf { color: #666666 } /* Literal.Number.Float */
.mh { color: #666666 } /* Literal.Number.Hex */
.mi { color: #666666 } /* Literal.Number.Integer */
.mo { color: #666666 } /* Literal.Number.Oct */
.sa { color: #BA2121 } /* Literal.String.Affix */
.sb { color: #BA2121 } /* Literal.String.Backtick */
.sc { color: #BA2121 } /* Literal.String.Char */
.dl { color: #BA2121 } /* Literal.String.Delimiter */
.sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.s2 { color: #BA2121 } /* Literal.String.Double */
.se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.sh { color: #BA2121 } /* Literal.String.Heredoc */
.si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.sx { color: #008000 } /* Literal.String.Other */
.sr { color: #BB6688 } /* Literal.String.Regex */
.s1 { color: #BA2121 } /* Literal.String.Single */
.ss { color: #19177C } /* Literal.String.Symbol */
.bp { color: #008000 } /* Name.Builtin.Pseudo */
.fm { color: #0000FF } /* Name.Function.Magic */
.vc { color: #19177C } /* Name.Variable.Class */
.vg { color: #19177C } /* Name.Variable.Global */
.vi { color: #19177C } /* Name.Variable.Instance */
.vm { color: #19177C } /* Name.Variable.Magic */
.il { color: #666666 } /* Literal.Number.Integer.Long */

/* Estilo LPP */

body {
  font-family: Helvetica, arial, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  background-color: white;
  padding: 60px;
}

pre {
  background-color: #f8f8f8;
  border: 1px solid #cccccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px;
}

table {
  padding: 0;border-collapse: collapse; }
  table tr {
    border-top: 1px solid #cccccc;
    background-color: white;
    margin: 0;
    padding: 0; }
    table tr:nth-child(2n) {
      background-color: #f8f8f8; }
    table tr th {
      font-weight: bold;
      border: 1px solid #cccccc;
      margin: 0;
      padding: 6px 13px; }
    table tr td {
      border: 1px solid #cccccc;
      margin: 0;
      padding: 6px 13px; }
    table tr th :first-child, table tr td :first-child {
      margin-top: 0; }
    table tr th :last-child, table tr td :last-child {
      margin-bottom: 0; }

</style>

</head>

<body>
<h2>Semana 5</h2>
<p>Notas de clase de la semana 5 de LPP.</p>
<h2>Tema 3: Procedimientos recursivos</h2>
<ul>
<li>El coste de la recursión</li>
<li>Soluciones al coste de la recursión: procesos iterativos</li>
<li>Soluciones al coste de la recursión: memoization</li>
<li>Figuras recursivas</li>
</ul>
<hr />
<h3>El coste de la recursión</h3>
<ul>
<li>Vamos a analizar el coste de la recursión de una forma empírica, sin
  realizar una análisis matemático riguroso.</li>
<li>Veremos que el coste se dispara cuando tenemos dos llamadas
  recursivas.</li>
<li>Veremos dos formas de conseguir que el coste sea menor.</li>
</ul>
<hr />
<h3>La pila de la recursión</h3>
<ul>
<li>Para analizar una función vamos por primera vez a <em>entrar en la
  recursión</em> y hacer una traza de las llamadas recursivas del
  siguiente:</li>
</ul>
<pre class="highlight"><code class="language-racket">(define (mi-length items)
    (if (null? items)
        0
        (+ 1 (mi-length (rest items)))))</code></pre>
<ul>
<li>¿Cómo podemos representar las llamadas y el resultado de <code>(mi-length
  '(a b c d))</code></li>
</ul>
<p style="margin-bottom:2cm;"></p>

<pre class="highlight"><code class="language-text">(mi-length '(a b c d))
(+ 1 (mi-length '(b c d)))
(+ 1 (+ 1 (mi-length '(c d))))
(+ 1 (+ 1 (+ 1 (mi-length '(d)))))
(+ 1 (+ 1 (+ 1 (+ 1 (mi-length '())))))
(+ 1 (+ 1 (+ 1 (+ 1 0))))
(+ 1 (+ 1 (+ 1 1)))
(+ 1 (+ 1 2))
(+ 1 3)
4</code></pre>
<ul>
<li>Cada llamada a la recursión <strong>deja una función en espera de ser
  evaluada cuando la recursión devuelva un valor</strong> (en el caso
  anterior el +). Esta función, junto con sus argumentos, se almacenan
  en la <strong>pila de la recursión</strong>.</li>
<li>Cuando la recursión devuelve un valor, los valores se recuperan de
  la pila, se realiza la llamada y se devuelve el valor a la anterior
  llamada en espera.</li>
<li>Si la recursión está mal hecha y nunca termina se genera un <em>stack
  overflow</em> porque la memoria que se almacena en la pila sobrepasa la
  memoria reservada para el intérprete DrRacket.</li>
</ul>
<hr />
<h3>Coste espacial de la recursión</h3>
<ul>
<li>
<p>El coste espacial de un programa es una función que relaciona la
  memoria consumida por una llamada para resolver un problema con
  alguna variable que determina el tamaño del problema a resolver.</p>
</li>
<li>
<p>En el caso de la función <code>mi-length</code> el tamaño del problema viene
  dado por la longitud de la lista. El coste espacial de <code>mi-lenght</code>
  es <em>O(n)</em>, siendo <em>n</em> la longitud de la lista.</p>
</li>
</ul>
<hr />
<h3>1.2.3 El coste depende del número de llamadas a la recursión</h3>
<ul>
<li>
<p>Veamos con un ejemplo que el coste de las llamadas recursivas puede
  dispararse. Supongamos la famosa [secuencia de Fibonacci]:
  0,1,1,2,3,5,8,13,...</p>
</li>
<li>
<p>Secuencia de Fibonacci en la <a href="http://en.wikipedia.org/wiki/Fibonacci_number">Wikipedia</a></p>
</li>
<li>
<p>Formulación matemática de la secuencia de Fibonacci:</p>
</li>
</ul>
<pre class="highlight"><code class="language-text">Fibonacci(n) = Fibonacci(n-1) + Fibonacci(n-2)  
Fibonacci(0) = 0  
Fibonacci(1) = 1</code></pre>
<ul>
<li>Formulación recursiva en Scheme:</li>
</ul>
<pre class="highlight"><code class="language-racket">(define (fib n)
    (cond ((= n 0) 0)
        ((= n 1) 1)
        (else (+ (fib (- n 1))
                 (fib (- n 2))))))</code></pre>
<ul>
<li>Evaluación de una llamada a Fibonacci:</li>
</ul>
<p><img src="./imagenes/fibonacci.png"/></p>
<ul>
<li>
<p>Cada llamada a la recursión produce otras dos llamadas, por lo que
  el número de llamadas finales es 2^n siendo n el número que se pasa
  a la función.</p>
</li>
<li>
<p>El coste espacial y temporal es exponencial, O(2^n).</p>
</li>
<li>
<p>¿Qué pasa si intentamos evaluar <code>(fib 40)</code>?</p>
</li>
</ul>
<hr />
<h3>1.3 Soluciones al coste de la recursión: procesos iterativos</h3>
<ul>
<li>Diferenciamos entre procedimientos y procesos: un procedimiento es
  un algoritmo y un proceso es la ejecución de ese algoritmo.</li>
<li>Es posible definir <em>procedimientos recursivos</em> que generen <em>procesos
  iterativos</em> en los que no se dejen llamadas recursivas en espera ni
  se incremente la pila de la recursión.</li>
<li>
<p><strong>Solución</strong>: Construimos la recursión de forma que en cada llamada
  se haga un cálculo parcial y en el caso base se pueda devolver
  directamente el resultado obtenido.</p>
</li>
<li>
<p>Este estilo de recursión se denomina <em>recursión por la cola</em>
  (<a href="http://en.wikipedia.org/wiki/Tail_call">tail recursion</a>, en
  inglés).</p>
</li>
</ul>
<hr />
<h3>Versión iterativa de mi-length</h3>
<ul>
<li>Definimos la función <code>(mi-length-iter lista result)</code> que es la que
  define el proceso iterativo</li>
<li>Tiene un parámetro adicional (<code>result</code>) que es el parámetro en el
  que se irán guardando los cálculos intermedios</li>
<li>Al final de la recursión la longitud debe estar calculada en
  <code>result</code> y se devuelve</li>
</ul>
<pre class="highlight"><code class="language-racket">(define (mi-length lista)
   (mi-length-iter lista 0))

(define (mi-length-iter lista result)
   (if (null? lista)
      result
      (mi-length-iter (rest lista) (+ result 1))))</code></pre>
<p>Secuencia de llamadas:</p>
<pre class="highlight"><code class="language-text">(mi-length '(a b c d)) =&gt;
(mi-length-iter '(a b c d) 0) =&gt;
(mi-length-iter '(b c d) 1) =&gt;
(mi-length-iter '(c d) 2) =&gt;
(mi-length-iter '(d) 3) =&gt;
(mi-length-iter '() 4) =&gt;
4</code></pre>
<hr />
<h3>Procesos iterativos</h3>
<ul>
<li>La recursión resultante es menos elegante</li>
<li>Se necesita una parámetro adicional en el que se van acumulando los
  resultados parciales</li>
<li>La última llamada a la recursión devuelve el valor acumulado</li>
<li>El proceso resultante de la recursión es iterativo en el sentido de
  que no deja llamadas en espera ni incurre en coste espacial</li>
</ul>
<hr />
<h3>Ejemplo de función iterativa - max</h3>
<ul>
<li>¿Cómo definiríamos de forma iterativa la función <code>(max lista)</code>
que devuelve el máximo de una lista de números?</li>
</ul>
<p style="margin-bottom:2cm;"></p>

<pre class="highlight"><code class="language-racket">(define (max lista)
    (max-iter (rest lista) (first lista)))

(define (max-iter lista result)
    (if (null? lista)
        result
        (max-iter (rest lista) (if (&gt; result (first lista))
                                   result
                                   (first lista)))))</code></pre>
<hr />
<h3>Ejemplo de función iterativa - mi-reverse</h3>
<ul>
<li>¿Cómo definiríamos de forma iterativa la función <code>(mi-reverse lista)</code>
que devuelve una lista invertida?</li>
</ul>
<p style="margin-bottom:2cm;"></p>

<pre class="highlight"><code class="language-racket">(define (mi-reverse lista)
    (reverse-iter lista '()))

 (define (reverse-iter lista result)
    (if (null? lista)
        result
        (reverse-iter (rest lista) (cons (first lista) result))))</code></pre>
<hr />
<h3>Fibonacci iterativo</h3>
<ul>
<li>Cualquier programa recursivo se puede transformar en otro que genera
  un proceso iterativo.</li>
<li>En general, las versiones iterativas son menos intuitivas y más
  difíciles de entender y depurar.</li>
<li>Ejemplo: Fibonacci iterativo</li>
</ul>
<pre class="highlight"><code class="language-racket">(define (fib n)
    (fib-iter 1 0 n))

(define (fib-iter a b count)
    (if (= count 0)
        b
        (fib-iter (+ a b) a (- count 1))))</code></pre>
<hr />
<h3>Triángulo de Pascal</h3>
<pre class="highlight"><code class="language-text">1
1   1
1   2   1
1   3   3   1
1   4   6   4   1
1   5  10   10  5   1
1   6  15  20   15  6   1
1   7  21  35   35  21  7   1
             ...</code></pre>
<p>-- Formulación matemática:</p>
<pre class="highlight"><code class="language-text">Pascal(n, 0) = 1  
Pascal(n, n) = 1  
Pascal(fila, columna) = Pascal(fila-1,columna-1) + Pascal(fila-1, columna)</code></pre>
<p>La versión recursiva pura:</p>
<pre class="highlight"><code class="language-racket">(define (pascal row col)
    (cond ((= col 0) 1)
          ((= col row) 1)
          (else (+ (pascal (- row 1) (- col 1))
                   (pascal (- row 1) col) ))))
(pascal 4 2)
(pascal 8 4)
(pascal 27 13)</code></pre>
<hr />
<h3>Triángulo de Pascal versión iterativa</h3>
<p>Utilizamos enfoque iterativo: cada fila se genera a partir de la
anterior (lo hace la función <code>pascal-sig-fila</code> que recibe
como parámetro la fila anterior).</p>
<p>Por ejemplo:</p>
<pre class="highlight"><code class="language-racket">(pascal-sig-fila '(1 3 3 1))
; ⇒ (1 4 6 4 1)</code></pre>
<p>Usando la función anterior definimos la función <code>pascal-fila</code> a la que
le pasamos el número de fila <code>n</code> y nos devuelve la lista de <code>n+1</code>
números que constituyen la fila <code>n</code> del triángulo de Pascal:</p>
<pre class="highlight"><code class="language-text">fila 0 = (1)
fila 1 = (1 1)
fila 2 = (1 2 1)
fila 3 = (1 3 3 1)
fila 4 = (1 4 6 4 1)
...</code></pre>
<p>El código completo:</p>
<pre class="highlight"><code class="language-racket">(define (pascal fila col)
   (list-ref (pascal-fila '(1) fila) col))

(define (pascal-fila lista-fila n)
   (if (= 0 n)
      lista-fila
      (pascal-fila (pascal-sig-fila lista-fila) (- n 1))))

(define (pascal-sig-fila lista-fila)
   (append '(1)
           (pascal-suma-dos-a-dos lista-fila)
           '(1)))

(define (pascal-suma-dos-a-dos lista-fila)
   (if (null? (rest lista-fila))
      '()
      (cons (+ (first lista-fila) (second lista-fila))
            (pascal-suma-dos-a-dos (rest lista-fila)))))</code></pre>
<hr />
<h3>Soluciones al coste de la recursión: memoization</h3>
<ul>
<li>
<p>Una alternativa que mantiene la elegancia de los procesos recursivos
  y la eficiencia de los iterativos es la
  <a href="http://en.wikipedia.org/wiki/Memoization">memoization</a>. Si miramos
  la traza de <code>(fib 4)</code> podemos ver que el coste está producido
  por la repetición de llamadas; por ejemplo <code>(fib 3)</code> se evalúa
  2 veces.</p>
</li>
<li>
<p>En programación funcional la llamada a <code>(fib 3)</code> siempre va a
  devolver el mismo valor.</p>
</li>
<li>
<p>Podemos guardar el valor devuelto por la primera llamada en alguna
  estructura (una lista de asociación, por ejemplo) y no volver a
  realizar la llamada a la recursión las siguientes veces.</p>
</li>
</ul>
<hr />
<h3>Fibonacci con memoization</h3>
<ul>
<li>
<p>Usamos un diccionario con los métodos <code>put</code> y <code>get</code> que actualizan su información con mutación (no pertenecen al paradigma funcional).</p>
</li>
<li>
<p>La función <code>(make-dic)</code> devuelve un diccionario vacío.</p>
</li>
<li>
<p>La función <code>(put key value dic)</code> asocia un valor a una clave, la
 guarda en el diccionario (con mutación) y devuelve el valor.</p>
</li>
<li>
<p>La función <code>(get key dic)</code> devuelve el valor del diccionario asociado a
una clave (si no existe devuelve <code>#f</code>). </p>
</li>
<li>
<p>El predicado <code>(key-exists? key dic)</code> devuelve <code>#f</code> en que no exista la clave y <code>#t</code> si existe.</p>
</li>
</ul>
<p>Ejemplos:</p>
<pre class="highlight"><code class="language-racket">(define mi-dic (make-dic))
(put 1 10 mi-dic) ; ⇒ 10
(get 1 mi-dic) ; ⇒ 10
(key-exists? 2 dic) ; ⇒ #f</code></pre>
<ul>
<li>
<p>La implementación utiliza parejas mutables. Está
  incluida en el <a href="https://raw.githubusercontent.com/domingogallardo/apuntes-lpp/master/src/lpp.rkt">fichero <code>lpp.rkt</code></a>.</p>
</li>
<li>
<p>La función <code>fib-memo</code> realiza el cálculo de la serie de Fibonacci
  utilizando el proceso recursivo visto anteriormente y la técnica de
  memoización, en la que se consulta el valor de Fibonacci en el diccionario
  antes de realizar la llamada recursiva:</p>
</li>
</ul>
<pre class="highlight"><code class="language-racket">(require "lpp.rkt")

(define (fib-memo n dic)
  (cond ((= n 0) 0)
        ((= n 1) 1)
        ((key-exists? n dic) (get n dic))
        (else (put n (+ (fib-memo (- n 1) dic)
                        (fib-memo (- n 2) dic)) dic))))</code></pre>
<ul>
<li>Podemos comprobar la diferencia de tiempos de ejecución entre esta
  versión y la anterior. El coste de la función <em>memoizada</em> es
  O(n). Frente al coste O(2^n) de la versión inicial que la hacía
  imposible de utilizar.</li>
</ul>
<pre class="highlight"><code class="language-racket">(define dic (crea-diccionario))
(fib-memo 200 dic)
; ⇒ 280571172992510140037611932413038677189525</code></pre>
<hr />
<h3>Figuras recursivas</h3>
<ul>
<li>Último ejemplo de uso de la recursión, algo distinto de los vistos
  hasta ahora.</li>
<li>Usaremos la recursión para dibujar figuras fractales usando la
  librería de imágenes de Racket <code>2htdp/image</code>.</li>
</ul>
<hr />
<h3>Construcción de imágenes básicas</h3>
<p>Círculo, cuadrado, rectángulo y triángulo:</p>
<pre class="highlight"><code class="language-racket">#lang racket
(require 2htdp/image)

(circle 30 "solid" "blue")
(square 30 "outline" "black")
(rectangle 80 40 "solid" "gray")
(triangle 40 "solid" "red")</code></pre>
<p><img src="imagenes/imagenes-basicas.png" width="100px"/></p>
<p>Podemos también construir un triángulo isósceles indicando la
longitud de sus lados iguales y el ángulo entre ellos:</p>
<pre class="highlight"><code class="language-racket"> (isosceles-triangle 60 30 "outline" "black") </code></pre>
<p><img src="imagenes/image-isosceles.png" width="360px"/></p>
<p>Y también trazar una línea desde la esquina superior izquierda hasta
la coordenada (<em>x</em>, <em>y</em>) (la coordenada <em>x</em> crece hacia la derecha y
la <em>y</em> hacia abajo):</p>
<pre class="highlight"><code class="language-racket">(line 30 30 "black")</code></pre>
<p><img src="imagenes/image-line.png" width="30"/></p>
<hr />
<h3>Operaciones y combinaciones de imágenes</h3>
<p>Podemos rotar una imagen un ángulo, expresado en grados sexagesimales
en el sentido contrario de las agujas del reloj. Por ejemplo, podemos
rotar el triángulo isósceles anterior:</p>
<pre class="highlight"><code class="language-racket">(define triangulo (isosceles-triangle 60 30 "outline" "black"))
(rotate 90 triangulo) 
; ⇒ imagen rotada 90 grados en sentido contrario a las agujas del reloj
(rotate -90 triangulo)
; ⇒ imagen rotada 90 grados en sentido de las agujas del reloj</code></pre>
<p><img src="imagenes/imagen-rotada.png" width="500px"/></p>
<p>Podemos también combinar imágenes, agrupándolas con las funciones
<code>above</code> y <code>beside</code>:</p>
<pre class="highlight"><code class="language-racket">(above (ellipse 70 20 "solid" "gray")
       (ellipse 50 20 "solid" "darkgray")
       (ellipse 30 20 "solid" "dimgray")
       (ellipse 10 20 "solid" "black"))</code></pre>
<p><img src="imagenes/image-above.png" width="340px"/></p>
<pre class="highlight"><code class="language-racket">(beside (ellipse 20 70 "solid" "gray")
        (ellipse 20 50 "solid" "darkgray")
        (ellipse 20 30 "solid" "dimgray")
        (ellipse 20 10 "solid" "black"))</code></pre>
<p><img src="imagenes/image-beside.png" width="340px"/></p>
<p>En los dos ejemplos anteriores las imágenes agrupadas se alinean en el
centro. Si queremos otra alineación podemos especificara usando las
funciones <code>above/align</code> y <code>beside/align</code>.</p>
<pre class="highlight"><code class="language-racket">(above/align "left"
               (ellipse 70 20 "solid" "yellowgreen")
               (ellipse 50 20 "solid" "olivedrab")
               (ellipse 30 20 "solid" "darkolivegreen")
               (ellipse 10 20 "solid" "darkgreen"))</code></pre>
<p><img src="imagenes/image-above-left.png" width="100px"/></p>
<pre class="highlight"><code class="language-racket">(above/align "right"
               (ellipse 70 20 "solid" "gold")
               (ellipse 50 20 "solid" "goldenrod")
               (ellipse 30 20 "solid" "darkgoldenrod")
               (ellipse 10 20 "solid" "sienna"))</code></pre>
<p><img src="imagenes/image-above-right.png" width="100px"/></p>
<pre class="highlight"><code class="language-racket">(beside/align "top"
                (ellipse 20 70 "solid" "mediumorchid")
                (ellipse 20 50 "solid" "darkorchid")
                (ellipse 20 30 "solid" "purple")
                (ellipse 20 10 "solid" "indigo"))</code></pre>
<p><img src="imagenes/image-beside-top.png" width="100px"/></p>
<pre class="highlight"><code class="language-racket">(beside/align "bottom"
                (ellipse 20 70 "solid" "lightsteelblue")
                (ellipse 20 50 "solid" "mediumslateblue")
                (ellipse 20 30 "solid" "slateblue")
                (ellipse 20 10 "solid" "navy"))</code></pre>
<p><img src="imagenes/image-beside-bottom.png" width="100px"/></p>
<p>Podemos combinar todas las funciones anteriores para construir figuras
complejas:</p>
<pre class="highlight"><code class="language-racket">(rotate 45
        (above (triangle 40 "solid" "orange")
               (beside (rectangle 40 30 "solid" "black")
                       (rectangle 40 30 "solid" "olivedrab"))))</code></pre>
<p><img src="imagenes/imagen-compleja.png" width="100px"/></p>
<hr />
<h3>Triángulo de Sierpinski</h3>
<p>Vamos a utilizar las funciones anteriores que construyen imágenes para
construir una figura fractal, el denominado riángulo de Sierpinski,
usando la recursión.</p>
<p><img src="imagenes/sierpinski.png" width="400px"/></p>
<ul>
<li>¿Ves alguna recursión en la figura? </li>
<li>¿Cuál podría ser el parámetro de la función que la dibujara? </li>
<li>¿Se te ocurre un algoritmo recursivo que la dibuje?</li>
</ul>
<hr />
<h3>Algoritmo recursivo</h3>
<p>Supongamos que tenemos tres triángulos de Sierpinski de anchura
<em>x</em>. ¿Cómo podríamos construir el triángulo de Sierpinski de anchura
<em>2*x</em>?</p>
<p>Lo podríamos hacer combinando las tres imágenes de la siguiente forma:</p>
<ol>
<li>Juntamos 2 triángulos uno junto a otro.</li>
<li>Sobre la figura resultante colocamos (alineada en el centro) el
   triángulo restante.</li>
</ol>
<p><img src="imagenes/sierpinski.png" width="150px"/> <img
src="imagenes/image-esquema-sierpinski.png" width="200px"/> <img src="imagenes/sierpinski.png" width="300px"/></p>
<ul>
<li>
<p>El algoritmo recursivo se basa en la misma idea, pero <strong>hacia
atrás</strong>. Dibujamos un triángulo de anchura <em>x</em> basándonos en 3
llamadas recursivas a triángulos más pequeños (de anchura <em>x/2</em>).</p>
</li>
<li>
<p>En el caso base, cuando <em>x</em> sea menor que un umbral <em>h</em>, dibujaremos un
triángulo elemental de base <em>h</em>.</p>
</li>
</ul>
<hr />
<h3>Caso base de la recursión: triángulo elemental de Sierpinski</h3>
<p>Para construir la imagen elemental del triángulo de Sierpinski
necesitamos un triángulo isósceles de ángulo 90 y base <em>h</em>.</p>
<p><img src="imagenes/image-sierpinski-elemental.png" width="300px"/></p>
<p>La hipotenusa de un triángulo rectángulo con dos catetos de longitud
<em>x</em> se calcula con la siguiente expresión:</p>
<p>$$hipot(x) = \sqrt{x^2+x^2} = x \sqrt{2}$$</p>
<p>Lo podemos expresar en Racket:</p>
<pre class="highlight"><code class="language-racket">(define (hipotenusa x)
  (* x (sqrt 2)))</code></pre>
<p>El triángulo de Sierpinski elemental de base <code>h</code>. Será un triángulo
isósceles de ángulo 90 grados y de longitud de lado <code>hipotenusa(h/2)</code>:</p>
<p><pre class="highlight"><code class="language-racket">(define (sierpinski-elem base)
  (isosceles-triangle (hipotenusa (/ base 2)) 90 "outline" "black"))</code></pre>
<pre class="highlight"><code class="language-racket">(sierpinski-elem 40)</code></pre></p>
<p><img src="imagenes/image-sierpinski-elem.png" width="180px"/></p>
<hr />
<h3>Caso general de la recursión</h3>
<ul>
<li>El triángulo de Sierpinski de ancho <em>x</em> se construye llamando a la
recursión para que construya el triángulo de ancho <em>x/2</em> y componiendo
la imagen resultante con el patrón visto anteriormente.</li>
</ul>
<p>Recursión completa:</p>
<pre class="highlight"><code class="language-racket">(define (sierpinski ancho)
  (if (&lt; ancho 10)
      (sierpinski-elem ancho)
      (above (sierpinski (/ ancho 2))
             (beside (sierpinski (/ ancho 2))
                     (sierpinski (/ ancho 2))))))</code></pre>
<p><img src="imagenes/image-sierpinski.png" width="600px"/></p>
<ul>
<li>
<p>Mejoramos el código para evitar hacer tres llamadas recursivas. </p>
</li>
<li>
<p>Como todas las llamadas son iguales, hacemos solo una única llamada y
  pasamos el valor resultante (la figura de Sierpiniski pequeña) a una
  función auxiliar que hace la composición de la figura para construir
  la figura grande.</p>
</li>
</ul>
<pre class="highlight"><code class="language-racket">(define (componer-sierpinski figura)
    (above figura
           (beside figura figura)))

(define (sierpinski ancho)
  (if (&lt; ancho 10)
      (sierpinski-elem ancho)
      (componer-sierpinski (sierpinski (/ ancho 2)))))</code></pre>
<h3>Otra figura recursiva: curvas de Hilbert</h3>
<p>La curva de Hilbert es una curva fractal que tiene la propiedad de
rellenar completamente el plano.</p>
<p><img src="imagenes/hilbert-scheme.png" width="300px"/></p>
<p>Su dibujo tiene una formulación recursiva:</p>
<p><img src="imagenes/hilbert.png" style="width:600px;"/></p>
<p>La curva H2 se puede construir a partir de la curva H1. El algoritmo
recursivo se formula dibujando la curva i-ésima a partir de la curva
i-1.</p>
<p>Función <code>componer-hilbert</code>:</p>
<pre class="highlight"><code class="language-racket">(define (trazo-horizontal long)
  (line long 0 "black"))

(define (trazo-vertical long)
  (rotate 90 (trazo-horizontal long)))

(define (componer-hilbert imagen long-trazo)
  (beside (above/align "left"
                       (beside/align "bottom" imagen (trazo-horizontal long-trazo))
                       (trazo-vertical long-trazo)
                       (rotate -90 imagen))
          (above/align "right"
                       imagen
                       (trazo-vertical long-trazo)
                       (rotate 90 imagen))))</code></pre>
<p><img src="imagenes/imagen-componer.png" width="500px"/></p>
<p>Función <code>hilbert</code>:</p>
<pre class="highlight"><code class="language-racket">(define (hilbert nivel long-trazo)
  (if (= 1 nivel)
      (beside/align "top"
                    (trazo-vertical long-trazo)
                    (trazo-horizontal long-trazo)
                    (trazo-vertical long-trazo))
      (componer-hilbert (hilbert (- nivel 1) long-trazo) long-trazo)))</code></pre>
<p><img src="imagenes/image-hilbert.png" width="600px"/></p></body>

</html>
