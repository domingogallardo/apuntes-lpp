<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
<style type="text/css">

/* Admonition */

.admonition {
    padding-left: 15px;
    padding-right: 15px;
    margin-bottom: 10px;
    border: 1px solid transparent;
    border-radius: 4px;
    text-align: left;
}

.admonition.note { /* csslint allow: adjoining-classes */
    color: black;
    background-color: #d9edf7;
    border-color: #bce8f1;
}

.admonition.quote { /* csslint allow: adjoining-classes */
    color: black;
    background-color: #cecece;
    border-color: #cccccc;
}

.admonition.warning { /* csslint allow: adjoining-classes */
    color: black;
    background-color: #FCC8BE;
    border-color: #FCC8BE;
}

.admonition.hint { /* csslint allow: adjoining-classes */
    color: black;
    background-color: #E9F9F6;
    border-color: #AFEEEE;
}

.admonition.danger { /* csslint allow: adjoining-classes */
    color: black;
    background-color: #F7B2A4;
    border-color: #F7B2A4;
}

.admonition-title {
    font-weight: bold;
    text-align: left;
}


/* Codehilite */

.hll { background-color: #ffffcc }
.c { color: #408080; font-style: italic } /* Comment */
.err { border: 1px solid #FF0000 } /* Error */
.k { color: #008000; font-weight: bold } /* Keyword */
.o { color: #666666 } /* Operator */
.ch { color: #408080; font-style: italic } /* Comment.Hashbang */
.cm { color: #408080; font-style: italic } /* Comment.Multiline */
.cp { color: #BC7A00 } /* Comment.Preproc */
.cpf { color: #408080; font-style: italic } /* Comment.PreprocFile */
.c1 { color: #408080; font-style: italic } /* Comment.Single */
.cs { color: #408080; font-style: italic } /* Comment.Special */
.gd { color: #A00000 } /* Generic.Deleted */
.ge { font-style: italic } /* Generic.Emph */
.gr { color: #FF0000 } /* Generic.Error */
.gh { color: #000080; font-weight: bold } /* Generic.Heading */
.gi { color: #00A000 } /* Generic.Inserted */
.go { color: #888888 } /* Generic.Output */
.gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.gs { font-weight: bold } /* Generic.Strong */
.gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.gt { color: #0044DD } /* Generic.Traceback */
.kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.kp { color: #008000 } /* Keyword.Pseudo */
.kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.kt { color: #B00040 } /* Keyword.Type */
.m { color: #666666 } /* Literal.Number */
.s { color: #BA2121 } /* Literal.String */
.na { color: #7D9029 } /* Name.Attribute */
.nb { color: #008000 } /* Name.Builtin */
.nc { color: #0000FF; font-weight: bold } /* Name.Class */
.no { color: #880000 } /* Name.Constant */
.nd { color: #AA22FF } /* Name.Decorator */
.ni { color: #999999; font-weight: bold } /* Name.Entity */
.ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.nf { color: #0000FF } /* Name.Function */
.nl { color: #A0A000 } /* Name.Label */
.nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.nt { color: #008000; font-weight: bold } /* Name.Tag */
.nv { color: #19177C } /* Name.Variable */
.ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.w { color: #bbbbbb } /* Text.Whitespace */
.mb { color: #666666 } /* Literal.Number.Bin */
.mf { color: #666666 } /* Literal.Number.Float */
.mh { color: #666666 } /* Literal.Number.Hex */
.mi { color: #666666 } /* Literal.Number.Integer */
.mo { color: #666666 } /* Literal.Number.Oct */
.sa { color: #BA2121 } /* Literal.String.Affix */
.sb { color: #BA2121 } /* Literal.String.Backtick */
.sc { color: #BA2121 } /* Literal.String.Char */
.dl { color: #BA2121 } /* Literal.String.Delimiter */
.sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.s2 { color: #BA2121 } /* Literal.String.Double */
.se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.sh { color: #BA2121 } /* Literal.String.Heredoc */
.si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.sx { color: #008000 } /* Literal.String.Other */
.sr { color: #BB6688 } /* Literal.String.Regex */
.s1 { color: #BA2121 } /* Literal.String.Single */
.ss { color: #19177C } /* Literal.String.Symbol */
.bp { color: #008000 } /* Name.Builtin.Pseudo */
.fm { color: #0000FF } /* Name.Function.Magic */
.vc { color: #19177C } /* Name.Variable.Class */
.vg { color: #19177C } /* Name.Variable.Global */
.vi { color: #19177C } /* Name.Variable.Instance */
.vm { color: #19177C } /* Name.Variable.Magic */
.il { color: #666666 } /* Literal.Number.Integer.Long */

/* Estilo LPP */

body {
  font-family: Helvetica, arial, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  background-color: white;
  padding: 60px;
}

pre {
  background-color: #f8f8f8;
  border: 1px solid #cccccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px;
}

table {
  padding: 0;border-collapse: collapse; }
  table tr {
    border-top: 1px solid #cccccc;
    background-color: white;
    margin: 0;
    padding: 0; }
    table tr:nth-child(2n) {
      background-color: #f8f8f8; }
    table tr th {
      font-weight: bold;
      border: 1px solid #cccccc;
      margin: 0;
      padding: 6px 13px; }
    table tr td {
      border: 1px solid #cccccc;
      margin: 0;
      padding: 6px 13px; }
    table tr th :first-child, table tr td :first-child {
      margin-top: 0; }
    table tr th :last-child, table tr td :last-child {
      margin-bottom: 0; }

</style>

</head>

<body>
<h2>Tema 6: Programación Funcional con Swift (semana 1)</h2>
<h3>Contenidos</h3>
<ul>
<li><strong>1. Introducción</strong></li>
<li><strong>2. Inmutabilidad</strong></li>
<li><strong>3. Funciones</strong></li>
<li><strong>4. Recursión</strong></li>
<li><strong>5. Tipos función</strong></li>
<li><strong>6. Tipos</strong></li>
<li><strong>7. Enumeraciones</strong></li>
<li><strong>8. Enumeraciones instanciables</strong></li>
<li>
<ol start="9">
<li>Opcionales</li>
</ol>
</li>
<li>
<ol start="10">
<li>Clausuras</li>
</ol>
</li>
<li>
<ol start="11">
<li>Funciones de orden superior</li>
</ol>
</li>
<li>
<ol start="12">
<li>Genéricos</li>
</ol>
</li>
</ul>
<hr />
<h3>Bibliografía</h3>
<ul>
<li><a href="https://github.com/domingogallardo/apuntes-lpp/blob/master/seminarios/seminario2-swift/seminario2-swift.md">Seminario de Swift</a></li>
<li>Swift Language Guide<ul>
<li><a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/TheBasics.html#//apple_ref/doc/uid/TP40014097-CH5-ID309">The Basics</a></li>
<li><a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/CollectionTypes.html#//apple_ref/doc/uid/TP40014097-CH8-ID105">Collection Types</a></li>
<li><a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Functions.html#//apple_ref/doc/uid/TP40014097-CH10-ID158">Functions</a></li>
<li><a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Closures.html#//apple_ref/doc/uid/TP40014097-CH11-ID94">Closures</a></li>
<li><a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Enumerations.html#//apple_ref/doc/uid/TP40014097-CH12-ID145">Enumerations</a></li>
</ul>
</li>
<li><a href="https://developer.apple.com/library/ios/documentation/General/Reference/SwiftStandardLibraryReference/">Biblioteca estándar de Swift</a></li>
</ul>
<hr />
<h3>1. Introducción</h3>
<hr />
<h3>Swift</h3>
<p>Swift es un lenguaje principalmente imperativo, pero en su diseño se
han introducido conceptos modernos de programación funcional,
extraídos de lenguajes como Rust o Haskell. </p>
<p>Como dice su creador <a href="http://nondot.org/sabre/">Chris Lattner</a>:</p>
<blockquote>
<p>El lenguaje Swift es el resultado de un esfuerzo incansable de un
equipo de expertos en lenguajes, gurús de documentación, ninjas de
optimización de compiladores [..]. Por supuesto, también se
benefició enormemente de las experiencias ganadas en muchos otros
lenguajes, tomando ideas de Objective-C, Rust, Haskell, Ruby,
Python, C#, CLU, y demasiados otros para ser enumerados.</p>
</blockquote>
<p>Vamos a repasar en este tema cómo se implementan en Swift conceptos
principalmente funcionales como:</p>
<ul>
<li>Valores inmutables</li>
<li>Tipos de datos recursivos</li>
<li>Funciones como objetos de primera clase y clasuras</li>
<li>Funciones de orden superior</li>
</ul>
<hr />
<h3>Ejecución de programas Swift</h3>
<ul>
<li>Consultar en el seminario de Swift la forma de instalar el
  compilador de Swift: usar WSL en Windows, usando la terminal (Mac) o en Linux.</li>
</ul>
<!--
Visual Code Studio con un terminal y con el comando docker para
ejecutar Swift:

<img src="imagenes/vcode.png" width="700px"/>
-->

<hr />
<h3>Swift es fuertemente tipado</h3>
<ul>
<li>Swift es un lenguaje fuertemente tipado</li>
</ul>
<pre class="highlight"><code class="language-swift">let n: Int = 10
let str: String = "Hola"
let array: [Int] = [1,2,3,4,5]</code></pre>
<ul>
<li>Es posible no escribir el nombre del tipo en aquellos casos en los
  que el compilador pueda <strong>inferirlo</strong>.</li>
</ul>
<pre class="highlight"><code class="language-swift">let n = 10
let str = "Hola"
let array = [1,2,3,4,5]</code></pre>
<h3>Swift es multi-paradigma</h3>
<ul>
<li>Swift incorpora características funcionales, de programación
  imperativa y de programación orientada a objetos.</li>
</ul>
<hr />
<h3>2. Inmutabilidad</h3>
<hr />
<p>Una de las características funcionales importantes de Swift es el
énfasis en la inmutabilidad para reforzar la seguridad del
lenguaje. Veamos algunas características relacionadas con esto.</p>
<hr />
<h3>Palabra clave let</h3>
<ul>
<li>La palabra clave <code>let</code> permite definir variables inmutables. Si se intenta
  modificar el valor el compilador da un error.</li>
</ul>
<pre class="highlight"><code class="language-swift">var x = 10
x = 20 // x es mutable
let y = 10
y = 20 // error: y es inmutable</code></pre>
<ul>
<li>El valor asignado puede no conocerse en tiempo de compilación:</li>
</ul>
<pre class="highlight"><code class="language-swift">let respuesta: String = respuestaUsuario.respuesta()</code></pre>
<ul>
<li>Si una variable no se modifica es conveniente declararla como
  <code>let</code>. El compilador de Swift da una aviso para ello.</li>
</ul>
<pre class="highlight"><code class="language-swift">func saluda(nombre: String) -&gt; String {
    var saludo = "Hola " + nombre + "!"
    return saludo
}
//warning: variable 'saludo' was never mutated; consider changing to 'let' constant
//    var saludo = "Hola " + nombre
//    ~~~ ^
//    let</code></pre>
<hr />
<h3>Creación de nuevas estructuras y mutación</h3>
<ul>
<li>
<p>En la <a href="https://developer.apple.com/documentation/swift/swift_standard_library">biblioteca estándar de
Swift</a>
existen una gran cantidad de estructuras (como <code>Int</code>, <code>Double</code>,
<code>Bool</code>, <code>String</code>, <code>Array</code>, <code>Dictionary</code>, etc.) que tienen dos tipos de
métodos: métodos que mutan la estructura y métodos que devuelven una
nueva estructura. </p>
</li>
<li>
<p>Por ejemplo, en el struct <code>Array</code> se define el método <code>sort</code> y el
método <code>sorted</code>. El primero ordena el array con mutación y el segundo
devuelve una copia ordenada, sin modificar el array original. </p>
</li>
</ul>
<pre class="highlight"><code class="language-swift">// Código recomendable en programación funcional
// porque utiliza el método sorted que devuelve una
// copia del array original
let miArray = [10, -1, 3, 80]
let arrayOrdenado = miArray.sorted()
print(miArray)
print(arrayOrdenado)
// Imprime:
// [10, -1, 3, 80]
// [-1, 3, 10, 80]</code></pre>
<ul>
<li>Sin embargo, el siguiente código es imperativo y utiliza la mutación
  del array original: </li>
</ul>
<pre class="highlight"><code class="language-swift">// Código no recomendable en programación funcional
// porque utiliza el método sort que muta el array original
var miArray = [10, -1, 3, 80]
miArray.sort()
print(miArray)
// Imprime:
// [-1, 3, 10, 80]</code></pre>
<ul>
<li>Otro ejemplo es en la forma de añadir elementos a un array. Podemos
hacerlo con un enfoque funcional, usando el operador <code>+</code> que construye
un array nuevo:</li>
</ul>
<pre class="highlight"><code class="language-swift">// Código recomendable en programación funcional
let miArray = [10, -1, 3, 80]
let array2 = miArray + [100]
print(array2)
// Imprime:
// [10, -1, 3, 80, 100]</code></pre>
<ul>
<li>Y podemos hacerlo usando un enfoque imperativo, con el método
<code>append</code>:</li>
</ul>
<pre class="highlight"><code class="language-swift">// Código no recomendable en programación funcional
var miArray = [10, -1, 3, 80]
miArray.append(100)
print(miArray)
// Imprime:
// [10, -1, 3, 80, 100]</code></pre>
<div class="admonition note">
<p class="admonition-title">Importante</p>
<p>Cuando estemos escribiendo código con estilo
funcional deberemos utilizar los métodos que no modifican las
estructuras. Así evitaremos los efectos laterales y nuestro código
funcionará correctamente en entornos multi-hilo.</p>
</div>
<hr />
<h3>3. Funciones</h3>
<hr />
<h3>Definición de una función en Swift</h3>
<ul>
<li>Para definir una función en Swift se debe usar la palabra <code>func</code>,
definir el nombre de la función, sus parámetros y el tipo de vuelto.</li>
<li>El valor devuelto por la función se debe devolver usando la palabra
<code>return</code>.</li>
</ul>
<p>Ejemplo función <code>saluda(nombre:)</code>:</p>
<pre class="highlight"><code class="language-swift">func saluda(nombre: String) -&gt; String {
    let saludo = "Hola, " + nombre + "!"
    return saludo
}</code></pre>
<p>Invocación a la función <code>saluda(nombre:)</code>:</p>
<pre class="highlight"><code class="language-swift">print(saluda(nombre:"Ana"))
print(saluda(nombre:"Pedro"))
// Imprime "Hola, Ana!"
// Imprime "Hola, Pedro!"</code></pre>
<hr />
<h3>Etiquetas de argumentos y nombres de parámetros</h3>
<ul>
<li>Cada parámetro de una función tiene una <strong>etiqueta del argumento</strong> y
un <strong>nombre de parámetro</strong>.</li>
<li>Por defecto, los parámetros usan su nombre de parámetro como etiqueta
del argumento</li>
</ul>
<pre class="highlight"><code class="language-swift">func unaFuncion(primerNombreParametro: Int, segundoNombreParametro: Int) {
    // En el cuerpo de la función, primerNombreParametro y
    // segundoNombreParametro se refieren a los valores de los
    // argumentos del primer y el segundo parámetro
}
unaFuncion(primerNombreParametro: 1, segundoNombreParametro: 2)</code></pre>
<ul>
<li>Es posible hacer distintos la etiqueta del argumento del nombre del
parámetro:</li>
</ul>
<pre class="highlight"><code class="language-swift">func saluda(nombre: String, de ciudad: String) -&gt; String {
    return "Hola \(nombre)! Me alegro de que hayas podido visitarnos desde \(ciudad)."
}
print(saluda(nombre: "Bill", de: "Cupertino"))
// Imprime "Hola Bill! Me alegro de que hayas podido visitarnos desde Cupertino."</code></pre>
<ul>
<li>Otro ejemplo, la siguiente función <code>concatena(palabra:con:)</code>: </li>
</ul>
<pre class="highlight"><code class="language-swift">func concatena(palabra str1: String, con str2: String) -&gt; String {
    return str1+str2
}

print(concatena(palabra:"Hola", con:"adios"))</code></pre>
<ul>
<li>Si no se quiere una etiqueta del argumento para un parámetro, se puede
escribir un subrayado (<code>_</code>) en lugar de una etiqueta del argumento
explícita para ese parámetro:</li>
</ul>
<pre class="highlight"><code class="language-swift">func max(_ x:Int, _ y: Int) -&gt; Int {
   if x &gt; y {
      return x
   } else {
      return y
   }
}

print(max(10,3))

func divide(_ x:Double, entre y: Double) -&gt; Double {
   return x / y
}

print(divide(30, entre:4))</code></pre>
<ul>
<li>
<p>El perfil de una función (el nombre técnico es "function signature"
en inglés) está formada por el nombre de la función, las etiquetas de
los argumentos y sus tipos y el tipo devuelto por la función. Este
perfil permite al compilador y al programador identificar y diferenciar
funciones con el mismo nombre pero con diferentes listas de parámetros
o tipos de retorno.</p>
</li>
<li>
<p>En la documentación de las funciones en Swift se suele usar para
nombrarlas su nombre completo: el nombre de la propia función más el
nombre de los parámetros. Por ejemplo, las funciones anteriores se
nombran como <code>max(_:_:)</code> y <code>divide(_:entre:)</code>.</p>
</li>
<li>
<p>Los nombres de los parámetros son parte del nombre completo de la
función. Es posible definir funciones distintas con sólo distintos
nombres de parámetros, como las siguientes funciones <code>mitad(par:)</code> y
<code>mitad(impar:)</code>:</p>
</li>
</ul>
<pre class="highlight"><code class="language-swift">func mitad(par: Int) -&gt; Int{
    return par/2
}

func mitad(impar: Int) -&gt; Int{
    return (impar+1)/2
}

print(mitad(par: 8))
// Imprime 4
print(mitad(impar: 9))
// Imprime 5</code></pre>
<hr />
<h3>Parámetros y valores devueltos</h3>
<ul>
<li>Es posible definir funciones sin parámetros:</li>
</ul>
<pre class="highlight"><code class="language-swift">func diHolaMundo() -&gt; String {
    return "hola, mundo"
}
print(diHolaMundo())
// Imprime "hola, mundo"</code></pre>
<ul>
<li>Podemos definir funciones sin valor devuelto. Por ejemplo, la
  siguiente función <code>diAdios(nombre:)</code>. No hay que escribir flecha con
  el tipo devuelto. Cuidado, no sería propiamente programación
  funcional.</li>
</ul>
<pre class="highlight"><code class="language-swift">func diAdios(nombre: String) {
    print("Adiós, \(nombre)!")
}
diAdios(nombre:"Dave")
// Imprime "Adiós, Dave!"</code></pre>
<ul>
<li>Es posible devolver múltiples valores, construyendo una tupla. Por
ejemplo, la siguiente función <code>ecuacion(a:b:c:)</code> calcula las dos
soluciones de una ecuación de segundo grado:</li>
</ul>
<pre class="highlight"><code class="language-swift">func ecuacion(a: Double, b: Double, c: Double) -&gt; (pos: Double, neg: Double) {
    let discriminante = b*b-4*a*c
    let raizPositiva = (-b + discriminante.squareRoot()) / 2*a
    let raizNegativa = (-b - discriminante.squareRoot()) / 2*a
    return (raizPositiva, raizNegativa)
}</code></pre>
<ul>
<li>Recordemos (consultar el seminario de Swift) que podemos acceder a los
valores de la tupla por posición:</li>
</ul>
<pre class="highlight"><code class="language-swift">let resultado = ecuacion(a: 1, b: -5, c: 6)
print("Las raíces de la ecuación son \(resultado.0) y \(resultado.1)")
//Imprime "Las raíces de la ecuación son 3.0 y 2.0"</code></pre>
<ul>
<li>En este caso en la definición del tipo devuelto por la función estamos
etiquetando esos valores con las etiquetas <code>pos</code> y <code>neg</code>. De esta
forma podemos acceder a los componentes de la tupla usando esas
etiquetas definidas:</li>
</ul>
<pre class="highlight"><code class="language-swift">let resultado = ecuacion(a: 1, b: -5, c: 6)
print("Las raíces de la ecuación son \(resultado.pos) y \(resultado.neg)")
//Imprime "Las raíces de la ecuación son 3.0 y 2.0"</code></pre>
<hr />
<h3>4. Recursión</h3>
<hr />
<h3>Ejemplos de funciones recursivas en Swift</h3>
<ul>
<li>Recursión pura:</li>
</ul>
<pre class="highlight"><code class="language-swift">func suma(hasta x: Int) -&gt; Int {
  if x == 0 {
    return 0
  } else {
    return x + suma(hasta: x - 1)
  }
}

print(suma(hasta: 5))</code></pre>
<hr />
<h3>Funciones recursivas sobre Arrays</h3>
<ul>
<li>Los arrays en Swift no funcionan exactamente como las listas de
Scheme (no son listas de parejas), pero podríamos obtener el primer
elemento y el resto de la siguiente forma.</li>
</ul>
<pre class="highlight"><code class="language-swift">let a = [10, 20, 30, 40, 50, 60]
let primero = a[0]
let resto = Array(a.dropFirst())</code></pre>
<ul>
<li>
<p>En <code>primero</code> se guarda el número 10. En <code>resto</code> se guarda el <code>Array</code>
del 20 al 60.</p>
</li>
<li>
<p>El método <code>dropFirst</code> devuelve una <code>ArraySlice</code>, que es
una vista de un rango de elementos del array, en este caso el que va
desde la posición 1 hasta la 5 (la posición inicial de un array es la
0). Es necesario el constructor <code>Array</code> para convertir ese
<code>ArraySlice</code> en un <code>Array</code>.</p>
</li>
<li>
<p>Usando las instrucciones anteriores podemos definir la función
recursiva que suma los valores de un Array de la siguiente forma
similar a cómo lo hacíamos en Scheme:</p>
</li>
</ul>
<pre class="highlight"><code class="language-swift">func sumaValores(_ valores: [Int]) -&gt; Int {
    if (valores.isEmpty) {
        return 0
    } else {
        let primero = valores[0]
        let resto = Array(valores.dropFirst())
        return primero + sumaValores(resto)
    }
}

print(sumaValores([1,2,3,4,5,6,7,8])) 
// Imprime "36"</code></pre>
<ul>
<li>Un último ejemplo es la siguiente función <code>minMax(array:)</code> que
devuelve el número más pequeño y más grande de un array de enteros:</li>
</ul>
<pre class="highlight"><code class="language-swift">func minMax(array: [Int]) -&gt; (min: Int, max: Int) {
    if (array.count == 1) {
        return (array[0], array[0])
    } else {
        let primero = array[0]
        let resto = Array(array.dropFirst())

        // Llamada recursiva que devuelve el mínimo y el máximo del
        // resto del array
        let minMaxResto = minMax(array: resto)

        let minimo = min(primero, minMaxResto.min)
        let maximo = max(primero, minMaxResto.max)
        return (minimo, maximo)
    }
}

let limites = minMax(array: [8, -6, 2, 100, 3, 71])
print("El mínimo es \(limites.min) y el máximo es \(limites.max)")
// Imprime "El mímimo es -6 y el máximo es 100"</code></pre>
<ul>
<li>En este ejemplo nos apartamos un poco de la solución vista en Scheme
porque permitimos pasos de ejecución que inicializan variables. Pero
no nos salimos del paradigma funcional, porque todas son variables
inmutables definidas con <code>let</code>.</li>
</ul>
<hr />
<h3>5. Tipos función</h3>
<hr />
<h3>Funciones como objetos de primera clase</h3>
<ul>
<li>
<p>En Swift las funciones son objetos de primera clase y podemos
  asignarlas a variables, pasarlas como parámetro o devolverlas como
  resultado de otra función.</p>
</li>
<li>
<p>Cada función tiene un tipo específico, definido por el tipo de sus
parámetros y el tipo del valor devuelto.</p>
</li>
</ul>
<pre class="highlight"><code class="language-swift">func sumaDosInts(a: Int, b: Int) -&gt; Int {
    return a + b
}
func multiplicaDosInts(a: Int, b: Int) -&gt; Int {
    return a * b
}</code></pre>
<ul>
<li>
<p>El tipo de estas funciones es <code>(Int, Int) -&gt; Int</code></p>
</li>
<li>
<p>En Swift se puede usar un tipo función de la misma forma que
  cualquier otro tipo:</p>
</li>
</ul>
<p><pre class="highlight"><code class="language-swift">var f = sumaDosInts
print(f(2,3))
// Imprime "5"
f = multiplicaDosInts
print(f(2,3))
// Imprime "6"</code></pre>
- La variable <code>f</code> es una variable de tipo <code>(Int, Int) -&gt; Int</code>, o sea,
una variable que contiene funciones de dos argumentos <code>Int</code> que
devuelven un <code>Int</code>.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Habrás notado que al invocar a <code>f</code> no se ponen etiquetas en los
argumentos. De hecho, si las pusiéramos el compilador de Swift se
quejaría:</p>
<pre class="highlight"><code class="language-swift">print(f(a:2, b:3))
//error: extraneous argument labels 'a:b:' in call</code></pre>
<p>Esto es debido a que al ser <code>f</code> una variable se le puede asignar
cualquier función que tenga el tipo <code>(Int, Int) -&gt; Int</code> sin
tener en cuenta las etiquetas de los argumentos.</p>
</div>
<hr />
<h3>Funciones que reciben otras funciones</h3>
<ul>
<li>Podemos usar un tipo función en parámetros de otras funciones:</li>
</ul>
<pre class="highlight"><code class="language-swift">func printResultado(funcion: (Int, Int) -&gt; Int, _ a: Int, _ b: Int) {
    print("Resultado: \(funcion(a, b))")
}
printResultado(funcion: sumaDosInts, 3, 5)
// Prints "Resultado: 8"</code></pre>
<ul>
<li>Veamos otro ejemplo, que ya vimos en Scheme. Supongamos que queremos
  calcular el sumatorio desde <code>a</code> hasta <code>b</code> en el que aplicamos una
  función <code>f</code> a cada número que sumamos:</li>
</ul>
<pre class="highlight"><code class="language-text">sumatorio(a, b, f) = f(a) + f(a+1) + f(a+2) + ... + f(b)</code></pre>
<ul>
<li>Recordamos que se resuelve con la siguiente recursión:</li>
</ul>
<pre class="highlight"><code class="language-text">sumatorio(a, b, f) = f(a) + sumatorio(a+1, b, f)
sumatorio(a, b, f) = 0 si a &gt; b</code></pre>
<ul>
<li>Implementación en Swift: </li>
</ul>
<pre class="highlight"><code class="language-swift">func sumatorio(desde a: Int, hasta b: Int, func f: (Int) -&gt; Int) -&gt; Int {
   if a &gt; b { 
      return 0 
   } else {
      return f(a) + sumatorio(desde: a + 1, hasta: b, func: f)
   }
}

func identidad(_ x: Int) -&gt; Int {
   return x
}

func doble(_ x: Int) -&gt; Int {
   return x + x
}

func cuadrado(_ x: Int) -&gt; Int {
    return x * x
}

print(sumatorio(desde: 0, hasta: 10, func: identidad)) // Imprime 55
print(sumatorio(desde: 0, hasta: 10, func: doble)) // Imprime 110
print(sumatorio(desde: 0, hasta: 10, func: cuadrado)) // Imprime 385</code></pre>
<hr />
<h3>Funciones en estructuras de datos</h3>
<ul>
<li>Las funciones pueden también incluirse en estructuras de datos
  compuestas, como arrays:</li>
</ul>
<pre class="highlight"><code class="language-swift">let funciones = [identidad, doble, cuadrado]
print(funciones[0](10)) // 10
print(funciones[1](10)) // 20 
print(funciones[2](10)) // 100</code></pre>
<ul>
<li>
<p>El tipo de la variable <code>funciones</code> sería <code>[(Int) -&gt; Int]</code>. </p>
</li>
<li>
<p>Al ser Swift fuertemente tipado, no podríamos hacer un array con
distintos tipos de funciones. Por ejemplo el siguiente código daría un
error:</p>
</li>
</ul>
<pre class="highlight"><code class="language-swift">func suma(_ x: Int, _ y: Int) -&gt; Int {
   return x + y
}
// La siguiente línea genera un error
let misFunciones = [doble, cuadrado, suma]
// error: heterogenous collection literal could only be inferred to
// '[Any]'; add explicit type annotation if this is intentional
</code></pre>
<hr />
<h3>Funciones que devuelven otras funciones</h3>
<ul>
<li>
<p>Por último, veamos un ejemplo de funciones que devuelven otras
  funciones.</p>
</li>
<li>
<p>Empecemos por un ejemplo sencillo de una función que devuelve otra
que suma 10:</p>
</li>
</ul>
<pre class="highlight"><code class="language-swift">func construyeSumador10() -&gt; (Int) -&gt; Int {
  func suma10(x: Int) -&gt; Int {return x+10}
  return suma10
}

let g = construyeSumador10()
print(g(20))
// Imprime 30</code></pre>
<ul>
<li>
<p>La función devuelta por <code>construyeSumador10()</code> es una función con el tipo
<code>(Int) -&gt; Int</code> (recibe un parámetro entero y devuelve un entero). </p>
</li>
<li>
<p>Estas funciones devueltas se denominan <strong>clausuras</strong>. Más adelante
hablaremos algo más de ellas. Veremos también más adelante que es
posible usar <strong>expresiones de clausura</strong> que construyen clausuras
anónimas.</p>
</li>
<li>
<p>Podemos modificar el ejemplo anterior, haciendo que la función
<code>construyeSumador</code> reciba el número a sumar como parámetro:</p>
</li>
</ul>
<pre class="highlight"><code class="language-swift">func construyeSumador(inc: Int) -&gt; (Int) -&gt; Int {
  func suma(x: Int) -&gt; Int {return x+inc}
  return suma
}

let f2 = construyeSumador(inc: 10)
let f3 = construyeSumador(inc: 100)
print(f2(20))
// Imprime "30"
print(f3(20))
// Imprime "120"</code></pre>
<hr />
<h3>6. Tipos</h3>
<hr />
<h3>Swift es fuertemente tipado</h3>
<ul>
<li>
<p>Swift es un lenguaje fuertemente tipado, a diferencia de
  Scheme. </p>
</li>
<li>
<p>Entre las ventajas del uso de tipos está la detección de errores en
  los programas en tiempo de compilación o las ayudas del entorno de
  desarrollo para autocompletar código. </p>
</li>
<li>
<p>Entre los inconvenientes se encuentra la necesidad de ser más
  estrictos a la hora de definir los parámetros y los valores
  devueltos por las funciones, lo que impide la flexibilidad de
  Scheme.</p>
</li>
<li>
<p>Se utilizan tipos para definir los posibles valores de:</p>
<ul>
<li>variables</li>
<li>parámetros de funciones</li>
<li>valores devueltos por funciones</li>
</ul>
</li>
<li>
<p>Las definiciones de tipos van precedidas de dos puntos en las
  variables y parámetros, o de una flecha (<code>-&gt;</code>) en la definición de
  los tipos de los valores devueltos por una función:</p>
</li>
</ul>
<pre class="highlight"><code class="language-swift">let valorDouble : Double = 3.0
let unaCadena: String = "Hola"

func calculaEstadisticas(valores: Array&lt;Int&gt;) -&gt; (min: Int, max: Int, media: Int) {
   ...
}</code></pre>
<ul>
<li>En Swift existen dos clases de tipos: <strong>tipos con nombre</strong> y <strong>tipos
  compuestos</strong>.</li>
</ul>
<hr />
<h3>Tipos con nombre</h3>
<ul>
<li>
<p>Un tipo con nombre es un tipo al que se le puede dar un nombre
  determinado cuando se define:</p>
<ul>
<li>nombres de clases</li>
<li>nombres de estructuras</li>
<li>nombres de enumeraciones</li>
<li>nombres de protocolos </li>
</ul>
</li>
<li>
<p>Por ejemplo, instancias de una clase definida por el usuario llamada
<code>MiClase</code> tienen el tipo <code>MiClase</code>. </p>
</li>
<li>
<p>Además de los tipos definidos por el usuario, la biblioteca estándar
de Swift tiene un gran número de tipos predefinidos. A diferencia de
otros lenguajes, estos tipos no son parte del propio lenguaje sino que
se definen en su mayoría como estructuras implementadas en esta
biblioteca estándar. Por ejemplo, arrays, diccionarios o incluso los
tipos más básicos como <code>String</code> o <code>Int</code> están construidos en esa
biblioteca. La implementación de estos elementos está disponible en
abierto en el <a href="https://github.com/apple/swift/tree/master/stdlib/public/core">sitio GitHub de
Swift</a>. </p>
</li>
</ul>
<hr />
<h3>Tipos compuestos</h3>
<ul>
<li>Los tipos compuestos son tipos sin nombre. </li>
<li>En Swift se definen dos: <strong>tuplas</strong> y <strong>tipos función</strong> (ya los
  hemos visto). </li>
</ul>
<p>Ejemplo tuplas:</p>
<pre class="highlight"><code class="language-swift">
let tupla: (Int, Int, String) = (2, 3, "Hola")
let otraTupla: (Int, Int, String) = (5, 8, "Adios")

func sumaTupla(tupla t1: (Int, Int), con t2: (Int, Int)) -&gt; (Int, Int) {
  return (t1.0 + t2.0, t1.1 + t2.1)
}

print(sumaTupla(tupla: (tupla.0, tupla.1),
                con: (otraTupla.0, otraTupla.1)))

// Imprime (7, 11)</code></pre>
<hr />
<h3>Typealias</h3>
<ul>
<li>En Swift se define la palabra clave <code>typealias</code> para darle un nombre
  asignado a cualquier otro tipo. Ambos tipos son iguales a todos los
  efectos (es únicamente azúcar sintáctico).</li>
</ul>
<pre class="highlight"><code class="language-swift">typealias Resultado = (Int, Int)

enum Quiniela {
    case uno, equis, dos
}

func quiniela(resultado: Resultado) -&gt; Quiniela {
  switch resultado {
    case let (goles1, goles2) where goles1 &lt; goles2:
      return .dos
    case let (goles1, goles2) where goles1 &gt; goles2:
      return .uno
    default:
      return .equis
  }
}

print(quiniela(resultado: (1,3)))
// Imprime Dos
print(quiniela(resultado: (2,2)))
// Imprime Equis</code></pre>
<ul>
<li>En el ejemplo se usa una sentencia <code>switch</code> que recibe el resultado
del partido. Este resultado es una tupla de dos enteros. En el <code>case
let</code> se instancia los valores de esa tupla en las variables <code>goles1</code> y
<code>goles2</code> y después se define una condición para entrar en el caso. En
el primer caso, que <code>goles1</code> sea menor que <code>goles2</code> y en el segundo
que <code>goles1</code> sea mayor que <code>goles2</code>.</li>
</ul>
<h3>Tipos valor y tipos referencia</h3>
<ul>
<li>
<p>En Swift existen dos tipos de construcciones que forman la base de la
programación orientada a objetos: las estructuras (<em>structs</em>) y las
clases. En el tema siguiente hablaremos sobre ello.</p>
</li>
<li>
<p>En la <a href="https://developer.apple.com/documentation/swift/swift_standard_library">biblioteca estándar de
Swift</a>
la mayor parte de los tipos definidos (como <code>Int</code>, <code>Double</code>, <code>Bool</code>,
<code>String</code>, <code>Array</code>, <code>Dictionary</code>, etc.) son estructuras, no clases.</p>
</li>
<li>
<p>Una de las diferencias más importantes entre estructuras y clases es
su comportamiento en una asignación: las estructuras tienen una
<strong>semántica de copia</strong> (son tipos valor) y las clases tienen una
<strong>semántica de referencia</strong> (son tipos referencia).</p>
</li>
</ul>
<h4>Tipo valor</h4>
<ul>
<li>
<p>Un <em>tipo valor</em> es un tipo que tiene semántica de copia en las
asignaciones y cuando se pasan como parámetro en llamadas a funciones.</p>
</li>
<li>
<p>Los tipos valor son muy útiles porque evitan los efectos laterales
en los programas y simplifican el comportamiento del compilador en la
gestión de memoria. </p>
</li>
<li>
<p>Veamos ahora algunos ejemplos de copia por valor en estructuras. Por
  ejemplo, si asignamos una cadena a otra, se realiza una copia:</p>
</li>
</ul>
<pre class="highlight"><code class="language-swift">var str1 = "Hola"
var str2 = str1
str1.append("Adios")
print(str1) // Imprime "HolaAdios"
print(str2) // Imprime "Hola"</code></pre>
<ul>
<li>Los arrays también son estructuras y, por tanto, también tienen
  semántica de copia:</li>
</ul>
<pre class="highlight"><code class="language-swift">var array1 = [1, 2, 3, 4]
var array2 = array1
array1[0] = 10
print(array1) // [10, 2, 3, 4]
print(array2) // [1, 2, 3, 4]</code></pre>
<ul>
<li>A diferencia de otros lenguajes como Java, los parámetros de una
función siempre son inmutables y se pasan por copia, para reforzar el
carácter funcional de las funciones. Por ejemplo, es incorrecto
escribir lo siguiente:</li>
</ul>
<pre class="highlight"><code>func ponCero(array: [Int], pos: Int) {
    array[pos] = 0
// error: cannot assign through subscript: 'array' is a 'let' constant
}</code></pre>
<ul>
<li>Se podría pensar que es muy costoso copiar un array entero, pero no
es así. El compilador de Swift optimiza estas sentencias y sólo
realiza la copia en el momento en que hay una modificación de una de
las variables que comparten el array. Es lo que se llama <em>copy on
write</em>.</li>
</ul>
<h4>Tipo referencia</h4>
<ul>
<li>
<p>Frente a un tipo valor, un tipo de referencia es aquel en los que
los valores se asignan a variables con una semántica de
referencia. </p>
</li>
<li>
<p>Cuando se realizan varias asignaciones de una misma
instancia a distintas variables todas ellas guardan una referencia a
la misma instancia. Si la instancia se modifica, todas las variables
reflejarán el nuevo valor. </p>
</li>
<li>
<p>Cuando veamos las clases en el próximo tema veremos algunos
ejemplos.</p>
</li>
</ul>
<hr />
<h3>7. Enumeraciones</h3>
<hr />
<ul>
<li>Las enumeraciones definen un tipo con un valor restringido de
  posibles valores:</li>
</ul>
<pre class="highlight"><code class="language-swift">enum Direccion {
    case norte
    case sur
    case este
    case oeste
}</code></pre>
<p>Ejemplo de uso:</p>
<pre class="highlight"><code class="language-swift">let hemosGirado = true
var direccionActual = Direccion.norte
if hemosGirado {
   direccionActual = .sur
}</code></pre>
<p>En sentencias switch:</p>
<pre class="highlight"><code class="language-swift">let direccionAIr = Direccion.sur
switch direccionAIr {
case .norte:
   print("Nos vamos al norte")
case .sur:
   print("Cuidado con los pinguinos")
case .este:
    print("Donde nace el sol")
case .oeste:
    print("Donde el cielo es azul")
}
// Imprime "Cuidado con los pinguinos"</code></pre>
<h3>Valores brutos de enumeraciones</h3>
<ul>
<li>Es posible asignar a las constantes del enumerado un valor concreto de
un tipo subyacente, por ejemplo enteros:</li>
</ul>
<pre class="highlight"><code class="language-swift">enum Quiniela: Int {
    case uno=1, equis=0, dos=2
}</code></pre>
<ul>
<li>Se puede obtener el valor bruto a partir del propio tipo o de una
variable del tipo, usando <code>rawValue</code>:</li>
</ul>
<pre class="highlight"><code class="language-swift">// Obtenemos el valor bruto a partir del tipo
let valorEquis: Int = Quiniela.equis.rawValue

// Obtenemos el valor bruto a partir de una variable
let res = Quiniela.equis
let valorEquis = res.rawValue</code></pre>
<ul>
<li>También se puede asignar los valores de forma implícita, dando un
valor a la primera constante. Las siguientes tienen el valor consecutivo:</li>
</ul>
<pre class="highlight"><code class="language-swift">enum Planeta: Int {
    case mercurio=1, venus, tierra, marte, jupiter, saturno, urano, neptuno
}
let posicionTierra = Planeta.tierra.rawValue
// posicionTierra es 3</code></pre>
<ul>
<li>Podemos escoger cualquier tipo subyacente. Por ejemplo el tipo <code>Character</code>:</li>
</ul>
<pre class="highlight"><code class="language-swift">enum CaracterControlASCII: Character {
    case tab = "\t"
    case lineFeed = "\n"
    case carriageReturn = "\r"
}</code></pre>
<ul>
<li>Y por último, se puede definir como tipo subyacente <code>String</code> y los
valores brutos de las constantes serán sus nombres convertidos a
cadenas:</li>
</ul>
<pre class="highlight"><code class="language-swift">enum Direccion: String {
    case norte, sur, este, oeste
}
let direccionAtardecer = Direccion.oeste.rawValue
// direccionAtardecer es "oeste"</code></pre>
<ul>
<li>En este caso, también se puede inicializar el valor bruto con una
  asignación explícita y no usar el propio nombre:</li>
</ul>
<pre class="highlight"><code class="language-swift">enum Direccion: String {
    case norte = "north"
    case sur = "south"
    case este = "east"
    case oeste = "west"
}
let direccionAtardecer = Direccion.oeste.rawValue
// direccionAtardecer es "west"</code></pre>
<ul>
<li>Cuando se definen valores brutos es posible inicializar el enumerado
de una forma similar a una estructura o una clase pasando el valor
bruto. Devuelve el valor enumerado correspondiente o <code>nil</code> (un
opcional, lo veremos más adelante):</li>
</ul>
<pre class="highlight"><code class="language-swift">let posiblePlaneta = Planeta(rawValue: 7)
// posiblePlaneta es de tipo Planeta? y es igual a Planeta.urano</code></pre>
<hr />
<h2>8. Enumeraciones instanciables</h2>
<ul>
<li>Una característica singular de las enumeraciones en Swift es que
permiten definir valores variables asociados a cada caso de la
enumeración, creando algo muy parecido a una instancia de la
enumeración.</li>
</ul>
<h3>Valores asociados a instancias de enumeraciones</h3>
<ul>
<li>
<p>Un enumerado instanciable permite asociar valores a
  la instancia del enumerado. Para crear una instancia del
  enumerado debemos proporcionar el valor asociado.</p>
</li>
<li>
<p>Al igual que un enumerado normal, el enumerado puede especificar
  distintos casos. Cada caso puede determinar un tipo de valor asociado.</p>
</li>
<li>
<p>En otros lenguajes de programación se llaman <em>uniones etiquetadas</em> o
<em>variantes</em>.</p>
</li>
<li>
<p>Por ejemplo, podemos definir un enumerado que permita guardar un
<code>Int</code> o un <code>String</code>:</p>
</li>
</ul>
<pre class="highlight"><code class="language-swift">enum Multiple {
    case num(Int)
    case str(String)
}</code></pre>
<ul>
<li>De esta forma, podemos crear valores de tipo <code>Multiple</code> que
contienen un valor asociado <code>Int</code> (instanciando el caso <code>num</code>) o un
<code>String</code> (instanciando el caso <code>str</code>):</li>
</ul>
<pre class="highlight"><code class="language-swift">let valor3 = Multiple.num(10)
let valor4 = Multiple.str("Hola")</code></pre>
<ul>
<li>
<p>Es necesario definir un valor concreto asociado al crear el enumerado.</p>
</li>
<li>
<p>Para obtener el valor asociado debemos usar una expresión <code>case let</code>
en una sentencia <code>switch</code> con una variable a la que se asigna el
valor. Por ejemplo, la siguiente función reciba instancias de tipo
<code>Multiple</code> e imprime el valor asociado al enumerado que se pasa como parámetro.</p>
</li>
</ul>
<pre class="highlight"><code class="language-swift">func imprime(multiple: Multiple) {
    switch multiple {
    case let .num(x):
        print("Multiple tiene un Int: \(x)")
    case let .str(s):
        print("Multiple tiene un String: \(s)")
    }
}
imprime(multiple: valor3)
// Imprime "Multiple tiene un Int: 10"
imprime(multiple: valor4)
// Imprime "Multiple tiene un String: Hola</code></pre>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>No hay que confundir un valor asociado a un caso y un valor bruto:
el valor bruto de un caso de enumeración es el mismo para todas las
instancias, mientras que el valor asociado es distinto y se
proporciona cuando se define el valor concreto de la enumeración.</p>
</div>
<ul>
<li>El valor asociado puede ser una tupla:</li>
</ul>
<pre class="highlight"><code class="language-swift">enum CodigoBarras {
    case upc(Int, Int, Int, Int)
    case qrCode(String)
}</code></pre>
<hr />
<h3>Enumeraciones recursivas</h3>
<ul>
<li>Es posible combinar las características de las enumeraciones con
valor con la recursión para crear enumeraciones recursivas. Hay que
preceder la palabra clave <code>enum</code> con <code>indirect</code>:</li>
</ul>
<pre class="highlight"><code class="language-swift">indirect enum ExpresionAritmetica {
    case numero(Int)
    case suma(ExpresionAritmetica, ExpresionAritmetica)
    case multiplicacion(ExpresionAritmetica, ExpresionAritmetica)
}

let cinco = ExpresionAritmetica.numero(5)
let cuatro = ExpresionAritmetica.numero(4)
let suma = ExpresionAritmetica.suma(cinco, cuatro)
let producto = ExpresionAritmetica.multiplicacion(suma, ExpresionAritmetica.numero(2))</code></pre>
<ul>
<li>Es muy cómodo manejar enumeraciones recursivas de forma recursiva:</li>
</ul>
<pre class="highlight"><code class="language-swift">func evalua(expresion: ExpresionAritmetica) -&gt; Int {
    switch expresion {
    case let .numero(valor):
        return valor
    case let .suma(izquierda, derecha):
        return evalua(expresion: izquierda) + evalua(expresion: derecha)
    case let .multiplicacion(izquierda, derecha):
        return evalua(expresion: izquierda) * evalua(expresion: derecha)
    }
}

print(evalua(expresion: producto))
// Imprime 18</code></pre>
<ul>
<li>Otro ejemplo de enums recursivos, para definir un tipo de datos
<code>Lista</code> similar al que vimos en Scheme. La lista puede ser una lista
vacía o puede contener dos elementos: un valor <code>Int</code> y otra lista:</li>
</ul>
<pre class="highlight"><code class="language-swift">indirect enum Lista {
    case vacia
    case nodo(Int, Lista)
}</code></pre>
<ul>
<li>
<p>Para crear una lista de tipo <code>nodo</code> deberemos dar un valor entero (el
valor de la cabeza de la lista) y otra lista (el resto de la
lista). También podemos crear una lista vacía.</p>
</li>
<li>
<p>Por ejemplo, podemos crear la lista <code>(10, 20, 30)</code> de la siguiente
manera:</p>
</li>
</ul>
<pre class="highlight"><code class="language-swift">let lista1 = Lista.nodo(30, Lista.vacia)
let lista2 = Lista.nodo(20, lista1)
let lista3 = Lista.nodo(10, lista2)</code></pre>
<ul>
<li>Podríamos crear esta misma lista de una forma más abreviada:</li>
</ul>
<pre class="highlight"><code class="language-swift">let lista: Lista = .nodo(10, .nodo(20, .nodo(30, .vacia)))</code></pre>
<ul>
<li>Una vez definido el tipo enumerado, podemos definir funciones que
trabajen con él. La siguiente función, por ejemplo, es una función
recursiva que recibe una lista y devuelve la suma de sus
elementos. Funciona de una forma muy similar a la definición que
hicimos en Scheme:</li>
</ul>
<pre class="highlight"><code class="language-swift">func suma(lista: Lista) -&gt; Int {
    switch lista {
    case  .vacia:
        return 0
    case let .nodo(first, rest):
        return first + suma(lista: rest)
    }
}

let z: Lista = .nodo(20, .nodo(10, .vacia))

print(suma(lista: z))
// Imprime 30</code></pre>
<ul>
<li>Podemos también definir una función recursiva <code>construye(lista:[Int])</code>
que devuelve una lista a partir de una array de enteros:</li>
</ul>
<pre class="highlight"><code class="language-swift">func construye(lista: [Int]) -&gt; Lista {
    if (lista.isEmpty) {
        return Lista.vacia
    } else {
        let primero = lista[0]
        let resto = Array(lista.dropFirst())
        return Lista.nodo(primero, construye(lista: resto))
    } 
}

let lista2 = construye(lista: [1,2,3,4,5])

print(suma(lista: lista2))
// Imprime 15</code></pre></body>

</html>
