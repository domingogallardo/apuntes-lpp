<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
<style type="text/css">

/* Admonition */

.admonition {
    padding-left: 15px;
    padding-right: 15px;
    margin-bottom: 10px;
    border: 1px solid transparent;
    border-radius: 4px;
    text-align: left;
}

.admonition.note { /* csslint allow: adjoining-classes */
    color: black;
    background-color: #d9edf7;
    border-color: #bce8f1;
}

.admonition.quote { /* csslint allow: adjoining-classes */
    color: black;
    background-color: #cecece;
    border-color: #cccccc;
}

.admonition.warning { /* csslint allow: adjoining-classes */
    color: black;
    background-color: #FCC8BE;
    border-color: #FCC8BE;
}

.admonition.hint { /* csslint allow: adjoining-classes */
    color: black;
    background-color: #E9F9F6;
    border-color: #AFEEEE;
}

.admonition.danger { /* csslint allow: adjoining-classes */
    color: black;
    background-color: #F7B2A4;
    border-color: #F7B2A4;
}

.admonition-title {
    font-weight: bold;
    text-align: left;
}


/* Codehilite */

.hll { background-color: #ffffcc }
.c { color: #408080; font-style: italic } /* Comment */
.err { border: 1px solid #FF0000 } /* Error */
.k { color: #008000; font-weight: bold } /* Keyword */
.o { color: #666666 } /* Operator */
.ch { color: #408080; font-style: italic } /* Comment.Hashbang */
.cm { color: #408080; font-style: italic } /* Comment.Multiline */
.cp { color: #BC7A00 } /* Comment.Preproc */
.cpf { color: #408080; font-style: italic } /* Comment.PreprocFile */
.c1 { color: #408080; font-style: italic } /* Comment.Single */
.cs { color: #408080; font-style: italic } /* Comment.Special */
.gd { color: #A00000 } /* Generic.Deleted */
.ge { font-style: italic } /* Generic.Emph */
.gr { color: #FF0000 } /* Generic.Error */
.gh { color: #000080; font-weight: bold } /* Generic.Heading */
.gi { color: #00A000 } /* Generic.Inserted */
.go { color: #888888 } /* Generic.Output */
.gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.gs { font-weight: bold } /* Generic.Strong */
.gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.gt { color: #0044DD } /* Generic.Traceback */
.kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.kp { color: #008000 } /* Keyword.Pseudo */
.kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.kt { color: #B00040 } /* Keyword.Type */
.m { color: #666666 } /* Literal.Number */
.s { color: #BA2121 } /* Literal.String */
.na { color: #7D9029 } /* Name.Attribute */
.nb { color: #008000 } /* Name.Builtin */
.nc { color: #0000FF; font-weight: bold } /* Name.Class */
.no { color: #880000 } /* Name.Constant */
.nd { color: #AA22FF } /* Name.Decorator */
.ni { color: #999999; font-weight: bold } /* Name.Entity */
.ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.nf { color: #0000FF } /* Name.Function */
.nl { color: #A0A000 } /* Name.Label */
.nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.nt { color: #008000; font-weight: bold } /* Name.Tag */
.nv { color: #19177C } /* Name.Variable */
.ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.w { color: #bbbbbb } /* Text.Whitespace */
.mb { color: #666666 } /* Literal.Number.Bin */
.mf { color: #666666 } /* Literal.Number.Float */
.mh { color: #666666 } /* Literal.Number.Hex */
.mi { color: #666666 } /* Literal.Number.Integer */
.mo { color: #666666 } /* Literal.Number.Oct */
.sa { color: #BA2121 } /* Literal.String.Affix */
.sb { color: #BA2121 } /* Literal.String.Backtick */
.sc { color: #BA2121 } /* Literal.String.Char */
.dl { color: #BA2121 } /* Literal.String.Delimiter */
.sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.s2 { color: #BA2121 } /* Literal.String.Double */
.se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.sh { color: #BA2121 } /* Literal.String.Heredoc */
.si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.sx { color: #008000 } /* Literal.String.Other */
.sr { color: #BB6688 } /* Literal.String.Regex */
.s1 { color: #BA2121 } /* Literal.String.Single */
.ss { color: #19177C } /* Literal.String.Symbol */
.bp { color: #008000 } /* Name.Builtin.Pseudo */
.fm { color: #0000FF } /* Name.Function.Magic */
.vc { color: #19177C } /* Name.Variable.Class */
.vg { color: #19177C } /* Name.Variable.Global */
.vi { color: #19177C } /* Name.Variable.Instance */
.vm { color: #19177C } /* Name.Variable.Magic */
.il { color: #666666 } /* Literal.Number.Integer.Long */

/* Estilo LPP */

body {
  font-family: Helvetica, arial, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  background-color: white;
  padding: 60px;
}

pre {
  background-color: #f8f8f8;
  border: 1px solid #cccccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px;
}

table {
  padding: 0;border-collapse: collapse; }
  table tr {
    border-top: 1px solid #cccccc;
    background-color: white;
    margin: 0;
    padding: 0; }
    table tr:nth-child(2n) {
      background-color: #f8f8f8; }
    table tr th {
      font-weight: bold;
      border: 1px solid #cccccc;
      margin: 0;
      padding: 6px 13px; }
    table tr td {
      border: 1px solid #cccccc;
      margin: 0;
      padding: 6px 13px; }
    table tr th :first-child, table tr td :first-child {
      margin-top: 0; }
    table tr th :last-child, table tr td :last-child {
      margin-bottom: 0; }

</style>

</head>

<body>
<h2>Tema 6: Programación Funcional con Swift (semana 1)</h2>
<h3>Contenidos</h3>
<ul>
<li><strong>1. Introducción</strong></li>
<li><strong>2. Inmutabilidad</strong></li>
<li><strong>3. Funciones</strong></li>
<li><strong>4. Recursión</strong></li>
<li><strong>5. Tipos función</strong></li>
<li><strong>6. Tipos</strong></li>
<li><strong>7. Enumeraciones</strong></li>
<li><strong>8. Enumeraciones instanciables</strong></li>
<li>
<ol start="9">
<li>Opcionales</li>
</ol>
</li>
<li>
<ol start="10">
<li>Clausuras</li>
</ol>
</li>
<li>
<ol start="11">
<li>Funciones de orden superior</li>
</ol>
</li>
<li>
<ol start="12">
<li>Genéricos</li>
</ol>
</li>
</ul>
<hr />
<h3>Bibliografía</h3>
<ul>
<li><a href="https://github.com/domingogallardo/apuntes-lpp/blob/master/seminarios/seminario2-swift/seminario2-swift.md">Seminario de Swift</a></li>
<li>Swift Language Guide<ul>
<li><a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/TheBasics.html#//apple_ref/doc/uid/TP40014097-CH5-ID309">The Basics</a></li>
<li><a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/CollectionTypes.html#//apple_ref/doc/uid/TP40014097-CH8-ID105">Collection Types</a></li>
<li><a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Functions.html#//apple_ref/doc/uid/TP40014097-CH10-ID158">Functions</a></li>
<li><a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Closures.html#//apple_ref/doc/uid/TP40014097-CH11-ID94">Closures</a></li>
<li><a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Enumerations.html#//apple_ref/doc/uid/TP40014097-CH12-ID145">Enumerations</a></li>
</ul>
</li>
<li><a href="https://developer.apple.com/library/ios/documentation/General/Reference/SwiftStandardLibraryReference/">Biblioteca estándar de Swift</a></li>
</ul>
<hr />
<h3>1. Introducción</h3>
<hr />
<h3>Swift</h3>
<p>Swift es un lenguaje principalmente imperativo, pero en su diseño se
han introducido conceptos modernos de programación funcional,
extraídos de lenguajes como Rust o Haskell. </p>
<p>Como dice su creador <a href="http://nondot.org/sabre/">Chris Lattner</a>:</p>
<blockquote>
<p>El lenguaje Swift es el resultado de un esfuerzo incansable de un
equipo de expertos en lenguajes, gurús de documentación, ninjas de
optimización de compiladores [..]. Por supuesto, también se
benefició enormemente de las experiencias ganadas en muchos otros
lenguajes, tomando ideas de Objective-C, Rust, Haskell, Ruby,
Python, C#, CLU, y demasiados otros para ser enumerados.</p>
</blockquote>
<p>Vamos a repasar en este tema cómo se implementan en Swift conceptos
principalmente funcionales como:</p>
<ul>
<li>Valores inmutables</li>
<li>Tipos de datos recursivos</li>
<li>Funciones como objetos de primera clase y clasuras</li>
<li>Funciones de orden superior</li>
</ul>
<hr />
<h3>Ejecución de programas Swift</h3>
<ul>
<li>Consultar en el seminario de Swift la forma de instalar el
  compilador de Swift: usando un contenedor Docker, usando el terminal
  (Mac) o en Linux.</li>
</ul>
<p>Visual Code Studio con un terminal y con el comando docker para
ejecutar Swift:</p>
<p><img src="imagenes/vcode.png" width="700px"/></p>
<hr />
<h3>Swift es fuertemente tipado</h3>
<ul>
<li>Swift es un lenguaje fuertemente tipado</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="kd">let</span> <span class="nv">n</span><span class="p">:</span> <span class="nb">Int</span> <span class="p">=</span> <span class="mi">10</span>
<span class="kd">let</span> <span class="nv">str</span><span class="p">:</span> <span class="nb">String</span> <span class="p">=</span> <span class="s">&quot;Hola&quot;</span>
<span class="kd">let</span> <span class="nv">array</span><span class="p">:</span> <span class="p">[</span><span class="nb">Int</span><span class="p">]</span> <span class="p">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
</code></pre></div>
<ul>
<li>Es posible no escribir el nombre del tipo en aquellos casos en los
  que el compilador pueda <strong>inferirlo</strong>.</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="kd">let</span> <span class="nv">n</span> <span class="p">=</span> <span class="mi">10</span>
<span class="kd">let</span> <span class="nv">str</span> <span class="p">=</span> <span class="s">&quot;Hola&quot;</span>
<span class="kd">let</span> <span class="nv">array</span> <span class="p">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
</code></pre></div>
<h3>Swift es multi-paradigma</h3>
<ul>
<li>Swift incorpora características funcionales, de programación
  imperativa y de programación orientada a objetos.</li>
</ul>
<hr />
<h3>2. Inmutabilidad</h3>
<hr />
<p>Una de las características funcionales importantes de Swift es el
énfasis en la inmutabilidad para reforzar la seguridad del
lenguaje. Veamos algunas características relacionadas con esto.</p>
<hr />
<h3>Palabra clave let</h3>
<ul>
<li>La palabra clave <code>let</code> permite definir variables inmutables. Si se intenta
  modificar el valor el compilador da un error.</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="kd">var</span> <span class="nv">x</span> <span class="p">=</span> <span class="mi">10</span>
<span class="n">x</span> <span class="p">=</span> <span class="mi">20</span> <span class="c1">// x es mutable</span>
<span class="kd">let</span> <span class="nv">y</span> <span class="p">=</span> <span class="mi">10</span>
<span class="n">y</span> <span class="p">=</span> <span class="mi">20</span> <span class="c1">// error: y es inmutable</span>
</code></pre></div>
<ul>
<li>El valor asignado puede no conocerse en tiempo de compilación:</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="kd">let</span> <span class="nv">respuesta</span><span class="p">:</span> <span class="nb">String</span> <span class="p">=</span> <span class="n">respuestaUsuario</span><span class="p">.</span><span class="n">respuesta</span><span class="p">()</span>
</code></pre></div>
<ul>
<li>Si una variable no se modifica es conveniente declararla como
  <code>let</code>. El compilador de Swift da una aviso para ello.</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="kd">func</span> <span class="nf">saluda</span><span class="p">(</span><span class="n">nombre</span><span class="p">:</span> <span class="nb">String</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">String</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">saludo</span> <span class="p">=</span> <span class="s">&quot;Hola &quot;</span> <span class="o">+</span> <span class="n">nombre</span> <span class="o">+</span> <span class="s">&quot;!&quot;</span>
    <span class="k">return</span> <span class="n">saludo</span>
<span class="p">}</span>
<span class="c1">//warning: variable &#39;saludo&#39; was never mutated; consider changing to &#39;let&#39; constant</span>
<span class="c1">//    var saludo = &quot;Hola &quot; + nombre</span>
<span class="c1">//    ~~~ ^</span>
<span class="c1">//    let</span>
</code></pre></div>
<hr />
<h3>Creación de nuevas estructuras y mutación</h3>
<ul>
<li>
<p>En la <a href="https://developer.apple.com/documentation/swift/swift_standard_library">biblioteca estándar de
Swift</a>
existen una gran cantidad de estructuras (como <code>Int</code>, <code>Double</code>,
<code>Bool</code>, <code>String</code>, <code>Array</code>, <code>Dictionary</code>, etc.) que tienen dos tipos de
métodos: métodos que mutan la estructura y métodos que devuelven una
nueva estructura. </p>
</li>
<li>
<p>Por ejemplo, en el struct <code>Array</code> se define el método <code>sort</code> y el
método <code>sorted</code>. El primero ordena el array con mutación y el segundo
devuelve una copia ordenada, sin modificar el array original. </p>
</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="c1">// Código recomendable en programación funcional</span>
<span class="c1">// porque utiliza el método sorted que devuelve una</span>
<span class="c1">// copia del array original</span>
<span class="kd">let</span> <span class="nv">miArray</span> <span class="p">=</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">80</span><span class="p">]</span>
<span class="kd">let</span> <span class="nv">arrayOrdenado</span> <span class="p">=</span> <span class="n">miArray</span><span class="p">.</span><span class="bp">sorted</span><span class="p">()</span>
<span class="bp">print</span><span class="p">(</span><span class="n">miArray</span><span class="p">)</span>
<span class="bp">print</span><span class="p">(</span><span class="n">arrayOrdenado</span><span class="p">)</span>
<span class="c1">// Imprime:</span>
<span class="c1">// [10, -1, 3, 80]</span>
<span class="c1">// [-1, 3, 10, 80]</span>
</code></pre></div>
<ul>
<li>Sin embargo, el siguiente código es imperativo y utiliza la mutación
  del array original: </li>
</ul>
<div class="highlight"><pre><span></span><code><span class="c1">// Código no recomendable en programación funcional</span>
<span class="c1">// porque utiliza el método sort que muta el array original</span>
<span class="kd">var</span> <span class="nv">miArray</span> <span class="p">=</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">80</span><span class="p">]</span>
<span class="n">miArray</span><span class="p">.</span><span class="bp">sort</span><span class="p">()</span>
<span class="bp">print</span><span class="p">(</span><span class="n">miArray</span><span class="p">)</span>
<span class="c1">// Imprime:</span>
<span class="c1">// [-1, 3, 10, 80]</span>
</code></pre></div>
<ul>
<li>Otro ejemplo es en la forma de añadir elementos a un array. Podemos
hacerlo con un enfoque funcional, usando el operador <code>+</code> que construye
un array nuevo:</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="c1">// Código recomendable en programación funcional</span>
<span class="kd">let</span> <span class="nv">miArray</span> <span class="p">=</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">80</span><span class="p">]</span>
<span class="kd">let</span> <span class="nv">array2</span> <span class="p">=</span> <span class="n">miArray</span> <span class="o">+</span> <span class="p">[</span><span class="mi">100</span><span class="p">]</span>
<span class="bp">print</span><span class="p">(</span><span class="n">array2</span><span class="p">)</span>
<span class="c1">// Imprime:</span>
<span class="c1">// [10, -1, 3, 80, 100]</span>
</code></pre></div>
<ul>
<li>Y podemos hacerlo usando un enfoque imperativo, con el método
<code>append</code>:</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="c1">// Código no recomendable en programación funcional</span>
<span class="kd">var</span> <span class="nv">miArray</span> <span class="p">=</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">80</span><span class="p">]</span>
<span class="n">miArray</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
<span class="bp">print</span><span class="p">(</span><span class="n">miArray</span><span class="p">)</span>
<span class="c1">// Imprime:</span>
<span class="c1">// [10, -1, 3, 80, 100]</span>
</code></pre></div>
<div class="admonition note">
<p class="admonition-title">Importante</p>
<p>Cuando estemos escribiendo código con estilo
funcional deberemos utilizar los métodos que no modifican las
estructuras. Así evitaremos los efectos laterales y nuestro código
funcionará correctamente en entornos multi-hilo.</p>
</div>
<hr />
<h3>3. Funciones</h3>
<hr />
<h3>Definición de una función en Swift</h3>
<ul>
<li>Para definir una función en Swift se debe usar la palabra <code>func</code>,
definir el nombre de la función, sus parámetros y el tipo de vuelto.</li>
<li>El valor devuelto por la función se debe devolver usando la palabra
<code>return</code>.</li>
</ul>
<p>Ejemplo función <code>saluda(nombre:)</code>:</p>
<div class="highlight"><pre><span></span><code><span class="kd">func</span> <span class="nf">saluda</span><span class="p">(</span><span class="n">nombre</span><span class="p">:</span> <span class="nb">String</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">String</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nv">saludo</span> <span class="p">=</span> <span class="s">&quot;Hola, &quot;</span> <span class="o">+</span> <span class="n">nombre</span> <span class="o">+</span> <span class="s">&quot;!&quot;</span>
    <span class="k">return</span> <span class="n">saludo</span>
<span class="p">}</span>
</code></pre></div>
<p>Invocación a la función <code>saluda(nombre:)</code>:</p>
<div class="highlight"><pre><span></span><code><span class="bp">print</span><span class="p">(</span><span class="n">saluda</span><span class="p">(</span><span class="n">nombre</span><span class="p">:</span><span class="s">&quot;Ana&quot;</span><span class="p">))</span>
<span class="bp">print</span><span class="p">(</span><span class="n">saluda</span><span class="p">(</span><span class="n">nombre</span><span class="p">:</span><span class="s">&quot;Pedro&quot;</span><span class="p">))</span>
<span class="c1">// Imprime &quot;Hola, Ana!&quot;</span>
<span class="c1">// Imprime &quot;Hola, Pedro!&quot;</span>
</code></pre></div>
<hr />
<h3>Etiquetas de argumentos y nombres de parámetros</h3>
<ul>
<li>Cada parámetro de una función tiene una <strong>etiqueta del argumento</strong> y
un <strong>nombre de parámetro</strong>.</li>
<li>Por defecto, los parámetros usan su nombre de parámetro como etiqueta
del argumento</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="kd">func</span> <span class="nf">unaFuncion</span><span class="p">(</span><span class="n">primerNombreParametro</span><span class="p">:</span> <span class="nb">Int</span><span class="p">,</span> <span class="n">segundoNombreParametro</span><span class="p">:</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// En el cuerpo de la función, primerNombreParametro y</span>
    <span class="c1">// segundoNombreParametro se refieren a los valores de los</span>
    <span class="c1">// argumentos del primer y el segundo parámetro</span>
<span class="p">}</span>
<span class="n">unaFuncion</span><span class="p">(</span><span class="n">primerNombreParametro</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="n">segundoNombreParametro</span><span class="p">:</span> <span class="mi">2</span><span class="p">)</span>
</code></pre></div>
<ul>
<li>Es posible hacer distintos la etiqueta del argumento del nombre del
parámetro:</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="kd">func</span> <span class="nf">saluda</span><span class="p">(</span><span class="n">nombre</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span> <span class="n">de</span> <span class="n">ciudad</span><span class="p">:</span> <span class="nb">String</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">String</span> <span class="p">{</span>
    <span class="k">return</span> <span class="s">&quot;Hola </span><span class="si">\(</span><span class="n">nombre</span><span class="si">)</span><span class="s">! Me alegro de que hayas podido visitarnos desde </span><span class="si">\(</span><span class="n">ciudad</span><span class="si">)</span><span class="s">.&quot;</span>
<span class="p">}</span>
<span class="bp">print</span><span class="p">(</span><span class="n">saluda</span><span class="p">(</span><span class="n">nombre</span><span class="p">:</span> <span class="s">&quot;Bill&quot;</span><span class="p">,</span> <span class="n">de</span><span class="p">:</span> <span class="s">&quot;Cupertino&quot;</span><span class="p">))</span>
<span class="c1">// Imprime &quot;Hola Bill! Me alegro de que hayas podido visitarnos desde Cupertino.&quot;</span>
</code></pre></div>
<ul>
<li>Otro ejemplo, la siguiente función <code>concatena(palabra:con:)</code>: </li>
</ul>
<div class="highlight"><pre><span></span><code><span class="kd">func</span> <span class="nf">concatena</span><span class="p">(</span><span class="n">palabra</span> <span class="n">str1</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span> <span class="n">con</span> <span class="n">str2</span><span class="p">:</span> <span class="nb">String</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">String</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">str1</span><span class="o">+</span><span class="n">str2</span>
<span class="p">}</span>

<span class="bp">print</span><span class="p">(</span><span class="n">concatena</span><span class="p">(</span><span class="n">palabra</span><span class="p">:</span><span class="s">&quot;Hola&quot;</span><span class="p">,</span> <span class="n">con</span><span class="p">:</span><span class="s">&quot;adios&quot;</span><span class="p">))</span>
</code></pre></div>
<ul>
<li>Si no se quiere una etiqueta del argumento para un parámetro, se puede
escribir un subrayado (<code>_</code>) en lugar de una etiqueta del argumento
explícita para ese parámetro:</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="kd">func</span> <span class="nf">max</span><span class="p">(</span><span class="kc">_</span> <span class="n">x</span><span class="p">:</span><span class="nb">Int</span><span class="p">,</span> <span class="kc">_</span> <span class="n">y</span><span class="p">:</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Int</span> <span class="p">{</span>
   <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="n">y</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">x</span>
   <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">y</span>
   <span class="p">}</span>
<span class="p">}</span>

<span class="bp">print</span><span class="p">(</span><span class="bp">max</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>

<span class="kd">func</span> <span class="nf">divide</span><span class="p">(</span><span class="kc">_</span> <span class="n">x</span><span class="p">:</span><span class="nb">Double</span><span class="p">,</span> <span class="n">entre</span> <span class="n">y</span><span class="p">:</span> <span class="nb">Double</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Double</span> <span class="p">{</span>
   <span class="k">return</span> <span class="n">x</span> <span class="o">/</span> <span class="n">y</span>
<span class="p">}</span>

<span class="bp">print</span><span class="p">(</span><span class="n">divide</span><span class="p">(</span><span class="mi">30</span><span class="p">,</span> <span class="n">entre</span><span class="p">:</span><span class="mi">4</span><span class="p">))</span>
</code></pre></div>
<ul>
<li>
<p>El perfil de la función está formado por el nombre de la función,
las etiquetas de los argumentos y el tipo devuelto por la función. En
la documentación de las funciones usaremos las etiquetas separadas por
dos puntos. Por ejemplo, las funciones anteriores son <code>max(_:_:)</code> y
<code>divide(_:entre:)</code>.</p>
</li>
<li>
<p>Las etiquetas de los argumentos son parte del nombre de la
función. Es posible definir funciones distintas con
sólo distintos nombres de argumentos, como las siguientes funciones
<code>mitad(par:)</code> y <code>mitad(impar:)</code>:</p>
</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="kd">func</span> <span class="nf">mitad</span><span class="p">(</span><span class="n">par</span><span class="p">:</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Int</span><span class="p">{</span>
    <span class="k">return</span> <span class="n">par</span><span class="o">/</span><span class="mi">2</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">mitad</span><span class="p">(</span><span class="n">impar</span><span class="p">:</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Int</span><span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">impar</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>
<span class="p">}</span>

<span class="bp">print</span><span class="p">(</span><span class="n">mitad</span><span class="p">(</span><span class="n">par</span><span class="p">:</span> <span class="mi">8</span><span class="p">))</span>
<span class="c1">// Imprime 4</span>
<span class="bp">print</span><span class="p">(</span><span class="n">mitad</span><span class="p">(</span><span class="n">impar</span><span class="p">:</span> <span class="mi">9</span><span class="p">))</span>
<span class="c1">// Imprime 5</span>
</code></pre></div>
<hr />
<h3>Parámetros y valores devueltos</h3>
<ul>
<li>Es posible definir funciones sin parámetros:</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="kd">func</span> <span class="nf">diHolaMundo</span><span class="p">()</span> <span class="p">-&gt;</span> <span class="nb">String</span> <span class="p">{</span>
    <span class="k">return</span> <span class="s">&quot;hola, mundo&quot;</span>
<span class="p">}</span>
<span class="bp">print</span><span class="p">(</span><span class="n">diHolaMundo</span><span class="p">())</span>
<span class="c1">// Imprime &quot;hola, mundo&quot;</span>
</code></pre></div>
<ul>
<li>Podemos definir funciones sin valor devuelto. Por ejemplo, la
  siguiente función <code>diAdios(nombre:)</code>. No hay que escribir flecha con
  el tipo devuelto. Cuidado, no sería propiamente programación
  funcional.</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="kd">func</span> <span class="nf">diAdios</span><span class="p">(</span><span class="n">nombre</span><span class="p">:</span> <span class="nb">String</span><span class="p">)</span> <span class="p">{</span>
    <span class="bp">print</span><span class="p">(</span><span class="s">&quot;Adiós, </span><span class="si">\(</span><span class="n">nombre</span><span class="si">)</span><span class="s">!&quot;</span><span class="p">)</span>
<span class="p">}</span>
<span class="n">diAdios</span><span class="p">(</span><span class="n">nombre</span><span class="p">:</span><span class="s">&quot;Dave&quot;</span><span class="p">)</span>
<span class="c1">// Imprime &quot;Adiós, Dave!&quot;</span>
</code></pre></div>
<ul>
<li>Es posible devolver múltiples valores, construyendo una tupla. Por
ejemplo, la siguiente función <code>ecuacion(a:b:c:)</code> calcula las dos
soluciones de una ecuación de segundo grado:</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="kd">func</span> <span class="nf">ecuacion</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="nb">Double</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="nb">Double</span><span class="p">,</span> <span class="n">c</span><span class="p">:</span> <span class="nb">Double</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="p">(</span><span class="n">pos</span><span class="p">:</span> <span class="nb">Double</span><span class="p">,</span> <span class="n">neg</span><span class="p">:</span> <span class="nb">Double</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nv">discriminante</span> <span class="p">=</span> <span class="n">b</span><span class="o">*</span><span class="n">b</span><span class="o">-</span><span class="mi">4</span><span class="o">*</span><span class="n">a</span><span class="o">*</span><span class="n">c</span>
    <span class="kd">let</span> <span class="nv">raizPositiva</span> <span class="p">=</span> <span class="p">(</span><span class="o">-</span><span class="n">b</span> <span class="o">+</span> <span class="n">discriminante</span><span class="p">.</span><span class="n">squareRoot</span><span class="p">())</span> <span class="o">/</span> <span class="mi">2</span><span class="o">*</span><span class="n">a</span>
    <span class="kd">let</span> <span class="nv">raizNegativa</span> <span class="p">=</span> <span class="p">(</span><span class="o">-</span><span class="n">b</span> <span class="o">-</span> <span class="n">discriminante</span><span class="p">.</span><span class="n">squareRoot</span><span class="p">())</span> <span class="o">/</span> <span class="mi">2</span><span class="o">*</span><span class="n">a</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">raizPositiva</span><span class="p">,</span> <span class="n">raizNegativa</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>
<ul>
<li>Recordemos (consultar el seminario de Swift) que podemos acceder a los
valores de la tupla por posición:</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="kd">let</span> <span class="nv">resultado</span> <span class="p">=</span> <span class="n">ecuacion</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="n">c</span><span class="p">:</span> <span class="mi">6</span><span class="p">)</span>
<span class="bp">print</span><span class="p">(</span><span class="s">&quot;Las raíces de la ecuación son </span><span class="si">\(</span><span class="n">resultado</span><span class="p">.</span><span class="mi">0</span><span class="si">)</span><span class="s"> y </span><span class="si">\(</span><span class="n">resultado</span><span class="p">.</span><span class="mi">1</span><span class="si">)</span><span class="s">&quot;</span><span class="p">)</span>
<span class="c1">//Imprime &quot;Las raíces de la ecuación son 3.0 y 2.0&quot;</span>
</code></pre></div>
<ul>
<li>En este caso en la definición del tipo devuelto por la función estamos
etiquetando esos valores con las etiquetas <code>pos</code> y <code>neg</code>. De esta
forma podemos acceder a los componentes de la tupla usando esas
etiquetas definidas:</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="kd">let</span> <span class="nv">resultado</span> <span class="p">=</span> <span class="n">ecuacion</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="n">c</span><span class="p">:</span> <span class="mi">6</span><span class="p">)</span>
<span class="bp">print</span><span class="p">(</span><span class="s">&quot;Las raíces de la ecuación son </span><span class="si">\(</span><span class="n">resultado</span><span class="p">.</span><span class="n">pos</span><span class="si">)</span><span class="s"> y </span><span class="si">\(</span><span class="n">resultado</span><span class="p">.</span><span class="n">neg</span><span class="si">)</span><span class="s">&quot;</span><span class="p">)</span>
<span class="c1">//Imprime &quot;Las raíces de la ecuación son 3.0 y 2.0&quot;</span>
</code></pre></div>
<hr />
<h3>4. Recursión</h3>
<hr />
<h3>Ejemplos de funciones recursivas en Swift</h3>
<ul>
<li>Recursión pura:</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="kd">func</span> <span class="nf">suma</span><span class="p">(</span><span class="n">hasta</span> <span class="n">x</span><span class="p">:</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Int</span> <span class="p">{</span>
  <span class="k">if</span> <span class="n">x</span> <span class="p">==</span> <span class="mi">0</span> <span class="p">{</span>
    <span class="k">return</span> <span class="mi">0</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">suma</span><span class="p">(</span><span class="n">hasta</span><span class="p">:</span> <span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="bp">print</span><span class="p">(</span><span class="n">suma</span><span class="p">(</span><span class="n">hasta</span><span class="p">:</span> <span class="mi">5</span><span class="p">))</span>
</code></pre></div>
<hr />
<h3>Funciones recursivas sobre Arrays</h3>
<ul>
<li>Los arrays en Swift no funcionan exactamente como las listas de
Scheme (no son listas de parejas), pero podríamos obtener el primer
elemento y el resto de la siguiente forma.</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="kd">let</span> <span class="nv">a</span> <span class="p">=</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">60</span><span class="p">]</span>
<span class="kd">let</span> <span class="nv">primero</span> <span class="p">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="kd">let</span> <span class="nv">resto</span> <span class="p">=</span> <span class="nb">Array</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="bp">dropFirst</span><span class="p">())</span>
</code></pre></div>
<ul>
<li>
<p>En <code>primero</code> se guarda el número 10. En <code>resto</code> se guarda el <code>Array</code>
del 20 al 60.</p>
</li>
<li>
<p>El método <code>dropFirst</code> devuelve una <code>ArraySlice</code>, que es
una vista de un rango de elementos del array, en este caso el que va
desde la posición 1 hasta la 5 (la posición inicial de un array es la
0). Es necesario el constructor <code>Array</code> para convertir ese
<code>ArraySlice</code> en un <code>Array</code>.</p>
</li>
<li>
<p>Usando las instrucciones anteriores podemos definir la función
recursiva que suma los valores de un Array de la siguiente forma
similar a cómo lo hacíamos en Scheme:</p>
</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="kd">func</span> <span class="nf">sumaValores</span><span class="p">(</span><span class="kc">_</span> <span class="n">valores</span><span class="p">:</span> <span class="p">[</span><span class="nb">Int</span><span class="p">])</span> <span class="p">-&gt;</span> <span class="nb">Int</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">valores</span><span class="p">.</span><span class="bp">isEmpty</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">0</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="kd">let</span> <span class="nv">primero</span> <span class="p">=</span> <span class="n">valores</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="kd">let</span> <span class="nv">resto</span> <span class="p">=</span> <span class="nb">Array</span><span class="p">(</span><span class="n">valores</span><span class="p">.</span><span class="bp">dropFirst</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">primero</span> <span class="o">+</span> <span class="n">sumaValores</span><span class="p">(</span><span class="n">resto</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="bp">print</span><span class="p">(</span><span class="n">sumaValores</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">]))</span> 
<span class="c1">// Imprime &quot;36&quot;</span>
</code></pre></div>
<ul>
<li>Un último ejemplo es la siguiente función <code>minMax(array:)</code> que
devuelve el número más pequeño y más grande de un array de enteros:</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="kd">func</span> <span class="nf">minMax</span><span class="p">(</span><span class="n">array</span><span class="p">:</span> <span class="p">[</span><span class="nb">Int</span><span class="p">])</span> <span class="p">-&gt;</span> <span class="p">(</span><span class="bp">min</span><span class="p">:</span> <span class="nb">Int</span><span class="p">,</span> <span class="bp">max</span><span class="p">:</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">array</span><span class="p">.</span><span class="bp">count</span> <span class="p">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">array</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">array</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="kd">let</span> <span class="nv">primero</span> <span class="p">=</span> <span class="n">array</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="kd">let</span> <span class="nv">resto</span> <span class="p">=</span> <span class="nb">Array</span><span class="p">(</span><span class="n">array</span><span class="p">.</span><span class="bp">dropFirst</span><span class="p">())</span>

        <span class="c1">// Llamada recursiva que devuelve el mínimo y el máximo del</span>
        <span class="c1">// resto del array</span>
        <span class="kd">let</span> <span class="nv">minMaxResto</span> <span class="p">=</span> <span class="n">minMax</span><span class="p">(</span><span class="n">array</span><span class="p">:</span> <span class="n">resto</span><span class="p">)</span>

        <span class="kd">let</span> <span class="nv">minimo</span> <span class="p">=</span> <span class="bp">min</span><span class="p">(</span><span class="n">primero</span><span class="p">,</span> <span class="n">minMaxResto</span><span class="p">.</span><span class="bp">min</span><span class="p">)</span>
        <span class="kd">let</span> <span class="nv">maximo</span> <span class="p">=</span> <span class="bp">max</span><span class="p">(</span><span class="n">primero</span><span class="p">,</span> <span class="n">minMaxResto</span><span class="p">.</span><span class="bp">max</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">minimo</span><span class="p">,</span> <span class="n">maximo</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nv">limites</span> <span class="p">=</span> <span class="n">minMax</span><span class="p">(</span><span class="n">array</span><span class="p">:</span> <span class="p">[</span><span class="mi">8</span><span class="p">,</span> <span class="o">-</span><span class="mi">6</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">71</span><span class="p">])</span>
<span class="bp">print</span><span class="p">(</span><span class="s">&quot;El mínimo es </span><span class="si">\(</span><span class="n">limites</span><span class="p">.</span><span class="bp">min</span><span class="si">)</span><span class="s"> y el máximo es </span><span class="si">\(</span><span class="n">limites</span><span class="p">.</span><span class="bp">max</span><span class="si">)</span><span class="s">&quot;</span><span class="p">)</span>
<span class="c1">// Imprime &quot;El mímimo es -6 y el máximo es 100&quot;</span>
</code></pre></div>
<ul>
<li>En este ejemplo nos apartamos un poco de la solución vista en Scheme
porque permitimos pasos de ejecución que inicializan variables. Pero
no nos salimos del paradigma funcional, porque todas son variables
inmutables definidas con <code>let</code>.</li>
</ul>
<hr />
<h3>5. Tipos función</h3>
<hr />
<h3>Funciones como objetos de primera clase</h3>
<ul>
<li>
<p>En Swift las funciones son objetos de primera clase y podemos
  asignarlas a variables, pasarlas como parámetro o devolverlas como
  resultado de otra función. Al ser un lenguaje fuertemente tipado,
  las variables, parámetros o resultados deben ser objetos de tipo
  función.</p>
</li>
<li>
<p>Cada función tiene un tipo específico, definido por el tipo de sus
parámetros y el tipo del valor devuelto.</p>
</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="kd">func</span> <span class="nf">sumaDosInts</span><span class="p">(</span><span class="kc">_</span> <span class="n">a</span><span class="p">:</span> <span class="nb">Int</span><span class="p">,</span> <span class="kc">_</span> <span class="n">b</span><span class="p">:</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Int</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">multiplicaDosInts</span><span class="p">(</span><span class="kc">_</span> <span class="n">a</span><span class="p">:</span> <span class="nb">Int</span><span class="p">,</span> <span class="kc">_</span> <span class="n">b</span><span class="p">:</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Int</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">*</span> <span class="n">b</span>
<span class="p">}</span>
</code></pre></div>
<ul>
<li>
<p>El tipo de estas funciones es <code>(Int, Int) -&gt; Int</code></p>
</li>
<li>
<p>En Swift se puede usar un tipo función de la misma forma que
  cualquier otro tipo:</p>
</li>
</ul>
<p><div class="highlight"><pre><span></span><code><span class="kd">var</span> <span class="nv">f</span> <span class="p">=</span> <span class="n">sumaDosInts</span>
<span class="bp">print</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
<span class="c1">// Imprime &quot;5&quot;</span>
<span class="n">f</span> <span class="p">=</span> <span class="n">multiplicaDosInts</span>
<span class="bp">print</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
<span class="c1">// Imprime &quot;6&quot;</span>
</code></pre></div>
- La variable <code>f</code> es una variable de tipo <code>(Int, Int) -&gt; Int</code>, o sea,
una variable que contiene funciones de dos argumentos <code>Int</code> que
devuelven un <code>Int</code>.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Habrás notado que al invocar a <code>f</code> no se ponen etiquetas en los
argumentos. De hecho, si las pusiéramos el compilador de Swift se
quejaría:</p>
<div class="highlight"><pre><span></span><code><span class="bp">print</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">a</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span><span class="mi">3</span><span class="p">))</span>
<span class="c1">//error: extraneous argument labels &#39;a:b:&#39; in call</span>
</code></pre></div>
<p>Esto es debido a que al ser <code>f</code> una variable se le puede asignar
cualquier función que tenga el perfil <code>(Int, Int) -&gt; Int</code> sin
tener en cuenta las etiquetas de los argumentos.</p>
</div>
<hr />
<h3>Funciones que reciben otras funciones</h3>
<ul>
<li>Podemos usar un tipo función en parámetros de otras funciones:</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="kd">func</span> <span class="nf">printResultado</span><span class="p">(</span><span class="n">funcion</span><span class="p">:</span> <span class="p">(</span><span class="nb">Int</span><span class="p">,</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Int</span><span class="p">,</span> <span class="kc">_</span> <span class="n">a</span><span class="p">:</span> <span class="nb">Int</span><span class="p">,</span> <span class="kc">_</span> <span class="n">b</span><span class="p">:</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">{</span>
    <span class="bp">print</span><span class="p">(</span><span class="s">&quot;Resultado: </span><span class="si">\(</span><span class="n">funcion</span><span class="si">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="si">))</span><span class="s">&quot;</span><span class="p">)</span>
<span class="p">}</span>
<span class="n">printResultado</span><span class="p">(</span><span class="n">funcion</span><span class="p">:</span> <span class="n">sumaDosInts</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="c1">// Prints &quot;Resultado: 8&quot;</span>
</code></pre></div>
<ul>
<li>Veamos otro ejemplo, que ya vimos en Scheme. Supongamos que queremos
  calcular el sumatorio desde <code>a</code> hasta <code>b</code> en el que aplicamos una
  función <code>f</code> a cada número que sumamos:</li>
</ul>
<div class="highlight"><pre><span></span><code>sumatorio(a, b, f) = f(a) + f(a+1) + f(a+2) + ... + f(b)
</code></pre></div>
<ul>
<li>Recordamos que se resuelve con la siguiente recursión:</li>
</ul>
<div class="highlight"><pre><span></span><code>sumatorio(a, b, f) = f(a) + sumatorio(a+1, b, f)
sumatorio(a, b, f) = 0 si a &gt; b
</code></pre></div>
<ul>
<li>Implementación en Swift: </li>
</ul>
<div class="highlight"><pre><span></span><code><span class="kd">func</span> <span class="nf">sumatorio</span><span class="p">(</span><span class="n">desde</span> <span class="n">a</span><span class="p">:</span> <span class="nb">Int</span><span class="p">,</span> <span class="n">hasta</span> <span class="n">b</span><span class="p">:</span> <span class="nb">Int</span><span class="p">,</span> <span class="kd">func</span> <span class="nf">f</span><span class="p">:</span> <span class="p">(</span><span class="nb">Int</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Int</span> <span class="p">{</span>
   <span class="k">if</span> <span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span> <span class="p">{</span> 
      <span class="k">return</span> <span class="mi">0</span> 
   <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">f</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">+</span> <span class="n">sumatorio</span><span class="p">(</span><span class="n">desde</span><span class="p">:</span> <span class="n">a</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">hasta</span><span class="p">:</span> <span class="n">b</span><span class="p">,</span> <span class="kd">func</span><span class="p">:</span> <span class="n">f</span><span class="p">)</span>
   <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">identidad</span><span class="p">(</span><span class="kc">_</span> <span class="n">x</span><span class="p">:</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Int</span> <span class="p">{</span>
   <span class="k">return</span> <span class="n">x</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">doble</span><span class="p">(</span><span class="kc">_</span> <span class="n">x</span><span class="p">:</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Int</span> <span class="p">{</span>
   <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">x</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">cuadrado</span><span class="p">(</span><span class="kc">_</span> <span class="n">x</span><span class="p">:</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Int</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span>
<span class="p">}</span>

<span class="bp">print</span><span class="p">(</span><span class="n">sumatorio</span><span class="p">(</span><span class="n">desde</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="n">hasta</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span> <span class="kd">func</span><span class="p">:</span> <span class="n">identidad</span><span class="p">))</span> <span class="c1">// Imprime 55</span>
<span class="bp">print</span><span class="p">(</span><span class="n">sumatorio</span><span class="p">(</span><span class="n">desde</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="n">hasta</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span> <span class="kd">func</span><span class="p">:</span> <span class="n">doble</span><span class="p">))</span> <span class="c1">// Imprime 110</span>
<span class="bp">print</span><span class="p">(</span><span class="n">sumatorio</span><span class="p">(</span><span class="n">desde</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="n">hasta</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span> <span class="kd">func</span><span class="p">:</span> <span class="n">cuadrado</span><span class="p">))</span> <span class="c1">// Imprime 385</span>
</code></pre></div>
<hr />
<h3>Funciones en estructuras de datos</h3>
<ul>
<li>Las funciones pueden también incluirse en estructuras de datos
  compuestas, como arrays:</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="kd">let</span> <span class="nv">funciones</span> <span class="p">=</span> <span class="p">[</span><span class="n">identidad</span><span class="p">,</span> <span class="n">doble</span><span class="p">,</span> <span class="n">cuadrado</span><span class="p">]</span>
<span class="bp">print</span><span class="p">(</span><span class="n">funciones</span><span class="p">[</span><span class="mi">0</span><span class="p">](</span><span class="mi">10</span><span class="p">))</span> <span class="c1">// 10</span>
<span class="bp">print</span><span class="p">(</span><span class="n">funciones</span><span class="p">[</span><span class="mi">1</span><span class="p">](</span><span class="mi">10</span><span class="p">))</span> <span class="c1">// 20 </span>
<span class="bp">print</span><span class="p">(</span><span class="n">funciones</span><span class="p">[</span><span class="mi">2</span><span class="p">](</span><span class="mi">10</span><span class="p">))</span> <span class="c1">// 100</span>
</code></pre></div>
<ul>
<li>
<p>El tipo de la variable <code>funciones</code> sería <code>[(Int) -&gt; Int]</code>. </p>
</li>
<li>
<p>Al ser Swift fuertemente tipado, no podríamos hacer un array con
distintos tipos de funciones. Por ejemplo el siguiente código daría un
error:</p>
</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="kd">func</span> <span class="nf">suma</span><span class="p">(</span><span class="kc">_</span> <span class="n">x</span><span class="p">:</span> <span class="nb">Int</span><span class="p">,</span> <span class="kc">_</span> <span class="n">y</span><span class="p">:</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Int</span> <span class="p">{</span>
   <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
<span class="p">}</span>
<span class="c1">// La siguiente línea genera un error</span>
<span class="kd">var</span> <span class="nv">misFunciones</span> <span class="p">=</span> <span class="p">[</span><span class="n">doble</span><span class="p">,</span> <span class="n">cuadrado</span><span class="p">,</span> <span class="n">suma</span><span class="p">]</span>
<span class="c1">// error: heterogenous collection literal could only be inferred to</span>
<span class="c1">// &#39;[Any]&#39;; add explicit type annotation if this is intentional</span>
</code></pre></div>
<hr />
<h3>Funciones que devuelven otras funciones</h3>
<ul>
<li>
<p>Por último, veamos un ejemplo de funciones que devuelven otras
  funciones.</p>
</li>
<li>
<p>Empecemos por un ejemplo sencillo de una función que devuelve otra
que suma 10:</p>
</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="kd">func</span> <span class="nf">construyeSumador10</span><span class="p">()</span> <span class="p">-&gt;</span> <span class="p">(</span><span class="nb">Int</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Int</span> <span class="p">{</span>
  <span class="kd">func</span> <span class="nf">suma10</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Int</span> <span class="p">{</span><span class="k">return</span> <span class="n">x</span><span class="o">+</span><span class="mi">10</span><span class="p">}</span>
  <span class="k">return</span> <span class="n">suma10</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nv">g</span> <span class="p">=</span> <span class="n">construyeSumador10</span><span class="p">()</span>
<span class="bp">print</span><span class="p">(</span><span class="n">g</span><span class="p">(</span><span class="mi">20</span><span class="p">))</span>
<span class="c1">// Imprime 30</span>
</code></pre></div>
<ul>
<li>
<p>La función devuelta por <code>construyeSumador10()</code> es una función con el tipo
<code>(Int) -&gt; Int</code> (recibe un parámetro entero y devuelve un entero). </p>
</li>
<li>
<p>Estas funciones devueltas se denominan <strong>clausuras</strong>. Más adelante
hablaremos algo más de ellas. Veremos también más adelante que es
posible usar <strong>expresiones de clausura</strong> que construyen clausuras
anónimas.</p>
</li>
<li>
<p>Podemos modificar el ejemplo anterior, haciendo que la función
<code>construyeSumador</code> reciba el número a sumar como parámetro:</p>
</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="kd">func</span> <span class="nf">construyeSumador</span><span class="p">(</span><span class="n">inc</span><span class="p">:</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="p">(</span><span class="nb">Int</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Int</span> <span class="p">{</span>
  <span class="kd">func</span> <span class="nf">suma</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Int</span> <span class="p">{</span><span class="k">return</span> <span class="n">x</span><span class="o">+</span><span class="n">inc</span><span class="p">}</span>
  <span class="k">return</span> <span class="n">suma</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nv">f2</span> <span class="p">=</span> <span class="n">construyeSumador</span><span class="p">(</span><span class="n">inc</span><span class="p">:</span> <span class="mi">10</span><span class="p">)</span>
<span class="kd">var</span> <span class="nv">f3</span> <span class="p">=</span> <span class="n">construyeSumador</span><span class="p">(</span><span class="n">inc</span><span class="p">:</span> <span class="mi">100</span><span class="p">)</span>
<span class="bp">print</span><span class="p">(</span><span class="n">f2</span><span class="p">(</span><span class="mi">20</span><span class="p">))</span>
<span class="c1">// Imprime &quot;30&quot;</span>
<span class="bp">print</span><span class="p">(</span><span class="n">f3</span><span class="p">(</span><span class="mi">20</span><span class="p">))</span>
<span class="c1">// Imprime &quot;120&quot;</span>
</code></pre></div>
<hr />
<h3>6. Tipos</h3>
<hr />
<h3>Swift es fuertemente tipado</h3>
<ul>
<li>
<p>Swift es un lenguaje fuertemente tipado, a diferencia de
  Scheme. </p>
</li>
<li>
<p>Entre las ventajas del uso de tipos está la detección de errores en
  los programas en tiempo de compilación o las ayudas del entorno de
  desarrollo para autocompletar código. </p>
</li>
<li>
<p>Entre los inconvenientes se encuentra la necesidad de ser más
  estrictos a la hora de definir los parámetros y los valores
  devueltos por las funciones, lo que impide la flexibilidad de
  Scheme.</p>
</li>
<li>
<p>Se utilizan tipos para definir los posibles valores de:</p>
<ul>
<li>variables</li>
<li>parámetros de funciones</li>
<li>valores devueltos por funciones</li>
</ul>
</li>
<li>
<p>Las definiciones de tipos van precedidas de dos puntos en las
  variables y parámetros, o de una flecha (<code>-&gt;</code>) en la definición de
  los tipos de los valores devueltos por una función:</p>
</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="kd">let</span> <span class="nv">valorDouble</span> <span class="p">:</span> <span class="nb">Double</span> <span class="p">=</span> <span class="mf">3.0</span>
<span class="kd">let</span> <span class="nv">unaCadena</span><span class="p">:</span> <span class="nb">String</span> <span class="p">=</span> <span class="s">&quot;Hola&quot;</span>

<span class="kd">func</span> <span class="nf">calculaEstadisticas</span><span class="p">(</span><span class="n">valores</span><span class="p">:</span> <span class="nb">Array</span><span class="p">&lt;</span><span class="nb">Int</span><span class="p">&gt;)</span> <span class="p">-&gt;</span> <span class="p">(</span><span class="bp">min</span><span class="p">:</span> <span class="nb">Int</span><span class="p">,</span> <span class="bp">max</span><span class="p">:</span> <span class="nb">Int</span><span class="p">,</span> <span class="n">media</span><span class="p">:</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">{</span>
   <span class="p">...</span>
<span class="p">}</span>
</code></pre></div>
<ul>
<li>En Swift existen dos clases de tipos: <strong>tipos con nombre</strong> y <strong>tipos
  compuestos</strong>.</li>
</ul>
<hr />
<h3>Tipos con nombre</h3>
<ul>
<li>
<p>Un tipo con nombre es un tipo al que se le puede dar un nombre
  determinado cuando se define:</p>
<ul>
<li>nombres de clases</li>
<li>nombres de estructuras</li>
<li>nombres de enumeraciones</li>
<li>nombres de protocolos </li>
</ul>
</li>
<li>
<p>Por ejemplo, instancias de una clase definida por el usuario llamada
<code>MiClase</code> tienen el tipo <code>MiClase</code>. </p>
</li>
<li>
<p>Además de los tipos definidos por el usuario, la biblioteca estándar
de Swift tiene un gran número de tipos predefinidos. A diferencia de
otros lenguajes, estos tipos no son parte del propio lenguaje sino que
se definen en su mayoría como estructuras implementadas en esta
biblioteca estándar. Por ejemplo, arrays, diccionarios o incluso los
tipos más básicos como <code>String</code> o <code>Int</code> están construidos en esa
biblioteca. La implementación de estos elementos está disponible en
abierto en el <a href="https://github.com/apple/swift/tree/master/stdlib/public/core">sitio GitHub de
Swift</a>. </p>
</li>
</ul>
<hr />
<h3>Tipos compuestos</h3>
<ul>
<li>Los tipos compuestos son tipos sin nombre. </li>
<li>En Swift se definen dos: <strong>tuplas</strong> y <strong>tipos función</strong> (ya los
  hemos visto). </li>
</ul>
<p>Ejemplo tuplas:</p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span> <span class="nv">tupla</span><span class="p">:</span> <span class="p">(</span><span class="nb">Int</span><span class="p">,</span> <span class="nb">Int</span><span class="p">,</span> <span class="nb">String</span><span class="p">)</span> <span class="p">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="s">&quot;Hola&quot;</span><span class="p">)</span>
<span class="kd">let</span> <span class="nv">otraTupla</span><span class="p">:</span> <span class="p">(</span><span class="nb">Int</span><span class="p">,</span> <span class="nb">Int</span><span class="p">,</span> <span class="nb">String</span><span class="p">)</span> <span class="p">=</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="s">&quot;Adios&quot;</span><span class="p">)</span>

<span class="kd">func</span> <span class="nf">sumaTupla</span><span class="p">(</span><span class="n">tupla</span> <span class="n">t1</span><span class="p">:</span> <span class="p">(</span><span class="nb">Int</span><span class="p">,</span> <span class="nb">Int</span><span class="p">),</span> <span class="n">con</span> <span class="n">t2</span><span class="p">:</span> <span class="p">(</span><span class="nb">Int</span><span class="p">,</span> <span class="nb">Int</span><span class="p">))</span> <span class="p">-&gt;</span> <span class="p">(</span><span class="nb">Int</span><span class="p">,</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">(</span><span class="n">t1</span><span class="p">.</span><span class="mi">0</span> <span class="o">+</span> <span class="n">t2</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="n">t1</span><span class="p">.</span><span class="mi">1</span> <span class="o">+</span> <span class="n">t2</span><span class="p">.</span><span class="mi">1</span><span class="p">)</span>
<span class="p">}</span>

<span class="bp">print</span><span class="p">(</span><span class="n">sumaTupla</span><span class="p">(</span><span class="n">tupla</span><span class="p">:</span> <span class="p">(</span><span class="n">tupla</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="n">tupla</span><span class="p">.</span><span class="mi">1</span><span class="p">),</span>
                <span class="n">con</span><span class="p">:</span> <span class="p">(</span><span class="n">otraTupla</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="n">otraTupla</span><span class="p">.</span><span class="mi">1</span><span class="p">)))</span>

<span class="c1">// Imprime (7, 11)</span>
</code></pre></div>
<hr />
<h3>Typealias</h3>
<ul>
<li>En Swift se define la palabra clave <code>typealias</code> para darle un nombre
  asignado a cualquier otro tipo. Ambos tipos son iguales a todos los
  efectos (es únicamente azúcar sintáctico).</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="kd">typealias</span> <span class="n">Resultado</span> <span class="p">=</span> <span class="p">(</span><span class="nb">Int</span><span class="p">,</span> <span class="nb">Int</span><span class="p">)</span>

<span class="kd">enum</span> <span class="nc">Quiniela</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">uno</span><span class="p">,</span> <span class="n">equis</span><span class="p">,</span> <span class="n">dos</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">quiniela</span><span class="p">(</span><span class="n">resultado</span><span class="p">:</span> <span class="n">Resultado</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">Quiniela</span> <span class="p">{</span>
  <span class="k">switch</span> <span class="n">resultado</span> <span class="p">{</span>
    <span class="k">case</span> <span class="kd">let</span> <span class="p">(</span><span class="n">goles1</span><span class="p">,</span> <span class="n">goles2</span><span class="p">)</span> <span class="k">where</span> <span class="n">goles1</span> <span class="o">&lt;</span> <span class="n">goles2</span><span class="p">:</span>
      <span class="k">return</span> <span class="p">.</span><span class="n">dos</span>
    <span class="k">case</span> <span class="kd">let</span> <span class="p">(</span><span class="n">goles1</span><span class="p">,</span> <span class="n">goles2</span><span class="p">)</span> <span class="k">where</span> <span class="n">goles1</span> <span class="o">&gt;</span> <span class="n">goles2</span><span class="p">:</span>
      <span class="k">return</span> <span class="p">.</span><span class="n">uno</span>
    <span class="k">default</span><span class="p">:</span>
      <span class="k">return</span> <span class="p">.</span><span class="n">equis</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="bp">print</span><span class="p">(</span><span class="n">quiniela</span><span class="p">(</span><span class="n">resultado</span><span class="p">:</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)))</span>
<span class="c1">// Imprime Dos</span>
<span class="bp">print</span><span class="p">(</span><span class="n">quiniela</span><span class="p">(</span><span class="n">resultado</span><span class="p">:</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)))</span>
<span class="c1">// Imprime Equis</span>
</code></pre></div>
<ul>
<li>En el ejemplo se usa una sentencia <code>switch</code> que recibe el resultado
del partido. Este resultado es una tupla de dos enteros. En el <code>case
let</code> se instancia los valores de esa tupla en las variables <code>goles1</code> y
<code>goles2</code> y después se define una condición para entrar en el caso. En
el primer caso, que <code>goles1</code> sea menor que <code>goles2</code> y en el segundo
que <code>goles1</code> sea mayor que <code>goles2</code>.</li>
</ul>
<h3>Tipos valor y tipos referencia</h3>
<ul>
<li>
<p>En Swift existen dos tipos de construcciones que forman la base de la
programación orientada a objetos: las estructuras (<em>structs</em>) y las
clases. En el tema siguiente hablaremos sobre ello.</p>
</li>
<li>
<p>En la <a href="https://developer.apple.com/documentation/swift/swift_standard_library">biblioteca estándar de
Swift</a>
la mayor parte de los tipos definidos (como <code>Int</code>, <code>Double</code>, <code>Bool</code>,
<code>String</code>, <code>Array</code>, <code>Dictionary</code>, etc.) son estructuras, no clases.</p>
</li>
<li>
<p>Una de las diferencias más importantes entre estructuras y clases es
su comportamiento en una asignación: las estructuras tienen una
<strong>semántica de copia</strong> (son tipos valor) y las clases tienen una
<strong>semántica de referencia</strong> (son tipos referencia).</p>
</li>
</ul>
<h4>Tipo valor</h4>
<ul>
<li>
<p>Un <em>tipo valor</em> es un tipo que tiene semántica de copia en las
asignaciones y cuando se pasan como parámetro en llamadas a funciones.</p>
</li>
<li>
<p>Los tipos valor son muy útiles porque evitan los efectos laterales
en los programas y simplifican el comportamiento del compilador en la
gestión de memoria. </p>
</li>
<li>
<p>Veamos ahora algunos ejemplos de copia por valor en estructuras. Por
  ejemplo, si asignamos una cadena a otra, se realiza una copia:</p>
</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="kd">var</span> <span class="nv">str1</span> <span class="p">=</span> <span class="s">&quot;Hola&quot;</span>
<span class="kd">var</span> <span class="nv">str2</span> <span class="p">=</span> <span class="n">str1</span>
<span class="n">str1</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="s">&quot;Adios&quot;</span><span class="p">)</span>
<span class="bp">print</span><span class="p">(</span><span class="n">str1</span><span class="p">)</span> <span class="c1">// Imprime &quot;HolaAdios&quot;</span>
<span class="bp">print</span><span class="p">(</span><span class="n">str2</span><span class="p">)</span> <span class="c1">// Imprime &quot;Hola&quot;</span>
</code></pre></div>
<ul>
<li>Los arrays también son estructuras y, por tanto, también tienen
  semántica de copia:</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="kd">var</span> <span class="nv">array1</span> <span class="p">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="kd">var</span> <span class="nv">array2</span> <span class="p">=</span> <span class="n">array1</span>
<span class="n">array1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">=</span> <span class="mi">10</span>
<span class="bp">print</span><span class="p">(</span><span class="n">array1</span><span class="p">)</span> <span class="c1">// [10, 2, 3, 4]</span>
<span class="bp">print</span><span class="p">(</span><span class="n">array2</span><span class="p">)</span> <span class="c1">// [1, 2, 3, 4]</span>
</code></pre></div>
<ul>
<li>A diferencia de otros lenguajes como Java, los parámetros de una
función siempre son inmutables y se pasan por copia, para reforzar el
carácter funcional de las funciones. Por ejemplo, es incorrecto
escribir lo siguiente:</li>
</ul>
<div class="highlight"><pre><span></span><code>func ponCero(array: [Int], pos: Int) {
    array[pos] = 0
// error: cannot assign through subscript: &#39;array&#39; is a &#39;let&#39; constant
}
</code></pre></div>
<ul>
<li>Se podría pensar que es muy costoso copiar un array entero, pero no
es así. El compilador de Swift optimiza estas sentencias y sólo
realiza la copia en el momento en que hay una modificación de una de
las variables que comparten el array. Es lo que se llama <em>copy on
write</em>.</li>
</ul>
<h4>Tipo referencia</h4>
<ul>
<li>
<p>Frente a un tipo valor, un tipo de referencia es aquel en los que
los valores se asignan a variables con una semántica de
referencia. </p>
</li>
<li>
<p>Cuando se realizan varias asignaciones de una misma
instancia a distintas variables todas ellas guardan una referencia a
la misma instancia. Si la instancia se modifica, todas las variables
reflejarán el nuevo valor. </p>
</li>
<li>
<p>Cuando veamos las clases en el próximo tema veremos algunos
ejemplos.</p>
</li>
</ul>
<hr />
<h3>7. Enumeraciones</h3>
<hr />
<ul>
<li>Las enumeraciones definen un tipo con un valor restringido de
  posibles valores:</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="kd">enum</span> <span class="nc">Direccion</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">norte</span>
    <span class="k">case</span> <span class="n">sur</span>
    <span class="k">case</span> <span class="n">este</span>
    <span class="k">case</span> <span class="n">oeste</span>
<span class="p">}</span>
</code></pre></div>
<p>Ejemplo de uso:</p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span> <span class="nv">hemosGirado</span> <span class="p">=</span> <span class="kc">true</span>
<span class="kd">var</span> <span class="nv">direccionActual</span> <span class="p">=</span> <span class="n">Direccion</span><span class="p">.</span><span class="n">norte</span>
<span class="k">if</span> <span class="n">hemosGirado</span> <span class="p">{</span>
   <span class="n">direccionActual</span> <span class="p">=</span> <span class="p">.</span><span class="n">sur</span>
<span class="p">}</span>
</code></pre></div>
<p>En sentencias switch:</p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span> <span class="nv">direccionAIr</span> <span class="p">=</span> <span class="n">Direccion</span><span class="p">.</span><span class="n">sur</span>
<span class="k">switch</span> <span class="n">direccionAIr</span> <span class="p">{</span>
<span class="k">case</span> <span class="p">.</span><span class="n">norte</span><span class="p">:</span>
   <span class="bp">print</span><span class="p">(</span><span class="s">&quot;Nos vamos al norte&quot;</span><span class="p">)</span>
<span class="k">case</span> <span class="p">.</span><span class="n">sur</span><span class="p">:</span>
   <span class="bp">print</span><span class="p">(</span><span class="s">&quot;Cuidado con los pinguinos&quot;</span><span class="p">)</span>
<span class="k">case</span> <span class="p">.</span><span class="n">este</span><span class="p">:</span>
    <span class="bp">print</span><span class="p">(</span><span class="s">&quot;Donde nace el sol&quot;</span><span class="p">)</span>
<span class="k">case</span> <span class="p">.</span><span class="n">oeste</span><span class="p">:</span>
    <span class="bp">print</span><span class="p">(</span><span class="s">&quot;Donde el cielo es azul&quot;</span><span class="p">)</span>
<span class="p">}</span>
<span class="c1">// Imprime &quot;Cuidado con los pinguinos&quot;</span>
</code></pre></div>
<p>Otro ejemplo:</p>
<div class="highlight"><pre><span></span><code><span class="kd">enum</span> <span class="nc">Planeta</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">mercurio</span><span class="p">,</span> <span class="n">venus</span><span class="p">,</span> <span class="n">tierra</span><span class="p">,</span> <span class="n">marte</span><span class="p">,</span> <span class="n">jupiter</span><span class="p">,</span> <span class="n">saturno</span><span class="p">,</span> <span class="n">urano</span><span class="p">,</span> <span class="n">neptuno</span>
<span class="p">}</span>
</code></pre></div>
<h3>Valores brutos de enumeraciones</h3>
<ul>
<li>Es posible asignar a las constantes del enumerado un valor concreto de
un tipo subyacente, por ejemplo enteros:</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="kd">enum</span> <span class="nc">Quiniela</span><span class="p">:</span> <span class="nb">Int</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">uno</span><span class="p">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">equis</span><span class="p">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">dos</span><span class="p">=</span><span class="mi">2</span>
<span class="p">}</span>
</code></pre></div>
<ul>
<li>Se puede obtener el valor bruto a partir del propio tipo o de una
variable del tipo, usando <code>rawValue</code>:</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="c1">// Obtenemos el valor bruto a partir del tipo</span>
<span class="kd">let</span> <span class="nv">valorEquis</span><span class="p">:</span> <span class="nb">Int</span> <span class="p">=</span> <span class="n">Quiniela</span><span class="p">.</span><span class="n">equis</span><span class="p">.</span><span class="n">rawValue</span>

<span class="c1">// Obtenemos el valor bruto a partir de una variable</span>
<span class="kd">let</span> <span class="nv">res</span> <span class="p">=</span> <span class="n">Quiniela</span><span class="p">.</span><span class="n">equis</span>
<span class="kd">let</span> <span class="nv">valorEquis</span> <span class="p">=</span> <span class="n">res</span><span class="p">.</span><span class="n">rawValue</span>
</code></pre></div>
<ul>
<li>También se puede asignar los valores de forma implícita, dando un
valor a la primera constante. Las siguientes tienen el valor consecutivo:</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="kd">enum</span> <span class="nc">Planeta</span><span class="p">:</span> <span class="nb">Int</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">mercurio</span><span class="p">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">venus</span><span class="p">,</span> <span class="n">tierra</span><span class="p">,</span> <span class="n">marte</span><span class="p">,</span> <span class="n">jupiter</span><span class="p">,</span> <span class="n">saturno</span><span class="p">,</span> <span class="n">urano</span><span class="p">,</span> <span class="n">neptuno</span>
<span class="p">}</span>
<span class="kd">let</span> <span class="nv">posicionTierra</span> <span class="p">=</span> <span class="n">Planeta</span><span class="p">.</span><span class="n">tierra</span><span class="p">.</span><span class="n">rawValue</span>
<span class="c1">// posicionTierra es 3</span>
</code></pre></div>
<ul>
<li>Podemos escoger cualquier tipo subyacente. Por ejemplo el tipo <code>Character</code>:</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="kd">enum</span> <span class="nc">CaracterControlASCII</span><span class="p">:</span> <span class="nb">Character</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">tab</span> <span class="p">=</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">&quot;</span>
    <span class="k">case</span> <span class="n">lineFeed</span> <span class="p">=</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span>
    <span class="k">case</span> <span class="n">carriageReturn</span> <span class="p">=</span> <span class="s">&quot;</span><span class="se">\r</span><span class="s">&quot;</span>
<span class="p">}</span>
</code></pre></div>
<ul>
<li>Y por último, se puede definir como tipo subyacente <code>String</code> y los
valores brutos de las constantes serán sus nombres convertidos a
cadenas:</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="kd">enum</span> <span class="nc">Direccion</span><span class="p">:</span> <span class="nb">String</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">norte</span><span class="p">,</span> <span class="n">sur</span><span class="p">,</span> <span class="n">este</span><span class="p">,</span> <span class="n">oeste</span>
<span class="p">}</span>
<span class="kd">let</span> <span class="nv">direccionAtardecer</span> <span class="p">=</span> <span class="n">Direccion</span><span class="p">.</span><span class="n">oeste</span><span class="p">.</span><span class="n">rawValue</span>
<span class="c1">// direccionAtardecer es &quot;oeste&quot;</span>
</code></pre></div>
<ul>
<li>En este caso, también se puede inicializar el valor bruto con una
  asignación explícita y no usar el propio nombre:</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="kd">enum</span> <span class="nc">Direccion</span><span class="p">:</span> <span class="nb">String</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">norte</span> <span class="p">=</span> <span class="s">&quot;north&quot;</span>
    <span class="k">case</span> <span class="n">sur</span> <span class="p">=</span> <span class="s">&quot;south&quot;</span>
    <span class="k">case</span> <span class="n">este</span> <span class="p">=</span> <span class="s">&quot;east&quot;</span>
    <span class="k">case</span> <span class="n">oeste</span> <span class="p">=</span> <span class="s">&quot;west&quot;</span>
<span class="p">}</span>
<span class="kd">let</span> <span class="nv">direccionAtardecer</span> <span class="p">=</span> <span class="n">Direccion</span><span class="p">.</span><span class="n">oeste</span><span class="p">.</span><span class="n">rawValue</span>
<span class="c1">// direccionAtardecer es &quot;west&quot;</span>
</code></pre></div>
<ul>
<li>Cuando se definen valores brutos es posible inicializar el enumerado
de una forma similar a una estructura o una clase pasando el valor
bruto. Devuelve el valor enumerado correspondiente o <code>nil</code> (un
opcional, lo veremos más adelante):</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="kd">let</span> <span class="nv">posiblePlaneta</span> <span class="p">=</span> <span class="n">Planeta</span><span class="p">(</span><span class="n">rawValue</span><span class="p">:</span> <span class="mi">7</span><span class="p">)</span>
<span class="c1">// posiblePlaneta es de tipo Planeta? y es igual a Planeta.urano</span>
</code></pre></div>
<hr />
<h2>8. Enumeraciones instanciables</h2>
<ul>
<li>Una característica singular de las enumeraciones en Swift es que
permiten definir valores variables asociados a cada caso de la
enumeración, creando algo muy parecido a una instancia de la
enumeración.</li>
</ul>
<h3>Valores asociados a instancias de enumeraciones</h3>
<ul>
<li>
<p>Un enumerado instanciable permite asociar valores a
  la instancia del enumerado. Para crear una instancia del
  enumerado debemos proporcionar el valor asociado.</p>
</li>
<li>
<p>Al igual que un enumerado normal, el enumerado puede especificar
  distintos casos. Cada caso puede determinar un tipo de valor asociado.</p>
</li>
<li>
<p>En otros lenguajes de programación se llaman <em>uniones etiquetadas</em> o
<em>variantes</em>.</p>
</li>
<li>
<p>Por ejemplo, podemos definir un enumerado que permita guardar un
<code>Int</code> o un <code>String</code>:</p>
</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="kd">enum</span> <span class="nc">Multiple</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">num</span><span class="p">(</span><span class="nb">Int</span><span class="p">)</span>
    <span class="k">case</span> <span class="n">str</span><span class="p">(</span><span class="nb">String</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>
<ul>
<li>De esta forma, podemos crear valores de tipo <code>Multiple</code> que
contienen un valor asociado <code>Int</code> (instanciando el caso <code>num</code>) o un
<code>String</code> (instanciando el caso <code>str</code>):</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="kd">let</span> <span class="nv">valor3</span> <span class="p">=</span> <span class="n">Multiple</span><span class="p">.</span><span class="n">num</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="kd">let</span> <span class="nv">valor4</span> <span class="p">=</span> <span class="n">Multiple</span><span class="p">.</span><span class="n">str</span><span class="p">(</span><span class="s">&quot;Hola&quot;</span><span class="p">)</span>
</code></pre></div>
<ul>
<li>
<p>Es necesario definir un valor concreto asociado al crear el enumerado.</p>
</li>
<li>
<p>Para obtener el valor asociado debemos usar una expresión <code>case let</code>
en una sentencia <code>switch</code> con una variable a la que se asigna el
valor. Por ejemplo, la siguiente función reciba instancias de tipo
<code>Multiple</code> e imprime el valor asociado al enumerado que se pasa como parámetro.</p>
</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="kd">func</span> <span class="nf">imprime</span><span class="p">(</span><span class="n">multiple</span><span class="p">:</span> <span class="n">Multiple</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">switch</span> <span class="n">multiple</span> <span class="p">{</span>
    <span class="k">case</span> <span class="kd">let</span> <span class="p">.</span><span class="n">num</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="bp">print</span><span class="p">(</span><span class="s">&quot;Multiple tiene un Int: </span><span class="si">\(</span><span class="n">x</span><span class="si">)</span><span class="s">&quot;</span><span class="p">)</span>
    <span class="k">case</span> <span class="kd">let</span> <span class="p">.</span><span class="n">str</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
        <span class="bp">print</span><span class="p">(</span><span class="s">&quot;Multiple tiene un String: </span><span class="si">\(</span><span class="n">s</span><span class="si">)</span><span class="s">&quot;</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="n">imprime</span><span class="p">(</span><span class="n">multiple</span><span class="p">:</span> <span class="n">valor3</span><span class="p">)</span>
<span class="c1">// Imprime &quot;Multiple tiene un Int: 10&quot;</span>
<span class="n">imprime</span><span class="p">(</span><span class="n">multiple</span><span class="p">:</span> <span class="n">valor4</span><span class="p">)</span>
<span class="c1">// Imprime &quot;Multiple tiene un String: Hola</span>
</code></pre></div>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>No hay que confundir un valor asociado a un caso y un valor bruto:
el valor bruto de un caso de enumeración es el mismo para todas las
instancias, mientras que el valor asociado es distinto y se
proporciona cuando se define el valor concreto de la enumeración.</p>
</div>
<ul>
<li>El valor asociado puede ser una tupla:</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="kd">enum</span> <span class="nc">CodigoBarras</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">upc</span><span class="p">(</span><span class="nb">Int</span><span class="p">,</span> <span class="nb">Int</span><span class="p">,</span> <span class="nb">Int</span><span class="p">,</span> <span class="nb">Int</span><span class="p">)</span>
    <span class="k">case</span> <span class="n">qrCode</span><span class="p">(</span><span class="nb">String</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>
<hr />
<h3>Enumeraciones recursivas</h3>
<ul>
<li>Es posible combinar las características de las enumeraciones con
valor con la recursión para crear enumeraciones recursivas. Hay que
preceder la palabra clave <code>enum</code> con <code>indirect</code>:</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="kr">indirect</span> <span class="kd">enum</span> <span class="nc">ExpresionAritmetica</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">numero</span><span class="p">(</span><span class="nb">Int</span><span class="p">)</span>
    <span class="k">case</span> <span class="n">suma</span><span class="p">(</span><span class="n">ExpresionAritmetica</span><span class="p">,</span> <span class="n">ExpresionAritmetica</span><span class="p">)</span>
    <span class="k">case</span> <span class="n">multiplicacion</span><span class="p">(</span><span class="n">ExpresionAritmetica</span><span class="p">,</span> <span class="n">ExpresionAritmetica</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nv">cinco</span> <span class="p">=</span> <span class="n">ExpresionAritmetica</span><span class="p">.</span><span class="n">numero</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="kd">let</span> <span class="nv">cuatro</span> <span class="p">=</span> <span class="n">ExpresionAritmetica</span><span class="p">.</span><span class="n">numero</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="kd">let</span> <span class="nv">suma</span> <span class="p">=</span> <span class="n">ExpresionAritmetica</span><span class="p">.</span><span class="n">suma</span><span class="p">(</span><span class="n">cinco</span><span class="p">,</span> <span class="n">cuatro</span><span class="p">)</span>
<span class="kd">let</span> <span class="nv">producto</span> <span class="p">=</span> <span class="n">ExpresionAritmetica</span><span class="p">.</span><span class="n">multiplicacion</span><span class="p">(</span><span class="n">suma</span><span class="p">,</span> <span class="n">ExpresionAritmetica</span><span class="p">.</span><span class="n">numero</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
</code></pre></div>
<ul>
<li>Es muy cómodo manejar enumeraciones recursivas de forma recursiva:</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="kd">func</span> <span class="nf">evalua</span><span class="p">(</span><span class="n">expresion</span><span class="p">:</span> <span class="n">ExpresionAritmetica</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Int</span> <span class="p">{</span>
    <span class="k">switch</span> <span class="n">expresion</span> <span class="p">{</span>
    <span class="k">case</span> <span class="kd">let</span> <span class="p">.</span><span class="n">numero</span><span class="p">(</span><span class="n">valor</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">valor</span>
    <span class="k">case</span> <span class="kd">let</span> <span class="p">.</span><span class="n">suma</span><span class="p">(</span><span class="n">izquierda</span><span class="p">,</span> <span class="n">derecha</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">evalua</span><span class="p">(</span><span class="n">expresion</span><span class="p">:</span> <span class="n">izquierda</span><span class="p">)</span> <span class="o">+</span> <span class="n">evalua</span><span class="p">(</span><span class="n">expresion</span><span class="p">:</span> <span class="n">derecha</span><span class="p">)</span>
    <span class="k">case</span> <span class="kd">let</span> <span class="p">.</span><span class="n">multiplicacion</span><span class="p">(</span><span class="n">izquierda</span><span class="p">,</span> <span class="n">derecha</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">evalua</span><span class="p">(</span><span class="n">expresion</span><span class="p">:</span> <span class="n">izquierda</span><span class="p">)</span> <span class="o">*</span> <span class="n">evalua</span><span class="p">(</span><span class="n">expresion</span><span class="p">:</span> <span class="n">derecha</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="bp">print</span><span class="p">(</span><span class="n">evalua</span><span class="p">(</span><span class="n">expresion</span><span class="p">:</span> <span class="n">producto</span><span class="p">))</span>
<span class="c1">// Imprime 18</span>
</code></pre></div>
<ul>
<li>Otro ejemplo de enums recursivos, para definir un tipo de datos
<code>Lista</code> similar al que vimos en Scheme. La lista puede ser una lista
vacía o puede contener dos elementos: un valor <code>Int</code> y otra lista:</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="kr">indirect</span> <span class="kd">enum</span> <span class="nc">Lista</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">vacia</span>
    <span class="k">case</span> <span class="n">nodo</span><span class="p">(</span><span class="nb">Int</span><span class="p">,</span> <span class="n">Lista</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>
<ul>
<li>
<p>Para crear una lista de tipo <code>nodo</code> deberemos dar un valor entero (el
valor de la cabeza de la lista) y otra lista (el resto de la
lista). También podemos crear una lista vacía.</p>
</li>
<li>
<p>Por ejemplo, podemos crear la lista <code>(10, 20, 30)</code> de la siguiente
manera:</p>
</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="kd">let</span> <span class="nv">lista1</span> <span class="p">=</span> <span class="n">Lista</span><span class="p">.</span><span class="n">nodo</span><span class="p">(</span><span class="mi">30</span><span class="p">,</span> <span class="n">Lista</span><span class="p">.</span><span class="n">vacia</span><span class="p">)</span>
<span class="kd">let</span> <span class="nv">lista2</span> <span class="p">=</span> <span class="n">Lista</span><span class="p">.</span><span class="n">nodo</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="n">lista1</span><span class="p">)</span>
<span class="kd">let</span> <span class="nv">lista3</span> <span class="p">=</span> <span class="n">Lista</span><span class="p">.</span><span class="n">nodo</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">lista2</span><span class="p">)</span>
</code></pre></div>
<ul>
<li>Podríamos crear esta misma lista de una forma más abreviada:</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="kd">let</span> <span class="nv">lista</span><span class="p">:</span> <span class="n">Lista</span> <span class="p">=</span> <span class="p">.</span><span class="n">nodo</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="p">.</span><span class="n">nodo</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="p">.</span><span class="n">nodo</span><span class="p">(</span><span class="mi">30</span><span class="p">,</span> <span class="p">.</span><span class="n">vacia</span><span class="p">)))</span>
</code></pre></div>
<ul>
<li>Una vez definido el tipo enumerado, podemos definir funciones que
trabajen con él. La siguiente función, por ejemplo, es una función
recursiva que recibe una lista y devuelve la suma de sus
elementos. Funciona de una forma muy similar a la definición que
hicimos en Scheme:</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="kd">func</span> <span class="nf">suma</span><span class="p">(</span><span class="n">lista</span><span class="p">:</span> <span class="n">Lista</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Int</span> <span class="p">{</span>
    <span class="k">switch</span> <span class="n">lista</span> <span class="p">{</span>
    <span class="k">case</span>  <span class="p">.</span><span class="n">vacia</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>
    <span class="k">case</span> <span class="kd">let</span> <span class="p">.</span><span class="n">nodo</span><span class="p">(</span><span class="bp">first</span><span class="p">,</span> <span class="n">rest</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">first</span> <span class="o">+</span> <span class="n">suma</span><span class="p">(</span><span class="n">lista</span><span class="p">:</span> <span class="n">rest</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nv">z</span><span class="p">:</span> <span class="n">Lista</span> <span class="p">=</span> <span class="p">.</span><span class="n">nodo</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="p">.</span><span class="n">nodo</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="p">.</span><span class="n">vacia</span><span class="p">))</span>

<span class="bp">print</span><span class="p">(</span><span class="n">suma</span><span class="p">(</span><span class="n">lista</span><span class="p">:</span> <span class="n">z</span><span class="p">))</span>
<span class="c1">// Imprime 30</span>
</code></pre></div>
<ul>
<li>Podemos también definir una función recursiva <code>construye(lista:[Int])</code>
que devuelve una lista a partir de una array de enteros:</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="kd">func</span> <span class="nf">construye</span><span class="p">(</span><span class="n">lista</span><span class="p">:</span> <span class="p">[</span><span class="nb">Int</span><span class="p">])</span> <span class="p">-&gt;</span> <span class="n">Lista</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">lista</span><span class="p">.</span><span class="bp">isEmpty</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">Lista</span><span class="p">.</span><span class="n">vacia</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="kd">let</span> <span class="nv">primero</span> <span class="p">=</span> <span class="n">lista</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="kd">let</span> <span class="nv">resto</span> <span class="p">=</span> <span class="nb">Array</span><span class="p">(</span><span class="n">lista</span><span class="p">.</span><span class="bp">dropFirst</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">Lista</span><span class="p">.</span><span class="n">nodo</span><span class="p">(</span><span class="n">primero</span><span class="p">,</span> <span class="n">construye</span><span class="p">(</span><span class="n">lista</span><span class="p">:</span> <span class="n">resto</span><span class="p">))</span>
    <span class="p">}</span> 
<span class="p">}</span>

<span class="kd">let</span> <span class="nv">lista2</span> <span class="p">=</span> <span class="n">construye</span><span class="p">(</span><span class="n">lista</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">])</span>

<span class="bp">print</span><span class="p">(</span><span class="n">suma</span><span class="p">(</span><span class="n">lista</span><span class="p">:</span> <span class="n">lista2</span><span class="p">))</span>
<span class="c1">// Imprime 15</span>
</code></pre></div></body>

</html>
